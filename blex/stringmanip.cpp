#include <blex/blexlib.h>
#include "unicode.h"

namespace Blex
{

namespace Detail
{

//Yes, extern: otherwise it has internal linkage..

extern const uint8_t Base64EncoderConversionMap[65]={"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"};
extern const uint8_t UFSEncoderConversionMap[65]={"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"};

extern const uint8_t Base64DecoderConversionMap[256]=
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //00-0f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //10-1f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,  62,0xff,0xff,0xff,  63,      //20-2f
    52,  53,  54,  55,  56,  57,  58,  59,  60,  61,0xff,0xff,0xff,0xff,0xff,0xff,      //30-3f
  0xff,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,      //40-4f
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,0xff,0xff,0xff,0xff,0xff,      //50-5f
  0xff,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,      //60-6f
    41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,0xff,0xff,0xff,0xff,0xff,      //70-7f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //80-8f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //90-9f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //a0-af
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //b0-bf
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //c0-cf
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //d0-df
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //e0-ef
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};     //f0-ff

extern const uint8_t UFSDecoderConversionMap[256]=
//   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F
{ 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //00-0f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //10-1f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,  62,0xff,0xff,      //20-2f
    52,  53,  54,  55,  56,  57,  58,  59,  60,  61,0xff,0xff,0xff,0xff,0xff,0xff,      //30-3f
  0xff,   0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,      //40-4f
    15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,0xff,0xff,0xff,0xff,  63,      //50-5f
  0xff,  26,  27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,      //60-6f
    41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,0xff,0xff,0xff,0xff,0xff,      //70-7f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //80-8f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //90-9f
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //a0-af
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //b0-bf
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //c0-cf
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //d0-df
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,      //e0-ef
  0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};     //f0-ff

} // End of namespace Detail

void CreateEntity(uint32_t entityval, std::string *entity)
{
        entity->clear();
        UTF8Encoder<std::back_insert_iterator<std::string> > encoder(std::back_inserter(*entity));
        encoder(entityval);
}

int LevenshteinDistance(std::string const &source, std::string const &target)
{
        // Step 1
        const int n = source.length();
        const int m = target.length();
        if (n == 0)
            return m;
        if (m == 0)
            return n;

        // Good form to declare a TYPEDEF
        typedef std::vector< std::vector<int> > Tmatrix;
        Tmatrix matrix(n+1, std::vector<int>(m+1) );

        // Step 2
        for (int i = 0; i <= n; i++)
            matrix[i][0]=i;

        for (int j = 0; j <= m; j++)
            matrix[0][j]=j;

        // Step 3
        for (int i = 1; i <= n; i++)
        {
                const char s_i = source[i-1];

                // Step 4
                for (int j = 1; j <= m; j++)
                {
                        const char t_j = target[j-1];

                        // Step 5
                        int cost = s_i==t_j ? 0 : 1;

                        // Step 6
                        const int above = matrix[i-1][j];
                        const int left = matrix[i][j-1];
                        const int diag = matrix[i-1][j-1];
                        int cell = std::min( above + 1, std::min(left + 1, diag + cost));

                        // Step 6A: Cover transposition, in addition to deletion,
                        // insertion and substitution. This step is taken from:
                        // Berghel, Hal ; Roach, David : "An Extension of Ukkonen's
                        // Enhanced Dynamic Programming ASM Algorithm"
                        // (http://www.acm.org/~hlb/publications/asm/asm.html)
                        if (i>2 && j>2)
                        {
                                int trans=matrix[i-2][j-2]+1;
                                if (source[i-2]!=t_j) trans++;
                                if (s_i!=target[j-2]) trans++;
                                if (cell>trans) cell=trans;
                        }
                        matrix[i][j]=cell;
                }
        }

        // Step 7
        return matrix[n][m];
}

} //end of namespace Blex
