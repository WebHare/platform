#!/bin/bash
source ${BASH_SOURCE%/*}/../lib/wh-functions.sh

REQUIRENPMVERSION="7.13.0"
DEBUGSTARTUP=""

export PGUSER="root" #postgres user, must be locked for compatibility between dev and prod

if [ "$WEBHARE_PLATFORM" == "darwin" ]; then #macoS
  export HOMEBREW_NO_AUTO_UPDATE=1 # We don't want to responsible for brew/trigger updates.
fi


if [[ $WEBHARE_DEBUG =~ ((^|[,])startup([,]|$))+ ]] ; then
  DEBUGSTARTUP=1
fi

while [[ $1 =~ ^-.* ]]; do
  if [ "$1" == "-v" -o "$1" == "--verbose" ]; then
    export WH_VERBOSE=1
    shift
  elif [ "$1" == "-f" -o "$1" == "--force" ]; then
    FORCE=1
    shift
  elif [ "$1" == "-i" -o "$1" == "--ignore-running" ]; then
    export WEBHARE_IGNORE_RUNNING=1
    shift
  else
    die "Illegal option $1"
  fi
done

INSTR="${1:-help}"
shift
OPTIONS=("$@")

# Print ASAP to give accurate measurements
[ "$INSTR" == "console" ] && [ -n "$DEBUGSTARTUP" ] && logWithTime "Preparing for console"

# We must have $WEBHARE_DIR, pointing to the 'whtree'.
if [ -z "$WEBHARE_DIR" ]; then
  if [ -n "$WEBHARE_CHECKEDOUT_TO" ]; then
    export WEBHARE_DIR="${WEBHARE_CHECKEDOUT_TO%/}/whtree"
  else
    export WEBHARE_DIR=`cd ${BASH_SOURCE%/*}/..; pwd`
  fi

  [ "$WH_VERBOSE" == "1" ] && echo "WebHare installation dir: $WEBHARE_DIR"
fi

# Ensure 'wh' runs this wh so we don't accidentally rely on external PATHs/functions/aliasses - lock it to WEBHARE_DIR
wh() { "${BASH_SOURCE%/*}/../bin/wh" "$@"; }
export -f wh

# Try to set WEBHARE_CHECKEDOUT_TO from WEBHARE_DIR where possible
if [ -z "$WEBHARE_CHECKEDOUT_TO" ]; then
  if [ -f "$WEBHARE_DIR/../builder/base_makefile" ]; then
    export WEBHARE_CHECKEDOUT_TO="`cd ${WEBHARE_DIR}/..; pwd`"
  fi
fi

# If we haven't found WEBHARE_DATAROOT that way, discover it
if [ -z "$WEBHARE_DATAROOT" ] ; then
  WEBHARE_DATAROOT="$WEBHARE_DIR/whdata"
  INFERRED_DATAROOT=1
elif [ "${WEBHARE_DATAROOT:0:1}" != "/" ]; then
  echo "WEBHARE_DATAROOT must be an absolute path" >&2
  exit 1
elif [ "${WEBHARE_DATAROOT: -1}" != "/" ]; then #ensure it ends with a slash
  WEBHARE_DATAROOT="${WEBHARE_DATAROOT}/"
fi

if [ -f "${WEBHARE_DATAROOT}dbase/translog.whdb" ]; then
  echo "The dbserver is no longer suppported by WebHare 5.0 and up. Downgrade and convert first!"
  exit 1
fi

# Oracle's instantclient requires additional libraries we can't ship with WebHare or through npm so we offer an option
# to place additional libraries in $WEBHARE_DATAROOT/lib/
if [ -z "$INFERRED_DATAROOT" ]; then
  if [ "$WEBHARE_PLATFORM" = "darwin" ]; then
    if ! [[ $DYLD_LIBRARY_PATH == ${WEBHARE_DATAROOT}lib* ]]; then #If not prepended yet..
      # Note that SIP on Darwin may interfere with this setting (see eg https://developer.apple.com/forums/thread/703757)
      export DYLD_LIBRARY_PATH="${WEBHARE_DATAROOT}lib:$DYLD_LIBRARY_PATH"
    fi
  else
    if ! [[ $LD_LIBRARY_PATH == ${WEBHARE_DATAROOT}lib* ]]; then #If not prepended yet..
      export LD_LIBRARY_PATH="${WEBHARE_DATAROOT}lib:$LD_LIBRARY_PATH"
     fi
  fi
fi

export WEBHARE_DBASENAME="webhare" # embedded database is always named WH

# If you haven't set WEBHARE_BASEPORT, assume it to be 13679
if [ -z "$WEBHARE_BASEPORT" ]; then
  WEBHARE_BASEPORT=13679
fi

# If you haven't set WEBHARE_TEMP, assume it to be $WEBHARE_DATAROOT/tmp
if [ -z "$WEBHARE_TEMP" ]; then
  WEBHARE_TEMP="$WEBHARE_DATAROOT/tmp"
fi

[ "$WH_VERBOSE" == "1" ] && echo "WebHare data directory:   $WEBHARE_DATAROOT"
[ "$WH_VERBOSE" == "1" ] && echo "WebHare base port number: $WEBHARE_BASEPORT"

export WEBHARE_CHECKEDOUT_TO
export WEBHARE_BUILDDIR
export WEBHARE_DIR
export WEBHARE_BASEPORT
export WEBHARE_DATAROOT
export WHBUILD_DOWNLOADCACHE
export WEBHARE_TEMP
export WHBUILD_BUILDROOT

# Ensures npm stable ordering - https://github.com/npm/npm/issues/17048
# Minimum debian/ubuntu install ships only with C.UTF-8, not en_US.UTF-8
export LANG="C"
export LC_ALL="C"

if [ ! -d "$WEBHARE_DIR" ]; then
  die "Cannot find WebHare installation"
fi

deprecation_sleep()
{
  for P in 1 2 3 4 5 ; do
    echo -n "."
    sleep 1
  done
  echo ""
}

exec_whcompile()
{
  getwhparameters
  exec $WEBHARE_DIR/bin/whcompile "$@"
}

wh()
{
  $WEBHARE_DIR/bin/wh "$@"
}

exec_wh()
{
  $WEBHARE_DIR/bin/wh "$@"
}

check_webhare_running()
{
  if [ "$WEBHARE_IGNORE_RUNNING" == "1" ]; then
    return
  fi

  if ! is_webhare_running ; then
    die "WebHare does not seem to be running"
  fi
}

check_webhare_not_running()
{
  if [ "$WEBHARE_IGNORE_RUNNING" == "1" ]; then
    return
  fi

  if is_webhare_running ; then
    die "WebHare is already running"
  fi
}

setup_webhare_envsettings()
{
  export WEBHARE_VERSION=$( source $WEBHARE_DIR/modules/system/whres/buildinfo ; echo -n "$version" )
  WEBHARE_DISPLAYBUILDINFO="$( source $WEBHARE_DIR/modules/system/whres/buildinfo ; echo -n "branch $branch, commit ${committag:0:10}")"

  ORIGIN=$( source $WEBHARE_DIR/modules/system/whres/buildinfo ; echo -n "$origin" )
  if [ -n "$ORIGIN" ]; then
    WEBHARE_DISPLAYBUILDINFO="$WEBHARE_DISPLAYBUILDINFO, source build, origin $ORIGIN"
  fi
  export WEBHARE_DISPLAYBUILDINFO

  # Export all WEBHARE_ vars to .webhare-envsettings.sh for scripts that need to restablish the whole `wh console` environment
  # But don't export WEBHARE_DEBUG= ... as WebHare will cross-process communicate that anyway
  set | grep -E '^WEBHARE_' | grep -v '^WEBHARE_DEBUG=' | sed -e 's/^/export /' > $WEBHARE_DATAROOT/.webhare-envsettings.sh
}

list_commands()
{
  grep -oe "^[a-z]*" ${BASH_SOURCE%/*}/../modules/system/doc/wh.txt

  SCRIPTDIR="$WEBHARE_DIR/modules/system/scripts/whcommands/"
  for SCRIPTPATH in "$WEBHARE_DIR/modules/platform/cli-commands/"*.ts "${SCRIPTDIR}"*.whscr "${SCRIPTDIR}"*.sh "${SCRIPTDIR}"*.ts; do
    if [ -f $SCRIPTPATH ]; then
      FILENAME="${SCRIPTPATH##*/}"
      INSTR="${FILENAME%.*}"
      echo "$INSTR"
    fi
  done

  if [ -x "$WEBHARE_DIR/bin/runscript" ]; then
    loadshellconfig
    for MODULE in $WEBHARE_CFG_MODULES; do
      if [ "$MODULE" != "system" ]; then
        getmoduledir MODULEDIR $MODULE
        SCRIPTDIR="${MODULEDIR}scripts/whcommands/"
        for SCRIPTPATH in "${SCRIPTDIR}"*.whscr "${SCRIPTDIR}"*.sh "${SCRIPTDIR}"*.ts; do
          if [ -f $SCRIPTPATH ]; then
            FILENAME="${SCRIPTPATH##*/}"
            INSTR="$MODULE:${FILENAME%.*}"
            echo "$INSTR"
          fi
        done
      fi
    done
  fi
}

getscripttorun()
{
  VARNAME=$1
  while shift; do
    if [ "$1" == "--whdebug" ]; then
      shift
    elif [ "${1:0:1}" != "-" ]; then
      break;
    fi
  done
  eval $VARNAME=\$1
}

setup_for_console() #setup_for_console is invoked when we're starting a major subprocess (console or exec)
{
  if [ -n "$INFERRED_DATAROOT" ]; then
    echo "WEBHARE_DATAROOT is not set and inferring WEBHARE_DATAROOT has been removed" 2>&1
    echo "Make sure WEBHARE_DATAROOT is set and exported or use 'runkit' to manage your WebHare intallation(s)" 2>&1
    exit 1
  fi

  # Ensure @mod- symlinks are in place.
  "$WEBHARE_DIR/modules/platform/scripts/bootstrap/prepare-whdata.sh" --force || die "Unable to ensure symlinks/scripts are in place"
  export __WEBHARE_WHDATA_PREPARED=1

  # WH 5.0 - move the unified cache (image cache) into the right place. To avoid races we *have* to do this before we start WebHare - it should normally be done in a sec...
  if [ -d "$WEBHARE_DATAROOT"/ephemeral/system.uc2 ]; then
    # If a conflicting dir exists, you upgraded WebHare while it was running. Removing it, images will get recreated
    rm -rf -- "$WEBHARE_DATAROOT"/storage/system/output/uc >/dev/null 2>&1
    mkdir -p -- "$WEBHARE_DATAROOT"/storage/system/output
    if ! mv "$WEBHARE_DATAROOT"/ephemeral/system.uc2 "$WEBHARE_DATAROOT"/storage/system/output/uc ; then
      # If this failed.. cross disk partition? we'll delete it in the background and have it regenerated.
      rm -rf -- "$WEBHARE_DATAROOT"/ephemeral/system.uc2 > /dev/null 2>&1 &
    fi
  fi
}

# Do we need to prepare whdata? Anything that does setup_for_console or things like make and finalize don't need it
if [[ ! "$INSTR" =~ ^(console|mic|umic|exec|execbuilt|shell|make|finalize-webhare|prepare-whdata|fixbuild|builddocker|testdocker|deploydocker)$ ]]; then
  if [ -z "$__WEBHARE_WHDATA_PREPARED" ]; then
    if [ ! -f "$WEBHARE_DIR/jssdk/ts-esbuild-runner/dist/resolveplugin.js" ]; then #this may trigger after a source checkout and attempting to just 'wh'
      echo "It looks like WebHare isn't built yet. Try wh make install" 1>&2
      exit 1
    fi

    if ! is_webhare_running; then
      export __WEBHARE_WHDATA_PREPARED=1 #Set before regeneration to prevent duplicate/looping invocations. It's easy for wh to refer back to itself during execution
      "$WEBHARE_DIR/modules/platform/scripts/bootstrap/prepare-whdata.sh" --force || die "Cannot prepare whdata"
    fi
  fi
fi

# Find the 'dev' module, and if present, load its hooks. Not sure if we should trust random modules to install hooks.. especially as we may run under different UIDs ?
# WEBHARE_WH_HOOK is an external hook which may replace implementations in wh.
for EXT in "$WEBHARE_WH_HOOK" \
           "$WEBHARE_DATAROOT/installedmodules/dev/scripts/wh-hook.sh" \
           "$WEBHARE_DATAROOT/installedmodules/webhare/dev/scripts/wh-hook.sh" ; do
  if [ -n "$EXT" ] && [ -f "$EXT" ]; then
    # shellcheck source=/dev/null
    source "$EXT"
  fi
done

case $INSTR in
  "exec")
    setup_for_console
    getwhparameters

    PROCESS="$1"
    shift

    if [ -x "$WEBHARE_DIR/bin/${PROCESS}.sh" ]; then #so 'wh exec postgres' launches the proper database and we can use the .sh extension for syntax highlighting
      PROCESS="$WEBHARE_DIR/bin/${PROCESS}.sh"
    elif [ -x "$WEBHARE_DIR/bin/$PROCESS" ]; then
      PROCESS="$WEBHARE_DIR/bin/$PROCESS"
    else
      echo "No such subbinary '$PROCESS'"
    fi

    exec $PROCESS "$@"
    exit 255
    ;;

  "execbuilt")
    setup_for_console
    getwhparameters
    setup_buildsystem

    DBGARGS=();
    if [ "$1" == "--dbg" ]; then
      shift
      [ "$WEBHARE_PLATFORM" == "darwin" ] && DBGARGS+=("lldb" "--")
      [ "$WEBHARE_PLATFORM" == "linux" ] && DBGARGS+=("gdb" "--args")
    fi

    PROCESS="$1"
    shift

    if [ ! -x "$PROCESS" -a -x "$WEBHARE_BUILDDIR/bin/$PROCESS" ]; then #resolve to bin path ?
      PROCESS="$WEBHARE_BUILDDIR/bin/$PROCESS"
    fi
    exec "${DBGARGS[@]}" $PROCESS "--moduledir" "$WEBHARE_BUILDDIR/lib" "$@"
    exit 255
    ;;

  "console")
    DEBUGTAGS=
    if [ "$1" == "--profile" ]; then
      DEBUGTAGS=apr
      shift;
    elif [ "$1" == "--coverage" ]; then
      DEBUGTAGS=cov
      shift;
    fi

    [ -n "$DEBUGTAGS" ] && WEBHARE_DEBUG="$WEBHARE_DEBUG,$DEBUGTAGS"
    STARTUPOPTIONS=()
    if [[ $WEBHARE_DEBUG =~ ((^|[,])startup([,]|$))+ ]] ; then
      STARTUPOPTIONS+=(--verbose)
    fi

    check_webhare_not_running
    setup_for_console

    getwhparameters
    setup_webhare_envsettings

    # Verify no unsupported downgrade
    PREVIOUSVERSION=""
    if [ -f "$WEBHARE_DATAROOT/webhare.version" ]; then
      PREVIOUSVERSION="$(jq -r .version < "$WEBHARE_DATAROOT/webhare.version" 2>/dev/null)"
    fi
    if [ -n "$PREVIOUSVERSION" ] && ! verify_webhare_version "$PREVIOUSVERSION" "$WEBHARE_VERSION" ; then
      echo "Aborting - if you want to ignore this version check failure, delete $WEBHARE_DATAROOT/webhare.version at your own risk!"
      exit 1
    fi

    TOSHOWFILE=
    if [ "$DEBUGTAGS" == "cov" ]; then
      wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr" --deleteprofiles

      echo "Coverage data will be stored in ${WEBHARE_DATAROOT}ephemeral/profiles/default"
      echo
    fi

    # envvar WEBHARE_DEBUG should be treated as an 'initial' value so we move it
    if [ -n "$WEBHARE_DEBUG" ]; then
      export __WEBHARE_DEBUG_INITIALSETTING="$WEBHARE_DEBUG"
      WEBHARE_DEBUG=""
    fi

    # check if file ulimit is below 1024
    FILELIMIT=$(ulimit -n)
    if [[ "$FILELIMIT" != "unlimited" ]] && (( $FILELIMIT < 1024 )) ; then
      echo ""
      echo "** WARNING: The current filedescriptor limit is set to $FILELIMIT, you should raise it above 1024 (but probably more)"
      echo ""
      sleep 3
    fi

    # reset current directory, make sure we're not on a mountpunt (and would dump any coredumps over the network)
    cd /tmp/

    [ -n "$DEBUGSTARTUP" ] && logWithTime "Launching in console mode"

    SERVICEMANAGER="$WEBHARE_DIR/modules/platform/js/bootstrap/servicemanager/main.ts"
    # 100 spaces to allocate room for updating the process.title
    PS_SPACER="                                                                                                    "
    if [ "$DEBUGTAGS" == "" ]; then # no processing needed, just exec
      exec_wh_runjs "$SERVICEMANAGER" "$@" "$PS_SPACER"
      exit 255
    fi

    wh_runjs "$SERVICEMANAGER" "$@" "$PS_SPACER"

    if [ "$DEBUGTAGS" == "cov" ]; then
      echo
      echo "Processing coverage data in ${WEBHARE_DATAROOT}ephemeral/profiles/default"
      wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr"
      echo "Results are available in ${WEBHARE_DATAROOT}ephemeral/profiles/default/index.html"
      TOSHOWFILE="${WEBHARE_DATAROOT}ephemeral/profiles/default/index.html"
    fi

    if [ -n "$TOSHOWFILE" ]; then
      [ "$WEBHARE_PLATFORM" == "darwin" ] && open "$TOSHOWFILE"
      [ "$WEBHARE_PLATFORM" == "linux" ] && xdg-open "$TOSHOWFILE"
    fi

    exit 0
    ;;

  "reset-coverage")
    exec_wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr" --deleteprofiles
    ;;

  "calculate-coverage")
    exec_wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr"
    ;;

  "cachereset")
    check_webhare_running
    CLEARPERSISTENT=
    while [ "$#" -ne 0 ]; do
      if [ "$1" == "-p" ]; then
        CLEARPERSISTENT=-p
      else
        die "Unknown option $1"
      fi
      shift
    done
    exec_runscript mod::system/scripts/whcommands/softreset.whscr -c $CLEARPERSISTENT
    ;;

  "run")
    getscripttorun SCRIPT "$@"
    if [ -z "$SCRIPT" ]; then
      die "Specify the script to run"
    fi
    shift

    # This should match the whconstant_javascript_extensions:
    if [ "${SCRIPT: -3}" == ".es" -o "${SCRIPT: -3}" == ".js" -o "${SCRIPT: -3}" == ".ts" -o "${SCRIPT: -4}" == ".tsx" ]; then
      resolveresourcepath RESOLVEDPATH "$SCRIPT"
      exec_wh_runjs "$RESOLVEDPATH" "$@"
    else
      exec_wh_runwhscr "$SCRIPT" "$@"
    fi
    ;;

  "terminate")
    check_webhare_running
    kill `pgrep -f $WEBHARE_DIR/bin`
    ;;

  "kill")
    check_webhare_running
    kill -9 `pgrep -f $WEBHARE_DIR/bin`
    ;;

  "activity")
    getlog LOGFILE access
    cut -d' ' -f4 -- "$LOGFILE" | cut -d':' -f2,3 | sort | uniq -c
    ;;

  "dumplog")
    getlog LOGFILE $1
    if [ -n "$LOGFILE" ]; then
      cat $LOGFILE
    else
      echo "Could not find log '$1'"
    fi
    ;;

  "dirs")
    if [ ! -z "$WEBHARE_CHECKEDOUT_TO" ]; then
      echo "git checkout:  $WEBHARE_CHECKEDOUT_TO"
    fi
    setup_for_console
    getwhparameters
    setup_webhare_envsettings
    echo "Installation:  $WEBHARE_DIR"
    echo "Log files:     $LOGFILEPATH"
    echo "Rescue port:   http://127.0.0.1:${WEBHARE_BASEPORT}/"
    echo ""
    echo "Data root:     $WEBHARE_DATAROOT"
    echo "Database data: $WEBHARE_DATABASEPATH"
    echo ""
    set|grep ^WEBHARE_
    ;;

  "getrootdir")
    echo ${WEBHARE_CHECKEDOUT_TO:-WEBHARE_DIR}
    ;;

  "getdatadir")
    getwhparameters
    echo $WEBHARE_DATAROOT
    ;;

  "getmoduledir")
    getmoduledir MODULEDIR "$1"
    echo $MODULEDIR
    ;;

  "getmodulelist")
    loadshellconfig
    echo $WEBHARE_CFG_MODULES
    ;;

  "getinstalledmodulelist")
    loadshellconfig
    echo $WEBHARE_CFG_INSTALLEDMODULES
    ;;

  "compile")
    exec_whcompile "$@"
    ;;

  "setupmyshell")
    cat << HERE
wh() { $WEBHARE_DIR/bin/wh "\$@"; } ;
whcd() {
  local DEST;
  DEST="\`wh run mod::system/scripts/internal/cli/getdir.whscr \"\$@\"\`";
  [ -n "\$DEST" ] && cd "\$DEST";
} ;
export -f wh ;
export -f whcd ;
source $WEBHARE_DIR/lib/wh-bashautocomplete.sh
HERE
    ;;

  "runtest")
    runscript --workerthreads 10 --onlyshippedfonts mod::system/scripts/internal/tests/runtest.whscr "$@"
    EXITCODE=$?
    if [ "$EXITCODE" != "0" ]; then
      echo "Test failed with exit code $EXITCODE"
      exit $EXITCODE
    fi
    exit 0
    ;;

  "make")
    if [[ "${OPTIONS[@]}" =~ install ]]; then
      check_webhare_not_running
    fi
    setup_buildsystem
    exec "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" "${OPTIONS[@]}"
    ;;

  "finalize-webhare")
    check_webhare_not_running
    exec "$WEBHARE_DIR/modules/platform/scripts/bootstrap/finalize-webhare.sh" "${OPTIONS[@]}"
    ;;

  "prepare-whdata")
    check_webhare_not_running
    exec "$WEBHARE_DIR/modules/platform/scripts/bootstrap/prepare-whdata.sh" --verbose "${OPTIONS[@]}"
    ;;

  "fixbuild")
    check_webhare_not_running
    setup_buildsystem

    # Cannot build a target for this in the makefile, we want to serialise these steps
    for P in clean-icu-provider clean-libs postuninstall install; do
      "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" $P
    done
    exit
    ;;

  "builddocker")
    source $WEBHARE_CHECKEDOUT_TO/whtree/lib/make-functions.sh
    setup_builddir
    exec $WEBHARE_CHECKEDOUT_TO/addons/docker-build/builddocker.sh "$@"
    ;;

  "testdocker")
    exec $WEBHARE_CHECKEDOUT_TO/addons/docker-build/testdocker.sh "$@"
    ;;

  "deploydocker")
    exec $WEBHARE_CHECKEDOUT_TO/addons/docker-build/deploydocker.sh "$@"
    ;;

  "testmodule")
    exec $WEBHARE_CHECKEDOUT_TO/addons/docker-build/testdocker.sh -m "$@"
    ;;

  "isrunning")
    is_webhare_running && exit 0 || exit 1
    ;;

  "installsocketbinder")
    git clone https://github.com/WebHare/socket_binder.git /tmp/installsocketbinder.$$
    cd /tmp/installsocketbinder.$$
    make
    if [ "$WEBHARE_PLATFORM" == "darwin" ]; then
      sudo make install-darwin
    else
      sudo make install
      echo "Make install ran, now do whatever it takes to start socketbinder on this platform"
    fi
    exit 0
    ;;

  "mic")
    setup_buildsystem
    check_webhare_not_running

    "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" install ||  exit 1

    getwhparameters
    exec $WEBHARE_DIR/bin/wh "$@" console
    exit 255
    ;;

  "__listcommands")
    list_commands | sort -u
    exit 0
    ;;

  "up" | "st" | "status" | "umic")
    echo "The command '$INSTR' is now provided by the 'dev' module, please install it first"
    exit 255
    ;;

  "__autocomplete_wh")
    autocomplete_init_compwords

    if [ "$COMP_CWORD" == "1" ]; then
      # Return list of commands (line separated)
      IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$(wh __listcommands)"
    fi

    autocomplete_print_compreply
    ;;

  "__autocomplete_whcd")
    autocomplete_init_compwords

    if [ "$COMP_CWORD" == "1" ]; then
      CUR="${COMP_WORDS[1]}"
      MODULEPREFIX=${CUR%%/*}

      if [ "$MODULEPREFIX" == "$CUR" ]; then
        # no slash, return module list (space separated) and append a slash
        read -r -a COMPREPLY <<< "$(wh getmodulelist)"
        COMPREPLY=("${COMPREPLY[@]/%//}")
      else
        # Calculate the path within the module
        SUBPATH=${CUR#"$MODULEPREFIX/"}

        # cd to the module root and complete the subpath there. Add the module prefix and append a slash
        pushd "$(wh getmoduledir "$MODULEPREFIX")" > /dev/null || return
        # Parse list of directories (line separated)
        IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$(compgen -d -P "$MODULEPREFIX/" -S / -- "${SUBPATH}")"
        popd > /dev/null || return
      fi
    fi

    autocomplete_print_compreply
    ;;

  *)
    if [[ $INSTR =~ .*:.* ]]; then
      TARGETMODULE="${INSTR%:*}"
      SUBCOMMAND="${INSTR##*:}"
    else
      # Try the preferred route first for new commands, a TS file in platform/cli-commands (not whcommands to prevent aliasing them as wh platform:xxx)
      # Also *we* have no reason to support es/js/tsx extensions (TODO allow .sh too? but whscr definitely shouldn't be here)
      if [ -f "${WEBHARE_DIR}/modules/platform/cli-commands/$INSTR.ts" ]; then
        exec_wh_runjs "${WEBHARE_DIR}/modules/platform/cli-commands/$INSTR.ts" "${OPTIONS[@]}"
      fi

      TARGETMODULE=system
      SUBCOMMAND="$INSTR"
    fi

    getmoduledir MODULEDIR $TARGETMODULE

    if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.sh" ]; then
      exec /bin/bash "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.sh" "${OPTIONS[@]}"
    fi
    if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.whscr" ]; then
      exec_wh_runwhscr "mod::$TARGETMODULE/scripts/whcommands/$SUBCOMMAND.whscr" "${OPTIONS[@]}"
    fi

    # This should match the whconstant_javascript_extensions:
    for EXT in es js ts tsx ; do
      if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.$EXT" ] ; then
        exec_wh_runjs "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.$EXT" "${OPTIONS[@]}"
      fi
    done

    die "Command '$INSTR' not understood - use 'wh help' for a list of instructions"
    ;;
esac
