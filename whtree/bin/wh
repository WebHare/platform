#!/bin/bash
export WEBHARE_DIR="${BASH_SOURCE%/*/*}"
# shellcheck source=../lib/wh-functions.sh
source "${WEBHARE_DIR}/lib/wh-functions.sh"

# Ensure 'wh' runs this wh so we don't accidentally rely on external PATHs/functions/aliasses - lock it to WEBHARE_DIR
# shellcheck disable=SC2317
wh() { "${WEBHARE_DIR}/bin/wh" "$@"; }
export -f wh

# --- Functions ---
check_webhare_running()
{
  if [ "$WEBHARE_IGNORE_RUNNING" == "1" ]; then
    return
  fi

  if ! is_webhare_running ; then
    die "WebHare does not seem to be running"
  fi
}

check_webhare_not_running()
{
  if [ "$WEBHARE_IGNORE_RUNNING" == "1" ]; then
    return
  fi

  if is_webhare_running ; then
    die "WebHare is already running"
  fi
}


## Main code
DEBUGSTARTUP=""

if [[ $WEBHARE_DEBUG =~ ((^|[,])startup([,]|$))+ ]] ; then
  DEBUGSTARTUP=1
fi

while [[ $1 =~ ^-.* ]]; do
  if [ "$1" == "-v" -o "$1" == "--verbose" ]; then
    export WH_VERBOSE=1
    shift
  elif [ "$1" == "-f" -o "$1" == "--force" ]; then
    FORCE=1
    shift
  elif [ "$1" == "-i" -o "$1" == "--ignore-running" ]; then
    export WEBHARE_IGNORE_RUNNING=1
    shift
  else
    die "Illegal option $1"
  fi
done

INSTR="${1:-help}"
shift
OPTIONS=("$@")

# Print ASAP to give accurate measurements
[ "$INSTR" == "console" ] && [ -n "$DEBUGSTARTUP" ] && logWithTime "Preparing for console"

[ "$WH_VERBOSE" == "1" ] && echo "WebHare installation dir: $WEBHARE_DIR"

# Setup important paths/vars
[ -n "$WEBHARE_BASEPORT" ] || WEBHARE_BASEPORT=13679
export WEBHARE_HSBUILDCACHE="${WEBHARE_DIR}/currentinstall/cache.harescript/${WEBHARE_BASEPORT}/"
export WEBHARE_TSBUILDCACHE="${WEBHARE_DIR}/currentinstall/cache.typescript/"
export PUPPETEER_CACHE_DIR="${WEBHARE_DIR}/libexec/puppeteer"

mkdir -p "$WEBHARE_HSBUILDCACHE" "$WEBHARE_TSBUILDCACHE"

# Allow hooks, eg. to launch podman for container builds
if [ -n "$WEBHARE_WH_HOOK" ] && [ -f "$WEBHARE_WH_HOOK" ]; then
  # shellcheck source=/dev/null
  source "$WEBHARE_WH_HOOK"
fi

# Deal with commands that don't require a set up WebHare
case $INSTR in
  "builddocker"|"buildcontainer")
    setup_builddir
    exec "$WEBHARE_CHECKEDOUT_TO/addons/docker-build/builddocker.sh" "$@"
    ;;

  "testdocker"|"testcontainer")
    exec "$WEBHARE_CHECKEDOUT_TO/addons/docker-build/testcontainer.sh" "$@"
    ;;

  "make")
    if [[ "${OPTIONS[*]}" =~ install ]]; then
      check_webhare_not_running
    fi

    exec "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" "${OPTIONS[@]}"
    ;;

  "finalize-webhare")
    check_webhare_not_running
    exec "$WEBHARE_DIR/modules/platform/scripts/bootstrap/finalize-webhare.sh" "${OPTIONS[@]}"
    ;;

esac

# If we haven't found WEBHARE_DATAROOT that way, discover it
if [ -z "$WEBHARE_DATAROOT" ] ; then
  echo "WEBHARE_DATAROOT must be set. If you're running a source installation, set up WebHare runkit" >&2
  exit 1
elif [[ $WEBHARE_DATAROOT == $WEBHARE_DIR* ]]; then # Test if WEBHARE_DATAROOT is inside WEBHARE_DIR
  echo "WEBHARE_DATAROOT ($WEBHARE_DATAROOT) must not be inside the WebHare installation directory ($WEBHARE_DIR)" >&2
  if [ -n "$WHRUNKIT_TARGETSERVER" ]; then #we're started through runkit..
    # Do not recommend rm -r .. rm will safely delete a symlink but not a directory
    echo "Suggested fix: mv $WEBHARE_DATAROOT $WHRUNKIT_DATADIR/$WHRUNKIT_TARGETSERVER/whdata && rm $WHRUNKIT_DATADIR/$WHRUNKIT_TARGETSERVER/dataroot" >&2
  fi
  exit 1
elif [ "${WEBHARE_DATAROOT:0:1}" != "/" ]; then
  echo "WEBHARE_DATAROOT must be an absolute path" >&2
  exit 1
elif [ "${WEBHARE_DATAROOT: -1}" != "/" ]; then #ensure it ends with a slash
  WEBHARE_DATAROOT="${WEBHARE_DATAROOT}/"
fi

if [ -f "${WEBHARE_DATAROOT}dbase/translog.whdb" ]; then
  echo "The dbserver is no longer supported by WebHare 5.0 and up. Downgrade and convert first!" >&2
  exit 1
fi

export WEBHARE_DATABASEPATH="${WEBHARE_DATAROOT}postgresql"

export PGUSER="root" #postgres user, must be locked for compatibility between dev and prod
export PGHOST="$WEBHARE_DIR/currentinstall/pg/"
export PGPORT=$((WEBHARE_BASEPORT + 8))

# Oracle's instantclient requires additional libraries we can't ship with WebHare or through npm so we offer an option
# to place additional libraries in $WEBHARE_DATAROOT/lib/
if [ "$WEBHARE_PLATFORM" = "darwin" ]; then
  if ! [[ $DYLD_LIBRARY_PATH == ${WEBHARE_DATAROOT}lib* ]]; then #If not prepended yet..
    # Note that SIP on Darwin may interfere with this setting (see eg https://developer.apple.com/forums/thread/703757)
    export DYLD_LIBRARY_PATH="${WEBHARE_DATAROOT}lib:$DYLD_LIBRARY_PATH"
  fi
else
  if ! [[ $LD_LIBRARY_PATH == ${WEBHARE_DATAROOT}lib* ]]; then #If not prepended yet..
    export LD_LIBRARY_PATH="${WEBHARE_DATAROOT}lib:$LD_LIBRARY_PATH"
    fi
fi

export WEBHARE_DBASENAME="webhare" # embedded database is always named WH

# If you haven't set WEBHARE_TEMP, assume it to be $WEBHARE_DATAROOT/tmp
if [ -z "$WEBHARE_TEMP" ]; then
  WEBHARE_TEMP="$WEBHARE_DATAROOT/tmp"
fi

[ "$WH_VERBOSE" == "1" ] && echo "WebHare data directory:   $WEBHARE_DATAROOT"
[ "$WH_VERBOSE" == "1" ] && echo "WebHare base port number: $WEBHARE_BASEPORT"

export WEBHARE_CHECKEDOUT_TO
export WEBHARE_BUILDDIR
export WEBHARE_DIR
export WEBHARE_BASEPORT
export WEBHARE_DATAROOT
export WHBUILD_DOWNLOADCACHE
export WEBHARE_TEMP
export WHBUILD_BUILDROOT

# Ensures npm stable ordering - https://github.com/npm/npm/issues/17048
# Minimum debian/ubuntu install ships only with C.UTF-8, not en_US.UTF-8
export LANG="C"
export LC_ALL="C"

if [ ! -d "$WEBHARE_DIR" ]; then
  die "Cannot find WebHare installation"
fi

exec_whcompile()
{
  getwhparameters
  exec $WEBHARE_DIR/bin/whcompile "$@"
}

wh()
{
  $WEBHARE_DIR/bin/wh "$@"
}

exec_wh()
{
  $WEBHARE_DIR/bin/wh "$@"
}

setup_webhare_envsettings()
{
  getwebhareversion

  # Export all WEBHARE_ vars to .webhare-envsettings.sh for scripts that need to restablish the whole `wh console` environment
  # But don't export WEBHARE_DEBUG= ... as WebHare will cross-process communicate that anyway
  set | grep -E '^WEBHARE_' | grep -v '^WEBHARE_DEBUG=' | sed -e 's/^/export /' > "$WEBHARE_DATAROOT/.webhare-envsettings.sh"
}

list_commands()
{
  grep -oe "^[a-z]*" ${BASH_SOURCE%/*}/../modules/system/doc/wh.txt

  SCRIPTDIR="$WEBHARE_DIR/modules/system/scripts/whcommands/"
  for SCRIPTPATH in "$WEBHARE_DIR/modules/platform/cli-commands/"*.ts "${SCRIPTDIR}"*.whscr "${SCRIPTDIR}"*.sh "${SCRIPTDIR}"*.ts; do
    if [ -f $SCRIPTPATH ]; then
      FILENAME="${SCRIPTPATH##*/}"
      INSTR="${FILENAME%.*}"
      echo "$INSTR"
    fi
  done

  if [ -x "$WEBHARE_DIR/bin/runscript" ]; then
    for MODULE in $( cd "$WEBHARE_DATAROOT/config/mod" && echo *); do
      if [ "$MODULE" != "system" ]; then
        getmoduledir MODULEDIR $MODULE
        SCRIPTDIR="${MODULEDIR}scripts/whcommands/"
        for SCRIPTPATH in "${SCRIPTDIR}"*.whscr "${SCRIPTDIR}"*.sh "${SCRIPTDIR}"*.ts; do
          if [ -f $SCRIPTPATH ]; then
            FILENAME="${SCRIPTPATH##*/}"
            INSTR="$MODULE:${FILENAME%.*}"
            echo "$INSTR"
          fi
        done
      fi
    done
  fi
}

getscripttorun()
{
  VARNAME=$1
  while shift; do
    if [ "$1" == "--whdebug" ]; then
      shift
    elif [ "${1:0:1}" != "-" ]; then
      break;
    fi
  done
  eval $VARNAME=\$1
}

move_dir() { # oldlocation newparentlocation newsublocation
  if [ -d "$1" ]; then
    echo "Migrating $1 to $2/$3"
    # If a conflicting dir exists, you upgraded WebHare while it was running. Removing it, images will get recreated
    rm -rf -- "$2"/"$3" >/dev/null 2>&1
    mkdir -p -- "$2"
    if ! mv "$1" "$2"/"$3" ; then
      # If this failed.. cross disk partition? we'll delete it in the background and have it regenerated.
      rm -rf -- "$1" > /dev/null 2>&1 &
    fi
  fi
}

#setup_for_console is invoked when we're starting a major subprocess (console or exec)
setup_for_console()
{
  # Ensure @mod- symlinks are in place.
  "$WEBHARE_DIR/modules/platform/scripts/bootstrap/prepare-whdata.sh" --force || die "Unable to ensure symlinks/scripts are in place"
  export __WEBHARE_WHDATA_PREPARED=1

  # WH 5.0 - move the unified cache (image cache) into the right place. To avoid races we *have* to do this before we start WebHare - it should normally be done in a sec...
  move_dir "$WEBHARE_DATAROOT"ephemeral/system.uc2 "$WEBHARE_DATAROOT"caches/platform uc
  # WH 5.6 - move the unified cache into the right place, for real this time
  move_dir "$WEBHARE_DATAROOT"storage/system/output/uc "$WEBHARE_DATAROOT"caches/platform uc
  # WH 5.6 - move assetpacks into generated/
  move_dir "$WEBHARE_DATAROOT"publisher.ap "$WEBHARE_DATAROOT"generated/platform ap
}

# Do we need to prepare whdata? Anything that does setup_for_console or things like make and finalize don't need it
if [[ ! "$INSTR" =~ ^(console|mic|umic|exec|execbuilt|usebuiltwasm|shell|make|finalize-webhare|prepare-whdata|fixbuild|buildcontainer|testcontainer|builddocker|testdocker)$ ]]; then
  if [ -z "$__WEBHARE_WHDATA_PREPARED" ]; then
    if [ ! -f "$WEBHARE_DIR/jssdk/tsrun/dist/resolveplugin.js" ]; then #this may trigger after a source checkout and attempting to just 'wh'
      echo "It looks like WebHare isn't built yet. Try wh make install" 1>&2
      exit 1
    fi

    if ! is_webhare_running; then
      export __WEBHARE_WHDATA_PREPARED=1 #Set before regeneration to prevent duplicate/looping invocations. It's easy for wh to refer back to itself during execution
      "$WEBHARE_DIR/modules/platform/scripts/bootstrap/prepare-whdata.sh" --force || die "Cannot prepare whdata"
    fi
  fi
fi

# If devkit module is active load its hooks. this should happen after whdata/ setup
DEVKIT_WH_HOOK="$WEBHARE_DATAROOT/config/mod/devkit/scripts/libexec/wh-hook.sh"
if [ -n "$DEVKIT_WH_HOOK" ] && [ -f "$DEVKIT_WH_HOOK" ]; then
  # shellcheck source=/dev/null
  source "$DEVKIT_WH_HOOK"
fi

case $INSTR in
  "exec")
    setup_for_console
    getwhparameters

    PROCESS="$1"
    shift

    if [ -x "$WEBHARE_DIR/bin/${PROCESS}.sh" ]; then #so 'wh exec postgres' launches the proper database and we can use the .sh extension for syntax highlighting
      PROCESS="$WEBHARE_DIR/bin/${PROCESS}.sh"
    elif [ -x "$WEBHARE_DIR/bin/$PROCESS" ]; then
      PROCESS="$WEBHARE_DIR/bin/$PROCESS"
    else
      echo "No such subbinary '$PROCESS'" 1>&2
      exit 255
    fi

    exec $PROCESS "$@"
    exit 255
    ;;

  "execbuilt")
    setup_for_console
    getwhparameters
    setup_builddir

    DBGARGS=();
    if [ "$1" == "--dbg" ]; then
      shift
      [ "$WEBHARE_PLATFORM" == "darwin" ] && DBGARGS+=("lldb" "--")
      [ "$WEBHARE_PLATFORM" == "linux" ] && DBGARGS+=("gdb" "--args")
    fi

    PROCESS="$1"
    shift

    if [ ! -x "$PROCESS" -a -x "$WEBHARE_BUILDDIR/bin/$PROCESS" ]; then #resolve to bin path ?
      PROCESS="$WEBHARE_BUILDDIR/bin/$PROCESS"
    fi
    exec "${DBGARGS[@]}" $PROCESS "--moduledir" "$WEBHARE_BUILDDIR/lib" "$@"
    exit 255
    ;;

  "usebuiltwasm")
    setup_builddir
    export WEBHARE_WASMMODULEDIR="$WEBHARE_BUILDDIR/lib/"
    exec "$@"
    ;;

  "console")
    DEBUGTAGS=
    if [ "$1" == "--profile" ]; then
      DEBUGTAGS=apr
      shift;
    elif [ "$1" == "--coverage" ]; then
      DEBUGTAGS=cov
      shift;
    fi

    [ -n "$DEBUGTAGS" ] && WEBHARE_DEBUG="$WEBHARE_DEBUG,$DEBUGTAGS"
    STARTUPOPTIONS=()
    if [[ $WEBHARE_DEBUG =~ ((^|[,])startup([,]|$))+ ]] ; then
      STARTUPOPTIONS+=(--verbose)
    fi

    check_webhare_not_running
    setup_for_console

    getwhparameters
    setup_webhare_envsettings

    TOSHOWFILE=
    if [ "$DEBUGTAGS" == "cov" ]; then
      wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr" --deleteprofiles

      echo "Coverage data will be stored in ${WEBHARE_DATAROOT}ephemeral/profiles/default"
      echo
    fi

    # envvar WEBHARE_DEBUG should be treated as an 'initial' value so we move it so you can eg 'WEBHARE_DEBUG=startup wh console'
    # and still disable the flag later. otherwise it would be sticky as WEBHARE_DEBUG is otherwise inherited by all processes
    if [ -n "$WEBHARE_DEBUG" ]; then
      export __WEBHARE_DEBUG_INITIALSETTING="$WEBHARE_DEBUG"
      WEBHARE_DEBUG=""
    fi

    # check if file ulimit is below 1024
    FILELIMIT=$(ulimit -n)
    if [[ "$FILELIMIT" != "unlimited" ]] && (( $FILELIMIT < 1024 )) ; then
      echo ""
      echo "** WARNING: The current filedescriptor limit is set to $FILELIMIT, you should raise it above 1024 (but probably more)"
      echo ""
      sleep 3
    fi

    # reset current directory, make sure we're not on a mountpunt (and would dump any coredumps over the network)
    cd /tmp/

    [ -n "$DEBUGSTARTUP" ] && logWithTime "Launching in console mode"

    SERVICEMANAGER="$WEBHARE_DIR/modules/platform/js/bootstrap/servicemanager/main.ts"
    # 100 spaces to allocate room for updating the process.title
    PS_SPACER="                                                                                                    "
    if [ "$DEBUGTAGS" == "" ]; then # no processing needed, just exec
      exec_wh_runjs "$SERVICEMANAGER" "$@" "$PS_SPACER"
      exit 255
    fi

    wh_runjs "$SERVICEMANAGER" "$@" "$PS_SPACER"

    if [ "$DEBUGTAGS" == "cov" ]; then
      echo
      echo "Processing coverage data in ${WEBHARE_DATAROOT}ephemeral/profiles/default"
      wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr"
      echo "Results are available in ${WEBHARE_DATAROOT}ephemeral/profiles/default/index.html"
      TOSHOWFILE="${WEBHARE_DATAROOT}ephemeral/profiles/default/index.html"
    fi

    if [ -n "$TOSHOWFILE" ]; then
      [ "$WEBHARE_PLATFORM" == "darwin" ] && open "$TOSHOWFILE"
      [ "$WEBHARE_PLATFORM" == "linux" ] && xdg-open "$TOSHOWFILE"
    fi

    exit 0
    ;;

  "reset-coverage")
    exec_wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr" --deleteprofiles
    ;;

  "calculate-coverage")
    exec_wh_runwhscr "mod::system/scripts/debug/analyze_coverage.whscr"
    ;;

  "cachereset")
    check_webhare_running
    CLEARPERSISTENT=
    while [ "$#" -ne 0 ]; do
      if [ "$1" == "-p" ]; then
        CLEARPERSISTENT=-p
      else
        die "Unknown option $1"
      fi
      shift
    done
    exec_runscript mod::system/scripts/whcommands/softreset.whscr -c $CLEARPERSISTENT
    ;;

  "run")
    getscripttorun SCRIPT "$@"
    if [ -z "$SCRIPT" ]; then
      die "Specify the script to run"
    fi
    shift

    # This should match the whconstant_javascript_extensions:
    if [ "${SCRIPT: -3}" == ".es" ] || [ "${SCRIPT: -3}" == ".js" ] || [ "${SCRIPT: -3}" == ".ts" ] || [ "${SCRIPT: -4}" == ".tsx" ] || [ "${SCRIPT: -4}" == ".mjs" ]; then
      resolveresourcepath RESOLVEDPATH "$SCRIPT"
      exec_wh_runjs "$RESOLVEDPATH" "$@"
    else
      exec_wh_runwhscr "$SCRIPT" "$@"
    fi
    ;;

  "activity")
    getlog LOGFILE access
    cut -d' ' -f4 -- "$LOGFILE" | cut -d':' -f2,3 | sort | uniq -c
    ;;

  "dumplog")
    getlog LOGFILE $1
    if [ -n "$LOGFILE" ]; then
      cat $LOGFILE
    else
      echo "Could not find log '$1'"
    fi
    ;;

  "dirs")
    if [ -d "${WEBHARE_CHECKEDOUT_TO}/.git" ]; then
      echo "git checkout:  $WEBHARE_CHECKEDOUT_TO"
    fi
    setup_for_console
    getwhparameters
    setup_webhare_envsettings
    echo "Installation:  $WEBHARE_DIR"
    echo "Rescue port:   http://127.0.0.1:${WEBHARE_BASEPORT}/"
    echo ""
    echo "Data root:     $WEBHARE_DATAROOT"
    echo "Database data: $WEBHARE_DATABASEPATH"
    echo ""
    set|grep ^WEBHARE_
    ;;

  "getrootdir")
    echo ${WEBHARE_CHECKEDOUT_TO:-WEBHARE_DIR}
    ;;

  "getdatadir")
    getwhparameters
    echo $WEBHARE_DATAROOT
    ;;

  "getmoduledir")
    readlink "$WEBHARE_DATAROOT"/config/mod/"$1"
    ;;

  "getmodulelist")
    ( cd "$WEBHARE_DATAROOT/config/mod" && echo *)
    ;;

  "compile")
    exec_whcompile "$@"
    ;;

  "setupmyshell")
    cat << HERE
wh() { $WEBHARE_DIR/bin/wh "\$@"; } ;
whcd() {
  local DEST;
  DEST="\`wh run mod::system/scripts/internal/cli/getdir.whscr \"\$@\"\`";
  [ -n "\$DEST" ] && cd "\$DEST";
} ;
export -f wh ;
export -f whcd ;
source $WEBHARE_DIR/lib/wh-bashautocomplete.sh
HERE
    ;;

  "runtest")
    runscript --workerthreads 10 --onlyshippedfonts mod::system/scripts/internal/tests/runtest.whscr "$@"
    EXITCODE=$?
    if [ "$EXITCODE" != "0" ]; then
      echo "Test failed with exit code $EXITCODE"
      exit $EXITCODE
    fi
    exit 0
    ;;

  "fixbuild")
    check_webhare_not_running

    # Force brew to update
    touch "$WEBHARE_CHECKEDOUT_TO/addons/darwin/webhare-deps.rb"
    # Force emsdk to update
    rm -f "$WEBHARE_CHECKEDOUT_TO/vendor/wh-current-emscripten-version"

    # Cannot build a target for this in the makefile, we want to serialise these steps
    for P in postuninstall clean install; do
      "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" --output-sync=target $P
    done
    exit
    ;;

  "isrunning")
    is_webhare_running && exit 0 || exit 1
    ;;

  "installsocketbinder")
    git clone https://github.com/WebHare/socket_binder.git /tmp/installsocketbinder.$$
    cd /tmp/installsocketbinder.$$
    make
    if [ "$WEBHARE_PLATFORM" == "darwin" ]; then
      sudo make install-darwin
    else
      sudo make install
      echo "Make install ran, now do whatever it takes to start socketbinder on this platform"
    fi
    exit 0
    ;;

  "mic")
    check_webhare_not_running

    "$WEBHARE_CHECKEDOUT_TO/builder/make.sh" install ||  exit 1

    getwhparameters
    exec $WEBHARE_DIR/bin/wh "$@" console
    exit 255
    ;;

  "__listcommands")
    list_commands | sort -u
    exit 0
    ;;

  "up" | "st" | "status" | "umic")
    echo "The command '$INSTR' is now provided by the 'dev' module, please install it first"
    exit 255
    ;;

  "__autocomplete_wh")
    autocomplete_init_compwords

    NEEDFILTER=
    if [ "$COMP_CWORD" == "1" ]; then
      # Return list of commands (line separated)
      IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$(wh __listcommands)"
      for key in "${!COMPREPLY[@]}"; do
        COMPREPLY[key]="${COMPREPLY[key]} "
      done;
      NEEDFILTER=filter
    else
      if [ -S "$WEBHARE_DATAROOT/.cli-autocomplete.sock" ] && RESPONSE=$(echo -n "$COMP_SLICED_LINE" | curl --silent --fail --request POST --data-binary @- --unix-socket "$WEBHARE_DATAROOT/.cli-autocomplete.sock" http://example.com/autocomplete); then
        IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$RESPONSE"
      else
        IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$(wh_runjs "$WEBHARE_DIR/modules/platform/js/cli/autocomplete-service.ts" "--try-start-service")"
      fi
      NEEDFILTER=no-filter
    fi

    autocomplete_print_compreply $NEEDFILTER
    ;;

  "__autocomplete_whcd")
    autocomplete_init_compwords

    if [ "$COMP_CWORD" == "1" ]; then
      CUR="${COMP_WORDS[1]}"
      MODULEPREFIX=${CUR%%/*}

      if [ "$MODULEPREFIX" == "$CUR" ]; then
        # no slash, return module list (space separated) and append a slash
        read -r -a COMPREPLY <<< "$(wh getmodulelist)"
        COMPREPLY=("${COMPREPLY[@]/%//}")
      else
        # Calculate the path within the module
        SUBPATH=${CUR#"$MODULEPREFIX/"}

        # cd to the module root and complete the subpath there. Add the module prefix and append a slash
        pushd "$(wh getmoduledir "$MODULEPREFIX")" > /dev/null || return
        # Parse list of directories (line separated)
        IFS=$'\n' read -d '' -r -a COMPREPLY <<< "$(compgen -d -P "$MODULEPREFIX/" -S / -- "${SUBPATH}")"
        popd > /dev/null || return
      fi
    fi

    autocomplete_print_compreply filter
    ;;

  *)
    if [[ $INSTR =~ .*:.* ]]; then
      TARGETMODULE="${INSTR%:*}"
      SUBCOMMAND="${INSTR##*:}"
    else
      # Try the preferred route first for new commands, a TS file in platform/cli-commands (not whcommands to prevent aliasing them as wh platform:xxx)
      # Also *we* have no reason to support es/js/tsx extensions (TODO allow .sh too? but whscr definitely shouldn't be here)
      if [ -f "${WEBHARE_DIR}/modules/platform/cli-commands/$INSTR.ts" ]; then
        exec_wh_runjs "${WEBHARE_DIR}/modules/platform/cli-commands/$INSTR.ts" "${OPTIONS[@]}"
      fi

      TARGETMODULE=system
      SUBCOMMAND="$INSTR"
    fi

    getmoduledir MODULEDIR $TARGETMODULE

    if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.sh" ]; then
      exec /bin/bash "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.sh" "${OPTIONS[@]}"
    fi
    if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.whscr" ]; then
      exec_wh_runwhscr "mod::$TARGETMODULE/scripts/whcommands/$SUBCOMMAND.whscr" "${OPTIONS[@]}"
    fi

    # This should match the whconstant_javascript_extensions:
    for EXT in es js ts tsx ; do
      if [ -f "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.$EXT" ] ; then
        exec_wh_runjs "${MODULEDIR}scripts/whcommands/$SUBCOMMAND.$EXT" "${OPTIONS[@]}"
      fi
    done

    die "Command '$INSTR' not understood - use 'wh help' for a list of instructions"
    ;;
esac
