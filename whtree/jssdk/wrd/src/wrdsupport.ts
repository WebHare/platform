import { WRDAttributeTypeId, type WRDAttributeType } from "@mod-wrd/js/internal/types";
import { ResourceDescriptor, decodeScanData } from "@webhare/services/src/descriptor";
import { __RichDocumentInternal } from "@webhare/services/src/richdocument";
import { WebHareBlob } from "@webhare/services";
import { createPGBlobByBlobRec } from "@webhare/whdb/src/blobs";
import { nameToSnakeCase, nameToCamelCase } from "@webhare/hscompat/types";

export interface WRDAttributeConfiguration_HS {
  id: number;
  attributetype: number;
  attributetypename: string;
  tag: string;
  title: string;
  checklinks: boolean;
  domain: number;
  isunsafetocopy: boolean;
  isrequired: boolean;
  isordered: boolean;
  isunique: boolean;
  allowedvalues: string[];
}

export interface WRDAttributeConfigurationBase {
  attributeType: WRDAttributeType;
  title?: string;
  checkLinks?: boolean;
  domain?: string | null;
  isUnsafeToCopy?: boolean;
  isRequired?: boolean;
  isOrdered?: boolean;
  isUnique?: boolean;
  allowedValues?: string[] | null;
}

export interface WRDAttributeConfiguration extends WRDAttributeConfigurationBase {
  tag: string;
  title: string;
  checkLinks: boolean;
  domain: string | null;
  isUnsafeToCopy: boolean;
  isRequired: boolean;
  isOrdered: boolean;
  isUnique: boolean;
  allowedValues: string[] | null;
}


const fixed_tojs: Record<string, string> = {
  "wrd_creationdate": "wrdCreationDate",
  "wrd_limitdate": "wrdLimitDate",
  "wrd_modificationdate": "wrdModificationDate",
  "wrd_dateofbirth": "wrdDateOfBirth",
  "wrd_dateofdeath": "wrdDateOfDeath",
  "wrd_firstname": "wrdFirstName",
  "wrd_firstnames": "wrdFirstNames",
  "wrd_lastname": "wrdLastName",
  "wrd_fullname": "wrdFullName",
  "wrd_orgname": "wrdOrgName",
  "wrd_salute_formal": "wrdSaluteFormal",
  "wrd_address_formal": "wrdAddressFormal",
  "wrd_titles_suffix": "wrdTitlesSuffix",
  "wrd_leftentity": "wrdLeftEntity",
  "wrd_rightentity": "wrdRightEntity"
};

const fixed_tohs = Object.fromEntries(Object.entries(fixed_tojs).map(([key, value]) => [value, key.toUpperCase()]));

/**
 * Convert a HS tag (eg WRD_PERSON) to JavaScript (wrdPerson)
 * @param tag - The tag to convert
 */
export function tagToJS(tag: string): string {
  tag = tag.toLowerCase();
  if (fixed_tojs[tag])
    return fixed_tojs[tag];

  return nameToCamelCase(tag);
}

/**
 * Convert a JS tag (eg wrdPerson) to HS (WRD_PERSON)
 * @param tag - The tag to convert
 */
export function tagToHS(tag: string): string {
  if (fixed_tohs[tag])
    return fixed_tohs[tag];

  if (tag[0] === tag[0].toUpperCase())
    throw new Error(`A JS WRD name may not start with an uppercase letter: ${tag}`);
  if (tag.match(/_[a-z]/i))
    throw new Error(`Invalid JS WRD name - are you passing a HareScript tag? (eg WRD_PERSON instead of wrdPerson): ${tag}`);

  return nameToSnakeCase(tag).toUpperCase();
}

interface WrappedObjectFromWRDSetting { // generated by HS GetWrappedObjectFromWRDSetting
  "^$wrdtype": 'fileimage';
  id: string;
  size: number;
  scandata: string;
  fs_object: number;
}

interface WrappedJSONFromWRDSetting {
  "^$wrdtype": 'json';
  json: string;
}

interface WrappedRichDocumentFromWRDSetting {
  "^$wrdtype": "richdocument";
  htmltext: WebHareBlob;
  embedded: unknown[];
  links: Array<{ tag: string; linkref: number }>;
  instances: Array<{ instanceid: string; data: unknown }>;
}

type WrappedFromWRDSetting = WrappedObjectFromWRDSetting | WrappedJSONFromWRDSetting | WrappedRichDocumentFromWRDSetting;

function buildRichDescriptor(val: WrappedObjectFromWRDSetting) {
  return new ResourceDescriptor(val.size ? createPGBlobByBlobRec(val.id, val.size) : null, { ...decodeScanData(val.scandata), sourceFile: val.fs_object });
}

function returnWRDObject(rawvalue: object) {
  const value = rawvalue as WrappedFromWRDSetting;
  switch (value["^$wrdtype"]) {
    case "fileimage":
      return buildRichDescriptor(value);
    case "json":
      return JSON.parse((value).json);
    case "richdocument":
      return new __RichDocumentInternal(value.htmltext);
    default:
      return value;
  }
}

export function fieldsToJS(fields: Record<string, unknown>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(fields)) {
    if (Array.isArray(value) && value.length && typeof value[0] === "object" && value[0]) { // array?
      result[tagToJS(key)] = value.map(elt => fieldsToJS(elt));
    } else if (value && typeof value === "object")
      result[tagToJS(key)] = returnWRDObject(value);
    else
      result[tagToJS(key)] = value;
  }
  return result;
}

export function fieldsToHS(fields: Record<string, unknown>, attributes: WRDAttributeConfiguration_HS[]): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(fields)) {
    const hstag = tagToHS(key);
    const matchattr = attributes.find(attr => attr.tag === hstag);
    if (matchattr && matchattr.attributetype === WRDAttributeTypeId.JSON)
      result[hstag] = JSON.stringify(value);
    else if (Array.isArray(value) && value.length && typeof value[0] === "object" && value[0]) { // array?
      result[hstag] = value.map(elt => fieldsToHS(elt, []));
    } else
      result[hstag] = value;
  }
  return result;
}

export function outputmapToHS(fields: Record<string, unknown>): Record<string, unknown> {
  const result: Record<string, unknown> = {};
  for (const [key, value] of Object.entries(fields)) {
    if (typeof value === "object")
      result[key] = outputmapToHS(value as Record<string, unknown>);
    else
      result[key] = tagToHS(value as string); //FIXME support records
  }
  return result;
}

type RepairMapping = Array<{ key: string; isrecord: false } | { key: string; isrecord: true; subkeys: RepairMapping }>;

function prepareRepair(mapping: Record<string, unknown>): RepairMapping {
  const retval: RepairMapping = [];
  const entries = Object.entries(mapping);
  for (const [key, value] of entries) {
    if (typeof value === "string")
      retval.push({ key, isrecord: false });
    else
      retval.push({ key, isrecord: true, subkeys: prepareRepair(value as Record<string, unknown>) });
  }
  return retval;
}

export function repairResultValue(value: unknown) {
  if (Array.isArray(value) && value.length && typeof value[0] === "object" && value[0])
    return value.map(elt => fieldsToJS(elt));

  if (value && typeof value === "object")
    return returnWRDObject(value);

  return value;
}

function repairResultSetInternal(row: Record<string, unknown>, preparedmapping: RepairMapping): Record<string, unknown> {
  const fixedrow = { ...row };

  for (const rec of preparedmapping) {
    if (!(rec.key in fixedrow)) {
      //the key is missing in the outputset. find it case-insensitively to correct it
      const match = Object.keys(fixedrow).find(k => k.toLowerCase() === rec.key.toLowerCase());
      if (!match)
        throw new Error(`Missing key ${rec.key} in output row`);

      let value = fixedrow[match];
      if (rec.isrecord)
        value = repairResultSetInternal(value as Record<string, unknown>, rec.subkeys);
      else
        value = repairResultValue(value);

      fixedrow[rec.key] = value;
      delete fixedrow[match];
    } else if (rec.isrecord) {
      fixedrow[rec.key] = repairResultSetInternal(row[rec.key] as Record<string, unknown>, rec.subkeys);
    } else
      fixedrow[rec.key] = repairResultValue(row[rec.key]);
  }
  return fixedrow;
}

export function repairResultSet(resultset: Array<Record<string, unknown>>, mapping: Record<string, unknown>): Array<Record<string, unknown>> {
  const preparedmapping = prepareRepair(mapping);
  return resultset.map(row => repairResultSetInternal(row, preparedmapping));
}

export function isValidWRDTag(tag: string): boolean {
  return Boolean(tag.match(/^[A-Z][A-Z0-9_]{0,63}$/) && !tag.endsWith('_'));
}
