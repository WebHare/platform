# Code Contexts
The goal of WebHare contexts is to mimic the ease-of-use of HareScript, where each VM has its own 'primary' transaction object (and other context such as the
current user, language setting...) and manages the transactions itself. HareScript VMs are much lighter-weight than JavaScript workers
(they use a m:n threading model and probably have better code caching) so creating and destroying them for every web request is not an issue.

JavaScript V8 workers use a 1:1 threading model and are much more expensive to create and destroy. So we need something simpler

## Architecture
We're using AsyncLocalStorage as the base for our context implementation (and hope to be able to switch to [AsyncContext](https://github.com/tc39/proposal-async-context)
in the future). This API helps keep context data as the code goes through callbacks. However, it doesn't do anything for standard callbacks, eg this
doesn't work:

```javascript
const resolved = als.run(new WebHareScriptContext, () => {
  console.log("inside my store", als.getStore());
  return () => console.log("deeper! store", als.getStore());
```

The second log statement will report `null`. See also https://github.com/nodejs/node/issues/41285

So any such callback needs to be wrapped using `CodeContext.wrap`.

## Rejected alternatives

### Running `require` inside a new context
Something like:

```javascript
vm.runInNewContext(`
  console.log("Passed context:", __webharecontext);
  require(__tocall.lib)[__tocall.functionname](args)`, { __webharecontext: {x:42}, __tocall, args, console, require});
```

this doesn't work. The require comes from your top level context and (ignoring caching etc) it basically does this:

```javascript
const code = readFileSync(lib);
eval`(function(exports, require, module, __filename, __dirname) { ${code}\r\n})`) (â€¦);
```

Simplified: each function object has a global object ('Realm') bound to it. It's bound to the require you passed into
the new context, which will pass that along to eval, which will pass that along to the code it evaluates and the functions
generated by that code will still be in the same Realm you started with. [module.createRequire](https://nodejs.org/api/module.html#modulecreaterequirefilename)
won't help either - you'd need to pass `module` into the new script, still bound to the toplevel Realm, and that new
require will still be associated with that Realm.

### vm.runInNewContext
We have to build our own implementation of require and its cache to have a require evaluating the newly generated code inside the new context:

```javascript
  require(lib: string) {
    if ((module as ModuleWithIsBuiltin).isBuiltin(lib))
      return require(lib); //builtin

    //Loads library into this context
    const sourcelib = this.loadstack.slice(-1)[0]?.lib || "<root>";
    const finallib = require.resolve(lib, { paths: [path.dirname(sourcelib), ...(this.loadstack.slice(-1)[0]?.paths ?? [])] });
    if (this.modulecache[finallib]) {
      return this.modulecache[finallib].exports;
    }

    let code = (fs.readFileSync(finallib, 'utf8'));
    code = transpile(code, finallib);
    code = `(function(exports, require, module, __filename, __dirname) {\r\n${code}\r\n})`;

    const script = new vm.Script(code, { filename: finallib });

    try {
      this.loadstack.push({ lib: finallib, paths: require.resolve.paths(finallib) ?? [] });
      const _exports = {}, _require = this.require.bind(this), _module = { exports: _exports };
      this.modulecache[finallib] = _module; //register first to deal with circular dependencies
      script.runInContext(this.context)(_exports, _require, _module, finallib, path.dirname(finallib));
      return _module.exports;
    } finally {
      this.loadstack.pop();
    }
  }
```

This has some major drawbacks:
- we evaluate the code for every context to ensure proper binding. There may be caching opportunities but I doubt we'll be able
  to resolve all performance issues unless we reuse previously compiled contexts. And that would bring along it's own subtle issues
- no support for sourcemaps in `vm.Script` which hinders the use of TypeScript (https://github.com/nodejs/node/issues/8042)

### ShadowRealms
They look promising but aren't finished. However, you can only pass `PrimitiveValueOrCallable`s over the realm boundaries - ie,
you can't even *try* to pass a `pg` connection cached inside a pool to a new context. All complex resource sharing will require
some form of proxying, message passing or rebuilding objects with bound functions (which can then still only take primivites or
bound functions, but no objects). It looks like ShadowRealm gives more isolation than we need (and thus less chance of optimization)
