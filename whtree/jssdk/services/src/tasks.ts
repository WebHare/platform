import { PlatformDB } from "@mod-platform/generated/whdb/platform";
import { loadlib } from "@webhare/harescript";
import { convertWaitPeriodToDate, sleep, type WaitPeriod } from "@webhare/std";
import { broadcastOnCommit, db, isWorkOpen, onFinishWork } from "@webhare/whdb";
import { openBackendService, subscribeToEventStream } from "@webhare/services";
import { getStackTrace, type StackTrace } from "@webhare/js-api-tools";
import { checkModuleScopedName } from "./naming";

interface TaskResponseFinished {
  type: "finished";
  result: object | null;
}

interface TaskResponseCancelled {
  type: "cancelled";
  result: object | null;
  error: string;
}

interface TaskResponseFailed {
  type: "failed";
  result: object | null;
  error: string;
}

interface TaskResponseFailedTemporarily {
  type: "failedtemporarily";
  result: object | null;
  error: string;
  nextretry?: Date | null;
  trace: StackTrace;
}

interface TaskResponseRestart {
  type: "restart";
  when: Date;
  newData?: unknown;
  auxData?: unknown;
  result: null;
}

export type TaskResponse = TaskResponseFinished | TaskResponseCancelled | TaskResponseFailed | TaskResponseFailedTemporarily | TaskResponseRestart;

export type TaskFunction = (req: TaskRequest<unknown>) => Promise<TaskResponse>;

export class TaskRequest<TaskDataType, TaskResultType extends object | null = object | null> {
  constructor(readonly taskid: number, readonly numFailures: number, readonly taskdata: TaskDataType) {
  }

  /** @deprecated synchronous cancellation should be generally be replaced with resolveByCompletion or resolveByPermanentFailure */
  resolveByCancellation(retval: TaskResultType, error: string): TaskResponse {
    return { type: "cancelled", result: retval, error: error };
  }

  resolveByCompletion(result?: TaskResultType): TaskResponse {
    return { type: "finished", result: result ?? null };
  }

  resolveByPermanentFailure(error: string, { result }: { result?: object } = {}): TaskResponse {
    return { type: "failed", error: error || "Unspecified permanent failure", result: result ?? null };
  }

  resolveByTemporaryFailure(error: string, { result, nextRetry }: { result?: object; nextRetry?: Date | null } = {}): TaskResponse {
    return { type: "failedtemporarily", error: error || "Unspecified temporary failure", result: result ?? null, nextretry: nextRetry ?? null, trace: getStackTrace() } satisfies TaskResponseFailedTemporarily;
  }

  resolveByRestart(when: Date, { newData, auxData }: { newData?: unknown; auxData?: unknown } = {}): TaskResponse {
    return { type: "restart", when, newData, auxData, result: null };
  }
}

export interface ScheduleTaskOptions {
  /** Auxilliary data cells. This will be merged with the task data when passed to the task, but stored separately to avoid the 4K limit  */
  auxdata?: unknown;
  /** Pre-allocated id of the task to create (must be generated by `nextVal("system.managedtasks", "id")`) */
  taskId?: number;
  /** Time limit for the task, 0 for no limit. If provided, overrides the limit set with the task type. */
  timeout?: number;
  /** Scheduled date after which the tasks can be executed */
  notBefore?: Date;
}

/** Schedule a managed task if this transaction commits
 *
 *  A managed task, once scheduled, will always attempt to complete, and is restarted when it or the task manager fails.
          Managed tasks are often used for 'after effects' which can take a lot of time, eg the actual deletion of a WRD schema.
          A managed task will be attempted even if the script that queued it exits before
          the task starts. If work is open, the task will be queued as soon as the current work is committed, and will not
          be queued if the work is rolled back.
    @param tasktype - Type of the task to schedule (eq: wrd:deleteschemas) - refers to to the servicemanager:managedtask in the moduledefinition
    @param taskdata - Task data, as specified by the task. The data must fit in 4K of HSON data
    @returns id of this task. This id is a database id and can be used by later scripts
*/
export async function scheduleTask(tasktype: string, taskdata?: unknown, options?: ScheduleTaskOptions): Promise<number> {
  return await loadlib("mod::system/lib/tasks.whlib").scheduleManagedTask(tasktype, taskdata, options) as number;
}

/** Wait for timed tasks to finish
    @param taskname - Task to wait for
    @param deadline - Wait until
    - debug Print debuginfo if waiting
    - allowMissing Don't fail if the task isn't registered (yet)
    @returns True if the task finished, false if timed out
*/
async function waitForTimedTask(taskname: string, deadline: WaitPeriod, options?: { allowMissing?: boolean; expectLastRunAfter?: Date }): Promise<boolean> {
  checkModuleScopedName(taskname);
  const matchtag = taskname.replace(":", ".");

  // executetasks now broadcasts this event whenever a task completes, so we know when to rescan the list
  using taskUpdatedStream = subscribeToEventStream("system:internal.taskcompleted");
  const abort = new AbortController;
  const deadlinePromise = sleep(deadline, { signal: abort.signal }).then(() => false);

  try {
    for (; ;) {
      //Get current state
      const taskstate = await db<PlatformDB>().selectFrom("system.tasks").select(["id", "lastrun", "nexttime", "error"]).where("tag", "=", matchtag).executeTakeFirst();
      if (!options?.allowMissing && !taskstate)
        throw new Error(`No such timed task '${taskname}' registered`);

      if (taskstate &&
        taskstate.lastrun && //if it never ran, it's not done
        (!options?.expectLastRunAfter || taskstate.lastrun >= options.expectLastRunAfter) &&
        taskstate.nexttime > new Date) //it's not scheduled for the future (TODO should we care if expectLastRunAfter is set? )
        return true; //Then it appears true, TODO though it would be better to set these things up as managed tasks and just wait for that ID

      if (!taskstate?.nexttime)
        throw new Error(`No such timed task '${taskname}' scheduled`);

      if (await Promise.race([taskUpdatedStream.next(), deadlinePromise]) === false)
        return false;
    }
  } finally {
    abort.abort(); //ensure the deadline sleep is aborted
  }
}

/** Schedule a timed task to run.
 *
    The task will be run at the specified time, or if not set, as soon as possible. If another request is made to
    run the task even earlier, or if the tasks 'runat' causes it to run, this request will be ignored (ie you cannot
    request multiple runs of a task by repeatedly calling this function)

    @param taskname - module:tag of the task
    @param options - when: When to run the task (if not set, asap)
                     allowMissing: Don't fail if the task isn't registered (yet)
                     onComplete: Callback to call when the task is completed. (remember to commit or the callback will never fire)
    @returns An object with taskDone(), which returns a promise that resolves when the task is completed
*/
export async function scheduleTimedTask(taskname: string, options?: { when?: Date; allowMissing?: boolean }): Promise<{
  get taskDone(): Promise<void>;
}> {
  const queuedat = new Date;
  await loadlib("mod::system/lib/tasks.whlib").scheduleTimedTask(taskname, { ...options, onComplete: undefined });
  //FIXME actually we should log some sort of iteration count/token - or even better, a managed task id? to be sure we're waiting for *our* scheduled task
  //      this might race against another task queueing the same task, but running just before our commit

  return {
    get taskDone(): Promise<void> {
      if (isWorkOpen())
        throw new Error("onCompletion should not be used with open work"); //too easy to deadlock yourself, so deny for now

      return waitForTimedTask(taskname, 86400 * 1000, { allowMissing: options?.allowMissing, expectLastRunAfter: queuedat }).then(result => {
        if (!result)
          throw new Error(`Timed task '${taskname}' did not finish in time`);
      });
    }
  };
}

export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: false }): Promise<T>;
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: boolean }): Promise<T | null>;

/** Get the result of a scheduled task
 * @param taskId - Task to look up
 * @param timeout - How long to wait for the task to finish
 * @param options - acceptCancel: Don't throw if the task is cancelled
 *                  acceptTempFailure: Don't throw if the task is temporarily failed but will still retry
 *                  acceptTimeout: Return null in case of timeout (by default, throws)
 * @returns The result of the task
 * @throws if the task is cancelled, failed or timed out
 */
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: {
  acceptCancel?: boolean;
  acceptTempFailure?: boolean;
  acceptTimeout?: boolean;
}): Promise<T | null> {
  options = {
    acceptCancel: false,
    acceptTempFailure: false,
    acceptTimeout: false,
    ...options
  };

  const maxwait = convertWaitPeriodToDate(timeout);
  return await loadlib("mod::system/lib/tasks.whlib").retrieveManagedTaskResult(taskId, maxwait, options) as T;
}

/// Handles cancelling running tasks after the commit
class TaskCancelHandler {
  static uniqueTag = Symbol("system:tasks.TaskCancelHandler");
  deferred = Promise.withResolvers<void>();

  async onCommit() {
    try {
      using service = await openBackendService("system:managedqueuemgr", [-1]);
      await service.stopCancelledTasks();
      this.deferred.resolve();
    } catch (e) {
      this.deferred.reject(e as Error);
    }
  }
}

/** Cancel managed tasks.
    @remarks Schedules cancellation of the specified managed tasks. When the promise returned by this function resolves, the
    changes have been written to the database. If any of the tasks are running, they will be stopped after the commit. After
    all running tasks have been stopped, the `runningTasksStopped` promise returned by this function will be fulfilled.
    @param taskids - Ids of the tasks that must be cancelled
    @returns - Promise that resolves when the cancellation has written to the database. The promise returned by
    `runningTasksStopped()` will be resolved when all running tasks have been stopped.
*/
export async function cancelManagedTasks(taskIds: number[]): Promise<{ runningTasksStopped(): Promise<void> }> {
  if (!taskIds.length)
    return { runningTasksStopped: () => Promise.resolve() };

  const seenTaskTypes = (await db<PlatformDB>().selectFrom("system.managedtasks").select("tasktype").where("id", "in", taskIds).distinct().execute()).map(task => task.tasktype);
  await db<PlatformDB>()
    .updateTable("system.managedtasks")
    .set({ iscancelled: true, finished: new Date(), lasterrors: "Cancelled by CancelManagedTasks" })
    .where("id", "in", taskIds)
    .execute();

  broadcastOnCommit("system:managedtasks.any.changes");
  for (const taskType of seenTaskTypes.sort())
    broadcastOnCommit(`system:managedtasks.${taskType}.changes`);

  // Make sure the commit handler is installed
  const handler = onFinishWork(() => new TaskCancelHandler, { uniqueTag: TaskCancelHandler.uniqueTag });

  return { runningTasksStopped: () => handler.deferred.promise };
}
