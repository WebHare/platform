import type { PlatformDB } from "@mod-platform/generated/db/platform";
import { appendToArray, convertFlexibleInstantToDate, convertWaitPeriodToDate, regExpFromWildcards, sleep, throwError, type FlexibleInstant, type WaitPeriod } from "@webhare/std";
import { broadcastOnCommit, db, isWorkOpen, nextVals, onFinishWork, uploadBlob } from "@webhare/whdb";
import { openBackendService } from "@webhare/services/src/backendservice.ts";
import { subscribeToEventStream } from "@webhare/services/src/backendevents.ts";
import { getStackTrace, type StackTrace } from "@webhare/js-api-tools";
import { checkModuleScopedName } from "./naming";
import { getExtractedConfig } from "@mod-system/js/internal/configuration";
import { decodeHSON, decodeHSONorJSONRecord, defaultDateTime, encodeHSON } from "@webhare/hscompat";
import { logDebug, WebHareBlob } from "@webhare/services";
import type { IPCMarshallableData } from "@webhare/hscompat/hson";
import { debugFlags } from "@webhare/env";
import { prependHSStackTrace, type ExceptionTrace } from "@webhare/harescript/src/wasm-support";

interface TaskResponseFinished {
  type: "finished";
  result: object | null;
}

interface TaskResponseCancelled {
  type: "cancelled";
  result: object | null;
  error: string;
}

interface TaskResponseFailed {
  type: "failed";
  result: object | null;
  error: string;
}

interface TaskResponseFailedTemporarily {
  type: "failedtemporarily";
  result: object | null;
  error: string;
  nextretry?: Date | null;
  trace: StackTrace;
}

interface TaskResponseRestart {
  type: "restart";
  when: Date;
  newData?: unknown;
  auxData?: unknown;
  result: null;
}

export type TaskResponse = TaskResponseFinished | TaskResponseCancelled | TaskResponseFailed | TaskResponseFailedTemporarily | TaskResponseRestart;

export type TaskFunction = (req: TaskRequest<unknown>) => Promise<TaskResponse>;

export class TaskRequest<TaskDataType, TaskResultType extends object | null = object | null> {
  constructor(readonly taskid: number, readonly numFailures: number, readonly taskdata: TaskDataType) {
  }

  /** @deprecated synchronous cancellation should be generally be replaced with resolveByCompletion or resolveByPermanentFailure */
  resolveByCancellation(retval: TaskResultType, error: string): TaskResponse {
    return { type: "cancelled", result: retval, error: error };
  }

  resolveByCompletion(result?: TaskResultType): TaskResponse {
    return { type: "finished", result: result ?? null };
  }

  resolveByPermanentFailure(error: string, { result }: { result?: object } = {}): TaskResponse {
    return { type: "failed", error: error || "Unspecified permanent failure", result: result ?? null };
  }

  resolveByTemporaryFailure(error: string, { result, nextRetry }: { result?: object; nextRetry?: Date | null } = {}): TaskResponse {
    return { type: "failedtemporarily", error: error || "Unspecified temporary failure", result: result ?? null, nextretry: nextRetry ?? null, trace: getStackTrace() } satisfies TaskResponseFailedTemporarily;
  }

  resolveByRestart(when: Date, { newData, auxData }: { newData?: unknown; auxData?: unknown } = {}): TaskResponse {
    return { type: "restart", when, newData, auxData, result: null };
  }
}

const TaskPriorityMap = {
  "background": 100,
  "normal": 0,
  "interactive": -100,
  "update": -200,
  "updateinteractive": -300
} as const;
export interface ScheduleTaskOptions {
  /** Auxilliary data cells. This will be merged with the task data when passed to the task, but stored separately to avoid the 4K limit  */
  auxdata?: IPCMarshallableData;
  /** Time limit for the task, 0 for no limit. If provided, overrides the limit set with the task type. */
  timeout?: number;
  /** Scheduled date after which the tasks can be executed */
  notBefore?: FlexibleInstant;
  /** Pre-allocated ids of the task to create. Must be generated by allocateTaskIds invoked in the same transaction */
  taskIds?: number[];
  /** Override the default task priority for this task type. Allowed values: '', 'background', 'normal', 'interactive', 'update', 'updateinteractive'. */
  priority?: keyof typeof TaskPriorityMap;
}

export interface ScheduleMultipleTaskOptions extends ScheduleTaskOptions {
}

export function allocateTaskIds(count: number): Promise<number[]> {
  return nextVals("system.managedtasks.id", count);
}

/** Schedule multiple managed tasks

    Allows you to schedule multiple managed tasks, as long as they share the same options. This allows the database
    to share the auxdata blobs, eg when scheduling an outgoing mail task with multiple receivers.

    @param tasktype - Type of the task (module:tasktype as definied in a moduledefinition)
    @param taskdatas - Task data records (as specified by the task). The data must fit in 4K of HSON data
    @param options - Task options
    @returns ID of the scheduled tasks in the taskdatas order */
export async function scheduleTasks(tasktype: string, taskdatas: IPCMarshallableData[], options?: ScheduleTaskOptions): Promise<number[]> {
  if (!isWorkOpen())
    throw new Error("scheduleTasks must be invoked with open work");

  const taskinfo = getExtractedConfig("tasks").tasktypes[tasktype] ?? throwError(`No such task type '${tasktype}' registered`);

  //TODO need to move to a key/value system where the TaskType knows which keys are expected, which keys must go to aux and perhaps also which keys are updateable
  const auxdata = options?.auxdata ? WebHareBlob.from(encodeHSON(options.auxdata)) : null;
  const now = new Date;
  const taskids: number[] = [...options?.taskIds ?? []];
  if (taskids.length < taskdatas.length)
    appendToArray(taskids, await allocateTaskIds(taskdatas.length - taskids.length));

  for (const [idx, taskdata] of taskdatas.entries()) {
    const notBeforeDate = convertFlexibleInstantToDate(options?.notBefore);

    await db<PlatformDB>().insertInto("system.managedtasks").values({
      id: taskids[idx],
      creationdate: now,
      nextattempt: notBeforeDate && notBeforeDate > now ? notBeforeDate : now,
      tasktype: tasktype,
      taskdata: encodeHSON(taskdata),
      auxdata: auxdata ? await uploadBlob(auxdata) : null,
      priority: options?.priority ? TaskPriorityMap[options?.priority] ?? 0 : 0,
      timeout: options?.timeout ?? taskinfo.timeout,
      notbefore: notBeforeDate ?? defaultDateTime,
      workertype: 0,
      finished: defaultDateTime,
      lasterrors: "",
      iscancelled: false,
      failures: 0,
      stacktrace: "",
      shortretval: "",
      iterations: 0
    }).execute();

    if (debugFlags.que)
      logDebug("system:schedulemanagedtask", { tasktype, options, trace: getStackTrace(), taskid: taskids[idx], taskdata });
  }

  broadcastOnCommit("system:managedtasks.any.new", { taskids });
  broadcastOnCommit(`system:managedtasks.${tasktype}.new`, { taskids });
  return taskids;
}

interface ListTasksOptions {
  /** createdafter Only return taskscreated on or after this date */
  createdAfter?: FlexibleInstant;
  /** Only return pending (not yet finally complete or failed) tasks */
  onlyPending?: boolean;
}

/** List managed tasks
    @param type - Type of the task (wildcards accepted)
    @param searchparameters - Search parameters
    @returns List of tasks
*/
export async function listTasks(type: string, searchparameters?: ListTasksOptions): Promise<Array<{
  id: number;
  created: Temporal.Instant;
  type: string;
}>> {

  let query = db<PlatformDB>().
    selectFrom("system.managedtasks").
    select(["id", "creationdate", "tasktype"]).
    where("tasktype", "like", type);

  if (searchparameters?.onlyPending)
    query = query.where("finished", "=", defaultDateTime);
  if (searchparameters?.createdAfter)
    query = query.where("creationdate", ">=", convertFlexibleInstantToDate(searchparameters.createdAfter));

  const results = await query.execute();
  return results.map(task => ({
    id: task.id,
    created: task.creationdate.toTemporalInstant(),
    type: task.tasktype
  }));
}

/** Schedule a managed task if this transaction commits
 *
 *  A managed task, once scheduled, will always attempt to complete, and is restarted when it or the task manager fails.
          Managed tasks are often used for 'after effects' which can take a lot of time, eg the actual deletion of a WRD schema.
          A managed task will be attempted even if the script that queued it exits before
          the task starts. If work is open, the task will be queued as soon as the current work is committed, and will not
          be queued if the work is rolled back.
    @param tasktype - Type of the task to schedule (eq: wrd:deleteschemas) - refers to to the servicemanager:managedtask in the moduledefinition
    @param taskdata - Task data, as specified by the task. The data must fit in 4K of HSON data
    @returns id of this task. This id is a database id and can be used by later scripts
*/
export async function scheduleTask(tasktype: string, taskdata?: IPCMarshallableData, options?: ScheduleTaskOptions): Promise<number> {
  return (await scheduleTasks(tasktype, [taskdata ?? {}], options))[0];
}

/** Wait for timed tasks to finish
    @param taskname - Task to wait for
    @param deadline - Wait until
    - debug Print debuginfo if waiting
    - allowMissing Don't fail if the task isn't registered (yet)
    @returns True if the task finished, false if timed out
*/
async function waitForTimedTask(taskname: string, deadline: WaitPeriod, options?: { allowMissing?: boolean; expectLastRunAfter?: Date }): Promise<{
  completed: boolean;
  errorMessage: string;
}> {
  checkModuleScopedName(taskname);
  if (isWorkOpen())
    throw new Error("waitForTimedTask cannot be invoked with open work");

  const matchtag = taskname.replace(":", ".");

  // executetasks now broadcasts this event whenever a task completes, so we know when to rescan the list
  using taskUpdatedStream = subscribeToEventStream("system:internal.taskcompleted");
  const abort = new AbortController;
  const deadlinePromise = sleep(deadline, { signal: abort.signal }).then(() => false);

  try {
    for (; ;) {
      //Get current state
      const taskstate = await db<PlatformDB>().selectFrom("system.tasks").select(["id", "lastrun", "nexttime", "error"]).where("tag", "=", matchtag).executeTakeFirst();
      if (!options?.allowMissing && !taskstate)
        throw new Error(`No such timed task '${taskname}' registered`);

      if (taskstate &&
        taskstate.lastrun && //if it never ran, it's not done
        (!options?.expectLastRunAfter || taskstate.lastrun >= options.expectLastRunAfter) &&
        taskstate.nexttime > new Date) //it's not scheduled for the future (TODO should we care if expectLastRunAfter is set? )
        return { completed: true, errorMessage: taskstate.error }; //Then it appears true, TODO though it would be better to set these things up as managed tasks and just wait for that ID

      if (!taskstate?.nexttime)
        throw new Error(`No such timed task '${taskname}' scheduled`);

      if (await Promise.race([taskUpdatedStream.next(), deadlinePromise]) === false)
        return { completed: false, errorMessage: "" };
    }
  } finally {
    abort.abort(); //ensure the deadline sleep is aborted
  }
}

/** Schedule a timed task to run.
 *
    The task will be run at the specified time, or if not set, as soon as possible. If another request is made to
    run the task even earlier, or if the tasks 'runat' causes it to run, this request will be ignored (ie you cannot
    request multiple runs of a task by repeatedly calling this function)

    @param taskname - module:tag of the task
    @param options - when: When to run the task (if not set, asap)
    @returns An object with taskDone(), which returns a promise that resolves when the task is completed
*/
export async function scheduleTimedTask(taskname: string, options?: { when?: FlexibleInstant/*; allowMissing?: boolean*/ }): Promise<{
  get taskDone(): Promise<void>;
}> {
  //TODO can we elimienate allowMissing? it's mostly an inconsistency with moduledefs (consult extracts?) or a startup issue (insert it ourselves? fix startup ordering?)
  checkModuleScopedName(taskname);
  if (!isWorkOpen())
    throw new Error("scheduleTimedTask must be invoked with open work");

  const dbtag = taskname.replaceAll(":", ".");
  const taskinfo = await db<PlatformDB>().selectFrom("system.tasks").select(["nexttime", "id", "inapplicable"]).where("tag", "=", dbtag).executeTakeFirst();
  if (!taskinfo) {
    // if (options?.allowMissing)
    //   return null;
    throw new Error(`No such timed task '${taskname}' registered`);
  }

  /* TODO HS used a finish handler to dedupe schedledtasks (which also unexpectedly separate reschedules from the original commit)
     but i'd rather avoid that and bet on having unique managed tasks first, and handle scheduledtasks through those tasks */
  const queuedat = new Date;
  const when = options?.when ? convertFlexibleInstantToDate(options?.when) : queuedat;
  const updateTask = (taskinfo.nexttime.getTime() === defaultDateTime.getTime() || taskinfo.nexttime.getTime() > when.getTime())
    //inapplicable tasks? move time forward when in the past, easier when developing - you can see times change)
    || (taskinfo.inapplicable && taskinfo.nexttime.getTime() < Date.now());

  if (updateTask) {
    await db<PlatformDB>().
      updateTable("system.tasks").
      where("id", "=", taskinfo.id).
      set({ nexttime: when }).
      execute();

    broadcastOnCommit("system:internal.scantasks");
  }

  if (debugFlags.que)
    logDebug("system:scheduletimedtask", { taskname, options, updateTask, trace: getStackTrace() });

  //FIXME actually we should log some sort of iteration count/token - or even better, a managed task id? to be sure we're waiting for *our* scheduled task
  //      this might race against another task queueing the same task, but running just before our commit

  return {
    get taskDone(): Promise<void> {
      if (isWorkOpen())
        throw new Error("onCompletion should not be used with open work"); //too easy to deadlock yourself, so deny for now

      return waitForTimedTask(taskname, 86400 * 1000, { /*allowMissing: options?.allowMissing,*/ expectLastRunAfter: queuedat }).then(result => {
        if (!result.completed)
          throw new Error(`Timed task '${taskname}' did not finish in time`);
        if (result.errorMessage)
          throw new Error(`Timed task '${taskname}' failed: ${result.errorMessage}`);
      });
    }
  };
}

interface RetrieveTaskResultOptions {
  acceptCancel?: boolean;
  acceptTempFailure?: boolean;
  acceptTimeout?: boolean;
  timeout?: WaitPeriod;
}

//legacy callers only use 'number' in practice, no WaitPeriod, and at most acceptTimeout as option, so easy to recognize
/** @deprecated WH5.7 expects timeout to be combined into the options parameter */
export async function retrieveTaskResult<T>(taskId: number, timeout: number, options?: { acceptTimeout: false }): Promise<T>;
/** @deprecated WH5.7 expects timeout to be combined into the options parameter */
export async function retrieveTaskResult<T>(taskId: number, timeout: number, options?: { acceptTimeout: boolean }): Promise<T | undefined>;

export async function retrieveTaskResult<T>(taskId: number, options: RetrieveTaskResultOptions & { acceptTimeout: true }): Promise<T | undefined>;
export async function retrieveTaskResult<T>(taskId: number, options?: RetrieveTaskResultOptions): Promise<T>;

/** Get the result of a scheduled task
 * @param taskId - Task to look up
 * @param timeout - How long to wait for the task to finish
 * @param options - acceptCancel: Don't throw if the task is cancelled
 *                  acceptTempFailure: Don't throw if the task is temporarily failed but will still retry
 *                  acceptTimeout: Return null in case of timeout (by default, throws)
 * @returns The result of the task
 * @throws if the task is cancelled, failed or timed out
 */
export async function retrieveTaskResult<T>(taskId: number, options?: RetrieveTaskResultOptions | number, options_old?: RetrieveTaskResultOptions): Promise<T | undefined> {
  if (typeof options === "number") {
    options = { ...options_old, timeout: options };
  }
  const maxwait = convertWaitPeriodToDate(options?.timeout ?? Infinity);

  options = {
    acceptCancel: false,
    acceptTempFailure: false,
    acceptTimeout: false,
    ...options
  };
  delete options.timeout;

  if (isWorkOpen())
    throw new Error("retrieveTaskResult cannot be invoked with open work");

  using listener = subscribeToEventStream(`system:managedtasks.any.${taskId}`);
  void (listener);

  for (; ;) {
    const taskinfo = await db<PlatformDB>().selectFrom("system.managedtasks").selectAll().where("id", "=", taskId).executeTakeFirst();
    if (!taskinfo)
      throw new Error(`No such task #${taskId}`);

    const taskdone = taskinfo.finished.getTime() !== defaultDateTime.getTime();
    if (taskinfo.lasterrors) {  //something is up)
      if (taskinfo.iscancelled) {
        if (!options.acceptCancel)
          throw new Error(`Task ${taskinfo.tasktype} #${taskId} has been cancelled: ${taskinfo.lasterrors}`);
      } else if (taskdone || !options.acceptTempFailure) {
        const err = new Error(`Task ${taskinfo.tasktype} #${taskId} has${taskdone ? " permanently" : ""} failed: ${taskinfo.lasterrors}`);
        if (taskinfo.stacktrace) {
          const trace = decodeHSON(taskinfo.stacktrace) as ExceptionTrace;
          prependHSStackTrace(err, trace);
        }
        throw err;
      }
    }

    if (taskdone)
      return !taskinfo.shortretval ? undefined : decodeHSONorJSONRecord(taskinfo.shortretval === "long" ? await taskinfo.longretval!.text() : taskinfo.shortretval) as T;

    if (Date.now() > maxwait.getTime())
      if (options.acceptTimeout)
        return undefined;
      else
        throw new Error(`Timeout waiting for completion of task ${taskinfo.tasktype} #${taskId}`);
  }
}

/// Handles cancelling running tasks after the commit
class TaskCancelHandler {
  static uniqueTag = Symbol("system:tasks.TaskCancelHandler");
  deferred = Promise.withResolvers<void>();

  async onCommit() {
    try {
      using service = await openBackendService("system:managedqueuemgr", [-1]);
      await service.stopCancelledTasks();
      this.deferred.resolve();
    } catch (e) {
      this.deferred.reject(e as Error);
    }
  }
}

/** Cancel managed tasks.
    @remarks Schedules cancellation of the specified managed tasks. When the promise returned by this function resolves, the
    changes have been written to the database. If any of the tasks are running, they will be stopped after the commit. After
    all running tasks have been stopped, the `tasksCancelled` promise returned by this function will be fulfilled.
    @param taskIds - Id or ids of the tasks that must be cancelled
    @returns - Promise that resolves when the cancellation has written to the database. The promise returned by
    `tasksCancelled()` will be resolved when all running tasks have been stopped.
*/
export async function cancelTask(taskIds: number[]): Promise<{ tasksCancelled(): Promise<void> }> {
  // TODO should we offer a deleteTask like the HS API? But if so, you still need to go through cancellation so at most we'll add a {delete} option here?
  if (!isWorkOpen())
    throw new Error("cancelTask cannot be invoked without open work");

  taskIds = typeof taskIds === "number" ? [taskIds] : taskIds;
  if (!taskIds.length)
    return { tasksCancelled: () => Promise.resolve() };

  const seenTaskTypes = (await db<PlatformDB>().selectFrom("system.managedtasks").select("tasktype").where("id", "in", taskIds).distinct().execute()).map(task => task.tasktype);
  await db<PlatformDB>()
    .updateTable("system.managedtasks")
    .set({ iscancelled: true, finished: new Date(), lasterrors: "Cancelled by cnacelTask" })
    .where("id", "in", taskIds)
    .execute();

  broadcastOnCommit("system:managedtasks.any.changes");
  for (const taskType of seenTaskTypes.sort())
    broadcastOnCommit(`system:managedtasks.${taskType}.changes`);

  // Make sure the commit handler is installed
  const handler = onFinishWork(() => new TaskCancelHandler, { uniqueTag: TaskCancelHandler.uniqueTag });

  return {
    tasksCancelled: () => handler.deferred.promise,
  };
}

/** @deprecated Renamed to cancelTask in WH5.7 */
export async function cancelManagedTasks(taskIds: number[]): Promise<{ runningTasksStopped(): Promise<void> }> {
  const res = await cancelTask(taskIds);
  return { runningTasksStopped: () => res.tasksCancelled() };
}

interface DescribedTask {
  /** Creation date of the task */
  created: Temporal.Instant;
  /** Next time the task will be run */
  nextAttempt: Temporal.Instant;
  /** Type of the task (format: modulename:tasktypename) */
  type: string;
  /** Datetime when the task was marked as finished */
  finished: Temporal.Instant | null;
  /** If not empty, errors the task returned */
  lastErrors: string;
  /** Stack trace with errors */
  trace: StackTrace;
  /** Return value of the task */
  result: object | null;
  /** Task data */
  data: IPCMarshallableData;
  /** Metadata of this task */
  metadata: Record<string, unknown>;
  /** Number of failures */
  failures: number;
  /** Scheduled date after which the tasks can be executed */
  notBefore: Temporal.Instant | null;
}

/** Describes a managed task
    @param taskid - Id of the managed task
    @param options - allowMissing: Don't throw if the task isn't found
    @returns Managed task info */

export async function describeTask(taskid: number, options: { allowMissing: true }): Promise<DescribedTask | null>;
export async function describeTask(taskid: number, options?: { allowMissing: boolean }): Promise<DescribedTask>;

export async function describeTask(taskid: number, options?: { allowMissing: boolean }): Promise<DescribedTask | null> {
  const taskinfo = await db<PlatformDB>().selectFrom("system.managedtasks").selectAll().where("id", "=", taskid).executeTakeFirst();
  if (!taskinfo)
    if (options?.allowMissing)
      return null;
    else
      throw new Error(`No such task #${taskid}`);

  const data = decodeHSON(taskinfo.taskdata);
  if (taskinfo.auxdata) //TODO we shouldn't decode auxdata unless explicitly requested, or just have a separate API for it. OR have the requester specify the fields
    Object.assign(data as object, decodeHSON(await taskinfo.auxdata.text()) as IPCMarshallableData);

  const rawMetadata = await db<PlatformDB>().selectFrom("system.managedtasksmeta").selectAll().where("task", "=", taskid).execute();
  const metadata = Object.fromEntries(rawMetadata.map(row => [row.metakey, decodeHSON(row.metavalue)]));

  const descr: DescribedTask = {
    created: taskinfo.creationdate.toTemporalInstant(),
    nextAttempt: taskinfo.nextattempt.toTemporalInstant(),
    type: taskinfo.tasktype,
    finished: taskinfo.finished && taskinfo.finished.getTime() > defaultDateTime.getTime() ? taskinfo.finished.toTemporalInstant() : null,
    lastErrors: taskinfo.lasterrors,
    trace: [],//FIXME taskinfo.stracktrace
    result: taskinfo.shortretval ? decodeHSONorJSONRecord(taskinfo.shortretval) : null,
    data: data,
    metadata,
    failures: taskinfo.failures,
    notBefore: taskinfo.notbefore ? taskinfo.notbefore.toTemporalInstant() : null
  };
  return descr;
}

/** Retry pending managed tasks by ID or tyoe
    @param tasks - ID(s) of tasks to retry or a type maks
*/
export async function retryTask(tasks: number | number[] | string): Promise<void> {
  const now = new Date;
  let flushtasksquery = db<PlatformDB>().
    selectFrom("system.managedtasks").
    select(["id", "tasktype", "nextattempt", "notbefore"]).
    where("nextattempt", ">=", now).
    where("notbefore", "<=", now).
    where("finished", "=", defaultDateTime);
  if (typeof tasks === "number")
    flushtasksquery = flushtasksquery.where("id", "=", tasks);
  else if (typeof tasks === "string")
    flushtasksquery = flushtasksquery.where("tasktype", "~", regExpFromWildcards(tasks).source);
  else
    flushtasksquery = flushtasksquery.where("id", "in", tasks);

  const flushtasks = await flushtasksquery.execute();
  if (!flushtasks.length)
    return;

  const seentasktypes = new Set(flushtasks.map(_ => _.tasktype));
  await db<PlatformDB>().
    updateTable("system.managedtasks").
    set({ nextattempt: now }).
    where("id", "in", flushtasks.map(_ => _.id)).
    execute();

  broadcastOnCommit("system:managedtasks.any.changes");
  for (const tasktype of seentasktypes)
    broadcastOnCommit(`system:managedtasks.${tasktype}.changes`);
}
