import { PlatformDB } from "@mod-system/js/internal/generated/whdb/platform";
import { loadlib } from "@webhare/harescript";
import { convertWaitPeriodToDate, createDeferred, type WaitPeriod } from "@webhare/std";
import { broadcastOnCommit, db, onFinishWork, sql } from "@webhare/whdb";
import { openBackendService } from "@webhare/services";

interface TaskResponseFinished {
  type: "finished";
  result: unknown;
}

interface TaskResponseCancelled {
  type: "cancelled";
  result: unknown;
  error: string;
}

interface TaskResponseFailed {
  type: "failed";
  result: unknown;
  error: string;
}

interface TaskResponseFailedTemporarily {
  type: "failedtemporarily";
  result: unknown;
  error: string;
  nextretry?: Date | null;
}

interface TaskResponseRestart {
  type: "restart";
  when: Date;
  newData?: unknown;
  auxData?: unknown;
  result: null;
}

export type TaskResponse = TaskResponseFinished | TaskResponseCancelled | TaskResponseFailed | TaskResponseFailedTemporarily | TaskResponseRestart;

export type TaskFunction = (req: TaskRequest<unknown>) => Promise<TaskResponse>;

export class TaskRequest<TaskDataType, TaskResultType = unknown> {
  readonly taskdata: TaskDataType;
  readonly taskid: number;

  constructor(taskid: number, taskdata: TaskDataType) {
    this.taskid = taskid;
    this.taskdata = taskdata;
  }

  resolveByCancellation(retval: TaskResultType, error: string): TaskResponse {
    return { type: "cancelled", result: retval, error: error };
  }

  resolveByCompletion(result?: TaskResultType): TaskResponse {
    return { type: "finished", result };
  }

  resolveByPermanentFailure(error: string, { result }: { result?: object } = {}): TaskResponse {
    return { type: "failed", error, result };
  }

  resolveByTemporaryFailure(error: string, { result, nextRetry }: { result?: object; nextRetry?: Date | null } = {}): TaskResponse {
    return { type: "failedtemporarily", error, result, nextretry: nextRetry ?? null };
  }

  resolveByRestart(when: Date, { newData, auxData }: { newData?: unknown; auxData?: unknown } = {}): TaskResponse {
    return { type: "restart", when, newData, auxData, result: null };
  }
}

export interface ScheduleTaskOptions {
  /** Auxilliary data cells. This will be merged with the task data when passed to the task, but stored separately to avoid the 4K limit  */
  auxdata?: unknown;
  /** Pre-allocated id of the task to create (must be generated by `nextVal("system.managedtasks", "id")`) */
  taskId: number;
  /** Time limit for the task, 0 for no limit. If provided, overrides the limit set with the task type. */
  timeout: number;
  /** Scheduled date after which the tasks can be executed */
  notBefore: Date;
}

/** Schedule a managed task if this transaction commits
 *
 *  A managed task, once scheduled, will always attempt to complete, and is restarted when it or the task manager fails.
          Managed tasks are often used for 'after effects' which can take a lot of time, eg the actual deletion of a WRD schema.
          A managed task will be attempted even if the script that queued it exits before
          the task starts. If work is open, the task will be queued as soon as the current work is committed, and will not
          be queued if the work is rolled back.
    @param tasktype - Type of the task to schedule (eq: wrd:deleteschemas) - refers to to the servicemanager:managedtask in the moduledefinition
    @param taskdata - Task data, as specified by the task. The data must fit in 4K of HSON data
    @returns id of this task. This id is a database id and can be used by later scripts
*/
export async function scheduleTask(tasktype: string, taskdata?: unknown, options?: ScheduleTaskOptions): Promise<number> {
  return await loadlib("mod::system/lib/tasks.whlib").scheduleManagedTask(tasktype, taskdata, options) as number;
}

/** Schedule a timed task to run.
 *
    The task will be run at the specified time, or if not set, as soon as possible. If another request is made to
    run the task even earlier, or if the tasks 'runat' causes it to run, this request will be ignored (ie you cannot
    request multiple runs of a task by repeatedly calling this function)

    @param taskname - module:tag of the task
    @param options - when: When to run the task (if not set, asap)
                     allowMissing: Don't fail if the task isn't registered (yet)
*/
export async function scheduleTimedTask(taskname: string, options?: { when?: Date; allowMissing?: boolean }): Promise<void> {
  await loadlib("mod::system/lib/tasks.whlib").scheduleTimedTask(taskname, options ?? {});
}

export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: false }): Promise<T>;
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: boolean }): Promise<T | null>;

/** Get the result of a scheduled task
 * @param taskId - Task to look up
 * @param timeout - How long to wait for the task to finish
 * @param options - acceptCancel: Don't throw if the task is cancelled
 *                  acceptTempFailure: Don't throw if the task is temporarily failed but will still retry
 *                  acceptTimeout: Return null in case of timeout (by default, throws)
 * @returns The result of the task
 * @throws if the task is cancelled, failed or timed out
 */
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: {
  acceptCancel?: boolean;
  acceptTempFailure?: boolean;
  acceptTimeout?: boolean;
}): Promise<T | null> {
  options = {
    acceptCancel: false,
    acceptTempFailure: false,
    acceptTimeout: false,
    ...options
  };

  const maxwait = convertWaitPeriodToDate(timeout);
  return await loadlib("mod::system/lib/tasks.whlib").retrieveManagedTaskResult(taskId, maxwait, options) as T;
}

/// Handles cancelling running tasks after the commit
class TaskCancelHandler {
  static uniqueTag = Symbol("system:tasks.TaskCancelHandler");
  deferred = createDeferred<void>();

  async onCommit() {
    try {
      using service = await openBackendService("system:managedqueuemgr", [-1]);
      await service.stopCancelledTasks();
      this.deferred.resolve();
    } catch (e) {
      this.deferred.reject(e as Error);
    }
  }
}

/** Cancel managed tasks.
    @remarks Schedules cancellation of the specified managed tasks. When the promise returned by this function resolves, the
    changes have been written to the database. If any of the tasks are running, they will be stopped after the commit. After
    all running tasks have been stopped, the `runningTasksStopped` promise returned by this function will be fulfilled.
    @param taskids - Ids of the tasks that must be cancelled
    @returns - Promise that resolves when the cancellation has written to the database. The promise returned by
    `runningTasksStopped()` will be resolved when all running tasks have been stopped.
*/
export async function cancelManagedTasks(taskIds: number[]): Promise<{ runningTasksStopped(): Promise<void> }> {
  if (!taskIds.length)
    return { runningTasksStopped: () => Promise.resolve() };

  const seenTaskTypes = (await db<PlatformDB>().selectFrom("system.managedtasks").select("tasktype").where("id", "=", sql`any(${taskIds})`).distinct().execute()).map(task => task.tasktype);
  await db<PlatformDB>()
    .updateTable("system.managedtasks")
    .set({ iscancelled: true, finished: new Date(), lasterrors: "Cancelled by CancelManagedTasks" })
    .where("id", "=", sql`any(${taskIds})`)
    .execute();

  broadcastOnCommit("system:managedtasks.any.changes");
  for (const taskType of seenTaskTypes.sort())
    broadcastOnCommit(`system:managedtasks.${taskType}.changes`);

  // Make sure the commit handler is installed
  const handler = onFinishWork(() => new TaskCancelHandler, { uniqueTag: TaskCancelHandler.uniqueTag });

  return { runningTasksStopped: () => handler.deferred.promise };
}
