import type { PlatformDB } from "@mod-platform/generated/whdb/platform";
import { loadlib } from "@webhare/harescript";
import { appendToArray, convertFlexibleInstantToDate, convertWaitPeriodToDate, sleep, throwError, type FlexibleInstant, type WaitPeriod } from "@webhare/std";
import { broadcastOnCommit, db, isWorkOpen, nextVals, onFinishWork, uploadBlob } from "@webhare/whdb";
import { openBackendService } from "@webhare/services/src/backendservice.ts";
import { subscribeToEventStream } from "@webhare/services/src/backendevents.ts";
import { getStackTrace, type StackTrace } from "@webhare/js-api-tools";
import { checkModuleScopedName } from "./naming";
import { getExtractedConfig } from "@mod-system/js/internal/configuration";
import { defaultDateTime, encodeHSON } from "@webhare/hscompat";
import { logDebug, WebHareBlob } from "@webhare/services";
import type { IPCMarshallableData } from "@webhare/hscompat/hson";
import { debugFlags } from "@webhare/env";

interface TaskResponseFinished {
  type: "finished";
  result: object | null;
}

interface TaskResponseCancelled {
  type: "cancelled";
  result: object | null;
  error: string;
}

interface TaskResponseFailed {
  type: "failed";
  result: object | null;
  error: string;
}

interface TaskResponseFailedTemporarily {
  type: "failedtemporarily";
  result: object | null;
  error: string;
  nextretry?: Date | null;
  trace: StackTrace;
}

interface TaskResponseRestart {
  type: "restart";
  when: Date;
  newData?: unknown;
  auxData?: unknown;
  result: null;
}

export type TaskResponse = TaskResponseFinished | TaskResponseCancelled | TaskResponseFailed | TaskResponseFailedTemporarily | TaskResponseRestart;

export type TaskFunction = (req: TaskRequest<unknown>) => Promise<TaskResponse>;

export class TaskRequest<TaskDataType, TaskResultType extends object | null = object | null> {
  constructor(readonly taskid: number, readonly numFailures: number, readonly taskdata: TaskDataType) {
  }

  /** @deprecated synchronous cancellation should be generally be replaced with resolveByCompletion or resolveByPermanentFailure */
  resolveByCancellation(retval: TaskResultType, error: string): TaskResponse {
    return { type: "cancelled", result: retval, error: error };
  }

  resolveByCompletion(result?: TaskResultType): TaskResponse {
    return { type: "finished", result: result ?? null };
  }

  resolveByPermanentFailure(error: string, { result }: { result?: object } = {}): TaskResponse {
    return { type: "failed", error: error || "Unspecified permanent failure", result: result ?? null };
  }

  resolveByTemporaryFailure(error: string, { result, nextRetry }: { result?: object; nextRetry?: Date | null } = {}): TaskResponse {
    return { type: "failedtemporarily", error: error || "Unspecified temporary failure", result: result ?? null, nextretry: nextRetry ?? null, trace: getStackTrace() } satisfies TaskResponseFailedTemporarily;
  }

  resolveByRestart(when: Date, { newData, auxData }: { newData?: unknown; auxData?: unknown } = {}): TaskResponse {
    return { type: "restart", when, newData, auxData, result: null };
  }
}

const TaskPriorityMap = {
  "background": 100,
  "normal": 0,
  "interactive": -100,
  "update": -200,
  "updateinteractive": -300
} as const;
export interface ScheduleTaskOptions {
  /** Auxilliary data cells. This will be merged with the task data when passed to the task, but stored separately to avoid the 4K limit  */
  auxdata?: IPCMarshallableData;
  /** Time limit for the task, 0 for no limit. If provided, overrides the limit set with the task type. */
  timeout?: number;
  /** Scheduled date after which the tasks can be executed */
  notBefore?: FlexibleInstant;
  /** Pre-allocated ids of the task to create. Must be generated by allocateTaskIds invoked in the same transaction */
  taskIds?: number[];
  /** Override the default task priority for this task type. Allowed values: '', 'background', 'normal', 'interactive', 'update', 'updateinteractive'. */
  priority?: keyof typeof TaskPriorityMap;
}

export interface ScheduleMultipleTaskOptions extends ScheduleTaskOptions {
}

export function allocateTaskIds(count: number): Promise<number[]> {
  return nextVals("system.managedtasks.id", count);
}

/** Schedule multiple managed tasks

    Allows you to schedule multiple managed tasks, as long as they share the same options. This allows the database
    to share the auxdata blobs, eg when scheduling an outgoing mail task with multiple receivers.

    @param tasktype - Type of the task (module:tasktype as definied in a moduledefinition)
    @param taskdatas - Task data records (as specified by the task). The data must fit in 4K of HSON data
    @param options - Task options
    @returns ID of the scheduled tasks in the taskdatas order */
export async function scheduledTasks(tasktype: string, taskdatas: IPCMarshallableData[], options?: ScheduleTaskOptions): Promise<number[]> {
  if (!isWorkOpen())
    throw new Error("scheduledTasks must be invoked with open work");

  const taskinfo = getExtractedConfig("tasks").tasktypes[tasktype] ?? throwError(`No such task type '${tasktype}' registered`);

  //TODO need to move to a key/value system where the TaskType knows which keys are expected, which keys must go to aux and perhaps also which keys are updateable
  const auxdata = options?.auxdata ? WebHareBlob.from(encodeHSON(options.auxdata)) : null;
  const now = new Date;
  const taskids: number[] = [...options?.taskIds ?? []];
  if (taskids.length < taskdatas.length)
    appendToArray(taskids, await allocateTaskIds(taskdatas.length - taskids.length));

  for (const [idx, taskdata] of taskdatas.entries()) {
    const notBeforeDate = convertFlexibleInstantToDate(options?.notBefore);

    await db<PlatformDB>().insertInto("system.managedtasks").values({
      id: taskids[idx],
      creationdate: now,
      nextattempt: notBeforeDate && notBeforeDate > now ? notBeforeDate : now,
      tasktype: tasktype,
      taskdata: encodeHSON(taskdata),
      auxdata: auxdata ? await uploadBlob(auxdata) : null,
      priority: options?.priority ? TaskPriorityMap[options?.priority] ?? 0 : 0,
      timeout: options?.timeout ?? taskinfo.timeout,
      notbefore: notBeforeDate ?? defaultDateTime,
      workertype: 0,
      finished: defaultDateTime,
      lasterrors: "",
      iscancelled: false,
      failures: 0,
      stacktrace: "",
      shortretval: "",
      iterations: 0
    }).execute();

    if (debugFlags.que)
      logDebug("system:schedulemanagedtask", { tasktype, options, trace: getStackTrace(), taskid: taskids[idx], taskdata });
  }

  broadcastOnCommit("system:managedtasks.any.new", { taskids });
  broadcastOnCommit(`system:managedtasks.${tasktype}.new`, { taskids });
  return taskids;
}

/** Schedule a managed task if this transaction commits
 *
 *  A managed task, once scheduled, will always attempt to complete, and is restarted when it or the task manager fails.
          Managed tasks are often used for 'after effects' which can take a lot of time, eg the actual deletion of a WRD schema.
          A managed task will be attempted even if the script that queued it exits before
          the task starts. If work is open, the task will be queued as soon as the current work is committed, and will not
          be queued if the work is rolled back.
    @param tasktype - Type of the task to schedule (eq: wrd:deleteschemas) - refers to to the servicemanager:managedtask in the moduledefinition
    @param taskdata - Task data, as specified by the task. The data must fit in 4K of HSON data
    @returns id of this task. This id is a database id and can be used by later scripts
*/
export async function scheduleTask(tasktype: string, taskdata?: IPCMarshallableData, options?: ScheduleTaskOptions): Promise<number> {
  return (await scheduledTasks(tasktype, [taskdata ?? {}], options))[0];
}

/** Wait for timed tasks to finish
    @param taskname - Task to wait for
    @param deadline - Wait until
    - debug Print debuginfo if waiting
    - allowMissing Don't fail if the task isn't registered (yet)
    @returns True if the task finished, false if timed out
*/
async function waitForTimedTask(taskname: string, deadline: WaitPeriod, options?: { allowMissing?: boolean; expectLastRunAfter?: Date }): Promise<{
  completed: boolean;
  errorMessage: string;
}> {
  checkModuleScopedName(taskname);
  if (isWorkOpen())
    throw new Error("waitForTimedTask cannot be invoked with open work");

  const matchtag = taskname.replace(":", ".");

  // executetasks now broadcasts this event whenever a task completes, so we know when to rescan the list
  using taskUpdatedStream = subscribeToEventStream("system:internal.taskcompleted");
  const abort = new AbortController;
  const deadlinePromise = sleep(deadline, { signal: abort.signal }).then(() => false);

  try {
    for (; ;) {
      //Get current state
      const taskstate = await db<PlatformDB>().selectFrom("system.tasks").select(["id", "lastrun", "nexttime", "error"]).where("tag", "=", matchtag).executeTakeFirst();
      if (!options?.allowMissing && !taskstate)
        throw new Error(`No such timed task '${taskname}' registered`);

      if (taskstate &&
        taskstate.lastrun && //if it never ran, it's not done
        (!options?.expectLastRunAfter || taskstate.lastrun >= options.expectLastRunAfter) &&
        taskstate.nexttime > new Date) //it's not scheduled for the future (TODO should we care if expectLastRunAfter is set? )
        return { completed: true, errorMessage: taskstate.error }; //Then it appears true, TODO though it would be better to set these things up as managed tasks and just wait for that ID

      if (!taskstate?.nexttime)
        throw new Error(`No such timed task '${taskname}' scheduled`);

      if (await Promise.race([taskUpdatedStream.next(), deadlinePromise]) === false)
        return { completed: false, errorMessage: "" };
    }
  } finally {
    abort.abort(); //ensure the deadline sleep is aborted
  }
}

/** Schedule a timed task to run.
 *
    The task will be run at the specified time, or if not set, as soon as possible. If another request is made to
    run the task even earlier, or if the tasks 'runat' causes it to run, this request will be ignored (ie you cannot
    request multiple runs of a task by repeatedly calling this function)

    @param taskname - module:tag of the task
    @param options - when: When to run the task (if not set, asap)
    @returns An object with taskDone(), which returns a promise that resolves when the task is completed
*/
export async function scheduleTimedTask(taskname: string, options?: { when?: FlexibleInstant/*; allowMissing?: boolean*/ }): Promise<{
  get taskDone(): Promise<void>;
}> {
  //TODO can we elimienate allowMissing? it's mostly an inconsistency with moduledefs (consult extracts?) or a startup issue (insert it ourselves? fix startup ordering?)
  checkModuleScopedName(taskname);
  if (!isWorkOpen())
    throw new Error("scheduleTimedTask must be invoked with open work");

  const dbtag = taskname.replaceAll(":", ".");
  const taskinfo = await db<PlatformDB>().selectFrom("system.tasks").select(["nexttime", "id", "inapplicable"]).where("tag", "=", dbtag).executeTakeFirst();
  if (!taskinfo) {
    // if (options?.allowMissing)
    //   return null;
    throw new Error(`No such timed task '${taskname}' registered`);
  }

  /* TODO HS used a finish handler to dedupe schedledtasks (which also unexpectedly separate reschedules from the original commit)
     but i'd rather avoid that and bet on having unique managed tasks first, and handle scheduledtasks through those tasks */
  const queuedat = new Date;
  const when = options?.when ? convertFlexibleInstantToDate(options?.when) : queuedat;
  const updateTask = (taskinfo.nexttime.getTime() === defaultDateTime.getTime() || taskinfo.nexttime.getTime() > when.getTime())
    //inapplicable tasks? move time forward when in the past, easier when developing - you can see times change)
    || (taskinfo.inapplicable && taskinfo.nexttime.getTime() < Date.now());

  if (updateTask) {
    await db<PlatformDB>().
      updateTable("system.tasks").
      where("id", "=", taskinfo.id).
      set({ nexttime: when }).
      execute();

    broadcastOnCommit("system:internal.scantasks");
  }

  if (debugFlags.que)
    logDebug("system:scheduletimedtask", { taskname, options, updateTask, trace: getStackTrace() });

  //FIXME actually we should log some sort of iteration count/token - or even better, a managed task id? to be sure we're waiting for *our* scheduled task
  //      this might race against another task queueing the same task, but running just before our commit

  return {
    get taskDone(): Promise<void> {
      if (isWorkOpen())
        throw new Error("onCompletion should not be used with open work"); //too easy to deadlock yourself, so deny for now

      return waitForTimedTask(taskname, 86400 * 1000, { /*allowMissing: options?.allowMissing,*/ expectLastRunAfter: queuedat }).then(result => {
        if (!result.completed)
          throw new Error(`Timed task '${taskname}' did not finish in time`);
        if (result.errorMessage)
          throw new Error(`Timed task '${taskname}' failed: ${result.errorMessage}`);
      });
    }
  };
}

export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: false }): Promise<T>;
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: { acceptTimeout: boolean }): Promise<T | null>;

/** Get the result of a scheduled task
 * @param taskId - Task to look up
 * @param timeout - How long to wait for the task to finish
 * @param options - acceptCancel: Don't throw if the task is cancelled
 *                  acceptTempFailure: Don't throw if the task is temporarily failed but will still retry
 *                  acceptTimeout: Return null in case of timeout (by default, throws)
 * @returns The result of the task
 * @throws if the task is cancelled, failed or timed out
 */
export async function retrieveTaskResult<T>(taskId: number, timeout: WaitPeriod, options?: {
  acceptCancel?: boolean;
  acceptTempFailure?: boolean;
  acceptTimeout?: boolean;
}): Promise<T | null> {
  options = {
    acceptCancel: false,
    acceptTempFailure: false,
    acceptTimeout: false,
    ...options
  };

  const maxwait = convertWaitPeriodToDate(timeout);
  return await loadlib("mod::system/lib/tasks.whlib").retrieveManagedTaskResult(taskId, maxwait, options) as T;
}

/// Handles cancelling running tasks after the commit
class TaskCancelHandler {
  static uniqueTag = Symbol("system:tasks.TaskCancelHandler");
  deferred = Promise.withResolvers<void>();

  async onCommit() {
    try {
      using service = await openBackendService("system:managedqueuemgr", [-1]);
      await service.stopCancelledTasks();
      this.deferred.resolve();
    } catch (e) {
      this.deferred.reject(e as Error);
    }
  }
}

/** Cancel managed tasks.
    @remarks Schedules cancellation of the specified managed tasks. When the promise returned by this function resolves, the
    changes have been written to the database. If any of the tasks are running, they will be stopped after the commit. After
    all running tasks have been stopped, the `runningTasksStopped` promise returned by this function will be fulfilled.
    @param taskids - Ids of the tasks that must be cancelled
    @returns - Promise that resolves when the cancellation has written to the database. The promise returned by
    `runningTasksStopped()` will be resolved when all running tasks have been stopped.
*/
export async function cancelManagedTasks(taskIds: number[]): Promise<{ runningTasksStopped(): Promise<void> }> {
  if (!taskIds.length)
    return { runningTasksStopped: () => Promise.resolve() };

  const seenTaskTypes = (await db<PlatformDB>().selectFrom("system.managedtasks").select("tasktype").where("id", "in", taskIds).distinct().execute()).map(task => task.tasktype);
  await db<PlatformDB>()
    .updateTable("system.managedtasks")
    .set({ iscancelled: true, finished: new Date(), lasterrors: "Cancelled by CancelManagedTasks" })
    .where("id", "in", taskIds)
    .execute();

  broadcastOnCommit("system:managedtasks.any.changes");
  for (const taskType of seenTaskTypes.sort())
    broadcastOnCommit(`system:managedtasks.${taskType}.changes`);

  // Make sure the commit handler is installed
  const handler = onFinishWork(() => new TaskCancelHandler, { uniqueTag: TaskCancelHandler.uniqueTag });

  return { runningTasksStopped: () => handler.deferred.promise };
}
