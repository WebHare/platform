import type { HTTPErrorCode, HTTPStatusCode } from "@webhare/router";
import type { DefaultErrorType, GetBodyType, GetOperation, GetOperationByPathAndMethod, GetParametersType, OperationResponseTypes } from "./types";
import type { ResponseForCode, RestResponsesBase } from "@webhare/router/src/restrequest";
import type { OpenAPIClientFetch, OpenAPIResponse } from "@webhare/openapi-service";
import { logRPCTraffic } from "@webhare/services/src/logging";


// Response when the content-type indicates a JSON response
type OpenAPIJsonResponse<BodyType> = {
  status: HTTPStatusCode;
  headers: Headers;
  contenttype: string;
  ///Body, JSON decoded
  body: BodyType;
};

type OpenAPINonJsonResponse = {
  status: HTTPStatusCode;
  headers: Headers;
  contenttype: string;
  response: OpenAPIResponse;
};

/** Base type for parameter types. Only strings, numbers and booleans are allowed as parameters */
type ParamsBaseType = Record<string, string | number | boolean | string[]>;

/** List of allowed paths for a method
 */
export type PathsForMethod<Paths, Method extends string, Path extends keyof Paths = keyof Paths> = Path extends keyof Paths ? Method extends keyof Paths[Path] ? Path & string : never : never;

/** Possible returned status codes */
type ReturnedStatusCodes<Responses extends RestResponsesBase> = Responses["status"] | HTTPErrorCode;

type ParameterEncoding = {
  explode?: boolean;
};

/** Parameter options for a method and a path
 */
type ParamOptions<Paths extends object, Path extends keyof Paths, Method extends Exclude<keyof Paths[Path], "parameters">> = object extends GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>>
  ? { params?: GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>> & ParamsBaseType; encoding?: ParameterEncoding } | undefined
  : { params: GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>> & ParamsBaseType; encoding?: ParameterEncoding };

type OpenAPIResponseFromOperationResponse<OperationResponse extends { status: HTTPStatusCode; isjson: boolean; response: unknown }> =
  (OperationResponse extends { isjson: infer IsJson; response: infer Response } ?
    ((true extends IsJson ? OpenAPIJsonResponse<Response> : never) |
      (false extends IsJson ? OpenAPINonJsonResponse : never)) :
    never) & { status: OperationResponse["status"] };

/** Union of all allowed response types for an operation, by operation record
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type OpResponseTypesInternal<Responses extends RestResponsesBase, DefaultErrorFormat extends object, Status extends ReturnedStatusCodes<Responses> = ReturnedStatusCodes<Responses>> = Status extends any
  ? OpenAPIResponseFromOperationResponse<ResponseForCode<Responses, DefaultErrorFormat, Status>>
  : never;

/** Union of all allowed response types for an operation, by path and method
 */
export type OpResponseTypes<Paths extends object, Components extends object, Path extends keyof Paths, Method extends string> =
  OpResponseTypesInternal<OperationResponseTypes<GetOperationByPathAndMethod<Paths, Path, Method & Exclude<keyof Paths[Path], "parameters">>>, DefaultErrorType<Paths, Components>>;

/** Body type, by path and method
 */
type OpBodyType<Paths extends object, Path extends keyof Paths, Method extends string> =
  GetBodyType<GetOperationByPathAndMethod<Paths, Path, Method & Exclude<keyof Paths[Path], "parameters">>>;

/** Tuple with method options, to make the options parameter optional when it has no required properties
 * @typeParam Paths - Paths object as generated by openapi-typescript
 * @typeParam Path - Path
 * @typeParam Method - Method
 */
type MethodOptions<Paths extends object, Path extends keyof Paths, Method extends Exclude<keyof Paths[Path], "parameters">> =
  undefined extends ParamOptions<Paths, Path, Method> ? [ParamOptions<Paths, Path, Method>?] : [ParamOptions<Paths, Path, Method>];

/** Typed OpenAPI client
 */
export class TypedOpenAPIClient<Paths extends object, Components extends object> {
  readonly service: string | OpenAPIClientFetch;
  readonly options: {
    service?: string;
  };
  defaultheaders: Record<string, string> = {};

  /** Build a new typed OpenAPI client
   * @param service - How to invoke the service - either a URL passed to fetch as a base url, or a fetch() like function accepting the subroute
   */
  constructor(service: string | OpenAPIClientFetch, options: {
    bearerToken?: string;
    service?: string;
  } = {}) {
    this.service = service;
    this.options = options;
    if (options?.bearerToken)
      this.defaultheaders["Authorization"] = "Bearer " + (options?.bearerToken);
  }

  async invoke(method: string, route: string, requestbody: string | null, options: {
    headers?: Record<string, string>;
    contentType?: string | null;
    params?: ParamsBaseType;
    encoding?: ParameterEncoding;
    alwaysReturnResponse: true;
  }): Promise<OpenAPINonJsonResponse>;

  async invoke<Path extends PathsForMethod<Paths, Method>, Method extends string>(method: string, route: string, requestbody: string | null, options?: {
    headers?: Record<string, string>;
    contentType?: string | null;
    params?: ParamsBaseType;
    encoding?: ParameterEncoding;
    alwaysReturnResponse?: boolean;
  }): Promise<OpResponseTypes<Paths, Components, Path, Method>>;

  async invoke<Path extends PathsForMethod<Paths, Method>, Method extends string>(method: string, route: string, requestbody: string | null, options?: {
    headers?: Record<string, string>;
    contentType?: string | null;
    params?: ParamsBaseType;
    encoding?: ParameterEncoding;
    alwaysReturnResponse?: boolean;
  }): Promise<OpResponseTypes<Paths, Components, Path, Method> | OpenAPINonJsonResponse> {
    const fetchoptions = {
      method,
      headers: { ...this.defaultheaders, ...options?.headers },
      ...(requestbody ? { body: requestbody } : null)
    } satisfies RequestInit;

    if (options?.contentType !== undefined) {
      if (options?.contentType === "string")
        fetchoptions.headers["Content-Type"] = options?.contentType;
    } else if (requestbody) {
      fetchoptions.headers["Content-Type"] = "application/json";
    }
    const used_pathelts: string[] = [];
    route = route.split("/").map(pathelt => {
      if (pathelt.startsWith("{")) {
        const name = pathelt.slice(1, -1);
        used_pathelts.push(name);
        const value = options?.params?.[name];
        if (typeof value !== "number" && typeof value !== "string" && typeof value !== "boolean")
          throw new Error(`Missing parameter ${JSON.stringify(pathelt.slice(1, -1))}`);
        return encodeURIComponent(value); // correctly encodes booleans to 'true'/'false'
      }
      return pathelt;
    }).join("/");
    if (route.startsWith("/"))
      route = route.slice(1);

    // add unused params to the url as query parameters
    const prefix = "https://example.net/";
    const url = new URL(prefix + route);
    if (options?.params) {
      for (const [key, value] of Object.entries(options.params)) {
        if (!used_pathelts.includes(key)) {
          if (Array.isArray(value)) {
            if (options.encoding?.explode ?? true) {
              for (const elt of value)
                url.searchParams.append(key, elt);
            } else
              url.searchParams.append(key, value.join(","));
          } else
            url.searchParams.append(key, value.toString());
        }
      }
    }

    const finalroute = url.toString().substring(prefix.length);

    let requestId: string | undefined;
    if (this.options.service) {
      await logRPCTraffic(this.options.service, finalroute, "outgoing", fetchoptions.body, {
        transactionId: (requestId = crypto.randomUUID()),
      });
    }

    const call = typeof this.service === "string" ?
      await fetch(this.service + finalroute, fetchoptions) :
      await this.service(finalroute, fetchoptions);

    const contenttype = call.headers.get("Content-Type") || "";
    if (contenttype.split(';')[0] === "application/json" && !options?.alwaysReturnResponse) {
      if (this.options.service) {
        await logRPCTraffic(this.options.service, finalroute, "incoming", () => call.clone().json(), {
          transactionId: requestId,
        });
      }
      return { status: call.status, headers: call.headers, contenttype, body: await call.json(), } as unknown as OpResponseTypes<Paths, Components, Path, Method>;
    } else
      if (this.options.service) {
        await logRPCTraffic(this.options.service, finalroute, "incoming", () => call.clone().blob(), {
          transactionId: requestId,
        });
      }
    return { status: call.status, headers: call.headers, contenttype, response: call };
  }

  async get<Path extends PathsForMethod<Paths, "get">>(route: Path, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "get">): Promise<OpResponseTypes<Paths, Components, Path, "get">> {
    return this.invoke("GET", route, "", options[0]);
  }
  async post<Path extends PathsForMethod<Paths, "post">>(route: Path, body: OpBodyType<Paths, Path, "post">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "post">): Promise<OpResponseTypes<Paths, Components, Path, "post">> {
    return this.invoke("POST", route, JSON.stringify(body), options[0]);
  }
  async patch<Path extends PathsForMethod<Paths, "patch">>(route: Path, body: OpBodyType<Paths, Path, "patch">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "patch">): Promise<OpResponseTypes<Paths, Components, Path, "patch">> {
    return this.invoke("PATCH", route, JSON.stringify(body), options[0]);
  }
  async put<Path extends PathsForMethod<Paths, "put">>(route: Path, body: OpBodyType<Paths, Path, "put">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "put">): Promise<OpResponseTypes<Paths, Components, Path, "put">> {
    return this.invoke("PUT", route, JSON.stringify(body), options[0]);
  }
  async delete<Path extends PathsForMethod<Paths, "delete">>(route: Path, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "delete">): Promise<OpResponseTypes<Paths, Components, Path, "delete">> {
    return this.invoke("DELETE", route, "", options[0]);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- needed to match all TypedOpenAPIClient objects
type TypedOpenAPIClientBase = TypedOpenAPIClient<any, any>;

/** Get the type parameters of a typed openapi client */
export type GetClientTypeParams<Client extends TypedOpenAPIClientBase> = Client extends TypedOpenAPIClient<infer Paths, infer Components> ? { paths: Paths; components: Components } : never;

/** Type for the request body of an operation
 * @typeParam Client - Client type (usually `typeof client`)
 * @typeParam Method - Method ("get", "post", etc.)
 * @typeParam Path - Operation path
 */
export type TypedClientRequestBody<
  Client extends TypedOpenAPIClientBase,
  Method extends "get" | "post" | "patch" | "put" | "delete",
  Path extends PathsForMethod<GetClientTypeParams<Client>["paths"], Method>
> = GetBodyType<GetOperation<GetClientTypeParams<Client>["paths"], `${Method} ${Path}`>>;

/** Type for the return value of an operation call
 * @typeParam Client - Client type (usually `typeof client`)
 * @typeParam Method - Method ("get", "post", etc.)
 * @typeParam Path - Operation path
 */
export type TypedClientResponse<
  Client extends TypedOpenAPIClientBase,
  Method extends "get" | "post" | "patch" | "put" | "delete",
  Path extends PathsForMethod<GetClientTypeParams<Client>["paths"], Method>
> = Client extends TypedOpenAPIClient<infer Paths, infer Components> ? OpResponseTypes<Paths, Components, Path, Method> : never;
