<?wh

LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/stringparser.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internal/css/tokenizer.whlib";


/// Maximum number of cached parsed CSS selectors (cache is cleared after reaching this size)
CONSTANT INTEGER parsed_selector_cache_size := 1024;

RECORD ARRAY FUNCTION __EvaluateCSSSelectors(RECORD ARRAY parts, OBJECT root, OBJECT scope, STRING mode) __ATTRIBUTES__(EXTERNAL, EXECUTESHARESCRIPT);


PUBLIC RECORD ARRAY FUNCTION SplitPrelude(RECORD ARRAY prelude)
{
  RECORD ARRAY selectors;
  RECORD ARRAY tokssofar;

  FOREVERY(RECORD tok FROM prelude)
  {
    IF (tok.type = ",")
    {
      IF (Length(tokssofar) > 0)
        INSERT [ prelude := tokssofar ] INTO selectors AT END;
      tokssofar := DEFAULT RECORD ARRAY;
      CONTINUE;
    }
    INSERT tok INTO tokssofar AT END;
  }

  IF (Length(tokssofar) > 0)
    INSERT [ prelude := tokssofar ] INTO selectors AT END;

  RETURN selectors;
}

PUBLIC RECORD FUNCTION GetPreludeSpecificity(BOOLEAN followspec, RECORD ARRAY prelude)
{
  // http://www.w3.org/TR/css3-selectors/#specificity
  INTEGER a := SELECT AS INTEGER COUNT(*) FROM prelude WHERE type = "#";// The number of ID-selectors;
  INTEGER b := SELECT AS INTEGER COUNT(*) FROM prelude WHERE (type = "delim" AND value = ".") OR type = "[" OR type = ":" OR (type = "parsed-simpleblock" AND associatedtoken = "[");// The number of class selectors, attribute selectors and pseudoclasses;
  // Fix the NOT operator:
  b := b - SELECT AS INTEGER COUNT(*) FROM prelude WHERE type = "ident" AND value = "not";
  // FIXME: The value for c is currently not entirely reliable: element selectors within simple blocks must als be counted, if the simple block is part of a psuedoclass.
  INTEGER c := SELECT AS INTEGER COUNT(*) FROM prelude WHERE (type = "ident" AND ToLowercase(value) IN
    [ "html", "head", "title", "base", "link", "meta", "style", "script", "noscript", "template", "body", "section", "nav", "article", "aside",
    "h1", "h2", "h3", "h4", "h5", "h6", "header", "footer", "address", "main", "p", "hr", "pre", "blockquote", "ol", "ul", "li", "dl", "dt", "dd",
    "figure", "figcaption", "div", "a", "em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd",
    "sub", "sup", "i", "b", "u", "mark", "ruby", "rt", "rp", "bdi", "bdo", "span", "br", "wbr", "ins", "del", "img", "iframe", "embed", "object",
    "param", "video", "audio", "source", "track", "canvas", "map", "area", "svg", "math", "table", "caption", "colgroup", "col", "tbody", "thead",
    "tfoot", "tr", "td", "th", "form", "fieldset", "legend", "label", "input", "button", "select", "datalist", "optgroup", "option", "textarea",
    "keygen", "output", "progress", "meter", "details", "summary", "menuitem", "menu",
    /* OBSOLETE ELEMENTS */
    "acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "dir", "font", "frame", "frameset", "hgroup", "isindex", "listing",
    "marquee", "nobr", "noframes", "plaintext", "spacer", "strike", "tt", "xmp" ]) OR type = ":";// The number of element selectors and pseudoclasses;
  IF(followspec)
    RETURN [ specificity := ToInteger(ToString(a) || ToString(b) || ToString(c), 0) ];

  RETURN [ a := a, b := b, c := c ];
}

PUBLIC OBJECTTYPE CSSException EXTEND Exception
< STRING pvt_code;
  PUBLIC PROPERTY code(pvt_code, -);

  MACRO NEW(STRING code, STRING message)
  : Exception(code || ": " || message)
  {
    this->pvt_code := code;
  }
>;

PUBLIC STRING ARRAY FUNCTION ExtractURLsFromTokens(RECORD ARRAY tokens)
{
  STRING ARRAY urls;
  FOREVERY (RECORD token FROM tokens)
  {
    SWITCH (token.type)
    {
      CASE "url"                  { INSERT token.value INTO urls AT END; }
      CASE "parsed-simpleblock"   { urls := urls CONCAT ExtractURLSFromTokens(token.value); }
    }
  }
  RETURN urls;
}

PUBLIC RECORD ARRAY FUNCTION RewriteURLsInTokens(RECORD ARRAY tokens, FUNCTION PTR rewriter, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  STRING baseurl;
  IF(CellExists(options, "BASEURL"))
    baseurl := options.baseurl;

  FOREVERY (RECORD token FROM tokens)
  {
    SWITCH (token.type)
    {
      CASE "url"
      {
        STRING url := token.value;

        IF (CellExists(options, "BASEURL"))
          url := ResolveToAbsoluteURL(options.baseurl, url);

        // Apply the rewriter, if any:
        IF (rewriter != DEFAULT FUNCTION PTR)
          url := rewriter(url);

        token.value := url;
        token.csstext := token.type || '("' || EncodeCSSString(url) || '")';

        tokens[#token] := token;
      }
      CASE "parsed-simpleblock"
      {
        tokens[#token].value := RewriteURLsInTokens(token.value, rewriter, options);
      }
    }
  }

  RETURN tokens;
}

STATIC OBJECTTYPE CSSSelectorParser
< /** List of CSS tokens to parse @includecelldef #CSSTokenizer::GetToken.return
  */
  RECORD ARRAY tokens;

  /// Current token within the token array
  INTEGER pos;

  /// Current token (= this->tokens[this->pos]) @includecelldef #CSSTokenizer::GetToken.return
  RECORD token;

  MACRO NEW(RECORD ARRAY tokens)
  {
    IF(Length(tokens) = 0)
      THROW NEW Exception("Received an empty selector");
    this->tokens := RECORD[ ...tokens, [ type := "eof", value := "", csstext := "" ] ];
    this->pos := 0;
    this->token := this->tokens[0];
  }

  /** Advance to the next token
  */
  MACRO Next()
  {
    this->pos := this->pos + 1;
    this->token := this->tokens[this->pos];
  }

  /** Eat whitespace, and return whether EOF has been reached
      @return TRUE if EOF has been reached
  */
  PUBLIC BOOLEAN FUNCTION AtEOF()
  {
    WHILE (this->TryParseWS())
      {}
    RETURN this->token.type = "eof";
  }

  /** Parses all whitespaces, returns if any was encountered
      @return TRUE if whitespace was found
  */
  PUBLIC BOOLEAN FUNCTION TryParseWS()
  {
    BOOLEAN retval;
    WHILE (this->token.type = "ws")
    {
      retval := TRUE;
      this->Next();
    }
    RETURN retval;
  }

  /** Parses a token by value. Does not match strings
      @param token Token value to match
      @return TRUE if the requested token was found and consimed
  */
  BOOLEAN FUNCTION TryParse(STRING token)
  {
    // Strings can have arbitrary values, don't match them
    IF (this->token.value != token OR this->token.type = "string")
      RETURN FALSE;
    this->Next();
    RETURN TRUE;
  }

  /** Expects end of token stream (allows trailing whitespace), throws
      if a non-whitespace token was found.
  */
  PUBLIC MACRO ExpectEOF()
  {
    IF (NOT this->AtEOF())
      THROW NEW Exception(`Found unexpected token ${EncodeJSON(this->token.csstext)}`);
  }

  /** Parses a token by type
      @param type Type of token that needs to be matched
      @return Consumed token if the current token was of the requested type @includecelldef #CSSTokenizer::GetToken.return
  */
  RECORD FUNCTION TryParseType(STRING type)
  {
    IF (this->token.type != type)
      RETURN DEFAULT RECORD;
    RECORD token := this->token;
    this->Next();
    RETURN token;
  }

  /** Parses a complex selector list
      @param allowimplicitscope Add implicit ":scope" before selectors starting with '>'
      @return @includecelldef #ParseComplexSelector.return
  */
  PUBLIC RECORD ARRAY FUNCTION ParseComplexSelectorList(BOOLEAN allowimplicitscope)
  {
    this->TryParseWS();
    RECORD ARRAY selectors;
    WHILE (TRUE)
    {
      selectors := selectors CONCAT this->ParseComplexSelector(allowimplicitscope);

      this->TryParseWS();
      IF (NOT this->TryParse(","))
        BREAK;

      this->TryParseWS();
    }
    this->ExpectEOF();

    RETURN selectors;
  }

  /** Parses a complex selector list
      @param allowimplicitscope Add implicit ":scope" before selectors starting with '>'
      @return Single selector split into compound selectors and their combinators
      @cell(record array) return.compoundselector Compound selector @includecelldef #ParseComplexSelector.return
      @cell(record array) return.combinator Combinator AFTER the compound selector
        - "": return if matches
        - " ": any descendent matches
        - ">": direct descendent matches
        - "~": any following sibling matches
        - "+": next sibling matches
  */
  RECORD ARRAY FUNCTION ParseComplexSelector(BOOLEAN allowimplicitscope)
  {
    RECORD ARRAY parts;
    BOOLEAN requireselector := TRUE;

    IF (allowimplicitscope)
    {
      STRING combinator := this->ParseCombinator();
      IF (combinator = ">")
      {
        INSERT CELL
            [ combinator
            , compoundselector :=
                  [ tag := ""
                  , selectors := [ [ type := ":", name := "scope" ] ]
                  ]
            ] INTO parts AT END;
      }
      ELSE IF (combinator != "" AND combinator != " ")
        THROW NEW Exception(`Combinator ${EncodeJSON(combinator)} is not allowed at the start of a selector`);
    }

    WHILE (TRUE)
    {
      RECORD compoundselector := this->ParseCompoundSelector(requireselector);
      IF (NOT RecordExists(compoundselector))
      {
        // last combinator must be " ", fix to ""
        parts[END-1].combinator := "";
        BREAK;
      }

      STRING combinator := this->ParseCombinator();
      INSERT CELL[ combinator, compoundselector ] INTO parts AT END;

      IF (combinator = "")
        BREAK;

      requireselector := combinator != " ";
    }
    RETURN parts;
  }

  /** Parses a combinator
      @return Combinator
        - "": return if matches
        - " ": any descendent matches
        - ">": direct descendent matches
        - "~": any following sibling matches
        - "+": next sibling matches
  */
  STRING FUNCTION ParseCombinator()
  {
    BOOLEAN have_ws;
    WHILE (this->TryParseWS())
      have_ws := TRUE;

    IF (this->token.type != "delim" OR this->token.value NOT IN [ ">", "+", "~" ])
      RETURN have_ws ? " " : "";

    STRING retval := this->token.value;
    this->Next();

    WHILE (this->TryParseWS())
    {}

    RETURN retval;
  }

  /** Parses a compound selector
      @param required If no compound selector was found, throw an error if TRUE. Otherwise return DEFAULT RECORD
      @return Compound selector
      @cell(string) return.tag Expected tag name ('' if all match)
      @cell(record array) return.selectors Subclass tests. Pseudo-class tests can have custom fields, returned
        by ParseFunction and ParsePseudoClass
      @cell(record array) return.selectors.type Type of test
        - "#": ID test
        - ".": class tests
        - "[": attribute test
        - "(": function test
        - ":": pseudo-class test
      @cell(record array) return.selectors.value Match value
        - ID (for id test)
        - class (for class test)
        - attribute value (for attribute test). Lowercased for case insensitive matches.
      @cell(record array) return.selectors.name Name of function / pseudo class
      @cell(record array) return.selectors.attr Attribute name (for attribute test)
      @cell(record array) return.selectors.casesensitive Whether attribute test is case sensitive
      @cell(record array) return.selectors.matcher Attribute matching function (for attribute test)
        - "": only existence check
        - "=": equality check
        - "~=": value exists in space-separated list
        - "|=": valus is first value in hyphen-separated list
        - "^=": attribute value starts with value
        - "$=": attribute value ends with value
        - "*=": attribute value contains with value
        - "nomatch": used for attributepart matches with an empty string - they don't match any element
      @cell(record array) return.selectors.tokens Function tokens (for function test) @includecelldef #CSSTokenizer::GetToken.return
  */
  PUBLIC RECORD FUNCTION ParseCompoundSelector(BOOLEAN required)
  {
    BOOLEAN have_item;

    STRING tag := "";
    RECORD ident := this->TryParseType("ident");
    IF (RecordExists(ident))
    {
      have_item := TRUE;
      tag := ident.value;
    }
    ELSE IF (this->TryParse("*"))
      have_item := TRUE;

    RECORD ARRAY selectors;

    BOOLEAN have_colon;

    WHILE (TRUE)
    {
      RECORD hashid := this->TryParseType("#");
      IF (RecordExists(hashid))
      {
        have_item := TRUE;
        INSERT CELL[ type := "#", hashid.value ] INTO selectors AT END;
      }
      ELSE IF (this->TryParse("."))
      {
        have_item := TRUE;
        this->TryParseWS();
        ident := this->TryParseType("ident");
        IF (NOT RecordExists(ident))
          THROW NEW Exception(`Expected an identifier after '.'`);
        INSERT CELL[ type := ".", value := ToLowercase(ident.value) ] INTO selectors AT END;
      }
      ELSE IF (this->TryParse("["))
      {
        have_item := TRUE;
        this->TryParseWS();
        STRING attrns := "";
        IF (this->TryParse("*"))
        {
          attrns := "*";
          IF (NOT this->TryParse("|"))
            THROW NEW Exception(`Expected "|" after "*" in attribute test`);
          ident := this->TryParseType("ident");
        }
        ELSE
        {
          ident := this->TryParseType("ident");
          IF (this->TryParse("|"))
            THROW NEW Exception(`Namespace prefixes in CSS selectors not supported`);
        }
        IF (NOT RecordExists(ident))
          THROW NEW Exception(`Expected an attribute name`);
        this->TryParseWS();
        STRING matcher := "has";
        STRING value;
        BOOLEAN casesensitive;
        IF (this->token.value IN [ "=", "~=", "|=", "^=", "$=", "*=" ])
        {
          matcher := this->token.value;
          this->Next();
          this->TryParseWS();

          IF (this->token.type IN [ "ident", "string" ])
            value := this->token.value;
          ELSE
            THROW NEW Exception(`Expected attribute value`);

          this->Next();
          this->TryParseWS();

          casesensitive := NOT this->TryParse("i");
          IF (casesensitive)
            this->TryParseWS();

          IF (value = "" AND matcher IN [ "^=", "$=", "*=" ])
            matcher := "nomatch";

          // [ <string-token> | <ident-token> ] <attr-modifier>? ']'
        }
        ELSE
          this->TryParseWS();

        IF (NOT this->TryParse("]"))
          THROW NEW Exception(`Expected "]"`);

        INSERT CELL
            [ type :=   "["
            , attr :=   ident.value
            , attrns
            , matcher
            , value :=  casesensitive ? value : ToLowercase(value)
            , casesensitive
            ] INTO selectors AT END;
      }
      ELSE IF (this->TryParse(":"))
      {
        have_item := TRUE;
        IF (this->token.value = ":")
        {
          have_colon := TRUE;
          BREAK;
        }
        ELSE
        {
          ident := this->TryParseType("ident") ?? this->TryParseType("function");
          IF (NOT RecordExists(ident))
            THROW NEW Exception(`Expected an identifier or a function`);
          IF (ident.type = "function" OR this->TryParse("(")) // no whitespace
          {
            STRING ARRAY delims := [ "(" ];

            RECORD ARRAY functokens;

            WHILE (LENGTH(delims) > 0)
            {
              IF (this->token.type = "eof")
                THROW NEW Exception(`Unexpected end of selector`);
              IF (this->token.value IN [ "(", "[", "{" ])
                INSERT this->token.value INTO delims AT END;
              ELSE IF (this->token.type = "function")
                INSERT "(" INTO delims AT END;
              ELSE IF (this->token.value IN [ ")", "]", "}" ])
              {
                IF (delims[END-1] != [ "(", "[", "{" ][SearchElement([ ")", "]", "}" ], this->token.value)])
                  THROW NEW Exception(`Unmatched closing token ${EncodeJSON(this->token.value)}`);
                DELETE FROM delims AT END - 1;
                IF (IsDefaultValue(delims))
                {
                  this->Next();
                  BREAK;
                }
              }
              ELSE IF (this->token.type = "bad-string" OR this->token.type = "bad-url")
                THROW NEW Exception(`Found a improperly encoded string or url`);
              INSERT this->token INTO functokens AT END;
              this->Next();
            }

            INSERT
                [ type :=     "("
                , name :=     ident.value
                , tokens :=   functokens
                , ...this->ParseFunction(ident.value, functokens)
                ] INTO selectors AT END;
          }
          ELSE
          {
            INSERT
                [ type :=     ":"
                , name :=     ident.value
                , ...this->ParsePseudoClass(ident.value)
                ] INTO selectors AT END;
          }
        }
      }
      ELSE
        BREAK;
    }

    IF (have_colon)
    {
      this->Next();
      THROW NEW Exception(`Pseudo element selectors are not supported`);
    }

    IF (NOT have_item)
    {
      IF (required)
        THROW NEW Exception(`Expected a compound selector${this->token.csstext = "" ? "" : `, got token ${EncodeJSON(this->token.csstext)}`}`);
      RETURN DEFAULT RECORD;
    }

    RETURN CELL
        [ tag
        , selectors
        ];
  }

  /** Parses An+B syntax for nth-child ea.
      @param name Name of function
      @param functokens Token list with the parameters CSSTokenizer::GetToken.return
      @param allowselector Whether to a allow a compound selector
      @return Parsed parameters
      @cell return.compoundselector Compound selector for :not function @includecelldef #ParseCompoundSelector.return
      @cell return.factor A from the An+B in nth-child-alike tests
      @cell return.ofs B from the An+B in nth-child-alike tests
  */
  RECORD FUNCTION ParseANPlusB(STRING name, RECORD ARRAY functokens, BOOLEAN allowselector)
  {
    // Compound selector is CSS4, but useful in implementing nth-of-type
    RECORD compoundselector;

    // Collect tokens into a string (doesn't handle escaping very will, though)
    // ADDME: rewrite folling CSS4 selector spec
    STRING str;
    BOOLEAN have_of;
    FOREVERY (RECORD token FROM functokens)
    {
      IF (token.type NOT IN [ "number", "ident", "dimension", "ws" ])
        THROW NEW Exception(`Syntax error in An+B expression, unexpected token ${EncodeJSON(token.csstext)}`);

      IF (token.type = "ident" AND token.value = "of" AND allowselector)
      {
        OBJECT p := NEW CSSSelectorParser(ArraySlice(functokens, #token + 1));
        p->TryParseWS();
        compoundselector := p->ParseCompoundSelector(TRUE);
        p->ExpectEOF();
        BREAK;
      }
      IF (token.type = "eof")
        BREAK;

      str := str || token.csstext;
    }

    STRING toparse := TrimWhitespace(ToLowercase(str));

    // CSS3 selector spec
    OBJECT p := NEW StringParser(TrimWhitespace(ToLowercase(str)));

    // S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
    //      ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*

    p->ParseWhileInset(" \n\t");

    INTEGER factor, ofs;
    IF (p->TryParse("even"))
    {
      factor := 2;
    }
    ELSE IF (p->TryParse("odd"))
    {
      factor := 2;
      ofs := 1;
    }
    ELSE
    {
      BOOLEAN negative := NOT p->TryParse("+") AND p->TryParse("-");
      STRING first_digits := p->ParseWhileInset(p->set_digit);
      BOOLEAN have_n := p->TryParse("n");

      IF (first_digits = "" AND NOT have_n)
        THROW NEW Exception(`Expected a number or "n" in function ${EncodeJSON(name)}`);

      p->ParseWhileInset(" \n\t");
      IF (have_n)
      {
        BOOLEAN second_positive :=p->TryParse("+");
        BOOLEAN second_negative := NOT second_positive AND p->TryParse("-");
        p->ParseWhileInset(" \n\t");
        STRING second_digits := p->ParseWhileInset(p->set_digit);
        IF (second_digits = "" AND (second_positive OR second_negative))
          THROW NEW Exception(`Expected a second number in function ${EncodeJSON(name)}`);

        factor := ToInteger(first_digits ?? "1", 0) * (negative ? -1 : 1);
        ofs := ToInteger(second_digits, 0) * (second_negative ? -1 : 1);
      }
      ELSE
      {
        ofs := ToInteger(first_digits, 0) * (negative ? -1 : 1);
      }
    }

    RETURN CELL
        [ factor
        , ofs
        , compoundselector
        ];
  }

  /** Parses functions
      @param name Function name
      @param functokens Arguments @includecelldef #CSSTokenizer::GetToken.return
      @return Parsed function parameters for evaluation
      @cell return.compoundselector Compound selector for :not function @includecelldef #ParseCompoundSelector.return
      @cell return.factor A from the An+B in nth-child-alike tests
      @cell return.ofs B from the An+B in nth-child-alike tests
  */
  RECORD FUNCTION ParseFunction(STRING name, RECORD ARRAY functokens)
  {
    SWITCH (name)
    {
      CASE "not"
      {
        OBJECT p := NEW CSSSelectorParser(functokens);
        p->TryParseWS();
        RECORD compoundselector := p->ParseCompoundSelector(TRUE);
        p->ExpectEOF();

        RETURN CELL
            [ compoundselector
            ];
      }
      CASE "nth-child", "nth-last-child"
      {
        RETURN this->ParseANPlusB(name, functokens, TRUE);
      }
      CASE "nth-of-type", "nth-last-of-type"
      {
        RETURN this->ParseANPlusB(name, functokens, FALSE);
      }
      DEFAULT
      {
        THROW NEW Exception(`Function ${EncodeJSON(name)} is not supported`);
      }
    }
  }

  /** Parses pseudo class selector
      @param name Pseudo class name
      @return Overrides for pseudoclass (can be used to transform into a function)
  */
  RECORD FUNCTION ParsePseudoClass(STRING name)
  {
    SWITCH (name)
    {
      CASE "first-child"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "last-child"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "only-child"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "first-of-type"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "last-of-type"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "only-of-type"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "empty"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "root"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "scope"
      {
        RETURN DEFAULT RECORD;
      }
      DEFAULT
      {
        THROW NEW Exception(`Pseudo-class ${EncodeJSON(name)} is not supported`);
      }
    }
  }
>;

/** Returns the 1-based index of a node (filtered with compoundselector)
    @param node Node
    @param ishtml Whether the node is from a HTML document
    @param fromstart If TRUE, get the index from the start, else from the end
    @param compoundselector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @param context Query context
    @cell(object) context.root Root node
    @cell(object) context.scope Scope node
    @return 1-based index of this node within its matching siblings list
*/
INTEGER FUNCTION GetIndex(OBJECT node, BOOLEAN ishtml, BOOLEAN fromstart, RECORD compoundselector, RECORD context)
{
  INTEGER idx := 1;
  WHILE (TRUE)
  {
    node := fromstart ? node->previouselementsibling : node->nextelementsibling;
    IF (NOT ObjectExists(node))
      RETURN idx;

    IF (NOT RecordExists(compoundselector) OR TestCompoundSelector(compoundselector, node, ishtml, context))
      idx := idx + 1;
  }
}

/** Returns whether the 1-based index of a node is 1 (filtered with compoundselector)
    @param node Node
    @param ishtml Whether the node is from a HTML document
    @param fromstart If TRUE, get the index from the start, else from the end
    @param compoundselector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @param context Query context
    @cell(object) context.root Root node
    @cell(object) context.scope Scope node
    @return 1-based index of this node within its matching siblings list
*/
BOOLEAN FUNCTION TestFirst(OBJECT node, BOOLEAN ishtml, BOOLEAN fromstart, RECORD compoundselector, RECORD context)
{
  WHILE (TRUE)
  {
    node := fromstart ? node->previouselementsibling : node->nextelementsibling;
    IF (NOT ObjectExists(node))
      RETURN TRUE;

    IF (NOT RecordExists(compoundselector) OR TestCompoundSelector(compoundselector, node, ishtml, context))
      RETURN FALSE;
  }
}

/** Test an index-based function (nth-child of)
    @param node Node
    @param ishtml Whether the node is from a HTML document
    @param fromstart If TRUE, get the index from the start, else from the end
    @param sc Test data
    @cell(integer) sc.factor A from An+B expression
    @cell(integer) sc.ofs B from An+B expression
    @cell sc.compoundselector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @param context Query context
    @cell(object) context.root Root node
    @cell(object) context.scope Scope node
    @return Whether the node matches the index-based functions
*/
BOOLEAN FUNCTION TestIndex(OBJECT node, BOOLEAN ishtml, BOOLEAN fromstart, RECORD sc, RECORD context)
{
  INTEGER idx := GetIndex(node, ishtml, fromstart, sc.compoundselector, context);
  INTEGER todiv := idx - sc.ofs;
  BOOLEAN ismatch := sc.factor = 0
        ? todiv = 0
        : todiv / sc.factor >= 0 AND todiv % sc.factor = 0;

  //DumpValue(CELL[ sc, fromstart, idx, ismatch, todiv ]);
  RETURN ismatch;
}

/** Tests if a node matches a compound selector
    @param selector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @param node Node to test
    @param ishtml Whether the node is from a HTML document
    @param context Query context
    @cell(object) context.root Root node
    @cell(object) context.scope Scope node
    @return TRUE if the node matches
*/
PUBLIC BOOLEAN FUNCTION TestCompoundSelector(RECORD selector, OBJECT node, BOOLEAN ishtml, RECORD context)
{
  // tag name test
  IF (selector.tag != "" AND
      (ishtml
          ? ToUppercase(node->localname ?? node->nodename) != ToUppercase(selector.tag)
          : (node->localname ?? node->nodename) != selector.tag))
    RETURN FALSE;

  BOOLEAN haveclasses;
  STRING ARRAY classes;

  FOREVERY (RECORD sc FROM selector.selectors)
  {
    SWITCH (sc.type)
    {
      CASE "#"
      {
        // ID matches case-sensitively
        IF (node->GetAttributeNS("", "id") != sc.value)
          RETURN FALSE;
      }
      CASE "."
      {
        // class matches case-insensitive, classes list is lowercased in this function and value already during parsing
        IF (NOT haveclasses)
        {
          classes := Tokenize(ToLowercase(node->GetAttributeNS("", "class")), " ");
          haveclasses := TRUE;
        }
        IF (sc.value NOT IN classes)
          RETURN FALSE;
      }
      CASE "["
      {
        STRING ARRAY attrvals;
        IF (sc.attrns = "" AND node->HasAttribute(sc.attr))
          attrvals := STRING[ node->GetAttribute(sc.attr) ];
        ELSE IF (sc.attrns != "*" AND node->HasAttributeNS(sc.attrns, sc.attr))
          attrvals := STRING[ node->GetAttributeNS(sc.attrns, sc.attr) ];
        ELSE
        {
          // XML documents must have exact matches for the ns and the name, so no need to search if no ns wildcard is present
          // HTML has case-insensitive matching for the attribute name
          IF (NOT ishtml AND sc.attrns != "*")
            RETURN FALSE;

          /* HTML parsers convert attributes to lowercase, but new attributes with uppercase names
             could be have been inserted. Check all attributes if a match is present
          */
          attrvals :=
              SELECT AS STRING ARRAY nodevalue
                FROM node->ListAttributes()
               WHERE (sc.attrns = "*"
                        ? TRUE
                        : namespaceuri = sc.attrns)
                 AND (ishtml
                        ? ToUppercase(localname ?? nodename) = ToUppercase(sc.attr)
                        : (localname ?? nodename) = sc.attr);
        }

        // A matching attribute MUST exist, for all comparisons
        IF (IsDefaultValue(attrvals))
          RETURN FALSE;

        BOOLEAN ismatch;
        STRING comp := sc.value;
        FOREVERY (STRING value FROM attrvals)
        {
          IF (NOT sc.casesensitive)
          {
            // sc.value was already lowercased during parsing
            value := ToLowercase(value);
          }
          SWITCH (sc.matcher)
          {
            CASE "has"    { ismatch := TRUE; }
            CASE "="      { IF (comp = value) ismatch := TRUE; }
            CASE "~="     { IF (comp IN Tokenize(value, " ")) ismatch := TRUE; }
            CASE "^="     { IF (Left(value, LENGTH(comp)) = comp) ismatch := TRUE; }
            CASE "$="     { IF (Right(value, LENGTH(comp)) = comp) ismatch := TRUE; }
            CASE "*="     { IF (SearchSubString(value, comp) != -1) ismatch := TRUE; }
            CASE "|="     { IF (Left(value, LENGTH(comp)) = comp AND SubString(value, LENGTH(comp), 1) IN [ "", "-" ]) ismatch := TRUE; }
            CASE "nomatch" { } // needed for $= with an empty value
          }
        }

        IF (NOT ismatch)
          RETURN FALSE;
      }
      CASE "("
      {
        // Evaluate functions
        SWITCH (sc.name)
        {
          CASE "not"
          {
            IF (TestCompoundSelector(sc.compoundselector, node, ishtml, context))
              RETURN FALSE;
          }
          CASE "nth-child"
          {
            IF (NOT TestIndex(node, ishtml, TRUE, sc, context))
              RETURN FALSE;
          }
          CASE "nth-last-child"
          {
            IF (NOT TestIndex(node, ishtml, FALSE, sc, context))
              RETURN FALSE;
          }
          CASE "nth-of-type"
          {
            // Construct a compound selector for the type of this node
            RECORD compoundselector :=
                [ tag :=          node->nodename
                , selectors :=    RECORD[]
                ];

            IF (NOT TestIndex(node, ishtml, TRUE, CELL[ ...sc, compoundselector ], context))
              RETURN FALSE;
          }
          CASE "nth-last-of-type"
          {
            // Construct a compound selector for the type of this node
            RECORD compoundselector :=
                [ tag :=          node->nodename
                , selectors :=    RECORD[]
                ];

            IF (NOT TestIndex(node, ishtml, FALSE, CELL[ ...sc, compoundselector ], context))
              RETURN FALSE;
          }
          DEFAULT
          {
            THROW NEW Exception(`Testing function ${sc.name} is not supported yet`);
          }
        }


      }
      CASE ":"
      {
        SWITCH (sc.name)
        {
          CASE "first-child"
          {
            IF (NOT TestFirst(node, ishtml, TRUE, DEFAULT RECORD, context))
              RETURN FALSE;
          }
          CASE "last-child"
          {
            IF (NOT TestFirst(node, ishtml, FALSE, DEFAULT RECORD, context))
              RETURN FALSE;
          }
          CASE "only-child"
          {
            IF (NOT TestFirst(node, ishtml, TRUE, DEFAULT RECORD, context))
              RETURN FALSE;
            IF (NOT TestFirst(node, ishtml, FALSE, DEFAULT RECORD, context))
              RETURN FALSE;
          }
          CASE "first-of-type", "last-of-type", "only-of-type"
          {
            // Construct a compound selector for the type of this node
            RECORD compoundselector :=
                [ tag :=          node->nodename
                , selectors :=    RECORD[]
                ];

            IF (sc.name != "last-of-type" AND NOT TestFirst(node, ishtml, TRUE, compoundselector, context))
              RETURN FALSE;
            IF (sc.name != "first-of-type" AND NOT TestFirst(node, ishtml, FALSE, compoundselector, context))
              RETURN FALSE;
          }
          CASE "root"
          {
            IF (NOT context.root->IsSameNode(node))
              RETURN FALSE;
          }
          CASE "scope"
          {
            IF (NOT context.scope->IsSameNode(node))
              RETURN FALSE;
          }
          CASE "empty"
          {
            /* CSS level 4 specs that only whitespace is also allowed, but currently
                no browser does that (caniuse.com checked at 2021-06-08)
            */
            OBJECT child := node->firstchild;
            WHILE (ObjectExists(child))
            {
              IF (child->nodetype IN [ 1, 3, 4 ]) // element, text or cdata
                RETURN FALSE;
              child := child->nextsibling;
            }
          }
          DEFAULT
          {
            THROW NEW Exception(`Testing pseudo-class ${EncodeJSON(sc.name)} is not supported yet`);
          }
        }
      }
    }
  }

  RETURN TRUE;
}

/** Returns a node path, node names with child index (like html[1] body[1] div[2])
    @param node Return the path to this node
    @return Text describing the path to a node
*/
STRING FUNCTION Debug_GetNodePath(OBJECT node)
{
  STRING name := node->nodename;
  INTEGER pos := 1;
  WHILE (ObjectExists(node->previouselementsibling))
  {
    pos := pos + 1;
    node := node->previouselementsibling;
  }
  name := `${name}[${pos}]`;
  IF (ObjectExists(node->parentnode) AND node->parentnode->nodetype = 1)
    name := `${Debug_GetNodePath(node->parentnode)} ${name}`;

  RETURN name;
}

/** Returns the path to and including a node
    @param node Node
    @return Record describing the path to a node
    @cell(object array) return.path Nodes on the path, starting at root node
    @cell(integer) return.pathlen Length of the path
*/
RECORD FUNCTION GetNodePathList(OBJECT node)
{
  OBJECT ARRAY path;
  IF (ObjectExists(node))
  {
    path := [ node ];
    WHILE (TRUE)
    {
      OBJECT parent := node->parentnode;
      IF (NOT ObjectExists(parent) OR parent->nodetype != 1)
        BREAK;
      INSERT parent INTO path AT 0;
      node := parent;
    }
  }
  RETURN CELL[ path, pathlen := LENGTH(path) ];
}

/** Selector cache
    @cell hash Selector hash
    @cell data Parsed complex selector list @includecelldef #CSSSelectorParser::ParseComplexSelectorList.return
*/
RECORD ARRAY selector_cache;

/** Parses a selector list
    @param selectors Selectors
    @param allowimplicitscope Allow start with `>` (and translate that to `:scope >`)
    @return Parsed complex selector list @includecelldef #CSSSelectorParser::ParseComplexSelectorList.return
*/
PUBLIC RECORD ARRAY FUNCTION ParseCSSRuleForEvaluation(STRING selectors, BOOLEAN allowimplicitscope)
{
  STRING hash := (allowimplicitscope?"1":"0") || __HS_INTERNAL_CalculateVariableHash(selectors);
  RECORD pos := RecordLowerBound(selector_cache, CELL[ hash ], [ "HASH" ]);
  IF (pos.found)
    RETURN selector_cache[pos.position].data;

  // Prevent unbounded cache growth
  IF (LENGTH(selector_cache) = parsed_selector_cache_size)
  {
    selector_cache := RECORD[];
    pos.position := 0;
  }

  OBJECT t := NEW CSSTokenizer(selectors);

  // Get all tokens, ignoring comments
  RECORD ARRAY tokens;
  WHILE (TRUE)
  {
    t->ConsumeToken();
    RECORD token := t->GetToken();
    IF (token.type = "eof")
      BREAK;
    IF (token.type != "ws-comment")
      INSERT token INTO tokens AT END;
  }

  OBJECT p := NEW CSSSelectorParser(tokens);
  RECORD ARRAY parsed := p->ParseComplexSelectorList(allowimplicitscope);

  INSERT CELL[ hash, data := parsed ] INTO selector_cache AT pos.position;
  RETURN parsed;
}

STRING FUNCTION GetPartStartPoint(RECORD part)
{
  STRING starts := "always";
  FOREVERY (RECORD rec FROM part.compoundselector.selectors)
    IF (rec.type = ":" AND (rec.name = "root" OR rec.name = "scope"))
      starts := rec.name;
  RETURN starts;
}

/** Evaluate CSS selectors
    @param doc Document
    @param scope Scope (set to DEFAULT OBJECT if no explicit scope is present)
    @param selectors CSS selectors
    @param mode @includecelldef #EvaluateSelectorRecursive.mode
    @return List of matching nodes
*/
PUBLIC OBJECT ARRAY FUNCTION EvaluateSelectors(OBJECT doc, OBJECT scope, STRING selectors, STRING mode)
{
  IF (mode NOT IN [ "qS", "qSA", "closest", "match" ])
    THROW NEW Exception(`Illegal engine mode ${mode}`);

  RECORD ARRAY selectorparts := ParseCSSRuleForEvaluation(selectors, mode IN [ "qS", "qSA" ]);

  // Add an empty selector cell to all parts, the evaluation needs it
  FOR (INTEGER i := 0, e := LENGTH(selectorparts); i < e; i := i + 1)
    INSERT CELL selector := DEFAULT RECORD INTO selectorparts[i];

  // If the scope is set, use the first element in the scope path as root
  // because we might be searching in a detached tree.
  RECORD scopepath := GetNodePathList(scope);
  OBJECT root := IsValueSet(scope) ? scopepath.path[0] : doc->documentelement;

  IF (NOT ObjectExists(root))
    RETURN OBJECT[];

  RETURN SELECT AS OBJECT ARRAY node FROM __EvaluateCSSSelectors(selectorparts, root, scope, mode);
}

/** Evaluate CSS selectors
    @param doc Document
    @param scope Scope (set to DEFAULT OBJECT if no explicit scope is present)
    @param selectors CSS selectors
    @cell selectors.selector CSS selector data
    @param mode @includecelldef #EvaluateSelectorRecursive.mode
    @return List of matching nodes and their matching selectors
    @cell(record array) return.matches List of matches, in document order
    @cell(object) return.matches.node Matching node
    @cell(record array) return.matches.selectors Matching selectors (not in original order!)
    @cell(record array) return.errors List of selectors with errors
    @cell(record) return.errors.selector Selector data
    @cell(object) return.errors.error Error message
*/
PUBLIC RECORD FUNCTION EvaluateMultipleSelectors(OBJECT doc, OBJECT scope, RECORD ARRAY selectors, STRING mode)
{
  IF (mode NOT IN [ "qS", "qSA", "closest", "match" ])
    THROW NEW Exception(`Illegal engine mode ${mode}`);

  RECORD retval :=
      [ errors :=     RECORD[]
      , matches :=    RECORD[]
      ];

  // Parse all selectors, add them to a bit selector array, with the correct selector data mixed in
  RECORD ARRAY selectorparts;
  FOREVERY (RECORD selector FROM selectors)
  {
    TRY
    {
      RECORD ARRAY parsed := ParseCSSRuleForEvaluation(selector.selector, mode IN [ "qS", "qSA" ]);

      FOREVERY (RECORD part FROM parsed)
        INSERT CELL[ ...part, selector ] INTO selectorparts AT END;
    }
    CATCH (OBJECT error)
    {
      INSERT CELL[ selector, error ] INTO retval.errors AT END;
    }
  }

  // If the scope is set, use the first element in the scope path as root
  // because we might be searching in a detached tree.
  RECORD scopepath := GetNodePathList(scope);
  OBJECT root := IsValueSet(scope) ? scopepath.path[0] : doc->documentelement;

  IF (NOT ObjectExists(root))
    RETURN retval;

  retval.matches := __EvaluateCSSSelectors(selectorparts, root, scope, mode);
  RETURN retval;
}
