<?wh

LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/stringparser.whlib";
LOADLIB "wh::internal/css/tokenizer.whlib";


PUBLIC RECORD ARRAY FUNCTION SplitPrelude(RECORD ARRAY prelude)
{
  RECORD ARRAY selectors;
  RECORD ARRAY tokssofar;

  FOREVERY(RECORD tok FROM prelude)
  {
    IF (tok.type = ",")
    {
      IF (Length(tokssofar) > 0)
        INSERT [ prelude := tokssofar ] INTO selectors AT END;
      tokssofar := DEFAULT RECORD ARRAY;
      CONTINUE;
    }
    INSERT tok INTO tokssofar AT END;
  }

  IF (Length(tokssofar) > 0)
    INSERT [ prelude := tokssofar ] INTO selectors AT END;

  RETURN selectors;
}

PUBLIC RECORD FUNCTION GetPreludeSpecificity(BOOLEAN followspec, RECORD ARRAY prelude)
{
  // http://www.w3.org/TR/css3-selectors/#specificity
  INTEGER a := SELECT AS INTEGER COUNT(*) FROM prelude WHERE type = "#";// The number of ID-selectors;
  INTEGER b := SELECT AS INTEGER COUNT(*) FROM prelude WHERE (type = "delim" AND value = ".") OR type = "[" OR type = ":" OR (type = "parsed-simpleblock" AND associatedtoken = "[");// The number of class selectors, attribute selectors and pseudoclasses;
  // Fix the NOT operator:
  b := b - SELECT AS INTEGER COUNT(*) FROM prelude WHERE type = "ident" AND value = "not";
  // FIXME: The value for c is currently not entirely reliable: element selectors within simple blocks must als be counted, if the simple block is part of a psuedoclass.
  INTEGER c := SELECT AS INTEGER COUNT(*) FROM prelude WHERE (type = "ident" AND ToLowercase(value) IN
    [ "html", "head", "title", "base", "link", "meta", "style", "script", "noscript", "template", "body", "section", "nav", "article", "aside",
    "h1", "h2", "h3", "h4", "h5", "h6", "header", "footer", "address", "main", "p", "hr", "pre", "blockquote", "ol", "ul", "li", "dl", "dt", "dd",
    "figure", "figcaption", "div", "a", "em", "strong", "small", "s", "cite", "q", "dfn", "abbr", "data", "time", "code", "var", "samp", "kbd",
    "sub", "sup", "i", "b", "u", "mark", "ruby", "rt", "rp", "bdi", "bdo", "span", "br", "wbr", "ins", "del", "img", "iframe", "embed", "object",
    "param", "video", "audio", "source", "track", "canvas", "map", "area", "svg", "math", "table", "caption", "colgroup", "col", "tbody", "thead",
    "tfoot", "tr", "td", "th", "form", "fieldset", "legend", "label", "input", "button", "select", "datalist", "optgroup", "option", "textarea",
    "keygen", "output", "progress", "meter", "details", "summary", "menuitem", "menu",
    /* OBSOLETE ELEMENTS */
    "acronym", "applet", "basefont", "bgsound", "big", "blink", "center", "dir", "font", "frame", "frameset", "hgroup", "isindex", "listing",
    "marquee", "nobr", "noframes", "plaintext", "spacer", "strike", "tt", "xmp" ]) OR type = ":";// The number of element selectors and pseudoclasses;
  IF(followspec)
    RETURN [ specificity := ToInteger(ToString(a) || ToString(b) || ToString(c), 0) ];

  RETURN [ a := a, b := b, c := c ];
}

PUBLIC STRING FUNCTION GetXpathForPrelude(RECORD ARRAY prelude)
{
  IF(Length(prelude) = 0)
    RETURN DEFAULT STRING;

  STRING ARRAY query;
  STRING ARRAY queries;
  BOOLEAN appendAsName := FALSE;
  BOOLEAN appendAsString := FALSE;
  BOOLEAN parseAsPseudo := FALSE;
  BOOLEAN ignoreNextIfWhiteSpace := FALSE;
  BOOLEAN atStartOfRule := TRUE;
  BOOLEAN ignoreCurrentRule := FALSE;
  BOOLEAN nextIsClassName := FALSE;
  BOOLEAN inFutureCompatMode := FALSE;
  STRING appendToNextCodePoint;
  STRING lastIdentValue;
  STRING lastIdentType;

  //dumpvalue(prelude,'tree');

  // Let's parse the prelude:
  FOREVERY(RECORD token FROM prelude)
  {
    // CSS syntax p9: 'The tokenizer described in this specification does not produce tokens for comments'
    // So, for selector purposes we must ignore them
    IF (token.type = "ws-comment")
      CONTINUE;

    IF (token.type = "ws")
    {
      // Ignore whitespace at start of rule
      IF (atStartOfRule)
        CONTINUE;

      // Ignore whitespace at end of prelude
      IF (token.startpos = prelude[END-1].startpos)
        BREAK;
    }

    IF(atStartOfRule)// If the previous rule was ignored, let's not assume we have to ignore this one as well.
      ignoreCurrentRule := FALSE;

    // Handle special cases:
    IF(ignoreNextIfWhiteSpace AND token.type = "ws")// Ignore whitespace if we're so told...
    {
      ignoreNextIfWhiteSpace := FALSE;
      CONTINUE;
    }
    ELSE IF(ignoreNextIfWhiteSpace AND Length(appendToNextCodePoint) = 0)// Nothing to do, reset the flag:
      ignoreNextIfWhiteSpace := FALSE;

    IF(appendAsName AND token.type != "ws")// Append an ident token literally
    {
      appendAsName := FALSE;
      IF(Length(appendToNextCodePoint) > 0)// A string needs to be appended:
      {
        INSERT token.value || appendToNextCodePoint INTO query AT END;
        appendToNextCodePoint := DEFAULT STRING;
      }
      ELSE// Just append the literal token
        INSERT token.value INTO query AT END;

      lastIdentValue := token.value;

      IF(nextIsClassName)
        nextIsClassName := FALSE;

      CONTINUE;
    }
    // Append a string token with quotes:
    IF(appendAsString)// Here for forward compatibility, never called wihtin this implementation, but may be needed in the near future.
    {
      appendAsString := FALSE;
      IF(Length(appendToNextCodePoint) > 0)// A string needs to be appended:
      {
        INSERT "'" || token.value || "'" || appendToNextCodePoint INTO query AT END;
        appendToNextCodePoint := DEFAULT STRING;
      }
      ELSE
        INSERT "'" || token.value || "'" INTO query AT END;

      CONTINUE;
    }
    // Handle pseudo-classes:
    IF(parseAsPseudo)
    {
      parseAsPseudo := FALSE;// Reset the flag

      SWITCH (token.type)
      {
        CASE "ident"
        {
          // Let's do some transliteration :)
          SWITCH(token.value)
          {
            CASE "first-child"
            {
              INSERT "[1]" INTO query AT END;
            }
            CASE "last-child"
            {
              INSERT "[last()]" INTO query AT END;
            }
            CASE "first-of-type"
            {
              INSERT "[1]" INTO query AT END;
            }
            CASE "last-of-type"
            {
              INSERT "[last()]" INTO query AT END;
            }
            CASE "empty"
            {
              INSERT "[count(*)=0]" INTO query AT END;
            }
            CASE "only-child"
            {
              INSERT "[count(preceding-sibling::*)+count(following-sibling::*)=0]" INTO query AT END;
            }
            CASE "only-of-type"
            {
              INSERT "[count(../" || lastIdentValue || ") = 1]" INTO query AT END;
            }
            CASE "disabled"
            {
              INSERT "[@disabled]" INTO query AT END;
            }
            CASE "checked"
            {
              INSERT "[@checked]" INTO query AT END;
            }
            CASE "not"
            {
              INSERT "[not(" INTO query AT END;
              appendToNextCodePoint := ")]";
            }
            DEFAULT
            {
              // Ignore it; we don't support :hover, :focus, :link, :visited & :active at the moment.
              IF(token.value IN [ "hover", "focus", "link", "visited", "active" ])
                ignoreCurrentRule := TRUE;
              // @NOTE: Some pseudo-classes that exist in spec 4 draft ARE implicitly supported here; the test has a case for :scope for instance.
              IF(token.value IN [ "scope" ])
                inFutureCompatMode := TRUE;
            }
          }
        }
        CASE "parsed-function"
        {
          STRING subQuery;
          // First, we construct the subquery:
          SWITCH(lastIdentType)
          {
            CASE "class"
            {
              subQuery := "[contains(concat(' ',@class,' '),' " || lastIdentValue || " ')]";
            }
            CASE "id"
            {
              subQuery := "[@id='" || lastIdentValue || "']";
            }
            CASE "ident"
            {
              subQuery := "[local-name()='" || lastIdentValue || "']";
            }
          }

          STRING argument := SerializeTokenListLine(token.value, FALSE);
          IF (argument = "")
            ignoreCurrentRule := TRUE;
          ELSE
          {
            // Next, we build the actual XPath query:
            SWITCH(token.name)
            {
              CASE "nth-of-type"
              {
                INSERT "[" || argument || "]" INTO query AT END;
              }
              CASE "nth-child"
              {
                // Invalidate the current query first (different type of selector):
                query := DEFAULT STRING ARRAY;
                INSERT "//*[" || argument || "]" || subQuery INTO query AT END;
              }
              CASE "nth-last-of-type"
              {
                INSERT "[last()-" || (ToInteger(argument, 2) - 1) || "]" INTO query AT END;
              }
              CASE "nth-last-child"
              {
                // Invalidate the current query first (different type of selector):
                query := DEFAULT STRING ARRAY;
                INSERT "//*[last()-" || (ToInteger(argument, 2) - 1) || "]" || subQuery INTO query AT END;
              }
            }
          }
        }
        DEFAULT
        {
          // Syntax error
          ignoreCurrentRule := TRUE;
        }
      }
      CONTINUE;
    } //IF(parseAsPseudo)

    // Handle simple blocks:
    IF(token.type = "parsed-simpleblock")
    {
      // Handle a simple block
      IF(Length(token.value) = 1)// Somehting in the shape of *[...]
      {
        // Handle it:
        //DumpValue(token, 'tree');
        IF(atStartOfRule)
        {
          atStartOfRule := FALSE;
          INSERT "//*" INTO query AT END;
        }
        /// Allow for one level deeper (edgecase where a pseudoclass contains another block):
        IF(TypeID(token.value[0].value) = TypeID(RECORD ARRAY))
        {
          /// We implement this specifically for the situation where a :not psuedoclass checks for the presence of an attribute
          /// using the `xxx:not([attr-name])` syntax. In this case, all we would need is the CSSTEXT property.
          /// ASSUMPTION: We assume that we are checking for attribute presence or value. Other assessment types WILL NOT work!
          STRING argument;
          IF(Length(token.value[0].value) > 1)
          {
            /// Note: This is the most naive approach that could be used here, but it will do the trick.
            BOOLEAN quotenext;
            FOREVERY(RECORD subtok FROM token.value[0].value)
            {
              IF(quotenext)
              {
                argument := argument || "'" || subtok.value || "'";
                quotenext := FALSE;
              }
              ELSE
                argument := argument || subtok.value;

              IF(subtok.value = "=")/// Assessment; next part MUST be quoted
                quotenext := TRUE;
            }
          }
          ELSE
            argument := token.value[0].value[0].csstext;

          INSERT "@" || argument || appendToNextCodePoint INTO query AT END;
        }
        ELSE
          INSERT "[@" || token.value[0].value || "]" INTO query AT END;
      }
      ELSE
      {
        IF (token.value[1].type != "delim" AND token.value[1].type NOT LIKE "*-match")
          THROW NEW Exception(`Expected an attribute operator`);

        SWITCH(token.value[1].value)// Correctly transliterate the match operators from CSS to XPath:
        {
          CASE "="
          {
            INSERT "[@" || token.value[0].value || "='" || token.value[2].value || "']" INTO query AT END;
          }
          CASE "~="
          {
            INSERT "[contains(concat(' ',@" || token.value[0].value || ",' '),' " || token.value[2].value || " ')]" INTO query AT END;
          }
          CASE "$="
          {
            INSERT "[ends-with(@" || token.value[0].value || ",'" || token.value[2].value || "')]" INTO query AT END;
          }
          CASE "^="
          {
            INSERT "[starts-with(@" || token.value[0].value || ",'" || token.value[2].value || "')]" INTO query AT END;
          }
          CASE "*="
          {
            INSERT "[contains(@" || token.value[0].value || ",'" || token.value[2].value || "')]" INTO query AT END;
          }
        }
      }
    }
    ELSE// Handle delimiters and identities:
    {
      SWITCH(token.type)
      {
        CASE "delim"
        {
          SWITCH(token.value)
          {
            CASE "."
            {
              // Concatenate "[contains(@class'" with next ident token value with "')]" and push it
              IF(atStartOfRule)
              {
                atStartOfRule := FALSE;
                INSERT "//*[contains(concat(' ',@class,' '),' " INTO query AT END;
              }
              ELSE
                IF((lastIdentType IN [ "ws" ] OR lastIdentValue IN [ "*" ]) AND NOT inFutureCompatMode)
                  INSERT "*[contains(concat(' ',@class,' '),' " INTO query AT END;
                ELSE
                {
                  INSERT "[contains(concat(' ',@class,' '),' " INTO query AT END;
                }

              appendAsName := TRUE;
              appendToNextCodePoint := " ')]";
              lastIdentType := "class";
              nextIsClassName := TRUE;
              IF(inFutureCompatMode)
                inFutureCompatMode := FALSE;

              CONTINUE;
            }
            CASE ">"
            {
              // Account for the :scope and lexically identical NULL previous token in the IF statement; this is spec 4.0 behaviour.
              ignoreNextIfWhiteSpace := TRUE;
              IF(atStartOfRule)
              {
                INSERT "//*" INTO query AT END;
                appendAsName := TRUE;
                atStartOfRule := FALSE;
              }
              ELSE
              {
                IF(Length(query) > 0)
                {
                  query[END-1] := "";
                  atStartOfRule := FALSE;
                }
                ELSE
                  INSERT "//*" INTO query AT END;
              }

              INSERT "/" INTO query AT END;

              CONTINUE;
            }
            CASE "+"
            {
              IF(Length(query) > 0)
              {
                query[END-1] := "";
                atStartOfRule := FALSE;
              }
              INSERT "/following-sibling::*[1][local-name()='" INTO query AT END;
              appendToNextCodePoint := "']";
              ignoreNextIfWhiteSpace := TRUE;
              appendAsName := TRUE;

              CONTINUE;
            }
            CASE '~'
            {
              IF(Length(query) > 0)
              {
                query[END-1] := "";
                atStartOfRule := FALSE;
              }
              INSERT "/following-sibling::" INTO query AT END;
              appendAsName := TRUE;
              ignoreNextIfWhiteSpace := TRUE;
            }
            CASE "*"
            {
              lastIdentType := "wc";
              IF(atStartOfRule)
                atStartOfRule := FALSE;

              INSERT "//*" INTO query AT END;
              CONTINUE;
            }
            CASE "|"
            {
              IF(atStartOfRule OR lastIdentType = "wc")
              {
                //IF(NOT atStartOfRule)
                //  query[END-1] := "";

                atStartOfRule := FALSE;
                INSERT "[local-name()='" INTO query AT END;
                appendAsName := TRUE;
                appendToNextCodePoint := "']";
              }
              ELSE IF(lastIdentType = "ws")
              {
                INSERT "*[local-name()='" INTO query AT END;
                appendAsName := TRUE;
                appendToNextCodePoint := "']";
              }
              ELSE
              {
                INSERT ":" INTO query AT END;
                appendAsName := TRUE;
              }
              lastIdentType := "delim";
            }
          }
        }
        CASE "#"
        {
          // Concatenate "[@id='" with next ident token value with "']" and push it
          STRING rulebase := "[@id='" || token.value || "']";
          IF(atStartOfRule)
          {
            atStartOfRule := FALSE;
            INSERT "//*" || rulebase INTO query AT END;
          }
          ELSE
            IF(lastIdentType = "ws")
              INSERT "*" || rulebase INTO query AT END;
            ELSE
              INSERT rulebase INTO query AT END;

          appendAsName := FALSE;
          appendToNextCodePoint := "";
          lastIdentType := "id";

          CONTINUE;
        }
        CASE ","
        {
          IF(ignoreCurrentRule)
          {
            ignoreCurrentRule := FALSE;
          }
          ELSE
          {
            IF(query[END-1] = "//")
              query[END-1] := "";

            INSERT Detokenize(query, "") INTO queries AT END;
          }
          query := DEFAULT STRING ARRAY;
          ignoreNextIfWhiteSpace := TRUE;
          atStartOfRule := TRUE;
        }
        CASE "ws"
        {
          IF(Length(query) > 0 AND query[END-1] NOT IN [ "/", "//" ])
            INSERT "//" INTO query AT END;

          ignoreNextIfWhiteSpace := TRUE;
          lastIdentType := "ws";
        }
        CASE ":"
        {
          // Get the pseudo:
          parseAsPseudo := TRUE;
          CONTINUE;
        }
        CASE "@"
        {
          RETURN "";
        }
        CASE "ident"
        {
          // Assume literal, just add it:
          IF(atStartOfRule)
          {
            STRING prepend;
            IF(token.value = "html")// The HTML element is a special case: It can only exist as the root element.
              prepend := "/";
            ELSE
              prepend := "//";

            INSERT prepend || "*[local-name()='" || token.value || "']" INTO query AT END;
            atStartOfRule := FALSE;
          }
          ELSE
            INSERT "*[local-name()='" || token.value || "']" INTO query AT END;

          lastIdentValue := token.value;
          lastIdentType := "ident";

        }
        DEFAULT
        {
          CONTINUE;
        }
      }
    }
  }
  IF(NOT ignoreCurrentRule)// Add the parsed selector query to the list of queries
    INSERT Detokenize(query, "") INTO queries AT END;

  // Combine all XPath queries, concatenating the with a query separator "|" and return the resulting string:
  RETURN Detokenize(queries, "|");
}


PUBLIC OBJECTTYPE CSSException EXTEND Exception
< STRING pvt_code;
  PUBLIC PROPERTY code(pvt_code, -);

  MACRO NEW(STRING code, STRING message)
  : Exception(code || ": " || message)
  {
    this->pvt_code := code;
  }
>;

PUBLIC STRING ARRAY FUNCTION ExtractURLsFromTokens(RECORD ARRAY tokens)
{
  STRING ARRAY urls;
  FOREVERY (RECORD token FROM tokens)
  {
    SWITCH (token.type)
    {
      CASE "url"                  { INSERT token.value INTO urls AT END; }
      CASE "parsed-simpleblock"   { urls := urls CONCAT ExtractURLSFromTokens(token.value); }
    }
  }
  RETURN urls;
}

PUBLIC RECORD ARRAY FUNCTION RewriteURLsInTokens(RECORD ARRAY tokens, FUNCTION PTR rewriter, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  STRING baseurl;
  IF(CellExists(options, "BASEURL"))
    baseurl := options.baseurl;

  FOREVERY (RECORD token FROM tokens)
  {
    SWITCH (token.type)
    {
      CASE "url"
      {
        STRING url := token.value;

        IF (CellExists(options, "BASEURL"))
          url := ResolveToAbsoluteURL(options.baseurl, url);

        // Apply the rewriter, if any:
        IF (rewriter != DEFAULT FUNCTION PTR)
          url := rewriter(url);

        token.value := url;
        token.csstext := token.type || '("' || EncodeCSSString(url) || '")';

        tokens[#token] := token;
      }
      CASE "parsed-simpleblock"
      {
        tokens[#token].value := RewriteURLsInTokens(token.value, rewriter, options);
      }
    }
  }

  RETURN tokens;
}

STATIC OBJECTTYPE CSSSelectorParser
< /** @cell root Root node
      @cell scope Scope node
  */
  RECORD config;

  /** List of CSS tokens to parse @includecelldef #CSSTokenizer::GetToken.return
  */
  RECORD ARRAY tokens;

  /// Current token within the token array
  INTEGER pos;

  /// Current token (= this->tokens[this->pos]) @includecelldef #CSSTokenizer::GetToken.return
  RECORD token;

  MACRO NEW(RECORD ARRAY tokens, RECORD config)
  {
    this->tokens := RECORD[ ...tokens, [ type := "eof", value := "", csstext := "" ] ];
    this->pos := 0;
    this->token := tokens[0];
    this->config := config;
  }

  /** Advance to the next token
  */
  MACRO Next()
  {
    this->pos := this->pos + 1;
    this->token := this->tokens[this->pos];
  }

  /** Eat whitespace, and return whether EOF has been reached
      @return TRUE if EOF has been reached
  */
  PUBLIC BOOLEAN FUNCTION AtEOF()
  {
    WHILE (this->TryParseWS())
      {}
    RETURN this->token.type = "eof";
  }

  /** Parses all whitespaces, returns if any was encountered
      @return TRUE if whitespace was found
  */
  PUBLIC BOOLEAN FUNCTION TryParseWS()
  {
    BOOLEAN retval;
    WHILE (this->token.type = "ws")
    {
      retval := TRUE;
      this->Next();
    }
    RETURN retval;
  }

  /** Parses a token by value. Does not match strings
      @param token Token value to match
      @return TRUE if the requested token was found and consimed
  */
  BOOLEAN FUNCTION TryParse(STRING token)
  {
    // Strings can have arbitrary values, don't match them
    IF (this->token.value != token OR this->token.type = "string")
      RETURN FALSE;
    this->Next();
    RETURN TRUE;
  }

  /** Expects end of token stream (allows trailing whitespace), throws
      if a non-whitespace token was found.
  */
  PUBLIC MACRO ExpectEOF()
  {
    IF (NOT this->AtEOF())
      THROW NEW Exception(`Found unexpected token ${EncodeJSON(this->token.csstext)}`);
  }

  /** Parses a token by type
      @param type Type of token that needs to be matched
      @return Consumed token if the current token was of the requested type @includecelldef #CSSTokenizer::GetToken.return
  */
  RECORD FUNCTION TryParseType(STRING type)
  {
    IF (this->token.type != type)
      RETURN DEFAULT RECORD;
    RECORD token := this->token;
    this->Next();
    RETURN token;
  }

  /** Parses a complex selector list
      @return @includecelldef #ParseComplexSelector.return
  */
  PUBLIC RECORD ARRAY FUNCTION ParseComplexSelectorList()
  {
    this->TryParseWS();
    RECORD ARRAY selectors;
    WHILE (TRUE)
    {
      INSERT this->ParseComplexSelector() INTO selectors AT END;

      this->TryParseWS();
      IF (NOT this->TryParse(","))
        BREAK;

      this->TryParseWS();
    }
    this->ExpectEOF();

    RETURN selectors;
  }

  /** Parses a complex selector list
      @return Single selector split into compoiund selectors and the combinators
      @cell(record array) return.parts Compound selectors and their combinators
      @cell(record array) return.parts.compoundselector Compound selector @includecelldef #ParseComplexSelector.return
      @cell(record array) return.parts.combinator Combinator AFTER the compound selector
        - "": return if matches
        - " ": any descendent matches
        - ">": direct descendent matches
        - "~": any following sibling matches
        - "+": next sibling matches
  */
  RECORD FUNCTION ParseComplexSelector()
  {
    RECORD ARRAY parts;
    BOOLEAN requireselector := TRUE;
    WHILE (TRUE)
    {
      RECORD compoundselector := this->ParseCompoundSelector(requireselector);
      IF (NOT RecordExists(compoundselector))
      {
        // last combinator must be " ", fix to ""
        parts[END-1].combinator := "";
        BREAK;
      }

      STRING combinator := this->ParseCombinator();
      INSERT CELL[ combinator, compoundselector ] INTO parts AT END;

      IF (combinator = "")
        BREAK;

      requireselector := combinator != " ";
    }
    RETURN CELL[ parts ];
  }

  /** Parses a combinator
      @return Combinator
        - "": return if matches
        - " ": any descendent matches
        - ">": direct descendent matches
        - "~": any following sibling matches
        - "+": next sibling matches
  */
  STRING FUNCTION ParseCombinator()
  {
    BOOLEAN have_ws;
    WHILE (this->TryParseWS())
      have_ws := TRUE;

    IF (this->token.type != "delim" OR this->token.value NOT IN [ ">", "+", "~" ])
      RETURN have_ws ? " " : "";

    STRING retval := this->token.value;
    this->Next();

    WHILE (this->TryParseWS())
    {}

    RETURN retval;
  }

  /** Parses a compound selector
      @return Compound selector
      @cell(string) return.tagname Expected tag name ('*' if all match)
      @cell(record array) return.subclasses Subclass tests. Pseudo-class tests can have custom fields, returned
        by ParseFunction and ParsePseudoClass
      @cell(record array) return.subclasses.type Type of test
        - "#": ID test
        - ".": class tests
        - "[": attribute test
        - "(": function test
        - ":": pseudo-class test
      @cell(record array) return.subclasses.value Match value
        - ID (for id test)
        - class (for class test)
        - attribute value (for attribute test). Lowercased for case insensitive matches.
      @cell(record array) return.subclasses.name Name of function / pseudo class
      @cell(record array) return.subclasses.attr Attribute name (for attribute test)
      @cell(record array) return.subclasses.casesensitive Whether attribute test is case sensitive
      @cell(record array) return.subclasses.matcher Attribute matching function (for attribute test)
        - "": only existence check
        - "=": equality check
        - "~=": value exists in space-separated list
        - "|=": valus is first value in hyphen-separated list
        - "^=": attribute value starts with value
        - "$=": attribute value ends with value
        - "*=": attribute value contains with value
        - "nomatch": used for attributepart matches with an empty string - they don't match any element
      @cell(record array) return.subclasses.tokens Function tokens (for function test) @includecelldef #CSSTokenizer::GetToken.return
  */
  PUBLIC RECORD FUNCTION ParseCompoundSelector(BOOLEAN required)
  {
    BOOLEAN have_item;

    STRING tagname := "*";
    RECORD ident := this->TryParseType("ident");
    IF (RecordExists(ident))
    {
      have_item := TRUE;
      tagname := ident.value;
    }
    ELSE IF (this->TryParse("*"))
      have_item := TRUE;

    RECORD ARRAY subclasses;

    BOOLEAN have_colon;

    WHILE (TRUE)
    {
      RECORD hashid := this->TryParseType("#");
      IF (RecordExists(hashid))
      {
        have_item := TRUE;
        INSERT CELL[ type := "#", hashid.value ] INTO subclasses AT END;
      }
      ELSE IF (this->TryParse("."))
      {
        have_item := TRUE;
        this->TryParseWS();
        ident := this->TryParseType("ident");
        IF (NOT RecordExists(ident))
          THROW NEW Exception(`Expected an identifier after '.'`);
        INSERT CELL[ type := ".", value := ToLowercase(ident.value) ] INTO subclasses AT END;
      }
      ELSE IF (this->TryParse("["))
      {
        have_item := TRUE;
        this->TryParseWS();
        STRING attrns := "";
        IF (this->TryParse("*"))
        {
          attrns := "*";
          IF (NOT this->TryParse("|"))
            THROW NEW Exception(`Expected "|" after "*" in attribute test`);
          ident := this->TryParseType("ident");
        }
        ELSE
        {
          ident := this->TryParseType("ident");
          IF (this->TryParse("|"))
            THROW NEW Exception(`Namespace prefixes in CSS selectors not supported`);
        }
        IF (NOT RecordExists(ident))
          THROW NEW Exception(`Expected an attribute name`);
        this->TryParseWS();
        STRING matcher := "has";
        STRING value;
        BOOLEAN casesensitive;
        IF (this->token.value IN [ "=", "~=", "|=", "^=", "$=", "*=" ])
        {
          matcher := this->token.value;
          this->Next();
          this->TryParseWS();

          IF (this->token.type IN [ "ident", "string" ])
            value := this->token.value;
          ELSE
            THROW NEW Exception(`Expected attribute value`);

          this->Next();
          this->TryParseWS();

          casesensitive := NOT this->TryParse("i");
          IF (casesensitive)
            this->TryParseWS();

          IF (value = "" AND matcher IN [ "^=", "$=", "*=" ])
            matcher := "nomatch";

          // [ <string-token> | <ident-token> ] <attr-modifier>? ']'
        }
        ELSE
          this->TryParseWS();

        IF (NOT this->TryParse("]"))
          THROW NEW Exception(`Expected "]"`);

        INSERT CELL
            [ type :=   "["
            , attr :=   ident.value
            , attrns
            , matcher
            , value :=  casesensitive ? value : ToLowercase(value)
            , casesensitive
            ] INTO subclasses AT END;
      }
      ELSE IF (this->TryParse(":"))
      {
        have_item := TRUE;
        IF (this->token.value = ":")
        {
          have_colon := TRUE;
          BREAK;
        }
        ELSE
        {
          ident := this->TryParseType("ident") ?? this->TryParseType("function");
          IF (NOT RecordExists(ident))
            THROW NEW Exception(`Expected an identifier or a function`);
          IF (ident.type = "function" OR this->TryParse("(")) // no whitespace
          {
            STRING ARRAY delims := [ "(" ];

            RECORD ARRAY functokens;

            WHILE (LENGTH(delims) > 0)
            {
              IF (this->token.type = "eof")
                THROW NEW Exception(`Unexpected end of selector`);
              IF (this->token.value IN [ "(", "[", "{" ])
                INSERT this->token.value INTO delims AT END;
              ELSE IF (this->token.type = "function")
                INSERT "(" INTO delims AT END;
              ELSE IF (this->token.value IN [ ")", "]", "}" ])
              {
                IF (delims[END-1] != [ "(", "[", "{" ][SearchElement([ ")", "]", "}" ], this->token.value)])
                  THROW NEW Exception(`Unmatched closing token ${EncodeJSON(this->token.value)}`);
                DELETE FROM delims AT END - 1;
                IF (IsDefaultValue(delims))
                {
                  this->Next();
                  BREAK;
                }
              }
              ELSE IF (this->token.type = "bad-string" OR this->token.type = "bad-url")
                THROW NEW Exception(`Found a improperly encoded string or url`);
              INSERT this->token INTO functokens AT END;
              this->Next();
            }

            INSERT
                [ type :=     "("
                , name :=     ident.value
                , tokens :=   functokens
                , ...this->ParseFunction(ident.value, functokens)
                ] INTO subclasses AT END;
          }
          ELSE
          {
            INSERT
                [ type :=     ":"
                , name :=     ident.value
                , ...this->ParsePseudoClass(ident.value)
                ] INTO subclasses AT END;
          }
        }
      }
      ELSE
        BREAK;
    }

    IF (have_colon)
    {
      this->Next();
      THROW NEW Exception(`Pseudo element selectors are not supported`);
    }

    IF (NOT have_item)
    {
      IF (required)
        THROW NEW Exception(`Expected a compound selector${this->token.csstext = "" ? "" : `, got token ${EncodeJSON(this->token.csstext)}`}`);
      RETURN DEFAULT RECORD;
    }

    RETURN CELL
        [ tagname
        , subclasses
        ];
  }

  /** Parses An+B syntax for nth-child ea.
      @param name Name of function
      @param functokens Token list with the parameters CSSTokenizer::GetToken.return
      @param allowselector Whether to a allow a compound selector
      @return Parsed parameters
      @cell return.compoundselector Compound selector for :not function @includecelldef #ParseCompoundSelector.return
      @cell return.factor A from the An+B in nth-child-alike tests
      @cell return.ofs B from the An+B in nth-child-alike tests
  */
  RECORD FUNCTION ParseANPlusB(STRING name, RECORD ARRAY functokens, BOOLEAN allowselector)
  {
    // Compound selector is CSS4, but useful in implementing nth-of-type
    RECORD compoundselector;

    // Collect tokens into a string (doesn't handle escaping very will, though)
    // ADDME: rewrite folling CSS4 selector spec
    STRING str;
    BOOLEAN have_of;
    FOREVERY (RECORD token FROM functokens)
    {
      IF (token.type NOT IN [ "number", "ident", "dimension", "ws" ])
        THROW NEW Exception(`Syntax error in An+B expression, unexpected token ${EncodeJSON(token.csstext)}`);

      IF (token.type = "ident" AND token.value = "of" AND allowselector)
      {
        OBJECT p := NEW CSSSelectorParser(ArraySlice(functokens, #token + 1), this->config);
        p->TryParseWS();
        compoundselector := p->ParseCompoundSelector(TRUE);
        p->ExpectEOF();
        BREAK;
      }
      IF (token.type = "eof")
        BREAK;

      str := str || token.csstext;
    }

    STRING toparse := TrimWhitespace(ToLowercase(str));

    // CSS3 selector spec
    OBJECT p := NEW StringParser(TrimWhitespace(ToLowercase(str)));

    // S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
    //      ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*

    p->ParseWhileInset(" \n\t");

    INTEGER factor, ofs;
    IF (p->TryParse("even"))
    {
      factor := 2;
    }
    ELSE IF (p->TryParse("odd"))
    {
      factor := 2;
      ofs := 1;
    }
    ELSE
    {
      BOOLEAN negative := NOT p->TryParse("+") AND p->TryParse("-");
      STRING first_digits := p->ParseWhileInset(p->set_digit);
      BOOLEAN have_n := p->TryParse("n");

      IF (first_digits = "" AND NOT have_n)
        THROW NEW Exception(`Expected a number or "n" in function ${EncodeJSON(name)}`);

      p->ParseWhileInset(" \n\t");
      IF (have_n)
      {
        BOOLEAN second_positive :=p->TryParse("+");
        BOOLEAN second_negative := NOT second_positive AND p->TryParse("-");
        p->ParseWhileInset(" \n\t");
        STRING second_digits := p->ParseWhileInset(p->set_digit);
        IF (second_digits = "" AND (second_positive OR second_negative))
          THROW NEW Exception(`Expected a second number in function ${EncodeJSON(name)}`);

        factor := ToInteger(first_digits ?? "1", 0) * (negative ? -1 : 1);
        ofs := ToInteger(second_digits, 0) * (second_negative ? -1 : 1);
      }
      ELSE
      {
        ofs := ToInteger(first_digits, 0) * (negative ? -1 : 1);
      }
    }

    RETURN CELL
        [ factor
        , ofs
        , compoundselector
        ];
  }

  /** Parses functions
      @param name Function name
      @param functokens Arguments @includecelldef #CSSTokenizer::GetToken.return
      @return Parsed function parameters for evaluation
      @cell return.compoundselector Compound selector for :not function @includecelldef #ParseCompoundSelector.return
      @cell return.factor A from the An+B in nth-child-alike tests
      @cell return.ofs B from the An+B in nth-child-alike tests
  */
  RECORD FUNCTION ParseFunction(STRING name, RECORD ARRAY functokens)
  {
    SWITCH (name)
    {
      CASE "not"
      {
        OBJECT p := NEW CSSSelectorParser(functokens, this->config);
        p->TryParseWS();
        RECORD compoundselector := p->ParseCompoundSelector(TRUE);
        p->ExpectEOF();

        RETURN CELL
            [ compoundselector
            ];
      }
      CASE "nth-child", "nth-last-child"
      {
        RETURN this->ParseANPlusB(name, functokens, TRUE);
      }
      CASE "nth-of-type", "nth-last-of-type"
      {
        RETURN this->ParseANPlusB(name, functokens, FALSE);
      }
      DEFAULT
      {
        THROW NEW Exception(`Function ${EncodeJSON(name)} is not supported`);
      }
    }
  }

  /** Parses functions
      @param name Function name
      @return Parsed pseudo class / function parameters for evaluation
      @cell return.type Type override (used to expand a pseudo-class into a function)
      @cell return.name Name override (used to expand a pseudo-class into a function)
      @cell return.compoundselector Compound selector for :not function @includecelldef #ParseCompoundSelector.return
      @cell(integer) return.factor A from the An+B in nth-child-alike tests
      @cell(integer) return.ofs B from the An+B in nth-child-alike tests
      @cell(object) return.node Exact node match (for :scope and :root)
  */
  RECORD FUNCTION ParsePseudoClass(STRING name)
  {
    // We rewrite the ...-child and ...-of-type to the nth-... forms
    // need to overwrite type and name too to make it functions
    SWITCH (name)
    {
      CASE "first-child"
      {
        RETURN
            [ type :=             "("
            , name :=             "nth-child"
            , factor :=           0
            , ofs :=              1
            , compoundselector := DEFAULT RECORD
            ];
      }
      CASE "last-child"
      {
        RETURN
            [ type :=             "("
            , name :=             "nth-last-child"
            , factor :=           0
            , ofs :=              1
            , compoundselector := DEFAULT RECORD
            ];
      }
      CASE "only-child"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "first-of-type"
      {
        RETURN
            [ type :=               "("
            , name :=               "nth-of-type"
            , factor :=             0
            , ofs :=                1
            ];
      }
      CASE "last-of-type"
      {
        RETURN
            [ type :=             "("
            , name :=               "nth-last-of-type"
            , factor :=             0
            , ofs :=                1
            ];
      }
      CASE "only-of-type"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "empty"
      {
        RETURN DEFAULT RECORD;
      }
      CASE "root"
      {
        RETURN
            [ node :=   this->config.root
            ];
      }
      CASE "scope"
      {
        RETURN
            [ node :=   this->config.scope
            ];
      }
      DEFAULT
      {
        THROW NEW Exception(`Pseudo-class ${EncodeJSON(name)} is not supported`);
      }
    }
  }
>;

/** Returns the 1-based index of a node (filtered with compoundselector)
    @param node Node
    @param fromstart If TRUE, get the index from the start, else from the end
    @param compoundselector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @return 1-based index of this node within its matching siblings list
*/
INTEGER FUNCTION GetIndex(OBJECT node, BOOLEAN fromstart, RECORD compoundselector)
{
  INTEGER idx := 1;
  WHILE (TRUE)
  {
    node := fromstart ? node->previouselementsibling : node->nextelementsibling;
    IF (NOT ObjectExists(node))
      RETURN idx;

    IF (NOT RecordExists(compoundselector) OR TestCompoundSelector(compoundselector, node))
      idx := idx + 1;
  }

  RETURN idx;
}

/** Test an index-based function (nth-child of)
    @param node Node
    @param fromstart If TRUE, get the index from the start, else from the end
    @param sc Test data
    @cell(integer) sc.factor A from An+B expression
    @cell(integer) sc.ofs B from An+B expression
    @cell sc.compoundselector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @return Whether the node matches the index-based functions
*/
BOOLEAN FUNCTION TestIndex(OBJECT node, BOOLEAN fromstart, RECORD sc)
{
  INTEGER idx := GetIndex(node, fromstart, sc.compoundselector);
  INTEGER todiv := idx - sc.ofs;
  BOOLEAN ismatch := sc.factor = 0
        ? todiv = 0
        : todiv / sc.factor >= 0 AND todiv % sc.factor = 0;

  //DumpValue(CELL[ sc, fromstart, idx, ismatch, todiv ]);
  RETURN ismatch;
}

/** Tests if a node matches a compound selector
    @param selector Compound selector @includecelldef #CSSSelectorParser::ParseCompoundSelector.return
    @param node Node to test
    @return TRUE if the node matches
*/
PUBLIC BOOLEAN FUNCTION TestCompoundSelector(RECORD selector, OBJECT node)
{
  // tag name test
  IF (selector.tagname != "*" AND
      (MemberExists(node->ownerdocument, "__IS_HTML_DOCUMENT")
          ? ToUppercase(node->localname ?? node->nodename) != ToUppercase(selector.tagname)
          : (node->localname ?? node->nodename) != selector.tagname))
    RETURN FALSE;

  STRING ARRAY classes := Tokenize(ToLowercase(node->GetAttribute("class")), " ");

  FOREVERY (RECORD sc FROM selector.subclasses)
  {
    SWITCH (sc.type)
    {
      CASE "#"
      {
        // ID matches case-sensitively
        IF (node->GetAttribute("id") != sc.value)
          RETURN FALSE;
      }
      CASE "."
      {
        // class matches case-insensitive, classes list is lowercased in this function and value already during parsing
        IF (sc.value NOT IN classes)
          RETURN FALSE;
      }
      CASE "["
      {
        STRING ARRAY attrvals;
        IF (sc.attrns = "" AND node->HasAttribute(sc.attr))
          attrvals := STRING[ node->GetAttribute(sc.attr) ];
        ELSE IF (sc.attrns != "*" AND node->HasAttributeNS(sc.attrns, sc.attr))
          attrvals := STRING[ node->GetAttributeNS(sc.attrns, sc.attr) ];
        ELSE
        {
          BOOLEAN ishtml := MemberExists(node->ownerdocument, "__IS_HTML_DOCUMENT");

          // XML documents must have exact matches for the ns and the name, so no need to search if no ns wildcard is present
          // HTML has case-insensitive matching for the attribute name
          IF (NOT ishtml AND sc.attrns != "*")
            RETURN FALSE;

          /* HTML parsers convert attributes to lowercase, but new attributes with uppercase names
             could be have been inserted. Check all attributes if a match is present
          */
          attrvals :=
              SELECT AS STRING ARRAY nodevalue
                FROM node->ListAttributes()
               WHERE (sc.attrns = "*"
                        ? TRUE
                        : namespaceuri = sc.attrns)
                 AND (ishtml
                        ? ToUppercase(localname ?? nodename) = ToUppercase(sc.attr)
                        : (localname ?? nodename) = sc.attr);
        }

        // A matching attribute MUST exist, for all comparisons
        IF (IsDefaultValue(attrvals))
          RETURN FALSE;

        BOOLEAN ismatch;
        STRING comp := sc.value;
        FOREVERY (STRING value FROM attrvals)
          {
          IF (NOT sc.casesensitive)
          {
            // sc.value was already lowercased during parsing
            value := ToLowercase(value);
          }
          SWITCH (sc.matcher)
          {
            CASE "has"    { ismatch := TRUE; }
            CASE "="      { IF (comp = value) ismatch := TRUE; }
            CASE "~="     { IF (comp IN Tokenize(value, " ")) ismatch := TRUE; }
            CASE "^="     { IF (Left(value, LENGTH(comp)) = comp) ismatch := TRUE; }
            CASE "$="     { IF (Right(value, LENGTH(comp)) = comp) ismatch := TRUE; }
            CASE "*="     { IF (SearchSubString(value, comp) != -1) ismatch := TRUE; }
            CASE "|="     { IF (Left(value, LENGTH(comp)) = comp AND SubString(value, LENGTH(comp), 1) IN [ "", "-" ]) ismatch := TRUE; }
            CASE "nomatch" { } // needed for $= with an empty value
          }
        }

        IF (NOT ismatch)
          RETURN FALSE;
      }
      CASE "("
      {
        // Evaluate functions
        SWITCH (sc.name)
        {
          CASE "not"
          {
            IF (TestCompoundSelector(sc.compoundselector, node))
              RETURN FALSE;
          }
          CASE "nth-child"
          {
            IF (NOT TestIndex(node, TRUE, sc))
              RETURN FALSE;
          }
          CASE "nth-last-child"
          {
            IF (NOT TestIndex(node, FALSE, sc))
              RETURN FALSE;
          }
          CASE "nth-of-type"
          {
            // Construct a compound selector for the type of this node
            RECORD compoundselector :=
                [ tagname :=      node->nodename
                , subclasses :=   RECORD[]
                ];

            IF (NOT TestIndex(node, TRUE, CELL[ ...sc, compoundselector ]))
              RETURN FALSE;
          }
          CASE "nth-last-of-type"
          {
            // Construct a compound selector for the type of this node
            RECORD compoundselector :=
                [ tagname :=      node->nodename
                , subclasses :=   RECORD[]
                ];

            IF (NOT TestIndex(node, FALSE, CELL[ ...sc, compoundselector ]))
              RETURN FALSE;
          }
          DEFAULT
          {
            THROW NEW Exception(`Testing function ${sc.name} is not supported yet`);
          }
        }


      }
      CASE ":"
      {
        SWITCH (sc.name)
        {
          CASE "root"
          {
            IF (NOT sc.node->IsSameNode(node))
              RETURN FALSE;
          }
          CASE "scope"
          {
            IF (NOT sc.node->IsSameNode(node))
              RETURN FALSE;
          }
          CASE "empty"
          {
            /* CSS level 4 specs that only whitespace is also allowed, but currently
                no browser does that (caniuse.com checked at 2021-06-08)
            */
            OBJECT child := node->firstchild;
            WHILE (ObjectExists(child))
            {
              IF (child->nodetype IN [ 1, 3, 4 ]) // element, text or cdata
                RETURN FALSE;
              child := child->nextsibling;

            }
          }
          CASE "only-child"
          {
            // use nth-first-child and nth-last-child evaluations
            RECORD test := [ factor := 0, ofs := 1, compoundselector := DEFAULT RECORD ];
            IF (NOT TestIndex(node, TRUE, test))
              RETURN FALSE;
            IF (NOT TestIndex(node, FALSE, test))
              RETURN FALSE;
          }
          CASE "only-of-type"
          {
            // use nth-first-of-type and nth-last-of-type evaluations
            RECORD compoundselector :=
                [ tagname :=      node->nodename
                , subclasses :=   RECORD[]
                ];

            RECORD test := CELL[ factor := 0, ofs := 1, compoundselector ];
            IF (NOT TestIndex(node, TRUE, test))
              RETURN FALSE;
            IF (NOT TestIndex(node, FALSE, test))
              RETURN FALSE;
          }
          DEFAULT
          {
            THROW NEW Exception(`Testing pseudo-class ${EncodeJSON(sc.name)} is not supported yet`);
          }
        }
      }
    }
  }

  RETURN TRUE;
}

/** Returns a node path, node names with child index (like html[1] body[1] div[2])
    @param node Return the path to this node
    @return Text describing the path to a node
*/
STRING FUNCTION Debug_GetNodePath(OBJECT node)
{
  STRING name := node->nodename;
  INTEGER pos := 1;
  WHILE (ObjectExists(node->previouselementsibling))
  {
    pos := pos + 1;
    node := node->previouselementsibling;
  }
  name := `${name}[${pos}]`;
  IF (ObjectExists(node->parentnode) AND node->parentnode->nodetype = 1)
    name := `${Debug_GetNodePath(node->parentnode)} ${name}`;

  RETURN name;
}

/** Returns the path to and including a node
    @param node Node
    @return Record describing the path to a node
    @cell(object array) return.path Nodes on the path, starting at root node
    @cell(integer) return.pathlen Length of the path
*/
RECORD FUNCTION GetNodePathList(OBJECT node)
{
  OBJECT ARRAY path;
  IF (ObjectExists(node))
  {
    path := [ node ];
    WHILE (TRUE)
    {
      OBJECT parent := node->parentnode;
      IF (NOT ObjectExists(parent) OR parent->nodetype != 1)
        BREAK;
      INSERT parent INTO path AT 0;
      node := parent;
    }
  }
  RETURN CELL[ path, pathlen := LENGTH(path) ];
}

/** Evaluate CSS selectors
    @param doc Document
    @param scope Scope (set to DEFAULT OBJECT if no explicit scope is present)
    @param selectors CSS selectors
    @param mode @includecelldef #EvaluateSelectorRecursive.mode
    @return List of matching nodes
*/
PUBLIC OBJECT ARRAY FUNCTION EvaluateSelectors(OBJECT doc, OBJECT scope, STRING selectors, STRING mode)
{
  IF (mode NOT IN [ "qS", "qSA", "closest", "match" ])
    THROW NEW Exception(`Illegal engine mode ${mode}`);

  OBJECT t := NEW CSSTokenizer(selectors);

  // Get all tokens, ignoring comments
  RECORD ARRAY tokens;
  WHILE (TRUE)
  {
    t->ConsumeToken();
    RECORD token := t->GetToken();
    IF (token.type = "eof")
      BREAK;
    IF (token.type != "ws-comment")
      INSERT token INTO tokens AT END;
  }

  // If the scope is set, use the first element in the scope path as root
  // because we might be searching in a detached tree.
  RECORD scopepath := GetNodePathList(scope);
  OBJECT root := IsValueSet(scope) ? scopepath.path[0] : doc->documentelement;

  RECORD config :=
      [ root :=       root
      , scope :=      scope ?? root
      ];

  OBJECT p := NEW CSSSelectorParser(tokens, config);
  RECORD ARRAY parsed := p->ParseComplexSelectorList();

  /* Concatenate the selector parts into a big selector array
    A single selector ends at combinator "" (match). Keep the indices
    of the first part of the rules.
  */
  INTEGER ARRAY alwaysactive;
  RECORD ARRAY selectorparts;
  FOREVERY (RECORD rec FROM parsed)
  {
    INSERT LENGTH(selectorparts) INTO alwaysactive AT END;
    FOREVERY (RECORD part FROM rec.parts)
      INSERT part INTO selectorparts AT END;
  }


  RETURN EvaluateSelectorRecursive(root, selectorparts, alwaysactive, scopepath, mode);
}

/** Iterate depth-first through the DOM, keeping lists of which compound selector parts of selectors are active
    When an active rule part matches, schedule checks for the next part at the relevant nodes. Return the
    nodes that match the last rule part of a selector - when they also match the query mode
    @param rootnode Node to start
    @param selectorparts Selector parts @includecelldef #CSSSelectorParser::ParseComplexSelectorList.return.parts
    @param startrules Positions of the first part of all selectors
    @param scopepath Path to explicit scope (empty path if the scope was set to :root implicitly)
    @param mode Selection mode
      - 'qS': querySelector mode, return the first match (within the scope subtree, if passed)
      - 'qSA': querySelector mode, return the first match (within the scope subtree, if passed)
      - 'match': match mode, return the scope node if it matches
      - 'closest': closest mode, return the closest node that matches
    @return List of matching nodes
*/
OBJECT ARRAY FUNCTION EvaluateSelectorRecursive(OBJECT rootnode, RECORD ARRAY selectorparts, INTEGER ARRAY startrules, RECORD scopepath, STRING mode)
{
  OBJECT ARRAY retval;

  // Current depth in nodes, :root is depth 0
  INTEGER depth := 0;

  // When mode is 'closest' or 'match', don't allow recursing outside of scope path
  INTEGER maxdepth;
  INTEGER min_return_depth;

  IF (mode IN [ "qS", "qSA" ])
  {
    // qS(A) may not return stuff in the scope path, needs to recurse into children of the scope
    maxdepth := 2147483647;
    min_return_depth := scopepath.pathlen;
  }
  ELSE
  {
    // match may only return the scope element, closest all items in the scope path (and we'll return the last)
    maxdepth := scopepath.pathlen - 1;
    min_return_depth := mode = "closest" ? 0 : scopepath.pathlen - 1;
  }

  /* Evaluation stack
     Contains a record for every node in the path to the current node
     @cell node Node to test next (is set to nextsibling before recursing into children)
     @cell alwaysactive List of selector parts positions that are always active in the tree
     @cell levelactive List of selector parts positions that are active at this level (children of the current parent). Also
       includes all positions in the alwaysactive list.
     @cell nodeactive List of selectors that are active for the current node (in #node)
  */
  RECORD ARRAY stack :=
      [ CELL
        [ node :=           rootnode
        , alwaysactive :=   startrules
        , levelactive :=    startrules
        , nodeactive :=     INTEGER[]
        ]
      ];

  WHILE (TRUE)
  {
    RECORD elt := stack[depth];

    OBJECT testnode := elt.node;

    // for children, all items that are always active at this point are active, active at its level is filled by '>' combinators.
    INTEGER ARRAY childalwaysactive := elt.alwaysactive, childlevelactive;

    // Is this node a match?
    BOOLEAN ismatch;

    // List of rules active at the next node, filled by "+" combinators
    INTEGER ARRAY newnodeactive;

    // Is the current node in the path to the current :scope element?
    BOOLEAN inscopepath := depth < scopepath.pathlen AND testnode->IsSameNode(scopepath.path[depth]);

/* debugging code
    PRINT("Process "|| Debug_GetNodePath(testnode) || `, depth ${depth}, inscopepath: ${inscopepath?1:0}, maxdepth ${maxdepth}\n`);
    PRINT("  " || Tokenize(testnode->outerHTML, ">")[0] || ">\n");

    PRINT(`    alwaysactive ${Substitute(AnyToString(elt.alwaysactive, "tree"), "\n", "")}` ||
        ` levelactive ${Substitute(AnyToString(elt.levelactive, "tree"), "\n", "")}` ||
        ` nodeactive ${Substitute(AnyToString(elt.nodeactive, "tree"), "\n", "")}\n`);
//*/
    FOREVERY (INTEGER i FROM elt.levelactive CONCAT elt.nodeactive)
    {
      RECORD rec := selectorparts[i];

      // Skip final rule parts when the current node may not be given back
      IF (rec.combinator = "" AND (depth < min_return_depth OR (depth < scopepath.pathlen AND NOT inscopepath)))
        CONTINUE;

      // skip rule parts that need to descend the tree when that part of the tree lies outside of the scope
      IF ((rec.combinator = " " OR rec.combinator = ">") AND NOT inscopepath AND depth < scopepath.pathlen)
        CONTINUE;

      // Test the rule part
      BOOLEAN test := TestCompoundSelector(rec.compoundselector, testnode);
      IF (NOT test)
        CONTINUE;

      SWITCH (rec.combinator)
      {
        CASE ">"
        {
          // '>' combinator means that the next rule part is active at the level of the children elements
          INSERT i + 1 INTO childlevelactive AT END;
        }
        CASE " "
        {
          // ' ' combinator means that the next rule part is always active in the children tree
          // if this was an alwaysactive rule, no need to test for this rule at the children anymore
          // But: in 'a > b c' the 'a' rule is still active, this can reactivate 'b', so we need
          // to deduplicate (or deactive 'a' too in this level).
          IF (i + 1 NOT IN childalwaysactive)
            INSERT i + 1 INTO childalwaysactive AT END;

          INTEGER pos := SearchElement(childalwaysactive, i);
          IF (pos != -1)
            DELETE FROM childalwaysactive AT pos;
        }
        CASE "+"
        {
          // '+' combinator means the next rule part needs to be checked for the next sibling
          INSERT i + 1 INTO newnodeactive AT END;
        }
        CASE "~"
        {
          // '~' combinator means the next rule part needs to be checked for the rest of this
          // level. No need to test for this rule anymore at this level.
          // But: in 'a + b ~ c' the 'a' rule is still active, this can reactivate 'b', so we need
          // to deduplicate (or deactive 'a' too in this level).
          IF (i + 1 NOT IN stack[depth].levelactive)
            INSERT i + 1 INTO stack[depth].levelactive AT END;
          INTEGER pos := SearchElement(stack[depth].levelactive, i);
          IF (pos != -1)
            DELETE FROM stack[depth].levelactive AT pos;
        }
        CASE ""
        {
          // last part of a selector, it's a match
          ismatch := TRUE;
        }
      }
    }

    IF (ismatch)
    {
      INSERT testnode INTO retval AT END;

      // mode 'qS' needs to return only 1 match
      IF (mode = "qS")
        RETURN retval;
    }

    // prepare for processing the next node at this level
    stack[depth].nodeactive := newnodeactive;
    stack[depth].node := testnode->nextelementsibling;

    // Any rules are active at the children, we can try to recurse into them
    // We need to be in the scope path, or if we're allowed to recurse into childen of the scope
    IF ((IsValueSet(childalwaysactive) OR IsValueSet(childlevelactive)) AND depth < maxdepth AND (depth >= scopepath.pathlen OR inscopepath))
    {
      OBJECT firstelementchild := testnode->firstelementchild;
      IF (IsValueSet(firstelementchild))
      {
        // fill the levelactive with the childalwaysactive and childlevelactive, so less need to concatenate in the next level
        INSERT
            [ node :=             firstelementchild
            , alwaysactive :=     childalwaysactive
            , levelactive :=      childalwaysactive CONCAT childlevelactive
            , nodeactive :=       INTEGER[]
            ] INTO stack AT END;
        depth := depth + 1;
        CONTINUE;
      }
    }

    // Pop stack levels where the end has been reached
    IF (IsDefaultValue(stack[depth].node))
    {
      DELETE FROM stack AT depth;
      depth := depth - 1;

      WHILE (depth >= 0 AND IsDefaultValue(stack[depth].node))
      {
        DELETE FROM stack AT depth;
        depth := depth - 1;
      }
      IF (depth < 0)
        BREAK;
    }
  }

  // In mode closest, return the last match
  IF (mode = "closest" AND IsValueSet(retval))
    retval := ArraySlice(retval, LENGTH(retval) - 1);

  RETURN retval;
}
