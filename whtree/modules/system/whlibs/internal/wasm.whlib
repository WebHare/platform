<?wh
(*ISSYSTEMLIBRARY*)

LOADLIB "wh::promise.whlib";
LOADLIB "wh::system.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internal/callbacks.whlib";

//This API in baselibs.cpp invokes Module.emSyscall and acts as a (slow) generic bridge to javascript.
RECORD FUNCTION __EM_SYSCALL(STRING call, VARIANT data) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);

RECORD ARRAY pendingpromises;

///We can't base off system.whlibs Exception (At least not without a whole lot of refactoring around ValidateOptions)
PUBLIC STATIC OBJECTTYPE WasmInvalidSyscallException
< /// Message for this exception
  PUBLIC STRING what;
  PUBLIC RECORD ARRAY trace;

  MACRO NEW(STRING what)
  {
    this->what := what;
  }

  PUBLIC RECORD FUNCTION EncodeForIPC()
  {
    RETURN
        [ type :=   "exception"
        , what :=   this->what
        , trace :=  this->trace
        ];
  }
>;

MACRO RunFunctionRequest(RECORD request)
{
  TRY
  {
    FUNCTION PTR target;
    IF(TYPEID(request."object") = TYPEID(OBJECT))
    {
      IF(NOT MemberExists(request."object", request.functionref)) //need to check ourselves, as GetObjectMethodPtr would generate an uncatchable HS error
        THROW NEW Exception(`No such object member '${request.functionref}'`);

      target := GetObjectMethodPtr(request."object", request.functionref);
    }
    ELSE
    {
      target := MakeFunctionPtr(request.functionref);
    }

    BOOLEAN ismacro := __INTERNAL_DEBUGFUNCTIONPTRTORECORD(target).returntype IN [0,2];
    VARIANT result := CallAnyPtrVA(target, request.params);
    __EM_SYSCALL("resolvedFunctionRequest", CELL[request.id, ismacro, resolved := result ]);
  }
  CATCH(OBJECT e)
  {
    __EM_SYSCALL("resolvedFunctionRequest", CELL[request.id, rejected := e->EncodeForIPC() ]);
  }
}

PUBLIC MACRO PromiseReceiver(STRING event, RECORD ARRAY msg)
{
  RECORD grp := __EM_SYSCALL("getActionQueue", DEFAULT RECORD).value;
  FOREVERY(RECORD result FROM grp.promiseresults)
  {
    INTEGER matchpos := (SELECT AS INTEGER #pendingpromises + 1 FROM pendingpromises WHERE pendingpromises.id = result.id) - 1;
    IF(matchpos < 0)
      CONTINUE;

    //Don't want to synchronously deal with followup exceptions, so let microtasks deal with 'm
    ScheduleMicroTask(PTR CallAnyPtrVA(result.isresolve ? pendingpromises[matchpos].resolve : pendingpromises[matchpos].reject, VARIANT[result.result]));
    DELETE FROM pendingpromises AT matchpos;
  }

  FOREVERY(RECORD request FROM grp.functionrequests)
    ScheduleMicroTask(PTR RunFunctionRequest(request));
}

//The 'low level' API to use, but with JSON wrapping so we can hopefully optimize a JSON/STRING pass away someday
PUBLIC VARIANT FUNCTION EM_Syscall(STRING call, RECORD data DEFAULTSTO DEFAULT RECORD)
{
  RECORD res := __EM_SYSCALL(call, data);
  IF(NOT RecordExists(res))
    RETURN DEFAULT RECORD; //signals no WASM
  IF(res.result = "unknown")
    THROW NEW WasmInvalidSyscallException(`No such EM Syscall '${call}'`);

  IF(res.promiseid = 0)
    RETURN res.value;

  RECORD defer := CreateDeferredPromise();
  INSERT CELL[ defer.resolve, defer.reject, id := res.promiseid ] INTO pendingpromises AT END;
  RETURN defer.promise;
}

RECORD emstate := EM_SYSCALL("init") ?? [ iswasm := FALSE ];

PUBLIC MACRO SetupWasmEventLoop()
{
  RegisterMultiEventCallback("system:wasm-promises", PTR PromiseReceiver);
  PromiseReceiver("",RECORD[]); //handle already queued events
}

/** Are we running in a WASM (__EMSCRIPTEN__) environment? */
PUBLIC BOOLEAN FUNCTION IsWASM()//TODO make this a public api, javascript.whlib or even system.whlib?
{
  RETURN emstate.iswasm;
}

/** A simple class to transfer data as a Buffer to JavaScript from a HareScriptVM. You need this when the HS/JS boundary you're using doesn't know to use getStringAsBuffer (eg EM_Syscall) */
PUBLIC STATIC OBJECTTYPE Buffer
<
  STRING bytes;
  STRING "^$WASMTYPE";

  MACRO NEW(STRING bytes)
  {
    this->"^$WASMTYPE" := "Buffer";
    this->bytes := bytes;
  }
>;
