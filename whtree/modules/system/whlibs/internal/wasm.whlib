<?wh
(*ISSYSTEMLIBRARY*)

LOADLIB "wh::system.whlib";
LOADLIB "wh::internal/interface.whlib";

//This API in baselibs.cpp invokes Module.emSyscall and acts as a (slow) generic bridge to javascript.
RECORD FUNCTION __EM_SYSCALL(STRING call, VARIANT data) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
VARIANT FUNCTION __EM_SYSCALL_WAITLASTPROMISE() __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);

///We can't base off system.whlibs Exception (At least not without a whole lot of refactoring around ValidateOptions)
PUBLIC STATIC OBJECTTYPE WasmInvalidSyscallException
< /// Message for this exception
  PUBLIC STRING what;
  PUBLIC RECORD ARRAY trace;

  MACRO NEW(STRING what)
  {
    this->what := what;
  }

  PUBLIC RECORD FUNCTION EncodeForIPC()
  {
    RETURN
        [ type :=   "exception"
        , what :=   this->what
        , trace :=  this->trace
        ];
  }
>;


//The 'low level' API to use, but with JSON wrapping so we can hopefully optimize a JSON/STRING pass away someday
PUBLIC VARIANT FUNCTION EM_Syscall(STRING call, RECORD data DEFAULTSTO DEFAULT RECORD)
{
  RECORD res := __EM_SYSCALL(call, data);
  IF(NOT RecordExists(res))
    RETURN DEFAULT RECORD; //signals no WASM
  IF(res.result = "unknown")
    THROW NEW WasmInvalidSyscallException(`No such EM Syscall '${call}'`);
  IF(res.result = "promise")
    res := __EM_SYSCALL_WAITLASTPROMISE();

  RETURN res.value;
}

RECORD emstate;

/** Are we running in a WASM (__EMSCRIPTEN__) environment? */
PUBLIC BOOLEAN FUNCTION IsWASM()
{
  IF(NOT RecordExists(emstate))
    emstate := EM_SYSCALL("init") ?? [ iswasm := FALSE ];
  RETURN emstate.iswasm;
}

