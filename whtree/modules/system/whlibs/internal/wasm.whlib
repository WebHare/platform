<?wh
(*ISSYSTEMLIBRARY*)

LOADLIB "wh::promise.whlib";
LOADLIB "wh::system.whlib";
LOADLIB "wh::internal/interface.whlib";

RECORD ARRAY pendingpromises;

///We can't base off system.whlibs Exception (At least not without a whole lot of refactoring around ValidateOptions)
PUBLIC STATIC OBJECTTYPE WasmInvalidSyscallException
< /// Message for this exception
  PUBLIC STRING what;
  PUBLIC RECORD ARRAY trace;

  MACRO NEW(STRING what)
  {
    this->what := what;
  }

  PUBLIC RECORD FUNCTION EncodeForIPC()
  {
    RETURN
        [ type :=   "exception"
        , what :=   this->what
        , trace :=  this->trace
        ];
  }
>;

//The 'low level' API to use, but with JSON wrapping so we can hopefully optimize a JSON/STRING pass away someday
PUBLIC VARIANT FUNCTION EM_Syscall(STRING call, RECORD data DEFAULTSTO DEFAULT RECORD)
{
  RECORD res := __EM_SYSCALL(call, data);
  IF(NOT RecordExists(res))
    RETURN DEFAULT RECORD; //signals no WASM
  IF(res.result = "unknown")
    THROW NEW WasmInvalidSyscallException(`No such EM Syscall '${call}'`);

  IF(res.promiseid = 0)
    RETURN res.value;

  RECORD defer := CreateDeferredPromise();
  INSERT CELL[ defer.resolve, defer.reject, id := res.promiseid ] INTO pendingpromises AT END;
  RETURN defer.promise;
}

/* Synchronous variant of EM_Syscall, if the syscall returns a promise execution of the VM is suspended until that promise resolves.
   Re-entering the VM is disallowed when calling this function, as reentrancy support needs a running HareScript event loop.
*/
PUBLIC VARIANT FUNCTION EM_SyncSyscall(STRING call, RECORD data DEFAULTSTO DEFAULT RECORD)
{
  RECORD res := __EM_SYNCSYSCALL(call, data);
  IF(NOT RecordExists(res))
    RETURN DEFAULT RECORD; //signals no WASM
  IF(res.result = "unknown")
    THROW NEW WasmInvalidSyscallException(`No such EM Syscall '${call}'`);

  RETURN res.value;
}


RECORD emstate := EM_SYSCALL("init") ?? [ iswasm := FALSE ];

/** Are we running in a WASM (__EMSCRIPTEN__) environment?
    @loadlib wh::javascript.whlib
*/
PUBLIC BOOLEAN FUNCTION IsWASM()
{
  RETURN emstate.iswasm;
}

/** A simple class to transfer data as a Buffer to JavaScript from a HareScriptVM. You need this when the HS/JS boundary you're using doesn't know to use getStringAsBuffer (eg EM_Syscall) */
PUBLIC STATIC OBJECTTYPE Buffer
<
  STRING bytes;
  STRING "^$WASMTYPE";

  MACRO NEW(STRING bytes)
  {
    this->"^$WASMTYPE" := "Buffer";
    this->bytes := bytes;
  }
>;
