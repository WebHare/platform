<?wh
(*ISSYSTEMLIBRARY*)

LOADLIB "wh::internal/interface.whlib";

//Borrowed from system.whlib:
VARIANT FUNCTION DecodeJSON(STRING indata, RECORD translations DEFAULTSTO DEFAULT RECORD, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN JSONDECODERQUICK(indata, FALSE, options, translations).value;
}
STRING FUNCTION EncodeJSON(VARIANT arg, RECORD translations DEFAULTSTO DEFAULT RECORD, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN JSONENCODETOSTRING(arg, FALSE, translations, options);
}
BOOLEAN FUNCTION RecordExists(RECORD rec) __ATTRIBUTES__(EXTERNAL, CONSTANT);


//This API in baselibs.cpp invokes Module.emSyscall and acts as a (slow) generic bridge to javascript.
STRING FUNCTION __EM_SYSCALL(STRING call) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);

///We can't base off system.whlibs Exception (At least not without a whole lot of refactoring around ValidateOptions)
PUBLIC STATIC OBJECTTYPE WasmInvalidSyscallException
< /// Message for this exception
  PUBLIC STRING what;
  PUBLIC RECORD ARRAY trace;

  MACRO NEW(STRING what)
  {
    this->what := what;
  }

  PUBLIC RECORD FUNCTION EncodeForIPC()
  {
    RETURN
        [ type :=   "exception"
        , what :=   this->what
        , trace :=  this->trace
        ];
  }
>;


//The 'low level' API to use, but with JSON wrapping so we can hopefully optimize a JSON/STRING pass away someday
PUBLIC RECORD FUNCTION EM_Syscall(STRING call, RECORD data DEFAULTSTO DEFAULT RECORD)
{
  STRING res := __EM_SYSCALL(EncodeJSON(CELL[call,data]));
  IF(res = "")
    RETURN DEFAULT RECORD; //signals no WASM
  IF(res = "unknown")
    THROW NEW WasmInvalidSyscallException(`No such EM Syscall '${call}'`);

  RETURN DecodeJSON(res);
}

RECORD emstate;

/** Are we running in a WASM (__EMSCRIPTEN__) environment? */
PUBLIC BOOLEAN FUNCTION IsWASM()
{
  IF(NOT RecordExists(emstate))
    emstate := EM_SYSCALL("init") ?? [ iswasm := FALSE ];
  RETURN emstate.iswasm;
}

