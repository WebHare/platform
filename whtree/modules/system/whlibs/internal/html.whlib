<?wh
LOADLIB "wh::util/stringparser.whlib";
LOADLIB "wh::filetypes/xml.whlib";
LOADLIB "wh::xml/dom.whlib";

PUBLIC RECORD ARRAY FUNCTION ParseNSPI(STRING indata)
{
  OBJECT parser := NEW StringParser(indata);
  RECORD ARRAY fields;
  WHILE(TRUE)
  {
    //eat any whitespace
    parser->ParseWhileInSet("\t\r\n ");
    //get the fieldname, stop at =
    STRING fieldname := parser->ParseWhileNotInSet("\t\r\n= ");
    //eat any whitespace
    parser->ParseWhileInSet("\t\r\n ");

    IF(NOT parser->TryParse('='))
      BREAK; //assume corrupter

    //eat any whitespace after =
    parser->ParseWhileInSet("\t\r\n ");

    //now see if it is quoted, or if we should just parse one word
    STRING fielddata;
    IF(parser->TryParse('"'))
    {
      fielddata := parser->ParseWhileNotInSet('"');
      parser->TryParse('"');
    }
    ELSE IF(parser->TryParse("'"))
    {
      fielddata := parser->ParseWhileNotInSet("'");
      parser->TryParse("'");
    }
    ELSE
    {
      fielddata := parser->ParseWhileNotInSet("\t\r\n ");
      parser->TryParse('"');
    }

    INSERT INTO fields(name, value) VALUES(DecodeValue(fieldname), DecodeValue(fielddata)) AT END;
  }
  RETURN fields;
}

/** @short Parse XML with callbacks
    @long This is a very basic XML parser. Extend this object and overwrite the callback functions for a functional parser.
          As this parser is based on DOM, it will not parse all node types.
*/
PUBLIC OBJECTTYPE XmlCallbackParser
<
  ////////////////////////////////////////////////////////////////////////////////
  //
  // Parse functions
  //

  /** @short Parse an XML document
      @param doc An XmlDocument object
  */
  PUBLIC MACRO ParseXmlDocument(OBJECT doc)
  {
    IF (NOT ObjectExists(doc))
      RETURN;
    IF (NOT doc EXTENDSFROM XmlDocument)
      THROW NEW Exception("Object is not an XML document");

    this->ParseXmlNodeInternal(doc, TRUE);
  }

  /** @short Parse the contents of a node (excluding the node)
      @param node An Xml node
  */
  PUBLIC MACRO ParseXMLNodeContents(OBJECT node)
  {
    IF (NOT ObjectExists(node))
      RETURN;
    IF (NOT node EXTENDSFROM XmlNode)
      THROW NEW Exception("Object is not an XML node");

    this->ParseXmlNodeInternal(node, FALSE);
  }

  ////////////////////////////////////////////////////////////////////////////////
  //
  // Callback functions to be updated
  //

  /** @short Called before parsing the document
  */
  MACRO StartDocument()
  {
  }

  /** @short Called after the document is parsed
  */
  MACRO EndDocument()
  {
  }

  /** @short Called when a new element is encountered
      @param name The (qualified) name of the element
      @param attributes The element attributes
      @cell attributes.name The attribute name
      @cell atrributes.value The attribute value
  */
  MACRO StartElement(STRING uri, STRING localname, STRING qname, RECORD ARRAY attributes)
  {
  }

  /** @short Called when an element is closed
      @param name The (qualified) name of the element
  */
  MACRO EndElement(STRING uri, STRING localname, STRING qname)
  {
  }

  /** @short Called when a processing instruction is encountered
      @param target The processing instruction target
      @param data The processing instruction data
  */
  MACRO ProcessingInstruction(STRING target, STRING data)
  {
  }

  /** @short Called when a text node is encountered
      @param content The content of the text node
  */
  MACRO Text(STRING content)
  {
  }

  /** @short Called when a comment is encountered
      @param content The content of the comment
  */
  MACRO Comment(STRING content)
  {
  }

  /** @short Called when a CDATA section is encountered
      @param content The content of the CDATA section
  */
  MACRO CdataSection(STRING content)
  {
  }

  /** @short Called when an entity reference is encountered
      @param name The entity name
  */
  MACRO EntityReference(STRING name)
  {
  }


  ////////////////////////////////////////////////////////////////////////////////
  //
  // Internal parsing functions
  //

  MACRO ParseXmlNodeInternal(OBJECT node, BOOLEAN include_node)
  {
    IF (NOT include_node)
    {
      IF (node->nodetype IN [ XmlElementNode, XmlDocumentNode, XmlHtmlDocumentNode, XmlDocumentFragNode ])
        this->ParseChildNodes(node);
      RETURN;
    }

    IF (node->nodetype = XmlElementNode)
    {
      this->StartElement(node->namespaceuri, node->localname, node->nodename, this->ParseAttributes(node));
      this->ParseChildNodes(node);
      this->EndElement(node->namespaceuri, node->localname, node->nodename);
    }
    ELSE IF (node->nodetype = XmlTextNode)
    {
      this->Text(node->nodevalue);
    }
    ELSE IF (node->nodetype = XmlCdataSectionNode)
    {
      this->CdataSection(node->nodevalue);
    }
    ELSE IF (node->nodetype = XmlEntityRefNode)
    {
      this->EntityReference(node->nodename);
    }
    ELSE IF (node->nodetype = XmlEntityNode)
    {
    }
    ELSE IF (node->nodetype = XmlPiNode)
    {
      this->ProcessingInstruction(node->nodename, node->nodevalue);
    }
    ELSE IF (node->nodetype = XmlCommentNode)
    {
      this->Comment(node->nodevalue);
    }
    ELSE IF (node->nodetype = XmlDocumentNode)
    {
      this->StartDocument();
      this->ParseChildNodes(node);
      this->EndDocument();
    }
    ELSE IF (node->nodetype = XmlDocumentTypeNode)
    {
    }
    ELSE IF (node->nodetype = XmlDocumentFragNode)
    {
      this->ParseChildNodes(node);
    }
    ELSE IF (node->nodetype = XmlNotationNode)
    {
    }
    ELSE IF (node->nodetype = XmlHtmlDocumentNode)
    {
      this->StartDocument();
      this->ParseChildNodes(node);
      this->EndDocument();
    }
    ELSE IF (node->nodetype = XmlDtdNode)
    {
    }
    ELSE IF (node->nodetype = XmlElementDecl)
    {
    }
    ELSE IF (node->nodetype = XmlAttributeDecl)
    {
    }
    ELSE IF (node->nodetype = XmlEntityDecl)
    {
    }
    ELSE IF (node->nodetype = XmlNamespaceDecl)
    {
    }
    ELSE IF (node->nodetype = XmlXincludeStart)
    {
    }
    ELSE IF (node->nodetype = XmlXincludeEnd)
    {
    }
    ELSE IF (node->nodetype = XmlDocbDocumentNode)
    {
    }
  }

  RECORD ARRAY FUNCTION ParseAttributes(OBJECT node)
  {
    IF (NOT ObjectExists(node->attributes))
      RETURN DEFAULT RECORD ARRAY;

    RECORD ARRAY attributes;
    FOR (INTEGER i := 0; i < node->attributes->length; i := i + 1)
      INSERT [ name := node->attributes->Item(i)->nodename, value := node->attributes->Item(i)->nodevalue ] INTO attributes AT END;
    RETURN attributes;
  }

  MACRO ParseChildNodes(OBJECT node)
  {
    FOR (OBJECT childnode := node->firstchild; ObjectExists(childnode); childnode := childnode->nextsibling)
      this->ParseXmlNodeInternal(childnode, TRUE);
  }
>;

