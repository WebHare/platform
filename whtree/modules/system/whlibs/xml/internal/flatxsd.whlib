<?wh

LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "wh::xml/internal/structures.whlib";
LOADLIB "wh::xml/internal/datatypes.whlib";

PUBLIC STATIC OBJECTTYPE FlatXSD
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Whether the data was imported (if not it was parsed)
  BOOLEAN is_imported;

  /** All found components, ordered by id
      @cell(integer) id Node id
      @cell(string) type Type of node
      @cell(string) name Name of node
      @cell(string) target_namespace Namespace of node
      @cell annotations List of annotations
      @cell(string) __rawtype Type of the node from the XSD parser
      @cell(record) userdata User data
  */
  RECORD ARRAY pvt_components;

  /** Registered toplevel nodes, ordered by name, namespace, type
      @cell(string) target_namespace Namespace of the node
      @cell(string) name Name of the node
      @cell(string) type Type of node
      @cell(integer) id Node id
      @cell(integer) component_pos Position of the component in the pvt_components array.
  */
  RECORD ARRAY pvt_toplevel_registrations;

  /** Worklist, contains all ids of nodes that still need to be processed. Only needed at construction.
  */
  INTEGER ARRAY pvt_worklist;

  /** List of recorded references (picked up by GetIdRef and GetIdRefs). Only needed at construction.
      @cell(integer) id Node id
      @cell(integer array) referenced_from Nodes this node is referenced from
  */
  RECORD ARRAY pvt_references;

  /** List of user functions that must be called for every xsd component. Only needed at construction.
      @cell name Cellname to insert the result of the parse function in
      @cell func Parse function
  */
  RECORD ARRAY pvt_user_component_parse_funcs;

  /** List of user functions that must be called for every annotation. Only needed at construction.
      @cell name Cellname to insert the result of the parse function in
      @cell func Parse function
  */
  RECORD ARRAY pvt_user_annotation_parse_funcs;

  /// Whether to keep the annotation nodes
  BOOLEAN pvt_keep_annotation_nodes;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /** List of top level component records
      @cell(integer) id Node id
      @cell(string) type Type of node
      @cell(string) name Name of node
      @cell(string) target_namespace Namespace of node
      @cell(record) userdata Data generated by user functions
      @cell(record array) annotations Annotations
      @cell(blob) annotations.docblob Blob with annotation node
      @cell(record) annotations.userdata  Parsed annotations data
  */
  PUBLIC PROPERTY toplevelrecords(GetTopLevelRecords, -);

  /** User functions that will be called for every imported xsd component node.
      @type(record array)
      @cell name Cellname that is used to store the function output in the userdata cell of component records
      @cell func Function that is called, signature: VARIANT FUNCTION func(OBJECT< xsdcomponent > node)
  */
  PUBLIC PROPERTY user_component_parse_functions(pvt_user_component_parse_funcs, pvt_user_component_parse_funcs);

  /** User functions that will be called for every imported xsd component node.
      @type(record array)
      @cell name Cellname that is used to store the function output in the userdata cell of annotation records
      @cell func Function that is called, signature: VARIANT FUNCTION func(OBJECT< xsdcomponent > node)
  */
  PUBLIC PROPERTY user_annotation_parse_functions(pvt_user_annotation_parse_funcs, pvt_user_annotation_parse_funcs);

  /** Whether to keep the annotation nodes (and copy them into separate, well-formed xml documents, which costs some CPU).
  */
  PUBLIC PROPERTY keep_annotation_nodes(pvt_keep_annotation_nodes, pvt_keep_annotation_nodes);

  /** Record file locations
  */
  PUBLIC BOOLEAN record_locations;

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  RECORD ARRAY FUNCTION GetTopLevelRecords()
  {
    RETURN
        SELECT AS RECORD ARRAY this->pvt_components[component_pos]
          FROM this->pvt_toplevel_registrations;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  /** @short Build a record that is a reference to another xsd component node. Use ResolveReference to get the referenced node record.
      @param from_node Node that made the reference, to build the referenced_from array
      @param node Referenced node (optional)
      @return Reference record to the node (or default record if it didn't exist)
      @cell(string) return.type "ref"
      @cell(integer) return.id ID of referenced node
      @see ResolveReference, ResolveReferences, GetIdRefs
  */
  RECORD FUNCTION GetIdRef(OBJECT from_node, OBJECT node)
  {
    IF (ObjectExists(node))
    {
      // Register the reference
      RECORD pos := RecordLowerBound(this->pvt_references, [ id := node->id ], [ "ID" ]);
      IF (NOT pos.found)
        INSERT [ id := node->id, referenced_from := [ INTEGER(from_node->id) ] ] INTO this->pvt_references AT pos.position;
      ELSE IF (from_node->id NOT IN this->pvt_references[pos.position].referenced_from)
        INSERT from_node->id INTO this->pvt_references[pos.position].referenced_from AT END;

      // Insert into the worklist, so the node will also be parsed
      INSERT node->id INTO this->pvt_worklist AT END;

      // The reference record!
      RETURN
          [ type :=         "ref"
          , id :=           node->id
          ];
    }
    RETURN DEFAULT RECORD;
  }

  /** @short Get reference records for a list of xsd component nodes. Use ResolveReferences to get the referenced node records.
      @param from_node Node that made the references, to build the referenced_from array
      @param nodes Referenced nodes
      @return Reference record to the nodes
      @cell(string) return.type "ref"
      @cell(integer) return.id ID of referenced node
      @see ResolveReference, ResolveReferences, GetIdRef
  */
  RECORD ARRAY FUNCTION GetIdRefs(OBJECT from_node, OBJECT ARRAY nodes)
  {
    RETURN SELECT AS RECORD ARRAY this->GetIdRef(from_node, node) FROM ToRecordArray(nodes, "NODE");
  }

  /** @short Set the referenced_from cell in all component records
  */
  MACRO SetReferences()
  {
    RECORD ARRAY cmps := this->pvt_components;
    FOREVERY (RECORD rec FROM cmps)
    {
      RECORD pos := RecordLowerBound(this->pvt_references, [ id := rec.id ], [ "ID" ]);
      IF (pos.found)
      {
        // Build reference records for every reference
        cmps[#rec].referenced_from :=
            SELECT type :=  "ref"
                 , id
              FROM ToRecordArray(this->pvt_references[pos.position].referenced_from, "ID");
      }
    }
    this->pvt_components := cmps;
  }

  /** @short Create the registration records for all toplevel elements
  */
  MACRO CreateToplevelRegistrations()
  {
    // Translate the the typenames to datatype, group, etc.
    this->pvt_toplevel_registrations :=
        SELECT target_namespace
             , name
             , type :=           [ STRING(type), "datatype", "datatype", "datatype", "attributegroup", "group", "attribute", "element" ][
                                      SearchElement([
                                            "simpletype",
                                            "complextype",
                                            "primitivetype",
                                            "attributegroupdefinition",
                                            "modelgroupdefinition",
                                            "attributedeclaration",
                                            "element"], type) + 1]
             , id
             , component_pos :=  #pvt_components
          FROM this->pvt_components
         WHERE registered_toplevel;

    // FIXME: what kind of toplevel nodes are we deleting here?
    this->pvt_toplevel_registrations :=
        SELECT *
          FROM this->pvt_toplevel_registrations
         WHERE type != ""
      ORDER BY name, target_namespace, type;
  }

  // ---------------------------------------------------------------------------
  //
  // Specific type serializers
  //

  /** @short Builds the record for an attribute declaration
      @url http://www.w3.org/TR/xmlschema-1/#Attribute_Declaration_details
      @param node Node to parse
      @return List of attribute declarations
      @cell(record) return.type_definition Reference to type of the attribute content
      @cell(record) return.value_constraint Value constraint (optional, may be default record)
      @cell(string) return.value_constraint.type Type of constraint, either 'default' or 'fixed'
      @cell(string) return.value_constraint.value Constraint value
  */
  RECORD FUNCTION GetAttributeDeclaration(OBJECT node)
  {
    RETURN
        [ type_definition :=                this->GetIdRef(node, node->type_definition)
        , value_constraint :=               node->value_constraint
        ];
  }

  /** @short Builds the record for an attribute group definition
      @url http://www.w3.org/TR/xmlschema-1/#Attribute_Group_Definition_details
      @param node Node to parse
      @return Parsed attribute group definition
      @cell(record array) return.attribute_uses References to attribute uses records
      @cell(record) return.attribute_wildcard Reference to attribute wildcard record
  */
  RECORD FUNCTION GetAttributeGroupDefinition(OBJECT node)
  {
    RETURN
        [ attribute_uses :=                 this->GetIdRefs(node, node->attribute_uses)
        , attribute_wildcard :=             this->GetIdRef(node, node->attribute_wildcard)
        ];
  }

  /** @short Builds the record for an attribute use definition
      @url http://www.w3.org/TR/xmlschema-1/#AU_details
      @param node Node to parse
      @return Parsed attribute use definition
      @cell(boolean) return.required Whether the attribute is required
      @cell(record) return.attribute_declaration Reference to attribute declaration record
      @cell(record) return.value_constraint Value constraint (optional, may be default record)
      @cell(string) return.value_constraint.type Type of constraint, either 'default' or 'fixed'
      @cell(string) return.value_constraint.value Constraint value
  */
  RECORD FUNCTION GetAttributeUse(OBJECT node)
  {
    RETURN
        [ required :=                       node->required
        , attribute_declaration :=          this->GetIdRef(node, node->attribute_declaration)
        , value_constraint :=               node->value_constraint
        ];
  }

  /** @short Builds the record for an complex type definition
      @url http://www.w3.org/TR/xmlschema-1/structures.html#Complex_Type_Definition_details
      @param node Node to parse
      @return Parsed complex type definition
      @cell(record) return.base_type_definition Reference to base type record, either a simple type definition or a complex type definition.
      @cell(string) return.derivation_method Method used to create this type (either 'extension' or 'restriction')
      @cell(boolean) return.abstract Whether this type is abstract (and thus may not be used to validate nodes)
      @cell(record array) return.attribute_uses List of references to attribute use records
      @cell(record) return.attribute_wildcard Optional reference to attribute wildcard record
      @cell(record) return.content_type Optional content type
      @cell(string) return.content_type.type Type of content (either 'simple' or 'complex')
      @cell(record) return.content_type.content Reference to a particle
      @cell(record) return.content_type.mixed For type='complex', whether text is also allowed (either 'mixed' or 'element-only')
  */
  RECORD FUNCTION GetComplexType(OBJECT node)
  {
    RETURN
        [ base_type_definition :=           this->GetIdRef(node, node->base_type_definition)
        , derivation_method :=              node->derivation_method
        , abstract :=                       node->abstract
        , attribute_uses :=                 this->GetIdRefs(node, node->attribute_uses)
        , attribute_wildcard :=             this->GetIdRef(node, node->attribute_wildcard)
        , content_type :=
                RecordExists(node->content_type)
                    ? node->content_type.type = "simple"
                          ? [ type :=         "simple"
                            , content :=      this->GetIdRef(node, node->content_type.content)
                            ]
                          : [ type :=         "complex"
                            , content :=      this->GetIdRef(node, node->content_type.content)
                            , mixed :=        node->content_type.mixed
                            ]
                    : DEFAULT RECORD
        ];
  }

  /** @short Builds the record for an element declaration
      @url http://www.w3.org/TR/xmlschema-1/#Element_Declaration_details
      @param node Node to parse
      @return Parsed element declaration
      @cell(record) return.type_definition Reference to type definition record, either a simple type definition or a complex type definition.
      @cell(record array) return.identity_constraint_definitions List of references to identity constraint definition records
  */
  RECORD FUNCTION GetElement(OBJECT node)
  {
    RETURN
        [ type_definition :=                this->GetIdRef(node, node->type_definition)
        , identity_constraint_definitions := this->GetIdRefs(node, node->identity_constraint_definitions)
        , nillable :=                       node->nillable
        ];
  }

  /** @short Builds the record for an complex type definition
      @url http://www.w3.org/TR/xmlschema-1/#Identity-constraint_Definition_details
      @param node Node to parse
      @return Parsed identity constraint definition
      @cell(string) return.identity_constraint_category Type of constraint, either 'key', 'keyref' or 'unique' (when equal to 'keyref', this is a reference to another constraint)
      @cell(string) return.selector Restricted XPath expression that selects all relevant nodes
      @cell(string array) return.fields Fields that are used in the constraint
      @cell(record) return.referenced_key Reference to identity constraint definition record (only when identity_constraint_category is 'keyref')
  */
  RECORD FUNCTION GetIdentityConstraintDefinition(OBJECT node)
  {
    RETURN
        [ identity_constraint_category :=   node->identity_constraint_category
        , selector :=                       node->selector
        , fields :=                         node->fields
        , referenced_key :=                 this->GetIdRef(node, node->referenced_key)
        ];
  }

  /** @short Builds the record for a model group
      @url http://www.w3.org/TR/xmlschema-1/#Model_Group_details
      @param node Node to parse
      @return Parsed model group
      @cell(string) return.compositor Compositor of the modelgroup, either 'all', 'choice' or 'sequence'.
      @cell(record array) return.particles List of references to particle records
  */
  RECORD FUNCTION GetModelGroup(OBJECT node)
  {
    RETURN
        [ compositor :=                     node->compositor
        , particles :=                      this->GetIdRefs(node, node->particles)
        ];
  }

  /** @short Builds the record for an model group definition
      @url http://www.w3.org/TR/xmlschema-1/#Model_Group_Definition_details
      @param node Node to parse
      @return Parsed model group definition
      @cell(record) return.model_group Reference to model group record
  */
  RECORD FUNCTION GetModelGroupDefinition(OBJECT node)
  {
    RETURN
        [ model_group :=                    this->GetIdRef(node, node->model_group)
        ];
  }

  /** @short Builds the record for a particle
      @url http://www.w3.org/TR/xmlschema-1/#Particle_details
      @param node Node to parse
      @return Parsed particle
      @cell(integer) return.min_occurs Minimum number of occurences
      @cell(integer) return.max_occurs Maximum number of occurences (unbounded_max_int when unbounded)
      @cell(record) return.term Reference to a model group, a wildcard, or an element declaration record
      @see %unbounded_max_int
  */
  RECORD FUNCTION GetParticle(OBJECT node)
  {
    RETURN
        [ min_occurs :=                     node->min_occurs
        , max_occurs :=                     node->max_occurs
        , term :=                           this->GetIdRef(node, node->term)
        ];
  }

  /** @short Builds the record for a primitive type
      @param node Node to parse
      @return Parsed primitive type
  */
  RECORD FUNCTION GetPrimitiveType(OBJECT node)
  {
    RETURN DEFAULT RECORD;
  }

  /** @short Builds the record for a simple data type
      @url http://www.w3.org/TR/xmlschema-2/#dc-defn
      @param node Node to parse
      @return Parsed simple type
      @cell(string) return.variety What kind of type this is, either "atomic", "list" or "union"
      @cell(record) return.primitive_type_definition Reference to primitive type definition record, only when variety='atomic'
      @cell(record) return.item_type_definition Reference to item type definition record, only when variety='list'
      @cell(record) return.member_type_definitions List of References to member type definition records, only when variety='union'
      @cell(record array) return.facets List of constraining facets (patters, enumerations, etc. that limit the allowed values) ADDME to document
      @cell(record) return.base_type_definition Reference to base type record (optional)
  */
  RECORD FUNCTION GetSimpleTypeData(OBJECT node)
  {
    // Parse & replace the annotations in the facets
    RECORD ARRAY facets := node->facets;
    FOREVERY (RECORD facet FROM facets)
    {
      RECORD ARRAY annotations;
      IF (CellExists(facet, "ANNOTATIONS"))
      {
        annotations := this->GetAnnotations(facet.annotations);
        DELETE CELL annotations FROM facets[#facet];
      }
      INSERT CELL annotations := annotations INTO facets[#facet];
      IF (facet.type = "enumeration")
      {
        facets[#facet].value :=
          SELECT COLUMN value
               , annotations := this->GetAnnotations(value.annotations)
            FROM facet.value;
      }
    }
    // FIXME: What does this do here? Where does it need to go? FIXME!
        SELECT AS RECORD ARRAY CellExists(facets, "ANNOTATIONS")
                   ? CellInsert(CellDelete(facets, "ANNOTATIONS"), "ANNOTATIONS", this->GetAnnotations(facets.annotations))
                   : facets
          FROM node->facets;

    RETURN
        [ variety :=                        node->variety
        , primitive_type_definition :=      this->GetIdRef(node, node->primitive_type_definition)
        , item_type_definition :=           this->GetIdRef(node, node->item_type_definition)
        , member_type_definitions :=        this->GetIdRefs(node, node->member_type_definitions)
        , facets :=                         facets
        , base_type_definition :=           this->GetIdRef(node, node->base_type_definition)
        ];
  }

  /** @short Builds the record for a wildcard
      @url http://www.w3.org/TR/xmlschema-1/#Wildcard_details
      @param node Node to parse
      @return Parsed wildcard
      @cell(record) return.namespace_constraint Namespace constraint
      @cell(string) return.namespace_constraint.type Either 'any', 'not', 'set'
      @cell(string) return.namespace_constraint.namespaces List of relevant namespaces (only relevant for type='not' and type='set')
      @cell(string) return.process_contents Either 'skip', 'lax' or 'strict'.
  */
  RECORD FUNCTION GetWildcard(OBJECT node)
  {
    RETURN
        [ namespace_constraint :=           node->namespace_constraint
        , process_contents :=               node->process_contents
        ];
  }

  /** @short Builds the records for annotations
      @param annotations Annotation nodes
      @return List of annotation nodes
      @cell return.docblob Blob with annotation node
      @cell return.userdata Parsed annotations data
  */
  RECORD ARRAY FUNCTION GetAnnotations(OBJECT ARRAY annotations)
  {
    RECORD ARRAY result;
    OBJECT domimpl := NEW XMLDomImplementation;

    FOREVERY (OBJECT annotation FROM annotations)
    {
      OBJECT annotation_node;
      IF (this->pvt_keep_annotation_nodes)
      {
        OBJECT doc := domimpl->CreateDocument("http://www.w3.org/2001/XMLSchema", "xs:annotation", DEFAULT OBJECT);
        FOREVERY (OBJECT elt FROM annotation->xmlnode->childnodes->GetCurrentNodes())
          doc->documentelement->AppendChild(doc->ImportNode(elt, TRUE));

        doc->NormalizeDocument();
        annotation_node := doc->documentelement;
      }

      RECORD userdata;
      FOREVERY (RECORD rec FROM this->pvt_user_annotation_parse_funcs)
        userdata := CellInsert(userdata, rec.name, rec.func(annotation));

      INSERT
          [ xmlnode :=      annotation_node
          , userdata :=     userdata
          ] INTO result AT END;
    }

    RETURN result;
  }

  // ---------------------------------------------------------------------------
  //
  // Process single component
  //

  RECORD FUNCTION ProcessSingleItem(OBJECT xsdparser, INTEGER id)
  {
    RECORD pos := RecordLowerBound(this->pvt_components, [ id := id ], [ "ID" ]);
    IF (pos.found)
      RETURN this->pvt_components[pos.position];

    OBJECT node := xsdparser->GetComponentNodeByID(id);

    RECORD userdata;
    FOREVERY (RECORD rec FROM this->pvt_user_component_parse_funcs)
      userdata := CellInsert(userdata, rec.name, rec.func(node));

    RECORD baserec :=
        [ id :=                   id
        , name :=                 node->name
        , target_namespace :=     node->target_namespace
        , annotations :=          this->GetAnnotations(node->annotations)
        , __rawtype :=            node->type
        , registered_toplevel :=  node->registered_toplevel
        , referenced_from :=      DEFAULT RECORD ARRAY
        , userdata :=             userdata
        ];
    STRING type;

    IF (this->record_locations)
    {
      RECORD location;
      IF (ObjectExists(node->source_xml_node))
        location := [ line := node->source_xml_node->linenum ];

      INSERT CELL location := location INTO baserec;
    }

    RECORD nodedata;
    IF (node EXTENDSFROM XSDAttributeDeclaration)
    {
      type := "attributedeclaration";
      nodedata := this->GetAttributeDeclaration(node);
    }
    ELSE IF (node EXTENDSFROM XSDAttributeGroupDefinition)
    {
      type := "attributegroupdeclaration";
      nodedata := this->GetAttributeGroupDefinition(node);
    }
    ELSE IF (node EXTENDSFROM XSDAttributeUse)
    {
      type := "attributeuse";
      nodedata := this->GetAttributeUse(node);
    }
    ELSE IF (node EXTENDSFROM XSDComplexType)
    {
      type := "complextype";
      nodedata := this->GetComplexType(node);
    }
    ELSE IF (node EXTENDSFROM XSDElement)
    {
      type := "element";
      nodedata := this->GetElement(node);
    }
    ELSE IF (node EXTENDSFROM XSDIdentityConstraintDefinition)
    {
      type := "identityconstraintdefinition";
      nodedata := this->GetIdentityConstraintDefinition(node);
    }
    ELSE IF (node EXTENDSFROM XSDModelGroup)
    {
      type := "modelgroup";
      nodedata := this->GetModelGroup(node);
    }
    ELSE IF (node EXTENDSFROM XSDModelGroupDefinition)
    {
      type := "modelgroupdefinition";
      nodedata := this->GetModelGroupDefinition(node);
    }
    ELSE IF (node EXTENDSFROM XSDParticle)
    {
      type := "particle";
      nodedata := this->GetParticle(node);
    }
    ELSE IF (node EXTENDSFROM XSDPrimitiveType)
    {
      type := "primitivetype";
      nodedata := this->GetPrimitiveType(node);
    }
    ELSE IF (node EXTENDSFROM XSDSimpleType)
    {
      type := "simpletype";
      nodedata := this->GetSimpleTypeData(node);
    }
    ELSE IF (node EXTENDSFROM XSDWildcard)
    {
      type := "wildcard";
      nodedata := this->GetWildcard(node);
    }
//    ELSE
//      PRINT("Skipping node of type " || GetObjectTypeName(node) || "\n");

    IF (type != "")
    {
      INSERT CELL type := type INTO baserec;
      RECORD result := MakeMergedRecord(baserec, nodedata);
      INSERT result INTO this->pvt_components AT pos.position;
      RETURN result;
    }

    RETURN DEFAULT RECORD;
  }

  // ---------------------------------------------------------------------------
  //
  // Public api
  //

  /** Initialize from the contents of an XSD parser
      @param xsdparser XSD parser to import the contents of
  */
  PUBLIC MACRO ReadFromXSDParser(OBJECT xsdparser)
  {
    this->is_imported := FALSE;
    this->pvt_components := DEFAULT RECORD ARRAY;

    this->pvt_worklist :=
        SELECT AS INTEGER ARRAY node->id
          FROM ToRecordArray(xsdparser->all_nodes, "NODE");


    WHILE (LENGTH(this->pvt_worklist) != 0)
    {
      INTEGER id := this->pvt_worklist[0];
      DELETE FROM this->pvt_worklist AT 0;

      this->ProcessSingleItem(xsdparser, id);
    }

    this->SetReferences();
    this->CreateToplevelRegistrations();
  }

  /** @short Return a reference record to an xsd component node
      @param node Optional xsd component node
      @return Reference record
      @cell(string) return.type Always "ref"
      @cell(integer) return.id Node id
  */
  PUBLIC RECORD FUNCTION GetReference(OBJECT node)
  {
    IF (this->is_imported)
      THROW NEW Exception("This function cannot be used for imported XSDs");

    RETURN ObjectExists(node) ? [ type := "ref", id := node->id ] : DEFAULT RECORD;
  }

  /** @short Looks up a registered toplevel component record
      @param target_namespace Namespace of the node
      @param name Name of the node
      @param type Type of the node (either
                'datatype' for simpletype & complextype,
                'group' for model group definitions,
                'attributegroup' for attribute group definitions,
                'attribute' for attribute definitions or
                'element' for element definitions
      @return Component record (default object if it doesn't exist)
  */
  PUBLIC RECORD FUNCTION LookupNode(STRING target_namespace, STRING name, STRING type)
  {
    RECORD pos := RecordLowerBound(this->pvt_toplevel_registrations,
        [ target_namespace := target_namespace
        , name := name
        , type := type ], [ "name", "target_namespace", "type" ]);

    IF (NOT pos.found)
      RETURN DEFAULT RECORD;

    RETURN this->pvt_components[this->pvt_toplevel_registrations[pos.position].component_pos];
  }

  /** @short Given a component (refence) record, resolve the reference record and the component record
      @param component Component (reference) record
      @return Returns the component record
      @see GetReference, ResolveReferences
  */
  PUBLIC RECORD FUNCTION ResolveReference(RECORD component)
  {
    IF (RecordExists(component) AND component.type = "ref")
    {
      RECORD pos := RecordLowerBound(this->pvt_components, [ id := component.id ], [ "ID" ]);
      IF (pos.found)
        RETURN this->pvt_components[pos.position];
      THROW NEW Exception("No such component with id #" || component.id || " exists");
    }
    RETURN component;
  }

  /** @short Given a list of component (refence) records, resolve the reference records and return all component records
      @param components Component (reference) records
      @return Returns the component record
      @see GetReference, ResolveReference
  */
  PUBLIC RECORD ARRAY FUNCTION ResolveReferences(RECORD ARRAY components)
  {
    RETURN SELECT AS RECORD ARRAY this->ResolveReference(components) FROM components;
  }

  /** Creates an export of the data, suitable for storing in adhoc cache or so
      @return Opaque record, use ImportData to Restore
      @see ImportData
  */
  PUBLIC RECORD FUNCTION ExportData()
  {
    RETURN
        [ version := "flatxsd-v2.00"
        , data :=
              [ components :=             this->pvt_components
              , toplevel_registrations := this->pvt_toplevel_registrations
              ]
        ];
  }

  /** Imports previously exported flat data. Throws if the format isn't understood.
      @param transferdata Previously exported data
  */
  PUBLIC MACRO ImportData(RECORD transferdata)
  {
    this->is_imported := TRUE;
    this->pvt_components := DEFAULT RECORD ARRAY;
    this->pvt_user_component_parse_funcs := DEFAULT RECORD ARRAY;
    this->pvt_worklist := DEFAULT INTEGER ARRAY;

    STRING required_format := "flatxsd-v2.00";
    STRING got_format := CellExists(transferdata, "VERSION") ? transferdata.version : "*missing*";
    IF (got_format != required_format)
    {
      this->pvt_components := DEFAULT RECORD ARRAY;
      this->pvt_toplevel_registrations := DEFAULT RECORD ARRAY;

      THROW NEW Exception("Cannot parse this version of flatxsd export; got '"||got_format||"', wanted '"||required_format||"'");
    }

    this->pvt_components := transferdata.data.components;
    this->pvt_toplevel_registrations := transferdata.data.toplevel_registrations;
  }
>;


/** Get a flat XSD representation
    @param xsdparser XSD parser
    @param userfuncs User functions to execute on every stored xsd component. Returned data
       will be stored in @a userdata cell in the flat data.
    @cell userfuncs.name Cellname
    @cell userfuncs.func Called function. Signature: VARIANT func(OBJECT xsdcomponent)
    @return(object #FlatXSD) FlatXSD object with parsed
*/
PUBLIC OBJECT FUNCTION BuildFlatXSDData(OBJECT xsdparser, RECORD ARRAY userfuncs)
{
  OBJECT r := NEW FlatXSD;
  r->user_component_parse_functions := userfuncs;
  r->ReadFromXSDParser(xsdparser);
  RETURN r;
}


PUBLIC OBJECT FUNCTION MakeFlatXSDDataFromExport(RECORD transferdata)
{
  OBJECT r := NEW FlatXSD;
  r->ImportData(transferdata);
  RETURN r;
}
