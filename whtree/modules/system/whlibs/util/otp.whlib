<?wh

/** @topic harescript-utils/otp
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::internet/urls.whlib";


/*
Time-based One-time Password Algorithm - Wikipedia, the free encyclopedia
  http://en.wikipedia.org/wiki/Time-based_One-time_Password_Algorithm
RFC 4226 -- HOTP: An HMAC-Based One-Time Password Algorithm
  http://www.ietf.org/rfc/rfc4226.txt
RFC 4648 -- The Base16, Base32, and Base64 Data Encodings
  http://www.ietf.org/rfc/rfc4648.txt
RFC 6238 -- TOTP: Time-Based One-Time Password Algorithm
  http://www.ietf.org/rfc/rfc6238.txt
Key Uri Format · google/google-authenticator Wiki · GitHub
  https://github.com/google/google-authenticator/wiki/Key-Uri-Format
*/

RECORD defaultoptions :=
    [ interval := 30
    , hmac :=     "HMAC:SHA-1"
    , digits :=   6
    , now :=      DEFAULT DATETIME
    , start :=    MakeDate(1970, 1, 1)
    ];

CONSTANT STRING ARRAY allowed_hmacs := [ "HMAC:SHA-1", "HMAC:SHA-256", "HMAC:SHA-512" ];

INTEGER FUNCTION GetKeyLength(STRING hmac)
{
  SWITCH (hmac)
  {
    CASE "HMAC:SHA-512" { RETURN 64; }
    CASE "HMAC:SHA-256" { RETURN 32; }
    CASE "HMAC:SHA-1"   { RETURN 20; }
  }
  THROW NEW Exception(`Invalid HMAC algorithm: '${hmac}'`);
}

/** @short Generate an HMAC-based one-time password
    @long This function generates a HMAC-based one-time password. Please note that external applications may not support all
        of the options and will fallback to the defaults.
    @param secret The key to use (raw byte value)
    @param counter The counter value
    @cell(string) options.hmac The HMAC algorithm to use, defaults to "HMAC:SHA-1"
    @cell(integer) options.digits The length of the resulting password, range [6-8], defaults to 6
    @return The generated password
    @see GetTOTPCode GetHOTPUrl
*/
PUBLIC STRING FUNCTION GetHOTPCode(STRING secret, INTEGER64 counter, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL
      [ defaultoptions.hmac
      , defaultoptions.digits
      ], options,
      [ enums := [ hmac := allowed_hmacs ]
      ]);


  IF (options.digits < 6 OR options.digits > 8)
    THROW NEW Exception(`Invalid number of digits: ${options.digits}`);

  INTEGER expectedlength := GetKeyLength(options.hmac);
  IF (Length(secret) != expectedlength)
    THROW NEW Exception(`Expected secret of ${expectedlength} bytes, got ${Length(secret)} bytes`);

  // Convert INTEGER64 bits
  STRING countstring := DecodeBase16(Right("0000000000000000" || ToString(counter, 16), 16));
  // Calculate the hash
  STRING hs := GetHashForString(countstring, options.hmac, secret);
  // Get the code offset within the hash
  INTEGER offs := GetByteValue(Right(hs, 1)) BITAND 0xF;
  // Convert code bits to INTEGER
  INTEGER snum := ((GetByteValue(Substring(hs, offs, 1)) BITAND 0x7F) BITLSHIFT 24) +
                  ((GetByteValue(Substring(hs, offs + 1, 1)) BITAND 0xFF) BITLSHIFT 16) +
                  ((GetByteValue(Substring(hs, offs + 2, 1)) BITAND 0xFF) BITLSHIFT 8) +
                  (GetByteValue(Substring(hs, offs + 3, 1)) BITAND 0xFF);
  // Truncate and pad with leading zeroes to specified length
  INTEGER mod10 := 1;
  FOR (INTEGER i := 0; i < options.digits; i := i + 1)
    mod10 := mod10 * 10;

  RETURN Right(RepeatText("0", options.digits) || (snum % mod10), options.digits);;
}

/** @short Generate a time-based one-time password
    @long This function generates a time-based one-time password. Please note that external applications may not support all
        of the options and will fallback to the defaults.
    @param secret The key to use (raw byte value)
    @cell(integer) options.interval The interval to use in seconds, defaults to 30
    @cell(string) options.hmac The HMAC algorithm to use, defaults to "HMAC:SHA-1"
    @cell(integer) options.digits The length of the resulting password, range [6-8], defaults to 6
    @cell(datetime) options.now The timestamp to use as 'now', defaults to current date and time
    @cell(datetime) options.start The timestamp to use as offset date and time, defaults to 1970-01-01T00:00Z
    @return The generated password
    @see GetHOTPCode GetTOTPUrl
*/
PUBLIC STRING FUNCTION GetTOTPCode(STRING secret, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL
      [ defaultoptions.interval
      , defaultoptions.hmac
      , defaultoptions.digits
      , defaultoptions.start
      , now :=        GetCurrentDateTime()
      ], options,
      [ enums := [ hmac := allowed_hmacs ]
      ]);

  IF (options.digits < 6 OR options.digits > 8)
    THROW NEW Exception(`Invalid number of digits: ${options.digits}`);

  // Get the step counter (the number of second intervals since the epoch)
  INTEGER64 stamp := GetUnixTimestampMsecs(options.now) / 1000;
  INTEGER64 step := (stamp - (GetUnixTimestampMsecs(options.start) / 1000)) / options.interval;
  // Create the one-time password
  RETURN GetHOTPCode(secret, step, CELL[ options.hmac, options.digits ]);
}

/** @short Create a url which encodes the HOTP secret for use in external applications
    @long This function creates a URL that can be used by external applications to initialize HOTP authentication. This URL
        can be used to create a QR code that can be scanned by such applications. Please note that external applications may
        not support all of the options and will fallback to the defaults.
    @param secret The key to use (raw byte value)
    @param account The name of the user's account (may be left empty)
    @param issuer The name of the issuer of the secret (may be left empty)
    @param counter The counter value to start from
    @cell(string) options.hmac The HMAC algorithm to use, defaults to "HMAC:SHA-1"
    @cell(integer) options.digits The length of the resulting password, range [6-8], defaults to 6
    @return The url that can be used in external applications (for example by encoding it in a scannable QR code)
*/
PUBLIC STRING FUNCTION GetHOTPUrl(STRING secret, STRING account, STRING issuer, INTEGER64 counter, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL
      [ defaultoptions.hmac
      , defaultoptions.digits
      ], options,
      [ enums := [ hmac := allowed_hmacs ]
      ]);

  IF (options.digits < 6 OR options.digits > 8)
    THROW NEW Exception(`Invalid number of digits: ${options.digits}`);

  RETURN CreateOTPUrl("hotp", secret, account, issuer, counter, options);
}

/** @short Create a url which encodes the TOTP secret for use in external applications
    @long This function creates a URL that can be used by external applications to initialize TOTP authentication. This URL
        can be used to create a QR code that can be scanned by such applications. Please note that the 'now' and 'start'
        options that are supported by GetTOTPCode cannot be specified on a url and that external applications may not support
        all of the options and will fallback to the defaults.
    @param secret The key to use (raw byte value)
    @param account The name of the user's account (may be left empty)
    @param issuer The name of the issuer of the secret (may be left empty)
    @cell(integer) options.interval The interval to use in seconds, defaults to 30
    @cell(string) options.hmac The HMAC algorithm to use, defaults to "HMAC:SHA-1"
    @cell(integer) options.digits The length of the resulting password, range [6-8], defaults to 6
    @return The url that can be used in external applications (for example by encoding it in a scannable QR code)
*/
PUBLIC STRING FUNCTION GetTOTPUrl(STRING secret, STRING account, STRING issuer, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL
      [ defaultoptions.interval
      , defaultoptions.hmac
      , defaultoptions.digits
      ], options,
      [ enums := [ hmac := allowed_hmacs ]
      ]);

  IF (options.digits < 6 OR options.digits > 8)
    THROW NEW Exception(`Invalid number of digits: ${options.digits}`);

  RETURN CreateOTPUrl("totp", secret, account, issuer, 0, options);
}

STRING FUNCTION CreateOTPUrl(STRING type, STRING secret, STRING account, STRING issuer, INTEGER64 counter, RECORD options)
{
  INTEGER expectedlength := GetKeyLength(options.hmac);
  IF (Length(secret) != expectedlength)
    THROW NEW Exception(`Expected secret of ${expectedlength} bytes, got ${Length(secret)} bytes`);
  STRING ARRAY otpurl := [ `otpauth://${EncodeURL(type)}/${issuer != "" ? EncodeURL(issuer) || ":" : ""}${EncodeURL(account)}?secret=${Tokenize(EncodeBase32(secret), "=")[0]}` ];
  IF (issuer != "")
    INSERT `issuer=${EncodeURL(issuer)}` INTO otpurl AT END;
  IF (type = "hotp")
    INSERT `counter=${counter}` INTO otpurl AT END;
  IF (options.hmac != "HMAC:SHA-1")
  {
    // Convert "HMAC:SHA-1" to "SHA1"
    STRING algorithm := options.hmac;
    IF (algorithm LIKE "HMAC:*")
      algorithm := Substitute(Substring(options.hmac, 5), "-", "");
    INSERT `algorithm=${EncodeURL(algorithm)}` INTO otpurl AT END;
  }
  IF (options.digits != 6)
    INSERT `digits=${options.digits}` INTO otpurl AT END;
  IF (type = "totp" AND options.interval != 30)
    INSERT `period=${options.interval}` INTO otpurl AT END;

  RETURN Detokenize(otpurl, "&");
}

/** Unpacks an OTP url
    @param url URL to unpack
    @return Unpacked URL
    @cell(string) return.type URL type ('totp' / 'hotp')
    @cell(string) return.secret The key to use (raw byte value)
    @cell(string) return.account The name of the user's account
    @cell(string) return.issuer The name of the issuer of the secret
    @cell(integer) return.counter The counter value to start from (HOTP only)
    @cell(record) return.options TOTP/HOTP options
    @cell(string) return.options.hmac The HMAC algorithm
    @cell(integer) return.options.digits The length of the resulting password, range [6-8]
    @cell(integer) return.options.interval The interval in seconds (TOTP only)
*/
PUBLIC RECORD FUNCTION UnpackOTPUrl(STRING url)
{
  RECORD retval :=
      [ type :=     ""
      , issuer :=   ""
      , account :=  ""
      , secret :=   ""
      , options :=  DEFAULT RECORD
      ];

  RECORD options := defaultoptions;

  RECORD unpacked := UnpackURL(url);
  STRING path := Tokenize(unpacked.urlpath, "?")[0];
  IF (path LIKE "*:*")
  {
    retval.issuer := Tokenize(path, ":")[0];
    retval.account := SubString(path, LENGTH(retval.issuer) + 1);
  }
  ELSE
    retval.account := path;

  retval.secret := DecodeBase32(GetVariableFromURL(url, "secret"));
  options.hmac := `HMAC:${Substitute(GetVariableFromURL(url, "algorithm") ?? "SHA1", "SHA", "SHA-")}`;
  options.digits := ToInteger(GetVariableFromURL(url, "digits") ?? "6", 6);

  IF (unpacked.origin = "otpauth://totp")
  {
    retval.type := "totp";
    options.interval := ToInteger(GetVariableFromURL(url, "period") ?? "30", 30);
    retval.options := CELL
        [ options.hmac
        , options.digits
        , options.interval
        ];
  }
  ELSE IF (unpacked.origin = "otpauth://hotp")
  {
    retval.type := "hotp";
    INSERT CELL counter := ToInteger64(GetVariableFromURL(url, "counter") ?? "0", 0) INTO retval;

    retval.options := CELL
        [ options.hmac
        , options.digits
        ];
  }
  ELSE
    THROW NEW Exception(`Passed URL is not a valid OTP url`);

  RETURN retval;
}

/** @short Create a new HOTP/TOTP secret
    @param hmac The HMAC algorithm for which the secret is used, defaults to "HMAC:SHA-1"
    @return A new random secret
*/
PUBLIC STRING FUNCTION GenerateOTPSecret(STRING hmac DEFAULTSTO "HMAC:SHA-1")
{
  RETURN DecodeBase16(GenerateRandomText(2 * GetKeyLength(hmac), "0123456789abcdef"));
}

/** Test if a TOTP code matches the expected value
    @param secret The key to use (raw byte value)
    @param code Expected code
    @cell(integer) options.interval The interval to use in seconds, defaults to 30
    @cell(string) options.hmac The HMAC algorithm to use, defaults to "HMAC:SHA-1"
    @cell(integer) options.digits The length of the resulting password, range [6-8], defaults to 6
    @cell(datetime) options.now Current time
    @cell(integer) options.allowdrift Allowed drift in seconds. Rounded down to whole intervals.
    @return Match result
    @cell(boolean) return.success Whether a match was found
    @cell(integer) return.driftintervals Drift in interval steps
    @cell(integer) return.driftseconds Drift in seconds
*/
PUBLIC RECORD FUNCTION TestTOTPCode(STRING secret, STRING code, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL
      [ defaultoptions.interval
      , defaultoptions.hmac
      , defaultoptions.digits
      , defaultoptions.start
      , now :=          GetCurrentDateTime()
      , allowdrift :=   30
      ], options);

  IF (options.digits < 6 OR options.digits > 8)
    THROW NEW Exception(`Invalid number of digits: ${options.digits}`);

  options.allowdrift := RoundToMultiple(options.allowdrift, options.interval, "toward-zero");
  BOOLEAN success;
  INTEGER driftintervals, absdriftintervals;

  INTEGER maxdriftsteps := options.allowdrift / options.interval;

  // Work from zero drift outward, record only the first match
  FOR (INTEGER driftsteps := -maxdriftsteps; driftsteps <= maxdriftsteps; driftsteps := driftsteps + 1)
  {
    INTEGER drift := driftsteps * options.interval * 1000;
    INTEGER absdriftsteps := driftsteps < 0 ? -driftsteps : driftsteps;
    DATETIME testtime := AddTimeToDate(drift, options.now);

    STRING expectcode := GetTOTPCode(secret, CELL[ ...options, now := AddTimeToDate(drift, options.now), DELETE allowdrift ]);
    IF (expectcode = code)
    {
      IF (NOT success OR absdriftintervals > absdriftsteps)
      {
        success := TRUE;
        driftintervals := driftsteps;
        absdriftintervals := absdriftsteps;
      }
    }
  }

  RETURN CELL
      [ success
      , driftintervals
      , driftseconds :=     driftintervals * options.interval
      ];
}
