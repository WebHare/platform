<?wh
/** @topic harescript-utils/comparisons
*/

LOADLIB "wh::util/stringparser.whlib";

/** Semantic Versioning, see: http://semver.org */

/**
     @param compareparts A mix of INTEGER and STRING components suitable for direct comparisons */
PUBLIC RECORD FUNCTION DecodeVersion(STRING version)
{
  // Ignore leading v* (npm range parser ignores it)
  VARIANT ARRAY compareparts;
  IF (version LIKE "v*")
    version := SubString(version, 1);

  STRING ARRAY parts := Tokenize(version, "+");
  IF (Length(parts) > 2)
    RETURN DEFAULT RECORD;
  BOOLEAN hasbuild := Length(parts) > 1;
  STRING build := hasbuild ? Detokenize(ArraySlice(parts, 1), "+") : "";

  BOOLEAN hasprerelease := parts[0] LIKE "*-*";
  STRING prerelease := hasprerelease ? Substring(parts[0], SearchSubstring(parts[0], "-") + 1) : "";
  IF (hasprerelease)
    parts[0] := Left(parts[0], Length(parts[0]) - Length(prerelease) - 1);

  parts := Tokenize(parts[0], ".");
  IF (Length(parts) != 3)
    RETURN DEFAULT RECORD;

  FOREVERY(STRING part FROM parts)
  {
    INTEGER num := ToInteger(part, -1);
    IF(num < 0)
      RETURN DEFAULT RECORD;

    INSERT num INTO compareparts AT END;
  }

  IF(hasprerelease)
  {
    INSERT prerelease INTO compareparts AT END;
    IF(hasbuild)
        INSERT build INTO compareparts AT END;
  }

  RETURN CELL[ major := compareparts[0]
             , minor := compareparts[1]
             , patch := compareparts[2]
             , prerelease := prerelease
             , build := build
             , compareparts
             ];
}

BOOLEAN FUNCTION IsOnlyDigits(STRING digits)
{
  OBJECT s := NEW StringParser(digits);
  s->ParseWhileInSet(s->set_digit);
  RETURN digits != "" AND s->eof;
}

PUBLIC STRING FUNCTION EncodeVersion(RECORD version)
{
  IF (NOT CellExists(version, "major") OR version.major < 0
      OR NOT CellExists(version, "minor") OR version.minor < 0
      OR NOT CellExists(version, "patch") OR version.patch < 0)
    RETURN "";

  RETURN version.major || "." || version.minor || "." || version.patch
      || (CellExists(version, "prerelease") AND version.prerelease != "" ? "-" || version.prerelease : "")
      || (CellExists(version, "build") AND version.build != "" ? "+" || version.build : "");
}

PUBLIC STRING FUNCTION IncrementVersionMajor(STRING version)
{
  RECORD decoded := DecodeVersion(version);
  IF (NOT RecordExists(decoded))
    RETURN "";
  RETURN EncodeVersion(MakeUpdatedRecord(decoded, [ major := decoded.major + 1
                                                  , minor := 0
                                                  , patch := 0
                                                  ]));
}

PUBLIC STRING FUNCTION IncrementVersionMinor(STRING version)
{
  RECORD decoded := DecodeVersion(version);
  IF (NOT RecordExists(decoded))
    RETURN "";
  RETURN EncodeVersion(MakeUpdatedRecord(decoded, [ minor := decoded.minor + 1
                                                  , patch := 0
                                                  ]));
}

PUBLIC STRING FUNCTION IncrementVersionPatch(STRING version)
{
  RECORD decoded := DecodeVersion(version);
  IF (NOT RecordExists(decoded))
    RETURN "";
  RETURN EncodeVersion(MakeUpdatedRecord(decoded, [ patch := decoded.patch + 1 ]));
}

PUBLIC BOOLEAN FUNCTION IsValidVersion(STRING version)
{
  RETURN RecordExists(DecodeVersion(version));
}

PUBLIC BOOLEAN FUNCTION IsVersionNewer(STRING fromversion, STRING toversion)
{
  RECORD fromdecoded := DecodeVersion(fromversion);
  RECORD todecoded := DecodeVersion(toversion);

  IF (NOT RecordExists(fromdecoded))
    RETURN RecordExists(todecoded); // If fromversion is invalid, toversion is newer if valid
  ELSE IF (NOT RecordExists(todecoded))
    RETURN FALSE; // If toversion is invalid, it is not newer than fromversion

  // Major is greater, or major is equal and minor is greater, or minor is equal and patch is greater
  RETURN todecoded.major > fromdecoded.major OR
      (todecoded.major = fromdecoded.major AND (todecoded.minor > fromdecoded.minor OR
        (todecoded.minor = fromdecoded.minor AND (todecoded.patch > fromdecoded.patch OR
          (todecoded.patch = fromdecoded.patch AND IsPrereleaseNewer(fromdecoded.prerelease, todecoded.prerelease))))));
}

BOOLEAN FUNCTION IsPrereleaseNewer(STRING fromprerelease, STRING toprerelease)
{
  // Prelease version has lower precendence (so, no prerelease is newer)
  IF ((fromprerelease = "") != (toprerelease = ""))
    RETURN toprerelease = "";

  // Compare every dot separated identifier from left to right until a difference is found
  STRING ARRAY fromparts := Tokenize(fromprerelease, ".");
  STRING ARRAY toparts := Tokenize(toprerelease, ".");

  INTEGER maxlen := Min[]([LENGTH(fromparts), LENGTH(toparts)]);
  FOR (INTEGER i := 0; i < maxlen; i := i + 1)
  {
    BOOLEAN fromisdigit := IsOnlyDigits(fromparts[i]);
    BOOLEAN toisdigit := IsOnlyDigits(toparts[i]);

    // digit vs non-digit: non-digit has precedence (the one with digits is the smaller one)
    IF (fromisdigit != toisdigit)
      RETURN fromisdigit; // So if from is only digits, to must be newer.

    IF (fromisdigit)
    {
      // Only digits: compare numerically
      INTEGER64 from_int := ToInteger64(fromparts[i], 0);
      INTEGER64 to_int := ToInteger64(toparts[i], 0);
      IF (from_int != to_int)
        RETURN from_int < to_int;
    }
    ELSE
    {
      // Non-digits: compare ASCII (UTF-8 will do)
      IF (fromparts[i] != toparts[i])
        RETURN fromparts[i] < toparts[i];
    }
  }

  // More parts: higher precedence
  RETURN LENGTH(toparts) > LENGTH(fromparts);
}

/** Parser for semver range expressions. See https://docs.npmjs.com/misc/semver.
*/
STATIC OBJECTTYPE SemverRangeParser
< // ---------------------------------------------------------------------------
  //
  // Internal variables
  //

  /// Stringparser
  OBJECT p;

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  /** Returns a semver range that matches everything
  */
  RECORD FUNCTION EncodeMatchAny()
  {
    RECORD partial := this->EncodeValue(0, 0, 0, "");
    partial.parts := 0;
    RETURN [ type := "=", value := partial ];
  }

  /** Returns an webhare version
  */
  RECORD FUNCTION EncodeValue(INTEGER major, INTEGER minor, INTEGER patch, STRING prerelease)
  {
    STRING encoded := EncodeVersion(CELL[ major, minor, patch, prerelease ]);
    RETURN CELL
        [ decoded :=    DecodeVersion(encoded)
        , parts :=      prerelease != "" ? 4 : 3
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Parsing functions
  //

  /** Parses a range set
  */
  RECORD FUNCTION ParseRangeSet()
  {
    // Parses: range ( || range )*. Range can be ''.
    this->p->ParseWhileInSet(" ");
    RECORD e := this->ParseRange();

    WHILE (this->p->TryParse("||"))
    {
      e := e ?? this->EncodeMatchAny();
      this->p->ParseWhileInSet(" ");
      IF (this->p->eof)
        RETURN e;

      RECORD e2 := this->ParseRange();
      IF (NOT RecordExists(e2))
        BREAK;

      IF (e.type != "or")
        e := [ type := "or", vals := [ e ] ];
      INSERT e2 INTO e.vals AT END;
    }
    RETURN e;
  }

  RECORD FUNCTION ParseRange()
  {
    this->p->ParseWhileInSet(" ");
    IF (this->p->eof)
      RETURN this->EncodeMatchAny();

    RECORD e := this->ParseSimple();
    IF (NOT RecordExists(e))
      RETURN DEFAULT RECORD;

    IF (this->p->TryParse(" - "))
    {
      this->p->ParseWhileInSet(" ");
      RECORD e2 := this->ParseSimple();
      IF (NOT RecordExists(e2))
        THROW NEW Exception("Expected a second version in the range");

      RETURN [ type := "and", vals := [ [ type := ">=", value := e.value ], [ type := "<=", value := e2.value ] ] ];
    }


    e := [ type := "and", vals := [e]];

    WHILE (this->p->TryParse(" "))
    {
      this->p->ParseWhileInSet(" ");
      RECORD e2 := this->ParseRange();
      IF (NOT RecordExists(e2))
        BREAK;

      //IF (e.type != "and")
      //  e := [ type := "and", vals := [ e ] ];

      //INSERT e2 INTO e.vals AT END;
      e.vals := e.vals CONCAT e2.vals;
    }
    RETURN e;
  }

  RECORD FUNCTION ParseSimple()
  {
    this->p->ParseWhileInSet(" ");
    STRING prefix := this->p->ParseWhileInSet("<>=~^");
    IF (prefix = "~>")
      prefix := "~";
    IF (prefix NOT IN [ "<", ">", "<=", ">=", "=", "~", "^", "" ])
      THROW NEW Exception(`Illegal prefix '${prefix}'`);

    this->p->ParseWhileInSet(" ");
    RECORD partial := this->ParsePartial();

    IF (prefix = "" AND NOT RecordExists(partial))
      RETURN DEFAULT RECORD;

    /// Rewrite '~'
    IF (prefix = "~")
    {
      IF (partial.parts = 0)
        RETURN CELL[ type := "=", value := partial ];
      IF (partial.parts = 1)
      {
        RETURN
            [ type :=   "and"
            , vals :=   [ [ type :=     ">="
                          , value :=    partial
                          ]
                        , [ type :=     "<"
                          , value :=    this->EncodeValue(partial.decoded.major + 1, 0, 0, "")
                          ]
                        ]
            ];
      }

      // ~a.b.c-PRE translates to: (>= a.b.c-pre AND < a.b.c-ZZZZZZZ) OR (>= a.b.c AND < a.b+1.0)
      IF (partial.parts > 3)
      {
        RETURN
            [ type := "or"
            , vals := [ [ type := "and"
                        , vals := [ [ type := ">="
                                    , value := partial
                                    ]
                                  , [ type := "<"
                                    , value := this->EncodeValue(partial.decoded.major, partial.decoded.minor, partial.decoded.patch, "~") //~ is higher than any LEGAL value
                                    ]
                                  ]
                        ]
                      , [ type := "and"
                        , vals := [ [ type := ">="
                                    , value := this->EncodeValue(partial.decoded.major, partial.decoded.minor, partial.decoded.patch, "")
                                    ]
                                  , [ type := "<"
                                    , value := this->EncodeValue(partial.decoded.major, partial.decoded.minor + 1, 0, "")
                                    ]
                                  ]
                        ]
                      ]
            ];
      }

      // ~a.b.c translates to: >= a.b.c AND < a.b+1.0
      RETURN
          [ type := "and"
          , vals := [ [ type :=     ">="
                      , value :=    partial
                      ]
                    , [ type :=     "<"
                      , value :=    this->EncodeValue(partial.decoded.major, partial.decoded.minor + 1, 0, "")
                      ]
                    ]
          ];
    }

    /// Rewrite '~'
    IF (prefix = "^")
    {
      IF (partial.parts = 0)
        RETURN CELL[ type := "=", value := partial ];
      IF (partial.parts = 1 OR partial.decoded.major != 0)
      {
        RETURN
            [ type :=   "and"
            , vals :=   [ [ type :=     ">="
                          , value :=    partial
                          ]
                        , [ type :=     "<"
                          , value :=    this->EncodeValue(partial.decoded.major + 1, 0, 0, "")
                          ]
                        ]
            ];
      }
      IF (partial.parts = 2 OR partial.decoded.minor != 0)
      {
        RETURN
            [ type :=   "and"
            , vals :=   [ [ type :=     ">="
                          , value :=    partial
                          ]
                        , [ type :=     "<"
                        , value :=    this->EncodeValue(partial.decoded.major, partial.decoded.minor + 1, 0, "")
                          ]
                        ]
            ];
      }
      RETURN
          [ type :=   "and"
          , vals :=   [ [ type :=     ">="
                        , value :=    partial
                        ]
                      , [ type :=     "<"
                        , value :=    this->EncodeValue(partial.decoded.major, partial.decoded.minor, partial.decoded.patch + 1, "")
                        ]
                      ]
          ];
    }

    RETURN CELL
        [ type :=   prefix ?? "="
        , value :=  partial
        ];
  }

  /** Parses a (partial) version number
      @return
      @cell return.decoded Decoded version number, x'ed parts are defaulted to 0
      @cell return.parts Number of non-x'ed parts
  */
  RECORD FUNCTION ParsePartial()
  {
    INTEGER parts;

    INTEGER minor;
    INTEGER major;
    INTEGER patch;
    STRING prerelease;
    STRING build;

    this->p->TryParse("v");
    STRING p1 := this->ParseXR();
    IF (p1 = "")
      RETURN DEFAULT RECORD;

    major := ToInteger(p1, 0);
    IF (p1 NOT IN [ "x", "X", "*" ])
      parts := 1;
    STRING s := p1;

    IF (this->p->TryParse("."))
    {
      STRING p2 := this->ParseXR();
      minor := ToInteger(p2, 0);
      IF (parts = 1 AND p2 NOT IN [ "x", "X", "*" ])
        parts := 2;
      s := s || "." || p2;

      IF (this->p->TryParse("."))
      {
        STRING p3 := this->ParseXR();
        patch := ToInteger(p3, 0);
        IF (parts = 2 AND p3 NOT IN [ "x", "X", "*" ])
          parts := 3;
        s := s || "." || p3;
        IF (this->p->TryParse("-"))
        {
          prerelease := this->ParseParts();
          parts := 4;
          s := s || "-" || prerelease;
        }
        IF (this->p->TryParse("+"))
        {
          build := this->ParseParts();
          parts := 5;
          s := s || "+" || build;
        }
      }
    }

    STRING encoded := EncodeVersion(CELL[ major, minor, patch, prerelease ]);
    RECORD decoded := DecodeVersion(encoded);
    RETURN CELL
        [ decoded
        , parts
        ];
  }

  /** Parses a version number or 'x', 'X', '*'
  */
  STRING FUNCTION ParseXR()
  {
    RETURN this->p->ParseWhileInSet("0123456789xX*");
  }

  /** Parses a prerelease or build tag
  */
  STRING FUNCTION ParseParts()
  {
    STRING s := this->ParsePart();
    WHILE (this->p->TryParse("."))
      s := s || "." || this->ParsePart();
    RETURN s;
  }

  /** Parses part of a prerelease/build part
  */
  STRING FUNCTION ParsePart()
  {
    RETURN this->p->ParseWhileInSet(this->p->set_alpha || this->p->set_digit || "-");
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Parses a semver range
      @return Record with semver range expression
      @cell return.type 'and', 'or', '=', '>=', '<', '<='
      @cell return.vals For types 'and' and 'or', list of sub-ranges
      @cell return.value Version
      @cell return.value.parts Number of initial parts of version (eg 1.2.x has 2 numeric parts, * has 3, 1.2.3-beta2 has 3)
      @cell return.value.decoded Decoded version, with the non-numeric parts defaulted to 0.
  */
  PUBLIC RECORD FUNCTION Parse(STRING s)
  {
    this->p := NEW StringParser(NormalizeWhitespace(s));
    RECORD e := this->ParseRangeSet();
    this->p->ParseWhileInSet(" ");
    IF (NOT this->p->eof)
      THROW NEW Exception(`Could not parse semver range '${s}', error at '${this->p->remaining_data}'`);
    RETURN e;
  }

>;

/** Returns whether a parsedrange (type is not 'and' or 'or') matches the numeric part of a decoded version
*/
BOOLEAN FUNCTION MatchNumeric(RECORD lhs, RECORD rhs)
{
  RETURN lhs.major = rhs.major AND lhs.minor = rhs.minor AND lhs.patch = rhs.patch;
}

RECORD ARRAY FUNCTION GatherVersions(RECORD range)
{
  IF(range.type IN ["or","and"])
  {
    RECORD ARRAY versions;
    FOREVERY(RECORD val FROM range.vals)
      versions := versions CONCAT GatherVersions(val);
    RETURN versions;
  }
  RETURN RECORD[ range.value.decoded ];
}

BOOLEAN FUNCTION CompareSemverRangeWithVersionRecursive(RECORD parsedrange, RECORD decodedversion, STRING comparemode)
{
  SWITCH (parsedrange.type)
  {
    CASE "or"
    {
      FOREVERY (RECORD rec FROM parsedrange.vals)
        IF(CompareSemverRangeWithVersionRecursive(rec, decodedversion, comparemode))
          RETURN TRUE;

       RETURN FALSE;
    }
    CASE "and"
    {
      FOREVERY (RECORD rec FROM parsedrange.vals)
        IF(NOT CompareSemverRangeWithVersionRecursive(rec, decodedversion, comparemode))
          RETURN FALSE;

      IF(comparemode = "npm" AND decodedversion.prerelease != "")
      {
        /* in NPM, a prerelease NEVER matches if the relevant major/minor/patch with a prerelase aren't mentioned anywhere
           so for version a.b.c-x to be a match, even after all ranges, there must be a a.b.c-y somewhere in the versions */
        FOREVERY(RECORD version FROM GatherVersions(parsedrange))
          IF(version.prerelease != "" AND MatchNumeric(version, decodedversion))
            RETURN TRUE; //Qualified because of this verison

        RETURN FALSE; //Disqualified, no matching version
      }
      RETURN TRUE;
    }
    CASE "=","<=",">=","<",">"
    {
      //Print(`${EncodeJSON(lhsparts)} ${parsedrange.type} ${EncodeJSON(rhsparts)}\n`);
      VARIANT ARRAY rhsparts := ArraySlice(parsedrange.value.decoded.compareparts, 0, parsedrange.value.parts);
      VARIANT ARRAY lhsparts := decodedversion.compareparts;

      FOREVERY(VARIANT rhs FROM rhsparts) //we compare part-by-part - first three components are lexical, prerelease is lexical with an exception for empty...
      {
        VARIANT lhs;
        IF(#rhs < Length(lhsparts))
          lhs := lhsparts[#rhs];
        ELSE IF(#rhs<3)
          lhs := 0;
        ELSE
          lhs := "";

        BOOLEAN isequal := lhs = rhs;

        //for prerelease: lhs="" is bigger than all rhs!="", and lhs!="" is smaller than all rhs=""
        BOOLEAN issmaller;
        IF(NOT isequal)
          IF(#rhs = 3) //no prerelease is larger than any other prerelease. only npm does alphabetic compare,
            issmaller := lhs = "" ? FALSE : rhs = "" ? TRUE : lhs < rhs;
          ELSE
            issmaller := lhs < rhs;

        BOOLEAN isfinal := #rhs = Length(rhsparts) - 1 AND Length(lhsparts) = Length(rhsparts);

        BOOLEAN satisfied;
        IF(isfinal)
        {
          satisfied := isequal ? parsedrange.type LIKE "*=" : issmaller ? parsedrange.type LIKE "<*" : parsedrange.type LIKE ">*";
        }
        ELSE
        {
          satisfied := issmaller ? parsedrange.type LIKE "<*" : isequal OR parsedrange.type LIKE ">*";
          IF(satisfied AND NOT isequal) //if we're satisfied by a non-equality, we don't need to process further parts , (ie we are at 1.[2].3 < 1.[5].0) - no need to compare futher)
            BREAK;
        }

        IF(NOT satisfied)
          RETURN FALSE;
      }

      BOOLEAN numericmatch := Length(rhsparts) >= 3 AND lhsparts[0] = rhsparts[0] AND lhsparts[1] = rhsparts[1] AND lhsparts[2] = rhsparts[2];
      IF(Length(lhsparts) > 3)
      {
        //prerelease in LHS but no in RHS? Then by definition LHS < RHS
        IF(Length(rhsparts) = 3 AND numericmatch)
        {
          IF(parsedrange.type NOT LIKE "<*") //Reject - prereleasetag in LHS orders BEFORE any 'unspecified'
            RETURN FALSE;
        }
        IF(Length(rhsparts) > 3 AND numericmatch)
        {
          IF(comparemode = "webhare" AND rhsparts[3] != lhsparts[3]) //Reject - prereleasetag in WebHare never matches any other prereleasetag
            RETURN FALSE;
        }
      }
      RETURN TRUE; //Fully satisfied
    }
    DEFAULT
    {
      THROW NEW Exception(`Not implemented type ${parsedrange.type}`);
    }
  }
}

BOOLEAN FUNCTION HasGITCommitHash(STRING range)
{
  STRING hash := Tokenize(range || "#", "#")[1];
  RETURN LENGTH(hash) = 40;
}

BOOLEAN FUNCTION __CompareSemverRangeWithVersion(STRING semverrange, STRING version, STRING comparemode)
{
  OBJECT p := NEW SemverRangeParser;


  RECORD parsed;
  TRY
    parsed := p->Parse(semverrange);
  CATCH
  {
    STRING rangebase := Tokenize(semverrange, "#")[0];
    STRING versionbase := Tokenize(version, "#")[0];

    BOOLEAN satisfies := semverrange = version;
    IF (version LIKE "git+*" OR version LIKE "git:*" OR version LIKE "github:*")
    {
      IF (HasGITCommitHash(semverrange))
      {
        // When a commit hash is present, require an webhare match (with 'git+' and '.git' additions allowed)
        satisfies := satisfies OR (version IN [ semverrange, `git+${semverrange}`, `git+${Substitute(semverrange, "#", ".git#")}`, `git+${semverrange}.git` ]);
      }
      ELSE
      {
        // without a commit hash, ignore all hashes
        satisfies := satisfies OR (versionbase IN [ rangebase, `git+${rangebase}`, `git+${rangebase}.git` ]);
      }
    }

    RETURN satisfies;
  }

  RECORD decodedversion := DecodeVersion(version);
  IF (NOT RecordExists(decodedversion))
    RETURN FALSE;  //FIXME shouldn't we be throwing or  soemthing like that?

  RETURN CompareSemverRangeWithVersionRecursive(parsed, decodedversion, comparemode);
}

/** Check if a semantic version matches the specified range
    @param version Version to check
    @param semverrange Semver range to check against
    @cell(string) options.comparemode Comparison rules.
                  If 'webhare' (the default), prerelease tags never match other prerelease tags for that version.
                  If 'npm', prerelease tags are compared lexically, but additionally a prerelease version can only satisfy if its major.minor.patch is mentioned in combination with any patchlevel in the semver range
    @return True if 'version' qualifies */
PUBLIC BOOLEAN FUNCTION VersionSatisfiesRange(STRING version, STRING semverrange, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ comparemode := "webhare" ], options, [ enums := [ comparemode := ["npm","webhare"] ]]);
  RETURN __CompareSemverRangeWithVersion(semverrange, version, options.comparemode);
}
