<?wh

/** @short Fetch
    @long Fetching resources over the internet via HTTP
    @topic internet/webbrowser
*/

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/xml.whlib";
LOADLIB "wh::internet/mime.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "mod::system/lib/services.whlib";

OBJECT fetchpool;

STATIC OBJECTTYPE FetchResponseHeaders
<
  RECORD ARRAY headers;
  MACRO NEW(VARIANT ARRAY headers)
  {
    FOREVERY(VARIANT hdr FROM headers)
      INSERT CELL[ name  := hdr[0], value := hdr[1] ] INTO this->headers AT END;
  }
  PUBLIC STRING FUNCTION get(STRING headername)
  {
    RETURN SELECT AS STRING value FROM this->headers WHERE ToUppercase(name) = ToUppercase(headername);
  }
>;

STATIC OBJECTTYPE FetchResponse
<
  RECORD fetchresult;
  OBJECT __headers;

  PUBLIC PROPERTY status(fetchresult.status, -);
  PUBLIC PROPERTY statustext(fetchresult.statustext, -);
  // A boolean indicating whether the response was successful (status in the range 200 â€“ 299) or not.
  PUBLIC PROPERTY ok(fetchresult.ok, -);
  PUBLIC PROPERTY headers(__headers, -);

  MACRO NEW(RECORD fetchresult)
  {
    this->fetchresult := fetchresult;
    this->__headers := NEW FetchResponseHeaders(fetchresult.headers);
  }
  PUBLIC ASYNC FUNCTION JSON()
  {
    RETURN DecodeJSONBlob(this->fetchresult.body);
  }
  PUBLIC ASYNC FUNCTION Text()
  {
    RETURN BlobToString(this->fetchresult.body);
  }
>;

STATIC OBJECTTYPE SyncFetchResponse
<
  OBJECT asyncresponse;

  MACRO NEW(OBJECT asyncresponse)
  {
    this->asyncresponse := asyncresponse;
  }

  PUBLIC PROPERTY status(asyncresponse->status, -);
  PUBLIC PROPERTY statustext(asyncresponse->statustext, -);
  PUBLIC PROPERTY ok(asyncresponse->ok, -);
  PUBLIC PROPERTY headers(asyncresponse->headers, -);

  PUBLIC VARIANT FUNCTION JSON()
  {
    RETURN WaitForPromise(this->asyncresponse->JSON());
  }
  PUBLIC VARIANT FUNCTION Text()
  {
    RETURN WaitForPromise(this->asyncresponse->Text());
  }
>;

/** Fetch a HTTP resource
    @param uri URI of the resource
    @param options Fetch options
    @param pooloptions Pool options
    @return Promise resvoling to a Response
*/
PUBLIC ASYNC FUNCTION Fetch(STRING uri, RECORD options DEFAULTSTO DEFAULT RECORD, RECORD pooloptions DEFAULTSTO DEFAULT RECORD)
{
  IF(NOT ObjectExists(fetchpool))
    fetchpool := OpenWebHareService("system:fetchpool");

  options := ValidateOptions(
      [ method :=         "GET"
      , headers :=        DEFAULT RECORD
      , body :=           DEFAULT BLOB
      , redirect :=       "follow"
      ],
      options,
      [ enums :=        [ redirect := [ "follow", "error", "manual" ]
                        ]
      , optional :=     [ "body" ]
      , notypecheck  := [ "body" ]
      ]);

  pooloptions := ValidateOptions(
      [ timeout :=  -1 //fetch would use (abort) siganl
      , debug :=    FALSE //debug from pool to console
      ], pooloptions);

  IF(CellExists(options,'body'))
  {
    IF(TYPEID(options.body) NOT IN [TYPEID(BLOB),TYPEID(STRING)])
      THROW NEW Exception(`BODY must be either a BLOB or a STRING`);
  }

  IF(NOT RecordExists(options.headers))
    options.headers := CELL[];

  TRY
  {
    RETURN NEW FetchResponse(AWAIT (AWAIT fetchpool)->goFetch(uri, options, pooloptions));
  }

  CATCH(OBJECT<ServiceDisconnectException> e)
  {
    //just reconnect (once)
    fetchpool := OpenWebHareService("system:fetchpool");
    RETURN NEW FetchResponse(AWAIT (AWAIT fetchpool)->goFetch(uri, options, pooloptions));
  }
}

/** Synchronous fetch implemtentation */
PUBLIC OBJECT FUNCTION FetchSync(STRING uri, RECORD options DEFAULTSTO DEFAULT RECORD, RECORD pooloptions DEFAULTSTO DEFAULT RECORD)
{
  RETURN NEW SyncFetchResponse(WaitForPromise(Fetch(uri, options, pooloptions)));
}
