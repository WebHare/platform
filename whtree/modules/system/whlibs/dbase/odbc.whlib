<?wh
/** @short Accessing ODBC data sources
    @long Access ODBC data sources, using already installed Microsoft data access components or a UnixODBC driver.
    @topic database/odbc
*/

LOADLIB "wh::internal/retransdb.whlib";

//FIXME this is enforcing WHDB rules onto postgress, perhaps case folding should be done at a higher level (or make it configurable on the driver)
STRING FUNCTION EncodeIdentifier(STRING name)
{
  RETURN '"' || ToLowercase(Substitute(name,'"','""')) || '"';
}

PUBLIC OBJECTTYPE ODBCException EXTEND Exception
<
  MACRO NEW(STRING what) : Exception(what)
  {

  }
>;

STRING FUNCTION GetHareScriptTypeFromSQLType(INTEGER type)
{
  SWITCH (type)
  {
    // sql.h
    CASE 1        { RETURN "STRING"; }    // SQL_CHAR
    CASE 2        { RETURN "MONEY"; }     // SQL_NUMERIC
    CASE 3        { RETURN "MONEY"; }     // SQL_DECIMAL
    CASE 4        { RETURN "INTEGER"; }   // SQL_INTEGER
    CASE 5        { RETURN "INTEGER"; }   // SQL_SMALLINT
    CASE 6        { RETURN "FLOAT"; }     // SQL_FLOAT
    CASE 7        { RETURN "FLOAT"; }     // SQL_REAL
    CASE 8        { RETURN "FLOAT"; }     // SQL_DOUBLE
    CASE 9        { RETURN "DATETIME"; }  // SQL_DATETIME
    CASE 12       { RETURN "STRING"; }    // SQL_VARCHAR

     // sqlext.h
    CASE -1       { RETURN "STRING"; }    // SQL_LONGVARCHAR
    CASE -2       { RETURN "BLOB"; }      // SQL_BINARY
    CASE -3       { RETURN "BLOB"; }      // SQL_VARBINARY
    CASE -4       { RETURN "BLOB"; }      // SQL_LONGVARBINARY
    CASE -5       { RETURN "INTEGER"; }   // SQL_BIGINT; how to translate?
    CASE -6       { RETURN "INTEGER"; }   // SQL_TINYINT
    CASE -7       { RETURN "BOOLEAN"; }   // SQL_BIT
    CASE -9       { RETURN "STRING"; }    // SQL_WVARCHAR
    CASE -10      { RETURN "STRING"; }    // SQL_WLONGVARCHAR
    CASE -11      { RETURN "STRING"; }    // SQL_GUID
    CASE 10       { RETURN "DATETIME"; }  // SQL_TIME
    CASE 11       { RETURN "DATETIME"; }  // SQL_TIMESTAMP

    CASE 91       { RETURN "DATETIME"; }  // SQL_TYPE_DATE
    CASE 92       { RETURN "DATETIME"; }  // SQL_TYPE_TIME
    CASE 93       { RETURN "DATETIME"; }  // SQL_TYPE_TIMESTAMP

    DEFAULT { RETURN "UNKNOWN"; }
  }
}


PUBLIC OBJECTTYPE ODBCTransaction EXTEND RetransLowlevelTransaction
<
  BOOLEAN cached_pgsql_check; //FIXME remove
  BOOLEAN is_pgsql; //FIXME remove

  BOOLEAN pvt_isauto;
  BOOLEAN pvt_is_work_open;

  MACRO NEW(INTEGER id, RECORD config, BOOLEAN isauto)
  : RetransLowLevelTransaction(id,
        [ full_null_translation := CellExists(config, "FULL_NULL_TRANSLATION") AND config.full_null_translation
        ])
  {
    //FIXME: Use SQLSetConnectAttr to switch to manual-commit mode

    this->RegisterTransaction(id);
    this->pvt_isauto := isauto;
  }

  UPDATE STRING FUNCTION GetType()
  {
    RETURN "odbc";
  }

  UPDATE PUBLIC BOOLEAN FUNCTION HasWorkSupport()
  {
    RETURN this->pvt_isauto;
  }

  BOOLEAN FUNCTION IsPostgresql()
  {
    IF(NOT this->cached_pgsql_check)
    {
      this->cached_pgsql_check := TRUE;
      this->is_pgsql := GetODBCInfo(this->id).database_application="PostgreSQL";
    }
    RETURN this->is_pgsql;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetSchemaListing()
  {
    //ADDME Blind assumption of postgresql ....
    IF(this->IsPostgresql())
    {
      RECORD ARRAY schemalist := SELECT schema_name := nspname
                                      , is_system_schema := (nspname LIKE 'pg_*' OR nspname='information_schema')
                                   FROM SendODBCCommand(this->id,'select nspname from pg_namespace');
      RETURN schemalist;
    }

    RECORD ARRAY schemalist := SELECT DISTINCT schema_name FROM GetODBCTables(this->id);
    schemalist := SELECT *
                       , is_system_schema := ToUppercase(schema_name) IN ["INFORMATION_SCHEMA"]
                    FROM schemalist;
    RETURN schemalist;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetTableListing(STRING findschemaname)
  {
    RETURN SELECT table_name
                , primary_key_name := "FIXME"
                , isview := FALSE //FIXME get views too
             FROM GetODBCTables(this->id)
            WHERE ToUppercase(schema_name) = ToUppercase(VAR findschemaname);
  }

  PUBLIC RECORD ARRAY FUNCTION GetRawColumnListing(STRING schemaname, STRING tablename)
  {
    RETURN GetODBCColumns(this->id, schemaname || "." || tablename);
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetColumnListing(STRING schemaname, STRING tablename)
  {
    RECORD ARRAY incols := GetODBCColumns(this->id, schemaname || "." || tablename);

/*    RETURN
        SELECT column_name
             , data_type
             , character_octet_length
             , character_maximum_length
             , is_nullable := not_null = FALSE
             , column_default
             , is_unique := columns."unique"
          FROM incols;;
          */

          //this is what postgres returned, ODBC incompatibiltiy?!    RETURN
//printrecordarrayto(0,incols,'boxed');

//FIXME return proper data_types, getting '4' from unixodbc postgresql

/*

*/

    RETURN
        SELECT column_name
             , data_type :=   ToString(data_type)
             , character_octet_length := char_octet_length
             , character_maximum_length := CellExists(incols, "BUFFER_LENGTH") ? buffer_length : column length // odbc 3 vs 2
             , is_nullable
             , column_default := column_def
             , is_unique := FALSE
             , hstype :=      GetHareScriptTypeFromSQLType(data_type)
          FROM incols;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION Commit()
  {
    CommitODBCTransaction(this->id);
    this->UnregisterTransaction();
    RETURN DEFAULT RECORD ARRAY; // FIXME: errors?
  }

  UPDATE PUBLIC MACRO Close()
  {
    RollbackODBCTransaction(this->id);
    this->UnregisterTransaction();
  }

  UPDATE PUBLIC BOOLEAN FUNCTION IsWorkOpen()
  {
    RETURN NOT this->pvt_isauto OR this->pvt_is_work_open;
  }

  UPDATE PUBLIC MACRO BeginWork(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->pvt_is_work_open := TRUE;
  }
  UPDATE PUBLIC RECORD ARRAY FUNCTION CommitWork()
  {
    this->pvt_is_work_open := FALSE;
    RETURN DEFAULT RECORD ARRAY; // FIXME
  }

  UPDATE PUBLIC MACRO CreateSchema(STRING schemaname, STRING ownerschema, STRING ownerrole)
  {
    IF(ownerschema != "")
      THROW NEW Exception("This database driver does not support owners inside schemas");

    SendODBCCommand(this->id, 'CREATE SCHEMA ' || EncodeIdentifier(schemaname));
  }
  UPDATE PUBLIC MACRO DropSchema(STRING schemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ cascade := FALSE ], options);
    SendODBCCommand(this->id, 'DROP SCHEMA ' || EncodeIdentifier(schemaname) || (options.cascade ? ' CASCADE' : ''));
  }
>;


RECORD FUNCTION __StartODBCTransaction(RECORD transinfo) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short List available ODBC data sources
    @param sourcetype Type of sources to request (0=show all sources, 1=show user sources only, 2=show system sources only)
    @param codepage Codepage that will be used to convert characters sent by the driver (leave empty to use unicode)
    @return record array of data sources
    @cell return.name Name of the data source
    @cell return.driver Driver associated with this data source
    @see GetODBCTables GetODBCColumns GetODBCInfo
*/
PUBLIC RECORD ARRAY FUNCTION GetODBCDataSources(INTEGER sourcetype, STRING codepage) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** Start a new ODBC transaction
    @param transinfo Data about how the transaction must be opened
    @cell transinfo.type String value that specifies how the transaction should be opened
        (allowed values: "DRIVER": connect by driver string, "DSN": connect using a DSN)
    @cell transinfo.connection_string Connection string to send to the ODBC driver (mandatory for driver-connects)
    @cell transinfo.dsn ODBC driver name (mandatory for dsn-connects)
    @cell transinfo.username User name (mandatory for dsn-connects)
    @cell transinfo.password Password (mandatory for dsn-connects)
    @cell transinfo.codepage Codepage to use to translate all odbc driver output (for
        use with non-unicode complient drivers), allowed for both driver and dsn
    @return The new transaction, throws if opening the transaction failed
*/
PUBLIC OBJECT FUNCTION StartODBCTransaction(RECORD transinfo)
{
  RECORD tr := __StartODBCTransaction(transinfo);
  IF(tr.id=0)
    THROW NEW ODBCException(tr.msg ?? `Unable to setup the ODBC connection${tr.error = "" ? "" : ": " || tr.error}`);

  RETURN NEW ODBCTransaction(tr.id, DEFAULT RECORD, FALSE);
}

/** @short Open an ODBC transaction
    @param dsn Data source name
    @param username Username to use when connecting
    @param password Password for the given username
    @return The transaction id for the ODBC connection. If connection failed value <= 0
*/
PUBLIC INTEGER FUNCTION OpenODBCTransaction(STRING dsn, STRING username, STRING password)// __ATTRIBUTES__(EXTERNAL "wh_odbc");
{
  RETURN StartODBCTransaction([type:="DSN", dsn := dsn, username := username, password := password])->id;
}

RECORD ARRAY FUNCTION __GetODBCTables(INTEGER transaction) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Lists tables in a ODBC transaction
    @param transaction ODBC transaction
    @return record array of table descriptions
    @cell return.table_name Name of the table
    @see GetODBCColumns GetODBCDataSources GetODBCInfo
*/
PUBLIC RECORD ARRAY FUNCTION GetODBCTables(INTEGER transaction)
{
  RECORD ARRAY data := __GetODBCTables(transaction);
  IF (LENGTH(data) = 0)
    RETURN data;

  // ODBC 2.0 and 3.0 have different names... compensate for that.
  IF (CellExists(data[0], "TABLE_CAT"))
    RETURN SELECT catalog_name  := table_cat
                , schema_name   := table_schem
                , table_name    := table_name
                , type          := table_type
             FROM data;
  ELSE
    RETURN SELECT catalog_name  := table_qualifier
                , schema_name   := table_owner
                , table_name    := table_name
                , type          := table_type
             FROM data;
}



/** @short Lists colums in a ODBC table
    @param transaction ODBC transaction
    @param tablename Table to list columns of
    @return record array of column descriptions
    @cell return.column_name Name of the table
    @see GetODBCTables GetODBCDataSources GetODBCInfo
*/
PUBLIC RECORD ARRAY FUNCTION GetODBCColumns(INTEGER transaction, STRING tablename) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Sends a query to an ODBC driver
    @long Sends a single, raw SQL query to the ODBC driver, without any further processing. Selects the best matching types for the columns in the returned record array
    @param transaction ODBC transaction
    @param query Query to send
    @return Returned records, if exist
*/
PUBLIC RECORD ARRAY FUNCTION SendODBCCommand(INTEGER transaction, STRING query) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Sends a query to an ODBC driver and specify the required return types
    @long Sends a single, raw SQL query to the ODBC driver, without any further processing. Unlike @link SendODBCCommand, this command allows you to specify the exact HareScript types you want to be used in the returned record array
    @param transaction ODBC transaction
    @param query Query to send
    @param types An integer array, containing a typeid for every returned column indicating the requested type
    @return Returned records, if exist
*/
PUBLIC RECORD ARRAY FUNCTION SendODBCTypedCommand(INTEGER transaction, STRING query, INTEGER ARRAY types) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Commits an ODBC transaction
    @param transaction ODBC transaction
    @see RollbackODBCTransaction
*/
PUBLIC MACRO CommitODBCTransaction(INTEGER transaction) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Rolls an ODBC transaction back
    @param transaction ODBC transaction
    @see CommintODBCTransaction
*/
PUBLIC MACRO RollbackODBCTransaction(INTEGER transaction) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Get the ODBC driver information and capabilities
    @long This function returns information about the settings and
          capabilities of an ODBC transaction. It is intended for debugging
          purposes and the use of raw commands (SendODBCCommand and
          SendODBCTypedCommand) only - the native HareScript SQL commands will
          automatically cope with and simulate any missing functionality.
    @param transaction ODBC transaction id
    @return A record explaining the ODBC capabilities of a transaction
    @cell return.cap_setpos_position SQL_POS_POSITION - If available, HareScript native SELECT will be faster because they can fetch blocks instead of single rows
    @cell return.cap_setpos_modify SQL_POS_UPDATE and SQL_POS_DELETE - If available, HareScript native UPDATE and DELETE will be faster because they can fetch blocks instead of single rows
    @cell return.cap_bind Every ODBC driver should support column binding, which is faster, but disabling column binding may help track down problems with an individual ODBC driver
    @cell return.cap_getdata_when_bound SQL_GD_BOUND - If available, both native and raw commands will be faster because transferring small blobs and strings requires less ODBC driver communication
    @cell return.cap_getdata_any_column SQL_GD_ANY_COLUMN - If available, the ordering of selected columns in raw commands should have no effect on speed. If unavailable, larger columns should be selected after smaller columns.
    @cell return.database_name Name of the connected database
    @cell return.database_version Version of the connected database
    @cell return.database_application Application name of the connected database
    @cell return.driver_name Name of the driver used to connect
    @cell return.driver_version Version of the driver used to connect
    @cell return.driver_odbc_version ODBC Version of the driver used to connect
    @cell return.readonly True if this data source is read-only
    @cell return.pos_options A string listing the options offered by SetPos
    @cell return.scroll_options A string listing the capabilities of cursors
    @cell return.dynamic_attributes A string listing the attributes supported by dynamic cursors
    @cell return.forward_only_attributes A string listing the attributes supported by forward-only cursors
    @cell return.keyset_driven_attributes A string listing the attributes supported by keyset-driven cursors
    @cell return.static_attributes A string listing the attributes supported by static cursors
    @cell return.need_long_data_length True if this database needs to know the length beforehand of LONG data passed to it
    @see SetODBCCapabilities GetODBCTables GetODBCDataSources GetODBCDataSources
*/
PUBLIC RECORD FUNCTION GetODBCInfo(INTEGER transaction) __ATTRIBUTES__(EXTERNAL "wh_odbc");

/** @short Update a driver's ODBC capabilities
    @long This function updates the capability settings stored for a transaction.
          The HareScript ODBC driver accepts the new capability settings without
          verification, so this function should be used with caution and probably
          only for debugging - it can produce unpredictable results.
          This function can only be used to update the 'cap_' cells in the information
          returned by GetODBCInfo
    @param transaction ODBC transaction id
    @param newcaps A record with new capability settings, in the format as returned by GetODBCInfo
    @see GetODBCInfo
*/
PUBLIC MACRO SetODBCCapabilities(INTEGER transaction, RECORD newcaps) __ATTRIBUTES__(EXTERNAL "wh_odbc");
