<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::internal/interface.whlib";

LOADLIB "mod::system/lib/services.whlib";

RECORD ARRAY untransferred_table;
INTEGER next_untransferred_id := 24000;
BOOLEAN debug := FALSE;

VARIANT FUNCTION MapToBridgeRecursive(VARIANT input)
{
  IF(TYPEID(input) = TYPEID(RECORD))
  {
    IF(NOT RecordExists(input))
      RETURN DEFAULT RECORD;
    RETURN RepackRecord(SELECT *, value := MapToBridgeRecursive(value) FROM UnpackRecord(input));
  }

  IF(TYPEID(input) IN [TYPEID(OBJECT), TYPEID(FUNCTION PTR)])
  {
    IF(NOT IsValueSet(input))
      RETURN DEFAULT RECORD;

    INTEGER handleid := SELECT AS INTEGER id FROM untransferred_table WHERE TYPEID(val) = TYPEID(input) ? val = input : FALSE;
    IF(handleid != 0)
      RETURN [ __unmarshallable_type := GetTypeName(TYPEID(input)), id := handleid ];

    next_untransferred_id := next_untransferred_id + 1;
    INSERT [ id := next_untransferred_id, val := input ] INTO untransferred_table AT END;
    RETURN [ __unmarshallable_type := GetTypeName(TYPEID(input)), id := next_untransferred_id ];
  }

  RETURN input;
}

VARIANT FUNCTION MapToBridge(VARIANT input)
{
  VARIANT retval := MapToBridgeRecursive(input);
  IF(debug)
    DumpValue(retval, [ name := "MapToBridge" ]);
  RETURN retval;
}

VARIANT FUNCTION MapFromBridgeRecursive(VARIANT input)
{
  IF(TYPEID(input) = TYPEID(RECORD) AND CellExists(input, "__unmarshallable_type"))
  {
    RECORD match := SELECT * FROM untransferred_table WHERE id = input.id;
    IF(NOT RecordExists(match))
      THROW NEW Exception(`No such unmarshallable #${input.id}`);
    RETURN match.val;
  }
  RETURN input;

  IF(TYPEID(input) = TYPEID(RECORD))
  {
    IF(NOT RecordExists(input))
      RETURN DEFAULT RECORD;
    RETURN RepackRecord(SELECT *, value := MapFromBridgeRecursive(value) FROM UnpackRecord(input));
  }

  RETURN input;
}

VARIANT FUNCTION MapFromBridge(VARIANT input)
{
  VARIANT retval := MapFromBridgeRecursive(input);
  IF(debug)
    DumpValue(retval, [ name := "MapFromBridge" ]);
  RETURN retval;
}

INTEGER connecttimeout_cb := RegisterTimedCallback(AddTimeToDate(10000, GetCurrentDateTime()), PTR TerminateScriptWithError("HSVM bridge job not connected to within 10 seconds"));

VARIANT FUNCTION InvokeFPTR(FUNCTION PTR fptr, VARIANT ARRAY args)
{
  IF(__INTERNAL_DEBUGGETFUNCTIONPTRRETURNTYPE(fptr) IN [ 0, 2 ]) //it's a macro!
  {
    CallMacroPTRVA(fptr, args);
    RETURN [ __unmarshallable_type := "undefined" ];
  }
  ELSE
  {
    RETURN MapToBridge(CallFunctionPtrVA(fptr, args));
  }
}

OBJECTTYPE Controller
<
  MACRO NEW()
  {
    IF (connecttimeout_cb != 0)
      UnregisterCallback(connecttimeout_cb);
    connecttimeout_cb := 0;
  }
  PUBLIC ASYNC FUNCTION CreatePrintCallback(STRING text)
  {
    IF(debug)
      Print(`[bridge_hsvm] CreatePrintCallback(...)\n`);
    RETURN MapToBridge(PTR Print(text));
  }
  PUBLIC ASYNC FUNCTION Invoke(STRING lib, STRING name, VARIANT ARRAY args)
  {
    IF(debug)
      Print(`[bridge_hsvm] Invoke('${lib}', '${name}', ${Length(args)} arguments)\n`);

    args := SELECT AS VARIANT ARRAY MapFromBridge(arg) FROM ToRecordArray(args,"arg");
    RETURN InvokeFPTR(MakeFunctionPtr(lib,name), args);
  }
  PUBLIC ASYNC FUNCTION ObjInvoke(VARIANT obj, STRING name, VARIANT ARRAY args)
  {
    IF(debug)
      Print(`[bridge_hsvm] ObjInvoke(obj, '${name}', ${Length(args)} arguments)\n`);

    obj := MapFromBridge(obj);
    args := SELECT AS VARIANT ARRAY MapFromBridge(arg) FROM ToRecordArray(args,"arg");

    VARIANT retval;
    IF(ToUppercase(name) = "GET")
      RETURN MapToBridge(GetMember(obj, args[0]));
    ELSE
      RETURN InvokeFPTR(GetObjectMethodPtr(obj, name), args);
  }
  PUBLIC INTEGER FUNCTION GetNumObjects()
  {
    IF(debug)
      Print(`[bridge_hsvm] GetNumObjects()\n`);

    RETURN Length(untransferred_table);
  }
  PUBLIC MACRO ObjCleanup(INTEGER objid)
  {
    IF(debug)
      Print(`[bridge_hsvm] ObjCleanup(${objid})\n`);

    DELETE FROM untransferred_table WHERE id = objid;
  }

  // Called when service link is closed
  PUBLIC MACRO OnClose()
  {
    IF(debug)
      Print(`[bridge_hsvm] OnClose()\n`);

    TerminateScript();
  }
>;

OBJECT FUNCTION CreateController()
{
  RETURN NEW Controller;
}

RunWebhareService("system:bridge_hsmv_" || GetCurrentGroupId(), PTR CreateController, [ autorestart := FALSE ]);
