<?wh /* Prepare WebHare for shipping */
// wh run mod::system/scripts/internal/shrinkwrap.whscr /tmp/shrink

LOADLIB "wh::promise.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";

RECORD ARRAY options :=
  [ [ name := "outputfile", type := "param", required:=TRUE ]
  ];

RECORD args := ParseArguments(GetConsoleArguments(), options);
IF (NOT RecordExists(args))
{
  PRINT("Syntax: wh run shrinkwrap.whscr <outputfile>\n");
  RETURN;
}

OpenPrimary();
OBJECT service := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));

RECORD status := WaitForPromise(service->GetStatus());

OBJECT ARRAY promises;
RECORD ARRAY tocompile := SELECT * FROM status.bundles;
FOREVERY (RECORD bundle FROM tocompile)
  INSERT service->WaitForCompile(bundle.outputtag, FALSE) INTO promises AT END;

PRINT("Compiling: " || Detokenize((SELECT AS STRING ARRAY outputtag FROM tocompile), ", ") || "\n");
FOREVERY(OBJECT promise FROM promises)
{
  RECORD compileresult := WaitForPromise(promise);
  IF(compileresult.haserrors)
    ABORT(`Compilation of ${tocompile[#promise].outputtag} failed`);
}

WaitForPromise(CreatePromiseAll(promises));

OBJECT zipfile := CreateNewArchive("tar.gz");

FOREVERY(STRING outputtag FROM SELECT AS STRING ARRAY assetpacks.outputtag FROM system_internal.assetpacks)
{
  STRING tagfolder := Substitute(outputtag,':','.');
  zipfile->AddDiskFolderRecursive(GetWebHareConfiguration().varroot || "publisher.ap/" || tagfolder, "publisher.ap/" || tagfolder);
}
StoreDiskFile(args.outputfile, zipfile->MakeBlob(), [ overwrite := TRUE ]);
