<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::float.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::internet/tcpip.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/restart_reset.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/backend/backendsite.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";
LOADLIB  "mod::wrd/lib/internal/metadata/applyupdates.whlib";

BOOLEAN debug;
OBJECT trans;

MACRO UpdateModuleNotifications()
{
  trans->BeginWork();

  // Create a list of registered notifications
  RECORD ARRAY notifications;
  FOREVERY (RECORD mod FROM GetWebHareModules())
    IF (RecordExists(mod.portal))
      notifications := notifications CONCAT SELECT *
                                                 , module := (SELECT AS INTEGER id
                                                                FROM system.modules
                                                               WHERE name = mod.name)
                                              FROM mod.portal.notifications;

  // Check if current notifications are still registered
  FOREVERY (RECORD cur_ntf FROM SELECT * FROM system.towl_notifications)
  {
    RECORD new_ntf := SELECT *
                           , idx := #notifications
                        FROM notifications
                       WHERE notifications.module = cur_ntf.module
                             AND notifications.name = cur_ntf.name;

    IF (RecordExists(new_ntf))
    {
      // Update current notification
      UPDATE system.towl_notifications
         SET descriptiontid := new_ntf.description
           , defaultenabled := new_ntf.defaultenabled
       WHERE id = cur_ntf.id;

      // Don't need to add this, it already exists
      DELETE FROM notifications AT new_ntf.idx;
    }
    ELSE
    {
      // Current notification no longer registered, delete it
      DELETE FROM system.towl_notifications
             WHERE id = cur_ntf.id;
    }
  }

  // Add all new notifications that don't exist yet
  FOREVERY (RECORD new_ntf FROM notifications)
  {
    INSERT INTO system.towl_notifications(module, name, descriptiontid, defaultenabled)
           VALUES(new_ntf.module, new_ntf.name, new_ntf.description, new_ntf.defaultenabled);
  }

  trans->CommitWork();
}

MACRO HandleRunonceOutput(RECORD module, RECORD ro_result)
{
  FOREVERY(STRING msg FROM ro_result.messages)
    Print(module.name || " poststart runonce script: " || msg || "\n");
}

MACRO RunPostStartRunOnceScripts()
{
  RECORD ARRAY modlist := GetWebHareModules();

  FOREVERY (RECORD module FROM modlist)
  {
    OBJECT validator := GetModuleXMLValidator(module.name);
    INSERT CELL runoncescripts := ParseModuleDefRunonce(validator) INTO module;

    RECORD ro_result := RunRunOnceScripts(module, "poststart", debug);
    HandleRunonceOutput(module, ro_result);
  }
}

debug := IsDebugTagEnabled("startup");
DATETIME start := GetCurrentDatetime();

IF (IsDatabaseWritable())
{
  LogDebug("system:poststart", "Database is writable, start preparing");
  trans := OpenPrimary();

  //initialize non-core modules
  STRING ARRAY modules := ArrayDelete(GetInstalledModuleNames(), whconstant_builtinmodules);
  IF(Length(modules) > 0) {
    LogDebug("system:poststart", "Startup non core modules");
    WebHareStartup(modules, FALSE);

    LogDebug("system:poststart", "Apply non core module WRD schemas");
    //update WRD schemas for non-core modules
    UpdateAllModuleSchemas(CELL[modules]);
  }

  //TODO when installing, initdb_phase2 will have taken care of siteprofile compilation through UpdateBackendSite. we might see if we can have initdb_phase2 stop doing that ?

  //just in case this serverm missed its initdb due to odd upgrade ordering
  trans->BeginWork();
  IF(ReadRegistryKey("system.global.servername") = "")
    WriteRegistryKey("system.global.servername", GetSystemHostName(TRUE));
  IF(ReadRegistryKey("system.global.installationid") = "")
    WriteRegistryKey("system.global.installationid", GenerateUFS128BitId());
  IF(ReadRegistryKey("system.webserver.security.cachesecret")="")
    WriteRegistryKey("system.webserver.security.cachesecret", GenerateUFS128BitId()||GenerateUFS128BitId());
  IF(ReadRegistryKey("system.webserver.security.cookiesecret")="")
    WriteRegistryKey("system.webserver.security.cookiesecret", GenerateUFS128BitId()||GenerateUFS128BitId());
  IF(ReadRegistryKey("system.webserver.security.debugsecret")="")
    WriteRegistryKey("system.webserver.security.debugsecret", GenerateUFS128BitId()||GenerateUFS128BitId());
  IF(ReadRegistryKey("system.webserver.security.gcmsecret")="")
    WriteRegistryKey("system.webserver.security.gcmsecret", EncodeUFS(DecodeUFS(GenerateUFS128BitId())||DecodeUFS((GenerateUFS128BitId()))));
  trans->CommitWork();

  trans->BeginWork();
  LogDebug("system:poststart", "Start UpdateSystemBackendSite");
  UpdateSystemBackendSite();
  trans->CommitWork();

  // Rebuild various webhare pregenerated files so they are available before poststart completes (TODO we may need to generate non type-info stubs for missing files so scripts have something to import)
  ApplyWebHareConfiguration([ subsystems := [ "config" ], source := "post-start" ]);

  LogDebug("system:poststart", "Start UpdateModuleNotifications");
  UpdateModuleNotifications();

  LogDebug("system:poststart", "Start RunPostStartRunOnceScripts");
  RunPostStartRunOnceScripts();

  IF(GetEnvironmentVariable("WEBHARE_POSTSTARTSCRIPT") != "")
  {
    LogDebug("system:poststart", "Start post-startscript: " || GetEnvironmentVariable("WEBHARE_POSTSTARTSCRIPT"));
    OBJECT proc := CreateProcess(GetEnvironmentVariable("WEBHARE_POSTSTARTSCRIPT"), STRING[],
      [ take_input := FALSE
      , take_output := FALSE
      , take_errors := FALSE
      ]);

    proc->share_stdout := TRUE;
    proc->share_stderr := TRUE;
    proc->Start();

    OBJECT itr := MakeProcessAsyncIterator(proc);
    INTEGER exitcode;
    WHILE (TRUE)
    {
      RECORD rec := WaitForPromise(itr->Next());
      IF (rec.done)
        BREAK;
      IF (rec.value.type = "close")
        exitcode := rec.value.exitcode;
    }
    proc->Close();
    IF(exitcode != 0)
    {
      PrintTo(2, "Startup script failed with exitcode #" || exitcode || "\n");
      SetConsoleExitCode(1);
    }
  }

  RECORD startupdata := EnforceStructure([ start := DEFAULT DATETIME], PollWHServiceState("startup"));
  FLOAT startuptime := GetDatetimeDifference(startupdata.start, GetCurrentDateTime()).msecs / 1000f;
  LogDebug("system:poststart", CELL[ state := "finished", startuptime ]);
  Print(`All post start tasks completed, ${formatFloat(startuptime,3)} seconds from launch\n`);
}

SetWHServiceState("poststartdone", [ start := start, finished := GetCurrentDatetime() ]);
