<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::float.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internal/jobs.whlib";
LOADLIB "wh::internal/wasm.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/testfw/runtest.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";


MACRO __SYSTEM_SETSYSTEMCONFIG(RECORD data) __ATTRIBUTES__(EXTERNAL);

// -----------------------------------------------------------------------------
//
// Constants
//

// -----------------------------------------------------------------------------
//
// Variables
//

RECORD ARRAY testdefs;
BOOLEAN print_output;
BOOLEAN print_errors;
BOOLEAN quiet_mode;
BOOLEAN breakonerror;
BOOLEAN use_jobs;
BOOLEAN autotests;
OBJECT testrunner;
BOOLEAN reduceverboseness;
OBJECT jstestrunner;
STRING ARRAY testtypes;
STRING profiling; // "", "cov", "apr"
BOOLEAN jscoverage;
RECORD parsedargs;
BOOLEAN keepopen;
BOOLEAN alwayslog;
BOOLEAN showbrowser;

DATETIME teststart := GetCurrentDateTime();
BOOLEAN interrupted;
RECORD interruptdefer := CreateDeferredPromise();
MACRO AbortTests()
{
  PrintTo(2,`Interrupt received..\n`);
  SetConsoleExitCode(250);
  interrupted := TRUE;
  interruptdefer.resolve([ type := "interrupt", done := FALSE, value := [ type := "interrupt" ]]); //look like both a simple value and an iterator value
}
AddInterruptCallback(PTR AbortTests);

MACRO MyPrint(STRING message)
{
  IF (NOT quiet_mode)
    PRINT(message);
}

/** @return
    @cell(string) return.status ok/fail/none
    @cell(record array) return.failed string array of failed tests
    @cell(string) return.failed.test Name of the failed test
    @cell(string array) return.executed string array of executed tests
*/
RECORD FUNCTION RunTest(RECORD testinfo, STRING testmask, BOOLEAN toplevel, STRING ARRAY skips) {
  RECORD result :=
      [ status :=       "none"
      , failed :=       DEFAULT RECORD ARRAY
      , executed :=     DEFAULT STRING ARRAY

      , id := ""
      , time_msecs := 0
      , failures := RECORD[]
      ];

  IF (testrunner->print_debug)
    Print("; RunTest(" || testinfo.type || ", " || testinfo.testname || ")\n");

  DATETIME start := GetCurrentDateTime();
  SWITCH (testinfo.type) {
    CASE "test"  {
      IF ("backend" NOT IN testtypes)
      {
        result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
        RETURN result;
      }

      IF (autotests AND testinfo.skipauto)
      {
        IF (testrunner->print_debug)
          Print("; Skipping test: " || testinfo.testname || "\n");

        result.status := "ok";
        result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
        RETURN result;
      }

      FOREVERY (STRING skip FROM skips)
        IF (testinfo.testname LIKE skip)
        {
          IF (testrunner->print_debug)
            Print("; Skipping test: " || testinfo.testname || "\n");

          result.status := "ok";
          result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
          RETURN result;
        }

      STRING runner;
      STRING ARRAY arguments;
      STRING script;
      BOOLEAN run_in_job;

      STRING engine;
      IF (testinfo.type = "test")
      {
        IF (IsAbsoluteResourcePath(testinfo.script))
        {
          script := testinfo.script;
        }
        ELSE
        {
          script :=
              SELECT AS STRING MergePath(value, testinfo.script)
                FROM testinfo.params
               WHERE name = "scriptpath";
        }

        IF(script LIKE "*.sh")
        {
          runner := GetWebHareResourceDiskPath(script);
          arguments := testinfo.arguments;
        }
        ELSE IF(GetExtensionFromPath(script) IN whconstant_javascript_extensions)
        {
          runner := GetInstallationRoot() || "bin/wh";
          arguments := [ "run", GetWebHareResourceDiskPath(script), ...testinfo.arguments ];
        }
        ELSE IF(IsWasm())
        {
          //If we're running under wasm ourselves, keep everything in wasm as we can't CreateProcess anyway
          arguments := testinfo.runscriptarguments CONCAT [ script ] CONCAT testinfo.arguments;
          run_in_job := TRUE;
        }
        ELSE
        {
          engine := testinfo.engine ?? (parsedargs.wasm ? "wasm" : "native");

          IF (engine = "wasm" OR GetEnvironmentVariable("WEBHARE_HARESCRIPT_WASMONLY") != "")
          {
            runner := GetInstallationRoot() || "bin/wh";
            arguments := [ "runwasm", GetWebHareResourceDiskPath(script), ...testinfo.arguments ];
          }
          ELSE
          {
            runner := GetInstallationRoot() || "bin/runscript";
            arguments := testinfo.runscriptarguments CONCAT [ script ] CONCAT testinfo.arguments;
            run_in_job := testinfo.runmode = "process" ? FALSE
                : testinfo.runmode = "job"
                      ? TRUE
                      : use_jobs;
          }
        }
      }

      MyPrint(FormatDateTime("[%H:%M:%S.%Q]", GetCurrentDateTime()) || " Test " || (engine != "" ? engine || " " : "") || testinfo.testname || (testinfo.xfail? " (xfailed)" : "") || "\n");
      WriteLogMarker("Test " || testinfo.testname || (testinfo.xfail ? " (xfailed)" : ""));

      INSERT testinfo.testname INTO result.executed AT END;
      result.id := testinfo.testname;
      BOOLEAN success;

      // Try flaky tests for 3 times
      FOR (INTEGER tries := 0; tries < 3; tries := tries + 1)
      {
        IF (tries != 0)
          MyPrint(FormatDateTime("[%H:%M:%S.%Q]", GetCurrentDateTime()) || " Retry failed flaky test " || testinfo.testname  || " (try " || tries + 1 || ")\n");

        success := run_in_job ? WaitForPromise(RunTestJob(testinfo.testname, runner, testinfo.arguments, script, testinfo.xfail, testinfo.timeout))
                              : RunTestProcess(testinfo.testname, runner, arguments, script, testinfo.xfail, testinfo.env, testinfo.timeout);
        IF (success OR NOT testinfo.flaky)
          BREAK;
      }

      IF (NOT success)
      {
        INSERT
            [ test :=     Substitute(testinfo.testname, ".all", "")
            ] INTO result.failed AT END;
        result.status := "fail";
        INSERT [ type := "ERROR", message := "Test failed", text := "" ] INTO result.failures AT END;
      }
      ELSE
        result.status := "ok";

      result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
      RETURN result;
    }

    CASE "fail" {
      IF ("backend" NOT IN testtypes)
      {
        result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
        RETURN result;
      }

      MyPrint("\nRunning test " || testinfo.testname || ": " || testinfo.script || "\n");
      MyPrint("Test definition error: " || testinfo.errormsg || "\n");

      INSERT [ type := "ERROR", message := testinfo.errormsg, text := "" ] INTO result.failures AT END;

      INSERT SubStitute(testinfo.testname, ".all", "") INTO result.executed AT END;
      INSERT
         [ test :=  SubStitute(testinfo.testname, ".all", "")
         ] INTO result.failed AT END;
      result.status := "fail";
      result.id := Substitute(testinfo.testname, ".all", "");
      result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
      RETURN result;
    }

    CASE "jstest" {
      IF ("frontend" NOT IN testtypes)
      {
        result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
        RETURN result;
      }

      IF (autotests AND testinfo.skipauto)
      {
        IF (testrunner->print_debug)
          Print("; Skipping test: " || testinfo.testname || "\n");

        result.status := "ok";
        result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
        RETURN result;
      }

      FOREVERY (STRING skip FROM skips)
        IF (testinfo.testname LIKE skip)
        {
          IF (testrunner->print_debug)
            Print("; Skipping test: " || testinfo.testname || "\n");

          result.status := "ok";
          result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
          RETURN result;
        }

      MyPrint(FormatDateTime("[%H:%M:%S.%Q]", GetCurrentDateTime()) || " Test " || testinfo.testname || (testinfo.xfail? " (xfailed)" : "") || "\n");
      WriteLogMarker("Test " || testinfo.testname || (testinfo.xfail ? " (xfailed)" : ""));

      IF (testrunner->print_debug)
        Print("; Running test: " || testinfo.testname || "\n");

      INSERT testinfo.testname INTO result.executed AT END;
      result.id := testinfo.testname;

      IF(NOT ObjectExists(jstestrunner)) { //not initialized yet
        jstestrunner := ImportJS("mod::platform/js/testing/foregroundrunner.ts");
        WaitForPromise(jstestrunner->Init(CELL[ debug := parsedargs.d, keepopen, showbrowser, alwayslog ]));
      }

      RECORD res := WaitForPromise( CreatePromiseRace(OBJECT[ interruptdefer.promise, jstestrunner->RunTest(testinfo) ]) );

      IF(CellExists(res,'type') AND res.type = "interrupt") {
        INSERT [ test := testinfo.testname ] INTO result.failed AT END;
        result.status := "fail";
      } ELSE {
        result.status := res.status;
        IF(res.status != "ok")
          INSERT [ test := testinfo.testname ] INTO result.failed AT END;
      }
    }
    DEFAULT
    {
      THROW NEW Exception(`Unrecognized test type '${testinfo.type}'`);
    }
  }

  result.time_msecs := GetDateTimeDifference(start, GetCurrentDateTime()).msecs;
  RETURN result;
}


BOOLEAN FUNCTION RunTestProcess(STRING testname, STRING runner, STRING ARRAY arguments, STRING script, BOOLEAN xfail, RECORD ARRAY addenv, INTEGER timeout_msecs)
{
  BOOLEAN success := TRUE;

  IF (testrunner->print_debug)
    Print(`; Using command: ${runner} ${script} ${Detokenize(arguments,' ')}\n`);

  IF (profiling != "") //TODO how useful is this, as we'd be clearing out any other debug settings for our child process
  {
    addenv := addenv CONCAT [ [ name := "WEBHARE_DEBUG", value := profiling || ",context=" || testname ] ];
  }

  RECORD ARRAY env := GetEnvironment();
  FOREVERY(RECORD envvar FROM addenv) //Remove vars from environment we're overwriting
    DELETE FROM env WHERE name = envvar.name;
  env := env CONCAT addenv;

  OBJECT process;
  TRY
  {
    process := CreateProcess(runner, arguments, FALSE, TRUE, TRUE, FALSE);
    process->SetEnvironment(env);
    process->Start();
  }
  CATCH (OBJECT e)
  {
    Print("Could not start runscript: " || runner || "\n");
    IF (breakonerror)
      RETURN FALSE;
    success := FALSE;
    RETURN FALSE;
  }

  INTEGER procid := process->handle;

  BOOLEAN delay_output := xfail OR reduceverboseness;

  STRING alloutput;
  STRING currtype := "";

  INTEGER outputstream := delay_output ? CreateStream() : 0;

  DATETIME timeout := AddTimeToDate(timeout_msecs, GetCurrentDateTime());
  BOOLEAN is_timeout;

  WHILE (TRUE)
  {
    INTEGER waitmsecs := GetDateTimeDifference(GetCurrentDateTime(), timeout).msecs;
    IF (waitmsecs <= 0)
    {
      is_timeout := TRUE;
      BREAK;
    }

    WaitForProcessOutput (procid, waitmsecs);
    BOOLEAN any_output := FALSE;
    WHILE (TRUE)
    {
      STRING output := ReadProcessOutput(procid);
      IF (output = "")
        BREAK;
      IF (print_output)
      {
        any_output := TRUE;
        IF (currtype = "err")
          PrintTo(outputstream, "\n");
        ELSE IF (currtype != "out")
          PrintTo(outputstream, "> ");
        output := Substitute(output, "\r", "\r> ");
        output := Substitute(output, "\n", "\n> ");
        IF (output LIKE "*\n> ")
        {
          currtype := "";
          output := LEFT(output, LENGTH(output) - 2);
        }
        ELSE
          currtype := "out";
        PrintTo(outputstream, output);
      }
    }

    WHILE (TRUE)
    {
      STRING output := ReadProcessErrors(procid);
      IF (output = "")
        BREAK;
      IF (print_errors)
      {
        any_output := TRUE;
        IF (currtype = "out")
          PrintTo(outputstream, "\n");
        ELSE IF (currtype != "err")
          PrintTo(outputstream, "! ");
        output := Substitute(output, "\n", "\n! ");
        IF (output LIKE "*\n! ")
        {
          currtype := "";
          output := LEFT(output, LENGTH(output) - 2);
        }
        ELSE
          currtype := "err";
        PrintTo(outputstream, output);
      }

      IF(interrupted)
        InterruptProcess(procid);
    }

    IF (NOT any_output AND NOT IsProcessrunning(procid))
      BREAK;
  }

  IF (currtype != "")
    PrintTo(outputstream, "\n");

  STRING delayed_output := delay_output ? BlobToString(MakeBlobFromStream(outputstream), -1) : "";

  INTEGER exitcode;
  IF (is_timeout)
    TerminateProcess(procid);
  ELSE
    exitcode := GetProcessExitCode(procid);

  CloseProcess(procid);

  IF (timeout <= GetCurrentDateTime())
  {
    PRINT(delayed_output);
    Print("Script timed out after " || timeout_msecs || " ms\n");
    RETURN FALSE;
  }

  IF (exitcode != 0)
  {
    // Script failed
    IF (xfail)
    {
      Print("Script failed: "|| script || " (exitcode = "|| exitcode || "), as expected (XFAIL)\n");
    }
    ELSE
    {
      PRINT(delayed_output);
      Print("Script failed: "|| script || " (exitcode = "|| exitcode || ")\n");
    }
  }
  ELSE
  {
    IF (xfail)
    {
      PRINT(delayed_output);
      Print("Script succeeded unexpectedly, it was marked with XFAIL\n");
    }
  }

  RETURN (exitcode = 0) != xfail;
}

RECORD FUNCTION ReturnTimeout(INTEGER timeoutduration)
{
  RETURN [ done := FALSE, value := [ type := "timeout" ]];
}

ASYNC FUNCTION RunTestJob(STRING testname, STRING runner, STRING ARRAY arguments, STRING script, BOOLEAN xfail, INTEGER timeout_msecs)
{
  BOOLEAN success := TRUE;

  IF (testrunner->print_debug)
    Print(`; Simulating as job: ${runner} ${script} ${Detokenize(arguments,' ')}\n`);

  RECORD jobrec := CreateJob(script);

  IF (NOT ObjectExists(jobrec.job))
  {
    Print("Could not start job: " || script || "\n" || FormatHarescriptErrors(jobrec.errors));
    IF (breakonerror)
      RETURN xfail;

    RETURN xfail;
  }

  BOOLEAN delay_output := xfail OR reduceverboseness;

  OBJECT job := jobrec.job;
  INTEGER outputstream := delay_output ? CreateStream() : 0;
  INTEGER joboutput := job->CaptureOutput();
  job->SetConsoleArguments(arguments);
  IF (profiling != "")
  {
    RECORD ARRAY env := SELECT * FROM GetEnvironment() WHERE name != "WEBHARE_DEBUG";
    env := env CONCAT [ [ name := "WEBHARE_DEBUG", value := profiling || ",context=" || testname ] ];
    job->SetEnvironment(env);
  }
  job->Start();
  STRING alloutput;
  STRING currtype := "";

  BOOLEAN is_timeout;

  OBJECT itr := MakeJobAsyncIterator(job, CELL[ outputhandle := joboutput, autoclose := FALSE ]);
  OBJECT timeout := CreateSleepPromise(timeout_msecs)->Then(PTR ReturnTimeout);

  FOR (RECORD evt := AWAIT CreatePromiseRace([ timeout, interruptdefer.promise, itr->Next() ]); NOT evt.done; evt := AWAIT CreatePromiseRace([ timeout, interruptdefer.promise, itr->Next() ]))
  {
    SWITCH(evt.value.type)
    {
      CASE "timeout"
      {
        is_timeout := TRUE;
        BREAK;
      }
      CASE "output"
      {
        STRING output := evt.value.data;
        PrintTo(outputstream, output||"\n");
      }
      CASE "interrupt"
      {
        job->Terminate();
        BREAK;
      }
    }
  }

  IF (NOT delay_output AND currtype != "")
    PrintTo(outputstream, "\n");

  STRING delayed_output := delay_output ? BlobToString(MakeBlobFromStream(outputstream), -1) : "";

  RECORD ARRAY errors;
  INTEGER exitcode;

  IF (job->IsSignalled()) // Getting errors blocks when not signalled
  {
    errors := job->GetErrors();
    exitcode := job->GetConsoleExitCode();

    IF (LENGTH(errors) != 0)
      LogHarescriptErrors(errors, [ script := "direct::" || script ]);
  }

  BOOLEAN hasfailed := Length(errors)>0 OR exitcode != 0 OR interrupted;

  job->Close();

  IF (is_timeout)
  {
    PRINT(delayed_output);
    Print("Script timed out after " || timeout_msecs || " ms\n");
    RETURN xfail;
  }

  IF (hasfailed)
  {
    // Script failed
    IF (xfail)
    {
      Print("Script failed: "|| script || " (exitcode = "|| exitcode || "), as expected (XFAIL)\n");
    }
    ELSE
    {
      PRINT(delayed_output);
      Print(FormatHarescriptErrors(errors));
      Print("\nScript failed: "|| script || " (exitcode = "|| exitcode || ")\n");
    }
  }
  ELSE
  {
    IF (xfail)
    {
      PRINT(delayed_output);
      Print("Script succeeded unexpectedly, it was marked with XFAIL\n");
    }
  }

  RETURN hasfailed = xfail;
}

MACRO PrintSyntax()
{//     | <- The room between these pipe symbols is exactly 80 characters - - - - - - -> |
  Print("Usage: runtest [-deoqj] [--loop] [--breakonerror] [--skip=mask] all|testname[.group] \n");
  Print("\n");
  Print("  -d               Print test debug information\n");
  Print("  -e               Print test script errors\n");
  Print("  -o               Print test script output\n");
  Print("  -q               Runs the test in quiet mode. Only error messages will be displayed\n");
  Print("  -p               Use processes instead of jobs\n");
  Print("  --untilfail      Loop tests until something breaks\n");
  Print("  --breakonerror   Break on first failing test\n");
  Print("  --loop           After all test are finished, start again with first test (often combined with --breakonerror\n");
  Print("  --tag=..         Specify tags to require or exclude (eg: --tag=forms,-external)\n");
  Print("  --skip=mask      Skip test that match the mask (can be used multiple times)\n");
  Print("  --outputdir      Save output files to this directory\n");
  Print("  --testtype=...   Types of tests to run ('all', 'frontend', 'backend')\n");
  Print("  --param=x=y      Set a test parameters\n");
  Print("  --timeout=...    Set timeout in msecs. Defaults to 15 minutes\n");
  Print("  -b/--showbrowser Show browser during tests pages (or: WEBHARE_DEBUG=test-showbrowser)\n");
  Print("  -k/--keepopen    Do not close browser page when test fails (or: WEBHARE_DEBUG=test-keepopen)\n");
  Print("  --alwayslog      Always store logs and end result of a test, even if succesful\n");
  Print("  --wasm           Default to the wasm engine for tests that do not declare their engine\n");
  Print("  all              Run the group 'all' in all known tests\n");
  Print("  testname         Run the test with this name (may be a comma separated list)\n");
  Print("  group            Run only the given group within a test. If this parameter is\n");
  Print("                   omitted, the group 'all' is run\n");
  Print("\n");
}

MACRO SyntaxError(STRING str)
{
  IF (str != "")
    PRINT(str || "\n\n");
  PrintSyntax();
  SetConsoleExitCode(1);
  TerminateScript();
}

BOOLEAN FUNCTION CheckAgainstTags(STRING ARRAY testtags, STRING ARRAY requiretags, STRING ARRAY excludetags)
{
  IF(Length(requiretags)>0)
  {
    FOREVERY(STRING tag FROM requiretags)
      IF(tag NOT IN testtags)
        RETURN FALSE;
  }
  IF(Length(excludetags)>0)
  {
    FOREVERY(STRING tag FROM excludetags)
      IF(tag IN testtags)
        RETURN FALSE;
  }
  RETURN TRUE;
}

// -----------------------------------------------------------------------------
//
// Main code
//

parsedargs := ParseArguments(GetConsoleArguments(),
                                    [ [name := "o", type := "switch", defaultvalue := TRUE]
                                    , [name := "e", type := "switch", defaultvalue := TRUE]
                                    , [name := "d", type := "switch", defaultvalue := FALSE]
                                    , [name := "q", type := "switch", defaultvalue := FALSE]
                                    , [name := "p", type := "switch", defaultvalue := FALSE]
                                    , [name := "jscoverage", type := "switch"]
                                    , [name := "coverage", type := "switch" ]
                                    , [name := "skip", type := "stringlist"]
                                    , [name := "untilfail", type := "switch"]
                                    , [name := "breakonerror", type := "switch"]
                                    , [name := "tag", type := "stringopt"]
                                    , [name := "testtype", type := "stringlist"]
                                    , [name := "outputdir", type := "stringopt"]
                                    , [name := "param", type := "stringlist"]
                                    , [name := "loop", type := "switch"]
                                    , [name := "autotests", type := "switch"]
                                    , [name := "k", type := "switch"]
                                    , [name := "keepopen", type := "switch"]
                                    , [name := "b", type := "switch"]
                                    , [name := "showbrowser", type := "switch"]
                                    , [name := "alwayslog", type := "switch"]
                                    , [name := "terse", type := "switch"]
                                    , [name := "wasm", type := "switch"]
                                    , [name := "testlist", type := "paramlist" ]
                                    ]);

IF (NOT RecordExists(parsedargs))
  SyntaxError("Parameter syntax error");

testtypes := parsedargs.testtype;
IF ("all" IN testtypes OR Length(testtypes)=0)
  testtypes := [ ...testtypes, "frontend", "backend" ];
print_output := parsedargs.o;
print_errors := parsedargs.e;
quiet_mode := parsedargs.q;
use_jobs := NOT parsedargs.p;
breakonerror := parsedargs.breakonerror OR parsedargs.untilfail;
autotests := parsedargs.autotests;
reduceverboseness := parsedargs.terse;
keepopen := parsedargs.keepopen OR parsedargs.k;
showbrowser := parsedargs.showbrowser OR parsedargs.b;
alwayslog := parsedargs.alwayslog;
profiling := parsedargs.coverage ? "cov" : "";
jscoverage := parsedargs.jscoverage;
BOOLEAN looptests := parsedargs.loop OR parsedargs.untilfail;

STRING ARRAY requiretags, excludetags;
FOREVERY(STRING tag FROM Tokenize(parsedargs.tag,','))
  IF(tag LIKE "-*")
    INSERT Substring(tag,1) INTO excludetags AT END;
  ELSE IF(tag != "")
    INSERT tag INTO requiretags AT END;

FOREVERY (STRING testtype FROM testtypes)
  IF (testtype NOT IN [ "all", "frontend", "backend" ])
    SyntaxError(`Illegal testtype '${testtype}', allowed are: 'all', 'frontend', 'backend'`);

IF (quiet_mode)
{
  IF (testrunner->print_debug)
  {
    Print("Quiet mode should not be used in combination with either 'Print test debug information' or 'Print test script output'\n");
    RETURN;
  }

  // Disable showing output in quiet mode. Required since output option is true by default
  print_output := FALSE;
}

// Parse params

FOREVERY (STRING param FROM parsedargs.param)
{
  INTEGER eq := SearchSubstring(param, '=');
  IF (eq > 0)
    INSERT [name := Left(param, eq), value := Right(param, Length(param)-eq-1)] INTO testrunner->cmdparams AT END;
  ELSE IF (eq < 0 AND Length(param) > 0)
    INSERT [name := param, value := ""] INTO testrunner->cmdparams AT END;
}

//Let's be very tolerant of the testlist to allow users to easily copypaste. We'll accept commas and any whitespace to separate testnames
STRING ARRAY testlist;
FOREVERY(STRING testarg FROM parsedargs.testlist ?? ["all"])
{
  testarg := Substitute(testarg,',',' ');
  FOREVERY(STRING test FROM ParseXSList(testarg))
    INSERT test INTO testlist AT END;
}

//Tests are unsafe until WebHare is ready
IF(NOT RecordExists(PollWHServiceState("poststartdone")))
{
  Print(`Waiting for WebHare to reach 'poststartdone'\n`);
  WHILE(NOT RecordExists(PollWHServiceState("poststartdone")))
  {
    WaitUntil(DEFAULT RECORD, AddTimeToDate(100, GetCurrentDateTime()));
    IF (interrupted)
      TerminateScript();
  }
}

OpenPrimary();
testrunner := NEW RunTests;
testrunner->print_debug := parsedargs.d;

RECORD ARRAY alltests;
RECORD ARRAY tests := testrunner->GatherAllTests(testlist, DEFAULT STRING ARRAY);
INTEGER iteration;

TRY {
  WHILE (TRUE) {
    BOOLEAN seenanytest := FALSE;

    RECORD ARRAY failed_tests;

    iteration := iteration + 1;

    FOREVERY (RECORD test FROM tests) {
      IF(interrupted)
        BREAK;
      IF(NOT CheckAgainstTags(test.tags, requiretags, excludetags))
        CONTINUE;

      seenanytest := TRUE;
      IF (autotests AND test.skipauto) //still counts as a match for the purposes of detecting invalid wh runtest invocations
        CONTINUE;

      RECORD localresult := RunTest(test, "*", TRUE, parsedargs.skip);
      INSERT localresult INTO alltests AT END;

      STRING ARRAY failed_tests_names :=
          SELECT AS STRING ARRAY COLUMN test
            FROM localresult.failed;

      IF (test.testname LIKE "wh.hscore.test.*")
      {
        // Special processing for self test (whether failure detection in process/job code works ok)
        BOOLEAN is_error;
        FOREVERY (STRING str FROM localresult.executed)
          IF ((str LIKE "*.fail.*") != (str IN failed_tests_names))
          {
            is_error := TRUE;
            INSERT test INTO failed_tests AT END;
          }
      }
      ELSE
      {
        IF (localresult.status = "fail")
        {
          INSERT test INTO failed_tests AT END;
        }
      }
      IF (localresult.status = "none")
        THROW NEW Exception("Unexpected status 'none'");

      IF(Length(failed_tests)>0 AND breakonerror)
        BREAK;
    }

    IF (NOT seenanytest)
      TerminateScriptWithError(`Error: No test matched: '${Detokenize(parsedargs.testlist,',')}'`);

    MyPrint("\n\n+=====================================================================\n");
    IF(looptests)
      MyPrint(`| TEST RESULTS (loops so far: ${iteration})\n`);
    ELSE
      MyPrint(`| TEST RESULTS\n`);
    MyPrint("+=====================================================================\n\n");

    IF (LENGTH(failed_tests) = 0)
      MyPrint("All tests succeeded\n");
    ELSE
    {
      //Report failed tests
      Print("The following modules failed:\n");
      FOREVERY (RECORD failure FROM failed_tests)
      {
        Print(' - ' || failure.testname);
        IF(failure.type="jstest")
          Print(' ' || UpdateURLVariables("https://my.webhare.dev/" || UnpackURL(failure.baseurl).urlpath, [ mask := failure.testname ]));
        Print('\n');
      }

      SetConsoleExitCode(1);
    }

    IF (NOT looptests OR (Length(failed_tests)>0 AND breakonerror) OR interrupted)
      BREAK;
  }
} FINALLY {
  IF (ObjectExists(jstestrunner)) {
    TRY{
      WaitForPromise(jstestrunner->Close());
    } CATCH(OBJECT ignore) {
      // Ignore errors, we generally only see a 'JavaScript runner process terminated without giving a response.'
    }
  }
}

IF(parsedargs.outputdir != "")
{
  STRING testreportfile := MergePath(parsedargs.outputdir, "testreport.json");
  CreateDiskDirectoryRecursive(parsedargs.outputdir, TRUE);
  StoreDiskFile(testreportfile, EncodeJSONBlob(CELL[ alltests ]), [ overwrite := TRUE ]);
  Print(`Written test report to ${testreportfile}\n`);

  OBJECT junitfile := LoadWittyLibrary("mod::system/lib/testfw/runtest.witty","XML");
  BLOB result := junitfile->RunComponentToBlob("junitxml",
    [ numtests := Length(alltests)
    , numfailures := Length(SELECT FROM alltests WHERE Length(failures) > 0)
    , time := FormatFloat( GetDateTimeDifference(teststart, GetCurrentDateTime()).msecs / 1000f, 3)
    , testcases := SELECT id := executed[0]
                        , time := FormatFloat(time_msecs / 1000f, 3)
                        , failures
                     FROM alltests
                    WHERE id NOT LIKE "wh.hscore.test.*" //these tests cheat with their lacking xfails. banning them from junit.xml
    ]);
  StoreDiskFile(MergePath(parsedargs.outputdir, "junit.xml"), result, [ overwrite := TRUE ]);
  Print(`Written junit report to ${MergePath(parsedargs.outputdir, "junit.xml")}\n`);
}
