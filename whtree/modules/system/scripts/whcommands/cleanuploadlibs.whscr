<?wh
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::filetypes/archiving.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/modules/sourcemanipulation.whlib";
LOADLIB "mod::system/lib/internal/harescript/libscan.whlib";
LOADLIB "mod::system/lib/validation.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/resources.whlib";

CONSTANT INTEGER hs_warningcode_unusedloadlib := 29;


RECORD ARRAY replacements := [ [ replacewith := "mod::tollium/lib/gettid.whlib", lib := "mod::tollium/lib/screenbase.whlib" ]
                             , [ replacewith := "wh::adhoccache.whlib", lib := "mod::system/lib/cache.whlib" ]
                             , [ replacewith := "wh::xml/xsd.whlib", lib := "wh::filetypes/xml.whlib" ]
                             , [ replacewith := "wh::xml/dom.whlib", lib := "wh::filetypes/xml.whlib" ]
                             , [ replacewith := "wh::internet/urls.whlib", lib := "wh::internet/http.whlib" ]
                             , [ replacewith := "wh::internet/urls.whlib", lib := "wh::internet/tcpip.whlib" ]
                             ];

RECORD args := ParseArguments(GetConsoleArguments(),
                              [ [ name := "go", type := "switch" ]
                              , [ name := "dirs", type := "paramlist" ]
                              ]);
IF(NOT RecordExists(args) OR Length(args.dirs) = 0)
{
  Print("Syntax: cleanuploadlibs [--go] <dir> [dir...] \n");
  TerminateScriptWithError("Invalid syntax");
}

RECORD ARRAY toscan;

FOREVERY(STRING specifiedpath FROM args.dirs)
{
  STRING path := ResolveToAbsolutePath(specifiedpath);
  RECORD props := GetDiskFileProperties(path);

  IF(NOT RecordExists(props) AND IsModuleInstalled(specifiedpath))
  {
    path := GetModuleInstallationRoot(specifiedpath);
    props := GetDiskFileProperties(path);
  }
  IF(NOT RecordExists(props))
   TerminateScriptWithError(`No such directory '${specifiedpath}'`);


  IF(props.type = 1 AND path NOT LIKE "*/")
    path := path || "/";

  STRING resourcepath :=  GetResourceNameFromDiskPath(path);
  IF(resourcepath NOT LIKE "mod::*")
    TerminateScriptWithError(`Invalid path '${specifiedpath}' - does not resolve to a module`);

  IF(RecordExists(props) AND props.type = 0)
    toscan := toscan CONCAT [[ name := resourcepath, diskpath := path ]];
  ELSE
    toscan := toscan CONCAT GatherFiles(path, resourcepath, harescriptextensions);
}

BOOLEAN allowremoval := args.go;

FOREVERY(RECORD scan FROM toscan)
{
  IF(scan.name LIKE "mod::webhare_testsuite/tests/wh/hscore/xml/generated/*")
    CONTINUE;

  RECORD dump := __HS_LIBDUMP(scan.name); //FIXME use DescribeCompiledLibrary, have it return error info on compile failure
  IF(NOT dump.success)
  {
    Sleep(1000); //compile race?
    dump := __HS_LIBDUMP(scan.name);
  }
  IF(NOT dump.success)
  {
    Print("compilation of " || scan.name || " failed\n");
    CONTINUE;
  }

  RECORD debuginfo := DecodeJSONBlob(MakeZlibDecompressedFile(dump.debuginfo_compressed, "GZIP"));
  STRING ARRAY unneeded := SELECT AS STRING ARRAY msg1 FROM RECORD ARRAY(debuginfo.warnings) WHERE code = hs_warningcode_unusedloadlib;

  INSERT "module::*" INTO unneeded AT 0; //try cleaning mod:: first

  STRING source := BlobToString(GetDiskResource(scan.diskpath));
  BOOLEAN anychanges;

  STRING backup := source;
  FOREVERY(STRING trykill FROM unneeded)
  {
    IF(trykill = "module::*")
    {
      RECORD res := RewriteModuleLoadlibsToMod(source);
      IF(NOT res.anychanges)
        CONTINUE;
      source := res.data;
    }
    ELSE
    {
      RECORD tryclean := RemoveLoadlibStatement(source, trykill);
      IF(NOT tryclean.success)
      {
        Print("Unable to remove " || trykill || " from " || scan.name || " - not matched in source file (EXPORT?)\n");
        CONTINUE;
      }
      source := tryclean.data;
    }

    RECORD res := ValidateSingleFile(scan.name, [ overridedata := StringToBlob(source) ]);
    IF(Length(res.errors) > 0) //it failed
    {
      BOOLEAN fixedanyway;
      IF(trykill != "module::*")
      {
        //Do we have replacements for this lib?
        RECORD ARRAY possible_replacements := SELECT * FROM replacements WHERE lib = trykill;

        FOREVERY(RECORD repl FROM possible_replacements)
        {
          RECORD replaced := InsertLoadlibStatement(source, repl.replacewith);
          IF (replaced.success)
          {
            RECORD res2 := ValidateSingleFile(scan.name, [ overridedata := StringToBlob(replaced.data) ]);
            IF(Length(res2.errors)=0)
            {
              Print("Successfully replaced " || trykill || " with " || repl.replacewith || " for library " || scan.name || "\n");
              source := replaced.data;
              fixedanyway := TRUE;
              anychanges := TRUE;
              BREAK;
            }
          }
        }
      }

      IF(NOT fixedanyway)
      {
        source := backup;
        Print("Unable to remove " || trykill || " from " || scan.name || ": " || res.errors[0].message || "\n");
      }
    }
    ELSE
    {
      Print("Successfully removed " || trykill || " from " || scan.name || "\n");
      backup := source;
      anychanges := TRUE;
    }
  }

  IF(allowremoval AND anychanges)
  {
    StoreDiskFile(scan.diskpath, StringToBlob(source), [ overwrite := TRUE ]);
    Print(`Updated ${scan.diskpath}\n`);
  }
}

IF(NOT args.go)
  Print("\nTo actually apply changes, pass the --go parameter\n");
