<?wh
// command: cli [command]
// short: Performs miscellaneous configuration/recovery actions

LOADLIB "wh::os.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/webserver/proxymgmt.whlib";

LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/registry.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/backend/users.whlib";
LOADLIB "mod::system/lib/internal/backend/backendsite.whlib";


OBJECT trans := OpenPrimary();
STRING ARRAY args := GetConsoleArguments() ?? ["help"];
STRING cmd := args[0];
STRING ARRAY parts := ArraySlice(args,1);

MACRO RunGetOverride(STRING ARRAY params)
{
  RECORD subargs := ParseArguments(params,
      [ [ name := "duration", type := "stringopt"  ]
      , [ name := "reason", type := "param" ]
      ]);

  IF(NOT RecordExists(subargs))
  {
    Print("Syntax: wh cli getoverride [--duration <minutes>] <reason>\n");
    TerminateScriptWithError("");
  }

  INTEGER duration;
  IF(subargs.duration != "")
  {
    duration := ToInteger(parts[0], 0);
    IF(duration <= 0 OR duration > 60*24)
    {
      Print("Illegal duration\n");
      RETURN;
    }
    duration := duration * 60*1000;
  }
  ELSE
  {
    duration := ReadRegistryKey("system.backend.security.override.duration");
  }
  IF(subargs.reason = "")
    TerminateScriptWithError("`wh cli getoverride` requires you to specify a reason (which will be specified in the audit log)");

  LogAuditEvent("system:cli", CELL[ action :=       "getoveridetoken"
                                  , duration
                                  , subargs.reason
                                  ]);

  STRING suburl := GetOverrideTokenURL(duration);
  STRING url := ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(), suburl);

  Print(`
A new override token has been generated, it will be valid for ${duration / 60000} minutes
Login on: ${url}
or append this token to your current WebHare URL: ${suburl}
`);
}

SWITCH(ToUppercase(args[0]))
{
  CASE "__BROADCASTEVENT"
  {
    IF(Length(parts)!=2)
      ABORT("Expected two parameters: event and data");
    VARIANT data := DecodeHSON(parts[1]);
    BroadcastEvent(parts[0], data);
  }
  CASE "GETOVERRIDE"
  {
    RunGetOverride(parts);
  }
  CASE "WAITSTATE"
  {
    Print("waiting to reach state '" || parts[0] || "'...");
    WaitForPromise(CreateWHServiceStatePromise(parts[0]));
    Print("ok!\n");
  }
  CASE "UPDATEBACKEND"
  {
    trans->BeginWork();
    UpdateSystemBackendSite();
    trans->CommitWork();
  }
  CASE "SETGUID"
  {
    STRING guid := parts[0];
    STRING username := parts[1];

    IF(guid="" OR username="")
    {
      Print("Syntax: SETGUID <guid> <username>\n");
      Print("eg: SETGUID wrd:4598A3061B603818133FF3782130B4F7 sysop\n");
    }
    ELSE
    {
      trans->BeginWork();
      RECORD ARRAY matches := SELECT * FROM system.authobjects WHERE ToUppercase(name)=ToUppercase(VAR username) AND type=1;
      IF(Length(matches)=0)
      {
        Print("Cannot find user '" || username || "'\n");
      }
      ELSE IF(Length(matches)>1)
      {
        DumpVAlue(matches,'boxed');
        Print("Too many matches\n");
      }

      ELSE
      {
        UPDATE system.authobjects SET guid := VAR guid WHERE id = matches[0].id;
        Print("Done\n\n");
      }
      trans->CommitWork();
    }
  }
  CASE "LISTPROXIES"
  {
    DumpValue(ListWebHareProxies(),'boxed');
  }
  CASE "GETPROXIES"
  {
    Print(EncodeJSON(GetWebhareProxies()) || "\n");
  }
  CASE "SETPROXIES"
  {
    RECORD data := DecodeJSON(parts[0]);
    IF(NOT RecordExists(data))
    {
      Print("Syntax: SETPROXIES <jsondata>\n");
      Print("  The jsondata must be of the form { proxies: [ {url: , password:, callback: } ] } ");
      RETURN;
    }
    trans->BeginWork();
    SetWebhareProxies(data);
    trans->CommitWork();
  }
  CASE "ADDPROXY"
  {
    IF(Length(parts)!=3)
    {
      Print("Syntax: ADDPROXY <proxyurl> <proxypasswrd> <callbackurl>\n");
      RETURN;
    }

    RECORD res := TestWebHareProxy(parts[0], parts[1], parts[2]);
    IF(NOT res.success)
    {
      Print(res.errormessage || "\n");
      RETURN;
    }
    trans->BeginWork();
    SetWebhareProxy(0, [ url := parts[0], password := parts[1], reverseaddress := parts[2] ]);
    trans->CommitWork();
  }
  CASE "DELETEPROXY"
  {
    IF(Length(parts)!=1)
    {
      Print("Syntax: DELETEPROXY <proxyid>\n");
      RETURN;
    }
    INTEGER proxyid := ToInteger(parts[0],0);
    IF(NOT UnregisterWebhareProxy(proxyid))
      PRINT("WARNING! Deregistration at proxyserver failed\n");
    trans->BeginWork();
    DeleteWebhareProxy(proxyid);
    trans->CommitWork();
  }
  CASE "SETSYSTEMTYPE"
  {
    SetSystemServerType(parts[0]);
  }
  CASE "HELP"
  {
    //TODO document proxy commands, but they may actually belong in `wh webserver` ?
    PrintTo(2,`Syntax: wh cli <command>
Where command is one of:
- getoverride   - Create a 'override' token, granting sysop-level access
- updatebackend - Update the 'WebHare Backend' interface website
- setsystemtype - Set the system type (production, acceptance, test or development)
- waitstate     - Wait for the startup to reach a specified state
`);
  }
  DEFAULT
  {
    TerminateScriptWithError(`Unknown command '${cmd}'`);
  }
}
