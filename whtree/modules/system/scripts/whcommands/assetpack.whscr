<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::internal/any.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/asynctools.whlib";

OBJECT assetpackcontrol;

RECORD args := ParseArguments(GetConsoleArguments(),
                              [ [ name := "color", type := "switch" ]
                              , [ name := "quiet", type := "switch" ]
                              , [ name := "command", type := "param", required := TRUE ]
                              , [ name := "params", type := "paramlist" ]
                              ]);

MACRO Syntax(STRING errormsg DEFAULTSTO "")
{
  IF (errormsg != "")
    PRINT(errormsg || "\n");
  Print("Syntax: wh assetpack [--quiet] <instruction>\n");
  Print("  --quiet                    Don't report anything that's not an error\n");
  Print("  list [assetpacks...]       List asset packs\n");
  Print("  check [assetpacks...]      Check if assetpacks are okay. List any errors. Omit or use '*' to check all\n");
  Print("  recompile <assetpacks...>  Recompile an asset pack. Use '*' to compile all\n");
  Print("  info <assetpack>           Detailed info about an assetpack\n");
  Print("  wait [assetpacks...]       Wait for the assetpacks to be compiled. Omit or use '*' to wait for all\n");
  Print("  autocompile                Configure autocompilation of production packages\n");

  TerminateScriptWithError("Invalid syntax");
}

RECORD ARRAY FUNCTION GetBundles(STRING ARRAY masks)
{
  RECORD status := WaitForPromise(assetpackcontrol->GetStatus());
  RECORD ARRAY bundles := SELECT * FROM status.bundles WHERE Length(masks) = 0 OR __MatchesAnyMask(outputtag, masks) ORDER BY ToUppercase(outputtag);
  IF(Length(bundles) = 0)
    TerminateScriptWithError(`No assetpacks match masks: ${Detokenize(masks, ", ")}`);

  RETURN bundles;
}

MACRO PrintBundleErrors(STRING tag)
{
  RECORD data := WaitForPromise(assetpackcontrol->GetBundleStatus(tag));
  IF(data.toperror != "")
  {
    Print("Bundle " || tag || " has the following errors:\n\n");
    IF (data.toperror != "")
      Print("Errors: " || data.toperror || "\n");

    DumpValue(data.errors, "tree");
  }
}

BOOLEAN FUNCTION WaitForCompilation(STRING ARRAY masks, BOOLEAN verbose)
{
  STRING ARRAY lastcompiling;

  OBJECT condition := NEW ManualCondition;
  RegisterEventCallback("publisher:assetpackcontrol.change.*", PTR SetSignalledUponEvent(condition, #1, #2));

  WHILE (TRUE)
  {
    RECORD ARRAY bundles := GetBundles(masks);
    STRING ARRAY compiling := SELECT AS STRING ARRAY outputtag FROM bundles WHERE iscompiling;

    STRING ARRAY newcompiling := ArrayDelete(compiling, lastcompiling);
    IF (verbose AND LENGTH(newcompiling) != 0)
      PRINT(`Now compiling: ${Detokenize(newcompiling, ", ")}\n`);

    STRING ARRAY finished := ArrayDelete(lastcompiling, compiling);
    IF (verbose AND LENGTH(finished) != 0)
      PRINT(`Finished: ${Detokenize(finished, ", ")}\n`);

    lastcompiling := compiling;
    IF (LENGTH(lastcompiling) = 0)
    {
      STRING ARRAY failedassetpacks := SELECT AS STRING ARRAY outputtag FROM bundles WHERE haserrors;
      IF(verbose AND Length(failedassetpacks) > 0)
        PRINT(`FAILED: ${Detokenize(failedassetpacks, ", ")}\n`);
      RETURN Length(failedassetpacks) = 0;
    }

    WaitForPromise(condition->WaitSignalled());
    condition->signalled := FALSE;
  }
}

IF (NOT RecordExists(args) OR args.command NOT IN [ "list", "recompile", "rebuild", "info", "wait", "check", "autocompile" ])
  Syntax();

IF (args.color OR IsConsoleATerminal())
  SetAnsiCmdMode("enabled");

VARIANT ARRAY arguments := VARIANT[`wh assetpack ${Detokenize(GetConsoleArguments(),' ')}}`];
TRY
{
  assetpackcontrol := WaitForPromise(OpenWebHareService("platform:assetpacks", CELL[ timeout := 3000, arguments ]));
}
CATCH
{
  TRY
  {
    //Tell user what we're doing so we can tolerably wait a lot more (eg CI starts wh fixmodules pretty fast nowadays and WebHare may not even be running yet)
    Print("Waiting for assetpack control to be available...\n");
    assetpackcontrol := WaitForPromise(OpenWebHareService("platform:assetpacks", CELL[ timeout := 3000, arguments ]));
  }
  CATCH
  {
    PRINT("Could not connect to the assetpackcontrol\n");
    SetConsoleExitCode(1);
    RETURN;
  }
}

STRING ARRAY FUNCTION MatchUUIDs(RECORD ARRAY bundles, STRING mask)
{
   RETURN SELECT AS STRING ARRAY outputtag
              FROM bundles
             WHERE ToUppercase(outputtag) LIKE ToUppercase(mask);
}

STRING FUNCTION GetBundleStatusString(RECORD bundle)
{
  RETURN (bundle.hasstatus ? bundle.haserrors ? AnsiCmd("bold,red") || "errors" : "ok" : AnsiCmd("reset") || "n/a") || AnsiCmd("reset");
}

MACRO ListBundles(STRING ARRAY masks, BOOLEAN withwatchcounts)
{
  RECORD ARRAY bundles := GetBundles(masks);
  IF(args.quiet)
    DELETE FROM bundles WHERE NOT haserrors;

  INTEGER blen := SELECT AS INTEGER MAX(LENGTH(outputtag)) FROM bundles;
  FOREVERY (RECORD bundle FROM bundles)
  {
    STRING bundlestatus := GetBundleStatusString(bundle);
    STRING compiling := bundle.iscompiling ? AnsiCmd("bold,magenta") || "build" || AnsiCmd("reset") : bundle.requirecompile ? "dirty" : "-";
    PRINT(Left(bundle.outputtag || RepeatText(" ", blen), blen)
        || "\t" || bundlestatus
        || (withwatchcounts ? "\t" || (bundle.watchcount = 0 ? "-" : (bundle.watchcount || "")) : "")
        || "\t" || compiling || "\n");
  }
}

MACRO SetSignalledUponEvent(OBJECT cv, STRING event, RECORD data)
{
  cv->signalled := TRUE;
}

MACRO DoRecompile(STRING ARRAY masks, BOOLEAN onlyfailed)
{
  RECORD ARRAY bundles := GetBundles(masks);
  IF(onlyfailed)
    DELETE FROM bundles WHERE NOT haserrors;

  OBJECT condition := NEW ManualCondition;
  RegisterEventCallback("publisher:assetpackcontrol.change.*", PTR SetSignalledUponEvent(condition, #1, #2));

  FOREVERY (RECORD match FROM bundles)
    WaitForPromise(assetpackcontrol->RecompileBundle(match.outputtag));

  IF(NOT args.quiet)
    Print("Recompile scheduled, waiting to finish\n");

  STRING ARRAY compiling;
  STRING ARRAY done;

  WHILE (TRUE)
  {
    bundles := GetBundles(masks);
    IF(onlyfailed)
      DELETE FROM bundles WHERE NOT haserrors;

    BOOLEAN any_not_done;

    // For display ordering, first print 'done' messages
    FOREVERY (RECORD bundle FROM bundles)
    {
      IF (bundle.iscompiling)
        CONTINUE;
      IF (NOT bundle.requirecompile)
      {
        IF (bundle.outputtag NOT IN done)
        {
          Print("Bundle " || bundle.outputtag || " now done, status: " || GetBundleStatusString(bundle) || "\n");
          INSERT bundle.outputtag INTO done AT END;
        }
      }
      ELSE // Scheduled
        any_not_done := TRUE;
    }

    // And then 'compiling' messages
    FOREVERY (RECORD bundle FROM bundles)
    {
      IF (NOT bundle.iscompiling)
        CONTINUE;
      IF (bundle.outputtag NOT IN compiling)
      {
        Print("Bundle " || bundle.outputtag || " now compiling\n");
        INSERT bundle.outputtag INTO compiling AT END;
      }
      any_not_done := TRUE;
    }

    IF (NOT any_not_done)
      BREAK;

    WaitForPromise(condition->WaitSignalled());
    condition->signalled := FALSE;
  }

  IF(NOT args.quiet)
    Print("\nStatus of recompiled bundles:\n");
  ListBundles(masks, FALSE);

  IF (LENGTH(bundles) = 1 AND bundles[0].haserrors)
      PrintBundleErrors(bundles[0].outputtag);

  IF(RecordExists(SELECT FROM bundles WHERE haserrors))
    SetConsoleExitCode(1);
}

SWITCH (args.command)
{
  CASE "list"
  {
    RECORD subargs := ParseArguments(args.params,
                                  [ [ name := "withwatchcounts", type := "switch" ]
                                  , [ name := "watch", type := "switch" ]
                                  , [ name := "masks", type := "paramlist" ]
                                  ]);
    IF (NOT RecordExists(subargs))
      Syntax();

    IF (NOT subargs.watch)
    {
      ListBundles(subargs.masks, subargs.withwatchcounts);
    }
    ELSE
    {
      // Need ansi to be enabled in watch mode
      SetAnsiCmdMode("enabled");

      OBJECT condition := NEW ManualCondition;
      RegisterEventCallback("publisher:assetpackcontrol.change.*", PTR SetSignalledUponEvent(condition, #1, #2));

      WHILE (TRUE)
      {
        PRINT(AnsiCmd("erasedisplay,pos:0:0") || "Watching assetpacks, last update: " || FormatISO8601DateTime(GetCurrentDateTime()) || "\n\n");
        ListBundles(subargs.masks, subargs.withwatchcounts);

        WaitForPromise(condition->WaitSignalled());
        condition->signalled := FALSE;
      }
    }
  }
  CASE "recompile"
  {
    RECORD subargs := ParseArguments(args.params,
                                  [ [ name := "onlyfailed", type := "switch" ]
                                  , [ name := "masks", type := "paramlist", required := TRUE ]
                                  ]);
    IF (NOT RecordExists(subargs))
      Syntax();

    DoRecompile(subargs.masks, subargs.onlyfailed);
  }
  CASE "info"
  {
    RECORD subargs := ParseArguments(args.params,
                                  [ [ name := "masks", type := "paramlist", required := TRUE ]
                                  ]);
    IF (NOT RecordExists(subargs))
      Syntax();

    FOREVERY (RECORD bundle FROM GetBundles(subargs.masks))
    {
      RECORD data := WaitForPromise(assetpackcontrol->GetBundleStatus(bundle.outputtag));

      PRINT(bundle.outputtag || "\n");
      PRINT(" Status: " || GetBundleStatusString(bundle) || "\n");
      PRINT(" Compiler: " || (bundle.iscompiling ? AnsiCmd("bold,yellow") || "compiling" || AnsiCmd("reset") : bundle.requirecompile ? "scheduled" : "idle") || "\n");
      IF(TYPEID(bundle.lastcompile) = TYPEID(DATETIME))
        PRINT(" Last compile: " || FormatISO8601DateTime(bundle.lastcompile) || "\n");

      PrintBundleErrors(bundle.outputtag);
      Print("\n");
    }
  }
  CASE "check", "wait"
  {
    RECORD subargs := ParseArguments(args.params,
                                  [ [ name := "masks", type := "paramlist" ]
                                  ]);

    IF (NOT RecordExists(subargs))
      Syntax();

    BOOLEAN iswait := args.command = "wait";
    BOOLEAN success := WaitForCompilation(subargs.masks, iswait OR IsConsoleATerminal());

    IF(NOT iswait)
    {
      FOREVERY(RECORD uncompiled FROM SELECT * FROM GetBundles(subargs.masks) WHERE iscompiling OR haserrors)
        PrintBundleErrors(uncompiled.outputtag);
    }

    IF(NOT success)
      SetConsoleExitCode(1);
  }
  CASE "autocompile"
  {
    OBJECT trans := OpenPrimary();
    RECORD subargs := ParseArguments(args.params,
                                  [ [ name := "state", type := "param" ]
                                  ]);
    IF (NOT RecordExists(subargs))
      Syntax();

    IF (subargs.state = "")
    {
      PRINT(`Production assetpacks autocompilation is ${ReadRegistryKey("publisher.bundledassets.suspendautocompile") ? "off" : "on"}\n`);
    }
    ELSE
    {
      BOOLEAN newsuspend;
      IF (subargs.state IN [ "0", "off", "disabled" ])
        newsuspend := TRUE;
      ELSE IF (subargs.state NOT IN [ "1", "on", "enabled" ])
        Syntax(`Allowed autocompilation values: on/off\n`);

      trans->BeginWork();
      WriteRegistryKey("publisher.bundledassets.suspendautocompile", newsuspend);
      trans->CommitWork();
      WaitForPromise(assetpackcontrol->Reload());
    }
  }
}
