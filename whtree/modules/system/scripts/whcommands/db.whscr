<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::dbase/postgresql.whlib";
LOADLIB "wh::dbase/whdb.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/dbase/base.whlib";
LOADLIB "mod::system/lib/internal/dbase/postgresql.whlib";


// command: database <command>
// short: database control


MACRO ShowSyntax(STRING error)
{
  PRINT(`Error: ${error}\n`);
  PRINT("Syntax: wh db <command>\n");
  PRINT("Commands:\n");
  PRINT("  locks                      List contended locks\n");
  PRINT("  sequences [ --reset ]      List/reset sequences\n");
  PRINT("  setserver                  Get/set read-write status (readwrite / readonly)\n");
  PRINT("  transactions [ --allinfo ] Show transaction list\n");
  TerminateScriptWithError("");
}

RECORD args := ParseArguments(GetConsoleArguments(),
    [ [ name := "command", type := "param", required := TRUE ]
    , [ name := "args", type := "paramlist" ]
    ]);

IF (NOT RecordExists(args))
  ShowSyntax("Illegal syntax");

OBJECT trans := OpenPrimary();

SWITCH (args.command)
{
  CASE "transactions"
  {
    RECORD subargs := ParseArguments(args.args,
        [ [ name := "allinfo", type := "switch" ]
        ]);

    IF (NOT RecordExists(subargs))
      ShowSyntax(`Illegal syntax for command '${args.command}'`);
    args := CELL[ ...args, ...subargs ];

    IF (GetDatabaseType() = "whdb")
    {
      trans->BeginWork();
      PRINT(AnyToString(__SendWHDBCommand(trans->id,'show transactions'),'boxed'));
      RETURN;
    }

    RECORD ARRAY transactions := trans->__ExecSQL("select * FROM pg_stat_activity");
    IF (args.allinfo)
      PRINT(AnyToString(transactions, "tree"));
    ELSE
    {
      PRINT(AnyToString(
         (SELECT pid
               , application_name
               , backend_start
               , state
           FROM transactions
          WHERE backend_type = "client backend"
       ORDER BY backend_start), "boxed"));
    }
    PRINT(`Total: ${LENGTH(transactions)} connections\n`);
  }
  CASE "locks"
  {
    RECORD subargs := ParseArguments(args.args, RECORD
        [
        ]);

    IF (NOT RecordExists(subargs))
      ShowSyntax(`Illegal syntax for command '${args.command}'`);
    args := CELL[ ...args, ...subargs ];

    IF (GetDatabaseType() = "whdb")
    {
      PRINT(`Not supported for database type whdb\n`);
      RETURN;
    }

    RECORD monitorinfo := GetDatabaseMonitorInfo(GetPrimary());
    FOREVERY (RECORD owner FROM monitorinfo.blockinglocks)
    {
      PRINT(`Owner: ${owner.application_name}\n`);
      PRINT(` Transaction start: ${FormatISO8601DateTime(owner.xact_start, "", "milliseconds", "CET")}\n`);
      PRINT(` Query start: ${FormatISO8601DateTime(owner.query_start, "", "milliseconds", "CET")}\n`);
      PRINT(` PostgreSQL backend pid: ${owner.pid}\n`);
      IF (owner.debuginfohint != "")
        PRINT(` Debug info: ` || Substitute(owner.debuginfohint, "\n", "\n" || RepeatText(" ", 13)) || "\n");
      FOREVERY (RECORD waiter FROM owner.waiters)
      {
        PRINT(`  Waiter: ${waiter.application_name}\n`);
        PRINT(`   Transaction start: ${FormatISO8601DateTime(waiter.xact_start, "", "milliseconds", "CET")}\n`);
        PRINT(`   Query start: ${FormatISO8601DateTime(waiter.query_start, "", "milliseconds", "CET")}\n`);
        PRINT(`   PostgreSQL backend pid: ${waiter.pid}\n`);
        IF (waiter.tables != "")
          PRINT(`    Locking row in table ${waiter.tables}\n`);
        IF (waiter.debuginfohint != "")
          PRINT(`   Debug info: ` || Substitute(owner.debuginfohint, "\n", "\n" || RepeatText(" ", 15)) || "\n");
      }
    }
  }

  CASE "setserver"
  {
    RECORD subargs := ParseArguments(args.args,
        [ [ name := "newvalue", type := "param" ]
        ]);

    IF (NOT RecordExists(subargs))
      ShowSyntax(`Illegal syntax for command '${args.command}'`);
    args := CELL[ ...args, ...subargs ];

    IF (args.newvalue NOT IN [ "", "readonly", "readwrite" ])
      TerminateScriptWithError("Invalid new value, expected one of 'readonly'/'readwrite'");

    IF (args.newvalue != "")
    {
      STRING envsettings := BlobToString(GetDiskResource(MergePath(GetWebhareConfiguration().varroot, ".webhare-envsettings.sh"), [ allowmissing := TRUE ]));
      IF (envsettings LIKE `* WEBHARE_DBASE_READONLY=*` AND envsettings NOT LIKE `* WEBHARE_DBASE_READONLY=""\n`)
        TerminateScriptWithError("The database readonly settings are set globally by 'wh console' and cannot be changed.");

      IF (GetEnvironmentVariable("WEBHARE_DBASE_READONLY") != "")
        Print("Warning: The WEBHARE_DBASE_READONLY environment variable is currently set, the configuration change will only have effect on processes that don't have it set.\n");

      SWITCH (args.newvalue)
      {
        CASE "readonly"
        {
          RECORD dbaseconfig := GetDatabaseRuntimeConfig();
          UpdateSystemConfigurationRecord(CELL[ database := CELL[ ...dbaseconfig, readonly := TRUE ] ]);
          ReloadWebhareConfig2("ALL");
        }
        CASE "readwrite"
        {
          RECORD dbaseconfig := GetDatabaseRuntimeConfig();
          UpdateSystemConfigurationRecord(CELL[ database := CELL[ ...dbaseconfig, readonly := FALSE ] ]);
          ReloadWebhareConfig2("ALL");
        }
      }
    }

    PRINT(`Current database status: ${IsDatabaseWritable() ? "readwrite" : "readonly"}\n`);
  }

  CASE "sequences"
  {
    RECORD subargs := ParseArguments(args.args,
        [ [ name := "reset", type := "switch" ]
        ]);

    IF (NOT RecordExists(subargs))
      ShowSyntax(`Illegal syntax for command '${args.command}'`);
    args := CELL[ ...args, ...subargs ];

    IF (GetDatabaseType() = "whdb")
    {
      PRINT(`Not supported for database type whdb\n`);
      RETURN;
    }

    RECORD ARRAY sequences :=
        SELECT TEMPORARY seqdata := RECORD(GetPrimary()->__ExecSQL(`SELECT * FROM ${PostgreSQLEscapeIdentifier(n.nspname)}.${PostgreSQLEscapeIdentifier(c.relname)}`))
             , fullname :=      `${PostgreSQLEscapeIdentifier(n.nspname)}.${PostgreSQLEscapeIdentifier(c.relname)}`
             , last_value :=    seqdata.last_value
             , is_called :=     seqdata.is_called
          FROM postgresql_pg_catalog.pg_sequence AS s
             , postgresql_pg_catalog.pg_class AS c
             , postgresql_pg_catalog.pg_namespace AS n
         WHERE c.relkind = 'S'
           AND n.oid = c.relnamespace
           AND s.seqrelid = c.oid
      ORDER BY `${n.nspname}.${c.relname}`;

    IF (args.reset)
    {
      trans->BeginWork();
      FOREVERY (RECORD s FROM sequences)
        GetPrimary()->__ExecSQL(`ALTER SEQUENCE ${s.fullname} RESTART`);
      trans->CommitWork();
      PRINT(`All sequences have been reset to their start values\n`);
    }
    ELSE
      DumpValue(sequences, "boxed");
  }

  DEFAULT
  {
    ShowSyntax(`Unknown command '${args.command}'`);
  }
}
