<?wh
// syntax: <logfile>
// short: (RPC) log reader

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/configure.whlib";
//LOADLIB "mod::system/lib/internal/logging/noticelog.whlib";
LOADLIB "mod::system/lib/internal/logging/whlogreaders.whlib";


STRING FUNCTION EncodeSingleQuoted(STRING input)
{
  input := Substitute(input,"\\","\\\\");
  input := Substitute(input,"'","\\'");
  RETURN input;
}

STRING FUNCTION FindLogFile(STRING logfilepath)
{
  STRING absolutepath := MergePath(GetCurrentPath(), logfilepath);
  IF(RecordExists(GetDiskFileProperties(absolutepath)))
    RETURN absolutepath;

  IF(logfilepath NOT LIKE "*/*") //no path info
  {
    //Try to discover the intended file
    STRING trylogfile := MergePath(GetWebHareConfiguration().logroot, logfilepath);
    IF(RecordExists(GetDiskFileProperties(trylogfile)))
      RETURN trylogfile;

    // Missing .log?
    IF (logfilepath NOT LIKE "*.log")
      logfilepath := logfilepath || ".log";

    trylogfile := MergePath(GetWebHareConfiguration().logroot, logfilepath);
    IF(RecordExists(GetDiskFileProperties(trylogfile)))
      RETURN trylogfile;

    //Is it of the form "*.log" ?
    IF(logfilepath LIKE "*.log")
    {
      //Search the most recent datetime logged file
      STRING searchpath := Substitute(logfilepath, ".log",".*.log");
      RECORD ARRAY logfiles := SELECT name, nametoks := Tokenize(name,'.') FROM ReadDiskDirectory(GetWebHareConfiguration().logroot, searchpath);
      RECORD mostrecent := SELECT * FROM logfiles ORDER BY nametoks[Length(nametoks)-2] DESC;
      IF(RecordExists(mostrecent))
        RETURN MergePath(GetWebHareConfiguration().logroot, mostrecent.name);
    }
  }
  RETURN "";
}

STRING FUNCTION GuessLogfileFormat(STRING inline)
{
  STRING ARRAY datatoks := Tokenize(inline,"\t");

  //RPC format - \t separated. 0:timestamp source   1: srhid  2: sourcetracker  3: >|< transport  4: transactionid (currently assume UFSids) 5: rawdata
  IF(Length(datatoks) = 6 AND Left(datatoks[3],1) IN ["<",">"] AND Left(datatoks[5],6)="hson:{")
    RETURN "rpc";
  IF(Length(datatoks) = 7 AND Left(datatoks[4],1) IN ["<",">"] AND Left(datatoks[6],6)="hson:{")
    RETURN "rpc";

  RETURN "";
}

RECORD FUNCTION DecodeHTTPLogLine(RECORD inline)
{
  IF(inline.transport NOT LIKE "* *")
    RETURN DEFAULT RECORD;

  //parses the rawdata and transport associated with a http request
  INSERT CELL method := Left(inline.transport, SearchSubstring(inline.transport," ")) INTO inline;
  INSERT CELL url    := Substring(inline.transport, Length(inline.method) + 1) INTO inline;
  inline := MakeMergedRecord(inline, inline.rawdata);

  RETURN inline;
}

STRING FUNCTION ParseContextInfo(RECORD data)
{
  IF (NOT CellExists(data, "SOURCE"))
    RETURN "raw: " || EncodeJSON(data);
  SWITCH (data.source)
  {
    CASE "publisher:publishing" { RETURN `Publishing file #${data.id}`; }
    CASE "tollium:app"          { RETURN `Tollium-app: ${data.app}, wrduser: ${data.user_wrdid}, language: ${data.language}`; }
    DEFAULT                     { RETURN `${data.source}: ${EncodeHSON(CellDelete(data, "SOURCE"))}`; }
  }
}

STRING FUNCTION FormatJavascriptErrorCause(RECORD error)
{
  STRING retval;
  IF (CellExists(error, "CAUSE") AND RecordExists(error.cause))
  {
    retval := `Cause: ${error.cause.error}\n`;
    FOREVERY (RECORD t FROM error.cause.trace)
    {
      STRING func := CellExists(t, "FUNCTION") AND t."function" != "" ? t."function" : CellExists(t, "FUNC") ? t.func : "";
      retval := retval || "At " || t.filename || "(" || (CellExists(t, "LINE") ? t.line : 1) || "," || (CellExists(t, "COL") ? t.col : CellExists(t, "COLUMN") ? t."column" : 1) || ")" || (func = "" ? "" : " (" || func || ")") || "\n";
    }
    retval := retval || FormatJavascriptErrorCause(error.cause);
  }
  RETURN retval;
}

RECORD info := ParseArguments(GetConsoleArguments(),
                              [ [ name := "format", type := "stringopt" ]
                              , [ name := "output", type := "stringopt" ]
                              , [ name := "d", type := "switch" ]
                              , [ name := "f", type := "switch" ]
                              , [ name := "x", type := "switch" ]
                              , [ name := "n", type := "stringopt" ]
                              , [ name := "s", type := "stringlist" ]
                              , [ name := "g", type := "stringlist" ]
                              , [ name := "logfile", type := "param" ]
                              ]);

IF(NOT RecordExists(info))
{
  Print("Syntax: logreader.whscr [ -d ] [ -f ] [ -n lines ] [ -s sourcemask ]* <logfile>\n");
  Print("Valid lognames: rpc, debug, notice\n");
  Print("Switches:\n");
  Print("  -d        Show debug info\n");
  Print("  -f        Output new data as file grows\n");
  Print("  -n lines  Show the last <lines> lines (defaults to all lines, or last 5 when -f is present)\n");
  Print("  -x        Reformat HTTP body (rpc log only)\n");
  Print("  -s mask   Show only those RPC's whose source match these masks (rpc log only)\n");
  Print("  -g groupmask Show only the lines for these group ids\n");
  Print("\n");
  SetConsoleExitCode(1);
  RETURN;
}

INTEGER logfile;
STRING logfilepath;

INTEGER lastlinescount := ToInteger(info.n, -1);
IF (info.f AND lastlinescount = -1)
  lastlinescount := 5;

IF (info.logfile != "")
{
  logfilepath := FindLogFile(info.logfile);
  IF(logfilepath="")
    ABORT("Unable to find log file: " || info.logfile);

  IF (info.d)
    PRINT("Opened file: " || logfilepath || "\n");

  logfile := OpenDiskFile(logfilepath, FALSE);
  IF(logfile <= 0)
    ABORT("Unable to open file: " || logfilepath);
}

STRING firstline := ReadLineFrom(logfile, 16384, FALSE);
//detect gzip data
IF(Left(firstline,2) = "\x1F\x8B") //it's a gzip compressed file
{
  IF (logfile = 0)
    ABORT("Cannot decompress from stdin");


  CloseDiskFile(logfile); //it better be a blob

  IF(NOT IsPathAbsolute(logfilepath))
    logfilepath := MergePath(GetCurrentPath(), logfilepath);

  logfile := OpenBlobAsDecompressingStream(GetDiskResource(logfilepath), "GZIP");
  IF(logfile<=0)
    ABORT("Unable to decompress file: " || logfilepath);
  firstline := ReadLineFrom(logfile, 16384, FALSE);
}

IF(info.format="")
  info.format := GuessLogfileFormat(firstline);
IF (info.format = "" AND logfilepath LIKE "*debug.*")
  info.format := "debug";
IF (info.format = "" AND logfilepath LIKE "*notice.*")
  info.format := "notice";
IF (info.format = "" AND logfilepath LIKE "*audit.*")
  info.format := "audit";

IF(info.format NOT IN ["rpc", "debug", "notice", "audit"])
  ABORT("Unrecognized logformat '" || info.format || "'. Please use --format with eg 'rpc'");

FOREVERY (STRING g FROM info.g)
  IF (SearchSubstring(g, "*") = -1)
    info.g[#g] := `${g}*`;

OBJECT linereader;
SWITCH (info.format)
{
  CASE "rpc"      { linereader := NEW RPCLogReader; }
  CASE "debug"    { linereader := NEW DebugLogReader; }
  CASE "notice"   { linereader := NEW NoticeLogReader; }
  CASE "audit"    { linereader := NEW AuditLogReader; }
}
linereader->AddData(firstline); //throw in the line we already had

STRING ARRAY lastlines := [ "" ];
BOOLEAN cache := lastlinescount != -1;
BOOLEAN filtersources := LENGTH(info.s) != 0;
BOOLEAN filtergroups := LENGTH(info.g) != 0;
BOOLEAN lastmultiline := FALSE;

WHILE(TRUE)
{
  WHILE(TRUE)
  {
    RECORD line := linereader->ReadLine();
    IF(NOT RecordExists(line))
      BREAK;

    SWITCH (info.format)
    {
      CASE "rpc"
      {
        RECORD httpline := DecodeHTTPLogLine(line);
        IF(NOT RecordExists(httpline))
          CONTINUE;

        // Apply filters immediately after parsing
        IF (filtersources)
        {
          BOOLEAN have_match;
          FOREVERY (STRING mask FROM info.s)
            have_match := have_match OR httpline.source LIKE mask;
          IF (NOT have_match)
          {
            IF (info.d)
              PRINT("Ignored line from source " || httpline.source || "\n");

            lastlines[END-1] := "";
            CONTINUE;
          }
        }

        // Also add body to current line data
        IF(CellExists(httpline,'body'))
        {
          IF (info.x)
          {
            STRING contenttype := CellExists(httpline,'headers') ? SELECT AS STRING value FROM httpline.headers WHERE ToUppercase(field) = "CONTENT-TYPE" : "";
            IF(contenttype LIKE "text/xml*")
            {
              STRING encoding := contenttype LIKE "*charset=*" ? Tokenize(contenttype, "charset=")[1] : "";
              OBJECT doc := MakeXMLDocument(httpline.body, encoding);
              IF (ObjectExists(doc))
                httpline.body := doc->GetDocumentBlob(TRUE);
            }
            ELSE IF(contenttype LIKE "application/json*")
            {
              httpline.body := StringToBlob(AnyToString(DecodeJSONBlob(httpline.body), "tree"));
            }
          }
        }

        IF (NOT info.d)
        {
          DELETE CELL raw FROM httpline;
          DELETE CELL rawdata FROM httpline;
        }

        IF(info.output = "curl")
        {
          lastlines[END-1] := `curl '${EncodeSingleQuoted(httpline.url)}' `;

          FOREVERY(RECORD header FROM httpline.headers)
            IF(ToUppercase(header.field) NOT IN ["CONTENT-LENGTH","HOST","TRANSFER-ENCODING"])
              lastlines[END-1] := lastlines[END-1] || ` -H '${header.field}: ${EncodeSingleQuoted(header.value)}'`;

          //FIXME what if data is unreadable?
          IF(Length(httpline.body) > 0)
            lastlines[END-1] := lastlines[END-1] || ` --data-binary '${EncodeSingleQuoted(BlobToString(httpline.body))}'`;
          lastlines[END-1] := lastlines[END-1] || "\n";
        }
        ELSE
        {
          // Add http line to the current line data
          lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q] ", httpline.when) || httpline.source || " " || (httpline.incoming ? ">in " : "<out ") ||httpline.transport || "\n";
          lastlines[END-1] := lastlines[END-1] || AnyToString(httpline,'tree');
          IF(CellExists(httpline,'body'))
          {
            lastlines[END-1] := lastlines[END-1] || BlobToString(httpline.body, -1);
            IF (lastlines[END-1] NOT LIKE "*\n")
              lastlines[END-1] := lastlines[END-1] || "\n";
          }
        }
      }
      CASE "debug"
      {
        lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q]", line."@timestamp") || " " || line.groupid || " " || line.source || " " || (CellExists(line, "data") ? EncodeJSON(line.data) : CellExists(line, "overflow") ? `<Line too long: ${line.overflow} bytes>` : "") || "\n";

        IF (filtersources)
        {
          BOOLEAN have_match;
          FOREVERY (STRING mask FROM info.s)
            have_match := have_match OR line.source LIKE mask;
          IF (NOT have_match)
          {
            IF (info.d)
              PRINT("Ignored line from source " || line.source || "\n");

            lastlines[END-1] := "";
            CONTINUE;
          }
        }
        IF (filtergroups)
        {
          BOOLEAN have_match;
          FOREVERY (STRING mask FROM info.g)
            have_match := have_match OR line.groupid LIKE mask;
          IF (NOT have_match)
          {
            IF (info.d)
              PRINT("Ignored line from source " || line.source || "\n");

            lastlines[END-1] := "";
            CONTINUE;
          }
        }
      }
      CASE "notice"
      {
        lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q]", line."@timestamp") || " " || line.groupid || " " || line.source || " " || line.type || "\n";
        //lastlines[END-1] := lastlines[END-1] || AnyToString(line.message, "tree");
        IF (line.script != "")
          lastlines[END-1] := lastlines[END-1] || "Script: " || line.script || "\n";
        IF (RecordExists(line.contextinfo))
        {
          STRING parsed := ParseContextInfo(line.contextinfo);
          IF (parsed != "")
            lastlines[END-1] := lastlines[END-1] || "Context: " || parsed || "\n";
        }

        FOREVERY (RECORD t FROM line.errors)
        {
          lastlines[END-1] := lastlines[END-1] || "Error: " || t.message || "\n";
          IF (LENGTH(line.trace) = 0)
          {
            STRING file := CellExists(t, "FILENAME") ? t.filename : CellExists(t, "FILE") ? t.file : "";
            INTEGER linenum := CellExists(t, "LINENUM") ? t.linenum : CellExists(t, "LINE") ? t.line : 1;
            INTEGER col := CellExists(t, "COLNUM") ? t.colnum : CellExists(t, "COL") ? t.col : CellExists(t, "COLUMN") ? t."column" : 1;
            STRING func := CellExists(t, "FUNCTIONNAME") AND t."FUNCTIONNAME" != "" ? t."FUNCTIONNAME" : CellExists(t, "FUNC") ? t.func : "";
            lastlines[END-1] := lastlines[END-1] || "At " || file || "(" || linenum || "," || col || ")" || (func = "" ? "" : " (" || func || ")") || "\n";
          }
        }

        IF (RecordExists(line.browser) AND line.browser.location != "")
          lastlines[END-1] := lastlines[END-1] || "URL: " || line.browser.location || "\n";
        ELSE IF (line.location != "")
          lastlines[END-1] := lastlines[END-1] || "URL: " || line.location || "\n";

        FOREVERY (RECORD t FROM line.trace)
        {
          STRING func := CellExists(t, "FUNCTIONNAME") AND t."FUNCTIONNAME" != "" ? t."FUNCTIONNAME" : CellExists(t, "FUNC") ? t.func : "";
          lastlines[END-1] := lastlines[END-1] || "At " || t.filename || "(" || (CellExists(t, "LINE") ? t.line : 1) || "," || (CellExists(t, "COL") ? t.col : CellExists(t, "COLUMN") ? t."column" : 1) || ")" || (func = "" ? "" : " (" || func || ")") || "\n";
        }

        IF (line.testscript != "")
          lastlines[END-1] := lastlines[END-1] || "Test script: " || line.testscript || "\n";

        IF (line.type NOT IN [ "script-error", "script-unhandledrejection", "siteprofilecompilation-error" ] AND RecordExists(line.data))
          lastlines[END-1] := lastlines[END-1] || "log entry type: " || line.type || "\n" || EncodeJSON(line.data) || "\n";
      }
      CASE "audit"
      {
        IF(CellExists(line, "@timestamp"))
        {
          lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q]", MakeDateFromText(line."@timestamp")) || ` ${line.groupid} ${line.source}\n  > ` ||
              Substitute(TrimWhitespace(AnyToString(line, "tree")), "\n", "\n  > ") || "\n";
        }
        ELSE IF (CellExists(line,'v') AND line.v = 1)
        {
          lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q]", line.when) || ` ${line.srhid} ${line.source} login:${line.login} ${line.auth}\n  > ` ||
              Substitute(TrimWhitespace(AnyToString(line.message, "tree")), "\n", "\n  > ") || "\n";
        }
        ELSE
        {
          lastlines[END-1] := lastlines[END-1] || FormatDateTime("[%H:%M:%S.%Q]", line.when) || ` ${line.srhid} ${line.source}\n  > ` ||
              Substitute(TrimWhitespace(AnyToString(line.auditcontext, "tree")), "\n", "\n  > ") || "\n  > " ||
              Substitute(TrimWhitespace(AnyToString(line.message, "tree")), "\n", "\n  > ") || "\n";
        }

        IF (filtersources)
        {
          BOOLEAN have_match;
          FOREVERY (STRING mask FROM info.s)
            have_match := have_match OR line.source LIKE mask;
          IF (NOT have_match)
          {
            IF (info.d)
              PRINT("Ignored line from source " || line.source || "\n");

            lastlines[END-1] := "";
            CONTINUE;
          }
        }
      }
    }

    // When caching (used when -n is in effect) initialize a new rpc, throw away first item when cache overflows
    IF (cache)
    {
      IF (LENGTH(lastlines) > lastlinescount)
        DELETE FROM lastlines AT 0;
      INSERT "" INTO lastlines AT END;
    }
    ELSE // not caching - print all mode
    {
      FOREVERY (STRING s FROM lastlines)
      {
        BOOLEAN nowmultiline := s LIKE "*\n*?";
        IF (lastmultiline OR nowmultiline)
          PRINT("\n");
        PRINT(s);
        lastmultiline := nowmultiline;
      }
      lastlines := [ "" ];
    }
  }

  STRING data := ReadLineFrom(logfile, 16384, FALSE);
  IF(data="") //eof!
  {
    // No more data - reached the end of the file. If still caching, this is the time to print the cache
    FOREVERY (STRING s FROM lastlines)
      IF (s != "")
      {
        BOOLEAN nowmultiline := s LIKE "*\n*?";
        IF (lastmultiline OR nowmultiline)
          PRINT("\n");
        PRINT(s);
        lastmultiline := nowmultiline;
      }
    lastlines := [ "" ];
    cache := FALSE;


    // Not in 'follow' mode? We're done
    IF (NOT info.f)
      BREAK;


    // Check every 250 ms for new data from the log file
    WHILE (data = "")
    {
      Sleep(250);
      data := ReadLineFrom(logfile, 16384, FALSE);
    }
  }

  // Add data to the current line data
  //lastlines[END-1] := lastlines[END-1] || '['||data||']\n';

  linereader->AddData(data);
}
