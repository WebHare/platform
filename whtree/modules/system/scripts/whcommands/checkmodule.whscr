<?wh

LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

RECORD args := ParseArguments(GetConsoleArguments(),
                              [ [ name := "debug", type := "switch" ]
                              , [ name := "silent", type := "switch" ]
                              , [ name := "nowarnings", type := "switch" ]
                              , [ name := "nochecktypescript", type := "switch" ]
                              , [ name := "hidehints", type := "switch" ]
                              , [ name := "color", type := "switch" ]
                              , [ name := "onlytids", type := "switch" ]
                              , [ name := "sync", type := "switch" ]
                              , [ name := "async", type := "switch" ]
                              , [ name := "filemask", type := "stringopt" ]
                              , [ name := "onlypaths", type := "stringopt" ]
                              , [ name := "modules", type := "paramlist", required := TRUE ]
                              ]);

INTEGER numerrors, numwarnings, numhints;

IF(NOT RecordExists(args))
{
  Print("Syntax: wh checkmodule [ platform / <modulename mask...> ] \n");
  TerminateScriptWithError("Invalid syntax");
}
SetupFunctionProfiling("checkmodule", Detokenize(args.modules,','));

IF (args.color)
  SetAnsiCmdMode("enabled");

STRING ARRAY onlypaths;
IF (args.onlypaths != "")
{
  BLOB filecontents;
  IF (args.onlypaths = "-")
    filecontents := GetSTDINAsBlob();
  ELSE
    filecontents := GetDiskResource(args.onlypaths);
  FOREVERY (STRING path FROM Tokenize(BlobToString(filecontents), "\n"))
  {
    path := TrimWhitespace(path);
    IF (path = "" OR path LIKE "#*")
      CONTINUE;
    INSERT path INTO onlypaths AT END;
  }
}

STRING ARRAY checklist;
IF(Length(args.modules) = 0)
{
  STRING currentpath := GetCurrentPath() || "/";
  FOREVERY(STRING mod FROM __SYSTEM_GetInstalledModuleNames())
  {
    STRING root := GetModuleInstallationRoot(mod);
    IF (currentpath LIKE root || "*")
      INSERT mod INTO checklist AT END;
  }
  IF (currentpath LIKE GetWebhareConfiguration().installationroot || "jssdk/*")
    INSERT "jssdk" INTO checklist AT END;

  IF (LENGTH(checklist) = 0)
  {
    PRINT(`Could not find the installed module from the current path\n`);
    SetConsoleExitCode(1);
  }
}
ELSE
{
  FOREVERY(STRING module FROM args.modules)
    FOREVERY(STRING mask FROM module = "platform" ? whconstant_builtinmodules CONCAT [ "jssdk" ]: [module])
  {
    BOOLEAN have_match;
    FOREVERY(STRING mod FROM __SYSTEM_GetInstalledModuleNames() CONCAT [ "jssdk" ])
      IF(mod NOT IN checklist AND ToUppercase(mod) LIKE ToUppercase(mask))
      {
        have_match := TRUE;
        INSERT mod INTO checklist AT END;
      }
    IF (NOT have_match)
    {
      numerrors := numerrors + 1;
      PRINT(`No module matches the mask '${mask}'\n`);
    }
  }
}

OBJECT ARRAY promises;
BOOLEAN core_typescript_checked;
FOREVERY(STRING modname FROM checklist)
{
  BOOLEAN checktypescript := TRUE;
  IF (modname IN whconstant_builtinmodules OR modname = "jssdk")
  {
    /* Only check typescript for the first of the core modules, typescript check of a core
       module will check all core modules at once
    */
    checktypescript := NOT core_typescript_checked;
    core_typescript_checked := TRUE;
  }

  IF (NOT args.silent)
    Print(`Checking module ${modname}...${args.nowarnings ? " (no warnings)" : ""}${args.hidehints ? " (hide hints)" : ""}${args.nochecktypescript ? " (no typescript checking)" : ""}${args.onlytids ? " (only tids)":""}\n`);
  OBJECT promise := AsyncCallFunctionFromJob(
              "mod::system/lib/internal/modules/checkmodule.whlib#CheckModule",
              modname, CELL
              [ printissues := TRUE
              , args.debug
              , args.onlytids
              , args.filemask
              , args.color
              , args.nowarnings
              , checktypescript := checktypescript AND NOT args.nochecktypescript
              , args.hidehints
              , onlypaths
              ]);
  INSERT promise INTO promises AT END;

  IF (args."sync")
  {
    WaitForPromise(promise);
    Print("\n");
  }
}

RECORD ARRAY allissues;
FOREVERY (OBJECT p FROM promises)
{
  RECORD ARRAY issues := WaitForPromise(p);
  numwarnings := numwarnings + Length(SELECT FROM issues WHERE category = "warning");
  numerrors := numerrors + Length(SELECT FROM issues WHERE category = "error");
  numhints := numhints + Length(SELECT FROM issues WHERE category = "hint");
  allissues := allissues CONCAT issues;
}

IF(numerrors>0)
{
  Print(`${AnsiCmd("red")}Checkmodule done: ${numerrors} errors, ${numwarnings} warnings, ${numhints} hints${AnsiCmd("reset")}\n`);
  SetConsoleExitCode(1);

  //ADDME types for error messages might make this a bit more robust
  RECORD ARRAY langedits := SELECT module := Tokenize(Tokenize(":" || message,":")[END-2],"'")[END-1] FROM allissues WHERE category = "error" AND message LIKE "Missing tid *";
  langedits := SELECT module, num := Count(*) FROM langedits GROUP BY module;
  FOREVERY(RECORD openlangedit FROM langedits)
    Print(`To fix ${openlangedit.num} language errors: https://my.webhare.dev/?app=dev:langedit(${openlangedit.module})\n`);
}
ELSE
{
  IF (NOT args.silent)
    Print(`Checkmodule done: ${numwarnings} warnings, ${numhints} hints\n`);
}
