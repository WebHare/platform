import { ModDefYML } from "@webhare/services/src/moduledefparser";
import { backendConfig, getVersionInteger } from "../configuration";
import { getAttr } from "./xmlhelpers";
import { regExpFromWildcards } from "@webhare/std";

const systemservertypes = ["production", "acceptance", "test", "development"];

//Explain the file is autogenerated and just disable eslinting because that just complicates building these files. formatting/linting only matters for files we commit
export const generatorBanner = "/* This file is auto-generated, do not modify but regenerate using `wh update-generated-files`.\n    Use the dev module's browser for examples on how to use these types. */\n\n/* eslint-disable */\n";
export const generatorTypes = ["schema", "config", "extract", "whdb", "wrd", "openapi"] as const;
export type GeneratorType = typeof generatorTypes[number];

export interface FileToUpdate {
  path: string;
  module: string; //'platform' for builtin modules
  type: GeneratorType;
  generator: (options: GenerateContext) => string | Promise<string>;
}

export interface LoadedModuleDefs {
  name: string;
  resourceBase: string;
  modXml: Document | null;
  modYml: ModDefYML | null;
}

export interface GenerateContext {
  verbose: boolean;
  moduledefs: LoadedModuleDefs[];
}

interface WebHareVersionInfo {
  versionnum: number;
  version: string;
  dtapstage: string;
  servername: string;
  modules: string[];
}

export function getMyApplicabilityInfo(): WebHareVersionInfo {
  return { //NOTE: No env variables -- too dangerous as the result of this function is returned to peers.
    versionnum: getVersionInteger(),
    version: backendConfig.buildinfo.version,
    dtapstage: backendConfig.dtapstage,
    servername: backendConfig.servername,
    modules: Object.keys(backendConfig.module)
  };
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars -- will soon be used
function getSemVerFromClassicVersion(oldversion: number) {
  return `${oldversion / 10000}.${oldversion % 10000 / 100}.${oldversion % 100}`;
}

export interface ApplicabilityRestrictions {
  webhareversion: string;
  minservertype: string;
  maxservertype: string;
  restrictservers: string[];
  ifenvironset: string[];
  unlessenvironset: string[];
  ifmodules: string;
}

export function getApplicabilityError(webhareversioninfo: WebHareVersionInfo, restrictions: ApplicabilityRestrictions): string | null {
  /* FIXME restore semver check: if(restrictions.webhareversion && !versionSatisfiesRange(semver, restrictions.webhareversion))
  //Support versioninfo without semantic 'version' for backwards compatibility (eg. peering with old webhares)
  const semver = webhareversioninfo?.version ?? getSemVerFromClassicVersion(webhareversioninfo.versionnum);
    RETURN`WebHare version '${semver}' does not match required version '${restrictions.webhareversion}'`;
    */

  for (let mod of restrictions.ifmodules.split(';')) {
    mod = mod.trim();
    if (mod && !webhareversioninfo.modules.includes(mod))
      return `Module '${mod}' is not installed`;
  }

  if (restrictions.minservertype && systemservertypes.indexOf(restrictions.minservertype) < systemservertypes.indexOf(webhareversioninfo.dtapstage))
    return `Required minimum dtap stage: '${restrictions.minservertype}', current: '${webhareversioninfo.dtapstage}'`;
  if (restrictions.maxservertype && systemservertypes.indexOf(restrictions.maxservertype) > systemservertypes.indexOf(webhareversioninfo.dtapstage))
    return `Required maximum dtap stage: '${restrictions.maxservertype}', current: '${webhareversioninfo.dtapstage}'`;

  for (const testvar of restrictions.ifenvironset) {
    const split = testvar.match(/^([^=]+)(=(.*))?$/);
    if (!split)
      return `Invalid ifenvironset setting`;

    const actualvalue = process.env[split[1]];
    if (actualvalue === undefined)
      return `Required environment variable '${split[1]}' not set`;
    if (split[3] !== undefined && actualvalue !== split[3])
      return `Environment variable '${split[1]}' set to '${process.env[split[1]]}' not '${split[3]}'`;
  }

  for (const testvar of restrictions.unlessenvironset) {
    const split = testvar.match(/^([^=]+)(=(.*))?$/);
    if (!split)
      return `Invalid unlessenvironment setting`;

    const actualvalue = process.env[split[1]];
    if (split[3] !== undefined && actualvalue === split[3])
      return `Environment variable '${split[1]}' matches '${split[3]}'`;
    if (split[3] === undefined && actualvalue !== undefined)
      return `Forbidden environment variable '${split[1]}' set to '${actualvalue}'`;
  }

  if (restrictions.restrictservers.length > 0 && !regExpFromWildcards(restrictions.restrictservers, { caseInsensitive: true }).test(webhareversioninfo.servername))
    return `Restricted to servers: ${restrictions.restrictservers.join(", ")}, current: ${webhareversioninfo.servername}`;

  return null;
}


export function readApplicableToWebHareNode(xmlnode: Element, prefix: string): ApplicabilityRestrictions {
  return {
    webhareversion: getAttr(xmlnode, prefix + "webhareversion"),
    minservertype: getAttr(xmlnode, prefix + "minservertype"),
    maxservertype: getAttr(xmlnode, prefix + "maxservertype"),
    restrictservers: getAttr(xmlnode, prefix + "restrictservers", []),
    ifenvironset: getAttr(xmlnode, prefix + "ifenvironset", []),
    unlessenvironset: getAttr(xmlnode, prefix + "unlessenvironset", []),
    ifmodules: getAttr(xmlnode, prefix + "ifmodules")
  };
}

/** Returns whether a node with version/servertype/installationtype restrictions is applicable to this WebHare installation
    @param xmlnode - XML node to check
    @param prefix - Prefix to add before attribute names. Eg set to 'data-' by <meta> mailer tags
    @returns Whether the node is applicable to this WebHare installation.
*/
export function isNodeApplicableToThisWebHare(xmlnode: Element, prefix: string) {
  return getApplicabilityError(getMyApplicabilityInfo(), readApplicableToWebHareNode(xmlnode, prefix)) === null;
}
