import type { ModDefYML } from "@webhare/services/src/moduledefparser";
import { backendConfig, getVersionInteger } from "../configuration";
import { getAttr } from "./xmlhelpers";
import { regExpFromWildcards } from "@webhare/std";
import type { DtapStage, IfWebHare } from "@mod-platform/generated/schema/moduledefinition";
import { validRange, satisfies } from "semver";
import type { Document, Element } from "@xmldom/xmldom";
import { toFSPath } from "@webhare/services/src/resources";
import { whconstant_builtinmodules } from "../webhareconstants";

//Explain the file is autogenerated and just disable eslinting because that just complicates building these files. formatting/linting only matters for files we commit
export const generatorBanner = "/* This file is auto-generated, do not modify but regenerate using `wh apply config`.\n    Use the dev module's browser for examples on how to use these types. */\n\n/* eslint-disable */\n";
export const generatorTypes = ["config", "extracts", "whfs", "wrd", "openapi", "ts", "db", "schema", "public", "devkit"] as const;
export type GeneratorType = typeof generatorTypes[number];
export { type IfWebHare };

export interface FileToUpdate {
  path: string;
  module: string; //'platform' for builtin modules
  requireDb?: boolean; //requires an online database - skip if --nodb
  type: GeneratorType;
  generator: (options: GenerateContext) => Promise<string>;
}

export interface LoadedModuleDefs {
  name: string;
  resourceBase: string;
  modXml: Document | null;
  modYml: ModDefYML | null;
}

export interface GenerateContext {
  verbose: boolean;
  moduledefs: LoadedModuleDefs[];
  versionInfo: WebHareVersionInfo;
}

interface WebHareVersionInfo {
  versionnum: number;
  version: string;
  dtapstage: DtapStage;
  servername: string;
  modules: string[];
  env: Record<string, string | undefined>;
}

function getEnvironment(unsafeEnv: boolean): Record<string, string> {
  //We should only let WEBHARE_  variables through, other variabels may inadvertedly reveal secrets or other sensitive (configuration) information
  return Object.fromEntries(Object.entries(process.env).filter(([key]) => unsafeEnv || key.startsWith("WEBHARE_")).map(([key, value]) => [key, value ?? '']));
}

export function getMyApplicabilityInfo({ unsafeEnv = false } = {}): WebHareVersionInfo {
  return {
    versionnum: getVersionInteger(),
    version: backendConfig.whVersion,
    dtapstage: backendConfig.dtapstage,
    servername: backendConfig.serverName,
    modules: Object.keys(backendConfig.module),
    env: getEnvironment(unsafeEnv)
  };
}

function getSemVerFromClassicVersion(oldversion: number) {
  return `${Math.floor(oldversion / 10000)}.${Math.floor(oldversion % 10000 / 100)}.${Math.floor(oldversion % 100)}`;
}

export function getApplicabilityError(webhareversioninfo: WebHareVersionInfo, restrictions: IfWebHare): string | null {
  //Support versioninfo without semantic 'version' for backwards compatibility (eg. peering with old webhares)
  const ourSemVer = webhareversioninfo?.version || getSemVerFromClassicVersion(webhareversioninfo.versionnum);
  if (restrictions.whVersion) {
    const cleanrange = validRange(restrictions.whVersion);
    if (!cleanrange)
      return `whVersion specificier '${restrictions.whVersion}' is not a valid semver range`;
    if (!satisfies(ourSemVer, cleanrange))
      return `WebHare version '${ourSemVer}' does not satisfy range: ${cleanrange}`;
  }

  for (const mod of restrictions.ifModules ?? []) {
    if (!webhareversioninfo.modules.includes(mod))
      return `Module '${mod}' is not installed`;
  }
  if (restrictions.dtapStages && !restrictions.dtapStages.includes(webhareversioninfo.dtapstage))
    return `Required one of dtap stage: ${restrictions.dtapStages.join(', ')}, current: ${webhareversioninfo.dtapstage}`;

  for (const testvar of restrictions.envVars ?? []) {
    const split = testvar.match(/^([^=]+)(=(.*))?$/);
    if (!split)
      return `Invalid envVars setting`;

    const actualvalue = webhareversioninfo.env[split[1]];
    if (actualvalue === undefined)
      return `Required environment variable '${split[1]}' not set`;
    if (split[3] !== undefined && actualvalue !== split[3])
      return `Environment variable '${split[1]}' set to '${webhareversioninfo.env[split[1]]}' not '${split[3]}'`;
  }

  if (restrictions.not) {
    for (const testRule of restrictions.not) {
      const noterror = getApplicabilityError(webhareversioninfo, testRule);
      if (!noterror) { //the testrule did not get triggered
        return `Requirement that should not be met is met: ${JSON.stringify(testRule)}`;
      }
    }
  }

  if (restrictions.serverNames && !regExpFromWildcards(restrictions.serverNames, { caseInsensitive: true }).test(webhareversioninfo.servername))
    return `Restricted to servers: ${restrictions.serverNames.join(", ")}, current: ${webhareversioninfo.servername}`;

  return null;
}

export function readApplicableToWebHareNode(xmlnode: Element, prefix: string): IfWebHare {
  const restrictions: IfWebHare = {};

  const webhareversion = getAttr(xmlnode, prefix + "webhareversion");
  if (webhareversion)
    restrictions.whVersion = webhareversion;

  const minservertype = getAttr(xmlnode, prefix + "minservertype") as DtapStage;
  const maxservertype = getAttr(xmlnode, prefix + "maxservertype") as DtapStage;
  if (minservertype || maxservertype) {
    const stages: DtapStage[] = ["development", "test", "acceptance", "production"];
    restrictions.dtapStages = stages.slice(
      stages.indexOf(minservertype || ("development" as DtapStage)),
      stages.indexOf(maxservertype || ("production" as DtapStage)) + 1);
  }

  const restrictservers = getAttr(xmlnode, prefix + "restrictservers", []);
  if (restrictservers.length > 0)
    restrictions.serverNames = restrictservers;

  const ifenvironset = getAttr(xmlnode, prefix + "ifenvironset", []);
  if (ifenvironset.length > 0)
    restrictions.envVars = ifenvironset;

  const unlessenvironset = getAttr(xmlnode, prefix + "unlessenvironset", []);
  if (unlessenvironset.length > 0) {
    /* envVars (ifenvironset) requires *all* vars to match before it evaluates to true
       unlessenvironset should *fail* if *any* of the vars match. so we need to rewrite it to many 'not envSet' checks to get
       the same effect( otherwise it would only fail if *all* unlessEnvironSet vars are set */
    restrictions.not = unlessenvironset.map((envvar) => ({ envVars: [envvar] }));
  }

  const ifmodules = getAttr(xmlnode, prefix + "ifmodules");
  if (ifmodules.length)
    restrictions.ifModules = ifmodules.split(';').map(mod => mod.trim()).filter(Boolean);

  return restrictions;
}

/** Returns whether an ifWebHare node maches this WebHare installation
    @param restrictions - Restrictions to check for
    @param options - Options for checking
    @param options.unsafeEnv - Allow unsafe environment variables to be tested, eg TESTSECRET__. You should only enable this for 'trusted' ifWebHare sources as environment variables may leak information (eg static moduledefinition.ymls are okay, a RPC from a connecting peer server is not)
    @returns Whether the node is applicable to this WebHare installation.
*/
export function matchesThisServer(restrictions: IfWebHare, { unsafeEnv = false } = {}) {
  return getApplicabilityError(getMyApplicabilityInfo({ unsafeEnv }), restrictions) === null;
}

/** Returns whether a node with version/servertype/installationtype restrictions is applicable to this WebHare installation
    @param xmlnode - XML node to check
    @param prefix - Prefix to add before attribute names. Eg set to 'data-' by <meta> mailer tags
    @returns Whether the node is applicable to this WebHare installation.
*/
export function isNodeApplicableToThisWebHare(xmlnode: Element, prefix: string, { unsafeEnv = false } = {}) {
  return getApplicabilityError(getMyApplicabilityInfo({ unsafeEnv }), readApplicableToWebHareNode(xmlnode, prefix)) === null;
}

export function getGeneratedFilePath(module: string, type: string, path: string) {
  if (module === "platform" && type === "schema")
    return toFSPath(`mod::platform/generated/${path}`);
  if (module === "platform" && type !== 'extracts')
    return backendConfig.installationRoot + "modules/platform/generated/" + path;
  return backendConfig.dataRoot + "config/" + path;
}

export function appliesToModule(module: string, moduleList?: string[]) {
  return !moduleList || moduleList.includes(module) || (whconstant_builtinmodules.includes(module) && moduleList.includes("platform"));
}
