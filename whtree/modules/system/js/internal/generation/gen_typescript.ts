/* Generate the JavaScript/TypeScript infrastructure */

import { listDirectory, storeDiskFile } from "@webhare/system-tools";
import { backendConfig } from "../configuration";
import * as path from "node:path";
import { mkdir, readlink, rename, rm, symlink } from "node:fs/promises";
import { whconstant_builtinmodules } from "../webhareconstants";
import { globalPolyfills } from "@webhare/env/src/envbackend";
import { generateRandomId } from "@webhare/std";

type DataRootItem = {
  subPath: string;
  type: "symboliclink";
  target: string;
} | {
  subPath: string;
  type: "directory";
};

function getConfigModulePaths(): DataRootItem[] {
  return Object.entries(backendConfig.module).
    map(([name, settings]) => (
      {
        subPath: name,
        type: "symboliclink",
        target: settings.root
      }));
}

function getDataRootNodeModules(): DataRootItem[] {
  const installationroot = backendConfig.installationRoot;
  const whdataroot = backendConfig.dataRoot;

  const items: DataRootItem[] = Object.entries(backendConfig.module).
    map(([name, settings]) => (
      {
        subPath: `@mod-${name}`,
        type: "symboliclink",
        target: settings.root
      }));

  items.push(
    {
      subPath: "dompack",
      type: "symboliclink",
      target: `${backendConfig.module.system.root}js/dompack`
    },
    {
      subPath: "@types",
      type: "directory",
    },
    {
      subPath: "@types/node",
      type: "symboliclink",
      target: `${installationroot}node_modules/@types/node`
    },
    {
      subPath: "eslint",
      type: "symboliclink",
      target: `${installationroot}node_modules/eslint`
    },
    {
      subPath: "@webhare",
      type: "symboliclink",
      target: `${installationroot}jssdk/`
    },
    {
      subPath: "wh:db",
      type: "symboliclink",
      target: `${whdataroot}config/db`
    },
    {
      subPath: "wh:openapi",
      type: "symboliclink",
      target: `${whdataroot}config/openapi`
    },
    {
      subPath: "wh:schema",
      type: "symboliclink",
      target: `${whdataroot}config/schema`
    },
    {
      subPath: "wh:ts", //misc generated ts files (eg registry.ts)
      type: "symboliclink",
      target: `${whdataroot}config/ts`
    },
    {
      subPath: "wh:wrd",
      type: "symboliclink",
      target: `${whdataroot}config/wrd`
    }
  );
  return items;
}

async function getTSPaths(items: DataRootItem[], startpath: string): Promise<Record<string, string[]>> {
  const result: Record<string, string[]> = {};
  for (const item of items) {
    if (item.type === "symboliclink") {
      if ((await listDirectory(item.target, { allowMissing: true, mask: "index.*" })).length) //permit direct links like @webhare/std to work
        result[`${startpath}${item.subPath}`] = [item.target];
      result[`${startpath}${item.subPath}/*`] = [path.join(item.target, '*')];
    }
  }
  return result;
}

export function getTSPolyfills() {
  return globalPolyfills.map(name => require.resolve(name));
}

async function buildTSConfig(node_modules: DataRootItem[]) {
  const tsconfig = {
    extends: backendConfig.installationRoot + "tsconfig.json",
    compilerOptions: {
      paths: await getTSPaths(node_modules, ""),
      baseUrl: "."
    },
    exclude: [
      "**/vendor/**",
      "**/node_modules/**"
    ],
    include: [
      "**/*",
      //activate the Temporal polyfill in the IDEs
      ...getTSPolyfills()
    ]
  };
  return tsconfig;
}

function formatTSConfig(config: unknown) {
  return `/* This file is generated by WebHare. To regenerate this file run 'wh apply config'.
*/

${JSON.stringify(config, null, 2)}
`;
}

export async function generateTSConfigTextForModule(module: string) {
  if (!backendConfig.module[module])
    throw new Error(`Module '${module}' not found`);

  const datarootitems = getDataRootNodeModules();
  return formatTSConfig(await buildTSConfig(datarootitems));
}

async function syncLinks(basepath: string, want: DataRootItem[], { clean = false, verbose = false } = {}) {
  const contents = (await listDirectory(basepath, { recursive: true })).map(entry => ({ ...entry, matched: false }));

  for (const item of want) {
    const itemPath = basepath + item.subPath;
    const pos = contents.findIndex(entry => entry.subPath === item.subPath);
    if (pos !== -1) {
      const found = contents[pos];
      contents[pos].matched = true;
      if (found.type === item.type && (item.type === "directory" || (await readlink(found.fullPath)) === item.target))
        continue;
      if (found.type === "directory")
        await rm(found.fullPath, { recursive: true, force: true }); //ignore ENOENT races
    }

    //If we get here, either the item (no longer) exists *or* it's a symlink we can just overwrite
    if (item.type === "symboliclink") {
      if (verbose)
        console.log(`Creating symlink ${itemPath} -> ${item.target}`);

      const tempPath = `${itemPath}.${generateRandomId()}.tmp`;
      await symlink(item.target, tempPath); //generate with unique name
      await rename(tempPath, itemPath); //and move atomically into place
    } else {
      await mkdir(itemPath, { recursive: true }); //recursive also prevents an error if the directory was created in parallel
    }
  }

  if (clean) //remove remaining unmatched entries
    for (const rec of contents.filter(_ => !_.matched).sort((a, b) => b.fullPath.length - a.fullPath.length)) { //delete deepest first
      if (verbose)
        console.log(`Removing ${rec.fullPath}`);
      await rm(rec.fullPath, { recursive: rec.type === "directory", force: true }); //ignore any ENOENT races
    }
}


/** Update the symlinks for the rest of the TS/JS system */
export async function updateTypeScriptInfrastructure(options?: { verbose?: boolean; showUnchanged?: boolean; modules?: string[] }) {
  if (options?.verbose)
    console.time("Updating TypeScript infrastructure");

  async function updateFile(filePath: string, text: string) {
    try {
      const { skipped } = await storeDiskFile(filePath, text, { overwrite: true, onlyIfChanged: true });
      if (options?.showUnchanged && skipped)
        console.log(`Keeping file ${filePath}`);
      if (options?.verbose && !skipped)
        console.log(`Updated file ${filePath}`);
    } catch (e) {
      console.error(`Error updating ${filePath}: ${(e as Error)?.message}`);
    }
  }

  const whdatamods = backendConfig.dataRoot + "node_modules/";
  await mkdir(whdatamods, { recursive: true });
  const configmods = backendConfig.dataRoot + "config/mod/";
  await mkdir(configmods, { recursive: true });

  await updateFile(backendConfig.dataRoot + "eslint.config.mjs",
    `import { relaxedConfig } from "@webhare/eslint-config";
export default [...relaxedConfig, {
  name: "WebHare whdata settings",
  files: ["config/**/*.ts"],
  linterOptions: {
    //we want eslint to spot issues in config files - but they disable a few warnings by default and that otherwise triggers more warnings:
    reportUnusedDisableDirectives: "off"
  }
}];`);

  /* When runnning `npm install` in the dataroot or a subdirectory (without its own package.json),
     npm will use the node_modules in the dataroot to place the new packages. It will then happily
     remove all symlinks starting in node_modules, and also and destroy the whole contents of the linked
     directories when the link starts with '@'.
     With the following engine restrictions and setting engine-strict to true, we prevent npm from running at all.
  */
  await updateFile(backendConfig.dataRoot + "package.json", JSON.stringify({
    engines: {
      npm: "not-allowed",
      yarn: "not-allowed",
      node: "not-allowed"
    }
  }, null, 2) + '\n');

  await updateFile(backendConfig.dataRoot + ".npmrc", `engine-strict=true\n`);

  const directmodlinks = getConfigModulePaths();
  await syncLinks(configmods, directmodlinks, { clean: true, verbose: options?.verbose });

  const datarootitems = getDataRootNodeModules();
  await syncLinks(whdatamods, datarootitems, { clean: true, verbose: options?.verbose });

  const tsconfig = await buildTSConfig(datarootitems);
  const dataRootConfig = {
    ...tsconfig,
    include: [
      "installedmodules/**/*", //to prevent tsc from scanning your entire whdata directory
      ...getTSPolyfills()
    ]
  };

  await updateFile(backendConfig.dataRoot + "tsconfig.json", formatTSConfig(dataRootConfig));

  /* Generate tsconfig.jsons for all modules. Considered going without tsconfig.jsons on non-dev setups but
     - this breaks ESLint validation whose TSLint plugins look up tsconfig.json. we'd have to manually set up those plugins then
     - this breaks loadType in @webhare/tests,it would have to start depending on gen_typescript
     - esbuild might also use it ?

    Note that 'wh checkmodule' currently also updates this for the checked module.*/
  const tsconfigText = formatTSConfig(tsconfig);
  for (const [module, config] of Object.entries(backendConfig.module)) {
    if (!whconstant_builtinmodules.includes(module) && (!options?.modules || options?.modules.includes(module))) { //the builtin ones are handled by a central tsconfig.json
      await updateFile(config.root + "tsconfig.json", tsconfigText);
    }
  }

  if (options?.verbose)
    console.timeEnd("Updating TypeScript infrastructure");
}
