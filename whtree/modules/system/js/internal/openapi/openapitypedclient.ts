import { HTTPErrorCode, HTTPMethod, HTTPStatusCode, RestDefaultErrorBody } from "@webhare/router";
import { ComponentsBase, DefaultErrorType, GetBodyType, GetOperation, GetOperationByPathAndMethod, GetParametersType, JSONResponseTypes } from "./types";
import { JSONResponseForCode, RestResponsesBase } from "@webhare/router/src/restrequest";
import { getServiceInstance, RestService } from "@mod-system/js/internal/openapi/openapiservice";
import { WebHareBlob } from "@webhare/services";


type OpenAPIResponse<BodyType> = {
  status: HTTPErrorCode | HTTPStatusCode;
  headers: Headers;
  contenttype: string;
  ///Body. JSON decoded if the response indicated JSON output, raw otherwise
  body: BodyType;
};


/** Base type for parameter types. Only strings, numbers and booleans are allowed as parameters */
type ParamsBaseType = Record<string, string | number | boolean | string[]>;

/** List of allowed paths for a method
 */
export type PathsForMethod<Paths, Method extends string, Path extends keyof Paths = keyof Paths> = Path extends keyof Paths ? Method extends keyof Paths[Path] ? Path & string : never : never;

/** Possible returned status codes */
type ReturnedStatusCodes<Responses extends RestResponsesBase> = Responses["status"] | HTTPErrorCode;

type ParameterEncoding = {
  explode?: boolean;
};

/** Parameter options for a method and a path
 */
type ParamOptions<Paths extends object, Path extends keyof Paths, Method extends Exclude<keyof Paths[Path], "parameters">> = object extends GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>>
  ? { params?: GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>> & ParamsBaseType; encoding?: ParameterEncoding } | undefined
  : { params: GetParametersType<GetOperationByPathAndMethod<Paths, Path, Method>> & ParamsBaseType; encoding?: ParameterEncoding };

/** Union of all allowed response types for an operation, by operation record
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type OpResponseTypesInternal<Responses extends RestResponsesBase, DefaultErrorFormat extends RestDefaultErrorBody, Status extends ReturnedStatusCodes<Responses> = ReturnedStatusCodes<Responses>> = Status extends any
  ? { status: Status } & OpenAPIResponse<JSONResponseForCode<Responses, DefaultErrorFormat, Status>>
  : never;

/** Union of all allowed response types for an operation, by path and method
 */
type OpResponseTypes<Paths extends object, Components extends ComponentsBase, Path extends keyof Paths, Method extends string> =
  OpResponseTypesInternal<JSONResponseTypes<GetOperationByPathAndMethod<Paths, Path, Method & Exclude<keyof Paths[Path], "parameters">>>, DefaultErrorType<Components>>;

/** Body type, by path and method
 */
type OpBodyType<Paths extends object, Path extends keyof Paths, Method extends string> =
  GetBodyType<GetOperationByPathAndMethod<Paths, Path, Method & Exclude<keyof Paths[Path], "parameters">>>;

/** Tuple with method options, to make the options parameter optional when it has no required properties
 * @typeParam Paths - Paths object as generated by openapi-typescript
 * @typeParam Path - Path
 * @typeParam Method - Method
 */
type MethodOptions<Paths extends object, Path extends keyof Paths, Method extends Exclude<keyof Paths[Path], "parameters">> =
  undefined extends ParamOptions<Paths, Path, Method> ? [ParamOptions<Paths, Path, Method>?] : [ParamOptions<Paths, Path, Method>];

/** Typed OpenAPI client
 */
export class TypedOpenAPIClient<Paths extends object, Components extends ComponentsBase> {
  readonly baseurl: string;
  defaultheaders: Record<string, string> = {};
  private viaservice: string | undefined;
  private serviceinstance: RestService | undefined;

  constructor(baseurl: string, options: { bearertoken?: string; __viaservice?: string } = {}) {
    this.baseurl = baseurl;
    this.viaservice = options.__viaservice;
    if (options?.bearertoken)
      this.defaultheaders["Authorization"] = "Bearer " + options.bearertoken;
  }

  async invoke<Path extends PathsForMethod<Paths, Method>, Method extends string>(method: string, route: string, requestbody: string, options?: { params?: ParamsBaseType; encoding?: ParameterEncoding }): Promise<OpResponseTypes<Paths, Components, Path, Method>> {
    const fetchoptions = {
      method,
      headers: this.defaultheaders,
      ...(requestbody ? { body: requestbody } : null)
    } satisfies RequestInit;
    if (requestbody) {
      fetchoptions.headers["Content-Type"] = "application/json";
    }
    const used_pathelts: string[] = [];
    route = route.split("/").map(pathelt => {
      if (pathelt.startsWith("{")) {
        const name = pathelt.slice(1, -1);
        used_pathelts.push(name);
        const value = options?.params?.[name];
        if (typeof value !== "number" && typeof value !== "string" && typeof value !== "boolean")
          throw new Error(`Missing parameter ${JSON.stringify(pathelt.slice(1, -1))}`);
        return encodeURIComponent(value); // correctly encodes booleans to 'true'/'false'
      }
      return pathelt;
    }).join("/");
    if (route.startsWith("/"))
      route = route.slice(1);

    // add unused params to the url as query parameters
    const url = new URL(this.baseurl + route);
    if (options?.params) {
      for (const [key, value] of Object.entries(options.params)) {
        if (!used_pathelts.includes(key)) {
          if (Array.isArray(value)) {
            if (options.encoding?.explode ?? true) {
              for (const elt of value)
                url.searchParams.append(key, elt);
            } else
              url.searchParams.append(key, value.join(","));
          } else
            url.searchParams.append(key, value.toString());
        }
      }
    }

    let retval;
    if (this.viaservice) {
      this.serviceinstance ??= await getServiceInstance(this.viaservice);
      const res = await this.serviceinstance.APICall({
        sourceip: "127.0.0.1", method: method.toUpperCase() as HTTPMethod, url: url.toString(), body: WebHareBlob.from(requestbody), headers: fetchoptions.headers
      }, url.toString().slice(this.baseurl.length));
      const headers = new Headers(res.headers);
      const contenttype = headers.get("Content-Type") || "";
      const responsebody = contenttype.split(';')[0] === "application/json" ? JSON.parse(await res.body.text()) : res.body;
      retval = { status: res.status, headers, contenttype, body: responsebody };
    } else {
      const call = await fetch(url.toString(), fetchoptions);
      const contenttype = call.headers.get("Content-Type") || "";
      const responsebody = contenttype.split(';')[0] === "application/json" ? await call.json() : await call.text();
      retval = { status: call.status, headers: call.headers, contenttype, body: responsebody };
    }

    return retval as OpResponseTypes<Paths, Components, Path, Method>;
  }

  async get<Path extends PathsForMethod<Paths, "get">>(route: Path, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "get">): Promise<OpResponseTypes<Paths, Components, Path, "get">> {
    return this.invoke("GET", route, "", options[0]);
  }
  async post<Path extends PathsForMethod<Paths, "post">>(route: Path, body: OpBodyType<Paths, Path, "post">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "post">): Promise<OpResponseTypes<Paths, Components, Path, "post">> {
    return this.invoke("POST", route, JSON.stringify(body), options[0]);
  }
  async patch<Path extends PathsForMethod<Paths, "patch">>(route: Path, body: OpBodyType<Paths, Path, "patch">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "patch">): Promise<OpResponseTypes<Paths, Components, Path, "patch">> {
    return this.invoke("PATCH", route, JSON.stringify(body), options[0]);
  }
  async put<Path extends PathsForMethod<Paths, "put">>(route: Path, body: OpBodyType<Paths, Path, "put">, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "put">): Promise<OpResponseTypes<Paths, Components, Path, "put">> {
    return this.invoke("PUT", route, JSON.stringify(body), options[0]);
  }
  async delete<Path extends PathsForMethod<Paths, "delete">>(route: Path, ...options: MethodOptions<Paths, Path, Exclude<keyof Paths[Path], "parameters"> & "delete">): Promise<OpResponseTypes<Paths, Components, Path, "delete">> {
    return this.invoke("DELETE", route, "", options[0]);
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any -- needed to match all TypedOpenAPIClient objects
type TypedOpenAPIClientBase = TypedOpenAPIClient<any, any>;

/** Get the type parameters of a typed openapi client */
export type GetClientTypeParams<Client extends TypedOpenAPIClientBase> = Client extends TypedOpenAPIClient<infer Paths, infer Components> ? { paths: Paths; components: Components } : never;

/** Type for the request body of an operation
 * @typeParam Client - Client type (usually `typeof client`)
 * @typeParam Method - Method ("get", "post", etc.)
 * @typeParam Path - Operation path
 */
export type TypedClientRequestBody<
  Client extends TypedOpenAPIClientBase,
  Method extends "get" | "post" | "patch" | "put" | "delete",
  Path extends PathsForMethod<GetClientTypeParams<Client>["paths"], Method>
> = GetBodyType<GetOperation<GetClientTypeParams<Client>["paths"], `${Method} ${Path}`>>;

/** Type for the return value of an operation call
 * @typeParam Client - Client type (usually `typeof client`)
 * @typeParam Method - Method ("get", "post", etc.)
 * @typeParam Path - Operation path
 */
export type TypedClientResponse<
  Client extends TypedOpenAPIClientBase,
  Method extends "get" | "post" | "patch" | "put" | "delete",
  Path extends PathsForMethod<GetClientTypeParams<Client>["paths"], Method>
> = Client extends TypedOpenAPIClient<infer Paths, infer Components> ? OpResponseTypes<Paths, Components, Path, Method> : never;
