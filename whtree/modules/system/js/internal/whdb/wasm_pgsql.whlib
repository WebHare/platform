<?wh

LOADLIB "wh::regex.whlib";
LOADLIB "wh::dbase/loopback.whlib";
LOADLIB "wh::dbase/transaction.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/comparisons.whlib";
LOADLIB "wh::internal/lockingtransbase.whlib";
LOADLIB "wh::internal/wasm.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "wh::dbase/postgresql.whlib";

MACRO __WASMPG_INSERTRECORD(RECORD query, RECORD newfields) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
MACRO __WASMPG_INSERTRECORDS(RECORD query, RECORD ARRAY newrecordarray) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
MACRO __WASMPG_UPDATERECORD(RECORD query, RECORD rowdata, RECORD newfields) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
MACRO __WASMPG_DELETERECORD(RECORD query, RECORD rowdata) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
RECORD FUNCTION __WASMPG_EXECUTEQUERY(RECORD query) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
RECORD ARRAY FUNCTION __WASMPG_EXECUTESQL(STRING query, RECORD options) __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
MACRO __WASMPG_BEGINWORK() __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);
BOOLEAN FUNCTION __WASMPG_ISWORKOPEN() __ATTRIBUTES__(EXECUTESHARESCRIPT, EXTERNAL);

CONSTANT INTEGER OID_BOOL := 16;
CONSTANT INTEGER OID_BYTEA := 17;
CONSTANT INTEGER OID_CHAR := 18;
CONSTANT INTEGER OID_NAME := 19;
CONSTANT INTEGER OID_TEXT := 25;
CONSTANT INTEGER OID_INT8 := 20;
CONSTANT INTEGER OID_INT2 := 21;
CONSTANT INTEGER OID_INT4 := 23;
CONSTANT INTEGER OID_REGPROC := 24;
CONSTANT INTEGER OID_OID := 26;
CONSTANT INTEGER OID_TID := 27;
CONSTANT INTEGER OID_XID := 28;
CONSTANT INTEGER OID_CID := 29;
CONSTANT INTEGER OID_FLOAT4 := 700;
CONSTANT INTEGER OID_FLOAT8 := 701;
CONSTANT INTEGER OID_INT2ARRAY := 1005;
CONSTANT INTEGER OID_INT4ARRAY := 1007;
CONSTANT INTEGER OID_TEXTARRAY := 1009;
CONSTANT INTEGER OID_OIDARRAY := 1028;
CONSTANT INTEGER OID_BPCHAR := 1042;
CONSTANT INTEGER OID_VARCHAR := 1043;
CONSTANT INTEGER OID_TIMESTAMP := 1114;
CONSTANT INTEGER OID_TIMESTAMPTZ := 1184;
CONSTANT INTEGER OID_BIT := 1560;
CONSTANT INTEGER OID_VARBIT := 1562;
CONSTANT INTEGER OID_NUMERIC := 1700;
CONSTANT INTEGER OID_ANY := 2276;
CONSTANT INTEGER OID_ANYARRAY := 2277;

STRING FUNCTION MapAction(STRING indata)
{
  SWITCH (indata)
  {
    CASE "a"  { RETURN "NO ACTION"; }
    CASE "r"  { RETURN "RESTRICT"; }
    CASE "c"  { RETURN "CASCADE"; }
    CASE "n"  { RETURN "SET NULL"; }
    CASE "d"  { RETURN "SET DEFAULT"; }
  }
  RETURN "";
}

/** doc1 */

/** doc2 */
STATIC OBJECTTYPE EMTransactionCursor EXTEND TransactionCursorBase
< RECORD query;
  INTEGER blockrowstart;
  RECORD ARRAY alldata;
  RECORD ARRAY rowsdata; // Contains ctid/rowpos for each row

  MACRO NEW(OBJECT trans, RECORD query)
  {
    this->query := query;

    RECORD res := __WASMPG_EXECUTEQUERY(query);
    this->alldata := res.tabledata;
    this->rowsdata := res.rowsdata;
    // DumpValue(this->alldata, "boxed");
    // DumpValue(this->rowsdata, "boxed");
  }
  UPDATE PUBLIC MACRO RetrieveNextBlock()
  {
    INTEGER tablecount := LENGTH(this->query.tablesources);
    this->blockrowstart := this->blockrowstart + LENGTH(this->pvt_currentblock) / tablecount;
    this->pvt_currentblock := ArraySlice(this->alldata, this->blockrowstart * tablecount, 64 * tablecount);
  }
  UPDATE PUBLIC MACRO Close()
  {

  }
  UPDATE PUBLIC STRING ARRAY FUNCTION GetFase2Data(INTEGER ARRAY rowlist)
  {
    RETURN STRING[];
  }
  UPDATE PUBLIC MACRO DeleteRecord(INTEGER row)
  {
    __WASMPG_DELETERECORD(this->query, this->rowsdata[this->blockrowstart + row]);
  }

  UPDATE PUBLIC MACRO UpdateRecord(INTEGER row, RECORD newfields)
  {
    __WASMPG_UPDATERECORD(this->query, this->rowsdata[this->blockrowstart + row], newfields);
  }
>;

STATIC OBJECTTYPE EMTransaction EXTEND LockingTransactionBase <
  INTEGER pushlevel;
  PUBLIC INTEGER forwardtransid;

  UPDATE STRING FUNCTION GetType()
  {
    RETURN "wasm-postgresql";
  }
  UPDATE PUBLIC OBJECT FUNCTION OpenCursor(RECORD query, STRING type)
  {
    //    DumpValue(CELL[ query, type ], "tree");
    RETURN NEW EMTransactionCursor(PRIVATE this, CELL[ ...query, type ]);
  }

  //NOTE we need to fully overwrite the Work API as transbase's work counters are useless, JS won't update them
  UPDATE PUBLIC MACRO BeginWork(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ mutex := ""
                               , mutexes := STRING[]
                               , delayreadonlyerror := FALSE
                               ], options);

    IF (this->IsWorkOpen())
      THROW NEW Exception("Cannot begin work: work is already open");

    IF (NOT options.delayreadonlyerror AND this->pvt_isprimary AND NOT IsDatabaseWritable())
      THROW NEW DatabaseReadonlyException;

    TRY
    {
      IF(options.mutex != "")
        INSERT this->__DoLockMutex(options.mutex) INTO this->pvt_worklocks AT END;

      FOREVERY(STRING mutex FROM options.mutexes)
        INSERT this->__DoLockMutex(mutex) INTO this->pvt_worklocks AT END;

      __WASMPG_BEGINWORK();
    }
    CATCH(OBJECT e)
    {
      this->ReleaseAllLocks();
      THROW;
    }
  }

  /** Returns TRUE when there is nested work open
      @return TRUE if nested work is open (eg multiple PushWorks)
  */
  UPDATE PUBLIC BOOLEAN FUNCTION IsNestedWorkOpen()
  {
    RETURN this->pushlevel > 0;
  }

  /** Pushes a new work; if no work has been opened, it will be opened.
  */
  UPDATE PUBLIC MACRO PushWork()
  {
    IF(this->IsWorkOpen())  //already open work? then just increase refcount
    {
      this->pushlevel := this->pushlevel + 1;
      RETURN;
    }
    this->BeginWork();
  }

  /** Pops work; if no pushed work is left, the work is committed and returned
      @return List of commit errors (FIXME: specify cells)
  */
  UPDATE PUBLIC RECORD ARRAY FUNCTION PopWork()
  {
    IF(this->pushlevel > 0) //Just count one down
    {
      this->pushlevel := this->pushlevel - 1;
      RETURN RECORD[];
    }
    RETURN this->CommitWork();
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION CommitWork()
  {
    IF (this->pushlevel > 0)
      THROW NEW Exception("Cannot commit work: inside a nesting level, we still need " || (this->pushlevel) || " PopWork calls");

    //TODO WASM PG needs to handle readonly DBs like transbase does
    WaitForPromise(EM_Syscall("finishWork", [commit := TRUE]));
    this->ReleaseAllLocks(); //TODO WASM PG should handle locks, not us. otherwise a commit on their side will not revoke the locks
    RETURN RECORD[];
  }

  UPDATE PUBLIC MACRO RollbackWork()
  {
    IF (this->pushlevel > 0)
      THROW NEW Exception("Cannot rollback work: inside a nesting level, we still need " || (this->pushlevel) || " PopWork calls");

    WaitForPromise(EM_Syscall("finishWork", [commit := FALSE]));
    this->ReleaseAllLocks(); //TODO WASM PG should handle locks, not us. otherwise a rollback on their side will not revoke the locks
  }

  UPDATE PUBLIC MACRO Rollback()
  {
    THROW NEW Exception("Rollback cannot be used on auto transactions, use RollbackWork");
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION Commit()
  {
    THROW NEW Exception("Commit cannot be used on auto transactions, use CommitWork");
  }

  UPDATE PUBLIC MACRO Close()
  {
    IF (this->IsWorkOpen())
    {
      this->pvt_numworks := 1;
      this->RollbackWork();
    }

    //we never open anything in WASM, so we don't have to close anything either
    LockingTransactionBase::Close();
  }

  UPDATE PUBLIC MACRO InsertRecord(RECORD query, RECORD newfields)
  {
    __WASMPG_INSERTRECORD(query, newfields);
  }

  UPDATE PUBLIC MACRO InsertRecords(RECORD query, RECORD ARRAY newrecords)
  {
    __WASMPG_INSERTRECORDS(query, newrecords);
  }

  PUBLIC RECORD ARRAY FUNCTION __ExecSQL(STRING query, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RETURN __WASMPG_EXECUTESQL(query, options);
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetTableListing(STRING schemaname)
  {
    SCHEMA catalog LIKE postgresql_pg_catalog;
    catalog := BindTransactionToSchema(this->forwardtransid, "pg_catalog");

    INTEGER namespace_oid :=
       SELECT AS INTEGER oid
         FROM catalog.pg_namespace
        WHERE nspname = schemaname;

    IF (namespace_oid = 0)
      RETURN RECORD[];

    RECORD ARRAY tables :=
        SELECT object_id :=   oid
             , table_name :=  relname
             , isview :=      relkind IN [ "v", "m" ]
          FROM catalog.pg_class
         WHERE relkind IN [ "r", "v", "m" ] // table, view, materialized view
           AND relnamespace = namespace_oid;

    RECORD ARRAY primary_keys :=
        SELECT conkey
             , object_id :=   conrelid
             , _matchkey :=   conrelid || "\t" || conkey[0]
          FROM catalog.pg_constraint
         WHERE conrelid IN (SELECT AS INTEGER ARRAY COLUMN object_id FROM tables)
           AND contype = "p"
           AND LENGTH(conkey) = 1;

    RECORD ARRAY columns :=
        SELECT attrelid
             , attnum
             , primary_key_name := attname
             , _matchkey :=   attrelid || "\t" || attnum
          FROM catalog.pg_attribute
         WHERE attrelid IN (SELECT AS INTEGER ARRAY COLUMN object_id FROM tables)
           AND NOT attisdropped;

    primary_keys := JoinArrays(primary_keys, "_matchkey", columns, [ primary_key_name := "" ], [ rightouterjoin := TRUE ]);
    tables := JoinArrays(tables, "object_id", primary_keys, [ primary_key_name := "" ], [ rightouterjoin := TRUE ]);

    RETURN tables;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetSchemaListing()
  {
    SCHEMA catalog LIKE postgresql_pg_catalog;
    catalog := BindTransactionToSchema(this->forwardtransid, "pg_catalog");

    RETURN SELECT schema_name :=      nspname
                , is_system_schema := ToUppercase(nspname) IN [ "DEFINITION_SCHEMA", "INFORMATION_SCHEMA" ] OR ToUppercase(nspname) LIKE "PG_*"
             FROM catalog.pg_namespace;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetColumnListing(STRING schemaname, STRING tablename)
  {
    SCHEMA catalog LIKE postgresql_pg_catalog;
    catalog := BindTransactionToSchema(this->forwardtransid, "pg_catalog");
    SCHEMA is LIKE postgresql_information_schema;
    is := BindTransactionToSchema(this->forwardtransid, "information_schema");

    INTEGER namespace_oid :=
       SELECT AS INTEGER oid
         FROM catalog.pg_namespace
        WHERE ToUppercase(nspname) = ToUppercase(schemaname);

    INTEGER table_oid :=
        SELECT AS INTEGER oid
          FROM catalog.pg_class
         WHERE relkind IN [ "r", "v", "m" ] // table, view, materialized view
           AND relnamespace = namespace_oid
           AND ToUppercase(relname) = ToUppercase(tablename);

    RECORD ARRAY constraints := this->__ExecSQL(
        `SELECT conrelid
              , contype
              , confrelid
              , conkey
              , conname
              , confdeltype
              , pg_get_constraintdef(oid) AS check_expression
           FROM pg_catalog.pg_constraint
         WHERE conrelid = $1
           AND array_length(conkey, 1) = 1`, [ args := VARIANT[ table_oid ] ]);

    RECORD ARRAY refdtables :=
        SELECT confrelid :=                 pg_class.oid
             , referenced_table_name :=     relname
             , referenced_table_schema :=   nspname
          FROM catalog.pg_class
             , catalog.pg_namespace
         WHERE relnamespace = pg_namespace.oid
           AND pg_class.oid IN (SELECT AS INTEGER ARRAY DISTINCT confrelid FROM constraints WHERE confrelid != 0);

    constraints := JoinArrays(constraints, "confrelid", refdtables,
        [ referenced_table_name := ""
        , referenced_table_schema := ""
        ],
        [ rightouterjoin := TRUE
        ]);

    OBJECT sequence_generator := NEW Regex("^nextval\\((.*)\\)|\\(([^.]*\\.webhare_autonrs_.*)\\(1\\)\\)\\[1\\]$");

    RECORD ARRAY columns :=
        SELECT TEMPORARY attr_constraints := (SELECT * FROM constraints WHERE constraints.conkey[0] = pg_attribute.attnum)
             , TEMPORARY foreignkey := (SELECT * FROM attr_constraints WHERE contype = "f")
             , TEMPORARY check_expression := (SELECT AS STRING COLUMN check_expression FROM attr_constraints WHERE contype = "c")
             , column_name :=               attname
             , character_octet_length :=    attlen
             , character_maximum_length :=  atttypid IN [ OID_BPCHAR, OID_VARCHAR ] ? atttypmod - 4 : atttypid IN [ OID_BIT, OID_VARBIT ] ? atttypmod : 0 // https://stackoverflow.com/questions/52376045/why-does-atttypmod-differ-from-character-maximum-length
             , is_nullable :=               RecordExists(foreignkey) ? attnotnull = FALSE : check_expression = ""
             , data_type :=                 (nspname = "pg_catalog" ? "" : nspname || ".") || typname || (atttypid IN [ OID_BPCHAR, OID_VARCHAR ] ? `(${atttypmod - 4})` : atttypid IN [ OID_BIT, OID_VARBIT ] ? `(${atttypmod})` : "")
             , on_delete :=                 RecordExists(foreignkey) ? MapAction(foreignkey.confdeltype) : ""
             , is_unique :=                 RecordExists(SELECT FROM attr_constraints WHERE contype = "u" OR contype = "p")
             , referenced_table_name :=     RecordExists(foreignkey) ? foreignkey.referenced_table_name : ""
             , referenced_table_schema :=   RecordExists(foreignkey) ? foreignkey.referenced_table_schema : ""
             , referenced_table_oid :=      RecordExists(foreignkey) ? foreignkey.confrelid : 0
          FROM catalog.pg_attribute
             , catalog.pg_type
             , catalog.pg_namespace
         WHERE attrelid = table_oid
           AND pg_type.oid = atttypid
           AND pg_namespace.oid = pg_type.typnamespace
           AND NOT attisdropped
           AND attname NOT IN [ "cmin", "cmax", "ctid", "tableoid", "xmax", "xmin" ]; // hide system columns

    RECORD ARRAY is_cols :=
        SELECT column_name
             , autonumber_start :=          ToInteger64(identity_minimum, 0)
             , column_default
          FROM is.columns
         WHERE ToUppercase(table_schema) = ToUppercase(schemaname)
           AND ToUppercase(table_name) = ToUppercase(tablename);

    FOREVERY (RECORD col FROM is_cols)
    {
      RECORD ARRAY match := sequence_generator->Exec(col.column_default);
      IF (RecordExists(match))
      {
        STRING sequencename := match[1].value;
        IF (sequencename = "")
        {
          // Assume that column_default is escaped so that regclass cast can parse it when encoded as string literal
          sequencename := `${PostgresqlEscapeLiteral(Substitute(match[2].value, ".webhare_autonrs_", ".webhare_seq_"))}::regclass`;
        }

        RECORD seq := this->__ExecSQL(`SELECT seqrelid, seqstart FROM pg_catalog.pg_sequence WHERE seqrelid = ${sequencename}`);
        is_cols[#col].autonumber_start := RecordExists(seq) ? INTEGER(seq.seqstart) : 0;
      }
    }

    RETURN JoinArrays(columns, "column_name", is_cols, [ autonumber_start := 0i64, column_default := "" ]);
  }

  UPDATE PUBLIC MACRO CreateSchema(STRING schemaname, STRING ownerschema, STRING ownerrole)
  {
    this->__ExecSQL(`CREATE SCHEMA ${PostgreSQLEscapeIdentifier(schemaname)}`);
  }

  UPDATE PUBLIC MACRO DropSchema(STRING schemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ cascade := FALSE ], options);
    this->__ExecSQL(`DROP SCHEMA ${PostgreSQLEscapeIdentifier(schemaname)}${options.cascade ? ` CASCADE` : ``}`);
  }

  /* attmissingvall is either null (DEFAULT RECORD) or an array:
    'This column has a one element array containing the value used when the column is entirely missing from the row, as
     happens when the column is added with a non-volatile DEFAULT value after the row is created. The value is only used
     when atthasmissing is true. If there is no value the column is null.' */
  VARIANT FUNCTION GetDefaultValue(INTEGER atttypid, BOOLEAN atthasdef, VARIANT attmissingval)
  {
    IF (atthasdef AND IsTypeidArray(TYPEID(attmissingval)) AND LENGTH(attmissingval) != 0)
      RETURN attmissingval[0];
    SWITCH (atttypid)
    {
      CASE OID_BOOL       { RETURN FALSE; }
      CASE OID_BYTEA      { RETURN ""; }
      CASE OID_CHAR       { RETURN ""; }
      CASE OID_NAME       { RETURN ""; }
      CASE OID_TEXT       { RETURN ""; }
      CASE OID_VARCHAR    { RETURN ""; }
      CASE OID_INT8       { RETURN 0i64; }
      CASE OID_INT2       { RETURN 0; }
      CASE OID_INT4       { RETURN 0; }
      CASE OID_REGPROC    { RETURN 0; }
      CASE OID_OID        { RETURN 0; }
      CASE OID_TID        { RETURN 0; }
      CASE OID_XID        { RETURN 0; }
      CASE OID_CID        { RETURN 0; }
      CASE OID_FLOAT4     { RETURN 0f; }
      CASE OID_FLOAT8     { RETURN 0f; }
      CASE OID_INT2ARRAY  { RETURN INTEGER[]; }
      CASE OID_INT4ARRAY  { RETURN INTEGER[]; }
      CASE OID_TEXTARRAY  { RETURN STRING[]; }
      CASE OID_OIDARRAY   { RETURN INTEGER[]; }
      CASE OID_TIMESTAMP, OID_TIMESTAMPTZ  { RETURN DEFAULT DATETIME; }
      CASE OID_NUMERIC    { RETURN 0m; }
      CASE OID_ANY        { RETURN 0; }
      CASE OID_ANYARRAY   { RETURN VARIANT[]; }
      DEFAULT
      {
        RECORD rec := this->__ExecSQL(`
            SELECT t.oid, t.typname, t.typbasetype, n.nspname, a.oid AS arrayeltoid
              FROM pg_catalog.pg_type t
                   INNER JOIN pg_catalog.pg_namespace n ON (t.typnamespace = n.oid)
                   LEFT OUTER JOIN pg_catalog.pg_type a ON (a.typarray = t.oid)
             WHERE t.oid = $1`, [ args := VARIANT[ atttypid ] ]);

        IF (rec.typbasetype != 0)
          RETURN this->GetDefaultValue(rec.typbasetype, atthasdef, attmissingval);
        IF (rec.nspname = "webhare_internal" AND rec.typname = "webhare_blob")
          RETURN DEFAULT BLOB;
        IF (rec.arrayeltoid != 0)
        {
          VARIANT elt := this->GetDefaultValue(rec.arrayeltoid, atthasdef, attmissingval);
          RETURN RepeatElement(elt, 0);
        }
        RETURN [ error := "values of this type cannot be read yet" ];
      }
    }
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION __GetTableTypeInfoCols(TABLE tbl, STRING ARRAY cols)
  {
    STRING table_name := GetBindingFromTable(tbl).tablename;
    STRING schema_name := "PUBLIC";
    IF (table_name LIKE "*.*")
    {
      schema_name := Tokenize(table_name, ".")[0];
      table_name := Tokenize(table_name, ".")[1];
    }

    SCHEMA catalog LIKE postgresql_pg_catalog;
    catalog := BindTransactionToSchema(this->id, "pg_catalog");

    RECORD ARRAY tablecols := this->__ExecSQL(`
       select attname, atttypid, atthasdef, attmissingval, attnotnull
       from pg_catalog.pg_attribute, pg_catalog.pg_class, pg_catalog.pg_namespace
       where pg_class.oid = attrelid
             and pg_namespace.oid = pg_class.relnamespace
             and upper(nspname) = upper($1)
             and upper(relname) = upper($2)
             and not attisdropped
             and not (attname in ('cmin', 'cmax', 'ctid', 'tableoid', 'xmax', 'xmin'))`,  [args := VARIANT[schema_name,table_name]]);

    tablecols :=
        SELECT TEMPORARY value :=   this->GetDefaultValue(atttypid, atthasdef, attmissingval)
             , name :=        attname
             , dbase_name :=  attname
             , type :=        TypeID(value)
             , flags :=       atttypid = OID_BYTEA ? 256 : 0 // ColumnFlags::Binary
             , fase :=        0
             , ...[ attnotnull OR TypeID(value) = TypeID(BLOB) ? CELL[] : [ nulldefault := value ] ]
          FROM tablecols
      ORDER BY attname;

    RECORD ARRAY retval;
    FOREVERY (STRING col FROM cols)
    {
      RECORD pos := RecordLowerBound(tablecols, [ name := col ], [ "NAME" ]);
      IF (NOT pos.found)
      {
        // Not found, try builtin columns (internally translated inside driver)
        INTEGER builtintype;
        SWITCH (ToLowercase(`${schema_name}.${table_name}(${col})`))
        {
          CASE "system.sites(webroot)"            { builtintype := TypeID(STRING); }
          CASE "system.fs_objects(fullpath)"      { builtintype := TypeID(STRING); }
          CASE "system.fs_objects(highestparent)" { builtintype := TypeID(INTEGER); }
          CASE "system.fs_objects(indexurl)"      { builtintype := TypeID(STRING); }
          CASE "system.fs_objects(isactive)"      { builtintype := TypeID(BOOLEAN); }
          CASE "system.fs_objects(publish)"       { builtintype := TypeID(BOOLEAN); }
          CASE "system.fs_objects(url)"           { builtintype := TypeID(STRING); }
          CASE "system.fs_objects(whfspath)"      { builtintype := TypeID(STRING); }
          DEFAULT
          {
            STRING ARRAY allowed := SELECT AS STRING ARRAY name FROM tablecols;
            STRING didyoumean := GetBestMatch(col, allowed, [ casesensitive := TRUE ]);
            THROW NEW Exception(`Could not find column "${EncodeJava(col)}" in table "${schema_name}"."${table_name}"${didyoumean = "" ? "" : `, did you mean "${didyoumean}"?`}`);
          }
        }

        INSERT
            [ name :=         col
            , dbase_name :=   col
            , type :=         builtintype
            , flags :=        0
            , fase :=         0
            ] INTO retval AT END;
      }
      ELSE
        INSERT tablecols[pos.position] INTO retval AT END;
    }

    RETURN retval;
  }

  UPDATE PUBLIC MACRO CreateTable(STRING schemaname, STRING tablename, RECORD tablestructure)
  {
    THROW NEW Exception(`CreateTable yet not supported for PostgreSQL`);
  }

  UPDATE PUBLIC MACRO AlterTable(STRING schemaname, STRING tablename, RECORD tablemanip)
  {
    THROW NEW Exception(`AlterTable yet not supported for PostgreSQL`);
  }

  UPDATE PUBLIC MACRO DropColumn(STRING schemaname, STRING tablename, STRING columnname)
  {
    this->__ExecSQL(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)} DROP COLUMN ${PostgreSQLEscapeIdentifier(columnname)}`);
  }

  UPDATE PUBLIC MACRO DropTable(STRING schemaname, STRING tablename)
  {
    this->__ExecSQL(`DROP TABLE ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)}`);
  }

  UPDATE PUBLIC INTEGER FUNCTION MakeAutoNumber(STRING schemaname, STRING tablename, STRING columnname)
  {
    RETURN this->MakeAutoNumbers(schemaname, tablename, columnname, 1)[0];
  }

  UPDATE PUBLIC BOOLEAN FUNCTION HasWorkSupport()
  {
    RETURN TRUE;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION IsWorkOpen()
  {
    RETURN __WASMPG_ISWORKOPEN();
  }

  UPDATE PUBLIC INTEGER ARRAY FUNCTION MakeAutoNumbers(STRING schemaname, STRING tablename, STRING columnname, INTEGER amount)
  {
    IF (NOT this->IsWorkOpen())
      THROW NEW Exception(`BeginWork must be called before modifying the database`);
    IF (amount < 1)
      RETURN INTEGER[];
    STRING generator := `(${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(`webhare_autonrs_${tablename}_${ToLowercase(columnname)}`)}(${amount}))`;
    RECORD result := this->__ExecSQL("SELECT " || generator || " AS value");
    IF (NOT RecordExists(result) OR LENGTH(result.value) != amount)
      THROW NEW Exception(`No value returned by MakeAutonumbers generator`);
    RETURN INTEGER ARRAY(result.value);
  }

  UPDATE PUBLIC INTEGER64 FUNCTION MakeAutoNumber64(STRING schemaname, STRING tablename, STRING columnname)
  {
    RETURN this->MakeAutoNumbers64(schemaname, tablename, columnname, 1)[0];
  }

  UPDATE PUBLIC INTEGER64 ARRAY FUNCTION MakeAutoNumbers64(STRING schemaname, STRING tablename, STRING columnname, INTEGER amount)
  {
    IF (NOT this->IsWorkOpen())
      THROW NEW Exception(`BeginWork must be called before modifying the database`);
    IF (amount < 1)
      RETURN INTEGER64[];
    STRING generator := `(${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(`webhare_autonrs_${tablename}_${ToLowercase(columnname)}`)}(${amount}))`;
    RECORD result := this->__ExecSQL("SELECT " || generator || " AS value");
    IF (NOT RecordExists(result) OR LENGTH(result.value) != amount)
      THROW NEW Exception(`No value returned by MakeAutonumber generator`);
    RETURN INTEGER64 ARRAY(result.value);
  }

>;

OBJECTTYPE ExtraForwards
<
  OBJECT __forwardto;

  MACRO NEW(OBJECT forwardto)
  {
    this->__forwardto := forwardto;
  }

  PUBLIC RECORD ARRAY FUNCTION __ExecSQL(STRING query, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RETURN this->__forwardto->__ExecSQL(query, options);
  }
>;

PUBLIC OBJECT FUNCTION CreateWASMPostgreSQLTransaction(RECORD transinfo)
{
  OBJECT trans := NEW EMTransaction;
  OBJECT forward := CreateForwardingLoopbackTransactionFromObject(trans, CELL[],
      [ supports_block_cursors := false
      , supports_single := true // unused!!
      , supports_data_modify := true
      , supports_nulls := true
      , supports_limit := true
      , needs_locking_and_recheck := false
      , fase2_locks_implicitly := true
      , needs_uppercase_names := false
      , max_joined_tables := 0
      , max_multiinsertrows := 64
      ]);
  trans->forwardtransid := forward->id;
  EXTEND __HS_INTERNAL_MakeObjectReferencePrivileged(forward) BY ExtraForwards(trans);
  RETURN forward;
}


INTEGER FUNCTION __HS_SQL_EMDB_REGISTER(STRING classref) __ATTRIBUTES__(EXTERNAL);
MACRO __HS_SQL_EMDB_UNREGISTER(INTEGER id) __ATTRIBUTES__(EXTERNAL);
