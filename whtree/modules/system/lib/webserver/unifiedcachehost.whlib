<?wh
/** @topic sitedev/caching */

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::graphics/filters.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/services.whlib";
LOADLIB "mod::system/lib/internal/cache/imgcache.whlib";
LOADLIB "mod::system/lib/internal/webserver/errorhandler.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/webserver/errors.whlib";

/* UC URL structure

  /.wh/ea/uc/i<twodigits>/restdigits/

  We'll store images as follows
  /.wh/ea/uc/i12/<imgtoken>.jpg
  /.wh/ea/uc/i34/<imgtoken>.png
  /.wh/ea/uc/i56/<imgtoken>.gif

  Need pretty names? Then simpy append /bicycle.jpg
  This naming convention allows us to serve images without looking at their
  contents

  We'll also want to offer files, and without having to go to the database. Ie,
  the disk version should give us enough info.

  e=embed, f=file

  /uc/e78/application/zip/<filetoken><extension>
  /uc/f9a/application/zip/<filetoken><extension>
*/

RECORD FUNCTION GetMimeType(STRING extension)
{
  OBJECT trans := OpenPrimary();
  STRING mimetype := (SELECT AS STRING mimetypes.mimetype FROM system.mimetypes WHERE mimetypes.extension = Substring(VAR extension,1)) ?? "application/octet-stream";
  trans->Close();
  RETURN [ value := mimetype
         , ttl := 5 * 60 * 1000 //ADDME flush on mimetype table change
         ];
}

PUBLIC STATIC OBJECTTYPE UnifiedCacheHostBase <
  BOOLEAN force;
  BOOLEAN trace;

  MACRO NEW()
  {
    this->force := GetWebVariable("force")="1";
    this->trace := GetWebVariable("trace")="1" AND IsDebugTagEnabled("etr");
    IF(this->trace)
      AddHTTPHeader("Content-Type","text/plain",FALSE);
  }

  //Get the disk hash key for this image
  STRING FUNCTION GetDiskPath(RECORD analyzed)
  {
    STRING folder := Left(analyzed.urlpart, SearchLastSubString(analyzed.urlpart, "/"));
    STRING hash := ToLowercase(EncodeBase16(GetHashForString(folder, "SHA-256"))) || analyzed.extension;
    hash := Left(hash, 3) || "/" || SubString(hash, 3);

    RETURN GetUnifiedCacheDiskRoot() || hash;
  }

  BLOB FUNCTION ProcessImage(RECORD imgrec, RECORD imginfo)
  {
    /* Verify and decode image information */
    RECORD res := GfxResizeWrappedImageWithMethod(imgrec, imginfo.resizemethod);
    IF(NOT RecordExists(res))
      THROW NEW Exception("GfxResizeImageBlobWithMethod failed");
    RETURN res.data;
  }

  RECORD FUNCTION GetCacheRawData(RECORD data) {
    //Get the path for this image
    STRING path := this->GetDiskPath(data);
    BLOB diskfile;
    IF (NOT this->force)
    {
      TRY
      {
        diskfile := GetDiskResource(path);
        IF(this->trace)
          Print("Disk name: " || path || " " || Length(diskfile) || " bytes\n");

        RECORD fileinfo := GetDiskFileProperties(path);
        RETURN [ modified := fileinfo.modified
               , data := diskfile
               ];
      }
      CATCH(OBJECT e)
      {
        IF(this->trace)
          Print("Disk name: " || path || " not present: " || e->what || "\n");
      }
    }

    /* Need to create it. To prevent peaks, create at most 4 images at a time. TODO It would be even better if we could terminate
       and delay the request for a 100ms or so, or just 503 if load gets real high.. Local locks are faster and safe as we atomically
       overwrite the end result file anyway. Worst case we spent a bit of unneeded work regenerating an image another webserver was */
    INTEGER imagebucket := GetByteValue(GetMD5Hash(path)) % 4;
    OBJECT lock := OpenLocalLockManager()->LockLocalMutex("system:unifedcachehost_" || imagebucket);

    //TODO we might not need to do temporary files ourselves. StoreDiskFile's overwrite mode does an atomic replace by default
    INTEGER imghandle;
    TRY {
      RECORD dbdata := LookupDataForUnifiedURL(data.item);
      IF (this->trace)
        DumpValue(dbdata, "tree");

      //If we get here, the url was validated and the item was not rejected
      IF(data.datatype = 1 AND (data.item.resizemethod.format IN ["image/webp","image/avif"] OR dbdata.mimetype IN ["image/webp","image/avif"])) {
        RECORD req := CELL[ ...dbdata
              , DELETE data //don't transfer the raw blob, receiver can cheat and use the PGBLOBID
              , data.item
              , path
              ];
        TRY {
          __OpenSynchronousWebHareService("platform:unifiedcache")->generateImageForCache(req);
        } CATCH(OBJECT e) {
          TRY {
            __OpenSynchronousWebHareService("platform:unifiedcache")->generateImageForCache(req);
            LogDebug("system:unifiedcache", [ retrysuccess := TRUE, exc1 := e->what ]);
          } CATCH(OBJECT f) {
            LogDebug("system:unifiedcache", [ retrysuccess := FALSE, exc1 := e->what, exc2 := f->what ]);
            THROW f;
          }
        }
      }
      ELSE
      {
        BLOB content := dbdata.data;
        IF(data.datatype = 1)
          content := this->ProcessImage(dbdata, data.item);

        CreateDiskDirectoryRecursive(GetDirectoryFromPath(path), TRUE);
        StoreDiskFile(path, content, [ overwrite := TRUE]);
      }
    }
    FINALLY
    {
      lock->Release();
    }

    DATETIME modified := GetDiskFileProperties(path).modified;

    IF(this->trace)
      Print("Image is generated. Last modified: " || FormatHTTPDatetime(modified) || "\n");

    RETURN CELL[ modified
           , data := GetDiskResource(path)
           ];
  }

  MACRO FailRequest(STRING why, BOOLEAN badurl)
  {
    IF(this->trace)
    {
      Print("Failed: " || why || "\n");
      TerminateScript();
    }
    IF(badurl)
      AddHTTPHeader("Cache-Control", "public, max-age=86400", FALSE); //not immutable, give us a chance to fix eg broken encryption secret
    AbortWithHTTPError(404, why);
  }

  PUBLIC MACRO HandleRequest()
  {
    STRING token := GetUCTokenFromURL(GetRequestURL());
    IF(token="")
      this->FailRequest("Unable to detect the token from the URL", TRUE);

    IF(this->trace)
      Print("Token = [" || token || "]\n");

    TRY
    {
      RECORD analyzed := AnalyzeUnifiedURLToken(token);
      IF(NOT RecordExists(analyzed))
        this->FailRequest("Could not parse urltoken", TRUE);

      IF(this->trace)
        DumpValue(analyzed,'tree');

      RECORD img := this->GetCacheRawData(analyzed);
      IF(this->trace)
        DumpValue(img,'tree');

      STRING mimetype := GetAdhocCached([ extension := analyzed.extension], PTR GetMimeType(analyzed.extension));

      AddHTTPHeader("Status", "200", FALSE);
      IF(this->trace)
      {
        Print("Generated image of " || Length(img.data) || " bytes with mimetype " || mimetype || "\n");
      }
      ELSE
      {
        AddHTTPHeader("Cache-Control", "public, max-age=31536000, immutable", FALSE);
        AddHTTPHeader("Content-Type", mimetype, FALSE);
        AddHTTPHeader("Last-Modified", FormatHTTPDatetime(img.modified), FALSE);
        SendWebFile(img.data);
      }
    }
    CATCH(OBJECT e)
    {
      AddHTTPHeader("Cache-Control", "no-cache", FALSE);
      LogWebserverError(e->what);
      IF(this->trace)
        Print("Final error: " || e->what ||"\n");
      ELSE
      {
        AddHTTPHeader("Status", "404", FALSE);
        GenerateHTTPErrorPage(404, DEFAULT RECORD);
      }
    }
  }
>;
AddHTTPHeader("Cache-Control", "no-cache", FALSE);
