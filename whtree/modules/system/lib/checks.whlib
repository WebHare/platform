<?wh

LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/api.whlib";


PUBLIC RECORD ARRAY FUNCTION GetCurrentCheckIssues(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ withhistory := FALSE ], options);

  //Some issues cannot be reported through the WRD mechanisms
  RECORD ARRAY issues;
  CONSTANT RECORD baseissue :=
    [ is_manageable := FALSE //a check has to come from the database to be manageable
    , is_critical := FALSE
    , message_tid := DEFAULT RECORD
    , snoozed := FALSE
    , scopes := STRING[]
    , since := DEFAULT DATETIME
    , stopped := DEFAULT DATETIME
    , jump_to := DEFAULT RECORD
    , snoozed_until := DEFAULT DATETIME
    ];

  IF (NOT IsDatabaseWritable())
  {
    INSERT CELL[ ...baseissue
               , message_text := "The WebHare database is in readonly mode!"
               , rowkey := -1
               , is_critical := TRUE
               ] INTO issues AT END;
  }

  RECORD lastintervalrun := SELECT * FROM system_internal.tasks WHERE tag = "system.intervalchecks";
  IF(NOT RecordExists(lastintervalrun) OR lastintervalrun.lastrun = DEFAULT DATETIME)
  {
    INSERT CELL[ ...baseissue
               , message_text := "The periodic status checks are not running - not all checks are available"
               , rowkey := -2
               , is_critical := TRUE
               ] INTO issues AT END;
  }
  ELSE IF(lastintervalrun.error != "")
  {
    INSERT CELL[ ...baseissue
               , message_text := `The periodic status checks are failing: ${NormalizeWhitespace(lastintervalrun.error)}`
               , rowkey := -2
               , is_critical := TRUE
               ] INTO issues AT END;
  }
  ELSE
  {
    RECORD startupdata := EnforceStructure([ start := DEFAULT DATETIME], PollWHServiceState("startup"));
    DATETIME boottime := startupdata.start;
    //if the server recently booted consider that the last run time to prevent this check during startup. Ideally we could consider most-recent-wake time too
    INTEGER64 lastrun := GetDatetimeDifference(MAX[]([boottime, lastintervalrun.lastrun]), GetCurrentDatetime()).totalmsecs;

    IF(lastrun > 10 * 60000) //it's scheduled every 5 minutes, so warn after 10
    {
      INSERT CELL[ ...baseissue
                 , message_text := `The periodic status checks have not been executed for more than ${lastrun / 60000} minutes`
                 , rowkey := -2
                 , is_critical := GetDtapStage() != "development" //if we can't prevent the error triggering due to recent sleep, make it non-critical for dev servers (most likely to sleep)
                 ] INTO issues AT END;

    }
  }

  RECORD ARRAY dbissues;
  OBJECT serverchecktype := OpenWRDSchema("system:config")->GetType('server_check');
  IF(ObjectExists(serverchecktype) AND serverchecktype->HasAttribute("is_critical"))
  {
    dbissues := serverchecktype->RunQuery(
        [ outputcolumns := CELL[ "type", "check_task", "metadata", "message_text", "message_tid", "jump_to", "snoozed_until", "wrd_id", since := "wrd_creationdate", "scopes", stopped := "wrd_limitdate", "is_critical" ]
        , historymode := options.withhistory ? "all" : "now"
        ]);

    DATETIME now := GetCurrentDatetime();
    dbissues := SELECT ...baseissue
                     , rowkey := wrd_id
                     , is_manageable := TRUE
                     , *
                     , snoozed := snoozed_until > now
                     , stopped := stopped = MAX_DATETIME ? DEFAULT DATETIME : stopped
                 FROM dbissues;
  }
  ELSE
  {
    INSERT CELL[ ...baseissue
                , message_text := `The periodic status check tables are unavailable`
                , rowkey := -2
                , is_critical := TRUE
                ] INTO issues AT END;
  }

  issues := RECORD[ ...issues, ...dbissues ];
  RETURN issues;
}


PUBLIC MACRO UpdateCheckStatus(STRING task, RECORD ARRAY checks)
{
  OBJECT wrdschema := OpenWRDSchema("system:config");
  GetPrimary()->BeginLockedWork("system:updatechecks." || task);

  checks := EnforceStructure([[ type := "", metadata := DEFAULT RECORD, message_text := "", message_tid := DEFAULT RECORD, jump_to := DEFAULT RECORD, scopes := STRING[], is_critical := FALSE ]], checks);
  UPDATE checks SET message_tid := EnforceStructure([ tid := "", params := STRING[] ], message_tid) WHERE RecordExists(message_tid);
  UPDATE checks SET message_text := CallFunctionPtrVA(PTR GetTidForLanguage, VARIANT["en", message_tid.tid, ...message_tid.params]) WHERE message_text = "" AND RecordExists(message_tid);

  DATETIME now := GetCurrentDatetime();
  RECORD ARRAY current := wrdschema->^server_check->RunQuery(
    CELL [ outputcolumns := ["wrd_id","type","metadata","message_text","message_tid","wrd_limitdate","is_critical"]
         , filters := [[ field := "check_task", value := task ]]
         , historymode := "all"
         ]);

  RECORD ARRAY seen;
  FOREVERY(RECORD check FROM checks)
  {
    IF(check.message_text = "")
      THROW NEW Exception(`Check #${#check} is missing a message_text`);
    IF(RecordExists(SELECT FROM seen WHERE seen.type = check.type AND EncodeJSON(seen.metadata) = EncodeJSON(check.metadata)))
      CONTINUE;
    INSERT check INTO seen AT END;

    INTEGER match := (SELECT AS INTEGER #current + 1 FROM current WHERE current.type = check.type AND EncodeJSON(current.metadata) = EncodeJSON(check.metadata)) - 1; //*our* encodejson is stable!
    RECORD baserecord :=
      CELL[ check_task := task
          , check.type
          , check.metadata
          , check.message_text
          , check.message_tid
          , wrd_limitdate := MAX_DATETIME
          , check.jump_to
          , check.scopes
          , check.is_critical
          ];

    IF(match = -1) //it's new
    {
      OBJECT newcheck := wrdschema->^server_check->CreateEntity(
        CELL[ ...baserecord
            , wrd_creationdate := now
            ]);
      wrdschema->^server_check_history->CreateEntity(
        CELL[ wrd_leftentity := newcheck->id
            , event := "start"
            , check.message_text
            , check.message_tid
            , wrd_creationdate := now
            ]);
      CONTINUE;
    }

    //We assume something like jumpto won't change without the message changing
    IF(current[match].message_text != check.message_text
       OR EncodeHSON(current[match].message_tid) != EncodeHSON(check.message_tid)
       OR current[match].wrd_limitdate != MAX_DATETIME
       OR current[match].is_critical != check.is_critical) //update it!
    {
      wrdschema->^server_check->UpdateEntity(current[match].wrd_id, baserecord);
      wrdschema->^server_check_history->CreateEntity(
        CELL[ wrd_leftentity := current[match].wrd_id
            , event := current[match].wrd_limitdate != MAX_DATETIME ? "start" : "change"
            , check.message_text
            , check.message_tid
            , wrd_creationdate := now
            ]);
    }
    DELETE FROM current AT match;
  }

  FOREVERY(RECORD cur FROM SELECT * FROM current WHERE wrd_limitdate = MAX_DATETIME)
  {
    wrdschema->^server_check->UpdateEntity(cur.wrd_id, CELL[ wrd_limitdate := now ]);
    wrdschema->^server_check_history->CreateEntity(
      CELL[ wrd_leftentity := cur.wrd_id
          , event := "stop"
          , wrd_creationdate := now
          ]);
  }

  GetPrimary()->CommitWork();
}

MACRO AuditIssue(INTEGER issueid, RECORD data)
{
  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD issueinfo := wrdschema->^server_check->GetEntityFields(issueid, CELL["message_text","type","metadata","snoozed_until"]);

  LogAuditEvent("system:systemmessages",
      CELL[ id :=                 issueid
          , until :=              issueinfo.snoozed_until
          , message_text :=       issueinfo.message_text
          , issuetype :=          issueinfo.type
          , issuemetadata :=      issueinfo.metadata
          , ...data
          ]);
}

PUBLIC MACRO SnoozeIssue(INTEGER issueid, DATETIME snoozed_until, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ comment := "", whuser := DEFAULT RECORD ], options);

  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD issueinfo := wrdschema->^server_check->GetEntityFields(issueid, CELL["snoozed_until","message_text","type","metadata"]);
  IF(issueinfo.snoozed_until > snoozed_until)
    THROW NEW Exception(`A longer snooze is already active for check issue #${issueid}`);

  wrdschema->^server_check->UpdateEntity(issueid, CELL[ snoozed_until ]);

  wrdschema->^server_check_history->CreateEntity(
    CELL[ wrd_leftentity := issueid
        , event := "snooze"
        , options.comment
        , snoozed_until
        , wh_user := options.whuser
        ]);

  AuditIssue(issueid, [ type := "snooze" , comment := options.comment ]);
}

PUBLIC MACRO UnsnoozeIssue(INTEGER issueid)
{
  //We don't really bother to log 'unsnoozing' as a history event
  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD ARRAY activesnoozes := wrdschema->^server_check_history->RunQuery(
      [ outputcolumns := CELL[ "wrd_id" ]
      , filters := [ [ field := "wrd_leftentity", value := issueid ]
                   , [ field := "event", value := "snooze" ]
                   , [ field := "snoozed_until", matchtype := ">=", value := GetCurrentDatetime() ]
                   ]
      ]);

  FOREVERY(RECORD activesnooze FROM activesnoozes)
    wrdschema->^server_check_history->CloseEntity(activesnooze.wrd_id);

  AuditIssue(issueid, [ type := "unsnooze" ]);
  wrdschema->^server_check->UpdateEntity(issueid, [ snoozed_until := DEFAULT DATETIME ]);
}
