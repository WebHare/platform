<?wh
/** @topic sitedev/caching */

LOADLIB "wh::adhoccache.whlib" EXPORT GetAdhocCached, LookupAdhocCached, StoreAdhocCached;
LOADLIB "wh::float.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::internal/graphics.whlib";
LOADLIB "wh::graphics/filters.whlib";
LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/cache/imgcache.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support2.whlib";

/** @short Get the URL to a (resized) image file
    @param baseurl Base URL for the returned cache url (leave empty for a /.uc/ or https://cdn/.uc/ url)
    @param fsobject system.fs_objects id of the file
    @param scalemethod Resizing method, if any */
PUBLIC STRING FUNCTION GetCachedFSImageURL(STRING baseurl, INTEGER fsobjectid, RECORD scalemethod)
{
  RETURN GetUnifiedCacheURL(baseurl, 1, 1, fsobjectid, scalemethod);
}

/** @short Get the URL to a file data download
    @param baseurl Base URL for the returned cache url (leave empty for a /.uc/ or https://cdn/.uc/ url)
    @param fsobject system.fs_objects id of the file
    @cell options.filename Filename to use in the URL
    @cell options.embed The returned URL should serve itself without a content-disposition: attachment
    @cell options.allowanyextension Do not fail if the wrong extension is used */
PUBLIC STRING FUNCTION GetCachedFSFileURL(STRING baseurl, INTEGER fsobjectid)
{
  RETURN GetUnifiedCacheURL(baseurl, 2, 1, fsobjectid, DEFAULT RECORD);
}

/** @short Get the URL to a (resized) image in instance data
    @param baseurl Base URL for the returned cache url (leave empty for a /.uc/ or https://cdn/.uc/ url)
    @param fsobject settingid of the image
    @param scalemethod Resizing method, if any */
PUBLIC STRING FUNCTION GetCachedFSSettingImageURL(STRING baseurl, INTEGER fssettingid, RECORD scalemethod)
{
  RETURN GetUnifiedCacheURL(baseurl, 1, 2, fssettingid, scalemethod);
}

/** @short Get the URL to an instance data file setting download
    @param baseurl Base URL for the returned cache url (leave empty for a /.uc/ or https://cdn/.uc/ url)
    @param fsobject settingid of the image (must have publish="true" in its contenttype definition)
    @cell options.filename Filename to use in the URL
    @cell options.embed The returned URL should serve itself without a content-disposition: attachment
    @cell options.allowanyextension Do not fail if the wrong extension is used */
PUBLIC STRING FUNCTION GetCachedFSSettingFileURL(STRING baseurl, INTEGER fssettingid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN GetUnifiedCacheURL(baseurl, 2, 2, fssettingid, options);
}

/** @short Return the cached data from an URL
    @long This function resolves the URL generated by one of the GetCached... functions in this library and returns
       the data
    @return
    @cell(blob) return.data
    @cell(string) return.mimetype
    @cell(string) return.filename
*/
PUBLIC RECORD FUNCTION GetCachedDataFromURL(STRING url)
{
  url := Tokenize(url, "?")[0];

  INTEGER uc := SearchSubstring(url, "/.uc/");
  IF(uc>=0)
  {
    RECORD analyzed := AnalyzeUnifiedURLToken(Substring(url, uc+5), "");
    IF(RecordExists(analyzed))
    {
      STRING mimetype;
      IF(analyzed.datatype = 1)
        mimetype := GetImageMimetype(analyzed.extension);
      ELSE
        mimetype := SELECT AS STRING mimetypes.mimetype FROM system.mimetypes WHERE mimetypes.extension = analyzed.extension;

      RECORD info := LookupDataForUnifiedURL(analyzed.item);
      BLOB content := info.data;
      IF (analyzed.datatype=1)
        content := __ProcessImage(info, analyzed.item);

      RETURN [ data := content
             , mimetype := mimetype
             , filename := analyzed.filename
             ];
    }
  }
  RETURN DEFAULT RECORD;
}

/** @topic wrd/api
    @loadlib mod::wrd/lib/api.whlib
    @short Get an image field and immediately resize it
    @param field Field to get
    @param method Resize method to apply
    */
PUBLIC RECORD FUNCTION WrapImageField(STRING field, RECORD method)
{
  method := ValidateResizeMethod(method);
  RETURN [ __queryfield := "" //indicated that this is a query wrapper. this would otherwise crash, as you can't select an empty field name
         , type := "wrapimage"
         , fieldname := field
         , resizemethod := method
         ];
}


// Copied from UnifiedCacheHost - needed to get resizing to work quickly in GetCachedDataFromURL
BLOB FUNCTION __ProcessImage(RECORD imgrec, RECORD imginfo)
{
  /* Verify and decode image information */
  RECORD hostdata;
  IF(CellExists(imginfo, "HOSTDATA"))
    hostdata := imginfo.hostdata;

  //INSERT CELL postprocessor := this->GetImagePostProcessor(hostdata) INTO imginfo.resizemethod;
  RECORD res := GfxResizeWrappedImageWithMethod(imgrec, imginfo.resizemethod);
  IF(NOT RecordExists(res))
    THROW NEW Exception("GfxResizeWrappedImageWithMethod failed");
  RETURN res.data;
}

/** @short Extract the original image from an image cache URL
    @param url URL to extract the image from
    @return The wrapped object if extract it from the URL. Returns a default record on failure */
PUBLIC RECORD FUNCTION GetWrappedSourceFromURL(STRING url)
{
  IF(url="")
    RETURN DEFAULT RECORD;

  RECORD info := GetCachedDataSourceMetadataFromURL(url);
  IF(RecordExists(info))
  {
    IF(info.type=1) //fsobject
      RETURN WrapFSObject(info.id);
    IF(info.type=2) //fssetting
      RETURN GetWHFSFileDirect(info.id);
    IF(info.type=3) //WRD
    {
      RECORD imgrecinfo := SELECT * FROM wrd.entity_settings WHERE id = info.id;
      RETURN RecordExists(imgrecinfo) ? GetWrappedObjectFromWRDSetting(imgrecinfo, FALSE, DEFAULT OBJECT, DEFAULT OBJECT) : DEFAULT RECORD;
    }
    IF(info.type=4)
    {
      RECORD attachinfo := SELECT * FROM publisher.formattachments WHERE id = info.id;
      RETURN RecordExists(attachinfo) ? CELL[...SplitBlobSetting(attachinfo.metadata,attachinfo.file,0), __blobsource := "r" || info.id] : DEFAULT RECORD;
    }
  }
  RETURN DEFAULT RECORD;
}

INTEGER FUNCTION TypeFromBlobSource(RECORD wrapped)
{
  SWITCH(Left(wrapped.__blobsource,1))
  {
    CASE "o" { RETURN 1; } //fs object
    CASE "s" { RETURN 2; } //fs setting
    CASE "w" { RETURN 3; } //wrd entity setting
    CASE "r" { RETURN 4; } //formresult attachment
  }
  THROW NEW Exception(`Unrecognized blobsource '${wrapped.__blobsource}'`);
}

/** @short Get the URL to a cached preprocessed image file
    @param wrappedimage Wrapped image record
    @param processingmethod Processing method, which can optionally contain an extra BASEURL cell
    @cell(string) processingmethod.method Resize method ('none' for no resizing)
    @cell(string) processingmethod.baseurl Base URL for the resulting URL.
    @return Link to the image. Empty string if a default record or non-image is passed */
PUBLIC STRING FUNCTION GetCachedImageLink(RECORD wrappedimage, RECORD processingmethod)
{
  IF(NOT RecordExists(wrappedimage))
    RETURN "";
  IF(NOT CellExists(wrappedimage, "__BLOBSOURCE") OR wrappedimage.__blobsource = "")
    THROW NEW Exception("GetCachedImageLink requires a WHFS Setting, WRD Setting or WHFSObject GetWrapped() record");

  STRING baseurl := CellExists(processingmethod, "BASEURL") ? processingmethod.baseurl : "";
  DELETE CELL baseurl FROM processingmethod;

  IF(NOT CellExists(processingmethod, "FILENAME") AND CellExists(wrappedimage,"FILENAME"))
    processingmethod := CELL[...processingmethod, filename := GetSafeFilename(wrappedimage.filename) ];

  INTEGER objid := ToInteger(Substring(wrappedimage.__blobsource, 1), 0);
  RETURN GetUnifiedCacheURL(baseurl, 1, TypeFromBlobSource(wrappedimage), objid, processingmethod);
}

/** @short Get the URL to a cached file
    @param wrappedfile Wrapped file record
    @param options Optional record with extra settings
    @cell options.baseurl
    @cell options.filename Filename to use in the URL
    @cell options.embed The returned URL should serve itself without a content-disposition: attachment
    @cell options.allowanyextension Do not strip unknown file extentions
    @cell options.cachehost
    @cell options.hosthash
    @return Link to the file. Empty string if a default record is passed
*/
PUBLIC STRING FUNCTION GetCachedFileLink(RECORD wrappedfile, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF(NOT RecordExists(wrappedfile))
    RETURN "";
  IF(NOT CellExists(wrappedfile, "__BLOBSOURCE") OR wrappedfile.__blobsource = "")
    THROW NEW Exception("GetCachedFileLink requires a WHFS Setting, WRD Setting or WHFSObject GetWrapped() record");

  STRING baseurl := CellExists(options,'baseurl') ? options.baseurl : '';
  DELETE CELL baseurl FROM options;

  IF(NOT CellExists(options, "FILENAME") AND CellExists(wrappedfile,"FILENAME"))
    options := CELL[...options, filename := GetSafeFilename(wrappedfile.filename) ];

  INTEGER objid := ToInteger(Substring(wrappedfile.__blobsource, 1), 0);
  RETURN GetUnifiedCacheURL(baseurl, 2, TypeFromBlobSource(wrappedfile), objid, options);
}

/** @short Get the URL and result of a cached preprocessed image file
    @param wrappedimage Wrapped image record
    @param processingmethod Processing method, which can optionally contain an extra BASEURL cell
    @return A record describing the image after applying the processing method, or a default record if no image is passed
    @cell(integer) return.width Image width in pixels
    @cell(integer) return.height Image height in pixels
    @cell(string) return.link Link to the image */
PUBLIC RECORD FUNCTION WrapCachedImage(RECORD wrappedimage, RECORD processingmethod)
{
  IF(NOT RecordExists(wrappedimage))
    RETURN DEFAULT RECORD;
  IF(NOT CellExists(wrappedimage, "__BLOBSOURCE") OR wrappedimage.__blobsource = "")
    THROW NEW Exception("WrapCachedImage requires a WHFS Setting, WRD Setting or WHFSObject GetWrapped() record");

  STRING link := GetCachedImageLink(wrappedimage, processingmethod);
  IF(link = "")
    RETURN DEFAULT RECORD;

  RECORD cleanedmethod := processingmethod;
  DELETE CELL baseurl, filename, cachehost, hostdata, hosthash FROM cleanedmethod;

  RECORD explained := ExplainImageProcessing(wrappedimage, cleanedmethod);

  // background-position to have the image centered towards the reference point when using the image as background-image with
  // background-size: cover
  STRING backgroundposition;
  IF (CellExists(explained, "REFPOINT") AND RecordExists(explained.refpoint)
      AND explained.outwidth > 0 AND explained.outheight > 0)
  {
    backgroundposition := FormatFloat(100f * explained.refpoint.x / explained.outwidth, 4) || "% "
                          || FormatFloat(100f * explained.refpoint.y / explained.outheight, 4) || "%";
  }

  RETURN [ width := explained.outwidth
         , height := explained.outheight
         , link := link
         , refpoint_backgroundposition := backgroundposition
         , dominantcolor := wrappedimage.dominantcolor
         , css := (wrappedimage.dominantcolor != "" ? wrappedimage.dominantcolor || " " : "")
                  || 'url("' || link || '") '
                  || (backgroundposition ?? "center")
                  || "/cover"
         ];
}

/** Get precalculated data, run in standalone job
    @param keydata Key data (not bound to calling library!)
    @param func Function to calculate values (format 'library#functionname'). Will be invoked with the specified keydata
        Its return value must be a record, and can have the following fields:
        - value: value (should be a record)
        - softttl: TTL in ms for soft expiry  (mutually exclusive with softexpiry)
        - softeventmasks: Event masks for soft expiry
        - softexpires: Date when item soft expires (mutually exclusive with softttl)
        - ttl: TTL in ms for expiry  (mutually exclusive with softexpiry)
        - eventmasks: Event masks for expiry
        - expires: Date when item expires (mutually exclusive with softttl)
        - crashretry: Cache period for crashes (retried after this period)
        - liverefreshtimeout: Max time to wait for new value after normal expiry (before falling back to cached value)

        Soft expiry and normal expiry both trigger background refresh. A soft expired value is returned immediately, a normal
        expired value is scheduled for refresh, and the new value is returned - except when that refresh crashes or runs past
        the liverefreshtimeout. In that cache, the old cached value is returned.

        Initial crashes are cached for 60 seconds.
    @cell options.waitforrefresh If TRUE, wait for recalculation of soft-expired data too (waiting until recalculation is finished, ignoring liverefreshtimeout)
    @return Precalculated data
*/
PUBLIC ASYNC FUNCTION GetPrecalculatedData(RECORD keydata, STRING func, RECORD options DEFAULTSTO CELL[])
{
  options := ValidateOptions(CELL[ waitforrefresh := FALSE ], options);
  OBJECT link := AWAIT OpenWebHareService("system:precalc");
  TRY
    RETURN AWAIT link->GetPrecalculatedData(keydata, func, options);
  FINALLY
    link->CloseService();
}

/** Throw this exception in a precalc calculation function to delete the query
*/
PUBLIC OBJECTTYPE PrecalcDiscardQueryException EXTEND Exception
<
  MACRO NEW()
  : Exception("precalc discarded query")
  {
  }

  UPDATE PUBLIC RECORD FUNCTION EncodeForIPC()
  {
    RETURN CELL[ ...Exception::EncodeForIPC(), type := "PrecalcDiscardQueryException" ];
  }
>;

RegisterReceivedExceptionType("PrecalcDiscardQueryException", PTR RestorePrecalcDiscardQueryException);

OBJECT FUNCTION RestorePrecalcDiscardQueryException(RECORD rec)
{
  OBJECT e := NEW PrecalcDiscardQueryException;
  e->trace := rec.trace;
  RETURN e;
}
