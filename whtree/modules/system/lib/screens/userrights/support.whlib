<?wh

LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/rightsmgmt.whlib";
LOADLIB "mod::system/lib/internal/webserver/support.whlib";
LOADLIB "mod::system/lib/userrights.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";


PUBLIC OBJECT __usereditcomposition;


INTEGER ARRAY FUNCTION MyGetExtraUnitRoots(OBJECT wrduser)
{
  IF (wrduser->entityid != 0)
    RETURN [ INTEGER(wrduser->GetParentUnitId()) ];

  RETURN DEFAULT INTEGER ARRAY;
}

/** Returns which specific authobjects (and thus the authobjects within)
    are visible for a specific user
*/
PUBLIC INTEGER ARRAY FUNCTION FilterAuthObjectsVisibleFor(INTEGER ARRAY authobjects, OBJECT wrduser)
{
  INTEGER ARRAY extra_roots;
  IF (wrduser->type = 1) // user
    extra_roots := MyGetExtraUnitRoots(wrduser);

  RECORD ARRAY paths := GetObjectsPaths([ "system:browseunits" ], wrduser->authobject, authobjects, extra_roots);
  RETURN
      SELECT AS INTEGER ARRAY objectid
        FROM paths
       WHERE LENGTH(path) != 0;
}

/** Returns whether a specific authobject (and thus the authobjects within)
    are visible for a specific user
*/
PUBLIC BOOLEAN FUNCTION MyIsAuthObjectVisibleFor(INTEGER authobject, OBJECT wrduser)
{
  IF (wrduser->HasRightOn("system:browseunits", authobject))
    RETURN TRUE;

  IF (wrduser->type = 1) // user
  {
    INTEGER ARRAY extra_roots := MyGetExtraUnitRoots(wrduser);
    WHILE (TRUE)
    {
      IF (authobject IN extra_roots)
        RETURN TRUE;

      IF (authobject = 0)
        RETURN FALSE;

      authobject := GetUnitOfAuthObject(authobject);
    }
  }
  RETURN FALSE;
}

/** Returns the ids of all the units that the user may see, but may not see their parents (or don't have parents)
    @param user User to check
    @return List of ids of all root viewable units
*/
PUBLIC INTEGER ARRAY FUNCTION GetRootViewableUnitAuthobjects(OBJECT wrduser)
{
  RETURN GetRootObjectsForRights([ "system:browseunits" ], wrduser->authobject, MyGetExtraUnitRoots(wrduser));
}

PUBLIC RECORD ARRAY FUNCTION EnrichWithAuthObjectIds(RECORD ARRAY inrows)
{
  STRING ARRAY getguids := SELECT AS STRING ARRAY wrd_guid FROM inrows;
  IF(Length(getguids)=0)
    RETURN DEFAULT RECORD ARRAY;

  RECORD ARRAY mapping :=
      SELECT id
           , parent
           , wrd_guid :=    guid
        FROM system.authobjects
       WHERE Length(getguids) = 1 ? guid = getguids[0] : TRUE
    ORDER BY guid;

  FOREVERY (RECORD rec FROM inrows)
  {
    RECORD pos := RecordLowerBound(mapping, rec, [ "WRD_GUID" ]);
    INSERT CELL authobjectid := pos.found ? mapping[pos.position].id : 0 INTO inrows[#rec];
    INSERT CELL authobjectparentid := pos.found ? mapping[pos.position].parent : 0 INTO inrows[#rec];
  }

  RETURN inrows;
}

/** @param userlist
    @cell userlist.unit
    @return
    @cell userlist.unitpath
*/
PUBLIC RECORD ARRAY FUNCTION EnrichWithUnitPath(RECORD ARRAY userlist, OBJECT user)
{
  INTEGER ARRAY no_rights_for;
  INTEGER ARRAY rights_for;

  INTEGER ARRAY extra_roots;
  IF (user->type = 1)
    extra_roots := MyGetExtraUnitRoots(user);

  RECORD ARRAY paths := GetObjectsPaths([ "system:browseunits" ], user->authobject, (SELECT AS INTEGER ARRAY authobjectparentid FROM userlist), extra_roots);

  INTEGER ARRAY all_unitids;
  FOREVERY (RECORD path FROM paths)
    all_unitids := all_unitids CONCAT path.path;

  all_unitids := SELECT AS INTEGER ARRAY DISTINCT id FROM ToRecordArray(all_unitids, "ID");

  RECORD ARRAY names :=
      SELECT id
           , name
        FROM system.authobjects
       WHERE id IN all_unitids
    ORDER BY id;

  FOREVERY (RECORD rec FROM userlist)
  {
    INTEGER unitid := rec.authobjectparentid;
    STRING path;

    IF (unitid = 0)
      path := GetTid("system:userrights.unitroot");
    ELSE
    {
      STRING ARRAY items;

      INTEGER ARRAY pathobjs := paths[RecordLowerBound(paths, [ objectid := unitid ], [ "OBJECTID" ]).position].path;
      FOREVERY (INTEGER unit FROM pathobjs)
      {
        RECORD pathrec := RecordLowerBound(names, [ id := unit ], [ "ID" ]);
        IF (pathrec.found)
          INSERT names[pathrec.position].name INTO items AT END;
      }

      path := Detokenize(items, "/");
    }
    INSERT CELL unitpath := path INTO userlist[#rec];
  }

  RETURN userlist;
}

// ---------------------------------------------------------------------------
//
// Unit trees
//

/** Returns a tree of all units visible for a user
    @param user
    @return Tree of units (root has rowkey -1!)
*/
PUBLIC RECORD ARRAY FUNCTION GetStaticUnitTree(OBJECT authapi, OBJECT user)
{
  BOOLEAN root_manageunit := user->HasRightOn("system:manageunit", 0);
  BOOLEAN root_manageroles := user->HasRightOn("system:manageroles", 0);

  INTEGER ARRAY root_manageunit_ids := root_manageunit ? DEFAULT INTEGER ARRAY : GetRootObjectsForRights([ "system:manageunit" ], user->EnsureAuthObject());
  INTEGER ARRAY root_manageroles_ids := root_manageroles ? DEFAULT INTEGER ARRAY : GetRootObjectsForRights([ "system:manageroles" ], user->EnsureAuthObject());

  RECORD ARRAY allunits := authapi->wrd_unit->RunQuery(
      [ outputcolumns :=
            [ wrd_id :=       "WRD_ID"
            , parent :=       "WRD_LEFTENTITY"
            , title :=        "WRD_TITLE"
            , description :=  "WHUSER_COMMENT"
            , wrd_guid :=     "WRD_GUID"
            ]
      ]);

  IF(NOT root_manageunit OR NOT root_manageroles) //for non-sysops, we need extra info because we need to do deep-tree right cehcks
    allunits := EnrichWithAuthObjectIds(allunits);

  RETURN
      [ [ rowkey :=             -1
        , wrd_id :=             0
        , title :=              GetTid("system:userrights.unitroot")
        , parent :=             0
        , type :=               2
        , subnodes :=           GetStaticUnitTreeIterate(0, user, root_manageunit, root_manageunit_ids, root_manageroles, root_manageroles_ids, allunits)
        , icon :=               2
        , iconoverlay :=        0
        , expanded :=           TRUE
        , canmanageunit :=      root_manageunit
        , canmanageroles :=     root_manageroles
        , candelete :=          FALSE
        , canselect :=          TRUE
        , isroot :=             TRUE
        ]
      ];
}


/** @param unitparent Id of parent
    @param user User object
    @param manageunit Whether user has has system:manageunit right on parent
    @param root_manageunit_ids Ids of root right-objects for right system:manageunit
    @param manageroles Whether user has has system:manageroles right on parent
    @param root_manageroles_ids Ids of root right-objects for right system:manageroles
*/
RECORD ARRAY FUNCTION GetStaticUnitTreeIterate(INTEGER unitparent, OBJECT user, BOOLEAN manageunit, INTEGER ARRAY root_manageunit_ids, BOOLEAN manageroles, INTEGER ARRAY root_manageroles_ids, RECORD ARRAY allunits)
{
  BOOLEAN unbrowsable_root := unitparent = 0 AND NOT MyIsAuthObjectVisibleFor(0, user);

  RECORD ARRAY nodes :=
      SELECT rowkey :=          wrd_id
           , wrd_id
           , title
           , parent
           , icon :=            2
           , iconoverlay :=     0
           , expanded :=        FALSE
           , canmanageunit :=   manageunit OR (authobjectid IN root_manageunit_ids)
           , canmanageroles :=  manageroles OR (authobjectid IN root_manageroles_ids)
           , canselect :=       TRUE
           , candelete :=       manageunit
           , isroot :=          FALSE
           , draginfo :=        [ type := "system:unit"
                                , data :=
                                      [ wrd_id :=     wrd_id
                                      , candelete :=  manageunit
                                      ]
                                ]
        FROM allunits
       WHERE (unbrowsable_root ? (authobjectid IN GetRootViewableUnitAuthobjects(user)) : (parent = unitparent))
    ORDER BY ToUppercase(title);

  RETURN
      SELECT *
           , subnodes :=        GetStaticUnitTreeIterate(rowkey, user, COLUMN canmanageunit, root_manageunit_ids, COLUMN canmanageroles, root_manageroles_ids, allunits)
        FROM nodes;
}

PUBLIC STRING FUNCTION GetAuthObjectPresentationName(OBJECT context, OBJECT wrdauthobj)
{
  // displays things such as "User 'sysop' (unit: 'WebHare')"
  RETURN GetTid("system:userrights.commondialogs.rights.authobjectfullid",
        ToString(wrdauthobj->type),
        wrdauthobj->GetUserRightsName(),
        GetUnitPath(context->controller->userapi, context->controller->userapi->GetUnitOf(wrdauthobj), context->user));
}

STRING FUNCTION GetUnitPath(OBJECT authapi, OBJECT unitobj, OBJECT browseuser)
{
  // Gather list of units toward root
  RECORD ARRAY units;
  INTEGER unitid := unitobj->entityid;
  WHILE (unitid != 0)
  {
    RECORD data := authapi->wrd_unit->GetEntityFields(unitid, [ "WRD_ID", "WRD_LEFTENTITY", "WRD_TITLE", "WRD_GUID" ]);
    IF (NOT RecordExists(data))
      BREAK;

    INSERT data INTO units AT 0;
    unitid := data.wrd_leftentity;
  }

  // Get the authobject ids
  units := EnrichWithAuthObjectIds(units);

  // Get the roots of visible units
  INTEGER ARRAY roots := GetRootViewableUnitAuthobjects(browseuser);
  IF (0 NOT IN roots)
  {
    // Remove invisible units
    WHILE (LENGTH(units) != 0 AND units[0].authobjectid NOT IN roots)
      DELETE FROM units AT 0;
  }

  IF (LENGTH(units) = 0 AND unitobj->entityid = 0)
    RETURN GetTid("system:userrights.common.rootunit");

  RETURN Detokenize((SELECT AS STRING ARRAY wrd_title FROM units), "/");
}

PUBLIC INTEGER ARRAY FUNCTION GetUsersEntityIdsWithRole(OBJECT authapi, OBJECT role)
{
  RETURN authapi->__GetRoleMembersByAuthObjectId(role->authobjectid);
}

PUBLIC INTEGER ARRAY FUNCTION GetRoleEntityIdsGrantedToUser(OBJECT authapi, OBJECT user)
{
  RETURN authapi->__GetRoleEntityIdsGrantedToUser(user->authobjectid);
}

PUBLIC STRING ARRAY FUNCTION GetFieldsFor(STRING ARRAY setfields, STRING type, OBJECT controller)
{
  type := ToLowerCase(type);
  STRING tag;
  IF(type = "person")
    tag := "WRD_" || ToUppercase(type);
  ELSE
    tag := "WHUSER_" || ToUppercase(type);
  STRING ARRAY availablefields := SELECT AS STRING ARRAY localtag FROM controller->userapi->wrdschema->GetType(tag)->ListAttributes(0) WHERE attributetype IN [ 2, 4 ];
  STRING ARRAY fields;
  FOREVERY(STRING field FROM setfields)
    IF(field IN availablefields)
      INSERT field INTO fields AT END;

  RETURN fields;
}

PUBLIC RECORD ARRAY FUNCTION EnrichWithOpenAs(RECORD ARRAY usersroles, OBJECT tolliumuser)
{
  BOOLEAN wearesysop := tolliumuser->HasRight("system:sysop");
  INTEGER ARRAY canopenas;
  IF(NOT wearesysop)
  {
    INTEGER ARRAY visibleobjects := (SELECT AS INTEGER ARRAY DISTINCT authobjectparentid FROM usersroles)
                                    CONCAT
                                    (SELECT AS INTEGER ARRAY authobjectid FROM usersroles);
    canopenas := tolliumuser->HasRightOnMultiple("system:openas", visibleobjects);
  }

  BOOLEAN ismagicsysopuser := wearesysop AND (SELECT AS STRING guid FROM system.authobjects WHERE id = tolliumuser->authobjectid) = "<overrideuser>";

  usersroles := SELECT *
                     , canopenas := issysop ? ismagicsysopuser : wearesysop OR authobjectparentid IN canopenas OR authobjectid IN canopenas
                 FROM usersroles;
  RETURN usersroles;
}

/** Returns a filtered list of users
    @param(object %TolliumControllerBase) controller Tollium controller
    @param filters WRD filters (for the WRD login type)
    @param(object %TolliumUser) tolliumuser Tollium user to calculate visiblity/rights for
    @return List of roles
    @cell(integer) return.rowkey WRD id of the user
    @cell(integer) return.wrd_id WRD id of the user
    @cell(integer) return.unit WRD id of the parent unit
    @cell(integer) return.authobjectid Authobject id of the user
    @cell(integer) return.authobjectidparentid Authobject id of the parent unit
    @cell(datetime) return.lastlogin Last login date
    @cell(integer) return.online Online status icon (3: online, 5: disabled)
    @cell(string) return.fullname Full name
    @cell(string) return.comment Comment
    @cell(boolean) return.online_login Sort value for online status
    @cell(string) return.name Login name of the user
    @cell(string) return.email E-mail address
    @cell(integer) return.type Always 1 (user)
    @cell(integer) return.icon Icon (1: normal user, 2: role, 3: unit, 5: disabled user, 6: sysop)
    @cell(boolean) return.isrole Always FALSE
    @cell(boolean) return.canedit Whether the passed user can edit this user
    @cell(boolean) return.candelete Whether the passed user can delete this user
    @cell(boolean) return.canopenas Whether the passed user can login as this user
    @cell(record) return.draginfo Drag info (for drag and dropping this user)
*/
PUBLIC RECORD ARRAY FUNCTION GetUsersByFilter(OBJECT controller, RECORD ARRAY filters, OBJECT tolliumuser)
{
  RECORD outcols := [ wrd_id :=       "WRD_ID"
                    , disabled :=     "WHUSER_DISABLED"
                    , realname :=     "WRD_TITLE"
                    , email :=        controller->userapi->wrdschema->accountemailtag
                    , login :=        controller->userapi->wrdschema->accountlogintag
                    , wrd_guid :=     "WRD_GUID"
                    , unit :=         "WHUSER_UNIT"
                    , comment :=      "WHUSER_COMMENT"
                    ];

  IF(ObjectExists(controller->wrdauthplugin) AND controller->wrdauthplugin->GetWRDAuthDomain()->lastloginfieldtag != "")
    INSERT CELL lastlogin := controller->wrdauthplugin->GetWRDAuthDomain()->lastloginfieldtag INTO outcols;

  RECORD ARRAY userlist := controller->userapi->wrdschema->accounttype->RunQuery(
        [ outputcolumns := outcols
        , filters :=       filters
       ]);
  userlist := EnrichWithAuthObjectIds(userlist);
  INTEGER ARRAY onlineusers := GetOnlineUsersIDs();

  INTEGER ARRAY visible_authobjects := FilterAuthObjectsVisibleFor((SELECT AS INTEGER ARRAY authobjectid FROM userlist), tolliumuser);
  DELETE FROM userlist WHERE authobjectid NOT IN visible_authobjects;

  BOOLEAN wearesysop := tolliumuser->HasRight("system:sysop");
  INTEGER ARRAY canmanage;
  IF(NOT wearesysop)
    canmanage := tolliumuser->HasRightOnMultiple("system:manageunit", visible_authobjects CONCAT SELECT AS INTEGER ARRAY authobjectparentid FROM userlist);

  INTEGER ARRAY allsysops := GetGrantedAuthObjects("system:sysop", 0);
  userlist := SELECT TEMPORARY candelete := wearesysop OR authobjectparentid IN canmanage
                   , TEMPORARY canedit := candelete OR authobjectid IN canmanage
                   , TEMPORARY issysop := authobjectid IN allsysops
                   , issysop :=         issysop
                   , rowkey :=          wrd_id
                   , wrd_id
                   , unit
                   , authobjectid
                   , authobjectparentid
                   , disabled :=        disabled
                   , lastlogin :=       CellExists(outcols, 'lastlogin') ? userlist.lastlogin : DEFAULT DATETIME
                   , online :=          disabled ? 5 : authobjectid IN onlineusers ? 3 : 0 //FIXME want to detect onlineusers by WRDID, not USERID
                   , fullname :=        realname
                   , comment :=         comment
                   , online_login :=    (authobjectid IN onlineusers ? 0 : 1) || realname
                   , name :=            login
                   , email
                   , type :=            1 // user
                   , icon :=            disabled ? 5 : issysop ? 6 : 1
                   , isrole :=          FALSE
                   , canedit :=         canedit
                   , candelete :=       candelete
                   //FIXME can we merge our canopenas formula with userapi.whlib's impersonation validation?
                   , draginfo :=        [ type := "system:user"
                                        , data := [ id := wrd_id, candelete := candelete ]
                                        ]
              FROM userlist;
  RETURN userlist;
}

/** Returns a filtered list of roles
    @param(object %TolliumControllerBase) controller Tollium controller
    @param filters WRD filters (for the WRD type 'wrd_role')
    @param(object %TolliumUser) tolliumuser Tollium user to calculate visiblity/rights for
    @return List of roles
    @cell(integer) return.rowkey WRD id of the role
    @cell(integer) return.wrd_id WRD id of the role
    @cell(integer) return.unit WRD id of the parent unit
    @cell(integer) return.authobjectid Authobject id of the role
    @cell(integer) return.authobjectidparentid Authobject id of the parent unit
    @cell(datetime) return.lastlogin Last login date, always DEFAULT DATETIME
    @cell(integer) return.online Online status icon, always 0
    @cell(string) return.fullname Full name, always empty
    @cell(string) return.comment Comment
    @cell(boolean) return.online_login Sort value for online status
    @cell(string) return.name Name of the role
    @cell(string) return.email E-mail address
    @cell(integer) return.type Always 3 (role)
    @cell(integer) return.icon Icon (1: normal user, 2: role, 3: unit, 5: disabled user, 6: sysop), always 2
    @cell(boolean) return.isrole Always TRUE
    @cell(boolean) return.canedit Whether the passed user can edit this role
    @cell(boolean) return.candelete Whether the passed user can delete this role
    @cell(boolean) return.canopenas Whether the passed user can login as this role (always FALSE)
    @cell(record) return.draginfo Drag info (for drag and dropping this role)
*/
PUBLIC RECORD ARRAY FUNCTION GetRolesByFilter(OBJECT controller, RECORD ARRAY filters, OBJECT tolliumuser)
{
  RECORD ARRAY rolelist := EnrichWithAuthObjectIds(controller->userapi->wrd_role->RunQuery(
        [ outputcolumns :=  [ wrd_id :=     "WRD_ID"
                            , wrd_title :=  "WRD_TITLE"
                            , wrd_guid :=   "WRD_GUID"
                            , unit :=       "WRD_LEFTENTITY"
                            , comment :=    "WHUSER_COMMENT"
                            ]
        , filters :=        filters
        ]));

  INTEGER ARRAY visible_authobjects := FilterAuthObjectsVisibleFor((SELECT AS INTEGER ARRAY authobjectid FROM rolelist), tolliumuser);
  DELETE FROM rolelist WHERE authobjectid NOT IN visible_authobjects;

  INTEGER ARRAY canmanageroles := tolliumuser->HasRightOnMultiple("system:manageroles", visible_authobjects CONCAT SELECT AS INTEGER ARRAY authobjectparentid FROM rolelist);

  INTEGER ARRAY allsysops := GetGrantedAuthObjects("system:sysop", 0, [expandroles := FALSE, inherited := FALSE]);
  RETURN
      SELECT rowkey :=          wrd_id
           , issysop :=         authobjectid IN allsysops
           , wrd_id
           , unit
           , authobjectid
           , authobjectparentid
           , lastlogin := DEFAULT DATETIME
           , online :=          0
           , fullname :=        ""
           , comment :=         comment
           , online_login :=    "2_" || wrd_title // used to make online column sort on online status+name
           , name :=            wrd_title
           , email :=           ""
           , type :=            3 // role
           , icon :=            2
           , isrole :=          TRUE
           , canedit :=         authobjectparentid IN canmanageroles OR authobjectid IN canmanageroles
           , candelete :=       authobjectparentid IN canmanageroles
           , draginfo :=        [ type := "system:role"
                                , data := [ id := wrd_id, candelete := authobjectparentid IN canmanageroles ]
                                ]
        FROM rolelist;
}

/** Returns a filtered list of units
    @param(object %TolliumControllerBase) controller Tollium controller
    @param filters WRD filters (for the WRD type 'wrd_unit')
    @param(object %TolliumUser) tolliumuser Tollium user to calculate visiblity/rights for
    @return List of roles
    @cell(integer) return.rowkey WRD id of the unit
    @cell(integer) return.wrd_id WRD id of the unit
    @cell(integer) return.unit WRD id of the parent unit
    @cell(integer) return.authobjectid Authobject id of the unit
    @cell(integer) return.authobjectidparentid Authobject id of the parent unit
    @cell(integer) return.online Online status icon, always 0
    @cell(string) return.fullname Full name, always empty
    @cell(string) return.comment Comment
    @cell(string) return.name Name of the unit
    @cell(string) return.email E-mail address (always empty)
    @cell(integer) return.type Always 2 (unit)
    @cell(integer) return.icon Icon (1: normal user, 2: role, 3: unit, 5: disabled user, 6: sysop), always 3.
    @cell(boolean) return.isrole Always FALSE
    @cell(boolean) return.canedit Whether the passed user can edit this unit
    @cell(boolean) return.candelete Whether the passed user can delete this unit
    @cell(boolean) return.canopenas Whether the passed user can login as this unit (always FALSE)
    @cell(record) return.draginfo Drag info (for drag and dropping this unit)
*/
PUBLIC RECORD ARRAY FUNCTION GetUnitsByFilter(OBJECT controller, RECORD ARRAY filters, OBJECT tolliumuser)
{
  RECORD ARRAY unitlist := EnrichWithAuthObjectIds(controller->userapi->wrd_unit->RunQuery(
        [ outputcolumns := [ wrd_id :=      "WRD_ID"
                           , wrd_title :=   "WRD_TITLE"
                           , wrd_guid :=    "WRD_GUID"
                           , comment :=     "WHUSER_COMMENT"
                           ]
        , filters := filters
        ]));

  INTEGER ARRAY visible_authobjects := FilterAuthObjectsVisibleFor((SELECT AS INTEGER ARRAY authobjectid FROM unitlist), tolliumuser);
  DELETE FROM unitlist WHERE authobjectid NOT IN visible_authobjects;

  INTEGER ARRAY canmanageunits := tolliumuser->HasRightOnMultiple("system:manageunit", visible_authobjects CONCAT SELECT AS INTEGER ARRAY authobjectid FROM unitlist);

  RETURN
      SELECT rowkey :=          wrd_id
           , wrd_id
           , unit :=            wrd_id
           , authobjectid
           , authobjectparentid
           , online :=          0
           , fullname :=        ""
           , comment :=         comment
           , name :=            wrd_title
           , email :=           ""
           , type :=            2 // unit
           , icon :=            3
           , isrole :=          FALSE
           , canedit :=         authobjectid IN canmanageunits OR wrd_id IN canmanageunits
           , candelete :=       authobjectid IN canmanageunits
           , draginfo :=        [ type := "system:unit"
                                , data :=
                                      [ wrd_id :=     wrd_id
                                      , candelete :=  authobjectid IN canmanageunits
                                      ]
                                ]
        FROM unitlist;

}

// -----------------------------------------------------------------------------
//
// Rights querying
//

BOOLEAN FUNCTION UserHasDirectGrantFor(STRING rightname, OBJECT grantee, INTEGER objectid, BOOLEAN onlywithgrantoption)
{
  INTEGER ARRAY grantobjids := GetObjectIdsOfDirectGrantsTo(rightname, grantee->authobject, onlywithgrantoption);
  RETURN (objectid IN grantobjids);
}

PUBLIC MACRO TolliumGrantRoleTo(OBJECT contexts, OBJECT work, OBJECT roleobj, OBJECT ARRAY grantees, STRING comment)
{
  IF (NOT contexts->user->HasRightOn("system:manageroles", roleobj->authobjectid))
  {
    work->AddError(GetTid("system:userrights.commondialogs.errors.norighttomanagerole", roleobj->GetUserRightsName()));
    RETURN;
  }

  IF (NOT roleobj->ExistsInDatabase())
  {
    work->AddError(GetTid("system:userrights.commondialogs.errors.rolehasbeendeleted", roleobj->GetUserRightsName()));
    RETURN;
  }

  FOREVERY (OBJECT obj FROM grantees)
    IF (NOT obj->ExistsInDatabase())
    {
      IF (obj->type = 3)
        work->AddError(GetTid("system:userrights.commondialogs.errors.rolehasbeendeleted", obj->GetUserRightsName()));
      ELSE
        work->AddError(GetTid("system:userrights.commondialogs.errors.userhasbeendeleted", obj->GetUserRightsName()));
    }

  IF (work->HasFailed())
    RETURN;

  OBJECT roleunit := contexts->userapi->GetUnitOf(roleobj);

  FOREVERY (OBJECT obj FROM grantees)
  {
    // User either should have the right to browse the new role, or should get it with the new role
    IF (NOT roleunit->IsVisibleFor(obj) AND NOT roleunit->IsVisibleFor(roleobj))
      work->AddWarning(GetTid("system:userrights.commondialogs.errors.usercannotviewunitofrole", obj->GetUserRightsName(), roleobj->GetUserRightsName()));
  }

  FOREVERY (OBJECT obj FROM grantees)
  {
    LogAuditEvent("system:userrights", CELL[ action :=  "grant-role"
                                           , grantee := obj->GetUserDataForLogging()
                                           , roleauthobjectid := roleobj->authobjectid
                                           , roleentityid := roleobj->entityid
                                           , rolename := roleobj->GetUserRightsName()
                                           , comment
                                           ]);
    TRY
    {
      contexts->user->GrantRoleTo(roleobj, obj, [ comment := comment ]);
    }
    CATCH (OBJECT e)
    {
      work->AddError(e->what);
    }
  }
}

PUBLIC MACRO TolliumRevokeRoleFrom(OBJECT contexts, OBJECT work, OBJECT roleobj, OBJECT ARRAY grantees)
{
  IF (NOT contexts->user->HasRightOn("system:manageroles", roleobj->authobjectid))
  {
    work->AddError(GetTid("system:userrights.commondialogs.errors.norighttorevokerole", roleobj->GetUserRightsName()));
    RETURN;
  }

  IF (NOT roleobj->ExistsInDatabase())
  {
    work->AddError(GetTid("system:userrights.commondialogs.errors.rolehasbeendeleted", roleobj->GetUserRightsName()));
    RETURN;
  }

  FOREVERY (OBJECT obj FROM grantees)
    IF (NOT obj->ExistsInDatabase())
    {
      IF (obj->type = 3)
        work->AddError(GetTid("system:userrights.commondialogs.errors.rolehasbeendeleted", obj->GetUserRightsName()));
      ELSE
        work->AddError(GetTid("system:userrights.commondialogs.errors.userhasbeendeleted", obj->GetUserRightsName()));
    }

  IF (work->HasFailed())
    RETURN;

  FOREVERY (OBJECT obj FROM grantees)
  {
    LogAuditEvent("system:userrights", CELL[ action :=  "revoke-role"
                                           , grantee := obj->GetUserDataForLogging()
                                           , roleauthobjectid := roleobj->authobjectid
                                           , roleentityid := roleobj->entityid
                                           , rolename := roleobj->GetUserRightsName()
                                           ]);
    TRY
    {
      contexts->user->RevokeRoleFrom(roleobj, obj);
    }
    CATCH (OBJECT e)
    {
      work->AddError(e->what);
    }
  }
}

MACRO LogRightAction(BOOLEAN isgrant, OBJECT grantor, OBJECT grantee, STRING right_name, INTEGER ARRAY objectids, BOOLEAN withgrantoption, STRING comment)
{
}

PUBLIC MACRO TolliumGrantRightTo(OBJECT work, OBJECT rightsinfo, OBJECT grantor, OBJECT grantee, STRING right_name, INTEGER ARRAY objectids, BOOLEAN withgrantoption, STRING comment)
{
  BOOLEAN right_is_global := IsRightGlobal(right_name);

  IF (right_is_global)
  {
    IF (NOT grantor->CanManageRight(right_name))
    {
      work->AddError(GetTid('system:userrights.errors.notallowedtomanageright', rightsinfo->GetRightTitle(right_name)));
      RETURN;
    }

    IF (UserHasDirectGrantFor(right_name, grantee, 0, withgrantoption))
      RETURN;

  }
  ELSE
  {
    objectids :=
        SELECT AS INTEGER ARRAY id
          FROM ToRecordArray(objectids, "ID")
         WHERE NOT UserHasDirectGrantFor(right_name, grantee, id, withgrantoption);

    IF (LENGTH(objectids) = 0)
      RETURN;

    FOREVERY (INTEGER objectid FROM objectids)
    {
      IF (NOT grantor->CanManageRightOn(right_name, objectid))
        work->AddError(GetTid('system:userrights.errors.notallowedtomanageright', rightsinfo->GetRightTitle(right_name)));
    }

    IF (work->HasFailed())
      RETURN;
  }

  TRY
  {
    LogAuditEvent("system:userrights", CELL[ action :=  "grant-right"
                                           , grantee := grantee->GetUserDataForLogging()
                                           , right := right_name
                                           , objectids
                                           , withgrantoption
                                           , comment
                                           ]);

    IF (right_is_global)
      grantor->GrantRightTo(right_name, grantee, withgrantoption, FALSE, comment);
    ELSE FOREVERY (INTEGER objectid FROM objectids)
      grantor->GrantRightToOn(right_name, grantee, objectid, withgrantoption, FALSE, comment);
  }
  CATCH (OBJECT e)
  {
    work->AddError(e->what);
  }
}

PUBLIC BOOLEAN FUNCTION IsRevokeDangerous(OBJECT grantor, OBJECT grantee, STRING right_name, INTEGER objectid)
{
  RECORD ARRAY other_grantor_grants :=
      SELECT *
        FROM ExplainRightGrantedToOn(right_name, grantor->authobject, objectid, FALSE)
       WHERE withgrantoption
         AND (grantedright != right_name
           OR grantedobject != objectid
           OR COLUMN grantee != grantee->id);

  RETURN LENGTH(other_grantor_grants) = 0;
}

PUBLIC MACRO TolliumRevokeRightFrom(OBJECT work, OBJECT rightsinfo, OBJECT grantor, OBJECT grantee, STRING right_name, INTEGER objectid, BOOLEAN onlyremovegrantoption)
{
  BOOLEAN right_is_global := IsRightGlobal(right_name);

  IF (NOT UserHasDirectGrantFor(right_name, grantee, objectid, onlyremovegrantoption))
    RETURN;

  IF (right_is_global)
  {
    IF (NOT grantor->CanManageRight(right_name))
    {
      work->AddError(GetTid('system:userrights.errors.notallowedtomanageright', rightsinfo->GetRightTitle(right_name)));
      RETURN;
    }
  }
  ELSE
  {
    IF (NOT grantor->CanManageRightOn(right_name, objectid))
    {
      work->AddError(GetTid('system:userrights.errors.notallowedtomanageright', rightsinfo->GetRightTitle(right_name)));
      RETURN;
    }
  }

  TRY
  {
    LogAuditEvent("system:userrights", CELL[ action :=  "revoke-right"
                                           , grantee := grantee->GetUserDataForLogging()
                                           , right := right_name
                                           , objectids := right_is_global ? INTEGER[] : INTEGER[objectid]
                                           ]);

    IF (right_is_global)
      grantor->RevokeRightFrom(right_name, grantee, onlyremovegrantoption);
    ELSE
      grantor->RevokeRightFromOn(right_name, grantee, objectid, onlyremovegrantoption);
  }
  CATCH (OBJECT e)
  {
    work->AddError(e->what);
  }
}

PUBLIC RECORD ARRAY FUNCTION ConstructSearchFilters(STRING term, STRING type, STRING ARRAY fields)
{
  STRING ARRAY parts := Tokenize(term, " ");

  RECORD ARRAY filters;
  FOREVERY(STRING part FROM parts)
  {
    RECORD ARRAY partfilters;
    FOREVERY(STRING field FROM fields)
      INSERT [ field := field, matchtype := "LIKE", value := "*" || part || "*" ] INTO partfilters AT END;

    INSERT [ type := "OR", filters := partfilters ] INTO filters AT END;
  }

  RETURN [ [ type := "AND", filters := filters ] ];
}

PUBLIC RECORD FUNCTION CollectUserPreferenceOptions(OBJECT tolliumcontroller)
{
  // Fill language options
  RECORD ARRAY languages;
  FOREVERY (STRING lang FROM ["en", "nl"]) //FIXME: Use the proper langfile option to detect de/jp if available
  {
    // Make the language editor understand the following lines
    IF (lang = "en")
      INSERT [ rowkey := lang, title := GetTid("system:userrights.edituser.prefslang_en") ] INTO languages AT END;
    ELSE IF (lang = "nl")
      INSERT [ rowkey := lang, title := GetTid("system:userrights.edituser.prefslang_nl") ] INTO languages AT END;
  }

  // Decimal separators
  RECORD ARRAY decimalseps := [[ rowkey := ".", title := GetTid("system:userrights.edituser.dot") ]
                              ,[ rowkey := ",", title := GetTid("system:userrights.edituser.comma") ]
                              ,[ rowkey := ":", title := GetTid("system:userrights.edituser.colon") ]
                              ];

  // Thousand separators
  RECORD ARRAY thousandseps := [[ rowkey := "", title := GetTid("system:userrights.edituser.none") ]
                               ,[ rowkey := " ", title := GetTid("system:userrights.edituser.space") ]
                               ,[ rowkey := ".", title := GetTid("system:userrights.edituser.dot") ]
                               ,[ rowkey := ",", title := GetTid("system:userrights.edituser.comma") ]
                               ,[ rowkey := "'", title := GetTid("system:userrights.edituser.apostrophe") ]
                               ];

  RETURN [ languages := languages
         , decimalseps := decimalseps
         , thousandseps := thousandseps
         ];
}

PUBLIC RECORD FUNCTION GetPolicyForUser(OBJECT contexts, INTEGER user)
{
  STRING ARRAY getfields := [ "WHUSER_UNIT"
                            , contexts->controller->wrdauthplugin->wrdschema->accountlogintag
                            ];
  IF(contexts->controller->wrdauthplugin->wrdschema->accountemailtag != contexts->controller->wrdauthplugin->wrdschema->accountlogintag)
    INSERT contexts->controller->wrdauthplugin->wrdschema->accountemailtag INTO getfields AT END;

  RECORD fields;
  RECORD userfields := contexts->controller->wrdauthplugin->wrdschema->accounttype->GetEntityFields(user, getfields);
  IF(RecordExists(userfields))
  {
    fields := [ username := GetCell(userfields, contexts->controller->wrdauthplugin->wrdschema->accountlogintag)
              , email :=    GetCell(userfields, contexts->controller->wrdauthplugin->wrdschema->accountemailtag)
              , unit :=     userfields.whuser_unit
              ];
  }

  RETURN contexts->controller->wrdauthplugin->GetSupportObject()->GetUserEditPolicy(user, fields, FALSE);
}

PUBLIC MACRO ConfigurePasswordFieldForPolicy(OBJECT pwdfield, RECORD policy)
{
  pwdfield->visible := policy.haspassword;
  pwdfield->cellname := pwdfield->contexts->controller->userapi->wrdschema->accountpasswordtag;
  pwdfield->validationchecks := policy.passwordvalidationchecks;
  pwdfield->policy := policy.passwordpolicy;
  pwdfield->onpolicycheck := policy.passwordcheck;
}
