<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/debugger/commonactions.whlib";
LOADLIB "mod::system/lib/internal/debugger/profilingsupport.whlib";
LOADLIB "mod::system/lib/internal/modules/devhooks.whlib";

LOADLIB "mod::tollium/lib/applications.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

CONSTANT STRING portname := "system:profiles";

PUBLIC STATIC OBJECTTYPE Main EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /** List of profiles
      @cell when Time profile was reported
      @cell data Profile data
      @cell data.type Type (memoryprofile, functionprofile)
      @cell data.rawdata Raw profiledata
  */
  RECORD ARRAY pvt_profiles;

  OBJECT port;

  OBJECT whmanagerconn;

  INTEGER counter;

  OBJECT ARRAY links;

  RECORD basecolumns;

  OBJECT currenthandler;

  STRING lasttype;

  RECORD ARRAY states;

  RECORD lastselectedfunction;

  RECORD lastselectedname;

  STRING profiledir;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->basecolumns :=
        [ functionslist :=  ^functionslist->columns
        , childrencalls :=  ^childrencalls->columns
        , parentcalls :=    ^parentcalls->columns
        , nameslist :=      ^nameslist->columns
        , stacktracelist := ^stacktracelist->columns
        ];

    IF (CellExists(data, "FROMDEBUGGER"))
    {
      this->pvt_profiles :=
          SELECT TEMPORARY handler := this->GetHandler(type)
               , id :=          #profiles + 1
               , when
               , source
               , command
               , type
               , info :=        handler->GetInfoFromRawData(rawdata)
               , processed :=   FALSE
               , rawdata :=     rawdata
               , handler :=     handler
            FROM data.profiles;

      DELETE FROM ^profileslist->columns WHERE name = "source";

      ^session->visible := FALSE;
      this->RefreshProfileList();
      ^profileslist->value := LENGTH(this->pvt_profiles);
    }
    ELSE
    {
      STRING session := Detokenize(data.params, " ") ?? "live";
      IF(session = "live" AND TestExclusiveLocked([ systemprofiles := portname ])) //live is not available so go for default (Perhaps we should show a profile session selector instead? or 'live' shouldn't require locking)
        session := "default";

      IF (session LIKE "/*")
      {
        this->ReloadSessions([ custom := session ]);
        ^session->value := "custom";
      }
      ELSE
      {
        this->ReloadSessions();
        ^session->value := session = "live" ? "live" : `session:${session}`;
      }

      ^session->onchange := PTR this->GotSessionChange; //not set earlier to prevent it triggering an exclusive lock in ReloadSessions
      this->GotSessionChange();
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotUnload()
  {
    IF (ObjectExists(this->whmanagerconn))
    {
      this->whmanagerconn->Close();
      this->whmanagerconn := DEFAULT OBJECT;
    }
    IF (ObjectExists(this->port))
    {
      UnregisterCallback(this->port->userdata.reg);
      this->port->Close();
      this->port := DEFAULT OBJECT;
    }
    this->ReleaseExclusiveAccess();
  }

  MACRO GotSessionChange()
  {
    this->GotUnload();

    IF (^session->value = "live")
    {
      IF (NOT this->GetExclusiveAccess([ systemprofiles := portname ], [ onbeforesteal := PTR this->GotUnload ]))
        RETURN;

      this->port := CreateIPCPort(portname);
      this->whmanagerconn := ConnectToIPCPort("system:whmanager");
      this->whmanagerconn->SendMessage([ type := "register", port := portname ]);

      RECORD res := this->whmanagerconn->ReceiveMessage(MAX_DATETIME);
      IF (res.status != "ok" OR NOT res.msg.success)
      {
        this->port->Close();
        THROW NEW Exception("Could not register profile monitor global port");
      }

      this->port->userdata := [ reg := RegisterHandleReadCallback(this->port->handle, PTR this->OnIncomingConnection()) ];
      this->pvt_profiles := RECORD[];
      this->RefreshProfileList();
    }
    ELSE IF (^session->value != "")
    {
      this->profiledir := RecordExists(^session->selection) ? ^session->selection.path : "";

      ^diskprofilelistener->masks := [ "system:storedprofile." || ^session->selection.name ];
      this->UpdateProfilesFromDisk();
      ^profileslist->value := 1;
    }
    ELSE
    {

    }
  }

  MACRO OnIncomingConnection()
  {
    OBJECT link := this->port->Accept(DEFAULT DATETIME);
    IF (ObjectExists(link))
    {
      IF (^session->value != "live")
      {
        link->Close();
        RETURN;
      }

      link->userdata := [ reg := RegisterHandleReadCallback(link->handle, PTR this->OnLinkSignalled(link)) ];
      INSERT link INTO this->links AT END;
    }
  }


  MACRO OnLinkSignalled(OBJECT link)
  {
    RECORD res := link->ReceiveMessage(DEFAULT DATETIME);
    SWITCH (res.status)
    {
      CASE "timeout"
      {
        RETURN;
      }
      CASE "gone"
      {
        UnregisterCallback(link->userdata.reg);
        link->Close();
        INTEGER pos := SearchElement(this->links, link);
        DELETE FROM this->links AT pos;
        RETURN;
      }
      CASE "ok"
      {
        IF (^session->value != "live")
          RETURN;

        SWITCH (res.msg.task)
        {
          CASE "addprofile"
          {
            // Send immediately
            link->SendReply([ type := "ack" ], res.msgid);
            IF (res.msg.source = "webserver" AND res.msg.command = "system:profiles")
              RETURN;

            OBJECT handler := this->GetHandler(res.msg.type);

            this->counter := this->counter + 1;
            RECORD rec :=
                [ id :=             this->counter
                , when :=           res.msg.start
                , source :=         res.msg.source
                , command :=        res.msg.command
                , type :=           res.msg.type
                , info :=           handler->GetInfoFromRawData(res.msg.rawdata)
                , processed :=      FALSE
                , rawdata :=        res.msg.rawdata
                , handler :=        handler
                ];

            INSERT rec INTO this->pvt_profiles AT END;
            this->RefreshProfileList();
          }
        }
      }
    }
  }

  MACRO OnNewStoredProfile(RECORD ARRAY events)
  {
    this->UpdateProfilesFromDisk();
  }

  MACRO OnProfileSelected()
  {
    this->RefreshMainLists();
  }

  MACRO OnFunctionSelected()
  {
    ^parentcalls->ReloadList();
    ^childrencalls->ReloadList();

    IF (RecordExists(^functionslist->selection))
    {
      INSERT ^functionslist->value INTO ^parentcalls->expanded AT END;
      INSERT ^functionslist->value INTO ^childrencalls->expanded AT END;
    }
  }

  MACRO OnNameSelected()
  {
    ^stacktracelist->ReloadList();
  }

  // ---------------------------------------------------------------------------
  //
  // List refreshes
  //

  MACRO ReloadSessions(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ custom :=   ""
        ], options);

    RECORD ARRAY sessions :=
        SELECT rowkey :=        `session:${name}`
             , title :=         name
             , name
             , path
          FROM ReadDiskDirectory(MergePath(GetWebhareConfiguration().basedataroot, "caches/platform/hs-profiles"), "*")
         WHERE type = 1
      ORDER BY name;

    RECORD defaultsession :=
        [ rowkey :=     `session:default`
        , title :=      "default"
        , name :=       "default"
        , path :=       MergePath(GetWebhareConfiguration().basedataroot, "caches/platform/hs-profiles/default")
        ];

    RECORD pos := RecordLowerBound(sessions, defaultsession, [ "NAME" ]);
    IF (NOT pos.found)
      INSERT defaultsession INTO sessions AT pos.position;

    ^session->options :=
        [ [ rowkey :=     "live"
          , path :=       "live"
          , title :=      this->GetTid(".live")
          ]
        , [ rowkey :=     "(divider2)"
          , isdivider :=  TRUE
          ]
        , ...(options.custom != ""
                ? [ [ rowkey :=     "custom"
                    , path :=       options.custom
                    , name :=       "(custom)"
                    , title :=      options.custom
                    ]
                  , [ rowkey :=     "(divider1)"
                    , isdivider :=  TRUE
                    ]
                  ]
                : RECORD[])
        , ...sessions
        ];
  }

  MACRO UpdateProfilesFromDisk()
  {
    UPDATE this->pvt_profiles SET exists := FALSE;

    RECORD ARRAY files;
    IF (this->profiledir NOT LIKE "*.zip")
      files := ReadDiskDirectory(this->profiledir, "*.prof");
    ELSE
    {
      files :=
          SELECT *
               , path := MergePath(path, name)
            FROM UnpackArchive(GetDiskResource(this->profiledir))
           WHERE name LIKE "*.prof";
    }
    FOREVERY (RECORD rec FROM files)
    {
      RECORD pos := RecordLowerBound(this->pvt_profiles, rec, [ "path" ]);
      IF (pos.found)
      {
        this->pvt_profiles[pos.position].exists := TRUE;
        CONTINUE;
      }

      BLOB filedata := CellExists(rec, "data") ? rec.data : GetDiskResource(rec.path);
      STRING firstline := BlobToString(filedata, 4 * 65536);
      INTEGER nlpos := SearchSubString(firstline, "\n");

      RECORD scriptdata := DecodeJSON(Left(firstline, nlpos));
      RECORD profiledata;
      TRY
      {
        profiledata := DecodeHSONBlob(MakeComposedBlob([ CELL[ data := filedata, start := nlpos + 1 ] ]));
      }
      CATCH(OBJECT e)
      {
        CONTINUE; //FIXME report
      }

      OBJECT handler := this->GetHandler(scriptdata.type);
      INSERT CELL
          [ id :=           #rec + 1
          , path :=         rec.path
          , when :=         MakeDateFromText(scriptdata.profilingstart)
          , source :=       scriptdata.script
          , command :=      scriptdata.script
          , type :=         scriptdata.type
          , info :=         handler->GetInfoFromRawData(profiledata)
          , processed :=    FALSE
          , rawdata :=      profiledata
          , handler
          , exists :=       TRUE
          ] INTO this->pvt_profiles AT pos.position;
    }

    DELETE FROM this->pvt_profiles WHERE NOT exists;
    this->RefreshProfileList();
  }

  MACRO RefreshProfileList()
  {
    ^profileslist->rows :=
        SELECT rowkey := id
             , when := GetMsecondCount(this->contexts->user->UTCToLocal(when))
             , source
             , command
             , type
             , info :=          info.text
             , infosortval :=   info.sortval
          FROM this->pvt_profiles;

    IF (RecordExists(^profileslist->selection))
      this->RefreshMainLists();
  }


  MACRO RefreshMainLists()
  {
    RECORD row := ^profileslist->selection;
    IF (NOT RecordExists(row))
    {
      this->currenthandler := DEFAULT OBJECT;
      ^childrencalls->visible := FALSE;
      ^parentcalls->visible := FALSE;
      ^functionslist->ReloadList();
      ^nameslist->ReloadList();
      this->lasttype := "";
    }
    ELSE
    {
      RECORD profdata := SELECT * FROM this->pvt_profiles WHERE id = row.rowkey;
      IF (NOT profdata.processed)
      {
        // Init with profiling data, then destroy that data
        profdata.handler->InitWithRawData(profdata.rawdata);
        UPDATE this->pvt_profiles
           SET rawdata :=   DEFAULT RECORD
             , processed := TRUE
         WHERE id = row.rowkey;
      }

      IF (^functionslist->visible AND RecordExists(^functionslist->selection))
        this->lastselectedfunction := ^functionslist->selection;
      IF (^nameslist->visible AND RecordExists(^nameslist->selection))
        this->lastselectedname := ^nameslist->selection;

      this->currenthandler := profdata.handler;
      IF (this->lasttype != this->currenthandler->GetType())
      {
        STRING ARRAY lists := this->currenthandler->GetShownLists();
        ^nameslist->visible := "names" IN lists;
        ^functionslist->visible := "functions" IN lists;
        ^childrencalls->visible := "children" IN lists;
        ^parentcalls->visible := "parents" IN lists;
        ^stacktracelist->visible := "stacktrace" IN lists;

        IF (this->lasttype != "")
          this->SaveInterfaceState(this->lasttype);
        this->lasttype := this->currenthandler->GetType();

        IF ("children" IN lists)
          this->ReconfigureList("childrencalls", "children");
        IF ("parents" IN lists)
          this->ReconfigureList("parentcalls", "parents");
        IF ("functions" IN lists)
          this->ReconfigureList("functionslist", "functions");
        IF ("names" IN lists)
          this->ReconfigureList("nameslist", "names");
        IF ("stacktrace" IN lists)
          this->ReconfigureList("stacktracelist", "stacktrace");

        ^ct_children->visible := ^childrencalls->visible;
        ^ct_parents->visible := ^parentcalls->visible;
        ^ct_trace->visible := ^stacktracelist->visible;
      }
      ELSE
      {
        IF (^functionslist->visible)
          ^functionslist->ReloadList();
        IF (^nameslist->visible)
          ^nameslist->ReloadList();
        IF (^childrencalls->visible)
          ^childrencalls->ReloadList();
        IF (^parentcalls->visible)
          ^parentcalls->ReloadList();
        IF (^stacktracelist->visible)
          ^stacktracelist->ReloadList();
      }
    }

    ^functionslistpart->visible := ^functionslist->visible;
    ^nameslistpart->visible := ^nameslist->visible;
    ^relationspart->visible := ^childrencalls->visible OR ^parentcalls->visible OR ^stacktracelist->visible;

    ^profileslist->borders.bottom := NOT ^relationspart->visible;
    ^nameslist->borders.bottom := NOT ^relationspart->visible;
    ^functionslist->borders.bottom := NOT ^relationspart->visible;

    IF (RecordExists(this->lastselectedfunction) AND ^functionslist->visible)
    {
      ^functionslist->selection :=
          SELECT *
            FROM ^functionslist->rows
           WHERE functionname = this->lastselectedfunction.functionname
             AND library = this->lastselectedfunction.library;
    }
    IF (RecordExists(this->lastselectedname) AND ^nameslist->visible)
    {
      ^nameslist->selection :=
          SELECT *
            FROM ^nameslist->rows
           WHERE name = this->lastselectedname.name
                 AND (CellExists(rows, "DEPTH") ? depth = 0 : TRUE)
           LIMIT 1;
    }
  }

  MACRO SaveInterfaceState(STRING handlertype)
  {
    DELETE FROM this->states WHERE COLUMN handlertype = VAR handlertype;
    FOREVERY (STRING compname FROM [ "functionslist", "childrencalls", "parentcalls", "nameslist" ])
    {
      INSERT
          [ handlertype :=    handlertype
          , compname :=       compname
          , sortcolumn :=     GetMember(this, compname)->sortcolumn
          , sortascending :=  GetMember(this, compname)->sortascending
          ] INTO this->states AT END;
    }
  }

  MACRO ReconfigureList(STRING compname, STRING nameforhandler)
  {
    RECORD ARRAY columns := GetCell(this->basecolumns, compname);
    OBJECT comp := GetMember(this, "^"||compname);

    RECORD config := this->currenthandler->GetListConfig(nameforhandler);

    columns := columns CONCAT config.datacolumns;
    IF (config.istree)
      columns[0].tree := TRUE;

    comp->columns := columns;

    RECORD sortconfig := SELECT * FROM this->states WHERE handlertype = this->currenthandler->GetType() AND COLUMN compname = VAR compname;
    IF (NOT RecordExists(sortconfig))
      sortconfig := config;

    comp->sortcolumn := CellExists(sortconfig, "SORTCOLUMN") ? sortconfig.sortcolumn : (config.datacolumns ?? columns)[0].name;
    comp->sortascending := CellExists(sortconfig, "SORTASCENDING") ? sortconfig.sortascending : FALSE;
  }

  // ---------------------------------------------------------------------------
  //
  // List refresh callbacks
  //

  RECORD ARRAY FUNCTION GetFunctionListRows(RECORD parentrow)
  {
    IF (NOT ObjectExists(this->currenthandler) OR NOT ^functionslist->visible)
      RETURN DEFAULT RECORD ARRAY;

    RETURN this->currenthandler->GetFunctionsListChildren(parentrow);
  }

  RECORD ARRAY FUNCTION GetNamesListRows(RECORD parentrow)
  {
    IF (NOT ObjectExists(this->currenthandler) OR NOT ^nameslist->visible)
      RETURN DEFAULT RECORD ARRAY;

    RETURN this->currenthandler->GetNamesListChildren(parentrow);
  }

  RECORD ARRAY FUNCTION GetParentListRows(RECORD parentrow)
  {
    RECORD funcsel := ^functionslist->selection;
    IF (NOT ObjectExists(this->currenthandler) OR NOT RecordExists(funcsel) OR NOT ^parentcalls->visible)
      RETURN DEFAULT RECORD ARRAY;

    RETURN this->currenthandler->GetParentsListChildren(funcsel, parentrow);
  }

  RECORD ARRAY FUNCTION GetChildrenListRows(RECORD parentrow)
  {
    RECORD funcsel := ^functionslist->selection;
    IF (NOT ObjectExists(this->currenthandler) OR NOT RecordExists(funcsel) OR NOT ^childrencalls->visible)
      RETURN DEFAULT RECORD ARRAY;

    RETURN this->currenthandler->GetChildrenListChildren(funcsel, parentrow);
  }

  RECORD ARRAY FUNCTION GetStackTraceRows()
  {
    RECORD funcsel := ^nameslist->selection;
    IF (NOT ObjectExists(this->currenthandler) OR NOT RecordExists(funcsel) OR NOT ^stacktracelist->visible)
      RETURN DEFAULT RECORD ARRAY;


    RETURN this->currenthandler->GetStackTraceRows(funcsel);
  }

  STRING ARRAY FUNCTION GetGenericPath(STRING rowkey)
  {
    STRING ARRAY elts := Tokenize(rowkey, "-");
    STRING ARRAY paths;
    FOR (INTEGER i := LENGTH(elts); i > 0; i := i - 1)
      INSERT Detokenize(ArraySlice(elts, 0, i), "-") INTO paths AT END;
    RETURN paths;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  OBJECT FUNCTION GetHandler(STRING type)
  {
    SWITCH (type)
    {
      CASE "functionprofile"  { RETURN NEW DisplayedFunctionProfile; }
      CASE "memoryprofile"    { RETURN NEW DisplayedMemoryProfile; }
      CASE "memorysnapshot"   { RETURN NEW DisplayedMemorySnapshot; }
      CASE "objectsnapshot"   { RETURN NEW DisplayedObjectsSnapshot; }
      CASE "blobreferences"   { RETURN NEW DisplayedBlobReferences; }
      CASE "handlelist"       { RETURN NEW DisplayedHandleList; }
      CASE "adhoccachelist"   { RETURN NEW DisplayedAdhocCacheList; }
    }
    THROW NEW Exception("Unknown rawdata type '" || type || "'");
  }

  MACRO OpenInEditor(RECORD selection)
  {
    STRING library := GetResourceNameFromDiskPath(selection.library, [ allowdiskpath := TRUE ]);
    RECORD posinfo := SELECT * FROM DescribeCompiledLibrary(library).functions WHERE mangledname = selection.functionname;

    posinfo := CELL[ ...posinfo, ...PickCells(selection, [ "line", "col" ]) ];
    IF(RecordExists(posinfo))
      LaunchOpenInEditor(this, library, CELL[ posinfo.line, posinfo.col ]);
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoChildOpen()
  {
    ^functionslist->value := ^childrencalls->selection.openrowkey;
  }

  MACRO DoEditSource()
  {
    this->OpenInEditor(^functionslist->selection);
  }

  MACRO DoEditChildrenCallSource()
  {
    this->OpenInEditor(^childrencalls->selection);
  }

  MACRO DoEditParentCallSource()
  {
    this->OpenInEditor(^parentcalls->selection);
  }

  MACRO DoEditStackTraceSource()
  {
    this->OpenInEditor(^stacktracelist->selection);
  }

  MACRO DoParentOpen()
  {
    ^functionslist->value := ^parentcalls->selection.openrowkey;
  }

  MACRO DoClearList()
  {
    IF (this->profiledir != "")
    {
      IF (this->RunSimpleScreen("confirm", this->GetTid(".suredeleteprofiles")) != "yes")
        RETURN;
      RECORD ARRAY files := ReadDiskDirectory(this->profiledir, "*.prof");
      FOREVERY (RECORD rec FROM files)
        DeleteDiskFile(rec.path);
    }

    this->pvt_profiles := DEFAULT RECORD ARRAY;
    this->RefreshProfileList();
  }

  MACRO DoWebserverAdhocCache()
  {
    this->LoadScreen("system:sysmgmt/adhoccache.status")->RunModal();
  }

  MACRO DoClearAllCaches()
  {
    RunClearCaches(this);
  }

>;
