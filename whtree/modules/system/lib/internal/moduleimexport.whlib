<?wh

/** This library contains the code for manipulating modules on the server.
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::adhoccache.whlib";

LOADLIB "mod::publisher/lib/internal/siteprofiles/compiler.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/dbase/updatecommands.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/logging.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/internal/metadata/applyupdates.whlib";

/** Get the module data based on the name
    @param path Full path of the module contents
    @param name Folder name of the module (including .bak, timestamps, etc).
    @param archived Whether the module is within the archivedmodules folder
    @return
    @cell name
    @cell foldername
    @cell newformat
    @cell paths
    @cell moduledate
    @cell moduleorgdate
    @cell obsoletiondate
*/
PUBLIC RECORD FUNCTION GetModuleDataFromFolder(STRING path, STRING name, BOOLEAN archived)
{
  RECORD result :=
      [ name :=           ""
      , foldername :=     name
      , path :=           path
      , newformat :=      FALSE
      , moduledate :=     DEFAULT DATETIME // Use for determining which module is the current (DEFAULT for .bak)
      , moduleorgdate :=  DEFAULT DATETIME // Installdate of the module (moduledate, moduledefinition date for old format)
      , obsoletiondate := DEFAULT DATETIME
      ];

  DATETIME stddate, moduledefdate;

  IF (archived)
  {
    IF (name LIKE "*.2???????T??????.???Z") //msecond precision
    {
      result.obsoletiondate := MakeDateFromText(Right(name, 20));
      name := Left(name, LENGTH(name) - 21);
    }
    ELSE IF (name LIKE "*.2???????T??????Z")
    {
      result.obsoletiondate := MakeDateFromText(Right(name, 16));
      name := Left(name, LENGTH(name) - 17);
    }
    ELSE
    {
      PRINT("Strange module folder: " || path || "\n");
      RETURN DEFAULT RECORD;
    }
  }

  IF (name LIKE "*.*")
  {
    result.name := Left(name, SearchSubString(name, "."));
    IF (name LIKE "*.2???????T??????.???Z")
    {
      result.moduledate := MakeDateFromText(Right(name, 20));
      result.newformat := TRUE;
    }
    IF (name LIKE "*.2???????T??????Z")
    {
      result.moduledate := MakeDateFromText(Right(name, 16));
      result.newformat := TRUE;
    }
  }
  ELSE
  {
    result.moduledate := MakeDate(1970, 1, 1); // Only for normal modules, so not for .bak
    result.name := name;
  }

  IF (NOT result.newformat)
  {
    RECORD moduledefprops := GetDiskFileProperties(path || "/moduledefinition.xml");
    IF (RecordExists(moduledefprops))
      result.moduleorgdate := moduledefprops.modified;
    ELSE IF (NOT archived)
      RETURN DEFAULT RECORD;
  }
  ELSE
    result.moduleorgdate := result.moduledate;

  RETURN result;
}

PUBLIC RECORD ARRAY FUNCTION GetAllModulesAndVersionDirs()
{
  RECORD ARRAY moduledirs;

  RECORD config := GetWebHareConfiguration();
  FOREVERY (STRING installdir FROM config.moduledirs)
  {
    // Skip core modules
    IF (installdir LIKE config.installationroot || "modules/*")
      CONTINUE;

    RECORD ARRAY topdirs := ReadDiskDirectory(installdir,"*");

    moduledirs := moduledirs CONCAT
                  SELECT *, path := MergePath(installdir, name)
                    FROM topdirs;

    FOREVERY(RECORD topdir FROM SELECT * FROM topdirs WHERE type!=0)
    {
      moduledirs := moduledirs CONCAT
                    SELECT *, path := MergePath(installdir, topdir.name || "/" || name)
                      FROM ReadDiskDirectory(MergePath(installdir, topdir.name),'*');
    }
  }

  moduledirs := SELECT DISTINCT * FROM moduledirs WHERE RecordExists(GetDiskFileProperties(path || "/moduledefinition.xml"));
  RETURN moduledirs;
}

RECORD ARRAY FUNCTION GetModuleDirs(STRING modulename)
{
  RECORD ARRAY moduledirs := SELECT *
                               FROM GetAllModulesAndVersionDirs()
                              WHERE (ToUppercase(name) = ToUppercase(VAR modulename) OR ToUppercase(name) LIKE ToUppercase(VAR modulename) || ".*")
                                    AND RecordExists(GetDiskFileProperties(MergePath(path,"moduledefinition.xml")));

  moduledirs := SELECT *
                  FROM moduledirs
              ORDER BY ToUppercase(name) NOT LIKE "*.BAK"
                     , ToUppercase(name);
  RETURN moduledirs;
}

PUBLIC BOOLEAN FUNCTION DeleteModule(STRING module)
{
  // Get the current modules in the installation dir. Order so that the most current module will be moved last
  RECORD ARRAY folderstomove := GetModuleDirs(module);
  IF(Length(folderstomove)=0)
    THROW NEW Exception(`Cannot find folder to delete for module '${module}'`);

  folderstomove :=
      SELECT *
           , data := GetModuleDataFromFolder(path, name, FALSE)
        FROM folderstomove;

  // Order by moduledate, so we archive the oldest module first
  folderstomove :=
      SELECT *
        FROM folderstomove
    ORDER BY REcordExists(data) ? data.moduledate : DEFAULT DATETIME;

  BOOLEAN success := TRUE;
  FOREVERY (RECORD folder FROM folderstomove)
  {
    DATETIME obsoletiondate := #folder = LENGTH(folderstomove) - 1 ? GetCurrentDateTime() : folderstomove[#folder + 1].data.moduleorgdate;

    // Move all modules, obsolete them by deletion date
    IF (NOT ArchiveModuleVersionByPath(folder.path, obsoletiondate))
      success := FALSE; //don't abort yet - we might have still moved one folder successfuly, so we'll need to go through all the reloads.
  }
  ReloadWebhareConfig(TRUE, TRUE, [ isdelete := TRUE ]);

  RecompileSiteProfiles();
  BroadcastEvent("system:modulesupdate", [ modulename := module  ]);

  RETURN success;
}

PUBLIC STRING FUNCTION GetModuleFolderTimestamp()
{
  // Use milliseconds for timestamps in case, CI can probably install modules more than once per second
  RETURN FormatISO8601DateTime(GetCurrentDateTime(), "", "milliseconds", "", FALSE);
}

/** Import a module
    @param module Module to upgrade (optional)
    @param modulefile Archive with module
    @return
    @cell(string) retval.name Name of imported module
    @cell(string) retval.path Path to the imported module
    @cell(string) retval.modulename
    @cell(string) retval.moduleversion
    @cell(string array) retval.warnings
    @cell(string array) retval.errors
    @cell(record) return.manifest Manifest data
    @cell(record) return.orgmanifest Manifest data of previous installed module (if present and parseable)

*/
PUBLIC RECORD FUNCTION ImportModule(BLOB modulefile, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ autoreplace := FALSE ], options); //autoreplace is kept for backwards compatibility with 4.21 and webharebv_policy.
  RECORD retval := [ name :=          ""
                   , path :=          ""
                   , fullversion :=   ""
                   , warnings :=      DEFAULT STRING ARRAY
                   , errors :=        DEFAULT STRING ARRAY
                   , importmodulename := ""
                   , manifestdata :=  DEFAULT RECORD
                   , orgmanifestdata := DEFAULT RECORD
                   ];

  RECORD ARRAY importdata := UnpackArchive(modulefile, "");
  RECORD mdef := SELECT * FROM importdata WHERE name LIKE "moduledefinition.xml" ORDER BY Length(path);
  STRING importmodulename := RecordExists(mdef) ? mdef.path : "";
  retval.importmodulename  := importmodulename;
  STRING finalmodulename;

  RECORD moduleinfo := GetWebhareModuleInfo(importmodulename);
  IF (RecordExists(moduleinfo) AND NOT moduleinfo.packagingupgrade)
  {
    INSERT GetTid("system:sysmgmt.errors.cannotreplacemodule", importmodulename) INTO retval.errors AT END;
  }

  // See which moduledefinition to use, and try to get the module name from it
  IF (importmodulename="")
  {
    INSERT GetTid("system:sysmgmt.errors.notvalidmodulefile") INTO retval.errors AT END;
    RETURN retval;
  }

  STRING tempmodulepath := GetWebHareConfiguration().varroot || "installedmodules/"||importmodulename||".tmp";
  INTEGER umask := ToInteger(ReadRegistryKey("system.modulemgr.installumask"), 7*8*8 + 5*8 + 5*8, 8);

  /* Remove previous webhare module upload */
  DeleteDiskDirectoryRecursive(tempmodulepath);

  IF (NOT CreateDiskDirectoryRecursive(tempmodulepath, TRUE))
    INSERT GetTid("system:sysmgmt.errors.ioerror", tempmodulepath || '/') INTO retval.errors AT END;
  SetUNIXPermissions(tempmodulepath, (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

  // Create new archive to store the module source for quick access & hotfix checks
  DATETIME now := GetCurrentDateTime();
  OBJECT module_source := CreateNewArchive("zip");
  STRING ARRAY seendirs;

  /* Extract module to a temporary directory */
  FOREVERY(RECORD entry FROM importdata)
  {
    STRING localpath := Substring(entry.path,Length(importmodulename),Length(entry.path));
    IF ((localpath="" OR localpath="/") AND entry.name="")
      CONTINUE; //request to create the current directory, can be ignored

    STRING fullpath := tempmodulepath || localpath;
    IF(fullpath NOT IN seendirs)
    {
      IF (NOT CreateDiskDirectory(fullpath, TRUE) AND NOT RecordExists(GetDiskFileProperties(fullpath)))
        INSERT GetTid("system:sysmgmt.errors.ioerror", fullpath) INTO retval.errors AT END;

      INSERT fullpath INTO seendirs AT END;
      SetUNIXPermissions(fullpath, (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

      module_source->AddFolder(entry.path || "/", now);
    }

    IF(entry.name != "") //A file
    {
      fullpath := fullpath || '/' || entry.name;

      DATETIME modtime;
      StoreDiskFile(fullpath, entry.data);

      SetUNIXPermissions(fullpath, (6*8*8 + 6*8 + 6) BITAND umask);
      RECORD properties := GetDiskFileProperties(fullpath);
      IF (RecordExists(properties))
        modtime := properties.modified;

      // Store the modtime as it is on disk
      module_source->AddFile(entry.path || "/" || entry.name, entry.data, modtime);
    }
  }

  // Make sure the history folder exists
  IF (NOT CreateDiskDirectoryRecursive(tempmodulepath || "/history", TRUE))
    INSERT GetTid("system:sysmgmt.errors.ioerror", tempmodulepath || '/history/') INTO retval.errors AT END;
  SetUNIXPermissions(tempmodulepath || "/history", (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

  // Create the source zip
  BLOB module_source_blob := module_source->MakeBlob();
  STRING source_path := tempmodulepath || "/history/source.zip";
  StoreDiskFile(source_path, module_source_blob);
  SetUNIXPermissions(source_path, (6*8*8 + 6*8 + 6) BITAND umask);

  finalmodulename := GetWebHareConfiguration().varroot || "installedmodules/" || importmodulename || "." || GetModuleFolderTimestamp();

  // Check whether all dependencies are present
  OBJECT moduledefinitionxml := MakeXMLDocument(mdef.data);

  IF (ObjectExists(moduledefinitionxml))
  {
    RECORD moduledef := ParseModuleDefinition(importmodulename, moduledefinitionxml);
    STRING ARRAY allmodules := GetInstalledModuleNames();

    FOREVERY(STRING module FROM allmodules)
      allmodules[#module] := ToLowercase(module);

    STRING ARRAY missingmodules;

    FOREVERY (RECORD mod FROM moduledef.requiredmodules)
    {
      IF (mod.name NOT IN allmodules)
        INSERT mod.name INTO missingmodules AT END;
    }

    IF (LENGTH(missingmodules) != 0)
    {
      INSERT GetTid("system:sysmgmt.errors.missingmodules", Detokenize(missingmodules, ", ")) INTO retval.errors AT END;
      importmodulename := "";
      finalmodulename := "";
    }
    ELSE
    {
      retval.fullversion := moduledef.version;

      RECORD manifest;
      BLOB manifestdata := GetDiskResource(MergePath(tempmodulepath, "history/manifest.xml"), [ allowmissing := TRUE]);
      IF (LENGTH(manifestdata) != 0)
      {
        OBJECT manifestdoc := MakeXMLDocument(manifestdata);
        IF (ObjectExists(manifestdoc))
        {
          manifest := ParseModuleManifest(manifestdoc);
          retval.fullversion := GetFullModuleVersion(moduledef, manifest);
        }
      }

      retval.manifestdata := GetAuditLogDataFromManifest(manifest);
    }
  }

  // Try to get manifest from the original module
  BLOB orgmanifestdata := GetDiskResource(MergePath(finalmodulename, "history/manifest.xml"), [ allowmissing := TRUE]);
  IF (LENGTH(orgmanifestdata) != 0)
  {
    OBJECT orgmanifestdoc := MakeXMLDocument(orgmanifestdata);
    IF (ObjectExists(orgmanifestdoc))
    {
      RECORD orgmanifest := ParseModuleManifest(orgmanifestdoc);
      retval.orgmanifestdata := GetAuditLogDataFromManifest(orgmanifest);
    }
  }

  IF (Length(retval.errors) = 0) //Still okay
  {
    IF(NOT MoveDiskPath(tempmodulepath, finalmodulename))
      INSERT GetTid("system:sysmgmt.errors.cannotreplacemodule", importmodulename) INTO retval.errors AT END;
  }

  // Activate new paths first - all apps now know about the new module
  ReloadWebhareConfig2("AUTH MODULES");
  /* Reset caches, so nothing using the old paths still stores it. Can't get rid
     of this until the source watcher knows to invalidate mod:: resources when
     the entire module is moved */
  BroadcastEvent("system:clearcaches", RECORD[]);

  IF (Length(retval.errors) = 0)
  {
    RECORD res := __ActivateInstalledModule(importmodulename, finalmodulename);
    retval.warnings := retval.warnings CONCAT res.warnings;
  }

//    IF (Length(retval.errors)!=0) //delete extracted data
//      DeleteDiskDirectoryRecursive(tempmodulepath);

  IF (Length(retval.errors)!=0) //delete extracted data
    importmodulename := "";

  retval.name := importmodulename;
  retval.path := finalmodulename;

  /* Flush all caches. ActivateInstalledModule does a system:softreset which
     used to imply a cache flush, but we want to get rid of that. But we need
     to fix all cache-users to not rely on a flush before we can do that */
  BroadcastEvent("system:clearcaches", RECORD[]);

  RETURN retval;
}

PUBLIC RECORD FUNCTION ActivateInstalledModule(STRING modulename, STRING installpath)
{
  //Reload module config (ADDME: Run installscript BEFORE __SYSTEM_RESTART!)  FIXME: Ensure reload was completed or manually find the InstallScript
  ReloadWebhareConfig2("AUTH MODULES");
  RETURN __ActivateInstalledModule(modulename, installpath);
}

RECORD FUNCTION __ActivateInstalledModule(STRING modulename, STRING installpath)
{
  RECORD retval := [ warnings := DEFAULT STRING ARRAY ];
  //Reload module config (ADDME: Run installscript BEFORE __SYSTEM_RESTART!)  FIXME: Ensure reload was completed or manually find the InstallScript

  //explicitly flush any moduledefinition.xml caches - otherwise we'll race with the source watcher doing the same in a few seconds
  BroadcastEvent("system:modulesupdate", [ modulename := modulename ]);

  ReconfigureLogFiles();

  //__FlushCaches();

  FixModuleSymlinks([modulename], FALSE); //put nodejs folder in place
  GetPrimary()->BeginWork();
  EnsureModulePrivateFolders();
  GetPrimary()->CommitWork();

  //Run init scripts for the module
  RECORD moduleinfo := GetWebhareModuleInfo(modulename);
  IF(NOT RecordExists(moduleinfo))
    THROW NEW Exception(`Unable to get moduleinfo for module '${modulename}'`);

  OBJECT validator := GetModuleXMLValidator(modulename);
  INSERT CELL runoncescripts := ParseModuleDefRunonce(validator) INTO moduleinfo;

  ClearAllSchemaCaches();
  RECORD sch := GetModuleDatabaseSchema(modulename);
  INSERT CELL databaseschemas := RecordExists(sch) ? [sch] : DEFAULT RECORD ARRAY INTO moduleinfo;
  INSERT CELL regkeys := GetModuleRegKeys(modulename) INTO moduleinfo;

  RECORD result := InitModuleIndependents([moduleinfo], FALSE, TRUE);
  BOOLEAN any_db_error := LENGTH(result.commitmessages) > 0;
  FOREVERY(RECORD msg FROM result.commitmessages)
    INSERT msg.text INTO retval.warnings AT END;

  RECORD ro_result := RunRunOnceScripts(moduleinfo, "afterschemacreation", FALSE);

  FOREVERY(STRING msg FROM ro_result.messages)
    INSERT msg INTO retval.warnings AT END;

  IF (NOT ro_result.error)
  {
    result := InitModuleTables(moduleinfo);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    ro_result := RunRunOnceScripts(moduleinfo, "aftertablebeforerights", FALSE);
    FOREVERY(STRING msg FROM ro_result.messages)
      INSERT msg INTO retval.warnings AT END;

    result := InitModuleRights([moduleinfo], FALSE);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    ro_result := RunRunOnceScripts(moduleinfo, "aftertablecreation", FALSE);
    FOREVERY(STRING msg FROM ro_result.messages)
      INSERT msg INTO retval.warnings AT END;
  }
  ELSE
    any_db_error := TRUE;

  IF (NOT any_db_error)
  {
    result := InitModuleIndependents([moduleinfo], FALSE, FALSE);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    result := InitModuleRegistryKeys([moduleinfo]);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;
  }

  ro_result := RunRunOnceScripts(moduleinfo, "afterregistryupdate", FALSE);
  FOREVERY(STRING msg FROM ro_result.messages)
    INSERT msg INTO retval.warnings AT END;

  INTEGER umask := ToInteger(ReadRegistryKey("system.modulemgr.installumask"), 7*8*8 + 5*8 + 5*8, 8);
  FOREVERY(RECORD perm FROM moduleinfo.packagingpermissions)
  {
    STRING fullpath := MergePath(installpath, perm.file);
    SetUNIXPermissions(fullpath, perm.permissions  BITAND umask);
  }

  // Update WRD schemas
  UpdateAllModuleSchemas();

  // Recompile siteprofiles and refresh the webserver configuration in-line.
  RecompileSiteProfiles();

  // Softreset (used to clear all caches, now only linked to specific cache keys) restart needed scripts
  BroadcastEvent("system:softreset", [ toreload := DEFAULT STRING ARRAY ]);

  // Execute post-start scripts for this module in executetasks.whscr
  OBJECT link := ConnectToGlobalIPCPort("system:executetasks");
  IF (ObjectExists(link))
  {
    link->SendMessage([ task := "poststartmodule", modulename := modulename ]);
    link->Close();
  }

  RETURN retval;
}


/** Moves a module folder from the installedmodules folder to the archive
    @param modulefolderpath Name of the module folder (like module.timestamp)
    @param obsoletiondate Date of obsoletiondate
    @return Whether the move was successful
*/
PUBLIC BOOLEAN FUNCTION ArchiveModuleVersionByPath(STRING modulefolderpath, DATETIME obsoletiondate)
{
  // Make sure archive folder exists
  STRING archiveroot := GetWebHareConfiguration().varroot || "archivedmodules";
  CreateDiskDirectoryRecursive(archiveroot, TRUE);

  // Calc the new old & new paths.
  STRING targetpath := archiveroot || "/" || Tokenize(modulefolderpath,'/')[END-1]|| "." || GetModuleFolderTimestamp();

  BOOLEAN result := MoveDiskPath(modulefolderpath, targetpath);
  IF(result = FALSE //looks like move failed
     AND NOT RecordExists(GetDiskFileProperties(modulefolderpath))) //but it's still gone
  {
    result := TRUE; //then we thought the module was still there but it isn't? consider it a success anyway
  }

  IF (result)
  {
    BroadcastEvent("system:modules.archivedmodule", DEFAULT RECORD);
  }
  RETURN result;
}

PUBLIC RECORD ARRAY FUNCTION EnrichInstalledModulesWithManifests(RECORD ARRAY modules)
{
  FOREVERY(RECORD mod FROM modules)
  {
    RECORD manifest;
    TRY
    {
      manifest := ParseModuleManifest(OpenXMLDoc("mod::" || mod.name || "/history/manifest.xml",FALSE).doc);
    }
    CATCH(OBJECT<RetrieveResourceException> e)
    {
      manifest := ParseModuleManifest(DEFAULT OBJECT);
      //ignoring retrieve errors
    }

    INSERT CELL manifest := manifest
              , fullversion := GetFullModuleVersion(mod, manifest)
              , root := GetModuleInstallationRoot(mod.name)
              , source_repository_url :=   manifest.source_repository_url
              , source_repository_uuid :=  manifest.source_repository_uuid
              , source_revision :=         manifest.source_revision
              , source_uncommittedchanges := manifest.has_modifications
           INTO mod;

    modules[#mod] := mod;
  }
  RETURN modules;
}

DATETIME FUNCTION GetModDateFromPath(STRING modulepath)
{
  IF(modulepath NOT LIKE "*/*")
    RETURN DEFAULT DATETIME;
  STRING lasttok := Tokenize(modulepath,'/')[END-2];
  RETURN lasttok LIKE "*.2*Z" ? MakeDateFromText(Tokenize(lasttok,'.')[1]) : DEFAULT DATETIME;
}

PUBLIC RECORD ARRAY FUNCTION GetInstalledModulesOverview(BOOLEAN include_deleted)
{
  RECORD ARRAY modules := GetWebHareModules();
  STRING builtinroot := GetWebHareConfiguration().installationroot || "modules/";
  STRING whversion := GetWebhareVersionInfo().version;

  modules := SELECT TEMPORARY path := GetModuleInstallationRoot(name)
                  , TEMPORARY isbuiltin := path LIKE builtinroot || "*"
                  , TEMPORARY lastmodified := isbuiltin ? DEFAULT DATETIME : GetModDateFromPath(path)
                  , name
                  , path :=                    path
                  , version :=                 isbuiltin ? whversion : version
                  , description
                  , packagingupgrade
                  , candownload :=             packagingdownload
                  , lastmodified :=            lastmodified
                  , isdeleted :=               FALSE
                  , isinstalled :=             lastmodified != DEFAULT DATETIME //any mod with a timestamp in its name must be installed
                  , isbuiltin :=               isbuiltin
                  , configscreen
               FROM modules
           ORDER BY name;

  IF (include_deleted)
  {
    // Get all archived modules
    STRING pathroot := GetWebHareConfiguration().varroot || "archivedmodules/";
    RECORD ARRAY archived := ReadDiskDirectory(pathroot, "*");

    // Sort by reverse deletion date
    archived := SELECT * FROM archived WHERE name LIKE "*.*Z" ORDER BY Tokenize(name,'.')[END-1] DESC;

    FOREVERY (RECORD rec FROM archived)
    {
      STRING name := Tokenize(rec.name,'.')[0];
      RECORD pos := RecordLowerBound(modules, [ name := name ] , [ "NAME" ]);
      IF (NOT pos.found)
      {
        INSERT
            [ name :=             name
            , path :=             rec.path
            , version :=          ""
            , description :=      ""
            , packagingupgrade := FALSE
            , candownload :=      FALSE
            , lastmodified :=     rec.path LIKE "*.*Z.*Z" ? GetModDateFromPath(rec.path) : DEFAULT DATETIME //paths with double timestamps have an actual moddate, single timestamps are git module deletions
            , isdeleted :=        TRUE
            , isinstalled :=      FALSE
            , isbuiltin :=        FALSE
            , configscreen :=     ""
            ] INTO modules AT pos.position;
      }
    }
  }
  RETURN modules;
}

STRING FUNCTION RemoveFirstPathElement(STRING fullpath)
{
  INTEGER pos := SearchSubstring(fullpath, "/");
  IF (pos = 0) // Compensate for '/modulename/blabla', just in case
  {
    fullpath := SubString(fullpath, pos + 1);
    pos := SearchSubstring(fullpath, "/");
  }
  IF (pos = -1)
    RETURN "";
  RETURN SubString(fullpath, pos + 1);
}

RECORD ARRAY FUNCTION ScanModuleDirectory(STRING path, STRING localpath)
{
  RECORD ARRAY entries := ReadDiskDirectory(path, "*");

  entries :=
      SELECT *
           , path :=        localpath
           , fullpath :=    MergePath(localpath, name)
        FROM entries;

  FOREVERY (RECORD entry FROM entries)
    IF (entry.type = 1)
      entries := entries CONCAT ScanModuleDirectory(MergePath(path, entry.name), entry.fullpath);

  RETURN entries;
}

BOOLEAN FUNCTION HaveDateChangedFromZip(DATETIME zipdate, DATETIME currentdate)
{
  // Zip file has 2sec granularity, but the rounding direction is unspecified (and we differ from InfoZip)
  INTEGER64 diff := GetDatetimeDifference(zipdate, currentdate).totalmsecs;
  RETURN NOT (-2000 <= diff AND diff <= 2000);
}

PUBLIC RECORD FUNCTION GetModuleModifiedFiles(STRING moduleroot, BOOLEAN include_sourcedata)
{
  STRING sourcezippath := MergePath(moduleroot, "history/source.zip");
  BLOB sourcezip := GetDiskResource(sourcezippath, [ allowmissing := TRUE ]);

  IF (LENGTH(sourcezip) = 0)
  {
    RETURN
        [ success :=  FALSE
        , code :=     "NOSOURCE"
        , files :=    DEFAULT RECORD ARRAY
        ];
  }

  OBJECT sourcearchive := OpenExistingArchive(sourcezip);

  RECORD ARRAY source_entries :=
      SELECT name
           , path :=              RemoveFirstPathElement(fullpath)
           , source_size :=       INTEGER64(size)
           , current_size :=      -1i64
           , source_modtime :=    modtime
           , current_modtime :=   DEFAULT DATETIME
           , xsource :=           1
           , originalfullpath :=  fullpath
        FROM sourcearchive->entries
       WHERE type = 0 AND RemoveFirstPathElement(fullpath) NOT LIKE "history/*"
    ORDER BY fullpath;

  RECORD ARRAY current_entries :=
      SELECT name
           , path :=              fullpath
           , source_size :=       -1i64
           , current_size :=      size64
           , source_modtime :=    DEFAULT DATETIME
           , current_modtime :=   modified
           , xsource :=           2
           , originalfullpath :=  ""
        FROM ScanModuleDirectory(moduleroot, "")
       WHERE type = 0
         AND fullpath != "source.zip" AND fullpath NOT LIKE "history/*"
    ORDER BY fullpath;

  RECORD ARRAY result :=
      SELECT path
           , name :=              Any(name)
           , status :=            [ "", "removed", "added", "modified"][SUM(xsource)]
           , source_size :=       MAX(source_size)
           , current_size :=      MAX(current_size)
           , source_modtime :=    MAX(source_modtime)
           , current_modtime :=   MAX(current_modtime)
           , originalfullpath :=  (SELECT AS STRING path FROM GroupedValues([ path := originalfullpath ]) WHERE path != "")
        FROM source_entries CONCAT current_entries
    GROUP BY path
      HAVING MAX(source_size) != MAX(current_size) OR HaveDateChangedFromZip(MAX(source_modtime), MAX(current_modtime))
    ORDER BY path;

  IF (include_sourcedata)
  {
    result :=
        SELECT *
             , source_data :=     sourcearchive->GetFile(originalfullpath)
          FROM result;
  }

  sourcearchive->Close();

  RETURN
      [ success :=    TRUE
      , code :=       ""
      , files :=      result
      ];
}


PUBLIC RECORD FUNCTION GetAuditLogDataFromManifest(RECORD manifest)
{
  RECORD manifestdata :=
      [ warnings :=         STRING[]
      , repository :=       ""
      , commit :=           ""
      , original_source :=  ""
      ];

  IF (RecordExists(manifest))
  {
    manifestdata.original_source := manifest.original_source;
    manifestdata.repository := manifest.source_repository_url;
    manifestdata.commit := manifest.source_revision;

    IF (manifest.original_source = "git")
    {
      IF (manifest.source_revision != manifest.source_localremoterevision OR manifest.source_revision != manifest.source_remoterevision)
      {
        IF (manifest.source_remoterevision != "" AND manifest.source_localremoterevision != manifest.source_remoterevision)
        {
          INSERT "notuptodate" INTO manifestdata.warnings AT END;
        }
        IF (manifest.source_localremoterevision = "")
        {
          // Local branch is not present on the origin - feature branch that hasn't been pushed yet
          INSERT "branchnotonorigin" INTO manifestdata.warnings AT END;
        }
        ELSE IF (manifest.source_revision != manifest.source_localremoterevision)
        {
          // Either uncommitted changes or not rebased yet
          IF (RecordExists(SELECT FROM manifest.commits WHERE id = manifest.source_localremoterevision))
          {
            // Local remote is ancestor of current commit - so current commit just hasn't been pushed yet
            INSERT "unpushedchanges" INTO manifestdata.warnings AT END;
          }
          ELSE
          {
            // Remote is not an ancestor of current version - have older version checked out or need to rebase
            INSERT "notatbranchhead" INTO manifestdata.warnings AT END;
          }
        }
      }

      IF (manifest.has_modifications)
      {
        INSERT "uncommittedchanges" INTO manifestdata.warnings AT END;
      }
    }
    ELSE
      INSERT "notgit" INTO manifestdata.warnings AT END;
  }

  IF (NOT RecordExists(manifest))
    INSERT "nomanifest" INTO manifestdata.warnings AT END;

  RETURN manifestdata;
}
