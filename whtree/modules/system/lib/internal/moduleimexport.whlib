<?wh

/** This library contains the code for manipulating modules on the server.
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::adhoccache.whlib";

LOADLIB "mod::publisher/lib/internal/siteprofiles/compiler.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/dbase/updatecommands.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/logging.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/internal/metadata/applyupdates.whlib";

RECORD FUNCTION GetGitRepoInfo(STRING repo, BOOLEAN query_remote) __ATTRIBUTES__(EXTERNAL "wh_git");

/** Get the module data based on the name
    @param path Full path of the module contents
    @param name Folder name of the module (including .bak, timestamps, etc).
    @param archived Whether the module is within the archivedmodules folder
    @return
    @cell name
    @cell foldername
    @cell newformat
    @cell paths
    @cell moduledate
    @cell moduleorgdate
    @cell obsoletiondate
*/
PUBLIC RECORD FUNCTION GetModuleDataFromFolder(STRING path, STRING name, BOOLEAN archived)
{
  RECORD result :=
      [ name :=           ""
      , foldername :=     name
      , path :=           path
      , newformat :=      FALSE
      , moduledate :=     DEFAULT DATETIME // Use for determining which module is the current (DEFAULT for .bak)
      , moduleorgdate :=  DEFAULT DATETIME // Installdate of the module (moduledate, moduledefinition date for old format)
      , obsoletiondate := DEFAULT DATETIME
      ];

  DATETIME stddate, moduledefdate;

  IF (archived)
  {
    IF (name NOT LIKE "*.2???????T??????*Z")
    {
      PRINT("Strange module folder: " || path || "\n");
      RETURN DEFAULT RECORD;
    }

    result.obsoletiondate := MakeDateFromText(Right(name, 16));
    name := Left(name, LENGTH(name) - 17);
  }

  IF (name LIKE "*.*")
  {
    result.name := Left(name, SearchSubString(name, "."));
    IF (name LIKE "*.2???????T??????*Z")
    {
      result.moduledate := MakeDateFromText(Right(name, 16));
      result.newformat := TRUE;
    }
  }
  ELSE
  {
    result.moduledate := MakeDate(1970, 1, 1); // Only for normal modules, so not for .bak
    result.name := name;
  }

  IF (NOT result.newformat)
  {
    RECORD moduledefprops := GetDiskFileProperties(path || "/moduledefinition.xml");
    IF (RecordExists(moduledefprops))
      result.moduleorgdate := moduledefprops.modified;
    ELSE IF (NOT archived)
      RETURN DEFAULT RECORD;
  }
  ELSE
    result.moduleorgdate := result.moduledate;

  RETURN result;
}

PUBLIC RECORD ARRAY FUNCTION GetAllModulesAndVersionDirs()
{
  RECORD ARRAY moduledirs;

  RECORD config := GetWebHareConfiguration();
  FOREVERY (STRING installdir FROM config.moduledirs)
  {
    // Skip core modules
    IF (installdir LIKE config.installationroot || "modules/*")
      CONTINUE;

    RECORD ARRAY topdirs := ReadDiskDirectory(installdir,"*");

    moduledirs := moduledirs CONCAT
                  SELECT *, path := MergePath(installdir, name)
                    FROM topdirs;

    FOREVERY(RECORD topdir FROM SELECT * FROM topdirs WHERE type!=0)
    {
      moduledirs := moduledirs CONCAT
                    SELECT *, path := MergePath(installdir, topdir.name || "/" || name)
                      FROM ReadDiskDirectory(MergePath(installdir, topdir.name),'*');
    }
  }

  moduledirs := SELECT DISTINCT * FROM moduledirs WHERE RecordExists(GetDiskFileProperties(path || "/moduledefinition.xml"));
  RETURN moduledirs;
}

RECORD ARRAY FUNCTION GetModuleDirs(STRING modulename)
{
  RECORD ARRAY moduledirs := SELECT *
                               FROM GetAllModulesAndVersionDirs()
                              WHERE (ToUppercase(name) = ToUppercase(VAR modulename) OR ToUppercase(name) LIKE ToUppercase(VAR modulename) || ".*")
                                    AND RecordExists(GetDiskFileProperties(MergePath(path,"moduledefinition.xml")));

  moduledirs := SELECT *
                  FROM moduledirs
              ORDER BY ToUppercase(name) NOT LIKE "*.BAK"
                     , ToUppercase(name);
  RETURN moduledirs;
}

PUBLIC BOOLEAN FUNCTION DeleteModule(STRING module)
{
  // Get the current modules in the installation dir. Order so that the most current module will be moved last
  RECORD ARRAY folderstomove := GetModuleDirs(module);
  IF(Length(folderstomove)=0)
    THROW NEW Exception(`Cannot find folder to delete for module '${module}'`);

  folderstomove :=
      SELECT *
           , data := GetModuleDataFromFolder(path, name, FALSE)
        FROM folderstomove;

  // Order by moduledate, so we archive the oldest module first
  folderstomove :=
      SELECT *
        FROM folderstomove
    ORDER BY REcordExists(data) ? data.moduledate : DEFAULT DATETIME;

  BOOLEAN success := TRUE;
  FOREVERY (RECORD folder FROM folderstomove)
  {
    DATETIME obsoletiondate := #folder = LENGTH(folderstomove) - 1 ? GetCurrentDateTime() : folderstomove[#folder + 1].data.moduleorgdate;

    // Move all modules, obsolete them by deletion date
    IF (NOT ArchiveModuleVersionByPath(folder.path, obsoletiondate))
      success := FALSE; //don't abort yet - we might have still moved one folder successfuly, so we'll need to go through all the reloads.
  }
  ReloadWebhareConfig(TRUE, TRUE, [ isdelete := TRUE ]);

  RecompileSiteProfiles();
  BroadcastEvent("system:modulesupdate", [ modulename := module  ]);

  RETURN success;
}

PUBLIC STRING FUNCTION GetModuleFolderTimestamp()
{
  // Use milliseconds for timestamps in case, CI can probably install modules more than once per second
  RETURN FormatISO8601DateTime(GetCurrentDateTime(), "", "milliseconds", "", FALSE);
}

/** Import a module
    @param module Module to upgrade (optional)
    @param modulefile Archive with module
    @return
    @cell(string) retval.name Name of imported module
    @cell(string) retval.path Path to the imported module
    @cell(string) retval.modulename
    @cell(string) retval.moduleversion
    @cell(string array) retval.warnings
    @cell(string array) retval.errors
    @cell(record) return.manifest Manifest data
    @cell(record) return.orgmanifest Manifest data of previous installed module (if present and parseable)

*/
PUBLIC RECORD FUNCTION ImportModule(BLOB modulefile, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ autoreplace := FALSE ], options); //autoreplace is kept for backwards compatibility with 4.21 and webharebv_policy.
  RECORD retval := [ name :=          ""
                   , path :=          ""
                   , fullversion :=   ""
                   , warnings :=      DEFAULT STRING ARRAY
                   , errors :=        DEFAULT STRING ARRAY
                   , importmodulename := ""
                   , manifestdata :=  DEFAULT RECORD
                   , orgmanifestdata := DEFAULT RECORD
                   ];

  RECORD ARRAY importdata := UnpackArchive(modulefile, "");
  RECORD mdef := SELECT * FROM importdata WHERE name LIKE "moduledefinition.xml" ORDER BY Length(path);
  STRING importmodulename := RecordExists(mdef) ? mdef.path : "";
  retval.importmodulename  := importmodulename;
  STRING finalmodulename;

  RECORD moduleinfo := GetWebhareModuleInfo(importmodulename);
  IF (RecordExists(moduleinfo) AND NOT moduleinfo.packagingupgrade)
  {
    INSERT GetTid("system:sysmgmt.errors.cannotreplacemodule", importmodulename) INTO retval.errors AT END;
  }

  // See which moduledefinition to use, and try to get the module name from it
  IF (importmodulename="")
  {
    INSERT GetTid("system:sysmgmt.errors.notvalidmodulefile") INTO retval.errors AT END;
    RETURN retval;
  }

  STRING tempmodulepath := GetWebHareConfiguration().varroot || "installedmodules/"||importmodulename||".tmp";
  INTEGER umask := ToInteger(ReadRegistryKey("system.modulemgr.installumask"), 7*8*8 + 5*8 + 5*8, 8);

  /* Remove previous webhare module upload */
  DeleteDiskDirectoryRecursive(tempmodulepath);

  IF (NOT CreateDiskDirectoryRecursive(tempmodulepath, TRUE))
    INSERT GetTid("system:sysmgmt.errors.ioerror", tempmodulepath || '/') INTO retval.errors AT END;
  SetUNIXPermissions(tempmodulepath, (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

  // Create new archive to store the module source for quick access & hotfix checks
  DATETIME now := GetCurrentDateTime();
  OBJECT module_source := CreateNewArchive("zip");
  STRING ARRAY seendirs;

  /* Extract module to a temporary directory */
  FOREVERY(RECORD entry FROM importdata)
  {
    STRING localpath := Substring(entry.path,Length(importmodulename),Length(entry.path));
    IF ((localpath="" OR localpath="/") AND entry.name="")
      CONTINUE; //request to create the current directory, can be ignored

    STRING fullpath := tempmodulepath || localpath;
    IF(fullpath NOT IN seendirs)
    {
      IF (NOT CreateDiskDirectory(fullpath, TRUE) AND NOT RecordExists(GetDiskFileProperties(fullpath)))
        INSERT GetTid("system:sysmgmt.errors.ioerror", fullpath) INTO retval.errors AT END;

      INSERT fullpath INTO seendirs AT END;
      SetUNIXPermissions(fullpath, (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

      module_source->AddFolder(entry.path || "/", now);
    }

    IF(entry.name != "") //A file
    {
      fullpath := fullpath || '/' || entry.name;

      DATETIME modtime;
      StoreDiskFile(fullpath, entry.data);

      SetUNIXPermissions(fullpath, (6*8*8 + 6*8 + 6) BITAND umask);
      RECORD properties := GetDiskFileProperties(fullpath);
      IF (RecordExists(properties))
        modtime := properties.modified;

      // Store the modtime as it is on disk
      module_source->AddFile(entry.path || "/" || entry.name, entry.data, modtime);
    }
  }

  // Make sure the history folder exists
  IF (NOT CreateDiskDirectoryRecursive(tempmodulepath || "/history", TRUE))
    INSERT GetTid("system:sysmgmt.errors.ioerror", tempmodulepath || '/history/') INTO retval.errors AT END;
  SetUNIXPermissions(tempmodulepath || "/history", (2*8*8*8 + 7*8*8 + 7*8 + 7) BITAND umask);

  // Create the source zip
  BLOB module_source_blob := module_source->MakeBlob();
  STRING source_path := tempmodulepath || "/history/source.zip";
  StoreDiskFile(source_path, module_source_blob);
  SetUNIXPermissions(source_path, (6*8*8 + 6*8 + 6) BITAND umask);

  finalmodulename := GetWebHareConfiguration().varroot || "installedmodules/" || importmodulename || "." || GetModuleFolderTimestamp();

  // Check whether all dependencies are present
  OBJECT moduledefinitionxml := MakeXMLDocument(mdef.data);

  IF (ObjectExists(moduledefinitionxml))
  {
    RECORD moduledef := ParseModuleDefinition(importmodulename, moduledefinitionxml);
    STRING ARRAY allmodules := GetInstalledModuleNames();

    FOREVERY(STRING module FROM allmodules)
      allmodules[#module] := ToLowercase(module);

    STRING ARRAY missingmodules;

    FOREVERY (RECORD mod FROM moduledef.requiredmodules)
    {
      IF (mod.name NOT IN allmodules)
        INSERT mod.name INTO missingmodules AT END;
    }

    IF (LENGTH(missingmodules) != 0)
    {
      INSERT GetTid("system:sysmgmt.errors.missingmodules", Detokenize(missingmodules, ", ")) INTO retval.errors AT END;
      importmodulename := "";
      finalmodulename := "";
    }
    ELSE
    {
      retval.fullversion := moduledef.version;

      RECORD manifest;
      BLOB manifestdata := GetDiskResource(MergePath(tempmodulepath, "history/manifest.xml"), [ allowmissing := TRUE]);
      IF (LENGTH(manifestdata) != 0)
      {
        OBJECT manifestdoc := MakeXMLDocument(manifestdata);
        IF (ObjectExists(manifestdoc))
        {
          manifest := ParseModuleManifest(manifestdoc);
          retval.fullversion := GetFullModuleVersion(moduledef, manifest);
        }
      }

      retval.manifestdata := GetAuditLogDataFromManifest(manifest);
    }
  }

  // Try to get manifest from the original module
  BLOB orgmanifestdata := GetDiskResource(MergePath(finalmodulename, "history/manifest.xml"), [ allowmissing := TRUE]);
  IF (LENGTH(orgmanifestdata) != 0)
  {
    OBJECT orgmanifestdoc := MakeXMLDocument(orgmanifestdata);
    IF (ObjectExists(orgmanifestdoc))
    {
      RECORD orgmanifest := ParseModuleManifest(orgmanifestdoc);
      retval.orgmanifestdata := GetAuditLogDataFromManifest(orgmanifest);
    }
  }

  IF (Length(retval.errors) = 0) //Still okay
  {
    IF(NOT MoveDiskPath(tempmodulepath, finalmodulename))
      INSERT GetTid("system:sysmgmt.errors.cannotreplacemodule", importmodulename) INTO retval.errors AT END;
  }

  // Activate new paths first - all apps now know about the new module
  ReloadWebhareConfig2("AUTH MODULES");
  /* Reset caches, so nothing using the old paths still stores it. Can't get rid
     of this until the source watcher knows to invalidate mod:: resources when
     the entire module is moved */
  BroadcastEvent("system:clearcaches", RECORD[]);

  IF (Length(retval.errors) = 0)
  {
    RECORD res := __ActivateInstalledModule(importmodulename, finalmodulename);
    retval.warnings := retval.warnings CONCAT res.warnings;
  }

//    IF (Length(retval.errors)!=0) //delete extracted data
//      DeleteDiskDirectoryRecursive(tempmodulepath);

  IF (Length(retval.errors)!=0) //delete extracted data
    importmodulename := "";

  retval.name := importmodulename;
  retval.path := finalmodulename;

  /* Flush all caches. ActivateInstalledModule does a system:softreset which
     used to imply a cache flush, but we want to get rid of that. But we need
     to fix all cache-users to not rely on a flush before we can do that */
  BroadcastEvent("system:clearcaches", RECORD[]);

  RETURN retval;
}

PUBLIC RECORD FUNCTION ActivateInstalledModule(STRING modulename, STRING installpath)
{
  //Reload module config (ADDME: Run installscript BEFORE __SYSTEM_RESTART!)  FIXME: Ensure reload was completed or manually find the InstallScript
  ReloadWebhareConfig2("AUTH MODULES");
  RETURN __ActivateInstalledModule(modulename, installpath);
}

RECORD FUNCTION __ActivateInstalledModule(STRING modulename, STRING installpath)
{
  RECORD retval := [ warnings := DEFAULT STRING ARRAY ];
  //Reload module config (ADDME: Run installscript BEFORE __SYSTEM_RESTART!)  FIXME: Ensure reload was completed or manually find the InstallScript

  //explicitly flush any moduledefinition.xml caches - otherwise we'll race with the source watcher doing the same in a few seconds
  BroadcastEvent("system:modulesupdate", [ modulename := modulename ]);

  ReconfigureLogFiles();

  //__FlushCaches();

  FixModuleSymlinks([modulename], FALSE); //put nodejs folder in place
  GetPrimary()->BeginWork();
  EnsureModulePrivateFolders();
  GetPrimary()->CommitWork();

  //Run init scripts for the module
  RECORD moduleinfo := GetWebhareModuleInfo(modulename);
  IF(NOT RecordExists(moduleinfo))
    THROW NEW Exception(`Unable to get moduleinfo for module '${modulename}'`);

  OBJECT validator := GetModuleXMLValidator(modulename);
  INSERT CELL runoncescripts := ParseModuleDefRunonce(validator) INTO moduleinfo;

  ClearAllSchemaCaches();
  RECORD sch := GetModuleDatabaseSchema(modulename);
  INSERT CELL databaseschemas := RecordExists(sch) ? [sch] : DEFAULT RECORD ARRAY INTO moduleinfo;
  INSERT CELL regkeys := GetModuleRegKeys(modulename) INTO moduleinfo;

  RECORD result := InitModuleIndependents([moduleinfo], FALSE, TRUE);
  BOOLEAN any_db_error := LENGTH(result.commitmessages) > 0;
  FOREVERY(RECORD msg FROM result.commitmessages)
    INSERT msg.text INTO retval.warnings AT END;

  RECORD ro_result := RunRunOnceScripts(moduleinfo, "afterschemacreation", FALSE);

  FOREVERY(STRING msg FROM ro_result.messages)
    INSERT msg INTO retval.warnings AT END;

  IF (NOT ro_result.error)
  {
    result := InitModuleTables(moduleinfo);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    ro_result := RunRunOnceScripts(moduleinfo, "aftertablebeforerights", FALSE);
    FOREVERY(STRING msg FROM ro_result.messages)
      INSERT msg INTO retval.warnings AT END;

    result := InitModuleRights([moduleinfo], FALSE);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    ro_result := RunRunOnceScripts(moduleinfo, "aftertablecreation", FALSE);
    FOREVERY(STRING msg FROM ro_result.messages)
      INSERT msg INTO retval.warnings AT END;
  }
  ELSE
    any_db_error := TRUE;

  IF (NOT any_db_error)
  {
    result := InitModuleIndependents([moduleinfo], FALSE, FALSE);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;

    result := InitModuleRegistryKeys([moduleinfo]);
    FOREVERY(RECORD msg FROM result.commitmessages)
      INSERT msg.text INTO retval.warnings AT END;
  }

  ro_result := RunRunOnceScripts(moduleinfo, "afterregistryupdate", FALSE);
  FOREVERY(STRING msg FROM ro_result.messages)
    INSERT msg INTO retval.warnings AT END;

  INTEGER umask := ToInteger(ReadRegistryKey("system.modulemgr.installumask"), 7*8*8 + 5*8 + 5*8, 8);
  FOREVERY(RECORD perm FROM moduleinfo.packagingpermissions)
  {
    STRING fullpath := MergePath(installpath, perm.file);
    SetUNIXPermissions(fullpath, perm.permissions  BITAND umask);
  }

  // Update WRD schemas
  UpdateAllModuleSchemas();

  // Recompile siteprofiles and refresh the webserver configuration in-line.
  RecompileSiteProfiles();

  // Softreset (used to clear all caches, now only linked to specific cache keys) restart needed scripts
  BroadcastEvent("system:softreset", [ toreload := DEFAULT STRING ARRAY ]);

  // Execute post-start scripts for this module in executetasks.whscr
  OBJECT link := ConnectToGlobalIPCPort("system:executetasks");
  IF (ObjectExists(link))
  {
    link->SendMessage([ task := "poststartmodule", modulename := modulename ]);
    link->Close();
  }

  RETURN retval;
}

// Creates module archives
PUBLIC STATIC OBJECTTYPE ModuleArchiver
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  STRING pvt_archivetype;

  STRING ARRAY pvt_defaultnopackagemasks;
  STRING ARRAY pvt_defaultnopackagepathmasks;

  /// Mask of files not to package, in uppercase
  STRING ARRAY pvt_nopackagemasks;
  /// Mask of paths not to package, in uppercase
  STRING ARRAY pvt_nopackagepathmasks;

  BOOLEAN pvt_disablechecks;

  STRING pvt_archivecomment;

  STRING pvt_userlogin;

  STRING pvt_userfullname;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /// Contenttype of generated archive, allowed: "application/x-gzip", "application/zip"
  PROPERTY archivetype(pvt_archivetype, pvt_archivetype);

  /// List of mask of files that will be ignored
  PROPERTY defaultnopackagemasks(pvt_defaultnopackagemasks, pvt_defaultnopackagemasks);

  /// If TRUE, disable checks for conflicts, packagingdownload.
  PROPERTY disablechecks(pvt_disablechecks, pvt_disablechecks);

  /// Comment to put in the archive
  PROPERTY archivecomment(pvt_archivecomment, pvt_archivecomment);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    this->pvt_archivetype := "application/x-gzip";
    this->pvt_defaultnopackagemasks := [ "CVS", ".svn", ".git", ".DS_Store" ];
    this->pvt_defaultnopackagepathmasks := [ "tests", "history/source.zip", "history/manifest.xml", "web/resources/tests", "include/tests", "screens/tests" ];
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  /** Return contents of a directory, auto-filters '.' and '..'.
      @param dir Directory
      @param mask Mask
      @return
      @cell return.name Entry name
      @cell return.type 0 = file, 1 = dir
      @cell return.modified Modtime
  */
  RECORD ARRAY FUNCTION GetDirectory(STRING dir, STRING mask)
  {
    RECORD ARRAY entries := ReadDiskDirectory(dir, mask);

    RETURN
        SELECT name
             , type
             , modified
          FROM entries;
  }

  /** Check filenames for strange stuff. Throw on stuff that really may not be there.
      @param entry File Entry
      @cell entry.name
      @cell entry.type
      @cell entry.modified
      @return Whether to include the file
  */
  BOOLEAN FUNCTION TestIncludeFile(STRING path, RECORD entry)
  {
    // Check for packaging excludes
    FOREVERY(STRING nopackage FROM this->pvt_nopackagemasks) // Already uppercase
      IF (ToUppercase(entry.name) LIKE nopackage)
        RETURN FALSE;

    STRING ufullpath := ToUppercase(path||entry.name);
    FOREVERY(STRING nopackage FROM this->pvt_nopackagepathmasks) // Already uppercase
      IF (ufullpath LIKE nopackage OR ufullpath LIKE nopackage||"/*")
        RETURN FALSE;

    RETURN TRUE;
  }

  /** Recursively add files and folders to the archive
      @param archive
      @param initialdir Folder with the module to pack
      @param curdir Current folder within the module
      @param modulename Name of the module
  */
  RECORD ARRAY FUNCTION RecurseAddFiles(OBJECT archive, STRING initialdir, STRING curdir, STRING modulename)
  {
    RECORD ARRAY entries := this->GetDirectory(initialdir || curdir, "*");
    RECORD ARRAY hashes;
    FOREVERY (RECORD entry FROM entries)
    {
      IF (NOT this->TestIncludeFile(curdir, entry))
        CONTINUE;

      STRING storename := modulename || "/" || curdir || entry.name;

      IF(entry.type=0)//file
      {
        BLOB diskfile := GetDiskResource(initialdir || curdir || entry.name);
        INSERT
            [ path :=       storename
            , sha1hash :=   GetHashForBlob(diskfile, "SHA-1")
            ] INTO hashes AT END;

        archive->AddFile(storename, diskfile, entry.modified);
      }
      ELSE IF(entry.type=1) //dir
      {
        archive->AddFolder(storename, entry.modified);
        hashes := hashes CONCAT this->RecurseAddFiles(archive, initialdir, curdir || entry.name || "/", modulename);
      }
    }
    RETURN hashes;
  }

  /** Create an archive from a module
      @param path Path to module data
      @param module Name of the module
      @param moduleinfo Module info
      @return
      @cell(blob) return.data Archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest Manifest data
  */
  RECORD FUNCTION CreateArchiveFromInfo(STRING path, STRING module, RECORD moduleinfo)
  {
    // Calculate the nopackage masks
    this->pvt_nopackagemasks :=
        SELECT AS STRING ARRAY DISTINCT ToUppercase(mask)
          FROM ToRecordArray(this->pvt_defaultnopackagemasks CONCAT moduleinfo.packagingnopackmask, "MASK");

    this->pvt_nopackagepathmasks :=
        SELECT AS STRING ARRAY DISTINCT ToUppercase(mask)
          FROM ToRecordArray(this->pvt_defaultnopackagepathmasks CONCAT moduleinfo.packagingnopackpathmask, "MASK");

    // Create the archive, set comment and add the files
    OBJECT archive := CreateNewArchive(this->pvt_archivetype);
    archive->archivecomment := this->pvt_archivecomment;

    RECORD ARRAY hashes := this->RecurseAddFiles(archive, path, "", module);

    IF (NOT RecordExists(SELECT FROM archive->entries WHERE fullpath = MergePath(module, "history")))
      archive->AddFolder(MergePath(module, "history"), GetCurrentDateTime());

    RECORD manifestdata := CreateModuleManifest(path, this->pvt_userlogin, this->pvt_userfullname, hashes, PTR this->TestIncludeFile);
    FOREVERY (RECORD file FROM manifestdata.files)
      archive->AddFile(MergePath(module, file.fullpath), file.data, file.modtime);

    // Get the data, close the archive and we're done
    archive->OptimizeArchiveSorting();
    BLOB data := archive->MakeBlob();
    archive->Close();

    RETURN
        [ data :=           data
        , fullversion :=    GetFullModuleVersion(moduleinfo, manifestdata.manifest)
        , manifest :=       manifestdata.manifest
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Private public API
  //

  PUBLIC RECORD ARRAY FUNCTION __GetSystemModuleManifestFiles(STRING path, STRING module)
  {
    this->pvt_nopackagemasks := STRING[];
    this->pvt_nopackagepathmasks := [ "HISTORY/SOURCE.ZIP", "HISTORY/MANIFEST.XML" ];

    // Create the source archive
    OBJECT archive := CreateNewArchive("zip");
    RECORD ARRAY hashes := this->RecurseAddFiles(archive, path, "", module);

    IF (NOT RecordExists(SELECT FROM archive->entries WHERE fullpath = MergePath(module, "history")))
      archive->AddFolder(MergePath(module, "history"), GetCurrentDateTime());

    RECORD manifestdata := CreateModuleManifest(path, this->pvt_userlogin, this->pvt_userfullname, hashes, PTR this->TestIncludeFile, [ ignoremodifications := TRUE ]);
    FOREVERY (RECORD file FROM manifestdata.files)
      archive->AddFile(MergePath(module, file.fullpath), file.data, file.modtime);

    // Get the data, close the archive and we're done
    BLOB data := archive->MakeBlob();
    archive->Close();

    RETURN manifestdata.files CONCAT
        [ [ data :=       data
          , fullpath :=   "history/source.zip"
          , modtime :=    manifestdata.files[0].modtime
          ]
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Set data about the current user (included in generated archives)
      @param login Login name
      @param fullname Full name
  */
  PUBLIC MACRO SetUserData(STRING login, STRING fullname)
  {
    this->pvt_userlogin := login;
    this->pvt_userfullname := fullname;
  }

  /** Create an archive of a module
      @param module Name of the module
      @return
      @cell(blob) return.data Module archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest
  */
  PUBLIC RECORD FUNCTION CreateArchive(STRING module)
  {
    RECORD moduleinfo := SELECT * FROM GetWebHareModules() WHERE name = module;

    IF (NOT RecordExists(moduleinfo))
      THROW NEW Exception(`No such module: ${module}`);

    IF (NOT this->pvt_disablechecks AND NOT moduleinfo.packagingdownload)
      THROW NEW Exception(`Module '${module}' may not be packaged`);

    RETURN this->CreateArchiveFromInfo(GetModuleInstallationRoot(module), module, moduleinfo);
  }


  /** Create an archive of a historic module version
      @param path Path of the module
      @param module Name of the module
      @return
      @cell(blob) return.data Module archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest
  */
  PUBLIC RECORD FUNCTION CreateArchiveFromVersion(STRING path, STRING module)
  {
    IF (path NOT LIKE "*/")
      path := path || "/";

    BLOB moduledefdata := GetDiskResource(path || "moduledefinition.xml");
    RECORD moduledef := ParseModuleDefinition(module, MakeXMLDocument(moduledefdata));

    RETURN this->CreateArchiveFromInfo(path, module, moduledef);
  }
>;


/** Moves a module folder from the installedmodules folder to the archive
    @param modulefolderpath Name of the module folder (like module.timestamp)
    @param obsoletiondate Date of obsoletiondate
    @return Whether the move was successful
*/
PUBLIC BOOLEAN FUNCTION ArchiveModuleVersionByPath(STRING modulefolderpath, DATETIME obsoletiondate)
{
  // Make sure archive folder exists
  STRING archiveroot := GetWebHareConfiguration().varroot || "archivedmodules";
  CreateDiskDirectoryRecursive(archiveroot, TRUE);

  // Calc the new old & new paths.
  STRING targetpath := archiveroot || "/" || Tokenize(modulefolderpath,'/')[END-1]|| "." || GetModuleFolderTimestamp();

  BOOLEAN result := MoveDiskPath(modulefolderpath, targetpath);
  IF(result = FALSE //looks like move failed
     AND NOT RecordExists(GetDiskFileProperties(modulefolderpath))) //but it's still gone
  {
    result := TRUE; //then we thought the module was still there but it isn't? consider it a success anyway
  }

  IF (result)
  {
    BroadcastEvent("system:modules.archivedmodule", DEFAULT RECORD);
  }
  RETURN result;
}

PUBLIC RECORD ARRAY FUNCTION EnrichInstalledModulesWithManifests(RECORD ARRAY modules)
{
  FOREVERY(RECORD mod FROM modules)
  {
    RECORD manifest;
    TRY
    {
      manifest := ParseModuleManifest(OpenXMLDoc("mod::" || mod.name || "/history/manifest.xml",FALSE).doc);
    }
    CATCH(OBJECT<RetrieveResourceException> e)
    {
      manifest := ParseModuleManifest(DEFAULT OBJECT);
      //ignoring retrieve errors
    }

    INSERT CELL manifest := manifest
              , fullversion := GetFullModuleVersion(mod, manifest)
              , root := GetModuleInstallationRoot(mod.name)
              , source_repository_url :=   manifest.source_repository_url
              , source_repository_uuid :=  manifest.source_repository_uuid
              , source_revision :=         manifest.source_revision
              , source_uncommittedchanges := manifest.has_modifications
           INTO mod;

    modules[#mod] := mod;
  }
  RETURN modules;
}

DATETIME FUNCTION GetModDateFromPath(STRING modulepath)
{
  IF(modulepath NOT LIKE "*/*")
    RETURN DEFAULT DATETIME;
  STRING lasttok := Tokenize(modulepath,'/')[END-2];
  RETURN lasttok LIKE "*.2*Z" ? MakeDateFromText(Tokenize(lasttok,'.')[1]) : DEFAULT DATETIME;
}

PUBLIC RECORD ARRAY FUNCTION GetInstalledModulesOverview(BOOLEAN include_deleted)
{
  RECORD ARRAY modules := GetWebHareModules();
  STRING builtinroot := GetWebHareConfiguration().installationroot || "modules/";
  STRING whversion := GetWebhareVersionInfo().version;

  modules := SELECT TEMPORARY path := GetModuleInstallationRoot(name)
                  , TEMPORARY isbuiltin := path LIKE builtinroot || "*"
                  , TEMPORARY lastmodified := isbuiltin ? DEFAULT DATETIME : GetModDateFromPath(path)
                  , name
                  , path :=                    path
                  , version :=                 isbuiltin ? whversion : version
                  , description
                  , packagingupgrade
                  , candownload :=             packagingdownload
                  , lastmodified :=            lastmodified
                  , isdeleted :=               FALSE
                  , isinstalled :=             lastmodified != DEFAULT DATETIME //any mod with a timestamp in its name must be installed
                  , isbuiltin :=               isbuiltin
                  , configscreen
               FROM modules
           ORDER BY name;

  IF (include_deleted)
  {
    // Get all archived modules
    STRING pathroot := GetWebHareConfiguration().varroot || "archivedmodules/";
    RECORD ARRAY archived := ReadDiskDirectory(pathroot, "*");

    // Sort by reverse deletion date
    archived := SELECT * FROM archived WHERE name LIKE "*.*Z" ORDER BY Tokenize(name,'.')[END-1] DESC;

    FOREVERY (RECORD rec FROM archived)
    {
      STRING name := Tokenize(rec.name,'.')[0];
      RECORD pos := RecordLowerBound(modules, [ name := name ] , [ "NAME" ]);
      IF (NOT pos.found)
      {
        INSERT
            [ name :=             name
            , path :=             rec.path
            , version :=          ""
            , description :=      ""
            , packagingupgrade := FALSE
            , candownload :=      FALSE
            , lastmodified :=     rec.path LIKE "*.*Z.*Z" ? GetModDateFromPath(rec.path) : DEFAULT DATETIME //paths with double timestamps have an actual moddate, single timestamps are git module deletions
            , isdeleted :=        TRUE
            , isinstalled :=      FALSE
            , isbuiltin :=        FALSE
            , configscreen :=     ""
            ] INTO modules AT pos.position;
      }
    }
  }
  RETURN modules;
}

STRING FUNCTION RemoveFirstPathElement(STRING fullpath)
{
  INTEGER pos := SearchSubstring(fullpath, "/");
  IF (pos = 0) // Compensate for '/modulename/blabla', just in case
  {
    fullpath := SubString(fullpath, pos + 1);
    pos := SearchSubstring(fullpath, "/");
  }
  IF (pos = -1)
    RETURN "";
  RETURN SubString(fullpath, pos + 1);
}

RECORD ARRAY FUNCTION ScanModuleDirectory(STRING path, STRING localpath)
{
  RECORD ARRAY entries := ReadDiskDirectory(path, "*");

  entries :=
      SELECT *
           , path :=        localpath
           , fullpath :=    MergePath(localpath, name)
        FROM entries;

  FOREVERY (RECORD entry FROM entries)
    IF (entry.type = 1)
      entries := entries CONCAT ScanModuleDirectory(MergePath(path, entry.name), entry.fullpath);

  RETURN entries;
}

BOOLEAN FUNCTION HaveDateChangedFromZip(DATETIME zipdate, DATETIME currentdate)
{
  IF (GetDayCount(zipdate) != GetDayCount(currentdate))
    RETURN TRUE;

  // Zip file has 2sec granularity
  RETURN (GetMsecondCount(zipdate) / 2000) != (GetMsecondCount(currentdate) / 2000);
}

PUBLIC RECORD FUNCTION GetModuleModifiedFiles(STRING moduleroot, BOOLEAN include_sourcedata)
{
  STRING sourcezippath := MergePath(moduleroot, "history/source.zip");
  BLOB sourcezip := GetDiskResource(sourcezippath, [ allowmissing := TRUE ]);

  IF (LENGTH(sourcezip) = 0)
  {
    RETURN
        [ success :=  FALSE
        , code :=     "NOSOURCE"
        , files :=    DEFAULT RECORD ARRAY
        ];
  }

  OBJECT sourcearchive := OpenExistingArchive(sourcezip);

  RECORD ARRAY source_entries :=
      SELECT name
           , path :=              RemoveFirstPathElement(fullpath)
           , source_size :=       INTEGER64(size)
           , current_size :=      -1i64
           , source_modtime :=    modtime
           , current_modtime :=   DEFAULT DATETIME
           , xsource :=           1
           , originalfullpath :=  fullpath
        FROM sourcearchive->entries
       WHERE type = 0 AND RemoveFirstPathElement(fullpath) NOT LIKE "history/*"
    ORDER BY fullpath;

  RECORD ARRAY current_entries :=
      SELECT name
           , path :=              fullpath
           , source_size :=       -1i64
           , current_size :=      size64
           , source_modtime :=    DEFAULT DATETIME
           , current_modtime :=   modified
           , xsource :=           2
           , originalfullpath :=  ""
        FROM ScanModuleDirectory(moduleroot, "")
       WHERE type = 0
         AND fullpath != "source.zip" AND fullpath NOT LIKE "history/*"
    ORDER BY fullpath;

  RECORD ARRAY result :=
      SELECT path
           , name :=              Any(name)
           , status :=            [ "", "removed", "added", "modified"][SUM(xsource)]
           , source_size :=       MAX(source_size)
           , current_size :=      MAX(current_size)
           , source_modtime :=    MAX(source_modtime)
           , current_modtime :=   MAX(current_modtime)
           , originalfullpath :=  (SELECT AS STRING path FROM GroupedValues([ path := originalfullpath ]) WHERE path != "")
        FROM source_entries CONCAT current_entries
    GROUP BY path
      HAVING MAX(source_size) != MAX(current_size) OR HaveDateChangedFromZip(MAX(source_modtime), MAX(current_modtime))
    ORDER BY path;

  IF (include_sourcedata)
  {
    result :=
        SELECT *
             , source_data :=     sourcearchive->GetFile(originalfullpath)
          FROM result;
  }

  sourcearchive->Close();

  RETURN
      [ success :=    TRUE
      , code :=       ""
      , files :=      result
      ];
}

PUBLIC RECORD FUNCTION LocateGitExecutable()
{
  RETURN LocateExecutable("", "git");
}

RECORD FUNCTION LocateExecutable(STRING tryregkey, STRING executablename)
{
  STRING ARRAY paths;
  STRING registrypath := tryregkey != "" ? ReadRegistryKey(tryregkey) : "";
  STRING result;

  IF (registrypath = "")
  {
    STRING path := GetEnvironmentVariable("PATH");
    path := Substitute(path, ";", ":");
    IF (path != "")
      paths := Tokenize(path, ":");
  }
  ELSE
  {
    // Is the path to a file?
    RECORD data := GetDiskFileProperties(registrypath);
    IF (RecordExists(data) AND data.type = 0)
      result := registrypath;

    paths := [ registrypath ];
  }

  IF (result = "")
  {
    FOREVERY (STRING path FROM paths)
    {
      STRING testpath := MergePath(path, executablename);

      RECORD data := GetDiskFileProperties(testpath);
      IF (RecordExists(data) AND data.type = 0)
      {
        result := testpath;
        BREAK;
      }
    }
  }

  RETURN
      [ value :=      result
      , ttl :=        5 * 60 * 60
      , eventmasks := [ "system:registry.system.modules" ]
      ];
}

PUBLIC RECORD FUNCTION ExecuteGitCommand(STRING ARRAY parameters, BOOLEAN captureoutput DEFAULTSTO TRUE)
{
  STRING gitpath := GetAdhocCached([ type := "gitpath" ], PTR LocateGITExecutable);

  OBJECT proc := CreateProcess(gitpath, parameters, FALSE, captureoutput, captureoutput, captureoutput);
  IF(NOT captureoutput)
  {
    proc->share_stdout := TRUE;
    proc->share_stderr := TRUE;
  }
  proc->Start();

  INTEGER stream := CreateStream();
  OBJECT itr := MakeProcessAsyncIterator(proc);
  WHILE (TRUE)
  {
    RECORD rec := WaitForPromise(itr->Next());
    IF (rec.done)
    {
      RETURN CELL
          [ rec.value.exitcode
          , output := BlobToString(MakeBlobFromStream(stream))
          ];
    }
    IF (rec.value.type = "output")
      PrintTo(stream, rec.value.line || "\n");
  }
}

PUBLIC RECORD FUNCTION AnalyzeGITModuleDir(STRING modulepath, BOOLEAN with_commits, BOOLEAN with_ls_remote)
{
  RECORD result :=
      [ revision :=                   ""
      , localremoterevision :=        ""
      , remoterevision :=             ""
      , repository_url :=             ""
      , files :=                      DEFAULT RECORD ARRAY
      , branch :=                     ""
      , commits :=                    DEFAULT RECORD ARRAY
      ];

  RECORD status := GetGitRepoInfo(modulepath, with_ls_remote);
  IF (status.status != "ok")
    RETURN DEFAULT RECORD;

  TRY
  {
    result.revision := status.head_oid;
    result.localremoterevision := status.origin_oid;
    result.repository_url := status.remote_url;
    result.branch := status.branch;

    IF (with_ls_remote)
    {
      // ADDME: should export tracked branch, local branch might not have the same name
      result.remoterevision :=
          SELECT AS STRING id
            FROM status.remote_refs
           WHERE target = "refs/heads/" || status.branch;
    }

    FOREVERY (RECORD file FROM RECORD ARRAY(status.paths))
    {
      INSERT
          [ fullpath :=   file.path
          , status :=     Detokenize(file.status, " ")
          , repostatus := ""
          ] INTO result.files AT END;
    }

    IF (with_commits)
      result.commits := RECORD ARRAY(status.commits);

    RETURN result;
  }
  CATCH (OBJECT e)
  {
    RETURN DEFAULT RECORD;
  }
}

/** Returns revision information for all modules in source control
    @return List of modules
    @cell return.
*/
RECORD ARRAY FUNCTION GetRevisionOfModules(STRING onlymodule DEFAULTSTO "")
{
  RECORD ARRAY results;

  FOREVERY (STRING modulesdir FROM GetWebHareConfiguration().moduledirs)
  {
    FOREVERY (RECORD rec FROM SELECT * FROM ReadDiskDirectory(modulesdir, "*") WHERE type = 1 AND name NOT IN [ ".", ".."])
    {
      STRING fullpath := MergePath(modulesdir, rec.name) || "/";
      IF (RecordExists(GetDiskFileProperties(MergePath(fullpath, ".git"))))
        results := results CONCAT GetRevisionOfGitModules(fullpath, TRUE, onlymodule);
      ELSE IF (NOT RecordExists(GetDiskFileProperties(MergePath(fullpath, "moduledefinition.xml"))))
      {
        FOREVERY (RECORD subrec FROM SELECT * FROM ReadDiskDirectory(fullpath, "*") WHERE type = 1 AND name NOT IN [ ".", ".."])
        {
          STRING fullsubpath := MergePath(fullpath, subrec.name) || "/";
          IF (RecordExists(GetDiskFileProperties(MergePath(fullsubpath, ".git"))))
            results := results CONCAT GetRevisionOfGitModules(fullsubpath, FALSE, onlymodule);
        }
      }
    }
  }

  RETURN results;
}

/** Returns revision information for all modules in source control
    @return List of modules
    @cell return.
*/
PUBLIC RECORD ARRAY FUNCTION GetRevisionOfAllModules()
{
  RETURN GetRevisionOfModules("");
}

/** Get revision information for a single module
    @return Module data, if found
*/
PUBLIC RECORD FUNCTION GetRevisionOfSingleModule(STRING modulename)
{
  RETURN GetRevisionOfModules(modulename);
}

/** Return list of modules within a GIT repo root
    @param modulepath Repo root
    @param topdir Whether this is a toplevel module-directory (and thus can contain module directories itself)
    @param onlymodule If not empty, skip modules with other names
    @cell return.name Module name
    @cell return.type Source control type (always "git")
    @cell return.revision SHA of the HEAD for the current repo
    @cell return.localremoterevision Current view of the the SHA of the branch HEAD at the remote origin
    @cell return.remoterevision Real SHA of the branch head at the remote origin (not supported for now)
    @cell return.repository_url URL of the remote
    @cell return.branch Name of the current branch (eg. "master")
    @cell return.files List of modified files
    @cell return.files.fullpath
    @cell return.files.status One of "changed" / "problematic" /  "deleted" / "added";
    @cell return.commit List of most recent commits
    @cell return.commit.id SHA of the commit
    @cell return.commit.date Date of the commit
*/
RECORD ARRAY FUNCTION GetRevisionOfGitModules(STRING modulepath, BOOLEAN topdir, STRING onlymodule)
{
  IF (NOT RecordExists(GetDiskFileProperties(MergePath(modulepath, "moduledefinition.xml"))))
    RETURN DEFAULT RECORD ARRAY;

  IF (modulepath NOT LIKE "*/")
    modulepath := modulepath || "/";

  STRING name := GetNameFromPath(Left(modulepath, LENGTH(modulepath) - 1));

  IF (onlymodule != "" AND name != onlymodule)
    RETURN DEFAULT RECORD ARRAY;

  RECORD data := AnalyzeGITModuleDir(modulepath, TRUE, FALSE);

  IF(NOT RecordExists(data))
    RETURN DEFAULT RECORD ARRAY;

  RETURN [ MakeMergedrecord(
                [ name :=   name
                , type :=   "git"
                ], data)
         ];
}

RECORD FUNCTION CreateModuleManifest(STRING modulepath, STRING login, STRING fullname, RECORD ARRAY filehashes, FUNCTION PTR testinclude, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ ignoremodifications :=  FALSE
      ], options);

  DATETIME now := GetCurrentDateTime();

  BLOB existing_manifest_data;

  IF (NOT options.ignoremodifications)
    existing_manifest_data := GetDiskResource(MergePath(modulepath, "history/manifest.xml"), [ allowmissing := TRUE ]);

  OBJECT doc;
  OBJECT xml_history;
  OBJECT xml_files;

  RECORD ARRAY files;

  IF (LENGTH(existing_manifest_data) != 0)
  {
    doc := MakeXMLDocument(existing_manifest_data);

    OBJECT query := doc->CreateXPathQuery();
    query->RegisterNamespace("mnf", xmlns_module_manifest);

    OBJECT ARRAY histories := query->ExecuteQuery("//mnf:manifest/mnf:history")->GetCurrentElements();
    IF (LENGTH(histories) > 0)
      xml_history := histories[0];

    OBJECT ARRAY fileses := query->ExecuteQuery("//mnf:manifest/mnf:sourcefiles")->GetCurrentElements();
    IF (LENGTH(fileses) > 0)
      xml_files := fileses[0];
  }
  ELSE
  {
    OBJECT domimpl := NEW XMLDomImplementation;
    doc := domimpl->CreateDocument("http://www.webhare.net/module-manifest/", "manifest", DEFAULT OBJECT);
    doc->documentelement->SetAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.webhare.net/module-manifest/");
  }

  IF (NOT ObjectExists(xml_files))
  {
    xml_files := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "sourcefiles");
    doc->documentelement->AppendChild(xml_files);
  }
  ELSE
  {
    WHILE (ObjectExists(xml_files->firstchild))
      xml_files->RemoveChild(xml_files->firstchild);
  }

  FOREVERY (RECORD hash FROM SELECT * FROM filehashes ORDER BY path)
  {
    OBJECT file := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "file");
    file->SetAttribute("path", RemoveFirstPathElement(hash.path));
    file->SetAttribute("sha1hash", ToLowercase(EncodeBase16(hash.sha1hash)));
    xml_files->AppendChild(file);
  }

  IF (NOT ObjectExists(xml_history))
  {
    xml_history := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "history");
    doc->documentelement->AppendChild(xml_history);
  }

  BOOLEAN first_changeset := LENGTH(xml_history->childnodes->GetCurrentElements()) = 0;

  OBJECT xml_changeset := doc->CreateElementNS(xmlns_module_manifest, "changeset");
  xml_history->AppendChild(xml_changeset);

  xml_changeset->SetAttribute("date", FormatISO8601DateTime(now, "", "", "", TRUE));
  xml_changeset->SetAttribute("server", GetServerName());

  IF (login != "")
    xml_changeset->SetAttribute("userlogin", login);
  IF (fullname != "")
    xml_changeset->SetAttribute("userfullname", fullname);

  // Add modified files & source of modified files if present
  OBJECT xml_modifications := doc->CreateElementNS(xmlns_module_manifest, "modifications");
  xml_changeset->AppendChild(xml_modifications);

  // Add list of incorporated commits
  OBJECT xml_commits := doc->CreateElementNS(xmlns_module_manifest, "commits");
  xml_changeset->AppendChild(xml_commits);

  BOOLEAN is_git;
  STRING revision;

  IF (NOT first_changeset)
  {
    xml_changeset->SetAttribute("source", "download");
  }
  ELSE
  {
    xml_changeset->SetAttribute("source", "local");

    RECORD gitdirdata := GetDiskFileProperties(MergePath(modulepath, ".git"));

    IF (RecordExists(gitdirdata))
    {
      RECORD md := AnalyzeGITModuleDir(modulepath, TRUE, TRUE);
      IF (RecordExists(md))
      {
        is_git := TRUE;

        xml_changeset->SetAttribute("source", "git");
        xml_changeset->SetAttribute("sourcerepositoryurl", md.repository_url || "\t" || md.branch);
        xml_changeset->SetAttribute("sourcerepositoryuuid", md.repository_url);
        xml_changeset->SetAttribute("sourcerevision", md.revision);
        xml_changeset->SetAttribute("sourcelocalremoterevision", md.localremoterevision);
        xml_changeset->SetAttribute("sourceremoterevision", md.remoterevision);

        FOREVERY (RECORD rec FROM md.files)
        {
          INTEGER spos := SearchLastSubString(rec.fullpath, "/");
          IF (testinclude != DEFAULT FUNCTION PTR AND NOT testinclude(
                Left(rec.fullpath, spos + 1),
                [ name := SubString(rec.fullpath, spos + 1)
                ]))
            CONTINUE;

          OBJECT xml_file := doc->CreateElementNS(xmlns_module_manifest, "file");
          xml_modifications->AppendChild(xml_file);

          xml_file->SetAttribute("path", rec.fullpath);
          xml_file->SetAttribute("status", rec.status);
        }

        FOREVERY (RECORD rec FROM md.commits)
        {
          OBJECT xml_commit := doc->CreateElementNS(xmlns_module_manifest, "commit");
          xml_commits->AppendChild(xml_commit);

          xml_commit->SetAttribute("id", rec.id);
          xml_commit->SetAttribute("date", FormatISO8601DateTime(rec.date, "", "milliseconds"));
        }
      }
    }
  }

  IF (NOT is_git AND NOT options.ignoremodifications)
  {
    RECORD mods := GetModuleModifiedFiles(modulepath, TRUE);

    RECORD ARRAY modified_files;
    IF (mods.success)
    {
      FOREVERY (RECORD mod FROM mods.files)
      {
        INTEGER spos := SearchLastSubString(mod.path, "/");
        IF (testinclude != DEFAULT FUNCTION PTR AND NOT testinclude(
              Left(mod.path, spos),
              [ name := SubString(mod.path, spos + 1)
              ]))
          CONTINUE;

        INSERT mod INTO modified_files AT END;
      }
    }

    IF (LENGTH(modified_files) != 0)
    {
      OBJECT archive := CreateNewArchive("zip");
      FOREVERY (RECORD mod FROM modified_files)
      {
        IF (mod.status != "added")
          archive->AddFile(mod.path, mod.source_data, mod.source_modtime);

        OBJECT xml_file := doc->CreateElementNS(xmlns_module_manifest, "file");
        xml_modifications->AppendChild(xml_file);

        xml_file->SetAttribute("path", mod.path);
        xml_file->SetAttribute("status", mod.status);
      }

      STRING archivename := "source-" || FormatISO8601DateTime(now, "", "milliseconds", "", FALSE) || ".zip";
      STRING sourcepath := "history/" || archivename;

      INSERT [ fullpath := sourcepath, data := archive->MakeBlob(), modtime := now ] INTO files AT END;

      xml_modifications->SetAttribute("originalsarchive", sourcepath);
      archive->Close();
    }
  }

  doc->NormalizeDocument();

  INSERT [ fullpath := "history/manifest.xml", data := doc->GetDocumentBlob(FALSE), modtime := now ] INTO files AT END;

  RETURN
      [ manifest :=  ParseModuleManifest(doc)
      , files :=     files
      ];
}

PUBLIC MACRO __CreateWebhareModulesManifests(STRING ARRAY list, STRING ARRAY exclude)
{
  OBJECT ar := NEW ModuleArchiver;

  FOREVERY (RECORD dir FROM ReadDiskDirectory(MergePath(GetWebHareConfiguration().installationroot, "modules"), "*"))
  {
    IF (LENGTH(list) != 0 AND dir.name NOT IN list)
      CONTINUE;
    IF (dir.name IN exclude)
      CONTINUE;

    IF (RecordExists(GetDiskFileProperties(MergePath(dir.path, "moduledefinition.xml"))))
    {
      RECORD ARRAY newfiles := ar->__GetSystemModuleManifestFiles(dir.path || "/", dir.name);

      FOREVERY (RECORD rec FROM newfiles)
      {
        CreateDiskDirectoryRecursive(MergePath(dir.path, GetDirectoryFromPath(rec.fullpath)), TRUE);
        StoreDiskFile(MergePath(dir.path, rec.fullpath), rec.data, [ overwrite := TRUE ]);
        SetFileModificationDate(MergePath(dir.path, rec.fullpath), rec.modtime);
      }
    }
  }
}

PUBLIC RECORD FUNCTION GetAuditLogDataFromManifest(RECORD manifest)
{
  RECORD manifestdata :=
      [ warnings :=         STRING[]
      , repository :=       ""
      , commit :=           ""
      , original_source :=  ""
      ];

  IF (RecordExists(manifest))
  {
    manifestdata.original_source := manifest.original_source;
    manifestdata.repository := manifest.source_repository_url;
    manifestdata.commit := manifest.source_revision;

    IF (manifest.original_source = "git")
    {
      IF (manifest.source_revision != manifest.source_localremoterevision OR manifest.source_revision != manifest.source_remoterevision)
      {
        IF (manifest.source_remoterevision != "" AND manifest.source_localremoterevision != manifest.source_remoterevision)
        {
          INSERT "notuptodate" INTO manifestdata.warnings AT END;
        }
        IF (manifest.source_localremoterevision = "")
        {
          // Local branch is not present on the origin - feature branch that hasn't been pushed yet
          INSERT "branchnotonorigin" INTO manifestdata.warnings AT END;
        }
        ELSE IF (manifest.source_revision != manifest.source_localremoterevision)
        {
          // Either uncommitted changes or not rebased yet
          IF (RecordExists(SELECT FROM manifest.commits WHERE id = manifest.source_localremoterevision))
          {
            // Local remote is ancestor of current commit - so current commit just hasn't been pushed yet
            INSERT "unpushedchanges" INTO manifestdata.warnings AT END;
          }
          ELSE
          {
            // Remote is not an ancestor of current version - have older version checked out or need to rebase
            INSERT "notatbranchhead" INTO manifestdata.warnings AT END;
          }
        }
      }

      IF (manifest.has_modifications)
      {
        INSERT "uncommittedchanges" INTO manifestdata.warnings AT END;
      }
    }
    ELSE
      INSERT "notgit" INTO manifestdata.warnings AT END;
  }

  IF (NOT RecordExists(manifest))
    INSERT "nomanifest" INTO manifestdata.warnings AT END;

  RETURN manifestdata;
}
