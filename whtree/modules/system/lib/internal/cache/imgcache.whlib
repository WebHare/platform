<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internal/graphics.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::graphics/filters.whlib";

LOADLIB "mod::publisher/lib/database.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/cluster/secrets.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";

LOADLIB "mod::wrd/lib/database.whlib";

//ADDME rename us to cache/implementation.whlib or something similar?


//store last requested unified cache object as it's very common for the same image to be requested repeatedly with different dimensions
RECORD lastobjinfo;

DATETIME moddatecutoff;
PUBLIC STRING imgcache_globalbaseurl; //set by eg webdesign to enforce CDN preferences
PUBLIC STRING imgcache_debug_urlschema := "v2";
CONSTANT STRING u1packet := "type:C,id:L,cc:L,md:L,ms:L,imgdatalen:C";

BOOLEAN FUNCTION IsImageRefpointRelevant(RECORD resizemethod)
{
  RETURN resizemethod.method IN ["crop","cropcanvas","fill"];
}

RECORD FUNCTION GetObjInfo(INTEGER sourcetype, INTEGER sourceid)
{
  SWITCH(sourcetype)
  {
    CASE 1
    {
      RECORD objinfo := SELECT creationdate, modificationdate, folder := isfolder ? id : parent, settingdata := scandata
                         FROM system.fs_objects
                        WHERE id = sourceid;
      IF(NOT RecordExists(objinfo))
        THROW NEW Exception("Invalid fsobject id #" || sourceid);

      INSERT CELL fsobjectfolder := objinfo.folder INTO objinfo;
      RETURN objinfo;
    }
    CASE 2
    {
      RECORD objinfo := SELECT fs_objects.creationdate
                            , fs_objects.modificationdate
                            , folder := isfolder ? fs_objects.id : fs_objects.parent
                            , settingdata := fs_settings.setting
                         FROM system.fs_objects
                            , system.fs_settings
                            , system.fs_instances
                        WHERE fs_settings.id = sourceid
                              AND fs_settings.fs_instance = fs_instances.id
                              AND fs_instances.fs_object = fs_objects.id;
      IF(NOT RecordExists(objinfo))
        THROW NEW Exception("Invalid setting id #" || sourceid);

      INSERT CELL fsobjectfolder := objinfo.folder INTO objinfo;
      RETURN objinfo;
    }
    CASE 3
    {
      RECORD objinfo := SELECT entities.creationdate, entities.modificationdate, settingdata := entity_settings.rawdata
                        FROM wrd.entities, wrd.entity_settings
                       WHERE entity_settings.id = VAR sourceid
                             AND entity_settings.entity = entities.id;

      IF(NOT RecordExists(objinfo))
        THROW NEW Exception("Invalid wrd setting id #" || sourceid);

      INSERT CELL fsobjectfolder := 0 INTO objinfo;
      RETURN objinfo;
    }
    CASE 4 //publisher formresult attachment
    {
      RECORD objinfo := SELECT creationdate := formresults.when
                      , modificationdate := formresults.modified
                      , settingdata := formattachments.metadata
                   FROM publisher.formresults, publisher.formattachments
                  WHERE formattachments.id = VAR sourceid
                        AND formattachments.formresult = formresults.id;

      IF(NOT RecordExists(objinfo))
        THROW NEW Exception("Invalid wrd setting id #" || sourceid);
      INSERT CELL fsobjectfolder := 0 INTO objinfo;
      RETURN objinfo;
    }
    DEFAULT
    {
      THROW NEW Exception(`Unrecognized source type ${sourcetype}`);
    }
  }
}

/** datatype: 1= img, 2 file, 3 embed
    sourcetype: 1 = system:whfs
          2 = system:whfssettings
          3 = wrd:settings
          */
PUBLIC STRING FUNCTION GetUnifiedCacheURL(STRING baseurl, INTEGER datatype, INTEGER sourcetype, INTEGER sourceid, RECORD options)
{
  IF(sourceid = 0)
    RETURN "";
  IF(datatype = 1 AND NOT RecordExists(options))
    THROW NEW Exception("A scalemethod is required for images");
  IF(datatype = 2 AND CellExists(options,'method'))
    THROW NEW Exception("A cached file cannot have a scale method. Did you mean to use one of the image APIs ?");

  IF(sourceid=0)
    RETURN "";

  BOOLEAN use_legacy_urlschema := imgcache_debug_urlschema = "v1";

  IF(moddatecutoff = DEFAULT DATETIME)
    moddatecutoff := ReadRegistryKey("system.cache.moddatecutoff");

  RECORD objinfo;
  IF(RecordExists(lastobjinfo) AND lastobjinfo.sourcetype = sourcetype AND lastobjinfo.sourceid = sourceid)
    objinfo := lastobjinfo;
  ELSE
    objinfo := GetObjInfo(sourcetype, sourceid);

  STRING mimetype := datatype = 1 AND CellExists(options,'format') ? options.format : "";


  RECORD filedata := SplitBlobSetting(objinfo.settingdata, DEFAULT BLOB, 0);
  IF(NOT RecordExists(filedata))
  {
    IF(sourcetype = 1) //unconverted file? this may happen as long as not everyone is at least one upgrade past 4.12+ (ie we're no longer doing a scandata upgrade)
    {
      filedata := ScanBlob((SELECT AS BLOB data FROM system.fs_objects WHERE id = sourceid), '');
    }
    ELSE
    {
      THROW NEW Exception(`Received invalid filedata for sourcetype #${sourcetype} source #${sourceid}`);
    }
  }
  IF(mimetype = "" AND RecordExists(filedata))
    mimetype := filedata.mimetype;
  IF(mimetype = "" AND sourcetype = 1)
    mimetype := ScanBlob((SELECT AS BLOB data FROM system.fs_objects WHERE id = sourceid), '').mimetype;

  STRING cachehost;
  RECORD hostdata;
  STRING hosthash;
  STRING filename;
  BOOLEAN embed := datatype = 1 OR (CellExists(options,'embed') AND options.embed=TRUE);

  IF(CellExists(options,'cachehost'))
    cachehost := options.cachehost;

  IF(CellExists(options,'filename'))
    filename := options.filename;

  IF(CellExists(options,'hosthash'))
  {
    IF(cachehost="")
      THROW NEW Exception("A resize method may only contain a 'hosthash' if it also specifies a 'cachehost'");
    hosthash := options.hosthash;
  }
  IF(CellExists(options,'hostdata'))
  {
    IF(cachehost="")
      THROW NEW Exception("A resize method may only contain a 'hostdata' if it also specifies a 'cachehost'");
    hostdata := options.hostdata;
  }

  RECORD scalemethod;
  BOOLEAN allowanyextension := CellExists(options, 'allowanyextension') ? options.allowanyextension : FALSE;
  IF(datatype = 1)
  {
    scalemethod := options;
    DELETE CELL cachehost, filename, hosthash, hostdata, allowanyextension FROM scalemethod;
    scalemethod := ValidateResizeMethod(scalemethod);
  }

  /* Format of added imginfo fields
     _t type (U8)
     _i id (U32)
     _c c^c (U32)
     _md = (U32)
     _ms = (U32) */

  STRING imgdata;
  IF(RecordExists(scalemethod))
  {
    imgdata := GfxPackImageResizeMethod(scalemethod);
    IF(Length(imgdata)>255)
      THROW NEW Exception("imgdata unexpectedly too long");
    IF(Length(imgdata)=0)
      THROW NEW Exception("imgdata could not be generated");
  }

  INTEGER md,ms;
  IF(objinfo.modificationdate >= moddatecutoff AND filedata.hash != "")
  {
    STRING hash := DecodeBase64(filedata.hash);
    IF(datatype =1 AND RecordExists(filedata.refpoint) AND IsImageRefpointRelevant(options))
      hash := GetMD5Hash(filedata.hash || EncodeHSON(filedata.refpoint));

    STRING hashdata := EncodeBase16(hash);
    md := ToInteger(Left(hashdata,8),0,16);
    ms := ToInteger(Substring(hashdata,8,8),0,16);
  }
  ELSE
  {
    md := GetDayCount(objinfo.modificationdate);
    ms := GetMsecondCount(objinfo.modificationdate);
  }

  STRING packet := "\x01" || EncodePacket(u1packet,
    [ type := sourcetype
    , id := sourceid
    , cc := GetDayCount(objinfo.creationdate) BITXOR GetMsecondCount(objinfo.creationdate)
    , md := md
    , ms := ms
    , imgdatalen := Length(imgdata)
    ]) || imgdata;

  STRING ARRAY validextensions;
  IF(datatype=1)
  {
    IF(mimetype="image/jpeg")
      validextensions := [ ".jpg" ];
    ELSE IF(mimetype="image/png" OR mimetype="image/x-bmp" OR mimetype="image/tiff")
      validextensions := [ ".png" ];
    ELSE IF(mimetype="image/gif")
      validextensions := [ ".gif" ];
    ELSE
      RETURN ""; //if someone got an incorrect filetype into something that should have been an image, don't crash on render - should have been prevented earlier.
  }
  ELSE
  {
    validextensions := SELECT AS STRING ARRAY "." || ToLowercase(mimetypes.extension) FROM system.mimetypes WHERE mimetypes.mimetype = VAR mimetype;
  }

  STRING useextension;
  IF(filename LIKE "*.*")
  {
    STRING fileext := ToLowercase(GetExtensionFromPath(filename));
    IF(Length(validextensions) > 0 AND fileext NOT IN validextensions AND NOT allowanyextension)
    {
      useextension := validextensions[0];
    }
    ELSE
    {
      useextension := fileext;
      filename := Left(filename, Length(filename) - Length(useextension));
    }
  }
  ELSE IF (Length(validextensions) > 0 AND NOT allowanyextension)
    useextension := validextensions[0];

  IF(RecordExists(hostdata))
  {
    //Wrap the packet..
    STRING data := EncodeHSON(hostdata);
    packet := "\x03" || EncodePacket("datalen:S", [ datalen := Length(data) ]) || data || packet;
  }

  STRING hash := Left(GetHashForString(packet || hosthash || useextension || GetClusterKeyBase("cachesecret"), "MD5"),4);
  packet := ToLowercase(EncodeBase16(hash || packet));

  IF (use_legacy_urlschema)
    packet := Left(packet,2) || "/" || Substring(packet,2);

  STRING suffix := datatype=1 ? "i" : embed ? "e" : "f";
  suffix := suffix || packet;

  filename := Left(filename, 80);
  IF (use_legacy_urlschema)
  {
    IF(embed = TRUE AND filename != "")
    {
      INTEGER slashpos := SearchLastSubstring(suffix,'/');
      suffix := Left(suffix, slashpos+1) || EncodeURL(filename || '-' || Substring(suffix,slashpos+1));
    }
    suffix := suffix || useextension;
  }
  ELSE
  {
    suffix := suffix || "/" || EncodeURL( (filename ?? "data") || useextension);
  }

  IF(cachehost != "")
  {
    IF(cachehost NOT LIKE "*/")
      cachehost := cachehost || "/";
    RETURN cachehost || suffix;
  }

  RETURN FixupReturnURL(baseurl, objinfo.fsobjectfolder, "/.uc/" || suffix);
}

RECORD FUNCTION GetCachableCDNUrl(INTEGER fsobjectid)
{
  RECORD siteinfo := SELECT cdnbaseurl
                          , sites.id
                       FROM system.sites, system.fs_objects
                      WHERE sites.id = fs_objects.parentsite
                            AND fs_objects.id = fsobjectid;

  IF (NOT RecordExists(siteinfo))
    RETURN [ value := siteinfo, ttl := 5000 ];

  RETURN
      [ value :=        siteinfo.cdnbaseurl = "" ? DEFAULT RECORD : siteinfo
      , eventmasks :=   [ "system:whfs.sitemeta." || siteinfo.id ]
      ];
}

STRING FUNCTION FixupReturnURL(STRING baseurl, INTEGER fsobjectid, STRING returnurl)
{
  IF(IsAbsoluteURL(baseurl,FALSE))
    RETURN ResolveToAbsoluteURL(baseurl, returnurl);
  IF(baseurl = "" AND imgcache_globalbaseurl != "")
    RETURN ResolveToAbsoluteURL(imgcache_globalbaseurl, returnurl);

  IF(baseurl="" AND fsobjectid != 0 )
  {
    RECORD siteinfo := GetAdhocCached(
        [ type := "siteinfo", fsobjectid := fsobjectid ],
        PTR GetCachableCDNUrl(fsobjectid),
        [ exclusive := FALSE
        ]);

    IF(RecordExists(siteinfo))
      RETURN MakeRelativeLinkFromURL(siteinfo.cdnbaseurl, ResolveToAbsoluteURL(siteinfo.cdnbaseurl, returnurl), "protocol");
  }
  RETURN returnurl;
}

PUBLIC STRING FUNCTION GetImageMimetype(STRING extension)
{
  IF(extension=".jpg")
    RETURN "image/jpeg";
  IF(extension=".gif")
    RETURN "image/gif";
  IF(extension=".png")
    RETURN "image/png";
  THROW NEW Exception("Unexpected image extension '" || extension || "'");
}

RECORD FUNCTION DecodeUnifiedData(STRING imgtok)
{
  IF(Left(imgtok,1)="\x03")
  {
    //this image token wraps a hostdata packet and the original imagetoken (ADDME smarter or compressed formats would be better?)
    INTEGER hostdatalen := DecodePacket("datalen:S", Substring(imgtok,1,2)).datalen;
    RECORD basedata := DecodeUnifiedData(Substring(imgtok,hostdatalen+3));
    INSERT CELL hostdata := DecodeHSON(Substring(imgtok,3,hostdatalen)) INTO basedata;
    RETURN basedata;
  }

  IF(Left(imgtok,1) != "\x01")
    THROW NEW Exception("Image token version not recognized");

  BOOLEAN isurl := Substring(imgtok,1,1)='\x3';

  RECORD outerpacket := DecodePacket(u1packet, Substring(imgtok,1));
  IF(NOT RecordExists(outerpacket))
    THROW NEW Exception("Image token outer packet corrupted");

  STRING resizeinfo := Substring(imgtok, 19, outerpacket.imgdatalen);
  RECORD resizemethod;
  IF(outerpacket.imgdatalen>0)
  {
    resizemethod := GfxUnpackImageResizeMethod(resizeinfo);
    IF(NOT RecordExists(resizemethod))
      THROW NEW Exception("Image token inner packet corrupted");
  }

  INSERT CELL resizemethod := resizemethod INTO outerpacket;
  RETURN outerpacket;
}

PUBLIC RECORD FUNCTION LookupDataForUnifiedURL(RECORD blobinfo)
{
  OBJECT localtrans;
  IF (NOT HavePrimaryTransaction())
    localtrans := OpenPrimary();

  TRY
  {
    RECORD lookupresult;

    IF(blobinfo.type = 1) //whfs objects
    {
      lookupresult := SELECT metadata := fs_objects.scandata
                           , data := fs_objects.data
                           , fs_object := 0
                           , creationdate := fs_objects.creationdate
                           //extra cells for specific verification
                           , fs_objects.name
                           , fs_objects.whfspath
                        FROM system.fs_objects
                       WHERE fs_objects.id=blobinfo.id;
    }
    ELSE IF(blobinfo.type = 2) //whfs settings
    {
      lookupresult := SELECT metadata := fs_settings.setting
                           , data := fs_settings.blobdata
                           , fs_object := fs_settings.fs_object
                           , creationdate := fs_objects.creationdate
                           //extra cells for specific verification
                           , fs_objects.whfspath
                        FROM system.fs_settings, system.fs_instances, system.fs_objects
                       WHERE fs_settings.id = blobinfo.id
                             AND fs_settings.fs_instance = fs_instances.id
                             AND fs_instances.fs_object = fs_objects.id;
    }
    ELSE IF(blobinfo.type = 3) //wrd entity settings
    {
      lookupresult := SELECT metadata := entity_settings.rawdata
                           , data := entity_settings.blobdata
                           , fs_object := 0
                           , creationdate := entities.creationdate
                        FROM wrd.entity_settings, wrd.entities
                       WHERE entity_settings.id = blobinfo.id
                             AND entities.id = entity_settings.entity;
    }
    ELSE IF(blobinfo.type = 4) //formresult attachments
    {
      lookupresult := SELECT formattachments.metadata
                           , data := formattachments.file
                           , fs_object := 0
                           , creationdate := formresults.when
                        FROM publisher.formattachments, publisher.formresults
                       WHERE formattachments.id = blobinfo.id
                             AND formattachments.formresult = formresults.id;
    }
    IF(NOT RecordExists(lookupresult))
      THROW NEW Exception(`Image lookup failed: no such object #${blobinfo.id} of type #${blobinfo.type}`);

    IF((GetDayCount(lookupresult.creationdate) BITXOR GetMsecondCount(lookupresult.creationdate)) != blobinfo.cc)
      THROW NEW Exception(`Image lookup failed: object #${blobinfo.id} of type #${blobinfo.type} does not have the expected creation date`);

    IF( (blobinfo.type = 1 OR blobinfo.type = 2) AND IsRecycleBinWHFSPath(lookupresult.whfspath))
      THROW NEW Exception(`Image lookup failed: object #${blobinfo.id} of type #${blobinfo.type} has been deleted`);

    IF(Length(lookupresult.data) = 0)
      THROW NEW Exception(`Image lookup failed: object #${blobinfo.id} of type #${blobinfo.type}  has no data`);

    IF(lookupresult.metadata = "") //it's missing ? preconversion fs_objects...
      RETURN WrapBlob(lookupresult.data, "");
    ELSE
      RETURN SplitBlobSetting(lookupresult.metadata, lookupresult.data, lookupresult.fs_object);
  }
  FINALLY
  {
    IF (ObjectExists(localtrans))
      localtrans->Close();
  }
}

RECORD FUNCTION GetUnifiedURLTokenParts(STRING token)
{
  INTEGER datatype;
  STRING extension;
  STRING filename;
  STRING urlschema;
  STRING urlpart;

  INTEGER qpos := SearchSubstring(token,'?');
  IF(qpos >= 0)
    token := Left(token,qpos);

  STRING datatoken;
  IF (token LIKE "???/*") // Legacy url decoder
  {
    IF(token LIKE "i??/*")
      datatype := 1;
    ELSE IF(token LIKE "f??/*")
      datatype := 2;
    ELSE IF(token LIKE "e??/*")
      datatype := 3;

    IF(datatype > 0)
    {
      urlschema := "v1";

      INTEGER extendingslash := SearchSubstring(token,'/',5);
      IF(extendingslash != -1) //there's a trailing slash. old image urls supported this. we'll need to strip for that
        token := Left(token, extendingslash);

      // Ignore trailing slashes
      urlpart := token;

      //<i><first two bytes>/<rest><.extension>
      INTEGER extensionstart := SearchLastSubstring(token,'.');
      IF(extensionstart >= 0)
      {
        extension := Substring(token, extensionstart);
        token := Left(token, extensionstart);
        datatoken := Substring(token,1,2) || Substring(token, 4, extensionstart-4);
      }
      ELSE
      {
        datatoken := Substring(token,1,2) || Substring(token, 4);
      }

      //Do we have the image on disk ?
      INTEGER lastdash := SearchLastSubstring(datatoken,'-');
      IF(lastdash != -1)
      {
        filename := Substring(datatoken, 2, lastdash - 2) || extension;
        datatoken := Left(datatoken,2) || Substring(datatoken, lastdash+1);
      }
      ELSE
        filename := "data" || extension;
    }
  }
  ELSE
  {
    urlschema := "v2";
    urlpart := token;

    IF(token LIKE "i*")
      datatype := 1;
    ELSE IF(token LIKE "f*")
      datatype := 2;
    ELSE IF(token LIKE "e*")
      datatype := 3;

    IF(datatype > 0)
    {
      //<i><token>/<filename><.extension>
      INTEGER slashpos := SearchSubstring(token, "/");
      datatoken := SubString(token, 1, slashpos - 1);

      // Get extension from end of url part
      INTEGER extensionstart := SearchLastSubstring(token, '.');
      IF (extensionstart > slashpos)
      {
        extension := Substring(token, extensionstart);
        token := Left(token, extensionstart);
      }

      // Get filename, and ignore slashes
      filename := DecodeURL(Tokenize(SubString(token, slashpos + 1), "/")[0] || extension); // ignore multiple slashes

      // Build a canonical url-part
      urlpart := LEFT(token, 1) || datatoken || "/" || filename;
    }
  }

  RETURN CELL
      [ datatoken
      , datatype
      , extension
      , filename
      , urlschema
      , urlpart
      ];
}


PUBLIC RECORD FUNCTION AnalyzeUnifiedURLToken(STRING token, STRING hosthash)
{
  RECORD retval := [ datatype :=  0
                   , token :=     ""
                   , tohash :=    ""
                   , hash :=      ""
                   , item :=      DEFAULT RECORD
                   , filename :=  ""
                   , extension := ""
                   , urlschema := ""
                   , urlpart :=   ""
                   ];

  RECORD data := GetUnifiedURLTokenParts(token);
  retval.datatype := data.datatype;
  retval.extension := data.extension;
  retval.filename := data.filename;
  retval.urlschema := data.urlschema;
  retval.urlpart := data.urlpart;

  IF (data.datatoken != "")
  {
    STRING datatoken := DecodeBase16(data.datatoken);
    retval.hash := Left(datatoken, 4);
    retval.tohash := Substring(datatoken, 4);

    STRING expectedhash := Left(GetHashForString(retval.tohash || hosthash || retval.extension || GetClusterKeyBase("cachesecret"), "MD5"),4);
    IF(expectedhash != retval.hash)
      RETURN DEFAULT RECORD;

    retval.token := data.datatoken;
    retval.item := DecodeUnifiedData(retval.tohash);
    RETURN retval;
  }

  RETURN DEFAULT RECORD;
}

PUBLIC RECORD FUNCTION GetCachedDataSourceMetadataFromURL(STRING url)
{
  INTEGER uc := SearchSubstring(url, "/.uc/");
  IF(uc>=0)
  {
    RECORD analyzed := AnalyzeUnifiedURLToken(Substring(url, uc+5), "");
    IF(RecordExists(analyzed))
    {
      RETURN [ type := analyzed.item.type
             , id := analyzed.item.id
             ];
    }
  }

  RETURN DEFAULT RECORD;
}



PUBLIC RECORD ARRAY FUNCTION GetCurrentUnifiedCacheContents(DATETIME ignore_modified_after)
{
  RECORD ARRAY deletion_candidates;
  STRING imgcache_current := GetWebHareConfiguration().ephemeralroot || "system.uc2";
  /* Read all current images from disks as deletion candidates */
  RECORD ARRAY imgcache_subs := ReadDiskDirectory(imgcache_current,"*");

  FOREVERY(RECORD subdir FROM imgcache_subs)
  {
    FOREVERY(RECORD img FROM ReadDiskDirectory(subdir.path, "*"))
    {
      IF(img.type!=0)
        CONTINUE;
      IF(img.modified > ignore_modified_after)
        CONTINUE;

      INSERT [ fullpath :=    img.path
             , name :=        "/" || subdir.name || "/" || img.name
             , expired :=     TRUE
             ] INTO deletion_candidates AT END;
    }
  }
  deletion_candidates := SELECT * FROM deletion_candidates ORDER BY name;
  RETURN deletion_candidates;
}


PUBLIC RECORD ARRAY FUNCTION FilterRecentHits(RECORD ARRAY deletion_candidates, DATETIME rangestart, DATETIME rangeend)
{
  STRING ARRAY imagecachefolders :=
      [ "/.uc/"
      , "/tollium_todd.res/webhare_testsuite/tests/imgcache/!/"
      ];

  STRING ARRAY foldermasks;
  FOREVERY (STRING folder FROM imagecachefolders)
    INSERT (folder LIKE "*/" ? folder : folder || "/") || "*" INTO foldermasks AT END;

  IF(Length(deletion_candidates) != 0)
  {
    /* Analyze the logfiles to figure out which images are recently accessed */
    OBJECT accesslog := OpenWebHareLogStream("access", rangestart, rangeend);
    WHILE(TRuE)
    {
      RECORD row := accesslog->ReadRecord();
      IF(NOT RecordExists(row))
        BREAK;
      IF(row.method != "GET")
        CONTINUE;

      STRING tokenpart;
      BOOLEAN iscandidate;
      FOREVERY (STRING foldermask FROM foldermasks)
        IF (row.url LIKE foldermask)
        {
          tokenpart := SubString(row.url, LENGTH(foldermask) - 1);
          iscandidate := TRUE;
        }

      IF (NOT iscandidate)
        CONTINUE;

      RECORD data := GetUnifiedURLTokenParts(tokenpart);
      IF (data.datatoken = "")
        CONTINUE;

      STRING diskname;
      IF (data.urlschema = "v1")
      {
        diskname := "/" || data.urlpart;
      }
      ELSE IF (data.urlschema = "v2")
      {
        STRING token := Left(data.urlpart, SearchLastSubstring(data.urlpart, "/"));
        diskname := ToLowercase(EncodeBase16(GetHashForString(token, "SHA-256"))) || data.extension;
        diskname := "/" || Left(diskname, 3) || "/" || SubString(diskname, 3);
      }

      RECORD foundpos := RecordLowerBound(deletion_candidates, [ name := ToLowercase(diskname) ], ["NAME"]);
      IF(foundpos.found AND deletion_candidates[foundpos.position].expired)
        deletion_candidates[foundpos.position].expired := FALSE;
    }
  }
  RETURN deletion_candidates;
}

