<?wh

LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/pkcs.whlib";
LOADLIB "wh::internet/tcpip.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/keystore.whlib";

// also called by renewcertbot.ts!
PUBLIC RECORD ARRAY FUNCTION ListCertificates()
{
  RECORD ARRAY certificates;
  FOREVERY (RECORD keypair_rec FROM ListKeyPairs())
  {
    OBJECT keypair := OpenKeyPair(keypair_rec.id);
    IF(NOT ObjectExists(keypair) OR Length(keypair->certificate)=0)
      CONTINUE;

    RECORD certdata;

    TRY
    {
      certdata := DecodePEMFile(BlobToString(keypair->certificate));
      IF (NOT RecordExists(certdata))
        CONTINUE;
    }
    CATCH(OBJECT e)
    {
      Print("Exception on keypair " || keypair->name || ": " || e->what || "\n");
      CONTINUE;
    }

    INSERT
        [ id :=           keypair_rec.id
        , name :=         keypair_rec.name
        , chainfile :=    BlobToString(keypair->certificatechain)
        , keyfile :=      BlobToString(keypair->privatekey)
        , valid_until :=  certdata.valid_until
        , servernames :=  certdata.dns_altnames //we now ignore "CN"
        ] INTO certificates AT END;
  }
  RETURN certificates;
}

PUBLIC RECORD FUNCTION GetBestCertificateForHost(RECORD ARRAY certificates, STRING hostname)
{
  RECORD best_cert;
  STRING name := ToLowercase(hostname);
  FOREVERY (RECORD cert FROM certificates)
  {
    BOOLEAN is_match := IsCertificateForHostname(cert, name);
    IF (is_match)
    {
      IF (NOT RecordExists(best_cert) OR best_cert.valid_until < cert.valid_until)
        best_cert := cert;
    }
  }
  RETURN best_cert;
}

/** Generate a Nginx proxy configuration
    @param data Current webserver configuration
*/
PUBLIC RECORD FUNCTION GenerateNginxProxyRegistrationRequest(RECORD data, STRING reverseaddress, STRING verificationurl, STRING hostswhitelist, INTEGER proxyid, DATETIME lastset)
{
  STRING ARRAY whitelistmasks := ParseXSList(hostswhitelist);
  IF(reverseaddress LIKE "*/")
    reverseaddress := Left(reverseaddress, Length(reverseaddress)-1); //ningx doesn't like a terminating slash (ADDME we should completely strip the urlpath)

  RECORD request :=
      [ id :=                       GetServerName()
      , version :=                  1
      , hosts :=                    DEFAULT RECORD ARRAY
      , certificates :=             DEFAULT RECORD ARRAY
      , ssl_ciphers :=              ReadRegistryKey("system.webserver.security.ciphersuite") ?? default_ciphersuites
      , reverseaddress :=           reverseaddress
      , verificationurl :=          verificationurl
      , proxyid :=                  proxyid
      , lastset :=                  lastset
      ];

  // Get all the usable certificates on the system
  RECORD ARRAY certificates := ListCertificates();

  RECORD ARRAY nonsecureportlist := [ [ port := 80 ], [ port := 80, ipv6 := TRUE ]];
  RECORD ARRAY secureportlist :=    [ [ port := 443, ssl := TRUE ], [ port := 443, ipv6 := TRUE, ssl := TRUE ]];

  RECORD ARRAY listenhosts;

  //PRINT("Aggregating hosts\n");
  FOREVERY (RECORD host FROM data.hosts)
  {
    // exclude listenhosts with port specification
    host.listenhosts :=
        SELECT AS STRING ARRAY listenhost
          FROM ToRecordArray(host.listenhosts, "listenhost")
         WHERE listenhost NOT LIKE "*:*";

    // Ignore  servers that are not virtual hosted
    IF (LENGTH(host.listenhosts) = 0 OR "_proxy" IN host.listenhosts)
      CONTINUE;

    STRING ARRAY nginx_servernames;
    FOREVERY (STRING name FROM host.listenhosts)
    {
      IF (name LIKE "*.")
        CONTINUE;

      IF(Length(whitelistmasks) > 0)
      {
        BOOLEAN isdeny := TRUE;
        FOREVERY(STRING mask FROM whitelistmasks)
          IF(ToUppercase(name) LIKE ToUppercase(mask))
            isdeny := FALSE;
        IF(isdeny)
          CONTINUE;
      }

      RECORD best_cert := GetBestCertificateForHost(certificates, name);
      name := ToLowercase(name);

      //convert everything with a wildcard, except "*.server", to a regex.
      IF (SearchSubstring(name, "*" , 1) >= 0 OR (Substring(name,0,1)='*' AND Substring(name,0,2)!='*.'))
      {
        name := Substitute(name,'.','\\.');
        name := Substitute(name,'*','.*');
        name := "~^" || name || '$';
      }

      INSERT
          [ servername :=     name
          , ssl_keypair :=    RecordExists(best_cert) ? best_cert.name : "fallback"
          , orghost :=        host.listenhosts[0]
          ] INTO listenhosts AT END;
    }
  }

  request.hosts :=
      SELECT ssl_keypair
           , ports :=           nonsecureportlist CONCAT secureportlist
           , servernames :=     Groupedvalues(servername)
        FROM listenhosts
    GROUP BY orghost, ssl_keypair;

  STRING ARRAY used_keypairs := SELECT AS STRING ARRAY ssl_keypair FROM request.hosts;

  // Filter the certificates
  request.certificates :=
      SELECT name
           , keyfile
           , chainfile
        FROM certificates
       WHERE name IN used_keypairs;

  RETURN request;
}
