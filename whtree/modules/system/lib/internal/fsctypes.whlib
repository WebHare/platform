<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";

/** Set to true in WHFSCommitHandler when changes have been made to fstypes/members
    Disables the adhoccache for type data
*/
PUBLIC BOOLEAN uncommitted_fstypes_changes;

PUBLIC BOOLEAN FUNCTION IsArrayVersionOf(INTEGER soloversion, INTEGER arrayversion)
{
  RETURN (soloversion IN [1,2] AND arrayversion IN [3,14])
         OR (soloversion = 11 AND arrayversion = 13);
}

/** Return the members of a type, sorted on (parent,name)
    @return
    @cell return.id Id of the member
    @cell return.name Name (lowercased)
    @cell return.type
    @cell return.maxlength
    @cell return.emptyval
    @cell return.allowed
    @cell return.parent Id of the parent array member
*/
PUBLIC RECORD ARRAY FUNCTION GetMembers(INTEGER typedefid)
{
  RETURN uncommitted_fstypes_changes
      ? GetCacheableMembers(typedefid).value
      : GetAdhocCached([ type := "members", typedefid := typedefid ], PTR GetCacheableMembers(typedefid));
}

RECORD FUNCTION GetCacheableMembers(INTEGER typedefid)
{
  // Lowercase the name, we want to do quick case-insensitive lookups
  RECORD ARRAY rawmembers :=
      SELECT TEMPORARY lowercase_name := ToLowercase(name)
           , *
           , name := lowercase_name
        FROM system.fs_members
       WHERE fs_type = typedefid
    ORDER BY parent, lowercase_name;

  RECORD ARRAY memberlist;
  FOREVERY (RECORD memberrec FROM rawmembers)
  {
    VARIANT emptyval;
    STRING ARRAY allowed;

    SWITCH(memberrec.type)
    {
      CASE 1 // Single
      {
        emptyval := "";
      }
      CASE 3,14 // Multiple, string array
      {
        emptyval := DEFAULT STRING ARRAY;
      }
      CASE 2 // Text
      {
        emptyval := "";
      }
      CASE 5 // Memo
      {
        emptyval := DEFAULT RECORD;
      }
      CASE 11
      {
        emptyval := 0;
      }
      CASE 13
      {
        emptyval := DEFAULT INTEGER ARRAY;
      }
      CASE 12
      {
        emptyval := DEFAULT RECORD ARRAY;
      }
      CASE 15, 16, 18, 20, 21, 23, 24 //RTD, intextlink, instance, composeddocument, record, typedrecord, image
      {
        emptyval := DEFAULT RECORD;
      }
      CASE 4,25 //Datetime, Date
      {
        emptyval := DEFAULT DATETIME;
      }
      DEFAULT
      {
        emptyval := AnyTypeFromString("", memberrec.type);
      }
    }

    INSERT INTO memberlist(id, name, type
                          ,emptyval, parent, orphan)
           VALUES(memberrec.id, memberrec.name, memberrec.type
                 ,emptyval, memberrec.parent, memberrec.orphan)
           AT END;
  }
  RETURN
      [ eventmasks := [ "publisher:compiled_siteprofiles"
                      , "system:whfs.types"
                      ]
      , value :=      memberlist
      ];
}

PUBLIC STRING FUNCTION EncodeMember(VARIANT data, INTEGER type)
{
  RECORD coding := AnyTypeToString(data);
  IF(coding.type != type)
  {
    // Casting rules. INTEGER/MONEY -> FLOAT, INTEGER->MONEY
    IF (type = 8 AND coding.type IN [ 7, 9 ])
      coding := AnyTypeToString(FLOAT(data));
    ELSE IF (type = 9 AND coding.type = 7)
      coding := AnyTypeToString(MONEY(data));
    ELSE
      ABORT("Illegal member type change");
  }
  RETURN coding.data;
}


//////////// Type 4: DATETIME.

PUBLIC STRING FUNCTION EncodeSPSetDatetime(DATETIME date)
{
  IF(date != MAX_DATETIME AND date >= MakeDate(10000,1,1))
    THROW NEW Exception(`Date out of range, got ${EncodeJSON(date)}`);

  RETURN GetDayCount(date) || ":" || GetMsecondCount(date);
}

PUBLIC DATETIME FUNCTION DecodeSPDatetime(RECORD ARRAY curset)
{
  IF(Length(curset) = 0)
    RETURN DEFAULT DATETIME;

  STRING ARRAY toks := Tokenize(curset[0].setting,":");
  IF (Length(toks)!=2)
    RETURN DEFAULT DATETIME;
  ELSE
    RETURN MakeDateFromParts(ToInteger(toks[0],0), ToInteger(toks[1],0));
}

//////////// Type 25: DATE.

PUBLIC STRING FUNCTION EncodeSPSetDate(DATETIME date)
{
  IF(date = MAX_DATETIME)
    THROW NEW Exception(`Date out of range, got MAX_DATETIME`);
  ELSE IF(date >= MakeDate(10000,1,1))
    THROW NEW Exception(`Date out of range, got ${EncodeJSON(date)}`);
  RETURN FormatDateTime("%Y-%m-%d", date);
}

PUBLIC DATETIME FUNCTION DecodeSPDate(RECORD ARRAY curset)
{
  IF(Length(curset) = 0)
    RETURN DEFAULT DATETIME;

  DATETIME newval := MakeDateFromText(curset[0].setting); //just store it as YYYY-MM-DD
  RETURN newval;
}
