<?wh

LOADLIB "wh::async.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::filetypes/harescript.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/tasks/callasync.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/harescript.whlib";
LOADLIB "mod::system/lib/internal/validation/scan.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";

LOADLIB "wh::internal/interface.whlib";


ASYNC FUNCTION ReadWholeProcessOutput(OBJECT process)
{
  RECORD retval :=
      [ output :=   ""
      , errors :=   ""
      , exitcode := -1
      ];

  OBJECT itr := MakeProcessAsyncIterator(process, [ autoclose := FALSE ]);
  WHILE (TRUE)
  {
    RECORD rec := AWAIT itr->Next();
    IF (rec.done)
      BREAK;
    SWITCH (rec.value.type)
    {
      CASE "output"   { retval.output := retval.output || rec.value.line || "\n"; }
      CASE "error"    { retval.errors := retval.errors || rec.value.line || "\n"; }
      CASE "close"    { retval.exitcode := rec.value.exitcode; }
    }
  }
  RETURN retval;
}

ASYNC MACRO SendProcessInput(OBJECT process, BLOB data)
{
  AWAIT AsyncSendBlobTo(process->input_handle, data);
  process->CloseInput();
}

ASYNC FUNCTION RunESLint(BLOB libdata, STRING resourcename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ fix := FALSE
      , allowinlineconfig := TRUE
      ], options);

  STRING path := resourcename LIKE "*::*" ? GetWebHareResourceDiskPath(resourcename) : resourcename;
  STRING eslintrcpath := MergePath(GetWebhareConfiguration().installationroot, ".eslintrc.json");

  RECORD cmd := CELL
      [ path
      , data :=           EncodeBase64(BlobToString(libdata))
      , cwd :=            GetWebhareConfiguration().installationroot
      , configfile :=     eslintrcpath
      , options.fix
      , options.allowinlineconfig
      ];

  RECORD result := AWAIT CallAsync("mod::system/js/internal/eslint.ts#handleLintingCommand", [ cmd ]);

  RETURN CELL
      [ messages :=
          (SELECT resourcename :=  resourcename
                , message := `${message} (eslint)` //clarify source
                , line
                , col
                , fatal
             FROM result.messages)
      , result.hasfixes
      , output :=       result.hasfixes ? StringToBlob(DecodeBase64(result.output)) : libdata
      ];
}

PUBLIC RECORD FUNCTION RunJSValidator(BLOB libdata, STRING resourcename, RECORD options)
{
  STRING modulename := GetModulenameFromResourcePath(resourcename);

  RECORD ARRAY warnings, errors;

  RECORD validateconfig := GetModuleValidationConfig(modulename);
  IF(NOT options.onlytids)
  {
    BOOLEAN run_eslint;
    STRING resnameformasks := Substring(resourcename,SearchSubString(resourcename,'/')+1);
    FOREVERY (STRING mask FROM validateconfig.eslintmasks)
      IF (ToUppercase(resnameformasks) LIKE ToUppercase(mask))
        run_eslint := TRUE;

    IF (run_eslint)
    {
      RECORD ARRAY messages := WaitForPromise(RunESLint(libdata, resourcename)).messages;
      errors := SELECT * FROM messages WHERE fatal;
      warnings := SELECT * FROM messages WHERE NOT fatal;
    }
  }

  RECORD texts := GetJSTexts(resourcename, libdata);

  RETURN CELL
         [ warnings
         , errors
         , tids :=    texts.texts
         , texts.icons
         ];
}

RECORD FUNCTION GetJSTexts(STRING resourcename, BLOB libdata)
{
//  BOOLEAN findscreens := TRUE; // we only need to search for screens in *.whlib files
  RECORD ARRAY texts;
  RECORD ARRAY icons;
  // Skip time consuming tokenizing and analysing of Javascript code
  // if the file has no mention of GetTid anywhere.
  // (This gives a big speed boost, huge even for the system module)
  STRING rawtext := ToUpperCase(BlobToString(libdata, -1));
  IF (SearchSubString(rawtext, 'GETTID') = -1 AND
      SearchSubString(rawtext, 'GETHTMLTID') = -1 AND
      SearchSubString(rawtext, '/*TID*/') = -1 AND
      SearchSubString(rawtext, '/*ICON*/') = -1)
    RETURN CELL[ texts, icons ];

  // Hack to be able to use the harescript tokenizer
  libdata := StringToBlob("<?wh " || Substitute(BlobToString(libdata), "?>", ""));

  INTEGER file := OpenHareScriptFile(libdata);

  RECORD tok := GetNextTok(file);
  RECORD ARRAY prevtokens;

  STRING current_objecttype;
  WHILE(TRUE)
  {
    tok := GetNextTok(file);
    IF(NOT RecordExists(tok))
      BREAK;

    //Keep a simple tokens lookback buffer
    IF(Length(prevtokens)=10)
      DELETE FROM prevtokens AT 0;
    INSERT tok INTO prevtokens AT END;

    BOOLEAN is_gettid := tok.token = "getTid";
    BOOLEAN is_gethtmltid := tok.token = "getHTMLTid";
    IF(is_gettid OR is_gethtmltid OR ToUppercase(tok.token) = "/*TID*/")
    {
      //ADDME: Gather errors and report them in a list after a 'scan missing texts' action
      RECORD expect_parenthesis := GetNextTok(file);

      RECORD expect_tid;

      IF(is_gettid AND RecordExists(expect_parenthesis) AND expect_parenthesis.token = ".") //is this getTid.html ?
      {
        expect_parenthesis := GetNextTok(file);
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token = "html")
        {
          expect_parenthesis := GetNextTok(file);
        }
        ELSE
        {
          CONTINUE; //unrecognized syntax
        }
      }

      IF (is_gettid OR is_gethtmltid)
      {
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token IN [":=","=",":"]) //use of gettid as variable name/function declaration
          CONTINUE; //skippable!


        IF(NOT RecordExists(expect_parenthesis) OR expect_parenthesis.token!="(")
        {
          CONTINUE;
        }

        expect_tid := GetNextTok(file);
        IF(RecordExists(expect_tid) AND expect_tid.istype) //definition of a function named gettid
          CONTINUE;
      }
      ELSE
        expect_tid := expect_parenthesis;

      // Skip if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_tid) OR Left(expect_tid.token,1) NOT IN ["'",'"'])
        CONTINUE;

      STRING tid := DecodeJava(Substring(expect_tid.token, 1, Length(expect_tid.token)-2));

      // Skip if the Tid isn't a single STRING (and give the first part which is a STRING)
      RECORD expect_comma_close := GetNextTok(file);
      IF(tid NOT LIKE ":*" AND (NOT RecordExists(expect_comma_close) OR Left(expect_comma_close.token,1) NOT IN [",",")","]"]))
        CONTINUE;

      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , tid :=       tid
             ]
        INTO texts AT END;
    }
    IF(ToUppercase(tok.token) = "/*ICON*/")
    {
      RECORD expect_icon := GetNextTok(file);

      // Ignore if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_icon) OR Left(expect_icon.token,1) NOT IN ["'",'"','`'])
        CONTINUE;

      IF(Left(expect_icon.token,1) = '`' AND Right(expect_icon.rawtoken,1) != '`') //looks like a ` string ending with a ${
        CONTINUE;

      STRING icon := DecodeJava(Substring(expect_icon.token, 1, Length(expect_icon.token)-2));
      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , icon :=      icon
             ]
        INTO icons AT END;
    }
  }

  CloseHarescriptFile(file);
  RETURN CELL[ texts, icons ];
}

/** Given a directory, find a .ts or .tsx file, ignoreing node_modules
    Returns the subpath within the root
    @param root Root folder
    @param subpath Subpath to start in (use "" to start at root)
    @return Subpath to first found .ts or .tsx file
*/
PUBLIC STRING FUNCTION RecursivelyFindTypeScriptFile(STRING root, STRING subpath DEFAULTSTO "")
{
  STRING finalpath := subpath = "" ? root : MergePath(root, subpath);

  RECORD ARRAY contents := ReadDiskDirectory(finalpath, "*");
  FOREVERY (RECORD rec FROM contents)
  {
    IF (rec.name = "node_modules" OR rec.name = "vendor" OR rec.name LIKE ".*")
      CONTINUE;
    IF (GetExtensionFromPath(rec.name) IN whconstant_typescript_extensions)
      RETURN subpath = "" ? rec.name : MergePath(subpath, rec.name);
    IF (rec.type = 1)
    {
      STRING tsfile := RecursivelyFindTypeScriptFile(root, subpath = "" ? rec.name : MergePath(subpath, rec.name));
      IF (IsValueSet(tsfile))
        RETURN tsfile;
    }
  }
  RETURN "";
}

/** Checks typescript files (using the typescript compiler)
    @param modulename Name of an external module to check or "coremodules" for all core modules.
    @return Validation results
    @cell return.issues List of found issues
    @cell return.issues.filename Resource name
    @cell return.issues.line Line
    @cell return.issues.col Column
    @cell return.issues.message Error message
    @cell return.issues.category Category ("error" or "warning")
*/
PUBLIC ASYNC FUNCTION CheckModuleTypeScriptFiles(STRING modulename)
{
  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  IF (modulename IN whconstant_builtinmodules)
    THROW NEW Exception(`Cannot check individual core modules, use "coremodules" to check all core modules`);

  // Use the whtree tsconfig.json for core modules (but never for webhare_testsuite)
  STRING tsbuildinfodir := MergePath(GetWebhareConfiguration().ephemeralroot, "system.typescript");
  STRING tsconfigpath, tsbuildinfofile;
  STRING workingdir := GetWebhareConfiguration().installationroot;

  IF (modulename = "coremodules"
      OR modulename = "jssdk"
      OR modulename IN whconstant_builtinmodules)
  {
    tsconfigpath := MergePath(GetWebhareConfiguration().installationroot, "tsconfig.json");
    tsbuildinfofile := MergePath(tsbuildinfodir, "coremodules.tsbuildinfo");
  }
  ELSE
  {
    STRING installationroot := GetModuleInstallationRoot(modulename);
    STRING anytsfile := RecursivelyFindTypeScriptFile(installationroot, ".");

    // Don't need to validate if no .ts/.tsx files present
    IF (IsDefaultValue(anytsfile))
      RETURN retval;

    tsconfigpath := MergePath(installationroot, "tsconfig.json");

    // Don't go create tsconfig.json on acceptance and production servers
    IF (GetDTAPStage() NOT IN [ "development", "test" ] AND NOT RecordExists(GetDiskFileProperties(tsconfigpath)))
      RETURN retval;

    BuildTSConfigFile(installationroot);
    tsbuildinfofile := MergePath(tsbuildinfodir, `${modulename}.tsbuildinfo`);
    workingdir := installationroot;

    // For git-based modules, make sure tsconfig.json is on the .gitignore list
    IF (RecordExists(GetDiskFileProperties(MergePath(installationroot, ".git"))))
    {
      BLOB gitignore := GetDiskResource(MergePath(installationroot, ".gitignore"), [ allowmissing := TRUE ]);
      STRING ARRAY gitignore_lines := Tokenize(Substitute(BlobToString(gitignore), "\r\n", "\n"), "\n");
      IF ("tsconfig.json" NOT IN gitignore_lines
          AND "/tsconfig.json" NOT IN gitignore_lines
          AND "**/tsconfig.json" NOT IN gitignore_lines)
      {
        INSERT
            [ resourcename := `mod::${modulename}/.gitignore`
            , line :=         1
            , col :=          1
            , message :=      "tsconfig.json is not present in the .gitignore file"
            , category :=     "error"
            ] INTO retval.issues AT END;
      }
    }
  }

  STRING tscpath := MergePath(GetWebhareConfiguration().installationroot, "node_modules/.bin/tsc");
  CreateDiskDirectoryRecursive(tsbuildinfodir, TRUE);

  STRING ARRAY args := [ "--project", tsconfigpath, "--noEmit", "--incremental", "--tsBuildInfoFile", tsbuildinfofile ];

  OBJECT proc := CreateProcess(tscpath, args, FALSE, TRUE, TRUE, FALSE);
  proc->initialworkingdirectory := workingdir;
  proc->Start();

  OBJECT reader := ReadWholeProcessOutput(proc);
  RECORD procresult := AWAIT reader;
  proc->Close();

  OBJECT matcher := NEW RegEx("^([^\\(]*)\\((\\d*),(\\d*)\\): (error .*)$");

  FOREVERY (STRING line FROM Tokenize(procresult.output, "\n"))
  {
    RECORD ARRAY match := matcher->Exec(line);
    IF (RecordExists(match))
    {
      STRING finalpath := MergePath(workingdir, match[1].value);
      STRING resourcename := GetResourceNameFromDiskPath(finalpath) ?? finalpath;

      INSERT CELL
          [ resourcename
          , line :=         ToInteger(match[2].value, 1)
          , col :=          ToInteger(match[3].value, 1)
          , message :=      match[4].value
           //until we find a better solution it's best to completely suppress the TS noise generated by the client
          , category :=     resourcename LIKE "*/jssdk/whdb/vendor/postgresql-client/*" ? "discard"
                            : resourcename LIKE "*/vendor/*" ? "hint"
                            : "error"
          ] INTO retval.issues AT END;
    }
  }

  IF (procresult.exitcode != 0 AND IsDefaultValue(retval.issues))
  {
    INSERT
        [ resourcename := ""
        , line :=         1
        , col :=          1
        , message :=      "TypeScript validation gave back an error, but did not find one when parsing the output"
        , category :=     "error"
        ] INTO retval.issues AT END;
  }

  DELETE FROM retval.issues WHERE category = "discard"; //only kept them to be able to do the 'TS worked' checked above

  RETURN retval;
}

RECORD FUNCTION DecodeResult(BLOB result)
{
  RECORD decoded := DecodeJSONBlob(result);
  RETURN CELL
      [ decoded.path
      , decoded.error
      , decoded.output
      ];
}

ASYNC FUNCTION FormatSingleFile(RECORD file)
{
  RECORD rec := AWAIT RunESLint(file.data, file.path, [ fix := TRUE, allowinlineconfig := FALSE ]);

  STRING dir := GetDirectoryFromPath(file.path);

  RECORD cmd := CELL
      [ basedir :=          dir
      , tsfmtfile :=        ResolveToRelativePath(dir, MergePath(GetWebhareConfiguration().installationroot, "tsfmt.json"))
      , file.path
      , data :=             EncodeBase64(BlobToString(rec.output))
      ];

  rec := AWAIT CallAsync("mod::system/js/internal/tsfmt.ts#handleFormattingCommand", [ cmd ]);

  BLOB output;
  IF (rec.output != cmd.data AND rec.error = "")
  {
    // Re-run eslint to clean up formatting result (which sometimes leaves trailing spaces)
    RECORD eslintres := AWAIT RunESLint(StringToBlob(DecodeBase64(rec.output)), file.path, [ fix := TRUE, allowinlineconfig := FALSE ]);
    output := eslintres.output;
  }
  ELSE
    output := StringToBlob(DecodeBase64(rec.output));

  RETURN CELL
      [ ...file
      , ...rec
      , output
      ];
}

/** Format multiple javascript files
    @param data List of files to format
    @cell(string) data.path Path to file
    @cell(blob) data.data Contents of file
    @return Formatted files
    @cell(string) return.path Path of formatted file
    @cell(string) return.error If set, error message
    @cell(blob) return.output Formatted output (if error is empty)
*/
PUBLIC ASYNC FUNCTION FormatJavascriptFiles(RECORD ARRAY data)
{
  INTEGER cmdstream := CreateStream();

  // Run max 8 formatters concurrently
  OBJECT serializer := MakeCallSerializer([ maxconcurrent := 8 ]);

  OBJECT ARRAY scheduled;
  FOREVERY (RECORD file FROM data)
    INSERT serializer->Call(PTR FormatSingleFile, file) INTO scheduled AT END;

  RETURN RECORD ARRAY(AWAIT CreatePromiseAll(scheduled));
}

/** Format a single javascript file
    @param path Path to file
    @param data Contents of the file
    @return Formatted file
    @cell(blob) return.output Formatted file
*/
PUBLIC ASYNC FUNCTION FormatJavascriptFile(STRING path, BLOB data)
{
  RECORD ARRAY res := AWAIT FormatJavascriptFiles([ CELL[ path, data ] ]);
  IF (res[0].error != "")
    THROW NEW Exception(`Error formatting file: ${res[0].error}`);
  RETURN CELL[ res[0].output ];
}

/** Checks the formatting status of all files in a module
    @param module Module to check
    @cell options.onlypaths If set, check only these paths
    @return List of issues
    @cell(record array) return.issues Issues
    @cell(string) return.issues.resourcename Name fo the resource with the issue
    @cell(integer) return.issues.line Line number
    @cell(integer) return.issues.col Column number
    @cell(string) return.issues.message Error message
    @cell(string) return.issues.category Category ('error' | 'warning')
*/
PUBLIC ASYNC FUNCTION CheckModuleJavascriptFormatting(STRING module, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ onlypaths := STRING[]
      , filemask := "*"
      ], options);

  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  STRING root := module = "jssdk"
      ? GetWebhareConfiguration().installationroot || "jssdk/"
      : "mod::" || module;

  RECORD ARRAY files := GetFilesToValidate([ root ], [ extensions := whconstant_javascript_extensions ]);

  RECORD ARRAY toformat;
  FOREVERY (RECORD rec FROM files)
  {
    IF (NOT MatchesPathMasks(rec.subpath, rec.settings.formatmasks) OR MatchesPathMasks(rec.subpath, rec.settings.formatexcludemasks))
      CONTINUE;

    IF (IsValueSet(options.onlypaths) AND rec.path NOT IN options.onlypaths)
      CONTINUE;

    IF (ToUppercase(GetNameFromPath(rec.subpath)) NOT LIKE ToUppercase(options.filemask))
      CONTINUE;

    BLOB data := GetDiskResource(rec.path);
    INSERT CELL[ rec.path, data, rec.module, rec.subpath ] INTO toformat AT END;
  }

  TRY
  {
    RECORD ARRAY result := WaitForPromise(FormatJavascriptFiles(toformat));
    FOREVERY (RECORD rec FROM result)
    {
      STRING resourcename := rec.module = "jssdk" ? `direct::${rec.path}` : `mod::${rec.module}/${rec.subpath}`;
      IF (rec.error != "")
      {
        INSERT CELL
            [ resourcename
            , line :=         1
            , col :=          1
            , message :=      `Formatting file caused an error: ${rec.error}`
            , category :=     "error"
            ] INTO retval.issues AT END;
        CONTINUE;

      }
      BOOLEAN ismatch := BlobToString(rec.output) = BlobToString(rec.data);
      IF (NOT ismatch)
      {
        INSERT CELL
            [ resourcename
            , line :=         1
            , col :=          1
            , message :=      `File hasn't been formatted correctly - fixable using wh dev:autoformat`
            , category :=     "error"
            ] INTO retval.issues AT END;
      }
    }
  }
  CATCH (OBJECT e)
  {
    INSERT
        [ resourcename := `mod::${module}/moduledefinition.xml`
        , line :=         1
        , col :=          1
        , message :=      `Error formatting javascript files: ${e->what}`
        , category :=     "error"
        ] INTO retval.issues AT END;
  }
  RETURN retval;
}
