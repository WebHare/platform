<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::filetypes/harescript.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/harescript.whlib";

LOADLIB "wh::internal/interface.whlib";

ASYNC FUNCTION ReadWholeProcessOutput(OBJECT process)
{
  RECORD retval :=
      [ output :=   ""
      , errors :=   ""
      , exitcode := -1
      ];

  OBJECT itr := MakeProcessAsyncIterator(process, [ autoclose := FALSE ]);
  WHILE (TRUE)
  {
    RECORD rec := AWAIT itr->Next();
    IF (rec.done)
      BREAK;
    SWITCH (rec.value.type)
    {
      CASE "output"   { retval.output := retval.output || rec.value.line || "\n"; }
      CASE "error"    { retval.errors := retval.errors || rec.value.line || "\n"; }
      CASE "close"    { retval.exitcode := rec.value.exitcode; }
    }
  }
  RETURN retval;
}

ASYNC MACRO SendProcessInput(OBJECT process, BLOB data)
{
  AWAIT AsyncSendBlobTo(process->input_handle, data);
  process->CloseInput();
}

ASYNC FUNCTION RunESLint(BLOB libdata, STRING resourcename)
{
  STRING diskpath := GetWebHareResourceDiskPath(resourcename);
  STRING eslintpath := MergePath(GetWebhareConfiguration().installationroot, "node_modules/.bin/eslint");
  STRING eslintrcpath := MergePath(GetWebhareConfiguration().installationroot, ".eslintrc.json");
  STRING ARRAY args := [ "-f", "json", "--no-eslintrc", "-c", eslintrcpath, "--stdin", "--stdin-filename", diskpath ];

  OBJECT proc := CreateProcess(eslintpath, args, TRUE, TRUE, TRUE, FALSE);
  //eslint looks up its plugins relative to its location
  proc->initialworkingdirectory := GetWebhareConfiguration().installationroot;
  proc->Start();

  OBJECT reader := ReadWholeProcessOutput(proc);
  AWAIT SendProcessInput(proc, libdata);
  RECORD retval := AWAIT reader;
  proc->Close();

  RECORD res := EnforceStructure([ messages := [[ line := 0, "column" := 0, message := "", fatal := FALSE ]]], DecodeJSON(retval.output));
  RETURN SELECT resourcename := resourcename, line, col := COLUMN "column", message, fatal FROM RECORD ARRAY(res.messages);
}

PUBLIC RECORD FUNCTION RunJSValidator(BLOB libdata, STRING resourcename, RECORD options)
{
  STRING modulename := GetModulenameFromResourcePath(resourcename);

  RECORD ARRAY warnings, errors;

  RECORD validateconfig := GetModuleValidationConfig(modulename);
  IF(NOT options.onlytids)
  {
    BOOLEAN run_eslint;
    STRING resnameformasks := Substring(resourcename,SearchSubString(resourcename,'/')+1);
    FOREVERY (STRING mask FROM validateconfig.eslintmasks)
      IF (ToUppercase(resnameformasks) LIKE ToUppercase(mask))
        run_eslint := TRUE;

    IF (run_eslint)
    {
      RECORD ARRAY messages := WaitForPromise(RunESLint(libdata, resourcename));
      errors := SELECT * FROM messages WHERE fatal;
      warnings := SELECT * FROM messages WHERE NOT fatal;
    }
  }

  RECORD texts := GetJSTexts(resourcename, libdata);

  RETURN CELL
         [ warnings
         , errors
         , tids :=    texts.texts
         , texts.icons
         ];
}

RECORD FUNCTION GetJSTexts(STRING resourcename, BLOB libdata)
{
//  BOOLEAN findscreens := TRUE; // we only need to search for screens in *.whlib files
  RECORD ARRAY texts;
  RECORD ARRAY icons;
  // Skip time consuming tokenizing and analysing of Javascript code
  // if the file has no mention of GetTid anywhere.
  // (This gives a big speed boost, huge even for the system module)
  STRING rawtext := ToUpperCase(BlobToString(libdata, -1));
  IF (SearchSubString(rawtext, 'GETTID') = -1 AND
      SearchSubString(rawtext, 'GETHTMLTID') = -1 AND
      SearchSubString(rawtext, '/*TID*/') = -1 AND
      SearchSubString(rawtext, '/*ICON*/') = -1)
    RETURN CELL[ texts, icons ];

  // Hack to be able to use the harescript tokenizer
  libdata := StringToBlob("<?wh " || Substitute(BlobToString(libdata), "?>", ""));

  INTEGER file := OpenHareScriptFile(libdata);

  RECORD tok := GetNextTok(file);
  RECORD ARRAY prevtokens;

  STRING current_objecttype;
  WHILE(TRUE)
  {
    tok := GetNextTok(file);
    IF(NOT RecordExists(tok))
      BREAK;

    //Keep a simple tokens lookback buffer
    IF(Length(prevtokens)=10)
      DELETE FROM prevtokens AT 0;
    INSERT tok INTO prevtokens AT END;

    BOOLEAN is_gettid := tok.token = "getTid";
    BOOLEAN is_gethtmltid := tok.token = "getHTMLTid";
    IF(is_gettid OR is_gethtmltid OR ToUppercase(tok.token) = "/*TID*/")
    {
      //ADDME: Gather errors and report them in a list after a 'scan missing texts' action
      RECORD expect_parenthesis := GetNextTok(file);

      RECORD expect_tid;

      IF(is_gettid AND RecordExists(expect_parenthesis) AND expect_parenthesis.token = ".") //is this getTid.html ?
      {
        expect_parenthesis := GetNextTok(file);
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token = "html")
        {
          expect_parenthesis := GetNextTok(file);
        }
        ELSE
        {
          CONTINUE; //unrecognized syntax
        }
      }

      IF (is_gettid OR is_gethtmltid)
      {
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token IN [":=","=",":"]) //use of gettid as variable name/function declaration
          CONTINUE; //skippable!


        IF(NOT RecordExists(expect_parenthesis) OR expect_parenthesis.token!="(")
        {
          CONTINUE;
        }

        expect_tid := GetNextTok(file);
        IF(RecordExists(expect_tid) AND expect_tid.istype) //definition of a function named gettid
          CONTINUE;
      }
      ELSE
        expect_tid := expect_parenthesis;

      // Skip if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_tid) OR Left(expect_tid.token,1) NOT IN ["'",'"'])
        CONTINUE;

      STRING tid := DecodeJava(Substring(expect_tid.token, 1, Length(expect_tid.token)-2));

      // Skip if the Tid isn't a single STRING (and give the first part which is a STRING)
      RECORD expect_comma_close := GetNextTok(file);
      IF(tid NOT LIKE ":*" AND (NOT RecordExists(expect_comma_close) OR Left(expect_comma_close.token,1) NOT IN [",",")","]"]))
        CONTINUE;

      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , tid :=       tid
             ]
        INTO texts AT END;
    }
    IF(ToUppercase(tok.token) = "/*ICON*/")
    {
      RECORD expect_icon := GetNextTok(file);

      // Ignore if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_icon) OR Left(expect_icon.token,1) NOT IN ["'",'"','`'])
        CONTINUE;

      IF(Left(expect_icon.token,1) = '`' AND Right(expect_icon.rawtoken,1) != '`') //looks like a ` string ending with a ${
        CONTINUE;

      STRING icon := DecodeJava(Substring(expect_icon.token, 1, Length(expect_icon.token)-2));
      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , icon :=      icon
             ]
        INTO icons AT END;
    }
  }

  CloseHarescriptFile(file);
  RETURN CELL[ texts, icons ];
}

/** Checks typescript files (using the typescript compiler)
    @param modulename Name of an external module to check or "coremodules" for all core modules.
    @return Validation results
    @cell return.issues List of found issues
    @cell return.issues.filename Resource name
    @cell return.issues.line Line
    @cell return.issues.col Column
    @cell return.issues.message Error message
    @cell return.issues.category Category (always "error")
*/
PUBLIC ASYNC FUNCTION CheckModuleTypeScriptFiles(STRING modulename)
{
  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  IF (modulename IN whconstant_builtinmodules)
    THROW NEW Exception(`Cannot check individual core modules, use "coremodules" to check all core modules`);

  IF (modulename = "coremodules" OR modulename IN whconstant_builtinmodules)
  {
    STRING tscpath := MergePath(GetWebhareConfiguration().installationroot, "node_modules/.bin/tsc");
    STRING tsconfigpath := MergePath(GetWebhareConfiguration().installationroot, "tsconfig.json");
    STRING tsbuildinfodir := MergePath(GetWebhareConfiguration().ephemeralroot, "system.typescript");
    STRING tsbuildinfofile := MergePath(tsbuildinfodir, "coremodules.tsbuildinfo");
    CreateDiskDirectoryRecursive(tsbuildinfodir, TRUE);

    STRING ARRAY args := [ "--project", tsconfigpath, "--noEmit", "--incremental", "--tsBuildInfoFile", tsbuildinfofile ];

    OBJECT proc := CreateProcess(tscpath, args, TRUE, TRUE, TRUE, FALSE);
    proc->initialworkingdirectory := GetWebhareConfiguration().installationroot;
    proc->Start();

    OBJECT reader := ReadWholeProcessOutput(proc);
    RECORD procresult := AWAIT reader;
    proc->Close();

    OBJECT matcher := NEW RegEx("^modules/([^\\(]*)\\((\\d*),(\\d*)\\): (.*)$");

    FOREVERY (STRING line FROM Tokenize(procresult.output, "\n"))
    {
      RECORD ARRAY match := matcher->Exec(line);
      IF (RecordExists(match))
      {
        INSERT
            [ resourcename := `mod::${match[1].value}`
            , line :=         ToInteger(match[2].value, 1)
            , col :=          ToInteger(match[3].value, 1)
            , message :=      match[4].value
            , category :=     "error"
            ] INTO retval.issues AT END;
      }
    }
  }
  RETURN retval;
}
