<?wh

LOADLIB "wh::async.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::filetypes/harescript.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/harescript.whlib";
LOADLIB "mod::system/lib/internal/validation/scan.whlib";

LOADLIB "wh::internal/interface.whlib";

PUBLIC RECORD FUNCTION RunESLint(RECORD ARRAY resources, RECORD options DEFAULTSTO DEFAULT RECORD) {
  RECORD res := CallJS("mod::system/js/internal/eslint.ts#handleLintingCommand", resources, options);
  RETURN CELL[ messages := RECORD ARRAY(res.messages), fixes := RECORD ARRAY(res.fixes) ];
}

//NOTE this API is no longer used for wh checkmodule
PUBLIC RECORD FUNCTION RunJSValidator(BLOB libdata, STRING resourcepath, RECORD options)
{
  STRING modulename := GetModulenameFromResourcePath(resourcepath);

  RECORD ARRAY warnings, errors;

  RECORD validateconfig := GetModuleValidationConfig(modulename);
  IF(NOT options.onlytids)
  {
    BOOLEAN run_eslint;
    STRING resnameformasks := Substring(resourcepath,SearchSubString(resourcepath,'/')+1);
    FOREVERY (STRING mask FROM validateconfig.eslintmasks)
      IF (ToUppercase(resnameformasks) LIKE ToUppercase(mask))
        run_eslint := TRUE;

    IF (run_eslint)
    {
      RECORD ARRAY messages := RunESLint([CELL[ resourcepath, contents := BlobToString(libdata) ]]).messages;
      errors := SELECT * FROM messages WHERE type="error";
      warnings := SELECT * FROM messages WHERE type!="error";
    }
  }

  RECORD texts := GetJSTexts(resourcepath, libdata);

  RETURN CELL
         [ warnings
         , errors
         , texts.tids
         , texts.icons
         ];
}

PUBLIC RECORD FUNCTION GetJSTexts(STRING resourcename, BLOB libdata)
{
//  BOOLEAN findscreens := TRUE; // we only need to search for screens in *.whlib files
  RECORD ARRAY texts;
  RECORD ARRAY icons;
  // Skip time consuming tokenizing and analysing of Javascript code
  // if the file has no mention of GetTid anywhere.
  // (This gives a big speed boost, huge even for the system module)
  STRING rawtext := ToUpperCase(BlobToString(libdata, -1));
  IF (SearchSubString(rawtext, 'GETTID') = -1 AND
      SearchSubString(rawtext, 'GETHTMLTID') = -1 AND
      SearchSubString(rawtext, '/*TID*/') = -1 AND
      SearchSubString(rawtext, '/*ICON*/') = -1)
    RETURN CELL[ tids := texts, icons ];

  // Hack to be able to use the harescript tokenizer
  libdata := StringToBlob("<?wh " || Substitute(BlobToString(libdata), "?>", ""));

  INTEGER file := OpenHareScriptFile(libdata);

  RECORD tok := GetNextTok(file);
  RECORD ARRAY prevtokens;

  STRING current_objecttype;
  WHILE(TRUE)
  {
    tok := GetNextTok(file);
    IF(NOT RecordExists(tok))
      BREAK;

    //Keep a simple tokens lookback buffer
    IF(Length(prevtokens)=10)
      DELETE FROM prevtokens AT 0;
    INSERT tok INTO prevtokens AT END;

    BOOLEAN is_gettid := tok.token = "getTid";
    BOOLEAN is_gethtmltid := tok.token = "getHTMLTid";
    IF(is_gettid OR is_gethtmltid OR ToUppercase(tok.token) = "/*TID*/")
    {
      //ADDME: Gather errors and report them in a list after a 'scan missing texts' action
      RECORD expect_parenthesis := GetNextTok(file);

      RECORD expect_tid;

      IF(is_gettid AND RecordExists(expect_parenthesis) AND expect_parenthesis.token = ".") //is this getTid.html ?
      {
        expect_parenthesis := GetNextTok(file);
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token = "html")
        {
          expect_parenthesis := GetNextTok(file);
        }
        ELSE
        {
          CONTINUE; //unrecognized syntax
        }
      }

      IF (is_gettid OR is_gethtmltid)
      {
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token IN [":=","=",":"]) //use of gettid as variable name/function declaration
          CONTINUE; //skippable!


        IF(NOT RecordExists(expect_parenthesis) OR expect_parenthesis.token!="(")
        {
          CONTINUE;
        }

        expect_tid := GetNextTok(file);
        IF(RecordExists(expect_tid) AND expect_tid.istype) //definition of a function named gettid
          CONTINUE;
      }
      ELSE
        expect_tid := expect_parenthesis;

      // Skip if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_tid) OR Left(expect_tid.token,1) NOT IN ["'",'"','`'])
        CONTINUE;

      STRING tid := DecodeJava(Substring(expect_tid.token, 1, Length(expect_tid.token)-2));

      // Skip if the Tid isn't a single STRING (and give the first part which is a STRING)
      RECORD expect_comma_close := GetNextTok(file);
      IF(tid NOT LIKE ":*" AND (NOT RecordExists(expect_comma_close) OR Left(expect_comma_close.token,1) NOT IN [",",")","]","}"]))
        CONTINUE;

      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , tid :=       tid
             ]
        INTO texts AT END;
    }
    IF(ToUppercase(tok.token) = "/*ICON*/")
    {
      RECORD expect_icon := GetNextTok(file);

      // Ignore if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_icon) OR Left(expect_icon.token,1) NOT IN ["'",'"','`'])
        CONTINUE;

      IF(Left(expect_icon.token,1) = '`' AND Right(expect_icon.rawtoken,1) != '`') //looks like a ` string ending with a ${
        CONTINUE;

      STRING icon := DecodeJava(Substring(expect_icon.token, 1, Length(expect_icon.token)-2));
      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , icon :=      icon
             ]
        INTO icons AT END;
    }
  }

  CloseHarescriptFile(file);
  RETURN CELL[ tids := texts, icons ];
}

BOOLEAN FUNCTION ShouldDiscard(STRING modulename, STRING resourcename)
{
  IF(resourcename LIKE "mod::*") //TS errors currently inconsistently come in as full paths or resource paths (also because /jssdk/ isn't a module)
    resourcename := GetWebHareResourceDiskPath(resourcename);

  //TS doesn't let us configure different settings for the postgresql-client dir so just discard the errors
  IF(resourcename LIKE "*/jssdk/whdb/vendor/postgrejs/*")
    RETURN TRUE;

  /* If modules (indirectly) include their own copy of @types/node they may not match the node WebHare is shipping with.
     This will lead to CI errors such as
     ERR!: whtree/.../webhareblob.ts:47:23 error TS2345: Argument of type 'ReadableStream<Uint8Array>' is not assignable to parameter of type 'Readable | ReadableStream | AsyncIterator<any, any, undefined>'.
     ie files that are outside your control.

     We cannot force checkmodules on external paths to use our types. It doesn't use our tsconfig.json path list for resolving @types/node
     but looks at the https://www.typescriptlang.org/tsconfig#typeRoots setting. But if we overwrite that, we completely take over all
     types, not just @types/node

     To avoid having every module install/upgrade their @types/node when encountering this we'll simply ignore any errors
     coming from the jssdk or builtin modules.

     Note that we get full paths in resourcename for files in jssdk but mod:: paths for files in eg mod::system
  */
  IF(modulename != "platform" AND resourcename NOT LIKE GetModuleInstallationRoot(modulename) || "*")
  {
    IF(resourcename LIKE MergePath(GetInstallationRoot(), "jssdk") || "/*" OR resourcename LIKE MergePath(GetInstallationRoot(), "modules/") || "/*")
      RETURN TRUE;
  }

  RETURN FALSE;
}

/** Checks typescript files (using the typescript compiler)
    @param modulename Name of an external module to check or "platform" for all core modules.
    @return Validation results
    @cell return.issues List of found issues
    @cell return.issues.filename Resource name
    @cell return.issues.line Line
    @cell return.issues.col Column
    @cell return.issues.message Error message
    @cell return.issues.category Category ("error" or "warning")
*/
PUBLIC ASYNC FUNCTION CheckModuleTypeScriptFiles(STRING modulename)
{
  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  IF (modulename IN whconstant_builtinmodules AND modulename != "platform")
    THROW NEW Exception(`Cannot check individual core modules, use "platform" to check all core modules`);

  FOREVERY(RECORD message FROM WaitForPromise(ImportJS("@mod-platform/js/devsupport/typescript.ts")->CheckUsingTSC(modulename)))
  {
    IF(ShouldDiscard(modulename, message.resourcename))
      CONTINUE;
    INSERT message INTO retval.issues AT END;
  }

  RETURN retval;
}

/** Format a single javascript file
    @param file File to format
    @param autofix If set, automatically fix issues. Usually not used when just testing for formatting changes to prevent turning autofixable eslint warnings into errors
    @return Formatted file
    @cell(blob) return.output Formatted file
*/
ASYNC FUNCTION FormatSingleFile(RECORD file, BOOLEAN autofix) {
  STRING contents := BlobToString(file.data);

  IF(autofix) {
    RECORD eslint := AWAIT RunESLint([CELL[ resourcepath := file.path, contents ]], [ fix := TRUE, allowinlineconfig := FALSE ]);
    IF(Length(eslint.fixes) > 0)
      contents := eslint.fixes[0].output;
  }

  STRING dir := GetDirectoryFromPath(file.path);

  RECORD cmd := CELL [ file.path, data := contents ];

  RECORD rec := CallJS("mod::system/js/internal/tsfmt.ts#handleFormattingCommand", cmd);
  IF (rec.output != cmd.data AND autofix) {
    contents := rec.output;

    // Re-run eslint to clean up formatting result (which sometimes leaves trailing spaces)
    RECORD eslint := AWAIT RunESLint([CELL[ resourcepath := file.path, contents ]], [ fix := TRUE, allowinlineconfig := FALSE ]);
    IF(Length(eslint.fixes) > 0)
      contents := eslint.fixes[0].output;
  }

  RETURN CELL
      [ ...file
      , ...rec
      , output := StringToBlob(contents)
      ];
}

/** Format multiple javascript files
    @param data List of files to format
    @cell(string) data.path Path to file
    @cell(blob) data.data Contents of file
    @return Formatted files
    @cell(string) return.path Path of formatted file
    @cell(string) return.error If set, error message
    @cell(blob) return.output Formatted output (if error is empty)
*/
PUBLIC ASYNC FUNCTION FormatJavascriptFiles(RECORD ARRAY data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ autofix := TRUE ], options);

  INTEGER cmdstream := CreateStream();

  // Run max 8 formatters concurrently
  OBJECT serializer := MakeCallSerializer([ maxconcurrent := 8 ]);

  OBJECT ARRAY scheduled;
  FOREVERY (RECORD file FROM data)
    INSERT serializer->Call(PTR FormatSingleFile, file, options.autofix) INTO scheduled AT END;

  RETURN RECORD ARRAY(AWAIT CreatePromiseAll(scheduled));
}

/** Format a single javascript file
    @param path Path to file
    @param data Contents of the file
    @return Formatted file
    @cell(blob) return.output Formatted file
*/
PUBLIC ASYNC FUNCTION FormatJavascriptFile(STRING path, BLOB data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ autofix := TRUE ], options);

  RECORD ARRAY res := AWAIT FormatJavascriptFiles([ CELL[ path, data ] ], options);
  RETURN CELL[ res[0].output ];
}

/** Checks the formatting status of all files in a module
    @param module Module to check
    @cell options.onlypaths If set, check only these paths
    @return List of issues
    @cell(record array) return.issues Issues
    @cell(string) return.issues.resourcename Name fo the resource with the issue
    @cell(integer) return.issues.line Line number
    @cell(integer) return.issues.col Column number
    @cell(string) return.issues.message Error message
    @cell(string) return.issues.category Category ('error' | 'warning')
*/
PUBLIC ASYNC FUNCTION CheckModuleJavascriptFormatting(STRING module, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ onlypaths := STRING[]
      , filemask := "*"
      ], options);

  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  STRING root := module = "jssdk"
      ? GetWebhareConfiguration().installationroot || "jssdk/"
      : "mod::" || module;

  RECORD ARRAY files := GetFilesToValidate([ root ], [ extensions := whconstant_javascript_extensions ]);

  RECORD ARRAY toformat;
  FOREVERY (RECORD rec FROM files)
  {
    IF (NOT MatchesPathMasks(rec.subpath, rec.settings.formatmasks) OR MatchesPathMasks(rec.subpath, rec.settings.formatexcludemasks))
      CONTINUE;

    IF (IsValueSet(options.onlypaths) AND rec.path NOT IN options.onlypaths)
      CONTINUE;

    IF (ToUppercase(GetNameFromPath(rec.subpath)) NOT LIKE ToUppercase(options.filemask))
      CONTINUE;

    BLOB data := GetDiskResource(rec.path);
    INSERT CELL[ rec.path, data, rec.module, rec.subpath ] INTO toformat AT END;
  }

  TRY
  {
    RECORD ARRAY result := WaitForPromise(FormatJavascriptFiles(toformat, [ autofix := FALSE ]));
    FOREVERY (RECORD rec FROM result)
    {
      STRING resourcename := rec.module = "jssdk" ? `direct::${rec.path}` : `mod::${rec.module}/${rec.subpath}`;
      BOOLEAN ismatch := BlobToString(rec.output) = BlobToString(rec.data);
      IF (NOT ismatch)
      {
        INSERT CELL
            [ resourcename
            , line :=         1
            , col :=          1
            , message :=      `File hasn't been formatted correctly - fixable using wh dev:autoformat`
            , category :=     "warning"
            , source :=       "tsfmt"
            ] INTO retval.issues AT END;
      }
    }
  }
  CATCH (OBJECT e)
  {
    INSERT
        [ resourcename := `mod::${module}/moduledefinition.xml`
        , line :=         1
        , col :=          1
        , message :=      `Error formatting javascript files: ${e->what}`
        , category :=     "error"
        ] INTO retval.issues AT END;
  }
  RETURN retval;
}
