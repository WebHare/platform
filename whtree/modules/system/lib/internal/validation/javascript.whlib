<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::filetypes/harescript.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/harescript.whlib";

LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::internal/interface.whlib";

ASYNC FUNCTION ReadWholeProcessOutput(OBJECT process)
{
  RECORD retval :=
      [ output :=   ""
      , errors :=   ""
      , exitcode := -1
      ];

  OBJECT itr := MakeProcessAsyncIterator(process, [ autoclose := FALSE ]);
  WHILE (TRUE)
  {
    RECORD rec := AWAIT itr->Next();
    IF (rec.done)
      BREAK;
    SWITCH (rec.value.type)
    {
      CASE "output"   { retval.output := retval.output || rec.value.line || "\n"; }
      CASE "error"    { retval.errors := retval.errors || rec.value.line || "\n"; }
      CASE "close"    { retval.exitcode := rec.value.exitcode; }
    }
  }
  RETURN retval;
}

ASYNC MACRO SendProcessInput(OBJECT process, BLOB data)
{
  AWAIT AsyncSendBlobTo(process->input_handle, data);
  process->CloseInput();
}

ASYNC FUNCTION RunESLint(BLOB libdata, STRING resourcename)
{
  STRING diskpath := GetWebHareResourceDiskPath(resourcename);
  STRING eslintpath := MergePath(GetWebhareConfiguration().installationroot, "node_modules/.bin/eslint");
  STRING eslintrcpath := MergePath(GetWebhareConfiguration().installationroot, ".eslintrc.json");
  STRING ARRAY args := [ "-f", "json", "--no-eslintrc", "-c", eslintrcpath, "--stdin", "--stdin-filename", diskpath ];

  OBJECT proc := CreateProcess(eslintpath, args, TRUE, TRUE, TRUE, FALSE);
  //eslint looks up its plugins relative to its location
  proc->initialworkingdirectory := GetWebhareConfiguration().installationroot;
  proc->Start();

  OBJECT reader := ReadWholeProcessOutput(proc);
  AWAIT SendProcessInput(proc, libdata);
  RECORD retval := AWAIT reader;
  proc->Close();

  RECORD res := EnforceStructure([ messages := [[ line := 0, "column" := 0, message := "", fatal := FALSE ]]], DecodeJSON(retval.output));
  RETURN SELECT resourcename := resourcename, line, col := COLUMN "column", message, fatal FROM RECORD ARRAY(res.messages);
}

PUBLIC RECORD FUNCTION RunJSValidator(BLOB libdata, STRING resourcename, RECORD options)
{
  STRING modulename := GetModulenameFromResourcePath(resourcename);

  RECORD ARRAY warnings, errors;

  RECORD validateconfig := GetModuleValidationConfig(modulename);
  IF(NOT options.onlytids)
  {
    BOOLEAN run_eslint;
    STRING resnameformasks := Substring(resourcename,SearchSubString(resourcename,'/')+1);
    FOREVERY (STRING mask FROM validateconfig.eslintmasks)
      IF (ToUppercase(resnameformasks) LIKE ToUppercase(mask))
        run_eslint := TRUE;

    IF (run_eslint)
    {
      RECORD ARRAY messages := WaitForPromise(RunESLint(libdata, resourcename));
      errors := SELECT * FROM messages WHERE fatal;
      warnings := SELECT * FROM messages WHERE NOT fatal;
    }
  }

  RECORD texts := GetJSTexts(resourcename, libdata);

  RETURN CELL
         [ warnings
         , errors
         , tids :=    texts.texts
         , texts.icons
         ];
}

RECORD FUNCTION GetJSTexts(STRING resourcename, BLOB libdata)
{
//  BOOLEAN findscreens := TRUE; // we only need to search for screens in *.whlib files
  RECORD ARRAY texts;
  RECORD ARRAY icons;
  // Skip time consuming tokenizing and analysing of Javascript code
  // if the file has no mention of GetTid anywhere.
  // (This gives a big speed boost, huge even for the system module)
  STRING rawtext := ToUpperCase(BlobToString(libdata, -1));
  IF (SearchSubString(rawtext, 'GETTID') = -1 AND
      SearchSubString(rawtext, 'GETHTMLTID') = -1 AND
      SearchSubString(rawtext, '/*TID*/') = -1 AND
      SearchSubString(rawtext, '/*ICON*/') = -1)
    RETURN CELL[ texts, icons ];

  // Hack to be able to use the harescript tokenizer
  libdata := StringToBlob("<?wh " || Substitute(BlobToString(libdata), "?>", ""));

  INTEGER file := OpenHareScriptFile(libdata);

  RECORD tok := GetNextTok(file);
  RECORD ARRAY prevtokens;

  STRING current_objecttype;
  WHILE(TRUE)
  {
    tok := GetNextTok(file);
    IF(NOT RecordExists(tok))
      BREAK;

    //Keep a simple tokens lookback buffer
    IF(Length(prevtokens)=10)
      DELETE FROM prevtokens AT 0;
    INSERT tok INTO prevtokens AT END;

    BOOLEAN is_gettid := tok.token = "getTid";
    BOOLEAN is_gethtmltid := tok.token = "getHTMLTid";
    IF(is_gettid OR is_gethtmltid OR ToUppercase(tok.token) = "/*TID*/")
    {
      //ADDME: Gather errors and report them in a list after a 'scan missing texts' action
      RECORD expect_parenthesis := GetNextTok(file);

      RECORD expect_tid;

      IF(is_gettid AND RecordExists(expect_parenthesis) AND expect_parenthesis.token = ".") //is this getTid.html ?
      {
        expect_parenthesis := GetNextTok(file);
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token = "html")
        {
          expect_parenthesis := GetNextTok(file);
        }
        ELSE
        {
          CONTINUE; //unrecognized syntax
        }
      }

      IF (is_gettid OR is_gethtmltid)
      {
        IF(RecordExists(expect_parenthesis) AND expect_parenthesis.token IN [":=","=",":"]) //use of gettid as variable name/function declaration
          CONTINUE; //skippable!


        IF(NOT RecordExists(expect_parenthesis) OR expect_parenthesis.token!="(")
        {
          CONTINUE;
        }

        expect_tid := GetNextTok(file);
        IF(RecordExists(expect_tid) AND expect_tid.istype) //definition of a function named gettid
          CONTINUE;
      }
      ELSE
        expect_tid := expect_parenthesis;

      // Skip if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_tid) OR Left(expect_tid.token,1) NOT IN ["'",'"'])
        CONTINUE;

      STRING tid := DecodeJava(Substring(expect_tid.token, 1, Length(expect_tid.token)-2));

      // Skip if the Tid isn't a single STRING (and give the first part which is a STRING)
      RECORD expect_comma_close := GetNextTok(file);
      IF(tid NOT LIKE ":*" AND (NOT RecordExists(expect_comma_close) OR Left(expect_comma_close.token,1) NOT IN [",",")","]"]))
        CONTINUE;

      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , tid :=       tid
             ]
        INTO texts AT END;
    }
    IF(ToUppercase(tok.token) = "/*ICON*/")
    {
      RECORD expect_icon := GetNextTok(file);

      // Ignore if first parameter of GetTid is not a STRING
      IF(NOT RecordExists(expect_icon) OR Left(expect_icon.token,1) NOT IN ["'",'"','`'])
        CONTINUE;

      IF(Left(expect_icon.token,1) = '`' AND Right(expect_icon.rawtoken,1) != '`') //looks like a ` string ending with a ${
        CONTINUE;

      STRING icon := DecodeJava(Substring(expect_icon.token, 1, Length(expect_icon.token)-2));
      INSERT [ resourcename :=  resourcename
             , line :=      tok.line
             , col :=       tok.col
             , icon :=      icon
             ]
        INTO icons AT END;
    }
  }

  CloseHarescriptFile(file);
  RETURN CELL[ texts, icons ];
}

/** Given a directory, find a .ts or .tsx file, ignoreing node_modules
    Returns the subpath within the root
    @param root Root folder
    @param subpath Subpath to start in (use "" to start at root)
    @return Subpath to first found .ts or .tsx file
*/
PUBLIC STRING FUNCTION RecursivelyFindTypeScriptFile(STRING root, STRING subpath DEFAULTSTO "")
{
  STRING finalpath := subpath = "" ? root : MergePath(root, subpath);

  RECORD ARRAY contents := ReadDiskDirectory(finalpath, "*");
  FOREVERY (RECORD rec FROM contents)
  {
    IF (rec.name = "node_modules")
      CONTINUE;
    IF (rec.name LIKE "*.ts" OR rec.name LIKE "*.tsx")
      RETURN subpath = "" ? rec.name : MergePath(subpath, rec.name);
    IF (rec.type = 1)
    {
      STRING tsfile := RecursivelyFindTypeScriptFile(root, subpath = "" ? rec.name : MergePath(subpath, rec.name));
      IF (IsValueSet(tsfile))
        RETURN tsfile;
    }
  }
  RETURN "";
}

/** Checks typescript files (using the typescript compiler)
    @param modulename Name of an external module to check or "coremodules" for all core modules.
    @return Validation results
    @cell return.issues List of found issues
    @cell return.issues.filename Resource name
    @cell return.issues.line Line
    @cell return.issues.col Column
    @cell return.issues.message Error message
    @cell return.issues.category Category ("error" or "warning")
*/
PUBLIC ASYNC FUNCTION CheckModuleTypeScriptFiles(STRING modulename)
{
  RECORD retval :=
      [ issues :=     RECORD[]
      ];

  IF (modulename IN whconstant_builtinmodules)
    THROW NEW Exception(`Cannot check individual core modules, use "coremodules" to check all core modules`);

  // For core modules (or webhare_testsuite when present in whtree) use the whtree tsconfig.json
  STRING tsbuildinfodir := MergePath(GetWebhareConfiguration().ephemeralroot, "system.typescript");
  STRING tsconfigpath, tsbuildinfofile;
  IF (modulename = "coremodules"
      OR modulename IN whconstant_builtinmodules
      OR (modulename = "webhare_testsuite" AND GetModuleInstallationRoot(modulename) LIKE GetWebhareConfiguration().installationroot || "*"))
  {
    tsconfigpath := MergePath(GetWebhareConfiguration().installationroot, "tsconfig.json");
    tsbuildinfofile := MergePath(tsbuildinfodir, "coremodules.tsbuildinfo");
  }
  ELSE
  {
    STRING installationroot := GetModuleInstallationRoot(modulename);
    STRING anytsfile := RecursivelyFindTypeScriptFile(installationroot, ".");

    // Don't need to validate if no .ts/.tsx files present
    IF (IsDefaultValue(anytsfile))
      RETURN retval;

    tsconfigpath := MergePath(installationroot, "tsconfig.json");

    // Don't go create tsconfig.json on acceptance and production servers
    IF (GetDTAPStage() NOT IN [ "development", "test" ] AND NOT RecordExists(GetDiskFileProperties(tsconfigpath)))
      RETURN retval;

    CreateModuleTSConfigFile(modulename);
    tsbuildinfofile := MergePath(tsbuildinfodir, `${modulename}.tsbuildinfo`);
  }

  STRING tscpath := MergePath(GetWebhareConfiguration().installationroot, "node_modules/.bin/tsc");
  CreateDiskDirectoryRecursive(tsbuildinfodir, TRUE);

  STRING ARRAY args := [ "--project", tsconfigpath, "--noEmit", "--incremental", "--tsBuildInfoFile", tsbuildinfofile ];

  OBJECT proc := CreateProcess(tscpath, args, FALSE, TRUE, TRUE, FALSE);
  proc->initialworkingdirectory := GetWebhareConfiguration().installationroot;
  proc->Start();

  OBJECT reader := ReadWholeProcessOutput(proc);
  RECORD procresult := AWAIT reader;
  proc->Close();

  OBJECT matcher := NEW RegEx("^modules/([^\\(]*)\\((\\d*),(\\d*)\\): (.*)$");

  FOREVERY (STRING line FROM Tokenize(procresult.output, "\n"))
  {
    RECORD ARRAY match := matcher->Exec(line);
    IF (RecordExists(match))
    {
      INSERT
          [ resourcename := `mod::${match[1].value}`
          , line :=         ToInteger(match[2].value, 1)
          , col :=          ToInteger(match[3].value, 1)
          , message :=      match[4].value
          , category :=     "error"
          ] INTO retval.issues AT END;
    }
  }

  RETURN retval;
}

/** Creates a tsconfig.json file in the root directory of the specified module
    @param modulename Name of the module
*/
PUBLIC MACRO CreateModuleTSConfigFile(STRING modulename)
{
  IF (modulename IN whconstant_builtinmodules OR
      (modulename = "webhare_testsuite" AND GetModuleInstallationRoot(modulename) LIKE GetWebhareConfiguration().installationroot || "*"))
    THROW NEW Exception(`Cannot generate tsconfig.json for webhare core modules`);

  STRING core_tsconfig_path := MergePath(GetWebhareConfiguration().installationroot, "tsconfig.json");
  STRING installationroot := GetModuleInstallationRoot(modulename);

  RECORD module := SELECT * FROM GetWebHareModules() WHERE name = modulename;
  STRING ARRAY allowedmodules := STRING[ ...whconstant_builtinmodules, "webhare_testsuite", modulename ];
  IF (RecordExists(module))
    allowedmodules := allowedmodules CONCAT ArrayDelete((SELECT AS STRING ARRAY name FROM module.requiredmodules), whconstant_builtinmodules);

  OBJECT paths := NEW JSONObject;
  paths->SetProp("dompack", [ ResolveToRelativePath(installationroot, MergePath(GetModuleInstallationRoot("system"), "/js/dompack")) ]);
  paths->SetProp("@types/node", [ ResolveToRelativePath(installationroot, MergePath(GetWebhareConfiguration().installationroot, "node_modules/@types/node")) ]);
  FOREVERY (STRING mod FROM allowedmodules)
  {
    STRING root := GetModuleInstallationRoot(mod);
    IF (root != "")
    {
      paths->SetProp(`@mod-${mod}`, [ ResolveToRelativePath(installationroot, root) ?? "." ]);
      paths->SetProp(`@storage-${mod}`, [ ResolveToRelativePath(installationroot, GetModuleStorageRoot(mod)) ]);
    }
  }

  OBJECT compilerOptions := NEW JSONObject;
  compilerOptions->SetProp("baseUrl", installationroot);
  compilerOptions->SetProp("paths", paths);

  OBJECT tsconfig := NEW JSONObject;
  tsconfig->SetProp("extends", core_tsconfig_path);
  tsconfig->SetProp("compilerOptions", compilerOptions);

  BLOB tsconfigblob := EncodeJSONBlob(tsconfig, DEFAULT RECORD, [ formatted := TRUE ]);

  StoreDiskFile(MergePath(installationroot, "tsconfig.json"), tsconfigblob, [ overwrite := TRUE ]);
}
