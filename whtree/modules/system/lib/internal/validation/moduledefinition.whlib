<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::util/localization.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/tasks.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/dbase/parser.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";

BOOLEAN FUNCTION IsValidTimeZone(STRING tz)
{
  IF(IsWasm())
    RETURN ImportJS("./validatehelpers.ts")->IsValidTimeZone(tz);
  ELSE
    RETURN GetCanonicalTimeZoneID(tz) != "";
}
BOOLEAN FUNCTION CaptureOtherTids(STRING modulename, OBJECT moduledeffile)
{
  GetModuleDashboardInfo(modulename, moduledeffile);
  GetAppGroups(modulename, moduledeffile);
  GetWHFSRegisterSlots(modulename, moduledeffile);
  RETURN TRUE;
}

RECORD FUNCTION GetWebruleMessage(RECORD rule, STRING message)
{
  INTEGER lastcolon := SearchLastSubstring(rule.source,':');
  RETURN CELL[ line := ToInteger(Substring(rule.source, lastcolon+1), 0), col := 0, resourcename := Left(rule.source,lastcolon), message ];
}

RECORD FUNCTION ValidateWebRuleData(RECORD rule)
{
  //Validate resources that have to exist as they shouldn't be created dynamically, eg mod::
  RECORD retval := [ errors := RECORD[], warnings := RECORD[] ];
  FOREVERY(RECORD datastore FROM rule.datastorage)
  {
    IF(datastore.resource LIKE "mod::*" AND datastore.resource NOT LIKE "*[*") //ignores [modulename]
    {
      RECORD target := GetDiskFileProperties(GetWebHareResourceDiskPath(datastore.resource));
      IF(NOT RecordExists(target))
        INSERT GetWebruleMessage(rule,`No such resource '${datastore.resource}'`) INTO retval.errors AT END;
      ELSE IF(target.type = 1 AND NOT datastore.isfolder)
        INSERT GetWebruleMessage(rule,`Resource '${datastore.resource}' is a folder`) INTO retval.errors AT END;
      ELSE IF(target.type = 0 AND datastore.isfolder)
        INSERT GetWebruleMessage(rule,`Resource '${datastore.resource}' is a file`) INTO retval.errors AT END;
    }
  }
  RETURN retval;
}
PUBLIC STATIC OBJECTTYPE ModuleDefinitionValidator EXTEND ModuleDefParser
<
  UPDATE PUBLIC MACRO ValidateDocument()
  {
    RECORD md := this->ParseAndValidate();

    ListModuleWebruleSets(this->respath, this->xml); //parse <webruleset> titles
    ParseModuleDefRunonce(this);
    CaptureOtherTids(this->modulename, this->xml);

    FOREVERY(OBJECT dbschema FROM this->xml->documentelement->ListElements(whconstant_xmlns_moduledef, "databaseschema"))
    {
      RECORD parsed := ParseWHDBSchemaSpec(this->modulename, dbschema);
      FOREVERY (RECORD rec FROM parsed.msgs)
        IF (rec.iserror)
          this->AddErrorForLine(rec.line, rec.text);
        ELSE
          this->AddWarningForLine(rec.line, rec.text);
    }

    FOREVERY(OBJECT scp FROM this->xml->documentelement->ListElements(whconstant_xmlns_moduledef, "searchcontentprovider"))
    {
      this->VerifyObjectExistence(scp->linenum, MakeAbsoluteResourcePath(this->respath, scp->GetAttribute("objectname")));
    }

    //Validate application entrypoints
    FOREVERY(RECORD app FROM md.portal.applications CONCAT md.fs_objecteditors)
    {
      IF(app.screen != "")
        this->VerifyScreenReferenceExistence(app.linenum, app.screen, "screen");

      IF(app.appfunction != "")
        this->VerifyFunctionExistenceForScope([ resourcename := this->respath, line := app.linenum, col := 0], app.appfunction);
    }


    FOREVERY(RECORD app FROM md.portal.applications)
      this->ValidateIcon(CELL[ app.line ], app.icon, "b,w");

    FOREVERY(RECORD task FROM md.tasks)
    {
      IF(task.runtz NOT IN ["","maintenance"] AND NOT IsValidTimeZone(task.runtz))
        this->AddErrorForLine(task.line, `Invalid timezone '${task.runtz}'`);

      IF(task.runat != "")
      {
        TRY GetNextCronTime(GetCurrentDatetime(), task.runat);
        CATCH(OBJECT e) { this->AddErrorForLine(task.line, `Invalid runat '${task.runat}': '${e->what}`); }
      }
    }

    RECORD taskinfo := ParseModuleTasks(this->modulename, this->respath, this->xml);
    FOREVERY(RECORD task FROM taskinfo.tasktypes)
    {
      IF(task.applyerror = "" AND task.objectname != "") //Note that JS tasks set taskrunner=, not objectname=
      {
        this->VerifyObjectExistence(task.linenum, task.objectname);
      }
    }

    FOREVERY(OBJECT rulenode FROM this->xml->GetElements("webrule"))
    {
      IF(NOT IsNodeApplicableToThisWebHare(rulenode))
        CONTINUE;

      //We don't currently have an easier way to parse rules..
      RECORD baserule := GetBaseWebRule(-9999999, rulenode->GetAttribute("path"), ParseWebRulePriority(rulenode->GetAttribute("priority")), this->respath || ":" || rulenode->linenum);
      RECORD parsed := ParseWebRuleData(this->modulename, baserule, rulenode, this->respath, [ forvalidation := TRUE ]);
      this->errors := this->errors CONCAT SELECT * FROM parsed.messages WHERE type = "error";
      this->warnings := this->warnings CONCAT SELECT * FROM parsed.messages WHERE type != "error";
      IF (RecordExists(parsed.rule))
      {
        RECORD validateres := ValidateWebRuleData(parsed.rule);
        this->errors   := this->errors   CONCAT validateres.errors;
        this->warnings := this->warnings CONCAT validateres.warnings;
      }
    }

    OBJECT packaging := PickFirst(this->xml->ListElements(whconstant_xmlns_moduledef,"packaging"));

    FOREVERY(OBJECT appnode FROM this->xml->ListElements(whconstant_xmlns_moduledef,"application"))
      IF(IsNodeApplicableToThisWebHare(appnode))
      {
        STRING startmacro := appnode->GetAttribute("startmacro");
        IF(appnode->HasAttribute("library"))
        {
          this->AddError(appnode, `library= is no longer supported (combine into startmacro=, dev:rewite can fix this!`);
          CONTINUE;
        }

        IF(startmacro != "" AND startmacro NOT LIKE "*#*")
        {
          this->AddErrorForLine(appnode->linenum, "Invalid startmacro reference");
          CONTINUE;
        }

        IF(startmacro != "")
        {
          STRING lib := MakeAbsoluteResourcePath(this->respath, Tokenize(startmacro,'#')[0]);
          IF(NOT RecordExists(RetrieveWebHareResource(lib, [ allowmissing := TRUE ])))
          {
            STRING trylib := "module::" || this->modulename || "/" || Tokenize(startmacro,'#')[0];
            IF(RecordExists(RetrieveWebHareResource(trylib, [ allowmissing := TRUE ])))
              this->AddError(appnode, `Cannot find '${lib}' but it may be in the module:: namespace - dev:rewrite can fix this!)`);
            ELSE
              this->AddError(appnode, `Cannot find '${lib}'`);

            CONTINUE;
          }
          this->VerifyFunctionExistence(appnode, MakeAbsoluteResourcePath(this->respath, startmacro));
        }
      }

    FOREVERY(OBJECT wrdschema FROM this->xml->ListElements(whconstant_xmlns_moduledef,"schema"))
      IF(IsNodeApplicableToThisWebHare(wrdschema))
      {
        STRING deffile := MakeAbsoluteResourcePath(this->respath, wrdschema->GetAttribute("definitionfile"));
        IF(deffile != "" AND NOT RecordExists(RetrieveWebHareResource(deffile, [ allowmissing := TRUE ])))
          this->AddErrorForLine(wrdschema->linenum, `Cannot find '${deffile}'`);
      }

    FOREVERY(OBJECT webservice FROM this->xml->ListElements(whconstant_xmlns_moduledef, "webservice"))
      IF(IsNodeApplicableToThisWebHare(webservice))
      {
        STRING lib := MakeAbsoluteResourcePath(this->respath, webservice->GetAttribute("library"));
        IF(lib != "" AND NOT RecordExists(RetrieveWebHareResource(lib, [ allowmissing := TRUE ])))
        {
          IF(RecordExists(RetrieveWebHareResource("module::" || this->modulename || "/" || webservice->GetAttribute("library"), [ allowmissing := TRUE ])))
            this->AddError(webservice, `Cannot find '${lib}' but it may be in the module:: namespace - dev:rewrite can fix this!)`);
          ELSE
            this->AddError(webservice, `Cannot find '${lib}'`);
        }
      }

    FOREVERY(OBJECT webservice FROM this->xml->ListElements(whconstant_xmlns_moduledef, "ephemeraltask") CONCAT this->xml->ListElements(whconstant_xmlns_moduledef, "managedtask"))
      IF(IsNodeApplicableToThisWebHare(webservice))
      {
        IF(webservice->HasAttribute("library"))
        {
          STRING lib := MakeAbsoluteResourcePath(this->respath, webservice->GetAttribute("library"));
          IF(NOT RecordExists(RetrieveWebHareResource(lib, [ allowmissing := TRUE ])))
            IF(RecordExists(RetrieveWebHareResource("module::" || this->modulename || "/" || webservice->GetAttribute("library"), [ allowmissing := TRUE ])))
              this->AddError(webservice, `Cannot find '${lib}' but it may be in the module:: namespace - dev:rewrite can fix this!)`);
            ELSE
              this->AddError(webservice, `Cannot find '${lib}'`);
        }
      }

    FOREVERY(OBJECT legacywrdschemas FROM this->xml->ListElements("http://www.webhare.net/xmlns/wrd/schemadefinition", "wrdschemas"))
      this->AddError(legacywrdschemas, `<wrdschemas xmlns="http://www.webhare.net/xmlns/wrd/schemadefinition"> have been deprecated, drop the xmlns`);
  }
>;
