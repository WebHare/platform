<?wh

LOADLIB "wh::devsupport.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/validation/witty.whlib";

STRING FUNCTION GetNodeType(OBJECT node)
{
  IF(node->namespaceuri = whconstant_xmlns_screens AND node->localname IN ["tabsextension","screen","fragment"])
    RETURN node->localname;

  RETURN "";
}


/** Base objecttype for resource validators
*/
PUBLIC STATIC OBJECTTYPE XMLValidatorBase
<
  STRING lastlib;
  RECORD lastlibdescr;

  PUBLIC BOOLEAN syntaxlevel_2020;
  PUBLIC BOOLEAN syntaxlevel_next;
  PUBLIC BOOLEAN onlytids;

  PUBLIC OBJECT xml;
  PUBLIC STRING modulename;
  PUBLIC STRING respath;

  //TODO merge hint,warning,errors into one big list? but we'll need to remove the public errors/warnings/hints then
  PUBLIC RECORD ARRAY errors;
  PUBLIC RECORD ARRAY warnings;
  PUBLIC RECORD ARRAY hints;

  MACRO NEW(OBJECT xmldoc, STRING respath)
  {
    this->modulename := GetModuleNameFromResourcePath(respath);
    this->respath := respath;
    this->xml := xmldoc;
  }

  //Add a hint. informational message that will never turn into an error, but usually adds details to warnings and errors
  PUBLIC MACRO AddHint(OBJECT node, STRING error)
  {
    this->AddHintForLine(ObjectExists(node) ? node->linenum : 0, error);
  }
  PUBLIC MACRO AddHintForLine(INTEGER linenum, STRING error)
  {
    INSERT [ resourcename :=  this->respath
           , line :=      linenum
           , col :=       0
           , message :=   error
           ] INTO this->hints AT END;
  }
  PUBLIC MACRO AddHints(RECORD ARRAY hints)
  {
    this->hints := this->hints CONCAT hints;
  }
  //Add a warning. Depending on validation settings for a module these may turn into errors
  PUBLIC MACRO AddWarning(OBJECT node, STRING error, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->AddWarningForLine(ObjectExists(node) ? node->linenum : 0, error, options);
  }
  PUBLIC MACRO AddWarningForLine(INTEGER linenum, STRING error, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ failatsyntaxlevel := "" ], options);
    IF( (options.failatsyntaxlevel = "2020" AND this->syntaxlevel_2020)
        OR
        (options.failatsyntaxlevel = "next" AND this->syntaxlevel_next))
    {
      this->AddErrorForLine(linenum, error);
      RETURN;
    }

    INSERT [ resourcename :=  this->respath
           , line :=      linenum
           , col :=       0
           , message :=   error
           ] INTO this->warnings AT END;
  }
  PUBLIC MACRO AddWarnings(RECORD ARRAY warnings)
  {
    this->warnings := this->warnings CONCAT warnings;
  }
  //Add an error.
  PUBLIC MACRO AddError(OBJECT node, STRING error)
  {
    this->AddErrorForLine(ObjectExists(node) ? node->linenum : 0, error);
  }
  PUBLIC MACRO AddErrorForLine(INTEGER linenum, STRING error)
  {
    INSERT [ resourcename :=  this->respath
           , line :=      linenum
           , col :=       0
           , message :=   error
           ] INTO this->errors AT END;
  }
  PUBLIC MACRO AddErrors(RECORD ARRAY errors)
  {
    this->errors := this->errors CONCAT errors;
  }

  /// Our module name
  PUBLIC STRING FUNCTION GetModuleName()
  {
    RETURN GetModuleNameFromResourcePath(this->respath);
  }
  /// Are we working for a builtin module? (higher compliance requirements)
  PUBLIC BOOLEAN FUNCTION IsBuiltinModule()
  {
    RETURN this->GetModuleName() IN whconstant_builtinmodules;
  }
  /** @param node Node to get the path from
      @param attrname Attribute to read
      @param legacybasepath Alternative lookup path (often `MakeAbsoluteResourcePath(this->respath,"scripts/")`)
      @cell(boolean) options.warnversion Warn after this version if the file was found in the legacy path. We recommend
           choosing at least 3 minor versions above the current version. Set to 0 to disable warnings entirely, even for builtin modules (backports)
      @cell(boolean) options.allowwittytags Allow witty tags in the path (disables verification if they are found)
      @return Absolute path
  */
  PUBLIC STRING FUNCTION GetVerifyPath(OBJECT node, STRING attrname, STRING legacybasepath, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ warnversion := 0
                               , allowwittytags := FALSE
                               ], options);

    STRING path := node->GetAttribute(attrname);
    IF(path = "")
      RETURN "";

    STRING directpath := MakeAbsoluteResourcePath(this->respath, path);
    IF(options.allowwittytags AND path LIKE '*[*')
      RETURN directpath; //no further checking possible

    IF(RecordExists(RetrieveWebHareResource(directpath, [ allowmissing := TRUE ])))
      RETURN directpath;

    //Direct path not failed.
    IF(legacybasepath != "")
    {
      STRING legacypath := MakeAbsoluteResourcePath(legacybasepath, path);
      IF(RecordExists(RetrieveWebHareResource(legacypath, [ allowmissing := TRUE ])))
      {
        IF(options.warnversion > 0 AND (this->IsBuiltinModule() OR GetWebhareVersionNumber() >= options.warnversion)) //builtin modules need to set a good example, so ignore the version check
        {
          STRING realpath := Substring(legacypath, Length(MakeAbsoluteResourcePath(this->respath,"./")));
          this->AddWarning(node, `Attribute '${attrname}' required the use of an implicit path to find, please specify it as '${realpath}'`);
        }
        RETURN legacypath;
      }
    }
    this->AddError(node, `Unable to find '${path}'`);
    RETURN "";
  }

  RECORD FUNCTION GetLibDescription(STRING libname)
  {
    IF(this->lastlib != libname)
    {
      this->lastlib := libname;
      IF(libname != "")
      {
        this->lastlibdescr := DescribeCompiledLibrary(libname);
      }
      ELSE
      {
        this->lastlibdescr := DEFAULT RECORD;
      }
    }
    RETURN this->lastlibdescr;
  }

  BOOLEAN FUNCTION VerifyWittyComponentExistence(INTEGER linenum, STRING wittyref)
  {
    STRING message := VerifyWittyComponentExistence(this->respath, wittyref);
    IF(message != "")
    {
      this->AddErrorForLine(linenum, message);
      RETURN FALSE;
    }
    RETURN TRUE;
  }

  BOOLEAN FUNCTION VerifyObjectExistence(INTEGER linenum, STRING objtype)
  {
    STRING ARRAY objtoks := Tokenize(objtype,'#');
    RECORD lib := this->GetLibDescription(objtoks[0]);
    IF(NOT RecordExists(lib))
    {
      this->AddErrorForLine(linenum, `No such library '${objtoks[0]}' (looking for '${objtoks[1]}')`);
      RETURN FALSE;
    }
    IF(NOT RecordExists(SELECT FROM lib.functions WHERE name = ToUppercase(objtoks[1] || "#NEW")))
    {
      this->AddErrorForLine(linenum, `Object '${objtoks[1]}' not found in '${objtoks[0]}'`);
      RETURN FALSE;
    }

    RETURN TRUE;
  }

  //verify the existence of a reference to a screens file thingy
  OBJECT FUNCTION VerifyScreenReferenceExistence(INTEGER linenum, STRING screenref, STRING type)
  {
    STRING absscreenref := MakeAbsoluteScreenReference(this->respath, screenref);
    IF(absscreenref = "")
      RETURN DEFAULT OBJECT; //we are not a required check..

    STRING ARRAY reftoks := Tokenize(absscreenref,'#');
    IF(Length(reftoks) != 2)
      this->AddErrorForLine(linenum, `Invalid reference for '${type}' target '${screenref}': expecting <resource>#<name>`);

    TRY
    {
      RECORD target := RetrieveCachedXMLResource(reftoks[0]);

      //Look for things under the documentnode
      FOREVERY(OBJECT potentialtarget FROM target.doc->documentelement->ListChildren("*","*"))
       IF(potentialtarget->GetAttribute("name") = reftoks[1])
       {
         STRING matchtype := GetNodeType(potentialtarget);
         IF(matchtype = type)
         {
           RETURN potentialtarget; //Found it!
         }
         ELSE IF(matchtype != "")
         {
           this->AddErrorForLine(linenum, `Invalid reference for '${type}' target '${screenref}': '${reftoks[1]}' is a '${matchtype}', not a '${type}'`);
           RETURN DEFAULT OBJECT;
        }
       }
    }
    CATCH(OBJECT<RetrieveResourceException> e)
    {
      this->AddErrorForLine(linenum, `Can't find '${type}' target '${screenref}': ${e->what}`);
      RETURN DEFAULT OBJECT;
    }
    this->AddErrorForLine(linenum, `Can't find '${type}' target '${reftoks[1]}' in ${reftoks[0]}`);
    RETURN DEFAULT OBJECT;
  }

  /** Hook for additional resource validation for XML documents */
  PUBLIC MACRO ValidateDocument()
  {
  }
>;

