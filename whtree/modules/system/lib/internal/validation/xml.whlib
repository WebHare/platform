<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::xml/internal/xpath.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/localization.whlib";


LOADLIB "mod::system/lib/internal/dbase/parser.whlib";
LOADLIB "mod::system/lib/internal/validation/support.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::tollium/lib/internal/gettid.whlib";

RECORD ARRAY schemata;
RECORD ARRAY captured_tids;

MACRO OnTid(STRING resourcename, RECORD tiddata)
{
  tiddata := CELL [ resourcename, ...tiddata ];
  INSERT tiddata INTO captured_tids AT END;
}

PUBLIC RECORD ARRAY FUNCTION RunAndExtractTids(STRING resourcename, FUNCTION PTR tocall)
{
  RECORD ARRAY save_captured_tids := captured_tids;
  MACRO PTR save_capture := onparsedtid;
  TRY
  {
    captured_tids := RECORD[];
    onparsedtid := PTR OnTid(resourcename, #1);
    tocall();
    RETURN captured_tids;
  }
  FINALLY
  {
    captured_tids := save_captured_tids;
    onparsedtid := save_capture;
  }
}


RECORD ARRAY FUNCTION GetXMLValidators()
{
  OBJECT resolver := NEW IndependentXPathNSResolver;
  resolver->AddNS("m", "http://www.webhare.net/xmlns/system/moduledefinition");

  RECORD ARRAY xmlfiletypes;
  FOREVERY (STRING module FROM GetInstalledModuleNames())
  {
    OBJECT doc;
    TRY
      doc := GetModuleDefinitionXML(module);
    CATCH
      CONTINUE;
    IF(NOT ObjectExists(doc))
      CONTINUE;

    OBJECT ARRAY xmltypes := doc->GetEvaluatedElements(resolver, "/m:module/m:validation/m:xmlfiletype");
    FOREVERY (OBJECT node FROM xmltypes)
    {
      RECORD filetype := [ module :=         module
                         , rootnodes :=      ParseXSList(node->GetAttribute("rootnodes"))
                         , namespaceuri :=   node->GetAttribute("namespaceuri")
                         , schemalocation := MakeAbsoluteResourcePath("mod::"||module||"/", node->GetAttribute("schemalocation"))
                         , validator :=      MakeAbsoluteResourcePath("mod::"||module||"/", node->GetAttribute("validator"))
                         ];

      IF(filetype.validator = "" AND node->GetAttribute("objectname") != "")
        filetype.validator := MakeAbsoluteResourcePath("mod::"||module||"/", node->GetAttribute("library") || "#" || node->GetAttribute("objectname"));

      INSERT filetype INTO xmlfiletypes AT END;
    }
  }
  RETURN xmlfiletypes;
}

PUBLIC STATIC OBJECTTYPE LegacyTestInfoValidator EXTEND XMLValidatorBase
<
  UPDATE PUBLIC MACRO ValidateDocument()
  {
    this->AddError(this->xml->documentelement, `You should add xmlns="http://www.webhare.net/xmlns/system/testinfo" to the root node of the tests`);
  }
>;

PUBLIC STATIC OBJECTTYPE TestInfoValidator EXTEND XMLValidatorBase
<
  UPDATE PUBLIC MACRO ValidateDocument()
  {
    IF(this->onlytids)
      RETURN;

    RECORD ARRAY unreferred := SELECT *
                                 FROM ReadWebHareResourceFolder(GetDirectoryFromPath(this->respath))
                                WHERE name != GetNameFromPath(this->respath)
                                      AND name != "testdata"
                                      AND name != "data"
                            ORDER BY ToUppercase(name);

    FOREVERY(STRING toignore FROM ParseXSList(this->xml->documentelement->GetAttribute("ignoremasks")))
      DELETE FROM unreferred WHERE ToUppercase(name) LIKE ToUppercase(toignore);

    /* Quick and dirty filename gathering. It would be nicer if a real parser existed for testfiles, but runtest.whlib just
       enumerates nodes directly without parsing first (and we probably want to ignore Applicable anyway) */
    FOREVERY(OBJECT checknode FROM this->xml->GetElements("test[script]"))
      DELETE FROM unreferred WHERE name = checknode->GetAttribute("script");
    FOREVERY(OBJECT checknode FROM this->xml->GetElements("jstest[file],mochanodetest[file]"))
      DELETE FROM unreferred WHERE name = checknode->GetAttribute("file");

    FOREVERY(OBJECT checknode FROM this->xml->GetElements("test[path]"))
    {
      STRING strippath := checknode->GetAttribute("path");
      IF(strippath LIKE "?*/")
      {
        strippath := Left(strippath, Length(strippath)-1); //delete trailing slash
        DELETE FROM unreferred WHERE name = strippath;
      }
    }

    FOREVERY(RECORD entry FROM unreferred)
      this->AddError(this->xml->documentelement, `Directory entry '${entry.name}' not referred in tests and not on ignoremasks list`);
  }
>;

BOOLEAN FUNCTION CaptureOtherTids(STRING modulename, OBJECT moduledeffile)
{
  GetModuleDashboardInfo(modulename, moduledeffile);
  GetAppGroups(modulename, moduledeffile);
  GetWHFSRegisterSlots(modulename, moduledeffile);
  RETURN TRUE;
}

RECORD FUNCTION GetWebruleMessage(RECORD rule, STRING message)
{
  INTEGER lastcolon := SearchLastSubstring(rule.source,':');
  RETURN CELL[ line := ToInteger(Substring(rule.source, lastcolon+1), 0), col := 0, resourcename := Left(rule.source,lastcolon), message ];
}
RECORD FUNCTION ValidateWebRuleData(RECORD rule)
{
  RECORD retval := [ errors := RECORD[], warnings := RECORD[] ];
  FOREVERY(RECORD datastore FROM rule.datastorage)
  {
    IF(NOT datastore.isfolder
       AND IsAbsoluteResourcePath(datastore.resource)  //ignores __legacy and siteoutput:: paths
       AND datastore.resource NOT LIKE "*[*" //ignores [modulename]
       AND NOT RecordExists(RetrieveWebhareResource(datastore.resource, [ allowmissing := TRUE ])))
    {
      INSERT GetWebruleMessage(rule,`No such resource '${datastore.resource}'`) INTO retval.errors AT END;
    }
  }
  RETURN retval;
}

MACRO CheckModuleWebservices(OBJECT validatingdoc)
{
  FOREVERY(OBJECT servicenode FROM validatingdoc->xml->ListElements("http://www.webhare.net/xmlns/system/moduledefinition", "services"))
    FOREVERY(OBJECT webservice FROM servicenode->ListElements("http://www.webhare.net/xmlns/system/moduledefinition", "webservice"))
    {
      IF(webservice->GetAttribute("prefix") = "")
        validatingdoc->AddWarning(webservice, `A webservice should define a prefix= to prevent accidental exports (eg prefix="RPC_")`, [ failatsyntaxlevel := "2020"]);
    }

}

PUBLIC STATIC OBJECTTYPE ModuleDefinitionValidator EXTEND ModuleDefParser
<
  UPDATE PUBLIC MACRO ValidateDocument()
  {
    RECORD md := this->ParseAndValidate();

    ListModuleWebruleSets(this->modulename, this->xml); //parse <webruleset> titles
    ParseModuleDefRunonce(this);
    CheckModuleWebservices(this);

    ParseModuleDefinition(this->modulename, this->xml);
    CaptureOtherTids(this->modulename, this->xml);

    FOREVERY(OBJECT dbschema FROM this->xml->documentelement->GetChildElementsByTagNameNS(whconstant_xmlns_moduledef, "databaseschema")->GetCurrentElements())
    {
      RECORD parsed := ParseWHDBSchemaSpec(this->modulename, dbschema);
      FOREVERY (RECORD rec FROM parsed.msgs)
        IF (rec.iserror)
          this->AddErrorForLine(rec.line, rec.text);
        ELSE
          this->AddWarningForLine(rec.line, rec.text);
    }

    FOREVERY(RECORD task FROM md.tasks)
    {
      IF(task.runtz NOT IN ["","maintenance"] AND GetCanonicalTimeZoneID(task.runtz) = "")
        this->AddErrorForLine(task.line, `Invalid timezone '${task.runtz}'`);

      IF(task.runat != "")
      {
        TRY GetNextCronTime(GetCurrentDatetime(), task.runat);
        CATCH(OBJECT e) { this->AddErrorForLine(task.line, `Invalid runat '${task.runat}': '${e->what}`); }
      }
    }

    FOREVERY(OBJECT rulenode FROM this->xml->GetElements("webrule"))
    {
      //We don't currently have an easier way to parse rules..
      RECORD baserule := GetBaseWebRule(-9999999, rulenode->GetAttribute("path"), ParseWebRulePriority(rulenode->GetAttribute("priority")), this->respath || ":" || rulenode->linenum);
      RECORD parsed := ParseWebRuleData(this->modulename, baserule, rulenode, this->respath, [ forvalidation := TRUE ]);
      this->errors := this->errors CONCAT parsed.errors;
      this->warnings := this->warnings CONCAT parsed.warnings;
      IF (RecordExists(parsed.rule))
      {
        RECORD validateres := ValidateWebRuleData(parsed.rule);
        this->errors   := this->errors   CONCAT validateres.errors;
        this->warnings := this->warnings CONCAT validateres.warnings;
      }
    }

    IF(this->syntaxlevel_2020)
      FOREVERY(OBJECT appcontext FROM this->xml->ListElements(whconstant_xmlns_moduledef,"appcontexts"))
        this->AddError(appcontext, "<appcontexts> have been deprecated");
    IF(this->syntaxlevel_next)
    {
      FOREVERY(OBJECT legacywrdschemas FROM this->xml->ListElements("http://www.webhare.net/xmlns/wrd/schemadefinition", "wrdschemas"))
        this->AddError(legacywrdschemas, `<wrdschema xmlns="http://www.webhare.net/xmlns/wrd/schemadefinition"> have been deprecated, drop the xmlns`);
    }

  }
>;

PUBLIC RECORD FUNCTION DetermineXMLFileValidationType(OBJECT doc, STRING name)
{
  IF (LENGTH(schemata) = 0)
    schemata := GetXMLValidators();

  RETURN SELECT *
           FROM schemata
          WHERE doc->documentelement->namespaceuri = namespaceuri
                AND (doc->documentelement->localname ?? doc->documentelement->nodename) IN rootnodes;
}

PUBLIC RECORD FUNCTION RunXMLValidator(BLOB doc_blob, STRING resourcename, RECORD options)
{
  OBJECT doc := resourcename LIKE "*.xsd" ? MakeXMLSchema(doc_blob) : MakeXMLDocument(doc_blob);

  IF(Length(doc->GetParseErrors())>0)
  {
    RETURN [ errors := (SELECT message
                             , resourcename :=  COLUMN filename ?? VAR resourcename
                             , localname
                             , namespaceuri
                             , line
                             , col :=       0
                        FROM doc->GetParseErrors()) ];
  }

  RECORD srec := DetermineXMLFileValidationType(doc, resourcename);
  IF(NOT RecordExists(srec))
    RETURN DEFAULT RECORD; //can't validate anything else

  RECORD schemarec;
  RECORD ARRAY errors;
  STRING ARRAY eventmasks;
  IF(srec.schemalocation != "")
  {
    TRY
    {
      schemarec := __RetrieveCachedXMLSchema(srec.schemalocation);
      eventmasks := GetResourceEventMasks(SELECT AS STRING ARRAY path FROM schemarec.files);
    }
    CATCH(OBJECT e)
    {
      //Blame XSD issues on the document element
      INSERT [[ message := e->what, line := doc->documentelement->linenum, col := 0, resourcename := VAR resourcename ]] INTO errors AT END;
    }
  }

  OBJECT validator := srec.validator != "" ? MakeObject(srec.validator, doc, resourcename) : NEW XMLValidatorBase(doc, resourcename);
  IF(ObjectExists(validator) AND NOT validator EXTENDSFROM XMLValidatorBase)
    THROW NEW Exception(`Validator '${srec.validator}' must derive from XMLValidatorBase`);

  IF(RecordExists(schemarec))
  {
    errors := schemarec.doc->ValidateDocument(doc);
    IF(Length(errors)>0)
    {
      RETURN [ errors := SELECT message
                              , line
                              , col :=     0
                              , resourcename := resourcename
                           FROM SimplifyXMLValidationErrors(errors, doc->documentelement)
             ];
    }
  }

  validator->onlytids := options.onlytids;
  validator->syntaxlevel_2020 := options.syntaxlevel IN ["2020","next"];
  validator->syntaxlevel_next := options.syntaxlevel = "next";

  RECORD ARRAY tids := RunAndExtractTids(resourcename, PTR validator->ValidateDocument());
  tids := SELECT DISTINCT resourcename := VAR resourcename, line, col, attrname, tid FROM tids ORDER BY line, col;
  RETURN CELL[ errors := validator->errors
             , warnings := validator->warnings
             , hints := validator->hints
             , tids
             , eventmasks
             ];
}

PUBLIC STATIC OBJECTTYPE TopicValidator EXTEND XMLValidatorBase
<
  UPDATE PUBLIC MACRO ValidateDocument()
  {
    IF(this->onlytids)
      RETURN;

    STRING ARRAY docorder := ParseXSList(this->xml->documentelement->GetAttribute("docorder"));

    RECORD ARRAY realdocs :=
        SELECT name
             , basename :=      GetBasenameFromPath(name)
          FROM ReadWebHareResourceFolder(Left(this->respath, SearchLastSubString(this->respath, "/")))
         WHERE name LIKE "*.md"
           AND name != "intro.md";

    STRING ARRAY missing := GetSortedSet(ArrayDelete(docorder, SELECT AS STRING ARRAY basename FROM realdocs));
    STRING ARRAY notordered := SELECT AS STRING ARRAY DISTINCT basename FROM realdocs WHERE basename NOT IN docorder ORDER BY name;

    IF (LENGTH(missing) != 0)
      this->AddError(this->xml->documentelement, `The following documents mentioned in docorder could not be found: ${Detokenize(missing, ", ")}`);
    IF (LENGTH(notordered) != 0)
      this->AddError(this->xml->documentelement, `The following documents are not mentioned in docorder: ${Detokenize(notordered, ", ")}`);
  }
>;
