<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::wrd/lib/internal/dbschema.whlib";
LOADLIB "mod::wrd/lib/api.whlib";

MACRO AddAuthObjects(RECORD ARRAY syncables)
{
  DATETIME now := GetCurrentDateTime();
  FOREVERY (RECORD rec FROM syncables)
  {
    INSERT INTO system_internal.authobjects(id, type, name, guid, creationdate, parent)
      VALUES (rec.id, rec.type, rec.want.name, rec.guid, now, rec.want.parent);
  }
}

RECORD ARRAY FUNCTION GetDBObjectsForAuthobjects(RECORD ARRAY syncables)
{
  RECORD ARRAY output;
  FOREVERY(RECORD syncable FROM syncables)
    output := output CONCAT GetSomeDBObjects(syncable.guid);
  RETURN SELECT * FROM output ORDER BY guid;
}

RECORD ARRAY FUNCTION GetSomeDBObjects(STRING whichguid)
{
  RETURN SELECT id
           , parent
           , guid
           , name
           , deletiondate
           , type
           , action :=  "delete"
        FROM system_internal.authobjects
       WHERE (whichguid = "" ? TRUE : guid = whichguid)
         AND type IN [ 1, 2, 3 ]
         AND guid NOT LIKE "<*>"
    ORDER BY guid;
}

RECORD ARRAY FUNCTION GetAllDBObjects()
{
  RETURN GetSomeDBObjects("");
}

RECORD FUNCTION EnrichAuthObjectsWithDBObjects(RECORD ARRAY allwantauthobjs, RECORD ARRAY dbobjects)
{
  // Keep sorted on wrd_id
  allwantauthobjs :=
      SELECT id :=           0
           , parent := 0
           , *
           , name := name ?? guid
        FROM allwantauthobjs
    ORDER BY wrd_id;

  // Add missing authobjects to the list of dbobjects (and calc their ids, so we can lookup parent for new units)
  FOREVERY (RECORD rec FROM allwantauthobjs)
  {
    RECORD pos := RecordLowerBound(dbobjects, rec, [ "GUID" ]);
    IF (NOT pos.found)
    {
      allwantauthobjs[#rec].id := MakeAutoNumber(system_internal.authobjects, "ID");
      INSERT
          [ id :=           allwantauthobjs[#rec].id
          , type :=         rec.type
          , name :=         rec.name
          , guid :=         rec.guid
          , parent :=       0
          , action :=       "insert"
          ] INTO dbobjects AT pos.position;
    }
    ELSE
    {
      allwantauthobjs[#rec].id := dbobjects[pos.position].id;
    }
  }

  // Lookup the parent ids for all the objects we want to be in the system authobjects
  FOREVERY (RECORD rec FROM allwantauthobjs)
  {
    IF (rec.parentwrdid = 0) //that's okay, we already inited the allwantauthobj to '0'
      CONTINUE;

    RECORD pos := RecordLowerBound(allwantauthobjs, [ wrd_id := rec.parentwrdid ], [ "WRD_ID" ]);
    IF (NOT pos.found)
      THROW NEW Exception(`Cannot find expected parent wrd#${rec.parentwrdid} for object wrd#${rec.wrd_id} (${rec.name}) in allwantauthobjs`);

    allwantauthobjs[#rec].parent := allwantauthobjs[pos.position].id;
  }

  RETURN [ allwantauthobjs := allwantauthobjs, dbobjects := dbobjects ];
}

RECORD ARRAY FUNCTION CheckDBObjectsAgainstAuthObjects(RECORD ARRAY dbobjects, RECORD ARRAY allwantauthobjs)
{
  FOREVERY (RECORD rec FROM allwantauthobjs)
  {
    RECORD pos := RecordLowerBound(dbobjects, rec, [ "GUID" ]);
    RECORD dbrec := dbobjects[pos.position];

    IF (dbrec.action = "delete") //existing dbobjects are always set to 'delete', here is where we decide to preserve them (if they are still wanted)
    {
      IF (dbrec.name != rec.name OR dbrec.parent != rec.parent OR dbrec.deletiondate != DEFAULT DATETIME)
      {
        //TODO shouldn't we clear the name in authobjects if the user should be deleted?
        dbobjects[pos.position].action := "update"; //we need to update it
      }
      ELSE
      {
        dbobjects[pos.position].action := "nothing"; //mark it as do-nothing
        CONTINUE; //and no new data to write
      }
    }
    IF (NOT CellExists(dbobjects[pos.position], "WANT"))
      INSERT CELL want := rec INTO dbobjects[pos.position]; //add the wanted data for update & insert
  }

  FOREVERY(RECORD dbrec FROM dbobjects)
    IF(dbrec.action = "delete" AND dbrec.type = 1 AND dbrec.deletiondate != DEFAULT DATETIME) //a user still marked for deletion, so we didn't want him
      dbobjects[#dbrec].action := "nothing";

  RETURN dbobjects;
}

PUBLIC RECORD ARRAY FUNCTION ApplyDBWantedAuthObjects(RECORD ARRAY allwantauthobjs, BOOLEAN fullsync)
{
  // Get the current system authobjects
  RECORD ARRAY dbobjects := fullsync ? GetAllDBObjects() : GetDBObjectsForAuthobjects(allwantauthobjs);

  // Add missing authobjects to the list of dbobjects (and calc their ids, so we can lookup parent for new units)
  RECORD res := EnrichAuthObjectsWithDBObjects(allwantauthobjs, dbobjects);
  allwantauthobjs := res.allwantauthobjs;
  dbobjects := res.dbobjects;

  // Check all system authobjects if they still match with the WRD data
  dbobjects := CheckDBObjectsAgainstAuthObjects(dbobjects, allwantauthobjs);

  // Remove all objects that are ok
  DELETE FROM dbobjects WHERE action = "nothing";

// Insert all new records first
  AddAuthObjects(SELECT * FROM dbobjects WHERE action = "insert");

  // Do modifications, including changing parent
  FOREVERY (RECORD rec FROM SELECT * FROM dbobjects WHERE action = "update")
  {
    UPDATE system_internal.authobjects
       SET parent :=      rec.want.parent
         , name :=        rec.want.name
         , deletiondate := DEFAULT DATETIME
     WHERE id = rec.id;
  }

  // Delete units and roles that have been deleted
  // ADDME When to delete a user? Since they can still be referred externally, when is it safe to delete? (ie modifiedby)
  INTEGER ARRAY tokill := SELECT AS INTEGER ARRAY id FROM dbobjects WHERE action="delete" AND type != 1; //select all roles (3) and units (2)
  UPDATE system_internal.authobjects SET parent := 0 WHERE parent IN tokill; //move their children to the root unit
  DELETE FROM system_internal.authobjects WHERE id IN tokill;

  INTEGER ARRAY toclose := SELECT AS INTEGER ARRAY id FROM dbobjects WHERE action="delete" AND deletiondate = DEFAULT DATETIME AND type = 1;
  UPDATE system_internal.authobjects SET deletiondate := GetCurrentDatetime()
                            WHERE id IN toclose;

  GetPrimary()->BroadcastOnCommit("system:rights.change", DEFAULT RECORD);
  RETURN dbobjects;
}

//Get the unit structure as desired
PUBLIC RECORD ARRAY FUNCTION GetSyncableUnits(OBJECT wrdunittype, INTEGER ARRAY limitunits)
{
  RECORD ARRAY wrd_units := wrdunittype->RunQuery([ outputcolumns := [ "WRD_ID", "WRD_GUID", "WRD_TITLE", "WRD_LEFTENTITY", "WRD_CREATIONDATE" ]
                                                  , historymode := "all"
                                                  ]);

  RECORD legacy_whmodules := SELECT * FROM wrd_units WHERE wrd_title = "__whmodules__";
  IF(RecordExists(legacy_whmodules))
  {
    wrdunittype->DeleteEntity(legacy_whmodules.wrd_id); //there's no need to have this one anymore
    DELETE FROM wrd_units WHERE wrd_title = "__whmodules__";
  }

  // Construct the system authobject records as we want them to be (only types 1, 2, 3)
  RECORD ARRAY wantauthobjs :=
      SELECT wrd_id
           , parentwrdid :=   wrd_leftentity
           , guid :=          wrd_guid
           , name :=          wrd_title
           , type :=          2
        FROM wrd_units;
  RETURN wantauthobjs;
}

//Get the user structure as desired
PUBLIC RECORD ARRAY FUNCTION GetSyncableUsers(OBJECT wrdusertype, INTEGER ARRAY limitusers)
{
  RECORD ARRAY users := wrdusertype->RunQuery(
        [ outputcolumns := [ wrd_id := "WRD_ID"
                           , wrd_guid := "WRD_GUID"
                           , wrd_title := "WRD_TITLE"
                           , whuser_unit := "WHUSER_UNIT"
                           , wrd_creationdate := "WRD_CREATIONDATE"
                           , loginname := wrdusertype->wrdschema->accountlogintag
                           , email := wrdusertype->wrdschema->accountemailtag
                           ]
        , historymode := "all"
        , filters := Length(limitusers)>0 ? [[ field := "WRD_ID", matchtype := "IN", value := limitusers ]]
                                          : DEFAULT RECORD ARRAY
        ]);
  RETURN SELECT wrd_id
             , parentwrdid :=   whuser_unit
             , guid :=          wrd_guid
             , name :=          loginname
             , type :=          1
             , realname :=      wrd_title
             , email :=         email
          FROM users;
}

//Get the role structures as desired
PUBLIC RECORD ARRAY FUNCTION GetSyncableRoles(OBJECT wrdroletype, INTEGER ARRAY limitroles)
{
  RECORD ARRAY roles := wrdroletype->RunQuery(
        [ outputcolumns := [ "WRD_ID", "WRD_GUID", "WRD_TITLE", "WRD_LEFTENTITY", "WRD_CREATIONDATE" ]
        , filters := Length(limitroles)>0 ? [[ field := "WRD_ID", matchtype := "IN", value := limitroles ]]
                                          : DEFAULT RECORD ARRAY
        ]);

  RETURN SELECT wrd_id
             , parentwrdid :=   wrd_leftentity
             , guid :=          wrd_guid
             , name :=          wrd_title
             , type :=          3
          FROM roles;
}
PUBLIC RECORD ARRAY FUNCTION ResyncAllToSystemTables()
{
  RECORD ARRAY syncschemas := SELECT id
                                   , name
                                FROM wrd.schemas
                               WHERE usermgmt
                            ORDER BY id; //ensure consistent ordering

  RECORD ARRAY allwantauthobjs;
  FOREVERY(RECORD syncschema FROM syncschemas)
  {
    TRY
    {
      OBJECT wrdschema := OpenWRDSchemaById(syncschema.id);
      IF(NOT ObjectExists(wrdschema)) //deleted?
        CONTINUE;

      OBJECT wrdunit := wrdschema->GetType("WHUSER_UNIT");
      OBJECT wrdrole := wrdschema->GetType("WHUSER_ROLE");
      OBJECT wrduser := wrdschema->accounttype;
      IF(NOT ObjectExists(wrdunit) OR NOT ObjectExists(wrdrole) OR NOT ObjectExists(wrduser))
        CONTINUE;
      allwantauthobjs := allwantauthobjs CONCAT GetSyncableUnits(wrdunit, DEFAULT INTEGER ARRAY) CONCAT GetSyncableRoles(wrdrole, DEFAULT INTEGER ARRAY) CONCAT GetSyncableUsers(wrduser, DEFAULT INTEGER ARRAY);
    }
    CATCH(OBJECT e)
    {
      Print("Failed to synchronize schema " || syncschema.name || ": " || e->What ||"\n");
    }
  }

  RETURN ApplyDBWantedAuthObjects(allwantauthobjs, TRUE);

  //PRINT("Sync result\n" || AnyToString((SELECT parent, name, id, guid FROM system_internal.authobjects WHERE type <= 3 ORDER BY parent, name), "boxed"));
  //PRINT(AnyToString((select a.* from system_internal.authobjects as a, system_internal.authobjects as b WHERE a.parent = b.parent And a.name = b.name and a.id != b.id), "boxed"));
}


PUBLIC RECORD ARRAY FUNCTION FixUnconnectedItems(OBJECT usermgmtschema)
{
  RECORD ARRAY fixed;
//Make sure all units, roles and users are in existing units
  INTEGER ARRAY liveunits := SortArray(usermgmtschema->^whuser_unit->RunQuery([ outputcolumn := "WRD_ID" ]));
  INTEGER lostandfoundunit;

  FOREVERY(RECORD checktype FROM [[ type := usermgmtschema->^wrd_person,  unitfield := "WHUSER_UNIT", allownull := FALSE ]
                                 ,[ type := usermgmtschema->^whuser_role, unitfield := "WRD_LEFTENTITY", allownull := FALSE ]
                                 ,[ type := usermgmtschema->^whuser_unit, unitfield := "WRD_LEFTENTITY", allownull := TRUE ]
                                 ])
  {
    RECORD ARRAY fixlist := checktype.type->RunQuery([ outputcolumns := CELL[ "WRD_ID", unit := checktype.unitfield ]]);
    IF(checktype.allownull)
      DELETE FROM fixlist WHERE unit = 0;
    DELETE FROM fixlist WHERE unit != 0 AND BinaryFind(liveunits, unit) != -1;

    IF(Length(fixlist) = 0)
      CONTINUE; //it's okay

    IF(lostandfoundunit = 0)
      lostandfoundunit := usermgmtschema->^whuser_unit->Search("WRD_TAG", "WH_LOSTANDFOUND");
    IF(lostandfoundunit = 0)
      lostandfoundunit := usermgmtschema->^whuser_unit->CreateEntity( [ wrd_tag := "WH_LOSTANDFOUND", wrd_title := "Lost & found" ])->id;

    FOREVERY(RECORD tofix FROM fixlist)
      checktype.type->UpdateEntity(tofix.wrd_id, CellInsert(CELL[], checktype.unitfield, lostandfoundunit));

    fixed := fixed CONCAT SELECT *, type := checktype.type->tag FROM fixlist;
  }
  RETURN fixed;
}
