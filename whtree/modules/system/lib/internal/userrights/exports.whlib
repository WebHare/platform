<?wh
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/rightsmgmt.whlib";
LOADLIB "mod::system/lib/internal/backend/users.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/screens/userrights/support.whlib";
LOADLIB "mod::system/lib/internal/rightsmgmt.whlib";
LOADLIB "mod::system/lib/internal/rightsinfo.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

RECORD FUNCTION GetAuthObjectById(RECORD ARRAY allobjs, INTEGER authobjectid)
{
  RECORD authobjectpos := RecordLowerBound(allobjs, [ id := authobjectid ], ["ID"]);
  IF(NOT authobjectpos.found)
    RETURN DEFAULT RECORD;
  RETURN allobjs[authobjectpos.position];
}

RECORD FUNCTION GetGrantee(RECORD ARRAY allusers, RECORD ARRAY allroles, RECORD ARRAY allobjs, INTEGER authobjectid)
{
  RECORD authobject := GetAuthObjectById(allobjs, authobjectid);
  IF(NOT RecordExists(authobject))
    RETURN DEFAULT RECORD;

  RECORD userobjpos := RecordLowerBound(allusers, [ guid := authobject.guid ], [ "GUID" ]);
  IF(userobjpos.found)
  {
    RECORD userrec := allusers[userobjpos.position];
    RETURN CELL[ login := authobject.name
               , userrec.active
               , userrec.fullname
               , userrec.email
               , authobject.unitid
               , authobject.unitname
               ];
  }

  RECORD roleobjpos := RecordLowerBound(allroles, [ wrd_guid := authobject.guid ], [ "WRD_GUID" ]);
  IF(roleobjpos.found)
  {
    RECORD rolerec := allroles[roleobjpos.position];
    RETURN CELL[ login := rolerec.wrd_title
               , active := TRUE
               , fullname := ""
               , email := ""
               , authobject.unitid
               , authobject.unitname
               ];
  }

  RETURN DEFAULT RECORD;
}

STRING FUNCTION GetGrantor(RECORD ARRAY allobjs, RECORD grant, RECORD grantordata)
{
  RECORD grantorrec;
  IF(grant.grantor = grant.grantee) //self grant!
    RETURN ""; //dont report a user with these, we want them to stand out

  IF(grant.grantor != 0 AND grant.grantor != grant.grantee)
  {
    grantorrec := GetAuthObjectById(allobjs, grant.grantor);
    IF(RecordExists(grantorrec))
      RETURN grantorrec.name ?? grantorrec.guid;
  }

  //TODO present data from grantordata, but need testcases
  RETURN "#" || grant.grantor;
}

PUBLIC RECORD ARRAY FUNCTION EnrichWithGrantorAndGrantee(OBJECT userapi, RECORD ARRAY rightslist)
{
  RECORD ARRAY allusers :=
      SELECT *
           , active :=    whuser_disable_type = ""
           , DELETE whuser_disable_type
        FROM userapi->accounttype->RunQuery(
                  [ outputcolumns :=
                        [ id :=         "WRD_ID"
                        , fullname :=   "WRD_TITLE"
                        , login :=      userapi->wrdschema->accountlogintag
                        , email :=      userapi->wrdschema->accountemailtag
                        , guid  :=      "WRD_GUID"
                        , whuser_disable_type := "WHUSER_DISABLE_TYPE"
                        ]
                  ]) AS row
    ORDER BY guid;

  RECORD ARRAY allroles :=
      SELECT *
           , active :=    TRUE
        FROM userapi->wrdschema->^whuser_role->RunQuery(
            [ outputcolumns := CELL[ "WRD_GUID", "WRD_TITLE" ]
            ])
    ORDER BY wrd_guid;

  RECORD ARRAY allobjs := SELECT authobjects.id
                               , authobjects.name
                               , authobjects.guid
                               , unitid := units.id
                               , unitname := units.name
                            FROM system.authobjects, system.authobjects as units
                           WHERE units.id = authobjects.parent
                        ORDER BY authobjects.id;

  RECORD ARRAY finallist;
  FOREVERY(RECORD grant FROM rightslist)
  {
    RECORD granteerec := GetGrantee(allusers, allroles, allobjs, grant.grantee);
    IF(NOT RecordExists(granteerec))
      CONTINUE;

    STRING grantor := GetGrantor(allobjs, grant, grant.grantordata);

    INSERT CELL[...grant, ...granteerec, grantor ] INTO finallist AT END;
  }

  RETURN finallist;
}

//NOTE: userapi should now only be enabled for schemas depending on usermgmt
PUBLIC RECORD ARRAY FUNCTION ListRightsAndRolesForExport(OBJECT userapi)
{
  RECORD ARRAY allroleobjs := SELECT authobjects.id
                                   , authobjects.name
                                   , authobjects.guid
                                   , unitid := units.id
                                   , unitname := units.name
                                FROM system.authobjects, system.authobjects as units
                               WHERE units.id = authobjects.parent
                                     AND authobjects.type = 3 //user role
                            ORDER BY authobjects.id;

  RECORD ARRAY allrights := GetListOfRights();
  GetPrimary()->BeginWork();
  OBJECT user := EnsureCreatedMagicSysop("<overrideuser>");
  GetPrimary()->CommitWork();

  RECORD ARRAY allrows;

  //Gather the rights
  FOREVERY(RECORD r FROM allrights)
  {
    RECORD ARRAY grants := GetDirectGrantsForRight(r.rightname);
    FOREVERY(RECORD grant FROM grants)
    {
      STRING objecttypename;
      INTEGER objectid;
      STRING ARRAY objectpath;

      IF(NOT r.isglobal)
      {
        RECORD pathrec := user->GetObjectPath(r.objecttypename, grant."object");
        IF (NOT RecordExists(pathrec) OR NOT pathrec.visible)
          CONTINUE;

        objecttypename := r.objecttypename;
        objectid := grant."object";
        objectpath := SELECT AS STRING ARRAY name FROM pathrec.path WHERE id != 0;
      }

      INSERT CELL[ ...grant
                 , type := "GRANT"
                 , r.rightname
                 , objecttypename
                 , objectid
                 , objectpath
                 ] INTO allrows AT END;
    }
  }

  //Gather the role grants
  RECORD ARRAY rolegrants := SELECT * FROM system.rolegrants;
  rolegrants := userapi->EnrichRoles("role", rolegrants, [ celltype := "authobjectid" ]); //enrich to kick out roles that don't exist in our userapi view
  rolegrants := SELECT *, grantordata := grantordata != "" ? DecodeHSON(grantordata) : DEFAULT RECORD FROM rolegrants;

  FOREVERY(RECORD grant FROM rolegrants)
  {
    RECORD roleinfo := GetAuthObjectById(allroleobjs, grant.role);
    IF(NOT RecordExists(roleinfo))
      CONTINUE;

    INSERT CELL[ ...grant
               , type := "ROLEGRANT"
               , rightname := ""
               , withgrantoption := FALSE
               , objecttypename := "role"
               , objectid := roleinfo.id
               //FIXME show full role path
               , objectpath := STRING[roleinfo.name]
               ] INTO allrows AT END;
  }

  allrows := EnrichWithGrantorAndGrantee(userapi, allrows);

  RETURN allrows;
}


INTEGER ARRAY FUNCTION GetAuthobjectsWithWebHareRole(INTEGER roleid)
{
  RETURN SELECT AS INTEGER ARRAY authobjects.id
           FROM system.rolegrants
              , system.authobjects
          WHERE rolegrants.grantee = authobjects.id
            AND rolegrants.role = roleid;
}

STATIC OBJECTTYPE ObjectTreeRightsExport
< // ---------------------------------------------------------------------------
  //
  // Variables
  //
  OBJECT userapi;

  OBJECT tolliumuser;

  OBJECT rightsinfo;

  STRING objecttypename;

  INTEGER objectid;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO NEW(OBJECT contexts, STRING objecttypename, INTEGER objectid)
  {
    this->userapi := contexts->userapi;
    this->tolliumuser := contexts->user;
    this->rightsinfo := GetRightsInfoObject(contexts->user);

    this->objecttypename := objecttypename;
    this->objectid := objectid;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING FUNCTION GetObjectPath(INTEGER objectid)
  {
    RECORD pathrec := GetPresentationRightsObjectPath(this->objecttypename, objectid, this->tolliumuser->authobject);
    IF (NOT RecordExists(pathrec) OR NOT pathrec.visible)
      RETURN "";

    RECORD ARRAY path := pathrec.path;
    IF (this->objectid != 0)
    {
      WHILE (LENGTH(path) != 0 AND path[0].id != this->objectid)
        DELETE FROM path AT 0;

      // Hide?
      IF (LENGTH(path) = 0)
        RETURN "";
    }
    RETURN "/" || Detokenize((SELECT AS STRING ARRAY name FROM path WHERE id != 0), "/");
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC RECORD ARRAY FUNCTION GenerateExport()
  {
    RECORD ARRAY rights :=
        SELECT *
          FROM this->rightsinfo->rights
         WHERE objecttypename = this->objecttypename;

    STRING ARRAY rightnames := SELECT AS STRING ARRAY name FROM rights;

    RECORD ARRAY grants;
    FOREVERY (RECORD right FROM rights)
    {
      grants := grants CONCAT
          SELECT grantee
               , objectid :=      COLUMN "object"
               , withgrantoption
               , rightname :=     right.name
               , righttitle :=    right.title
            FROM GetDirectGrantsForRight(right.name);
    }
    // Resolve all paths
    RECORD ARRAY paths :=
        SELECT objectid
             , path :=      this->GetObjectPath(objectid)
          FROM grants
      GROUP BY objectid
      ORDER BY objectid;
    // Delete the ones that are invisible
    DELETE FROM paths WHERE path = "";

    // Add the paths, filter out the invisible ones
    {
      RECORD ARRAY newgrants;
      FOREVERY (RECORD rec FROM grants)
      {
        RECORD pos := RecordLowerBound(paths, rec, [ "OBJECTID" ]);
        IF (pos.found)
        {
          INSERT CELL path := paths[pos.position].path INTO rec;
          INSERT rec INTO newgrants AT END;
        }
      }

      grants := newgrants;
    }

    INTEGER ARRAY all_grantees :=
        SELECT AS INTEGER ARRAY DISTINCT grantee
          FROM grants;

    RECORD ARRAY all_role_grantees :=
        SELECT id
          FROM system.authobjects
         WHERE id IN all_grantees
           AND type = 3;

    IF(Length(all_role_grantees) > 0)
    {
      INTEGER ARRAY visible_role_grantees := this->tolliumuser->HasRightOnMultiple("system:browseunits", SELECT AS INTEGER ARRAY id FROM all_role_grantees);
      DELETE FROM all_role_grantees WHERE id NOT IN visible_role_grantees;

      IF(Length(all_role_grantees) > 0) //still present
        all_role_grantees := this->userapi->EnrichRoles("ID", all_role_grantees, [ celltype := "authobjectid" ]);
    }

    INTEGER ARRAY all_user_grantees :=
        SELECT AS INTEGER ARRAY id
          FROM system.authobjects
         WHERE id IN all_grantees
           AND type = 1;

    RECORD ARRAY rows :=
        SELECT rowkey :=  "user-" || grantee || "-" || objectid || "-" || rightname
             , type :=    "user"
             , *
             , viarole := ""
          FROM grants
         WHERE grantee IN all_user_grantees;

    FOREVERY (RECORD rec FROM grants)
    {
      RECORD matchrole := SELECT * FROM all_role_grantees WHERE id = rec.grantee;
      IF (RecordExists(matchrole))
      {
        FOREVERY (INTEGER rolegrantee FROM GetAuthobjectsWithWebHareRole(rec.grantee))
          INSERT
              [ rowkey :=           "role-" || rec.grantee || "-" || rolegrantee || "-" || rec.objectid || "-" || rec.rightname
              , type :=             "role"
              , grantee :=          rolegrantee
              , objectid :=         rec.objectid
              , path :=             rec.path
              , withgrantoption :=  rec.withgrantoption
              , rightname :=        rec.rightname
              , righttitle :=       rec.righttitle
              , viarole :=          GetQualifiedAuthObjectName(rec.grantee) //TODO can't we use the names gathered in 'EnrichRoles' ?
              ] INTO rows AT END;
      }
    }


    {
      RECORD ARRAY newrows;
      INTEGER ARRAY userids := SELECT AS INTEGER ARRAY DISTINCT grantee FROM rows;

      RECORD ARRAY users :=
          SELECT id
               , type
               , unit :=      parent
               , login :=     name
               , authobjectparentid := parent
            FROM system.authobjects
           WHERE id IN userids
             AND type = 1
             AND this->tolliumuser->HasRightOn("system:browseunits", id);

      users := this->tolliumuser->authapi->EnrichUsers("userid", (SELECT id, type, unit, authobjectparentid, userid := id FROM users), [ celltype := "authobjectid" ] );
      users := EnrichWithUnitPath(users, this->tolliumuser);
      users := SELECT * FROM users ORDER BY id;

      FOREVERY (RECORD rec FROM rows)
      {
        RECORD pos := RecordLowerBound(users, [ id := rec.grantee ], [ "ID" ]);
        IF (pos.found)
        {
          INSERT CELL login := users[pos.position].unitpath || "/" || users[pos.position].login INTO rec;
          INSERT CELL fullname := users[pos.position].fullname INTO rec;
          INSERT rec INTO newrows AT END;
        }
      }

      rows := newrows;
    }

    RETURN
        SELECT login
             , fullname
             , right :=       righttitle
             , path
             , direct :=      type = "user" ? 1 : 2
             , viarole
          FROM rows
         WHERE this->objectid = 0 ? TRUE : path != ""
      ORDER BY login, path;
  }

  PUBLIC RECORD FUNCTION GetList()
  {
    RETURN CELL
      [ rows := this->GenerateExport()
      , columns :=  [ [ name := "path",     type := "text", title := GetTid("system:tolliumapps.userrights.common.objectpath") ]
                    , [ name := "login",    type := "text", title := GetTid("~username") ]
                    , [ name := "fullname", type := "text", title := GetTid("~fullname") ]
                    , [ name := "right",    type := "text", title := GetTid("system:tolliumapps.userrights.common.right") ]
                    , [ name := "viarole",  type := "text", title := GetTid("system:tolliumapps.userrights.common.viarole") ]
                    ]
      , exporttitle := GetTid("system:userrights.exports.exportobjectrights")
      ];
  }
>;


PUBLIC RECORD FUNCTION GetObjectTreeRightsExport(OBJECT contexts, STRING objecttypename, INTEGER objectid)
{
  OBJECT exporter := NEW ObjectTreeRightsExport(contexts, objecttypename, objectid);
  RETURN exporter->GetList();
}
