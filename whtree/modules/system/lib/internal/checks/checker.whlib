<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::dbase/postgresql.whlib";
LOADLIB "wh::internal/debug.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/internal/checks.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/userrights.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/internal/checks/webserver.whlib";
LOADLIB "mod::system/lib/internal/modules/node.whlib";
LOADLIB "mod::system/lib/internal/userrights/rightsparser.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/api.whlib";

RECORD FUNCTION GetGitRepoInfo(STRING repo, BOOLEAN query_remote) __ATTRIBUTES__(EXTERNAL "wh_git");

PUBLIC RECORD FUNCTION GetWHVersionInfo()
{
  RECORD versioninfo := GetWebhareVersionInfo();
  BOOLEAN developerbuild;
  IF(versioninfo.committag = "")
  {
    developerbuild := TRUE;
    RECORD info := GetGitRepoInfo(ResolveToAbsolutePath(GetModuleInstallationRoot("system") || "../../.."), FALSE);
    IF(RecordExists(info) AND info.status != "error")
    {
      versioninfo.branch := `${info.remote_url}:${info.branch}`;
      versioninfo.committag := info.head_oid;
    }
    ELSE
    {
      versioninfo.committag := "unknown";
    }
  }

  STRING versionname := `WebHare ${versioninfo.version} (`;
  IF(versioninfo.branch != "" AND versioninfo.branch NOT LIKE "release/*")
    versionname := versionname || versioninfo.branch || "@";
  versionname := versionname || Left(versioninfo.committag,7) || ")";

  RETURN CELL [ versionname
              , built := TrimWhitespace(`${versioninfo.builddate} ${versioninfo.buildtime}`)
              ];
}

RECORD ARRAY FUNCTION RunDevelopmentChecks()
{
  RECORD ARRAY node_issues := SELECT msg := `:Node module issue in WebHare Platform: ${error}`
                                FROM CheckNodeModulesInModule(GetWebhareConfiguration().installationroot);
  FOREVERY (STRING module FROM __SYSTEM_GetInstalledModuleNames())
  {
    STRING path := GetModuleInstallationRoot(module);
    node_issues := node_issues CONCAT SELECT msg := `:Node module issue in ${module}: ${error}`
                                        FROM CheckNodeModulesInModule(path);
  }
  RETURN node_issues;
}

ASYNC FUNCTION RunAsyncChecks()
{
  OBJECT publishercheckpromise := GetPersistentQueueStatus("publisher:publication", 15000);
  OBJECT outputanalyzercheckpromise := GetPersistentQueueStatus("publisher:outputanalyzer", 15000);

  RETURN AWAIT publishercheckpromise CONCAT AWAIT outputanalyzercheckpromise;

}

RECORD ARRAY FUNCTION GetHotFixCheckResult()
{
  RECORD ARRAY messages;

  STRING hotfixfile := GetWebHareConfiguration().ephemeralroot || "hotfixstate.json";
  RECORD data := DecodeJSONBlob(GetDiskResource(hotfixfile, [ allowmissing := TRUE ]));
  IF (RecordExists(data))
  {
    FOREVERY (RECORD module FROM RECORD ARRAY(data.modules))
    {
      FOREVERY (STRING msg FROM STRING ARRAY(module.messages))
        INSERT CELL
            [ msg
            , jumpto := [ app := "system:dashboard", panel := "system:modules", module := module.module ]
            ] INTO messages AT END;
    }
  }
  RETURN messages;
}

ASYNC FUNCTION GetPersistentQueueStatus(STRING service, INTEGER timeout)
{
  RECORD defer := CreateDeferredPromise();

  RegisterTimedCallback(AddTimeToDate(timeout, GetCurrentDatetime()), PTR defer.resolve("timeout"));
  GetPersistentQueueStatusInternal(service)->Then(defer.resolve);

  STRING res := AWAIT defer.promise;

  SWITCH (res)
  {
    CASE ""             { RETURN RECORD[]; }
    CASE "error"
    {
      RETURN
          [ [ msg := `:Error contacting service '${service}'`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "timeout"
    {
      RETURN
          [ [ msg := `:Timeout contacting service '${service}' (waited ${timeout}ms)`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "no_progress"
    {
      RETURN
          [ [ msg := `:Service '${service}' is reporting no progress in the last 10 minutes`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
  }
  RETURN RECORD[];
}

ASYNC FUNCTION GetPersistentQueueStatusInternal(STRING serviceport)
{
  RECORD ARRAY messages;

  RECORD res;
  TRY
  {
    OBJECT service := AWAIT OpenWebHareService(serviceport);
    TRY
      res := AWAIT service->GetState();
    FINALLY
      service->CloseService();
  }
  CATCH (OBJECT e)
  {
    LogHarescriptException(e);
    RETURN "error";
  }

  RECORD ARRAY allstats := RECORD[ ...res.queuestats.history, res.queuestats.currentstatus ];
  IF (LENGTH(allstats) < 10)
    RETURN "";

  RECORD ARRAY laststats := ArraySlice(allstats, LENGTH(allstats) - 11);

  RECORD state :=
      SELECT finished :=        Sum(finished)
           , maxqueuelength :=  MAX(queuelength.maxvalue)
           , minqueuelength :=  MAX(queuelength.minvalue)
        FROM laststats;

  IF (state.minqueuelength > 0 AND state.finished = 0)
    RETURN "no_progress";
  RETURN "";
}

PUBLIC RECORD ARRAY FUNCTION GetCurrentCheckIssues(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ withhistory := FALSE ], options);

  //Some issues cannot be reported through the WRD mechanisms
  RECORD ARRAY issues;
  CONSTANT RECORD baseissue :=
    [ ismanageable := FALSE
    , message_tid := DEFAULT RECORD
    , snoozed := FALSE
    , scopes := STRING[]
    , since := DEFAULT DATETIME
    , stopped := DEFAULT DATETIME
    , jump_to := DEFAULT RECORD
    ];

  IF (NOT IsDatabaseWritable())
  {
    INSERT CELL[ ...baseissue
               , message_text := "The WebHare database is in readonly mode!"
               , rowkey := -1
               ] INTO issues AT END;
  }

  RECORD lastintervalrun := SELECT * FROM system_internal.tasks WHERE tag = "system.intervalchecks";
  IF(NOT RecordExists(lastintervalrun) OR lastintervalrun.lastrun = DEFAULT DATETIME)
  {
    INSERT CELL[ ...baseissue
               , message_text := "The periodic status checks are not running - not all checks are available"
               , rowkey := -1
               ] INTO issues AT END;
  }
  ELSE IF(lastintervalrun.error != "")
  {
    INSERT CELL[ ...baseissue
               , message_text := `The periodic status checks are failing: ${NormalizeWhitespace(lastintervalrun.error)}`
               , rowkey := -1
               ] INTO issues AT END;
  }
  ELSE
  {
    INTEGER64 lastrun := GetDatetimeDifference(lastintervalrun.lastrun, GetCurrentDatetime()).totalmsecs;
    IF(lastrun > 10 * 60000) //it's scheduled every 5 minutes, so warn after 10
    {
      INSERT CELL[ ...baseissue
                 , message_text := `The periodic status checks have not been executed for more than ${lastrun / 60000} minutes`
                 , rowkey := -2
                 ] INTO issues AT END;

    }
  }

  RECORD ARRAY dbissues;
  IF(ObjectExists(OpenWRDSchema("system:config")->GetType('server_check')))
  {
    dbissues := OpenWRDSchema("system:config")->^server_check->RunQuery(
        [ outputcolumns := CELL[ "type", "check_task", "metadata", "message_text", "message_tid", "jump_to", "snoozed_until", "wrd_id", since := "wrd_creationdate", "scopes", stopped := "wrd_limitdate" ]
        , historymode := options.withhistory ? "all" : "now"
        ]);
  }

  DATETIME now := GetCurrentDatetime();
  issues := RECORD[ ...issues, ...(SELECT ...baseissue, rowkey := wrd_id, ismanageable := TRUE, *, snoozed := snoozed_until > now FROM dbissues) ];
  RETURN issues;
}

PUBLIC RECORD ARRAY FUNCTION RunChecks()
{
  RECORD ARRAY messages;

  OBJECT validationpromise := AsyncCallFunctionFromJob("mod::system/lib/internal/restart_reset.whlib", "ValidateModules");
  OBJECT asynccheckspromise := RunAsyncChecks();

  IF(RecordExists(__debugconfig) AND NOT IsDefaultValue(__debugconfig.tags))
  {
    STRING tags := Detokenize(__debugconfig.tags, ",");
    IF(__debugconfig.outputsession != "default")
      tags := tags || ",session=" || __debugconfig.outputsession;
    IF(__debugconfig.context != "")
      tags := tags || ",context=" || __debugconfig.context;

    INSERT [ msg := `:Debugging flags enabled: ${tags}`
           ] INTO messages AT END;
  }

  //warn if the transaction range shows vacuuming not working. you can also manually check this using `wh psql -c 'SELECT max(age(datfrozenxid)) FROM pg_database'`
  INTEGER maxxidage := SendPostgreSQLCommand(GetPrimary()->id, "SELECT max(age(datfrozenxid)) FROM pg_database").max;
  IF(maxxidage >= 5000000000) //500 million is a good indication something is wrong
    INSERT [ msg := `:PostgreSQL reports ${maxxidage} transaction ids in range, it may not be properly vacuuming`
           ] INTO messages AT END;

  STRING collation :=SendPostgreSQLCommand(GetPrimary()->id, "SHOW lc_collate").lc_collate;
  IF(collation != "C")
    INSERT [ msg := `:PostgreSQL reports it's in the '${collation}' collation, you need to 'wh recreate-postgresql-database' as soon as possible`
           ] INTO messages AT END;


  IF(ReadRegistryKey("system.webserver.global.locking.sysoponly"))
  {
    INSERT [ msg := ":Logins for normal users have been closed"
           ] INTO messages AT END;
  }
  IF(ReadRegistryKey("system.services.smtp.mailfrom")="")
  {
    INSERT [ msg := ":The email fallback FROM address has not been configured"
           ] INTO messages AT END;
  }

  //Unbound IPs (and other config issues?)
  STRING saved_configpath := MergePath(GetWebHareConfiguration().varroot, "system.cache/webserver-config");
  IF(RecordExists(GetDiskFileProperties(saved_configpath)))
  {
    RECORD config := DecodeHSONBlob(GetDiskResource(saved_configpath));
    IF(CellExists(config,'version') AND config.version = GetWebhareVersionNumber()) //We may ocassionally deal with the webserver-config information of a previous WebHare version.. so just don't parse it then
    {
      FOREVERY(RECORD brokenlistener FROM config.reloadstatus.broken_listeners)
        INSERT [ msg := `:Webserver cannot bind to ${brokenlistener.ip}:${brokenlistener.port}` ] INTO messages AT END;
    }
  }

  //Missing servers
  RECORD ARRAY missing_webservers := (SELECT hostname := UnpackURL(baseurl).host, lastseen, lastcheckerror FROM system.webservers WHERE lastseen != lastcheck)
                                     CONCAT
                                     (SELECT hostname, lastseen, lastcheckerror FROM system.webservers_aliases WHERE lastseen != lastcheck);

  FOREVERY(RECORD missingserver FROM missing_webservers)
  {
    INSERT [ msg := ":" || GetWebserverErrorMessage(missingserver.hostname, missingserver.lastseen, missingserver.lastcheckerror)
           , messagetag := [ type := "system:checker.hostname", hostname := missingserver.hostname ]
           ] INTO messages AT END;
  }

  DATETIME now := GetCurrentDatetime();
  DATETIME task_this_old_should_be_finished := AddTimeToDate(-60*60*1000, now);
  STRING ARRAY tasksbytype := SELECT AS STRING ARRAY DISTINCT tasktype FROM system.managedtasks WHERE finished = DEFAULT DATETIME AND creationdate < task_this_old_should_be_finished AND notbefore < now;
  FOREVERY(STRING task FROM tasksbytype)
  {
    IF(task = "system:outgoingmail")
      INSERT [ msg := ":Mailqueue is stuck"
             , jumpto := [ app := "system:dashboard", panel := "system:mailqueue" ]
             ] INTO messages AT END;
    ELSE
      INSERT [ msg := `:Task of type '${task}' is stuck`
             , jumpto := [ app := "system:dashboard", panel := "system:managedtasks", tag := task ]
             ] INTO messages AT END;
  }

  // Module issues
  messages := messages CONCAT SELECT msg := `:${resourcename}: ${line}:${col}: Error: ${message}` FROM GetLoadErrors();
  messages := messages CONCAT SELECT msg := `:${msg}` FROM ToRecordArray(GetModuleDependencyIssues(),'msg');

  //Count recent bounces
  RECORD ARRAY recentmail := SELECT failed := lasterrors != ""
                               FROM system.managedtasks
                              WHERE tasktype = "system:outgoingmail"
                                    AND NOT iscancelled
                                    AND notbefore < now
                                    AND finished > AddTimeToDate(-60*60*1000, GetCurrentDatetime());
  INTEGER numfailed := Length(SELECT FROM recentmail WHERE failed);
  IF(numfailed >= 3 AND numfailed >= Length(recentmail)/5) // 3 bounces and at least in an hour
  {
    INSERT
        [ msg := ":Mail error rate is " || (numfailed * 100 / Length(recentmail)) || "% over the last hour"
        , messagetag := [ type := "system:checker.mailerrorrate" ]
        ] INTO messages AT END;
  }

  //Legacy database directory
  FOREVERY(RECORD unused_db FROM ReadDiskDirectory(MergePath(GetWebhareConfiguration().basedataroot,"postgresql"),"db.*"))
  {
    IF(unused_db.name="db.switchto")
      INSERT [ msg := `:Your database server needs to be restarted to activate a restored/migrated database in ${unused_db.path}` ]INTO messages AT END;
    ELSE
      INSERT [ msg := `:It looks like a previous migration backup can be removed in ${unused_db.path} - use \`wh remove-old-databases\` to clean up` ]INTO messages AT END;
  }

  FOREVERY(STRING issue FROM GetModuleObjectTypes().issues)
    INSERT [ msg := ":" || issue ] INTO messages AT END;

  // Tollium registry stuff
  STRING backendurl := GetPrimaryWebhareInterfaceURL();
  IF (backendurl = "")
  {
    INSERT [ msg := ":Backend WebHare URL unknown"  ] INTO messages AT END;
  }
  ELSE IF (TOUppercase(UnpackURL(backendurl).host) IN ["LOCALHOST","127.0.0.1","::1","0.0.0.0","::0"])
  {
    INSERT [ msg := ":Backend WebHare URL '" || backendurl || "' is not a remotely reachable interface"  ] INTO messages AT END;
  }

  //Stuck proxy servers
  RECORD ARRAY brokenproxies := SELECT url FROM system_internal.proxies WHERE status != "ok" ORDER BY url;
  FOREVERY(RECORD brokenproxy FROM brokenproxies)
  {
    INSERT [ msg := ":No control over proxy " || brokenproxy.url ] INTO messages AT END;
  }

  //Custom checks (ADDME run them in parallel and in separate jobs)
  FOREVERY(RECORD check FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "check"))
  {
    STRING ARRAY issues;
    STRING objectname := check.node->GetAttribute("objectname");
    IF(check.node->HasAttribute("library"))
      objectname := "module::" || check.module || "/" || check.node->GetAttribute("library") || "#" || objectname;
    ELSE
      objectname := MakeAbsoluteResourcePath(check.resource, objectname);

    TRY
    {
      OBJECT obj := MakeObject(objectname);
      IF(NOT obj EXTENDSFROM CustomCheckBase)
        THROW NEW Exception("The check does not derive from CustomCheckBase");

      messages := messages CONCAT obj->GetIssueList();
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      INSERT [ msg := ":Error running check " || objectname || ": " || e->what ] INTO messages AT END;
    }
  }
  // Stuck tasks
  RECORD ARRAY stucktasks := SELECT tag := Substitute(tag, '.', ':') ?? script, error, id, script
                               FROM system_internal.tasks
                               WHERE enabled
                                     AND error != ""
                                     AND inapplicable = "";

  FOREVERY(RECORD stucktask FROM stucktasks)
  {
    INSERT [ msg := ":Task '" || stucktask.tag || "' has errors: " || UCLeft(Tokenize(stucktask.error,"\n")[0],120)
           , jumpto := [ app := "system:dashboard", panel := "system:timedtasks", taskid := stucktask.id ]
           , messagetag := [ type := "system:failedtimedtask", task := stucktask.tag ]
           ]
           INTO messages AT END;
  }

  messages := messages CONCAT RunWebserverChecks();
  messages := messages CONCAT RunConsilioChecks();
  messages := messages CONCAT GetHotFixCheckResult();
  messages := messages CONCAT SELECT msg := ":" || msg
                                   , messagetag := CELL[ type := "system:validation", resourcename, line ]
                                   , jumpto := CELL[ app := "system:codeview", target := CELL[ resourcename, line, col ]]
                                FROM WaitForPromise(validationpromise);

  messages := messages CONCAT WaitForPromise(asynccheckspromise);

  IF (GetDTAPStage() = "development")
    messages := messages CONCAT RunDevelopmentChecks();

  messages := EnforceStructure([[ checktypes := STRING[] ]], messages);

  messages :=
      SELECT TEMPORARY messagetag :=  CellExists(messages, "MESSAGETAG") ? COLUMN messagetag : [ type := "tag-from-text", msg := msg ]
           , TEMPORARY messagetaghash := EncodeBase16(GetSHA1Hash(EncodeHSON(messagetag)))
           , *
           , messagetag :=      messagetag
           , messagetaghash :=  messagetaghash
        FROM messages;

  RETURN messages;
}

PUBLIC MACRO UpdateCheckStatus(STRING task, RECORD ARRAY checks)
{
  OBJECT wrdschema := OpenWRDSchema("system:config");
  GetPrimary()->BeginLockedWork("system:updatechecks." || task);

  checks := EnforceStructure([[ type := "", metadata := DEFAULT RECORD, message_text := "", message_tid := [ tid := "", params := STRING[] ], jump_to := DEFAULT RECORD, scopes := STRING[] ]], checks);
  UPDATE checks SET message_text := CallFunctionPtrVA(PTR GetTidForLanguage, VARIANT["en", message_tid.tid, ...message_tid.params]) WHERE message_text = "" AND RecordExists(message_tid);

  DATETIME now := GetCurrentDatetime();
  RECORD ARRAY current := wrdschema->^server_check->RunQuery(
    CELL [ outputcolumns := ["wrd_id","type","metadata","message_text","wrd_limitdate"]
         , filters := [[ field := "check_task", value := task ]]
         , historymode := "all"
         ]);

  RECORD ARRAY seen;
  FOREVERY(RECORD check FROM checks)
  {
    IF(check.message_text = "")
      THROW NEW Exception(`Check #${#check} is missing a message_text`);
    IF(RecordExists(SELECT FROM seen WHERE seen.type = check.type AND EncodeJSON(seen.metadata) = EncodeJSON(check.metadata)))
      CONTINUE;
    INSERT check INTO seen AT END;

    INTEGER match := (SELECT AS INTEGER #current + 1 FROM current WHERE current.type = check.type AND EncodeJSON(current.metadata) = EncodeJSON(check.metadata)) - 1; //*our* encodejson is stable!
    RECORD baserecord :=
      CELL[ check_task := task
          , check.type
          , check.metadata
          , check.message_text
          , check.message_tid
          , wrd_limitdate := MAX_DATETIME
          , check.jump_to
          , check.scopes
          ];

    IF(match = -1) //it's new
    {
      OBJECT newcheck := wrdschema->^server_check->CreateEntity(
        CELL[ ...baserecord
            , wrd_creationdate := now
            ]);
      wrdschema->^server_check_history->CreateEntity(
        CELL[ wrd_leftentity := newcheck->id
            , event := "start"
            , check.message_text
            , check.message_tid
            , wrd_creationdate := now
            ]);
      CONTINUE;
    }

    //We assume something like jumpto won't change without the message changing
    IF(current[match].message_text != check.message_text OR current[match].wrd_limitdate != MAX_DATETIME) //update it!
    {
      wrdschema->^server_check->UpdateEntity(current[match].wrd_id, baserecord);
      wrdschema->^server_check_history->CreateEntity(
        CELL[ wrd_leftentity := current[match].wrd_id
            , event := current[match].wrd_limitdate != MAX_DATETIME ? "start" : "change"
            , check.message_text
            , check.message_tid
            , wrd_creationdate := now
            ]);
    }
    DELETE FROM current AT match;
  }

  FOREVERY(RECORD cur FROM SELECT * FROM current WHERE wrd_limitdate = MAX_DATETIME)
  {
    wrdschema->^server_check->UpdateEntity(cur.wrd_id, CELL[ wrd_limitdate := now ]);
    wrdschema->^server_check_history->CreateEntity(
      CELL[ wrd_leftentity := cur.wrd_id
          , event := "stop"
          , wrd_creationdate := now
          ]);
  }

  GetPrimary()->CommitWork();
}

MACRO AuditIssue(INTEGER issueid, RECORD data)
{
  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD issueinfo := wrdschema->^server_check->GetEntityFields(issueid, CELL["message_text","type","metadata","snoozed_until"]);

  LogAuditEvent("system:systemmessages",
      CELL[ id :=                 issueid
          , until :=              issueinfo.snoozed_until
          , message_text :=       issueinfo.message_text
          , issuetype :=          issueinfo.type
          , issuemetadata :=      issueinfo.metadata
          , ...data
          ]);
}

PUBLIC MACRO SnoozeIssue(INTEGER issueid, DATETIME snoozed_until, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ comment := "", whuser := DEFAULT RECORD ], options);

  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD issueinfo := wrdschema->^server_check->GetEntityFields(issueid, CELL["snoozed_until","message_text","type","metadata"]);
  IF(issueinfo.snoozed_until > snoozed_until)
    THROW NEW Exception(`A longer snooze is already active for check issue #${issueid}`);

  wrdschema->^server_check->UpdateEntity(issueid, CELL[ snoozed_until ]);

  wrdschema->^server_check_history->CreateEntity(
    CELL[ wrd_leftentity := issueid
        , event := "snooze"
        , options.comment
        , snoozed_until
        , wh_user := options.whuser
        ]);

  AuditIssue(issueid, [ type := "snooze" , comment := options.comment ]);
}

PUBLIC MACRO UnsnoozeIssue(INTEGER issueid)
{
  //We don't really bother to log 'unsnoozing' as a history event
  OBJECT wrdschema := OpenWRDSchema("system:config");
  RECORD ARRAY activesnoozes := wrdschema->^server_check_history->RunQuery(
      [ outputcolumns := CELL[ "wrd_id" ]
      , filters := [ [ field := "wrd_leftentity", value := issueid ]
                   , [ field := "event", value := "snooze" ]
                   , [ field := "snoozed_until", matchtype := ">=", value := GetCurrentDatetime() ]
                   ]
      ]);

  FOREVERY(RECORD activesnooze FROM activesnoozes)
    wrdschema->^server_check_history->CloseEntity(activesnooze.wrd_id);

  AuditIssue(issueid, [ type := "unsnooze" ]);
  wrdschema->^server_check->UpdateEntity(issueid, [ snoozed_until := DEFAULT DATETIME ]);
}
