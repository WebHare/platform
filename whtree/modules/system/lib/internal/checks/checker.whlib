<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::util/semver.whlib";
LOADLIB "wh::util/stringparser.whlib";
LOADLIB "wh::internal/debug.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::wrd/lib/api.whlib";

LOADLIB "mod::consilio/lib/internal/checks.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/checks/webserver.whlib";
LOADLIB "mod::system/lib/internal/userrights/rightsparser.whlib";

PUBLIC RECORD FUNCTION GetWHVersionInfo()
{
  RECORD versioninfo := GetWebhareVersionInfo();
  STRING versionname := `WebHare ${versioninfo.version} (`;
  IF(versioninfo.branch != "" AND versioninfo.branch NOT LIKE "release/*")
    versionname := versionname || versioninfo.branch || "@";
  versionname := versionname || Left(versioninfo.committag,7) || ")";

  RETURN CELL [ versionname
              , built := TrimWhitespace(`${versioninfo.builddatetime}`)
              ];
}

PUBLIC RECORD FUNCTION CheckCustomMessageConditions(RECORD ARRAY conditions)
{
  RECORD ARRAY result;
  FOREVERY (RECORD cond FROM conditions)
  {
    SWITCH (cond.type)
    {
      CASE "webhareVersion"
        {
          STRING whversion := GetWebhareVersionInfo().version;
          INSERT CELL
              [ cond.type
              , cond.semver_range
              , current := whversion
              , parsed := CELL[ cond.semver_range ]
              , matches := VersionSatisfiesRange(whversion, cond.semver_range)
              ] INTO result AT END;
        }
      CASE "dateRange"
        {
          DATETIME date_from, date_until := MAX_DATETIME;

          // ADDME: add shared parser for date_range (and use it for the interface too)
          OBJECT p := NEW StringParser(cond.date_range);
          p->ParseWhileInSet(" ");
          IF (p->TryParse(">="))
          {
            p->ParseWhileInSet(" ");
            date_from := MakeDateFromText(p->ParseWhileInSet("0123456789TZ-:."));
          }
          p->ParseWhileInSet(" ");
          IF (p->TryParse("<"))
          {
            p->ParseWhileInSet(" ");
            date_until := MakeDateFromText(p->ParseWhileInSet("0123456789TZ-:."));
          }
          p->ParseWhileInSet(" ");
          RECORD parsed := p->eof ? CELL[ date_from, date_until ] : DEFAULT RECORD;
          DATETIME now := GetCurrentDateTime();
          INSERT CELL
              [ cond.type
              , cond.date_range
              , current := FormatISO8601DateTime(GetCurrentDatetime())
              , parsed
              , matches := RecordExists(parsed) AND date_from <= now AND date_until > now
              ] INTO result AT END;
        }
      CASE "moduleVersion"
        {
          RECORD module := SELECT * FROM GetWebHareModules() WHERE name = cond.module;
          STRING version := RecordExists(module) ? module.version : "";
          INSERT CELL
              [ cond.type
              , cond.module
              , cond.semver_range
              , current := version
              , parsed := CELL[ cond.semver_range ]
              , matches := RecordExists(module) AND VersionSatisfiesRange(version, cond.semver_range)
              ] INTO result AT END;
        }
    }
  }

  RECORD failingcondition := SELECT * FROM result WHERE NOT matches;
  RETURN CELL
      [ parsed := result
      , matches := NOT RecordExists(failingcondition)
      , failingcondition
      ];
}

ASYNC FUNCTION RunAsyncChecks()
{
  OBJECT publishercheckpromise := GetPersistentQueueStatus("publisher:publication", 15000);
  OBJECT outputanalyzercheckpromise := GetPersistentQueueStatus("publisher:outputanalyzer", 15000);

  RETURN AWAIT publishercheckpromise CONCAT AWAIT outputanalyzercheckpromise;
}

RECORD ARRAY FUNCTION GetHotFixCheckResult()
{
  RECORD ARRAY messages;

  STRING hotfixfile := GetWebHareConfiguration().basedataroot || "caches/platform/run/hotfixstate.json";
  RECORD data := DecodeJSONBlob(GetDiskResource(hotfixfile, [ allowmissing := TRUE ]));
  IF (RecordExists(data))
  {
    FOREVERY (RECORD module FROM RECORD ARRAY(data.modules))
    {
      FOREVERY (STRING msg FROM STRING ARRAY(module.messages))
        INSERT CELL
            [ msg
            , jumpto := [ app := "system:dashboard", panel := "system:modules", module := module.module ]
            ] INTO messages AT END;
    }
  }
  RETURN messages;
}

ASYNC FUNCTION GetPersistentQueueStatus(STRING service, INTEGER timeout)
{
  RECORD defer := CreateDeferredPromise();

  RegisterTimedCallback(AddTimeToDate(timeout, GetCurrentDatetime()), PTR defer.resolve("timeout"));
  GetPersistentQueueStatusInternal(service)->Then(defer.resolve);

  STRING res := AWAIT defer.promise;

  SWITCH (res)
  {
    CASE ""             { RETURN RECORD[]; }
    CASE "error"
    {
      RETURN
          [ [ msg := `:Error contacting service '${service}'`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "timeout"
    {
      RETURN
          [ [ msg := `:Timeout contacting service '${service}' (waited ${timeout}ms)`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "no_progress"
    {
      RETURN
          [ [ msg := `:Service '${service}' is reporting no progress in the last 10 minutes`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
  }
  RETURN RECORD[];
}

PUBLIC RECORD ARRAY FUNCTION GetCustomCheckResults()
{
  TRY
  {
    OBJECT wrdschema := OpenWRDSchema("system:config");
    RECORD ARRAY checks := wrdschema->^custom_check_messages->RunQuery(
      [ outputcolumns := CELL[ "wrd_id", "wrd_title", "conditions" ]
      ]);

    RECORD ARRAY results;
    FOREVERY(RECORD check FROM checks)
    {
      IF (CellExists(check.conditions, "CONDITIONS") AND CheckCustomMessageConditions(check.conditions.conditions).matches)
      {
        INSERT
            [ msg := `:${check.wrd_title}`
            , messagetag := [ type := "system:custommessagechecks", id := check.wrd_id ]
            ] INTO results AT END;
      }
    }

    RETURN results;
  }
  CATCH (OBJECT e)
  {
    LogHarescriptException(e);
    RETURN RECORD[];
  }
}

ASYNC FUNCTION GetPersistentQueueStatusInternal(STRING serviceport)
{
  RECORD ARRAY messages;

  RECORD res;
  TRY
  {
    OBJECT service := AWAIT OpenWebHareService(serviceport);
    TRY
      res := AWAIT service->GetState();
    FINALLY
      service->CloseService();
  }
  CATCH (OBJECT e)
  {
    LogHarescriptException(e);
    RETURN "error";
  }

  RECORD ARRAY allstats := RECORD[ ...res.queuestats.history, res.queuestats.currentstatus ];
  IF (LENGTH(allstats) < 10)
    RETURN "";

  RECORD ARRAY laststats := ArraySlice(allstats, LENGTH(allstats) - 11);

  RECORD state :=
      SELECT finished :=        Sum(finished)
           , maxqueuelength :=  MAX(queuelength.maxvalue)
           , minqueuelength :=  MAX(queuelength.minvalue)
        FROM laststats;

  IF (state.minqueuelength > 0 AND state.finished = 0)
    RETURN "no_progress";
  RETURN "";
}

PUBLIC RECORD ARRAY FUNCTION RunChecks() {
  RECORD ARRAY messages;

  OBJECT validationpromise := AsyncCallFunctionFromJob("mod::system/lib/internal/restart_reset.whlib", "ValidateModules");
  OBJECT asynccheckspromise := RunAsyncChecks();

  IF(RecordExists(__debugconfig) AND NOT IsDefaultValue(__debugconfig.tags))
  {
    STRING tags := Detokenize(__debugconfig.tags, ",");
    IF(__debugconfig.outputsession != "default")
      tags := tags || ",session=" || __debugconfig.outputsession;
    IF(__debugconfig.context != "")
      tags := tags || ",context=" || __debugconfig.context;

    INSERT [ msg := `:Debugging flags enabled: ${tags}`
           ] INTO messages AT END;
  }
  IF(ReadRegistryKey("system.webserver.global.locking.sysoponly"))
  {
    INSERT [ msg := ":Logins for normal users have been closed"
           ] INTO messages AT END;
  }
  IF(ReadRegistryKey("system.services.smtp.mailfrom")="")
  {
    INSERT [ msg := ":The email fallback FROM address has not been configured"
           ] INTO messages AT END;
  }

  //Unbound IPs (and other config issues?)
  STRING saved_configpath := MergePath(GetWebHareConfiguration().varroot, "system.cache/webserver-config");
  IF(RecordExists(GetDiskFileProperties(saved_configpath)))
  {
    RECORD config := DecodeHSONBlob(GetDiskResource(saved_configpath));
    IF(CellExists(config,'version') AND config.version = GetWebhareVersionNumber()) //We may ocassionally deal with the webserver-config information of a previous WebHare version.. so just don't parse it then
    {
      FOREVERY(RECORD brokenlistener FROM config.reloadstatus.broken_listeners)
        INSERT [ msg := `:Webserver cannot bind to ${brokenlistener.ip}:${brokenlistener.port}` ] INTO messages AT END;
    }
  }

  //Missing servers
  RECORD ARRAY missing_webservers := (SELECT hostname := UnpackURL(baseurl).host, lastseen, lastcheckerror FROM system.webservers WHERE lastseen != lastcheck)
                                     CONCAT
                                     (SELECT hostname, lastseen, lastcheckerror FROM system.webservers_aliases WHERE lastseen != lastcheck);

  FOREVERY(RECORD missingserver FROM missing_webservers)
  {
    INSERT [ msg := ":" || GetWebserverErrorMessage(missingserver.hostname, missingserver.lastseen, missingserver.lastcheckerror)
           , messagetag := [ type := "system:checker.hostname", hostname := missingserver.hostname ]
           ] INTO messages AT END;
  }

  DATETIME now := GetCurrentDatetime();
  DATETIME task_this_old_should_be_finished := AddTimeToDate(-60*60*1000, now);
  STRING ARRAY tasksbytype := SELECT AS STRING ARRAY DISTINCT tasktype FROM system.managedtasks WHERE finished = DEFAULT DATETIME AND creationdate < task_this_old_should_be_finished AND notbefore < now;
  FOREVERY(STRING task FROM tasksbytype)
  {
    IF(task = "system:outgoingmail")
    {
      // Only warn for stuck mail queues in production
      IF (GetDTAPStage() = "production")
      {
        INSERT [ msg := ":Mailqueue is stuck"
              , jumpto := [ app := "system:dashboard", panel := "system:mailqueue" ]
              ] INTO messages AT END;
      }
    }
    ELSE
      INSERT [ msg := `:Task of type '${task}' is stuck`
             , jumpto := [ app := "system:dashboard", panel := "system:managedtasks", tag := task ]
             ] INTO messages AT END;
  }

  // Module issues
  messages := messages CONCAT SELECT msg := `:${resourcename}: ${line}:${col}: Error: ${message}` FROM GetLoadErrors();
  messages := messages CONCAT SELECT msg := `:${msg}` FROM ToRecordArray(GetModuleDependencyIssues(),'msg');

  //Count recent bounces
  RECORD ARRAY recentmail := SELECT failed := lasterrors != ""
                               FROM system.managedtasks
                              WHERE tasktype = "system:outgoingmail"
                                    AND NOT iscancelled
                                    AND notbefore < now
                                    AND finished > AddTimeToDate(-60*60*1000, GetCurrentDatetime());
  INTEGER numfailed := Length(SELECT FROM recentmail WHERE failed);
  IF(numfailed >= 3 AND numfailed >= Length(recentmail)/5) // 3 bounces and at least in an hour
  {
    INSERT
        [ msg := ":Mail error rate is " || (numfailed * 100 / Length(recentmail)) || "% over the last hour"
        , messagetag := [ type := "system:checker.mailerrorrate" ]
        ] INTO messages AT END;
  }

  FOREVERY(STRING issue FROM GetModuleObjectTypes().issues)
    INSERT [ msg := ":" || issue ] INTO messages AT END;

  // Tollium registry stuff
  STRING backendurl := GetPrimaryWebhareInterfaceURL();
  IF (backendurl = "")
  {
    INSERT [ msg := ":Backend WebHare URL unknown"  ] INTO messages AT END;
  }
  ELSE IF (TOUppercase(UnpackURL(backendurl).host) IN ["LOCALHOST","127.0.0.1","::1","0.0.0.0","::0"])
  {
    INSERT [ msg := ":Backend WebHare URL '" || backendurl || "' is not a remotely reachable interface"  ] INTO messages AT END;
  }

  //Stuck proxy servers
  RECORD ARRAY brokenproxies := SELECT url FROM system_internal.proxies WHERE status != "ok" ORDER BY url;
  FOREVERY(RECORD brokenproxy FROM brokenproxies)
  {
    INSERT [ msg := ":No control over proxy " || brokenproxy.url ] INTO messages AT END;
  }

  //Custom checks (ADDME run them in parallel and in separate jobs)
  FOREVERY(RECORD check FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "check"))
  {
    STRING ARRAY issues;
    STRING objectname :=  MakeAbsoluteResourcePath(check.resource, check.node->GetAttribute("objectname"));

    TRY
    {
      OBJECT obj := MakeObject(objectname);
      IF(NOT obj EXTENDSFROM CustomCheckBase)
        THROW NEW Exception("The check does not derive from CustomCheckBase");

      messages := messages CONCAT obj->GetIssueList();
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      INSERT [ msg := ":Error running check " || objectname || ": " || e->what ] INTO messages AT END;
    }
  }
  // Stuck tasks
  RECORD ARRAY stucktasks := SELECT tag := Substitute(tag, '.', ':') ?? script, error, id, script
                               FROM system_internal.tasks
                               WHERE enabled
                                     AND error != ""
                                     AND inapplicable = "";

  FOREVERY(RECORD stucktask FROM stucktasks)
  {
    INSERT [ msg := ":Task '" || stucktask.tag || "' has errors: " || UCLeft(Tokenize(stucktask.error,"\n")[0],120)
           , jumpto := [ app := "system:dashboard", panel := "system:timedtasks", taskid := stucktask.id ]
           , messagetag := [ type := "system:failedtimedtask", task := stucktask.tag ]
           ]
           INTO messages AT END;
  }

  //We want you to snooze disabled tasks so other admins can know why - and you can't easily forget to re-enable them
  RECORD ARRAY disabledtasks := SELECT tag := Substitute(tag, '.', ':') ?? script, id
                                 FROM system_internal.tasks
                                WHERE NOT enabled
                                      AND inapplicable = "";
  FOREVERY(RECORD disabledtask FROM disabledtasks)   {
    INSERT [ msg := `:Task ${disabledtask.tag}' has been manually disabled`
           , jumpto := [ app := "system:dashboard", panel := "system:timedtasks", taskid := disabledtask.id ]
           , messagetag := [ type := "system:disabledtimedtask", task := disabledtask.tag ]
           ]
           INTO messages AT END;
  }

  messages := messages CONCAT RunWebserverChecks();
  messages := messages CONCAT RunConsilioChecks();
  IF(GetEnvironmentVariable("WEBHARE_IN_DOCKER") != "") //check for hotfixes when running as container (as there they're easily lost)
    messages := messages CONCAT GetHotFixCheckResult();
  messages := messages CONCAT SELECT msg := `:${message}` FROM ToRecordArray(GetModuleObjectTypes().issues, "message");
  messages := messages CONCAT GetCustomCheckResults();
  messages := messages CONCAT SELECT msg := ":" || msg
                                   , messagetag := CELL[ type := "system:validation", resourcename, line ]
                                   , jumpto := CELL[ app := "system:codeview", target := CELL[ resourcename, line, col ]]
                                FROM WaitForPromise(validationpromise);

  messages := messages CONCAT WaitForPromise(asynccheckspromise);
  messages := EnforceStructure([[ checktypes := STRING[] ]], messages);

  messages :=
      SELECT TEMPORARY messagetag :=  CellExists(messages, "MESSAGETAG") ? COLUMN messagetag : [ type := "tag-from-text", msg := msg ]
           , TEMPORARY messagetaghash := EncodeBase16(GetSHA1Hash(EncodeHSON(messagetag)))
           , *
           , messagetag :=      messagetag
           , messagetaghash :=  messagetaghash
        FROM messages;

  RETURN messages;
}
