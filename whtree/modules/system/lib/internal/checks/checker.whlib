<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::dbase/postgresql.whlib";
LOADLIB "wh::internal/debug.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::consilio/lib/internal/checks.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/internal/checks/webserver.whlib";
LOADLIB "mod::system/lib/internal/modules/node.whlib";
LOADLIB "mod::system/lib/internal/userrights/rightsparser.whlib";

PUBLIC RECORD FUNCTION GetWHVersionInfo()
{
  RECORD versioninfo := GetWebhareVersionInfo();
  STRING versionname := `WebHare ${versioninfo.version} (`;
  IF(versioninfo.branch != "" AND versioninfo.branch NOT LIKE "release/*")
    versionname := versionname || versioninfo.branch || "@";
  versionname := versionname || Left(versioninfo.committag,7) || ")";

  RETURN CELL [ versionname
              , built := TrimWhitespace(`${versioninfo.builddate} ${versioninfo.buildtime}`)
              ];
}

RECORD ARRAY FUNCTION RunDevelopmentChecks()
{
  RECORD ARRAY node_issues := SELECT msg := `:Node module issue in WebHare Platform: ${error}`
                                FROM CheckNodeModulesInModule(GetWebHareConfiguration().installationroot, [ skipmodtimecheck := TRUE ]);
  FOREVERY (STRING module FROM __SYSTEM_GetInstalledModuleNames())
  {
    STRING path := GetModuleInstallationRoot(module);
    node_issues := node_issues CONCAT SELECT msg := `:Node module issue in ${module}: ${error}`
                                        FROM CheckNodeModulesInModule(path);
  }
  RETURN node_issues;
}

ASYNC FUNCTION RunAsyncChecks()
{
  OBJECT publishercheckpromise := GetPersistentQueueStatus("publisher:publication", 15000);
  OBJECT outputanalyzercheckpromise := GetPersistentQueueStatus("publisher:outputanalyzer", 15000);

  RETURN AWAIT publishercheckpromise CONCAT AWAIT outputanalyzercheckpromise;

}

RECORD ARRAY FUNCTION GetHotFixCheckResult()
{
  RECORD ARRAY messages;

  STRING hotfixfile := GetWebHareConfiguration().ephemeralroot || "hotfixstate.json";
  RECORD data := DecodeJSONBlob(GetDiskResource(hotfixfile, [ allowmissing := TRUE ]));
  IF (RecordExists(data))
  {
    FOREVERY (RECORD module FROM RECORD ARRAY(data.modules))
    {
      FOREVERY (STRING msg FROM STRING ARRAY(module.messages))
        INSERT CELL
            [ msg
            , jumpto := [ app := "system:dashboard", panel := "system:modules", module := module.module ]
            ] INTO messages AT END;
    }
  }
  RETURN messages;
}

ASYNC FUNCTION GetPersistentQueueStatus(STRING service, INTEGER timeout)
{
  RECORD defer := CreateDeferredPromise();

  RegisterTimedCallback(AddTimeToDate(timeout, GetCurrentDatetime()), PTR defer.resolve("timeout"));
  GetPersistentQueueStatusInternal(service)->Then(defer.resolve);

  STRING res := AWAIT defer.promise;

  SWITCH (res)
  {
    CASE ""             { RETURN RECORD[]; }
    CASE "error"
    {
      RETURN
          [ [ msg := `:Error contacting service '${service}'`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "timeout"
    {
      RETURN
          [ [ msg := `:Timeout contacting service '${service}' (waited ${timeout}ms)`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
    CASE "no_progress"
    {
      RETURN
          [ [ msg := `:Service '${service}' is reporting no progress in the last 10 minutes`
            , jumpto := [ app := "system:dashboard", panel := "system:queues" ]
            ]
          ];
    }
  }
  RETURN RECORD[];
}

ASYNC FUNCTION GetPersistentQueueStatusInternal(STRING serviceport)
{
  RECORD ARRAY messages;

  RECORD res;
  TRY
  {
    OBJECT service := AWAIT OpenWebHareService(serviceport);
    TRY
      res := AWAIT service->GetState();
    FINALLY
      service->CloseService();
  }
  CATCH (OBJECT e)
  {
    LogHarescriptException(e);
    RETURN "error";
  }

  RECORD ARRAY allstats := RECORD[ ...res.queuestats.history, res.queuestats.currentstatus ];
  IF (LENGTH(allstats) < 10)
    RETURN "";

  RECORD ARRAY laststats := ArraySlice(allstats, LENGTH(allstats) - 11);

  RECORD state :=
      SELECT finished :=        Sum(finished)
           , maxqueuelength :=  MAX(queuelength.maxvalue)
           , minqueuelength :=  MAX(queuelength.minvalue)
        FROM laststats;

  IF (state.minqueuelength > 0 AND state.finished = 0)
    RETURN "no_progress";
  RETURN "";
}

PUBLIC RECORD ARRAY FUNCTION RunChecks()
{
  RECORD ARRAY messages;

  OBJECT validationpromise := AsyncCallFunctionFromJob("mod::system/lib/internal/restart_reset.whlib", "ValidateModules");
  OBJECT asynccheckspromise := RunAsyncChecks();

  IF(RecordExists(__debugconfig) AND NOT IsDefaultValue(__debugconfig.tags))
  {
    STRING tags := Detokenize(__debugconfig.tags, ",");
    IF(__debugconfig.outputsession != "default")
      tags := tags || ",session=" || __debugconfig.outputsession;
    IF(__debugconfig.context != "")
      tags := tags || ",context=" || __debugconfig.context;

    INSERT [ msg := `:Debugging flags enabled: ${tags}`
           ] INTO messages AT END;
  }

  //warn if the transaction range shows vacuuming not working. you can also manually check this using `wh psql -c 'SELECT max(age(datfrozenxid)) FROM pg_database'`
  INTEGER maxxidage := SendPostgreSQLCommand(GetPrimary()->id, "SELECT max(age(datfrozenxid)) FROM pg_database").max;
  IF(maxxidage >= 5000000000) //500 million is a good indication something is wrong
    INSERT [ msg := `:PostgreSQL reports ${maxxidage} transaction ids in range, it may not be properly vacuuming`
           , messagetag := [ type := "system:checker.pg.toomanytransactionids" ]
           ] INTO messages AT END;

  STRING collation :=SendPostgreSQLCommand(GetPrimary()->id, "SHOW lc_collate").lc_collate;
  IF(collation != "C")
    INSERT [ msg := `:PostgreSQL reports it's in the '${collation}' collation, you need to 'wh recreate-postgresql-database' as soon as possible`
           ] INTO messages AT END;

  VARIANT connections := INTEGER(SendPostgreSQLCommand(GetPrimary()->id, "SELECT COUNT(*) FROM pg_stat_activity").count);
  VARIANT max_connections := ToInteger(SendPostgreSQLCommand(GetPrimary()->id, "SHOW max_connections").max_connections, 0);

  IF (connections >= max_connections / 2)
    INSERT [ msg := `:PostgreSQL reports ${connections}/${max_connections} active connections, it might be running out of connections soon`
           , messagetag := CELL[ type := "system:checker.pg.toomanyconnections", max_connections ] // reset snooze when max_connections is changed
           ] INTO messages AT END;

  IF(ReadRegistryKey("system.webserver.global.locking.sysoponly"))
  {
    INSERT [ msg := ":Logins for normal users have been closed"
           ] INTO messages AT END;
  }
  IF(ReadRegistryKey("system.services.smtp.mailfrom")="")
  {
    INSERT [ msg := ":The email fallback FROM address has not been configured"
           ] INTO messages AT END;
  }

  //Unbound IPs (and other config issues?)
  STRING saved_configpath := MergePath(GetWebHareConfiguration().varroot, "system.cache/webserver-config");
  IF(RecordExists(GetDiskFileProperties(saved_configpath)))
  {
    RECORD config := DecodeHSONBlob(GetDiskResource(saved_configpath));
    IF(CellExists(config,'version') AND config.version = GetWebhareVersionNumber()) //We may ocassionally deal with the webserver-config information of a previous WebHare version.. so just don't parse it then
    {
      FOREVERY(RECORD brokenlistener FROM config.reloadstatus.broken_listeners)
        INSERT [ msg := `:Webserver cannot bind to ${brokenlistener.ip}:${brokenlistener.port}` ] INTO messages AT END;
    }
  }

  //Missing servers
  RECORD ARRAY missing_webservers := (SELECT hostname := UnpackURL(baseurl).host, lastseen, lastcheckerror FROM system.webservers WHERE lastseen != lastcheck)
                                     CONCAT
                                     (SELECT hostname, lastseen, lastcheckerror FROM system.webservers_aliases WHERE lastseen != lastcheck);

  FOREVERY(RECORD missingserver FROM missing_webservers)
  {
    INSERT [ msg := ":" || GetWebserverErrorMessage(missingserver.hostname, missingserver.lastseen, missingserver.lastcheckerror)
           , messagetag := [ type := "system:checker.hostname", hostname := missingserver.hostname ]
           ] INTO messages AT END;
  }

  DATETIME now := GetCurrentDatetime();
  DATETIME task_this_old_should_be_finished := AddTimeToDate(-60*60*1000, now);
  STRING ARRAY tasksbytype := SELECT AS STRING ARRAY DISTINCT tasktype FROM system.managedtasks WHERE finished = DEFAULT DATETIME AND creationdate < task_this_old_should_be_finished AND notbefore < now;
  FOREVERY(STRING task FROM tasksbytype)
  {
    IF(task = "system:outgoingmail")
      INSERT [ msg := ":Mailqueue is stuck"
             , jumpto := [ app := "system:dashboard", panel := "system:mailqueue" ]
             ] INTO messages AT END;
    ELSE
      INSERT [ msg := `:Task of type '${task}' is stuck`
             , jumpto := [ app := "system:dashboard", panel := "system:managedtasks", tag := task ]
             ] INTO messages AT END;
  }

  // Module issues
  messages := messages CONCAT SELECT msg := `:${resourcename}: ${line}:${col}: Error: ${message}` FROM GetLoadErrors();
  messages := messages CONCAT SELECT msg := `:${msg}` FROM ToRecordArray(GetModuleDependencyIssues(),'msg');

  //Count recent bounces
  RECORD ARRAY recentmail := SELECT failed := lasterrors != ""
                               FROM system.managedtasks
                              WHERE tasktype = "system:outgoingmail"
                                    AND NOT iscancelled
                                    AND notbefore < now
                                    AND finished > AddTimeToDate(-60*60*1000, GetCurrentDatetime());
  INTEGER numfailed := Length(SELECT FROM recentmail WHERE failed);
  IF(numfailed >= 3 AND numfailed >= Length(recentmail)/5) // 3 bounces and at least in an hour
  {
    INSERT
        [ msg := ":Mail error rate is " || (numfailed * 100 / Length(recentmail)) || "% over the last hour"
        , messagetag := [ type := "system:checker.mailerrorrate" ]
        ] INTO messages AT END;
  }

  //Legacy database directory
  FOREVERY(RECORD unused_db FROM ReadDiskDirectory(MergePath(GetWebhareConfiguration().basedataroot,"postgresql"),"db.*"))
  {
    IF(unused_db.name="db.switchto")
      INSERT [ msg := `:Your database server needs to be restarted to activate a restored/migrated database in ${unused_db.path}` ]INTO messages AT END;
    ELSE
      INSERT [ msg := `:It looks like a previous migration backup can be removed in ${unused_db.path} - use \`wh remove-old-databases\` to clean up` ]INTO messages AT END;
  }

  FOREVERY(STRING issue FROM GetModuleObjectTypes().issues)
    INSERT [ msg := ":" || issue ] INTO messages AT END;

  // Tollium registry stuff
  STRING backendurl := GetPrimaryWebhareInterfaceURL();
  IF (backendurl = "")
  {
    INSERT [ msg := ":Backend WebHare URL unknown"  ] INTO messages AT END;
  }
  ELSE IF (TOUppercase(UnpackURL(backendurl).host) IN ["LOCALHOST","127.0.0.1","::1","0.0.0.0","::0"])
  {
    INSERT [ msg := ":Backend WebHare URL '" || backendurl || "' is not a remotely reachable interface"  ] INTO messages AT END;
  }

  //Stuck proxy servers
  RECORD ARRAY brokenproxies := SELECT url FROM system_internal.proxies WHERE status != "ok" ORDER BY url;
  FOREVERY(RECORD brokenproxy FROM brokenproxies)
  {
    INSERT [ msg := ":No control over proxy " || brokenproxy.url ] INTO messages AT END;
  }

  //Custom checks (ADDME run them in parallel and in separate jobs)
  FOREVERY(RECORD check FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "check"))
  {
    STRING ARRAY issues;
    STRING objectname := check.node->GetAttribute("objectname");
    IF(check.node->HasAttribute("library"))
      objectname := "module::" || check.module || "/" || check.node->GetAttribute("library") || "#" || objectname;
    ELSE
      objectname := MakeAbsoluteResourcePath(check.resource, objectname);

    TRY
    {
      OBJECT obj := MakeObject(objectname);
      IF(NOT obj EXTENDSFROM CustomCheckBase)
        THROW NEW Exception("The check does not derive from CustomCheckBase");

      messages := messages CONCAT obj->GetIssueList();
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      INSERT [ msg := ":Error running check " || objectname || ": " || e->what ] INTO messages AT END;
    }
  }
  // Stuck tasks
  RECORD ARRAY stucktasks := SELECT tag := Substitute(tag, '.', ':') ?? script, error, id, script
                               FROM system_internal.tasks
                               WHERE enabled
                                     AND error != ""
                                     AND inapplicable = "";

  FOREVERY(RECORD stucktask FROM stucktasks)
  {
    INSERT [ msg := ":Task '" || stucktask.tag || "' has errors: " || UCLeft(Tokenize(stucktask.error,"\n")[0],120)
           , jumpto := [ app := "system:dashboard", panel := "system:timedtasks", taskid := stucktask.id ]
           , messagetag := [ type := "system:failedtimedtask", task := stucktask.tag ]
           ]
           INTO messages AT END;
  }

  messages := messages CONCAT RunWebserverChecks();
  messages := messages CONCAT RunConsilioChecks();
  messages := messages CONCAT GetHotFixCheckResult();
  messages := messages CONCAT SELECT msg := ":" || msg
                                   , messagetag := CELL[ type := "system:validation", resourcename, line ]
                                   , jumpto := CELL[ app := "system:codeview", target := CELL[ resourcename, line, col ]]
                                FROM WaitForPromise(validationpromise);

  messages := messages CONCAT WaitForPromise(asynccheckspromise);

  IF (GetDTAPStage() = "development")
    messages := messages CONCAT RunDevelopmentChecks();

  messages := EnforceStructure([[ checktypes := STRING[] ]], messages);

  messages :=
      SELECT TEMPORARY messagetag :=  CellExists(messages, "MESSAGETAG") ? COLUMN messagetag : [ type := "tag-from-text", msg := msg ]
           , TEMPORARY messagetaghash := EncodeBase16(GetSHA1Hash(EncodeHSON(messagetag)))
           , *
           , messagetag :=      messagetag
           , messagetaghash :=  messagetaghash
        FROM messages;

  RETURN messages;
}
