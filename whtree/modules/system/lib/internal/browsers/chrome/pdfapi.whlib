<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::filetypes/html.whlib";
LOADLIB "wh::graphics/core.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/networking/adhocserver.whlib";
LOADLIB "mod::system/lib/internal/composer.whlib";


// All sizes (width, height, margin.top, margin.left, margin.right and margin.bottom) can be specified as either a number of
// pixels (@96dpi) or string value with a "px", "in", "cm" or "mm" unit.
// Format can be one of "letter", "legal", "tabloid", "ledger", "a0", "a1", "a2", "a3", "a4", "a5" or "a6". If set to empty
// without custom width and height specified, "a4" is used.
// Width and height are only used if they're both valid. If both format and width and height are specified, format is used.
PUBLIC CONSTANT RECORD pdf_defaultsettings :=
    [ scale := 1m
    , displayheaderfooter := FALSE
    , printbackground := TRUE
    , landscape := FALSE
    , pageranges := ""
    , format := "a4"
    , width := ""
    , height := ""
    , margin := DEFAULT RECORD // [ top := "", left := "", right := "", bottom := "" ]
    , preferCSSPageSize := TRUE
    , devtoolsurl := ""
    , headertemplate := ""
    , footertemplate := ""
    ];

// The following can be overwritten by wh-chromepdf-* meta/template tags in the HTML head
PUBLIC CONSTANT STRING ARRAY pdf_defaultsettings_optionals :=
    [ "margin"
    , "format"
    , "width"
    , "height"
    , "headertemplate"
    , "footertemplate"
    , "displayheaderfooter"
    ];

//We should be called through printer.whlib, not directyl!
PUBLIC STATIC OBJECTTYPE ChromePDFAPI EXTEND ComposerBase
<
  RECORD options;
  OBJECT runner;
  RECORD session;
  OBJECT connector;
  OBJECT conn;
  OBJECT page;
  RECORD ARRAY embedded_fonts;
  RECORD ARRAY logevents;

  PUBLIC BLOB htmlversion;
  PUBLIC STRING errors;

  MACRO NEW(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->options := ValidateOptions(CELL[...pdf_defaultsettings, debug := FALSE]
                                    , options
                                    , [ notypecheck := [ "width", "height" ] ]);
  }

  UPDATE STRING FUNCTION DoAddEmbeddedObject(BLOB data, STRING mimetype, STRING filename, BOOLEAN external)
  {
    STRING outname := `embedded${Length(this->embedded_files)+1}${GetExtensionFromPath(filename)}`;
    INSERT INTO this->embedded_files(contenttype, data, filename, external, href)
           VALUES(mimetype, data, filename, external, outname)
           AT END;
    RETURN outname;
  }

  MACRO PrepareHTMLVersion()
  {
    BLOB htmlversion := this->GenerateHTML().htmlversion; //ADDME can't we combine fontfaces generation for when we actulaly have access to the HTML source

    OBJECT htmldoc := MakeXMLDocumentFromHTML(htmlversion);
    OBJECT head := htmldoc->GetElement("head,body");
    OBJECT stylenode := htmldoc->CreateElement("style");
    head->InsertBefore(stylenode, head->firstchild);

    STRING styleinfo;
    this->embedded_fonts := RECORD[];

    IF(NOT IsWasm()) {
      FOREVERY(RECORD font FROM (SELECT * FROM GfxGetAvailableFonts() ORDER BY family,style))  {
        RECORD css := GfxGetFontCSSCode(font);
        IF(NOT RecordExists(css))
          CONTINUE;

        styleinfo := styleinfo || css.csstext;
        INSERT font INTO this->embedded_fonts AT END;
      }
    } ELSE {
      styleinfo := '/* Font listing not available in wasm */\n';
    }
    stylenode->AppendChild(htmldoc->CreateCDATASection(styleinfo));

    htmldoc->documentelement->SetAttribute("class", htmldoc->documentelement->GetAttribute("class") || " wk-chromepdf--pdfbody");
    htmlversion := NEW HTMLRewriterContext->GenerateHTML(htmldoc);

    this->htmlversion := htmlversion;
  }

  RECORD ARRAY FUNCTION GetFileList(BLOB data)
  {
    IF (Length(data) = 0 AND LengtH(this->htmlversion) = 0)
      RETURN RECORD[];

    RECORD ARRAY filelist;
    IF (Length(data) > 0)
    {
      // Generate PDF from supplied blob
      RECORD wrapped := WrapBlob(data, "");
      filelist := [ [ path := "/.contents"
                    , headers :=
                        [ [ field := "Content-Type", value := wrapped.mimetype ] ]
                    , data := data
                    ]
                  ];
    }
    ELSE
    {
      // Generate PDF from internal htmlversion/embedded_files
      filelist := [ [ path := "/.contents"
                    , headers :=
                        [ [ field := "Content-Type", value := "text/html" ] ]
                    , data := this->htmlversion
                    ]
                  ];
    }
    filelist := filelist
          CONCAT
          (SELECT path := "/" || href
                , headers :=
                    [ [ field := "Content-Type", value := contenttype ] ]
                , COLUMN data
             FROM this->embedded_files)
          CONCAT
          (SELECT path := "/" || GetNameFromPath(filename)
                , headers :=
                    [ [ field := "Content-Type", value := "application/octet-stream" ] ]
                , data := GetDiskResource(filename)
             FROM this->embedded_fonts);
    RETURN filelist;
  }

  ASYNC FUNCTION GeneratePDFInternal(BLOB data, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD ARRAY filelist := this->GetFileList(data);
    IF(Length(filelist) = 0)
      RETURN DEFAULT BLOB;

    OBJECT server := NEW AdHocServer(/*[ logdebug := TRUE ]*/);
    server->PrecacheFiles(filelist);

    RECORD result := AWAIT this->GeneratePDFFromURL(server->baseurl || "/.contents", options);
    server->Close();
    RETURN result;
  }

  PUBLIC ASYNC FUNCTION GeneratePDF(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->PrepareHTMLVersion();
    RETURN AWAIT this->GeneratePDFInternal(DEFAULT BLOB, options);
  }

  PUBLIC ASYNC FUNCTION GeneratePDFFrom(STRING url, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->embedded_files := options.embeddedfiles;
    options := CELL[...options, DELETE embeddedfiles];
    RETURN this->GeneratePDFFromURL(url, options);
  }

  PUBLIC ASYNC FUNCTION GeneratePDFFromURL(STRING url, RECORD options DEFAULTSTO DEFAULT RECORD) {
    // TODO avoid the job, but CallJS is blocking and would block our adhoc server. Once chromeheadlessrunner is a TS service we could just put the generators into that service. Or alternatively replace the adhocserver with something session based
    STRING res := WaitForPromise(AsyncCallFunctionFromJob("wh::javascript.whlib#CallJS", "mod::platform/js/services/puppeteer.ts#generatePDF", url, options ));
    RETURN [ pdf := StringToBlob(DecodeBase64(res))
         ];
  }
>;
