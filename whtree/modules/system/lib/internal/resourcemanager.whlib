<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/semver.whlib";

LOADLIB "mod::tollium/lib/dragdrop.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/webserver/management.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib" EXPORT GetWebhareModules, GetWebhareModuleInfo;
LOADLIB "mod::system/lib/internal/rightsmgmt.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

///Update the server type. Assumes an available primary transaction
PUBLIC MACRO SetSystemServerType(STRING newservertype)
{
  IF(newservertype = ReadRegistryKey("system.global.servertype"))
    RETURN;
  IF(newservertype NOT IN systemservertypes)
    THROW NEW Exception(`Invalid system server type ${newservertype}`);

  GetPrimary()->BeginWork();
  WriteRegistryKey("system.global.servertype", newservertype);
  GetPrimary()->CommitWork();
  UpdateSystemConfigurationRecord();

  BroadcastEvent("system:config.servertype", DEFAULT RECORD);
  //ADDME access rules should listen to servertype themselves?
}

/** @short Refresh the webserver configuration
    @long Ask the webserver to refresh its configuration read from the database and module definitions. The relevant changes need to be already committed. Returns when the webserver is reconfigured
    @return The configuration load status as reported by ConfigureWebserver. */
PUBLIC RECORD FUNCTION RefreshGlobalWebserverConfig(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ nowait := FALSE ], options);

  OBJECT getconfig := ConnectToManagedPort("system:webserver.getconfig", "webserver");
  IF (NOT ObjectExists(getconfig))
    RETURN [ error := "Webserver configuration port not yet available!" ];

  RECORD reloadstatus;
  IF(options.nowait)
  {
    getconfig->SendMessage([ task := "rescan" ]);
  }
  ELSE
  {
    RECORD res := getconfig->DoRequest([ task := "rescan" ]);
    IF (res.status != "ok" OR res.msg.status != "ok")
      THROW NEW Exception("Reloading webserver configuration failed" || AnyToString(res, "tree"));
    reloadstatus := res.msg.reloadstatus;
  }
  getconfig->Close();
  RETURN reloadstatus;
}

///Reload authentication data and/or modules
PUBLIC STRING FUNCTION ReloadWebhareConfig2(STRING toreload, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ isdelete := FALSE, nowait := FALSE ], options);

  STRING id := GenerateUFS128BitId();
  STRING ARRAY parts := toreload = "" ? DEFAULT STRING ARRAY : Tokenize(toreload, ' ');
  IF("AUTHDATA" IN parts OR "ALL" IN parts)
    RefreshGlobalWebserverConfig([ nowait := options.nowait ]);
  BroadcastEvent("system:softreset", [ toreload := parts, id := id, isdelete := options.isdelete ]);
  RETURN id;
}

PUBLIC STRING FUNCTION ReloadWebhareConfig(BOOLEAN authdata, BOOLEAN modules, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  STRING ARRAY toks;
  IF(authdata)
    INSERT "AUTHDATA" INTO toks AT END;
  IF(modules)
  {
    INSERT "MODULES" INTO toks AT END;
    INSERT "MODULEINIT" INTO toks AT END;
  }
  RETURN ReloadWebhareConfig2(Detokenize(toks,' '), options);
}

PUBLIC MACRO SetApplicationAndUserInAuthRecord(RECORD app, RECORD data, OBJECT user)
{
  RECORD authrec := GetAuthenticationRecord();
  IF (CellExists(authrec, "TOLLIUM"))
    DELETE CELL tollium FROM authrec;

  INSERT CELL tollium :=
      [ app :=
            [ name :=           app.name
            , title :=          app.title
            , data :=           data
            ]
      , user :=
            [ realname :=       user->realname
            , emailaddress :=   user->emailaddress
            , language :=       user->language
            , login :=          user->login
            , eventidentifier := user->GetUserEventIdentifier()
            , wrdentityid :=    user->entityid
            , authobjectid :=   user->authobjectid
            ]
      ] INTO authrec;

  SetAuthenticationRecord(authrec);
}

PUBLIC RECORD FUNCTION ApplyAccessCheck(RECORD accesscheck, BOOLEAN makeautotrans, OBJECT user)
{
  RECORD authrec := GetAuthenticationRecord();
  IF (NOT CellExists(authrec, "DATABASE"))
    INSERT CELL database := DEFAULT RECORD INTO authrec;

  // Check rights
  IF (NOT DoAccessCheckFor(accesscheck, user))
    RETURN [ success := FALSE, errorcode:="ACCESCHECK" ]; //(ADDME unclean? if we fail, we'll still have modified global stae through initializerightsweblet)

  OBJECT transobj := GetPrimaryWebhareTransactionObject();
  INTEGER ARRAY roleids;
  authrec.database :=
      [ userid :=       ObjectExists(user) ? user->authobjectid : 0
      , readonly :=     FALSE
      , autotrans :=    TRUE
      ];

  SetAuthenticationRecord(authrec);
  RETURN [ success := TRUE ];
}



// ---------------------------------------------------------------------------
//
// Public API
//


PUBLIC RECORD FUNCTION GetObjectEditor(STRING objeditorname)
{
  STRING modname := Left(objeditorname, SearchSubstring(objeditorname, ':'));
  STRING editorname := Substring(objeditorname, Length(modname)+1);

  RECORD modinfo := GetWebhareModuleInfo(modname);
  IF(RecordExists(modinfo))
  {
    RECORD objeditor := SELECT * FROM modinfo.fs_objecteditors WHERE ToUppercase(name)=ToUppercase(modname || ":" || editorname);
    IF(RecordExists(objeditor))
      RETURN objeditor;
  }
  RETURN DEFAULT RECORD;
}

PUBLIC STRING ARRAY FUNCTION GetModuleDependencyIssues()
{
  STRING ARRAY errors;
  RECORD ARRAY allmods := GetWebhareModules();
  FOREVERY(RECORD mod FROM allmods)
  {
    IF(mod.circulairdependency)
    {
      INSERT "Module " || mod.name || " is involved in a circulair dependency (requires " || Detokenize(mod.dependencies,",") INTO errors AT END;
    }
    FOREVERY(RECORD dep FROM mod.requiredmodules)
    {
      RECORD match := SELECT * FROM allmods WHERE allmods.name = dep.name;
      IF(NOT RecordExists(match))
      {
        INSERT `Module '${mod.name}' requires module '${dep.name}' but it is not installed` INTO errors AT END;
        CONTINUE;
      }
      IF(dep.moduleversion != "" AND NOT VersionSatisfiesRange(match.version, dep.moduleversion))
      {
        INSERT `Module '${mod.name}' requires module '${dep.name}' version ${dep.moduleversion}, got ${match.version}` INTO errors AT END;
        CONTINUE;
      }
    }
  }
  RETURN errors;
}

RECORD FUNCTION GetCacheableGlobalDragTypes()
{
  RECORD ARRAY results;

  STRING ARRAY allmodules := GetInstalledModuleNames();

  FOREVERY(STRING module FROM allmodules)
    allmodules[#module] := ToLowercase(module);

  FOREVERY(STRING module FROM allmodules)
  {
    OBJECT xmldoc;
    TRY
      xmldoc := GetModuleDefinitionXML(module);
    CATCH
      CONTINUE;


    OBJECT ARRAY elts := xmldoc->GetElementsByTagNameNS(whconstant_xmlns_moduledef, "dragtype")->GetCurrentElements();

    FOREVERY (OBJECT elt FROM elts)
    {
      STRING ARRAY flags := Tokenize(elt->GetAttribute("flags"), " ");
      flags := SELECT AS STRING ARRAY flag FROM ToRecordArray(flags, "FLAG") WHERE flag != "";

      STRING library := "module::" || module || "/" || elt->GetAttribute("library");
      STRING objectname := elt->GetAttribute("objectname");

      OBJECT dragtypeobj;
      TRY
      {
        dragtypeobj := MakeObject(library, objectname);
      }
      CATCH (OBJECT e) {}
      IF (NOT ObjectExists(dragtypeobj))
        THROW NEW Exception("Dragtype object '" || library || ":" || objectname || "' could not be found");
      ELSE IF (dragtypeobj NOT EXTENDSFROM DragTypeDescriber)
        THROW NEW Exception("Dragtype object '" || library || ":" || objectname || "' not extending DragTypeDescriber");

      INSERT
          [ name := module || ":" || elt->GetAttribute("name")
          , candownloadflags := elt->GetAttribute("candownloadflags")
          , library := library
          , objectname := objectname
          , flags := flags
          ] INTO results AT END;
    }
  }

  RETURN
      [ ttl :=   24 * 60 * 60 * 1000
      , eventmasks := ["system:modulesupdate"] //flush if any moduledef changes.
      , value := SELECT * FROM results ORDER BY name
      ];
}

PUBLIC RECORD ARRAY FUNCTION GetGlobalDragTypes()
{
  RETURN GetAdhocCached(
      [ type := "globaldragtypes"
      ], PTR GetCacheableGlobalDragTypes);
}

PUBLIC BOOLEAN FUNCTION IsApplicationAccessible(OBJECT user, RECORD apprec)
{
  RETURN DoAccessCheckFor(apprec.accesscheck, user);
}

/** Executes access check
    @return Returns whether the current user doesn't fail any access check
    @param accesscheck Describes the accesscheck to be done
    @cell accesscheck.type Type of the acccesscheck, valid: right, combine
    @cell accesscheck.value Name of right to check for (only valid when @a type = 'right')
    @cell accesscheck.combine Type of combining, valid: 'and', 'or' (only valid when @a type = 'combine')
    @cell accesscheck.checks List of access check records to combine (only valid when @a type = 'combine')
*/
PUBLIC BOOLEAN FUNCTION DoAccessCheckFor(RECORD accesscheck, OBJECT user)
{
  IF (NOT RecordExists(accesscheck) OR (accesscheck.type="combine" AND accesscheck.combine="and" AND Length(accesscheck.checks)=0))
    RETURN TRUE;
  IF (NOT ObjectExists(user))
    RETURN FALSE;

  TRY
  {
    SWITCH (accesscheck.type)
    {
    CASE "right"
      {
        IF (NOT IsRightGlobal(accesscheck.value))
        {
          RETURN user->HasRightOnAny(accesscheck.value);
        }
        ELSE
        {
          RETURN user->HasRight(accesscheck.value);
        }
      }
    CASE "anygrantableright"
      {
        RETURN user->HasAnyGrantableRight();
      }
    CASE "combine"
      {
        SWITCH (accesscheck.combine)
        {
        CASE "and"
          {
            FOREVERY (RECORD check FROM accesscheck.checks)
              IF (NOT DoAccessCheckFor(check, user))
                RETURN FALSE;
            RETURN TRUE;
          }
        CASE "or"
          {
            FOREVERY (RECORD check FROM accesscheck.checks)
              IF (DoAccessCheckFor(check, user))
                RETURN TRUE;
            RETURN FALSE;
          }
        }
        THROW NEW Exception("Unknown combine type " || accesscheck.combine);
      }
    }
    THROW NEW Exception("Unknown access check type " || accesscheck.type);
  }
  CATCH (OBJECT e)
  {
    //ADDME log the error!?
    RETURN FALSE;
  }
}
