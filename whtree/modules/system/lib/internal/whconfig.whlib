<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/semver.whlib";
LOADLIB "wh::internal/wasm.whlib";
LOADLIB "wh::internal/debug.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/registry.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";

PUBLIC CONSTANT STRING ARRAY systemservertypes := ["production","acceptance","test","development"];
CONSTANT STRING ARRAY servicestates := ["startup","started","poststartdone"];

//As changing dtapstage pretty mcuh requires a softreset, but it's often requested, it should be safe to cache on a  VM-level
STRING cacheddtapstage;
//restoration state. 0 if unknown, 1 if not-restore, 2 if restore
INTEGER restorestate;

RECORD buildinfo;

PUBLIC RECORD FUNCTION GetWebhareBuildInfo()
{
  IF(NOT RecordExists(buildinfo))
  {
    buildinfo := CELL[];
    TRY
    {
      BLOB buildinfofile := GetDiskResource(GetModuleInstallationRoot("platform") || "generated/buildinfo");
      IF(Length(buildinfofile) > 0)
      {
        FOREVERY(STRING line FROM Tokenize(BlobToString(buildinfofile),'\n'))
        {
          STRING param := Left(line,SearchSubstring(line,'='));
          IF(param="")
            CONTINUE;

          STRING value := TrimWhitespace(Substring(line, Length(param)+1));
          IF(value LIKE '"*"') //unescape quotes
            value := DecodeJava(Substring(value,1,Length(value)-2));
          buildinfo := CellInsert(buildinfo, param, value);
        }
      }
    }
    CATCH(OBJECT e)
    {
      //ignore buildinfo open failure
    }
  }
  RETURN buildinfo;
}

/** @short Get the server DTAP type
    @topic modules/config
    @public
    @loadlib mod::system/lib/configure.whlib
    @return "production", "acceptance", "test" or "development"
*/
PUBLIC STRING FUNCTION GetDTAPStage()
{
  IF(cacheddtapstage = "")
  {
    cacheddtapstage := GetEnvironmentVariable("WEBHARE_DTAPSTAGE");
    IF(cacheddtapstage NOT IN systemservertypes)
      cacheddtapstage := GetCachedWebHareConfig().servertype;
  }
  RETURN cacheddtapstage;
}

/** @short Is this a restored WebHare
    @topic modules/config
    @public
    @loadlib mod::system/lib/configure.whlib
    @return True if we are a restore and should suppress tasks with external effects, because we may be a clone of a running installation
*/
PUBLIC BOOLEAN FUNCTION IsRestoredWebHare()
{
  IF(restorestate=0)
    restorestate := GetEnvironmentVariable("WEBHARE_ISRESTORED") != "" ? 2 : 1;

  RETURN restorestate = 2;
}

RECORD FUNCTION GetConfigData()
{
  RECORD retval :=
      [ servertype :=     "production"
      , servername :=     ""
      , primaryinterfaceurl := ""

      , __eventmasks :=
          [ "system:registry.system.global"
          , "system:whfs.sitemeta.16" //site 16 (WebHare backend) tells us where the primaryinterfaceurl is
          ]
      ];

  // Might be running before initialization of the registry
  IF (NOT GetPrimary()->ColumnExists("SYSTEM", "FLATREGISTRY", "ID")
      OR ReadRegistryKey("system.global.servertype", [fallback := ""])="")
    RETURN retval;

  retval.servertype := ReadRegistryKey("system.global.servertype");
  retval.servername := ReadRegistryKey("system.global.servername");
  retval.primaryinterfaceurl := (SELECT AS STRING webroot FROM system.sites WHERE id = whconstant_whfsid_webharebackend);

  IF(retval.servertype = "alpha")  //No longer available
    retval.servertype := "development";
  ELSE IF(retval.servertype NOT IN ["production","test","acceptance","development"])
    retval.servertype := "production";
  RETURN retval;
}

RECORD FUNCTION GetCacheableWebHareConfig()
{
  RECORD configdata;

  IF (IsWASM())
    configdata := EM_SYSCALL("webHareConfig");
  ELSE
    configdata := RunInSeparatePrimary(PTR GetConfigData());

  RETURN
      [ value :=        configdata
      , ttl :=          60 * 60 * 1000
      , eventmasks :=   [ "system:internal.configdata","system:config.servertype" ] CONCAT configdata.__eventmasks
      ];
}

PUBLIC RECORD FUNCTION GetcachedWebHareConfig()
{
  RETURN GetAdhocCached([ type := "config" ], PTR GetCacheableWebHareConfig);
}

PUBLIC RECORD FUNCTION GetMyApplicabilityInfo()
{
  RETURN [ versionnum := __SYSTEM_WEBHAREVERSION().versionnum
         , version := GetWebhareBuildInfo().version
         , dtapstage := GetDtapStage()
         , servername := GetEnvironmentVariable("WEBHARE_SERVERNAME") ?? GetcachedWebHareConfig().servername
         , modules := __SYSTEM_GETINSTALLEDMODULENAMES()
         ];
}

PUBLIC STRING FUNCTION GetSemVerFromClassicVersion(INTEGER oldversion)
{
  RETURN `${oldversion/10000}.${oldversion%10000/100}.${oldversion%100}`;
}

/** @short Get a test secret, either from the environment or set using `wh debug setsecret`
    @topic testframework/api
    @public
    @loadlib mod::system/lib/testframework.whlib
*/
PUBLIC STRING FUNCTION GetTestSecret(STRING varname)
{
  RECORD currentconfig := __SYSTEM_GETSYSTEMCONFIG();
  IF(CellExists(currentconfig,'testsecrets') AND CellExists(currentconfig.testsecrets, varname))
  {
    STRING secret := GetCell(currentconfig.testsecrets, varname);
    IF(secret != "")
      RETURN secret;
  }

  RETURN GetEnvironmentVariable("TESTSECRET_" || ToUppercase(varname));
}

STRING FUNCTION GetEnvOrTestVar(STRING varname)
{
  RETURN varname LIKE "TESTSECRET_*" ? GetTestSecret(Substring(varname,11)) : GetEnvironmentVariable(varname);
}

PUBLIC STRING FUNCTION GetApplicabilityError(RECORD webhareversioninfo, RECORD restrictions)
{
  //Support versioninfo without semantic 'version' for backwards compatibility (eg. peering with old webhares)
  STRING semver := CellExists(webhareversioninfo,'version') ? webhareversioninfo.version : GetSemVerFromClassicVersion(webhareversioninfo.versionnum);

  IF(restrictions.webhareversion != "" AND NOT VersionSatisfiesRange(semver, restrictions.webhareversion))
    RETURN `WebHare version '${semver}' does not match required version '${restrictions.webhareversion}'`;

  FOREVERY(STRING mod FROM Tokenize(restrictions.ifmodules,';'))
  {
    mod := TrimWhitespace(mod);
    IF(mod != "" AND mod NOT IN webhareversioninfo.modules)
      RETURN `Module '${mod}' is not installed`;
  }

  STRING stage := webhareversioninfo.dtapstage;
  IF(restrictions.minservertype != "" AND SearchElement(systemservertypes, restrictions.minservertype) < SearchElement(systemservertypes, stage))
    RETURN `Required minimum dtap stage: '${restrictions.minservertype}', current: '${stage}'`;
  IF(restrictions.maxservertype != "" AND SearchElement(systemservertypes, restrictions.maxservertype) > SearchElement(systemservertypes, stage))
    RETURN `Required maximum dtap stage: '${restrictions.maxservertype}', current: '${stage}'`;

  FOREVERY(STRING testvar FROM restrictions.ifenvironset)
  {
    STRING varname := Left(testvar,SearchSubstring(testvar,'=')) ?? testvar;
    STRING varvalue := Substring(testvar,Length(varname)+1);
    STRING actualvalue := GetEnvOrTestVar(varname);

    IF(actualvalue = "")
      RETURN `Required environment variable '${varname}' not set`;
    IF(varvalue != "" AND actualvalue != varvalue)
      RETURN `Environment variable '${varname}' set to '${actualvalue}' not '${varvalue}'`;
  }

  FOREVERY(STRING testvar FROM restrictions.unlessenvironset)
  {
    STRING varname := Left(testvar,SearchSubstring(testvar,'=')) ?? testvar;
    STRING varvalue := Substring(testvar,Length(varname)+1);
    STRING actualvalue := GetEnvOrTestVar(varname);

    IF(varvalue != "" AND actualvalue = varvalue)
      RETURN `Environment variable '${varname}' matches '${varvalue}'`;
    IF(varvalue = "" AND actualvalue != varvalue)
      RETURN `Forbidden environment variable '${varname}' set to '${actualvalue}'`;
  }

  IF(Length(restrictions.restrictservers) > 0)
  {
    BOOLEAN anymatch;
    STRING servername := ToUppercase(webhareversioninfo.servername);
    FOREVERY(STRING servermask FROM restrictions.restrictservers)
      IF(servername LIKE servermask)
      {
        anymatch := TRUE;
        BREAK;
      }

    IF(NOT anymatch)
      RETURN `Restricted to servers: ${ToLowercase(Detokenize(restrictions.restrictservers,", "))}, current: ${webhareversioninfo.servername}`;
  }
  RETURN "";
}
PUBLIC RECORD FUNCTION ReadApplicableToWebHareNode(OBJECT xmlnode, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([prefix := ""], options);

  RECORD appl := CELL[ webhareversion :=     xmlnode->GetAttribute(options.prefix || "webhareversion")
                     , minservertype :=      xmlnode->GetAttribute(options.prefix || "minservertype")
                     , maxservertype :=      xmlnode->GetAttribute(options.prefix || "maxservertype")
                     , restrictservers :=    ParseXSList(ToUppercase(xmlnode->GetAttribute(options.prefix || "restrictservers")))
                     , ifenvironset :=       ParseXSList(xmlnode->GetAttribute(options.prefix || "ifenvironset"))
                     , unlessenvironset :=   ParseXSList(xmlnode->GetAttribute(options.prefix || "unlessenvironset"))
                     , ifmodules :=          xmlnode->GetAttribute(options.prefix || "ifmodules")
                     ];
  INSERT CELL anycheck := appl.webhareversion != ""
                          OR appl.minservertype != ""
                          OR appl.maxservertype != ""
                          OR Length(appl.restrictservers) > 0
                          OR Length(appl.ifenvironset) > 0
                          OR Length(appl.unlessenvironset) > 0
                          OR appl.ifmodules != ""
          INTO appl;
  RETURN appl;

}

/** Returns whether a node with version/servertype/installationtype restrictions is applicable to this WebHare installation
    @topic modules/config
    @public
    @loadlib mod::system/lib/configure.whlib
    @param xmlnode XML node to check
    @cell options.prefix Prefix to add before attribute names. Eg set to 'data-' by <meta> mailer tags
    @return Whether the node is applicable to this WebHare installation.
*/
PUBLIC BOOLEAN FUNCTION IsNodeApplicableToThisWebHare(OBJECT xmlnode, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD check := ReadApplicableToWebHareNode(xmlnode,options);
  IF(NOT check.anycheck)
    RETURN TRUE; //it applies, no actual checks
  RETURN GetApplicabilityError(GetMyApplicabilityInfo(), check) = "";
}

////////////////////////////////////////////////////////////////////////////////
//
// WebHare-wide state changes
//

PUBLIC RECORD FUNCTION PollWHServiceState(STRING waitfor)
{
  INTEGER file;
  TRY
  {
    file := OpenDiskFile(`${__SYSTEM_WHCOREPARAMETERS().basedataroot}caches/platform/run/servicestate.${waitfor}.json`, FALSE);
    IF(file > 0)
    {
      STRING data := ReadFrom(file, 16384);
      IF(data!="")
        RETURN DecodeJSON(data);
    }
  }
  FINALLY
  {
    IF(file>0)
      CloseDiskFile(file);
  }
  RETURN DEFAULT RECORD;
}

MACRO WHServiceStatePromise(STRING waitfor, MACRO PTR onresolve, MACRO PTR onreject)
{
  RECORD data := PollWHServiceState(waitfor);
  IF(RecordExists(data))
  {
    onresolve(data);
    RETURN;
  }

  //ADDME listen events
  RegisterTimedCallback(AddTimeToDate(250, GetCurrentDateTime()), PTR WHServiceStatePromise(waitfor, onresolve, onreject));
}
PUBLIC OBJECT FUNCTION CreateWHServiceStatePromise(STRING waitfor)
{
  IF(waitfor NOT IN servicestates)
    THROW NEW Exception(`Unknown service state '${waitfor}'`);

  RETURN CreatePromise(PTR WHServiceStatePromise(waitfor, #1, #2));
}
/* Update startup state info. We use three different servicestate files so pollers only need to check for file existence and don't have to parse */
PUBLIC MACRO SetWHServiceState(STRING waitingfor, RECORD state)
{
  IF(waitingfor NOT IN servicestates)
    THROW NEW Exception(`Unknown service state '${waitingfor}'`);

  StoreDiskFile(`${__SYSTEM_WHCOREPARAMETERS().basedataroot}caches/platform/run/servicestate.${waitingfor}.json`, StringToBlob(EncodeJSON(state) || "\n"), [ overwrite := TRUE ]);
  BroadcastEvent("system:internal.servicestate." || waitingfor, state);
}

PUBLIC RECORD FUNCTION GetAdhocCacheSettings()
{
  RETURN [ minimum_maxentries := 4096
         , minimum_minperlibrary := 64
         ];
}
PUBLIC MACRO TwistAdhocCacheKnobs(INTEGER maxentries, INTEGER minperlibrary)
{
  RECORD settings := GetAdhocCacheSettings();
  __SYSTEM_SetupAdhocCache(maxentries < settings.minimum_maxentries ? settings.minimum_maxentries : maxentries
                          ,minperlibrary < settings.minimum_minperlibrary ? settings.minimum_minperlibrary : minperlibrary
                          );
}

PUBLIC MACRO UpdateSystemConfigurationRecord(RECORD updates DEFAULTSTO DEFAULT RECORD)
{
  RECORD config := GetCacheableWebHareConfig().value;

  STRING dtapstage := GetEnvironmentVariable("WEBHARE_DTAPSTAGE");
  IF(dtapstage = "" OR dtapstage NOT IN systemservertypes)
    dtapstage := config.servertype;

  RECORD newconfig := CELL
      [ ...__SYSTEM_GETSYSTEMCONFIG()
      , ...config
      , ...updates
      , dtapstage
      ];

  LogDebug("system:systemconfig", newconfig);

  // Update the config. Applies immediately to local record, async to rest of processes (and self again)
  __SYSTEM_SETSYSTEMCONFIG(newconfig);
  cacheddtapstage := "";
}

ASYNC FUNCTION ReadWholeProcessOutput(OBJECT process)
{
  RECORD retval :=
      [ output :=   ""
      , errors :=   ""
      , exitcode := -1
      ];

  OBJECT itr := MakeProcessAsyncIterator(process, [ autoclose := FALSE ]);
  WHILE (TRUE)
  {
    RECORD rec := AWAIT itr->Next();
    IF (rec.done)
      BREAK;
    SWITCH (rec.value.type)
    {
      CASE "output"   { retval.output := retval.output || rec.value.line || "\n"; }
      CASE "error"    { retval.errors := retval.errors || rec.value.line || "\n"; }
      CASE "close"    { retval.exitcode := rec.value.exitcode; }
    }
  }
  RETURN retval;
}

PUBLIC MACRO UpdateDebugSettings(RECORD newsettings, RECORD options DEFAULTSTO DEFAULT RECORD) {
  //FIXME this may still be dangerous, we should go through the service to update config files
  CallJS("@mod-system/js/internal/generation/generator.ts#updateDebugSettings", newsettings, CELL[ verbose := IsDebugTagEnabled("startup"), ...options ]);
  BroadcastLocalEvent("system:configupdate"); //ensure our process synchronously knows about the new settings
}

PUBLIC STRING ARRAY FUNCTION GetDebugTagStringParts(RECORD debugconfig) {
  IF (NOT RecordExists(debugconfig) OR IsDefaultValue(debugconfig.tags))
    RETURN STRING[];

  STRING ARRAY tags := debugconfig.tags;
  IF(debugconfig.outputsession != "default")
    INSERT "session=" || debugconfig.outputsession INTO tags AT END;
  IF(debugconfig.context != "")
    INSERT "context=" || debugconfig.context INTO tags AT END;
  RETURN tags;
}

PUBLIC MACRO MutateDebugSettings(RECORD updates) {
  updates := ValidateOptions([ enable := STRING[]
                             , disable := STRING[]
                             , disable_all := FALSE
                             ], updates, [ title := "updatses" ]);

  STRING ARRAY currenttags := updates.disable_all ? STRING[] : GetDebugTagStringParts(__debugconfig);
  STRING ARRAY withnewtags := GetSortedSet(currenttags CONCAT updates.enable);
  STRING ARRAY finaltags := ArrayDelete(withnewtags, updates.disable);

  RECORD debugconfig := ReadDebugSetting(Detokenize(finaltags,','));
  // Update the configuration record (HareScript)
  UpdateSystemConfigurationRecord(CELL[ debugconfig ]);
  // Update generated platform.json (TypeScript)
  UpdateDebugSettings(debugconfig);
}
