<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/tasks.whlib";


OBJECT FUNCTION PrepareTask(RECORD taskinfo, BOOLEAN debug, RECORD setmeta)
{
  OBJECT taskrunner := MakeObject(taskinfo.objectname);
  IF(NOT taskrunner EXTENDSFROM ManagedTaskBase)
    THROW NEW Exception(`Objecttype '${taskinfo.objectname}' does not extend from ManagedTaskBase`);

  taskrunner->debug := debug;
  taskrunner->__taskmeta := setmeta;
  IF(debug)
    Print("Preparing task of type " || taskinfo.tasktype || "\n");

  taskrunner->PrepareTask(taskinfo.data);
  RETURN taskrunner;
}

RECORD FUNCTION ExecuteTask(OBJECT taskrunner, RECORD taskinfo)
{
  IF(taskrunner->debug)
    Print("Handling task of type " || taskinfo.tasktype || "\n");

  SetTidLanguage("en"); //reset the current language, mail tasks might change it

  IF(NOT RecordExists(taskrunner->pvt_resolution))
    taskrunner->RunTask(taskinfo.data);

  IF(NOT RecordExists(taskrunner->pvt_resolution))
    THROW NEW Exception("No resolution selected for the current task");

  RETURN taskrunner->pvt_resolution;
}

PUBLIC RECORD FUNCTION ExecuteEphemeralTask(RECORD taskinfo, BOOLEAN debug)
{
  OBJECT taskrunner := PrepareTask(taskinfo, debug, [ taskid := 0 ]);

  RECORD resolution := ExecuteTask(taskrunner, taskinfo);
  BOOLEAN hadworkopen := GetPrimary()->IsWorkOpen();
  IF (hadworkopen)
    GetPrimary()->RollbackWork();
  IF (NOT RecordExists(resolution) OR NOT CellExists(resolution,'type'))
    RETURN [ type := "taskfailed", error := "Could not read task result", trace := DEFAULT RECORD ARRAY, isfatal := TRUE ];

  IF(resolution.type = "restart")
    THROW NEW Exception("Task restarting is not supported for ephemeral tasks");

  IF (hadworkopen)
    RETURN [ type := "taskfailed", error := "Task did not close work", trace := DEFAULT RECORD ARRAY, isfatal := TRUE ];

  IF(resolution.type = "finished")
    RETURN [ type := "taskdone", result := resolution.result ];

  THROW NEW Exception(`Unexpected resolution type '${resolution.type}'`);
}

PUBLIC RECORD FUNCTION ExecuteManagedTask(RECORD taskinfo, BOOLEAN debug)
{
  IF(taskinfo.taskrunner != "") //this is a JavaScript task
    RETURN WaitForPromise(CallAsync("@mod-system/js/internal/tasks/taskrunner.ts#executeManagedTask",VARIANT[taskinfo, debug]));

  OBJECT trans := GetPrimary();
  OBJECT taskrunner := PrepareTask(taskinfo, debug, [ taskid := taskinfo.dbid ]);

  IF (taskrunner->mutex != "")
    trans->BeginLockedWork(taskrunner->mutex);
  ELSE
    trans->BeginWork();

  IF(NOT RecordExists(SELECT FROM system_internal.managedtasks WHERE id=taskinfo.dbid))
    THROW NEW Exception("Task suddenly disppeared!");

  RECORD resolution := ExecuteTask(taskrunner, taskinfo);

  IF(resolution.type="restart")
  {
    IF(debug)
      Print("Task requested restart\n");

    DATETIME nexttry := GetCurrentDatetime();
    IF(nexttry < resolution.when)
      nexttry := resolution.when;

    UPDATE system_internal.managedtasks
           SET nextattempt := nexttry
             , iterations  := iterations + 1
             , taskdata    := RecordExists(resolution.options.newdata) ? EncodeHSON(resolution.options.newdata) : managedtasks.taskdata
             , auxdata     := RecordExists(resolution.options.auxdata) ? EncodeHSONBlob(resolution.options.auxdata) : managedtasks.auxdata
             , lasterrors  := ""
             , failures    := 0 // a succesful restart should cancel the failure/backoff timer
           WHERE id = taskinfo.dbid
                 AND NOT iscancelled; //do not restart tasks marked as cancelled (which may happen in parallel, especially in CI)
  }
  ELSE IF(resolution.type="finished")
  {
    IF(debug)
      Print("Task said 'done'\n");

    STRING result := RecordExists(resolution.result) ? EncodeHSON(resolution.result) : "";
    UPDATE system_internal.managedtasks
           SET lasterrors := ""
             , finished := GetCurrentDatetime()
             , shortretval := Length(result) > 1000 ? "long" : result
             , longretval := Length(result) > 1000 ? StringToBlob(result) : DEFAULT BLOB
           WHERE id = taskinfo.dbid;
  }
  ELSE IF(resolution.type = "failed" OR resolution.type = "cancelled")
  {
    IF(debug)
      Print("Task said '" || resolution.type || "'\n");

    STRING result := RecordExists(resolution.result) ? EncodeHSON(resolution.result) : "";
    UPDATE system_internal.managedtasks
           SET lasterrors := resolution.error
             , iscancelled := resolution.type = "cancelled"
             , finished := GetCurrentDatetime()
             , shortretval := Length(result) > 1000 ? "long" : result
             , longretval := Length(result) > 1000 ? StringToBlob(result) : DEFAULT BLOB
           WHERE id = taskinfo.dbid;
  }
  ELSE IF(resolution.type="failedtemporarily")
  {
    IF(debug)
      Print("Task said '" || resolution.type || "'\n");

    trans->RollbackWork();
    RETURN CELL[ type := "taskfailed"
               , error := resolution.error
               , nextretry := resolution.nextretry
               , result := resolution.result
               , isfatal := FALSE
               , trace := resolution.trace
               ];
  }
  ELSE
  {
    THROW NEW Exception(`Unexpected resolution type '${resolution.type}'`);
  }
  trans->BroadcastOnCommit("system:managedtasks.any." || taskinfo.dbid, DEFAULT RECORD);
  trans->BroadcastOnCommit("system:managedtasks." || taskinfo.tasktype || "." || taskinfo.dbid, DEFAULT RECORD);

  trans->CommitWork();
  RETURN CELL[ type := "taskdone"
             , resolution
             ];
}
