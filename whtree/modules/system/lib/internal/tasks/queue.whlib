<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::money.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/tasks.whlib";
LOADLIB "mod::system/lib/internal/taskqueue.whlib";
LOADLIB "mod::system/lib/internal/tasks/queueapi.whlib";
LOADLIB "mod::system/lib/internal/tasks/recordslogfile.whscr";


PUBLIC CONSTANT INTEGER debuglevel_none := 0;
PUBLIC CONSTANT INTEGER debuglevel_error := 1;
PUBLIC CONSTANT INTEGER debuglevel_queue := 2;
PUBLIC CONSTANT INTEGER debuglevel_comm := 3;
PUBLIC CONSTANT INTEGER debuglevel_task := 4;
PUBLIC CONSTANT INTEGER debuglevel_all := 5;


PUBLIC INTEGER64 FUNCTION GetTimestamp()
{
  RETURN GetUnixTimestampMsecs(GetCurrentDateTime());
}

/** Work items for the persistent queue
*/
OBJECTTYPE PersistentQueueItem EXTEND QueueItem
< /// Task data
  PUBLIC RECORD taskdata;

  /// Id for the taskdata content
  PUBLIC STRING taskcontentid;

  /** Create a new work item
      @param queuekeeper Queue keeper for this item
      @param data Queue item data @includecelldef #QueueItem::NEW.initialdata
      @cell data.taskdata Queue task data
      @cell data.taskcontentid Queue task data content id (for deduplication)
  */
  MACRO NEW(OBJECT queuekeeper, RECORD data)
  : QueueItem(queuekeeper, CELL[ data.priority, data.queuename, data.scheduledate, data.onfinished ])
  {
    this->taskdata := data.taskdata;
    this->taskcontentid := data.taskcontentid;
  }
>;

/** Persistent, disk-based queue (saves the current state to disk)
*/
PUBLIC STATIC OBJECTTYPE PersistentDiskQueue
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// @type(object #QueueKeeper) Queue keeper
  OBJECT queue;

  /// Name for the queue in the queue keeper
  STRING queuename;

  /// Task type
  STRING tasktype;

  /// IPC port for commands
  OBJECT commandport;

  /// Number of active command links
  INTEGER linkcount;

  /// @type(object %PromiseBase) Promise for main loop when it is running
  OBJECT mainlooppromise;

  /// Debug level
  INTEGER debuglevel;

  /// Whether to print debug messages to stdout
  BOOLEAN debugprint;

  /// Whether currently scheduling new work items
  BOOLEAN assigningwork;

  /// Running actions (promises for ephemeral tasks)
  OBJECT ARRAY running_actions;

  /** Active queue items
      @cell(string) taskcontentid Task content id
      @cell(integer64) id Item id
      @cell(object) item Item object
  */
  RECORD ARRAY queueitems;

  /// Rewrite the persistent log this nr of msecs after the first item finish
  INTEGER rewriteinterval;

  /// Callback id for rewrite
  INTEGER rewritecb;

  /// Object that keeps the persistent records log
  OBJECT recordslog;

  // ---------------------------------------------------------------------------
  //
  // Initialization
  //

  /** Create a new persistent queue
      @param tasktype Type of tasks (executed by ephemeral queue)
      @cell options.debuglevel Debugging level
      @cell(boolean) options.debugprint Print to stdout instead of debug log
      @cell(boolean) options.cleanqueue If TRUE, ignore the stored queue when starting up
  */
  MACRO NEW(STRING tasktype, RECORD options)
  {
    options := ValidateOptions(
        [ debuglevel := debuglevel_none
        , debugprint := FALSE
        , cleanqueue := FALSE
        ], options, [ passthrough := TRUE ]);

    this->queue := NEW QueueKeeper;
    this->queue->ongotrunnable := PTR this->AssignWork();
    this->queuename := tasktype;

    this->debuglevel := options.debuglevel;
    this->debugprint := options.debugprint;

    //FIXME: Check if there's no other PersistentQueue for this tasktype!
    this->tasktype := tasktype;

    this->rewriteinterval := 60 * 60 * 1000;

    IF (this->debuglevel >= debuglevel_comm)
      this->DebugLog(`  Creating IPC port ${command_portname || this->tasktype}`);
    this->commandport := CreateGlobalIPCPort(`${command_portname || this->tasktype}`);

    STRING recordslogdir := GetModuleStorageRoot("system") || "persistentqueues/" || Substitute(this->tasktype, ":", "/") || "/";
    CreateDiskDirectoryRecursive(recordslogdir, TRUE);

    this->recordslog := NEW RecordsLogFile(MergePath(recordslogdir, "queuelog"));
    IF (options.cleanqueue)
    {
      IF (this->debuglevel >= debuglevel_comm)
        this->DebugLog(`  Writing empty list to record log file`);
      this->RewriteRecordsLog();
    }
  }

  BOOLEAN FUNCTION IsActive()
  {
    RETURN ObjectExists(this->mainlooppromise);
  }

  MACRO GotCommandPortSignalled()
  {
    OBJECT link := this->commandport->Accept(DEFAULT DATETIME);
    IF (ObjectExists(link))
      this->HandleLink(link);
  }

  ASYNC MACRO RunService()
  {
    (AWAIT GetAsyncControl())->autolinkcancel := TRUE;
    AWAIT 1; // Make sure Run() fills the mainloop promise.

    // IsActive() now returns TRUE! Will do so until we return.
    this->ReadQueue();

    // Schedule rewrite of the records log, we might have a lot of garbage
    IF (this->rewritecb = 0)
      this->rewritecb := RegisterTimedCallback(AddTimeToDate(1 * 60 * 1000, GetCurrentDateTime()), PTR this->GotIntervalRewrite);

    WHILE (TRUE)
    {
      AWAIT this->commandport->AsyncWaitRead(MAX_DATETIME);
      OBJECT link := this->commandport->Accept(DEFAULT DATETIME);
      IF (ObjectExists(link))
      {
        IF (this->debuglevel >= debuglevel_comm)
          this->DebugLog(`  Incoming link, active: ${this->linkcount+1}`);

        this->HandleLink(link);
      }

      // Throttle a bit when there are too many active links
      IF (this->linkcount > 100)
      {
        IF (this->debuglevel >= debuglevel_comm)
          this->DebugLog(`  Too much active links, throttling`);
        WaitUntil(DEFAULT RECORD, AddTimeToDate(this->linkcount / 100, GetCurrentDateTime()));
      }
    }
  }

  ASYNC MACRO HandleLink(OBJECT link)
  {
    this->linkcount := this->linkcount + 1;
    TRY
    {
      RECORD res := AWAIT link->AsyncReceiveMessage(MAX_DATETIME);
      IF (res.status = "ok" AND this->IsActive()) // we may have shut down already
      {
        IF (this->debuglevel >= debuglevel_comm)
          this->DebugLog(`  Received command`);
        this->ProcessCommand(res.msg, link, res.msgid);
      }
      ELSE IF (this->debuglevel >= debuglevel_error)
        this->DebugLog("! Did not receive command");
    }
    CATCH (OBJECT e)
      LogHareScriptException(e);
    link->Close();
    this->linkcount := this->linkcount - 1;
  }

  MACRO ProcessCommand(RECORD data, OBJECT ipc_conn, INTEGER64 ipc_msgid)
  {
    IF (this->debuglevel >= debuglevel_all)
      this->DebugLog("  Processing command", data.action, CELL[...data, DELETE action]);
    SWITCH (data.action)
    {
      CASE "SHUTDOWN"
      {
        IF (this->debuglevel >= debuglevel_all)
          this->DebugLog("# Shutdown request received");
        IF (ObjectExists(ipc_conn))
          ipc_conn->SendReply([ status := "ok" ], ipc_msgid);
        this->Shutdown();
      }
      CASE "SCHEDULE"
      {
        RECORD taskdata := CELL[ priority := 0, ...data.task ];
        this->PushTask(CELL[ ...taskdata, DELETE priority ], CELL[ taskdata.priority ]);
        ipc_conn->SendReply([ status := "queued" ], ipc_msgid);
      }
      CASE "SCHEDULEMULTIPLE"
      {
        FOREVERY (RECORD task FROM data.task.tasks)
        {
          RECORD taskdata := CELL[ priority := 0, ...task ];
          this->PushTask(CELL[ ...taskdata, DELETE priority ], CELL[ taskdata.priority ]);
        }
        ipc_conn->SendReply([ status := "queued" ], ipc_msgid);
      }
      CASE "STATE"
      {
        IF (this->debuglevel >= debuglevel_all)
          this->DebugLog("  Got state request");

        RECORD state := this->queue->GetState();
        ipc_conn->SendReply(CELL
            [ status :=     "ok"
            , running :=    (SELECT AS RECORD ARRAY CELL[ item->taskdata, item->date_running ] FROM ToRecordArray(state.running, "ITEM"))
            , runnable :=   0
            , timedwait :=  0
            , ...(SELECT * FROM state.queues WHERE queuename = this->queuename)
            ], ipc_msgid);
      }
      DEFAULT
      {
        IF (this->debuglevel >= debuglevel_error)
          this->DebugLog(`! Unrecognized command '${data.action}'`);
      }
    }
  }

  MACRO Shutdown()
  {
    this->mainlooppromise->Cancel();
  }

  MACRO PushTask(RECORD taskdata, RECORD options)
  {
    options := ValidateOptions(
          [ writetolog :=   TRUE
          , priority :=     0
          , scheduledate := DEFAULT DATETIME
          ], options);

    STRING taskcontentid := this->GetTaskContentId(taskdata);

    RECORD ARRAY items := RecordRange(this->queueitems, CELL[ taskcontentid ], [ "TASKCONTENTID" ]);
    FOREVERY (RECORD rec FROM items)
    {
      IF (rec.item->stage = "scheduled")
      {
        IF (this->debuglevel >= debuglevel_all)
          this->DebugLog(`  Found an scheduled item #${rec.item->id}, updating that item instead`);

        IF (rec.item->priority > options.priority)
        {
          rec.item->priority := options.priority;
          this->recordslog->AppendRecords([ CELL[ type := "update", rec.item->id, rec.item->taskcontentid, rec.item->priority ] ]);
        }
        RETURN;
      }
    }

    OBJECT item := NEW PersistentQueueItem(this->queue, CELL
        [ taskdata
        , options.priority
        , taskcontentid
        , queuename :=      this->queuename
        , options.scheduledate
        , onfinished :=     PTR this->GotItemFinished
        ]);

    IF (this->debuglevel >= debuglevel_all)
      this->DebugLog("  Scheduled item #" || item->id);

    RECORD rec := CELL
        [ taskcontentid
        , item
        , item->id
        ];
    INSERT rec INTO this->queueitems AT RecordUpperBound(this->queueitems, rec, [ "TASKCONTENTID", "ID" ]);

    IF (options.writetolog)
      this->recordslog->AppendRecords([ CELL[ type := "new", item->id, item->taskcontentid, item->taskdata, item->priority ] ]);
  }

  MACRO GotIntervalRewrite()
  {
    this->rewritecb := 0;
    this->RewriteRecordsLog();
  }

  MACRO GotItemFinished(OBJECT item)
  {
    IF (this->debuglevel >= debuglevel_all)
      this->DebugLog("  Item #" || item->id || " marked as finished");

    RECORD pos := RecordLowerBound(this->queueitems, CELL[ item->taskcontentid, item->id ], [ "TASKCONTENTID", "ID" ]);
    IF (pos.found)
      DELETE FROM this->queueitems AT pos.position;

    this->recordslog->AppendRecords([ CELL[ type := "finished", item->id, item->taskcontentid, item->taskdata ] ]);
    // Schedule rewrite after an hour
    IF (this->rewritecb = 0)
      this->rewritecb := RegisterTimedCallback(AddTimeToDate(this->rewriteinterval, GetCurrentDateTime()), PTR this->GotIntervalRewrite);

    this->AssignWork();
  }

  /// Check for new work, assign if work/workers available
  MACRO AssignWork()
  {
    IF (this->assigningwork)
      RETURN;
    this->assigningwork := TRUE;

    IF (this->debuglevel >= debuglevel_all)
      this->DebugLog("  Assigning work, currently active: " || LENGTH(this->running_actions));

    WHILE (LENGTH(this->running_actions) < 1)
    {
      OBJECT item := this->queue->GetNextRunnable(this->queuename);
      IF (NOT ObjectExists(item))
        BREAK;

      item->stage := "running";
      this->RunTask(item);
    }

    this->assigningwork := FALSE;
  }

  ASYNC MACRO RunTask(OBJECT item)
  {
    OBJECT promise;
    TRY
    {
      IF (this->debuglevel >= debuglevel_queue)
        this->DebugLog(`> Running task #${item->id}`, EncodeHSON(item->taskdata));

      promise := RunInSeparatePrimary(PTR ScheduleEphemeralTask(this->tasktype, CELL[ debug := this->debuglevel > debuglevel_task, task := item->taskdata ]));

      // No AWAITs before this point, this instruction needs to run synchronously with function invokation!
      INSERT promise INTO this->running_actions AT END;

      RECORD result := AWAIT promise;

      // Ignore everything when shutting down
      IF (NOT this->IsActive())
        RETURN;

      item->stage := "finished";

      IF (this->debuglevel >= debuglevel_queue)
        this->DebugLog(`< Have result for task with id ${item->id}: ${EncodeHSON(result)}`);
    }
    CATCH (OBJECT error)
    {
      // Ignore everything when shutting down
      IF (NOT this->IsActive())
        RETURN;

      item->stage := "finished";
      IF (this->debuglevel >= debuglevel_error)
        this->DebugLog(`! Error for task with id ${item->id}: ${error->what}`);

      this->HandleTaskError(item, error);
    }

    INTEGER pos := SearchElement(this->running_actions, promise);
    IF (pos >= 0)
      DELETE FROM this->running_actions AT pos;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO DebugLog(STRING message, VARIANT ARRAY ...debugargs)
  {
    IF (this->debugprint)
    {
      FOREVERY (VARIANT v FROM debugargs)
        IF (TypeID(v) = TypeID(STRING))
          message := message || ` ${v}`;
        ELSE
          message := message || ` ${EncodeHSON(v)}`;
      Print(message || "\n");
    }
    ELSE
      CallMacroPtrVA(PTR LogDebug, VARIANT[ "system:persistentqueue", this->tasktype, message, ...debugargs ]);
  }

  // ---------------------------------------------------------------------------
  //
  // Persistent queue
  //

  MACRO ReadQueue()
  {
    RECORD ARRAY items;
    BOOLEAN readall;
    OBJECT itr := this->recordslog->ReadAllRecords();
    WHILE (TRUE)
    {
      RECORD rec;
      TRY
        rec := itr->Next();
      CATCH (OBJECT e)
      {
        LogHareScriptException(e);
        BREAK;
      }
      IF (rec.done)
      {
        readall := rec.value;
        BREAK;
      }

      RECORD pos := RecordLowerBound(items, rec.value, [ "ID" ]);
      SWITCH (rec.value.type)
      {
        CASE "new"
        {
          INSERT CELL[ rec.value.taskcontentid, rec.value.taskdata, rec.value.id, rec.value.priority ] INTO items AT pos.position;
        }
        CASE "update"
        {
          IF (pos.found)
            items[pos.position].priority := rec.value.priority;
        }
        CASE "finished"
        {
          IF (pos.found)
            DELETE FROM items AT pos.position;
        }
      }
    }

    IF (this->debuglevel >= debuglevel_all)
      this->DebugLog(`  Read ${LENGTH(items)} items from persistent records log\n`);

    FOREVERY (RECORD rec FROM items)
      this->PushTask(rec.taskdata, CELL[ rec.priority, writetolog := FALSE ]);

    IF (NOT readall)
      this->RebuildPersistentQueue();
  }

  /// Rewrite the record log with only the current items
  MACRO RewriteRecordsLog()
  {
    RECORD ARRAY items :=
        SELECT type := "new"
             , id := item->id
             , taskcontentid := item->taskcontentid
             , taskdata := item->taskdata
             , priority := item->priority
          FROM this->queueitems;

    this->recordslog->Rewrite(items);
  }

  // ---------------------------------------------------------------------------
  //
  // Update functions
  //

  /** Returns a string that identifies the contents task (for coalescing re-schedules)
      @param task Task record
      @return Task content id
  */
  STRING FUNCTION GetTaskContentId(RECORD task)
  {
    RETURN `${task.id}`;
  }

  /** Update to try to rebuild the queue after a failure to correctly restore
      (if possible)
  */
  MACRO RebuildPersistentQueue()
  {
  }

  /** Update for custom error handling
      @param(object #PersistentQueueItem) item Queue item
      @param(object %Exception) error Exception
  */
  MACRO HandleTaskError(OBJECT item, OBJECT error)
  {
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /// Start processing the queue
  PUBLIC MACRO Run()
  {
    IF (ObjectExists(this->mainlooppromise))
      THROW NEW Exception(`Already running`);

    OBJECT runresult := this->RunService();
    this->mainlooppromise := runresult;
    TRY
      WaitForPromise(runresult);
    CATCH (OBJECT< OperationCancelledException > e)
    {
      // No need to error out when the loop is cancelled
    }

    this->mainlooppromise := DEFAULT OBJECT;

    // We're now inactive, results aren't recorded anymore
    FOREVERY (OBJECT action FROM this->running_actions)
      action->Cancel();

    // Don't rewrite the log, we want shutting down to be fast
  }
>;