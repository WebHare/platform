<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::internal/jobs.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::util/eventemitter.whlib";


// Base object type for objects created by RunWebHareService's constructor. This interface is not made available to the
// connecting client (i.e. through OpenWebHareService)
PUBLIC STATIC OBJECTTYPE WebHareServiceProxyBase
< STRING __servicename;
  OBJECT __link;

  MACRO NEW(STRING servicename DEFAULTSTO "(unknown)")
  {
    this->__servicename := servicename;
  }

  // Called when the link is closed
  PUBLIC MACRO OnClose()
  {
  }

  // Emit an event to the client
  PUBLIC MACRO EmitEvent(STRING event, RECORD data)
  {
    RECORD outmsg := CELL[ event, data ];
    RECORD res := this->__link->SendMessage(outmsg);

    IF (res.status != "ok")
      THROW NEW ServiceDisconnectException(this->__servicename, TRUE);
  }
>;

PUBLIC OBJECTTYPE ClusteredServiceBase EXTEND EventEmitter
<
  STRING __servicename;
  OBJECT __link;
  RECORD ARRAY __calllist;
  INTEGER __listener;
  FUNCTION PTR ARRAY __onclose;

  /** @private
      @param description Service description
      @param(object wh::internal/jobs.whlib#IPCLinkEndPoint) link Connection IPC link
  */
  MACRO NEW(STRING servicename, RECORD description, OBJECT link)
  {
    this->__servicename := servicename;
    this->__link := link;
    link->autothrow := FALSE;
    ReconstructInvokables(this, description, PTR this->__AsyncRemotingFunc);
    this->__listener := RegisterHandleReadCallback(link->handle, PTR this->__IncomingResult);
  }

  /** Calls a remote function asynchronously
      @param tocall Function to call
      @param args Arguments
      @return Promise for the result
  */
  ASYNC FUNCTION __AsyncRemotingFunc(STRING tocall, VARIANT ARRAY args) __ATTRIBUTES__(SKIPTRACE, VARARG)
  {
    IF (NOT ObjectExists(this->__link))
      THROW NEW ServiceDisconnectException(this->__servicename, TRUE);

    RECORD req := CreateDeferredPromise();

    RECORD outmsg := [ call := tocall, args := args ];

    RECORD res := this->__link->SendMessage(outmsg);

    IF(res.status != "ok")
      THROW NEW ServiceDisconnectException(this->__servicename, TRUE);

    // Add a waiting registration
    RECORD reg := [ replyto := res.msgid, resolve := req.resolve, reject := req.reject ];
    INSERT reg INTO this->__calllist AT RecordUpperBound(this->__calllist, reg, [ "REPLYTO" ]);

    // Wait for the response
    RETURN AWAIT req.promise;
  }

  MACRO __IncomingResult()
  {
    RECORD msg := this->__link->ReceiveMessage(DEFAULT DATETIME);

    IF (msg.status = "timeout") // Spurious wakeup
      RETURN;

    IF (msg.status = "gone")
    {
      //Uh oh. We are doomed. Reject all promises
      this->CloseService();
      RETURN;
    }

    // This is an event emitted on the WebHareServiceProxyBase
    IF (CellExists(msg.msg, "EVENT"))
    {
      this->EmitEvent(msg.msg.event, msg.msg.data);
      RETURN;
    }

    IF (msg.replyto != 0)
    {
      RECORD pos := RecordLowerBound(this->__calllist, msg, [ "REPLYTO" ]);
      IF (NOT pos.found)
      {
        ABORT("Received unexpected reply to " || msg.replyto);
      }

      RECORD hit := this->__calllist[pos.position];
      DELETE FROM this->__calllist AT pos.position;

      IF (CellExists(msg.msg, "__exception"))
      {
        hit.reject(DecodeReceivedException(msg.msg.__exception));
      }
      ELSE
      {
        IF(CellExists(msg.msg,'result'))
          hit.resolve(msg.msg.result); //No ?…:… here... result may not be boolean
        ELSE
          hit.resolve(FALSE);
      }
      RETURN;
    }

    THROW NEW Exception(`Misunderstood incoming message`);
  }

  PUBLIC MACRO __ScheduleCallbackOnServiceClose(FUNCTION PTR onclose)
  {
    INSERT onclose INTO this->__onclose AT END;
  }

  /// Closes the service
  PUBLIC MACRO CloseService()
  {
    IF (this->__listener != 0)
      UnregisterCallback(this->__listener);
    this->__listener := 0;
    FOREVERY(RECORD toreject FROM this->__calllist)
      toreject.reject(NEW ServiceDisconnectException(this->__servicename, FALSE));
    FOREVERY (FUNCTION PTR f FROM this->__onclose)
      f();
    IF (ObjectExists(this->__link))
      this->__link->Close();
    this->__link := DEFAULT OBJECT;
    RETURN;
  }
>;

/** Exception thrown when the connection to a service was lost
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC STATIC OBJECTTYPE ServiceDisconnectException EXTEND Exception
<
  /// If TRUE, the connection was disconnected before the current message arrived at the recipient. If FALSE, it's unknown whether the recipient processed your message
  PUBLIC BOOLEAN beforerequest;
  /// @private
  MACRO NEW(STRING servicename, BOOLEAN beforerequest) : Exception(`Connection to cluster service ${EncodeJSON(servicename)} lost`)
  {
    this->beforerequest := beforerequest;
  }
>;

/** Exception thrown when a service is unavailable
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC OBJECTTYPE ServiceUnavailableException EXTEND Exception
< /** @private
      @param servicename Name of the service
  */
  MACRO NEW(STRING servicename) : Exception(`Service ${EncodeJSON(servicename)} is unavailable`)
  {

  }
>;

PUBLIC MACRO ReconstructInvokables(OBJECT targetobject, RECORD description, FUNCTION PTR remotingfunc)
{
  OBJECT privptr := __HS_INTERNAL_MakeObjectReferencePrivileged(targetobject);

  FOREVERY (RECORD method FROM description.methods)
  {
    RECORD ARRAY params :=
        [ [ source :=       0
          , value :=        method.name
          ]
        ];

    FOREVERY (RECORD methodparam FROM method.signdata.params)
    {
      RECORD param;
      IF (methodparam.type != 0)
        INSERT CELL type := methodparam.type INTO param;
      INSERT CELL source := methodparam.has_default ? -#methodparam - 1 : #methodparam + 1 INTO param;
      INSERT param INTO params AT END;
    }

    BOOLEAN is_vararg := method.signdata.excessargstype != 0;
    FUNCTION PTR rebound := __HS_REBINDFUNCTIONPTR2(
        remotingfunc,
        params,
        LENGTH(method.signdata.params) + 1,
        is_vararg);

    MemberInsert(privptr, method.name, FALSE, rebound);
  }
}

PUBLIC RECORD FUNCTION DescribePublicInterface(OBJECT inobj)
{
  // If the object extends from WebHareServiceProxyBase, exclude all public methods from the base class, otherwise (for
  // legacy objects) only exclude "ONCLOSE"
  STRING ARRAY basemethods;
  IF (inobj EXTENDSFROM WebHareServiceProxyBase)
    basemethods :=
        SELECT AS STRING ARRAY name
          FROM __INTERNAL_DescribeObjectStructure(NEW WebHareServiceProxyBase("")).methods
         WHERE is_public
               AND name NOT LIKE "__*";
  ELSE
    basemethods := [ "ONCLOSE" ];

  RECORD ARRAY methods := __INTERNAL_DescribeObjectStructure(inobj).methods;
  methods :=
      SELECT name
           , signdata := GetRawFunctionPtrSignature(GetObjectMethodPtr(inobj, name))
        FROM methods
       WHERE is_public
             AND name NOT IN basemethods
             AND name NOT LIKE "__*";
  RETURN CELL[ methods ];
}

MACRO GotServiceStartEvent(FUNCTION PTR resolve, STRING event, RECORD data)
{
  resolve(TRUE);
}


PUBLIC OBJECT ASYNC FUNCTION CreateServiceStartWait(STRING service, INTEGER timeout)
{
  RECORD defer := CreateDeferredPromise();
  RegisterTimedCallback(AddTimeToDate(timeout, GetCurrentDateTime()), PTR defer.resolve(FALSE));
  INTEGER event_cb := RegisterEventCallback("system:webhareservice." || service || ".start", PTR GotServiceStartEvent(defer.resolve, #1, #2));

  BOOLEAN retval := AWAIT defer.promise;

  // We'll ignore the timer, it will remove itself after firing
  UnregisterCallback(event_cb);

  RETURN retval;
}

PUBLIC VARIANT FUNCTION InvokeOnServiceManager(STRING method, VARIANT ARRAY args) {
  //notOnDemand to prevent a loop if platform:servicemanager itself is unavailable
  OBJECT smservice := __OpenSynchronousWebHareService("platform:servicemanager", [ timeout := 5000 ]);
  TRY {
    RETURN CallAnyPtrVA(GetObjectMethodPtr(smservice, method), args);
  } FINALLY {
    smservice->CloseService();
  }
}

ASYNC MACRO AttemptAutoStart(STRING servicename) {
  //TODO avoid a thundering herd, throttle repeated auto starts from our side
  //TODO check configuration (where will we persist the service list) whether this service can be started on demand
  InvokeOnServiceManager("startService", VARIANT[ servicename ]);
}

PUBLIC BOOLEAN FUNCTION IsServiceRunning(STRING servicename) {
  RECORD state := InvokeOnServiceManager("getWebHareState", VARIANT[]);
  RETURN RecordExists(SELECT FROM state.availableServices WHERE name = servicename AND isrunning);
}

PUBLIC MACRO RestartService(STRING servicename) {
  RECORD result := InvokeOnServiceManager("restartService", VARIANT[ servicename ]);
  IF(result.errormessage)
    THROW NEW Exception(result.errormessage);
}

/** Open a WebHare service
    @param servicename Name of the service (should follow the 'module:tag' pattern)
    @cell(variant array) options.arguments Arguments for the service
    @cell(integer) options.timeout Connect timeout, defaults to 30 seconds
    @cell(boolean) options.notondemand Do not try to autostart an ondemand service
    @return A proxy offering ASYNC versions of the service API
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC OBJECT ASYNC FUNCTION OpenWebHareService(STRING servicename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ arguments := VARIANT[]
                             , timeout := 30000
                             , notondemand := FALSE
                             ], options);

  //FIXME don't assume servicename matches servicetag... we should be looking up the <internalservice tag=".... "
  OBJECT mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
  IF (NOT ObjectExists(mgrport))
  {
    // Start a listen to the start event (async function but listener registration is synchronous)
    OBJECT startpromise := CreateServiceStartWait(servicename, options.timeout);

    IF(NOT options.notondemand)
      AttemptAutoStart(servicename);

    // Check for the port to exist (it might have been created before the event listen started)
    mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
    IF (NOT ObjectExists(mgrport))
    {
      AWAIT startpromise;
      mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
      IF (NOT ObjectExists(mgrport))
        THROW NEW ServiceUnavailableException(servicename);
    }
  }

  mgrport->autothrow := TRUE;
  RECORD response := AWAIT mgrport->AsyncDoRequest( [ __new := options.arguments ] );
  IF(response.status = "gone")
    THROW NEW ServiceDisconnectException(servicename, FALSE);

  RETURN NEW ClusteredServiceBase(servicename, response.msg, mgrport);
}

/** Schedules a function to be called when a service closes
    @param service Service
    @param onclose Function to call when the service closes
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC MACRO ScheduleCallbackOnServiceClose(OBJECT service, FUNCTION PTR onclose)
{
  service->__ScheduleCallbackOnServiceClose(onclose);
}

/** Synchronous version of service api, internal use only
*/
OBJECTTYPE SyncClusteredServiceBase EXTEND EventEmitter
<
  STRING __servicename;
  OBJECT __link;
  RECORD ARRAY __calllist;
  FUNCTION PTR ARRAY __onclose;

  /** @private
      @param description Service description
      @param(object wh::internal/jobs.whlib#IPCLinkEndPoint) link Connection IPC link
  */
  MACRO NEW(STRING servicename, RECORD description, OBJECT link)
  {
    this->__servicename := servicename;
    this->__link := link;
    link->autothrow := FALSE;
    ReconstructInvokables(this, description, PTR this->__RemotingFunc);
  }

  /** Calls a remote function synchronously
      @param tocall Function to call
      @return Return value of the called function
  */
  VARIANT FUNCTION __RemotingFunc(STRING tocall, VARIANT ARRAY args) __ATTRIBUTES__(SKIPTRACE, VARARG)
  {
    IF (NOT ObjectExists(this->__link))
      THROW NEW ServiceDisconnectException(this->__servicename, TRUE);

    RECORD outmsg := [ call := tocall, args := args ];

    RECORD res := this->__link->SendMessage(outmsg);

    IF(res.status != "ok")
      THROW NEW ServiceDisconnectException(this->__servicename, TRUE);

    // Add a waiting registration
    RECORD reg := [ replyto := res.msgid, type := "" ];
    INSERT reg INTO this->__calllist AT RecordUpperBound(this->__calllist, reg, [ "REPLYTO" ]);

    WHILE (TRUE)
    {
      this->RunEvents();
      RECORD pos := RecordLowerBound(this->__calllist, reg, [ "REPLYTO" ]);
      RECORD hit := this->__calllist[pos.position];
      IF (hit.type = "")
        CONTINUE;

      DELETE FROM this->__calllist AT pos.position;
      SWITCH (hit.type)
      {
        CASE "value"
        {
          IF(CellExists(hit.value,'result'))
            RETURN hit.value.result;
          ELSE
            RETURN FALSE; // we invoked a JS function returning undefined or a HS MACRO
        }
        CASE "exception"  { THROW hit.value; }
      }
    }
  }

  MACRO RunEvents()
  {
    IF (NOT ObjectExists(this->__link))
      THROW NEW ServiceDisconnectException(this->__servicename, FALSE);

    this->__link->Wait(MAX_DATETIME);
    RECORD msg := this->__link->ReceiveMessage(DEFAULT DATETIME);

    IF (msg.status = "timeout") // Spurious wakeup
      RETURN;

    IF (msg.status = "gone")
    {
      //Uh oh. We are doomed. Reject all promises
      this->CloseService();
      THROW NEW ServiceDisconnectException(this->__servicename, FALSE);
    }

    // This is an event emitted on the WebHareServiceProxyBase
    IF (CellExists(msg.msg, "EVENT"))
    {
      this->EmitEvent(msg.msg.event, msg.msg.data);
      RETURN;
    }

    IF (msg.replyto != 0)
    {
      RECORD pos := RecordLowerBound(this->__calllist, msg, [ "REPLYTO" ]);
      IF (NOT pos.found)
      {
        ABORT("Received unexpected reply to " || msg.replyto);
      }

      IF (CellExists(msg.msg, "__exception"))
      {
        this->__calllist[pos.position].type := "exception";
        INSERT CELL value := DecodeReceivedException(msg.msg.__exception) INTO this->__calllist[pos.position];
      }
      ELSE
      {
        this->__calllist[pos.position].type := "value";
        INSERT CELL value := msg.msg INTO this->__calllist[pos.position];
      }

      RETURN;
    }

    THROW NEW Exception(`Misunderstood incoming message`);
  }

  PUBLIC MACRO __ScheduleCallbackOnServiceClose(FUNCTION PTR onclose)
  {
    INSERT onclose INTO this->__onclose AT END;
  }

  /// Closes the service
  PUBLIC MACRO CloseService()
  {
    FOREVERY (FUNCTION PTR f FROM this->__onclose)
      f();
    IF (ObjectExists(this->__link))
      this->__link->Close();
    this->__link := DEFAULT OBJECT;
    RETURN;
  }
>;

/** synchronous waiter on a service start event
/*/
STATIC OBJECTTYPE ServiceStartSyncWaiter
< OBJECT evtmgr;
  DATETIME waituntil;

  MACRO NEW(STRING service, INTEGER timeout)
  {
    this->evtmgr := NEW EventManager;
    this->evtmgr->RegisterInterest("system:webhareservice." || service || ".start");
    this->waituntil := AddTimeToDate(timeout, GetCurrentDateTime());
  }

  PUBLIC BOOLEAN FUNCTION Wait()
  {
    RETURN this->evtmgr->ReceiveEvent(this->waituntil).status = "ok";
  }

  PUBLIC MACRO Close()
  {
    this->evtmgr->Close();
    this->evtmgr := DEFAULT OBJECT;
  }
>;

OBJECT FUNCTION CreateSyncServiceStartWait(STRING service, INTEGER timeout)
{
  RETURN NEW ServiceStartSyncWaiter(service, timeout);
}

/** Open a WebHare service
    @param servicename Name of the service (should follow the 'module:tag' pattern)
    @cell(variant array) options.arguments Arguments for the service
    @cell(integer) options.timeout Connect timeout, defaults to 30 seconds
    @return A proxy offering synchronous versions of the service API
*/
PUBLIC OBJECT FUNCTION __OpenSynchronousWebHareService(STRING servicename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ arguments := VARIANT[]
                             , timeout := 30000
                             ], options);

  //FIXME don't assume servicename matches servicetag... we should be looking up the <internalservice tag=".... "
  OBJECT mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
  IF (NOT ObjectExists(mgrport))
  {
    // Start a listen to the start event (async function but listener registration is synchronous)
    OBJECT startwaiter := CreateSyncServiceStartWait(servicename, options.timeout);
    TRY
    {
      // Check for the port to exist (it might have been created before the event listen started)
      mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
      IF (NOT ObjectExists(mgrport))
      {
        startwaiter->wait();
        mgrport := ConnectToGlobalIPCPort("webhareservice:" || servicename);
        IF (NOT ObjectExists(mgrport))
          THROW NEW ServiceUnavailableException(servicename);
      }
    }
    FINALLY
      startwaiter->Close();
  }

  mgrport->autothrow := TRUE;
  RECORD response := mgrport->DoRequest( [ __new := options.arguments ] );
  IF(response.status = "gone")
    THROW NEW ServiceDisconnectException(servicename, FALSE);

  RETURN NEW SyncClusteredServiceBase(servicename, response.msg, mgrport);
}
