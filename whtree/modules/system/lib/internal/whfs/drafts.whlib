<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/contenttypes.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/events.whlib";
LOADLIB "mod::system/lib/internal/whfs/objects.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/history.whlib" ;
LOADLIB "mod::system/lib/internal/webhareconstants.whlib" ;

LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";

CONSTANT STRING ARRAY workflow_controlled_fields := ["DATA", "TITLE", "DESCRIPTION", "KEYWORDS" ];

RECORD FUNCTION StringVersionToParts(STRING stringversion)
{
  STRING ARRAY toks := Tokenize(stringversion, '.');
  IF(Length(toks) != 2)
    RETURN DEFAULT RECORD;

  RETURN CELL[ major := ToInteger(toks[0], 0)
             , minor := ToInteger(toks[1], 0)
             ];
}

RECORD FUNCTION GetLastSnapshotVersion(INTEGER source)
{
  RECORD ARRAY currentversions := SELECT version, userdata
                                    FROM system_internal.fs_history
                                   WHERE fs_object = VAR source
                                         AND version != "";
  currentversions := SELECT *, parts := StringVersionToParts(version) FROM currentversions;
  RETURN (SELECT AS RECORD CELL[ parts.major
                               , parts.minor
                               , userdata := userdata LIKE "hson:*" ? DecodeHSON(userdata) : DEFAULT RECORD
                               ] FROM currentversions
                                WHERE RecordExists(parts)
                                ORDER parts.major DESC, parts.minor DESC
                                LIMIT 1)
         ?? [ userdata := DEFAULT RECORD, major := 0, minor := 0 ];
}

RECORD ARRAY FUNCTION GetDraftableInstanceTypes(INTEGER ARRAY forobjects) {
  // Get all workflow: true types that exist on the object
  // FIXME might be more robust to set workflow to the database so we can't forget to copy due to siteprofile corruption, but figure out schema first
  RECORD ARRAY cloneable := SELECT id, namespace
                              FROM GetCachedSiteProfiles().contenttypes
                             WHERE workflow = TRUE;

  //TODO doesn't this incorrectly pick up instance-in-instances? It probably won't hurt though as GetInstanceData/SetInstanceData still filter the actual results
  INTEGER ARRAY activetypes := SELECT AS INTEGER ARRAY DISTINCT fs_type
                                 FROM system.fs_instances
                                WHERE fs_instances.fs_object IN forobjects;

  RETURN SELECT * FROM cloneable WHERE id IN activetypes;
}

MACRO CopyWorkflowInstances(INTEGER instancesource, INTEGER destid) {
  RECORD ARRAY tocopy := GetDraftableInstanceTypes([instancesource,destid]);
  FOREVERY(RECORD trycopy FROM tocopy) {
    OBJECT typeobj := OpenWHFSType(trycopy.namespace);
    typeobj->SetInstanceData(destid, typeobj->GetInstanceData(instancesource), [ ifreadonly := "update" ]);
  }
}

MACRO RefreshDraftStatus(INTEGER fsobjectid)
{
  INTEGER publicdraft := SELECT AS INTEGER id FROM system.fs_objects WHERE filelink = fsobjectid AND parent = whconstant_whfsid_drafts;
  INTEGER curpublished := SELECT AS INTEGER published FROM system.fs_objects WHERE id = fsobjectid;
  IF((publicdraft != 0) != TestFlagFromPublished(curpublished, PublishedFlag_HasPublicDraft))
  {
    RECORD file := SELECT id, parent, parentsite FROM system.fs_objects WHERE id = fsobjectid;
    IF (RecordExists(file))
    {
      UPDATE system.fs_objects
         SET published := SetFlagsInPublished(published, PublishedFlag_HasPublicDraft, publicdraft != 0)
       WHERE id = fsobjectid;

      GetWHFSCommitHandler()->ObjectUpdate(file.parentsite, file.parent, fsobjectid);
    }
  }
}


/** @param requestinguser User requesting the drafts
    @param forsource For which source file (if 0, requesting all drafts for current user) */
RECORD ARRAY FUNCTION GetSomeDrafts(INTEGER requestinguser, INTEGER forsource)
{
  INTEGER me := GetEffectiveUserId();
  RECORD ARRAY versions := SELECT id
                                , ispublic := parent = whconstant_whfsid_drafts
                                , parent
                                , user := modifiedby
                                , mine := modifiedby = VAR me
                                , creationdate
                             FROM system.fs_objects
                            WHERE (forsource != 0 ? filelink = forsource : modifiedby = requestinguser)
                                  AND parent IN [whconstant_whfsid_autosaves,whconstant_whfsid_drafts]
                         ORDER BY creationdate;
  RETURN versions;
}


PUBLIC OBJECT FUNCTION OpenWHFSDraft(INTEGER draftid)
{
  RECORD versioninfo := SELECT id, parent, filelink FROM system.fs_objects WHERE id = draftid AND parent IN [whconstant_whfsid_autosaves,whconstant_whfsid_drafts,17];//17 no longer exists
  IF(NOT RecordExists(versioninfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW WHFSDraft(versioninfo.id, versioninfo.parent = whconstant_whfsid_drafts, versioninfo.filelink);
}
PUBLIC RECORD ARRAY FUNCTION ListUserWHFSDrafts(INTEGER userid)
{
  RETURN GetSomeDrafts(userid, 0);
}

STATIC OBJECTTYPE WHFSDraft <
  OBJECT pvt_fsobject;
  BOOLEAN pvt_ispublic;
  // The live object on which this draft is based
  INTEGER pvt_source;

  PUBLIC PROPERTY ispublic(pvt_ispublic, -);

  //TODO get rid of when, user and fsobject. They're caches and already hid some bugs in the versioning code, but we should probably wait until all Versioning code is removed - 90% of fsobject references are there.
  PUBLIC PROPERTY fsobject(pvt_fsobject,-);

  //The ID of the draft object (lives in private autosave/draft folders) which holds the changed (meta)data
  PUBLIC PROPERTY id(pvt_fsobject->id, -);

  //The ID of the live/original object on which this draft is based (lives in the original site)
  PUBLIC PROPERTY source(pvt_source, -);

  PUBLIC PROPERTY when(this->pvt_fsobject->creationdate, -);

  PUBLIC PROPERTY user(this->pvt_fsobject->modifiedby, -);

  MACRO NEW(INTEGER draftid, BOOLEAN ispublic, INTEGER source)
  {
    this->pvt_ispublic := ispublic;
    this->pvt_fsobject := OpenWHFSObject(draftid);
    this->pvt_source := source;
  }
  MACRO UnlinkThis()
  {
    this->pvt_ispublic := FALSE;
    this->pvt_fsobject := DEFAULT OBJECT;
    this->pvt_source := 0;
  }

  PUBLIC RECORD FUNCTION GetMetadata() {
    RECORD draftmeta := this->pvt_fsobject->GetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata");
    RECORD basefields := SELECT title, keywords, description FROM system.fs_objects WHERE id = this->id;
    RETURN CELL [ draftmeta.name, basefields.title, basefields.keywords, basefields.description ];
  }

  PUBLIC MACRO UpdateMetadata(RECORD updates) {
    updates := ValidateOptions(CELL[ name := "", title := "", description := "" , keywords := "" ], updates, [ optional := ["*"], title := "updates" ] );

    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");
    IF(this->ispublic)
      THROW NEW Exception("This draft is already commited to history and is read-only");

    IF(CellExists(updates,'name'))
      this->pvt_fsobject->SetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata", CELL[  updates.name ], [ ifreadonly := "update" ]);

    RECORD directupdates :=  PickCells(updates, ["title","description","keywords"]);
    UPDATE system.fs_objects SET RECORD CELL[ ...directupdates
                                            , modificationdate := GetCurrentDatetime()
                                            ]
                           WHERE id = this->id;
  }

  PUBLIC RECORD FUNCTION GetInstanceData(STRING typens) {
    RECORD typeinfo := LookupContentTypeByName(typens);
    IF(NOT RecordExists(typeinfo))
      THROW NEW Exception(`Type '${typens}' is not a known content type`);
    IF(NOT typeinfo.workflow)
      THROW NEW Exception(`Type '${typens}' does not support workflow and should not be retrieved from drafts`);
    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");

    RETURN this->pvt_fsobject->GetInstanceData(typens);
  }

  PUBLIC MACRO SetInstanceData(STRING typens, RECORD data) {
    RECORD typeinfo := LookupContentTypeByName(typens);
    IF(NOT RecordExists(typeinfo))
      THROW NEW Exception(`Type '${typens}' is not a known content type`);
    IF(NOT typeinfo.workflow)
      THROW NEW Exception(`Type '${typens}' does not support workflow and should not be set on drafts`);
    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");
    IF(this->ispublic)
      THROW NEW Exception("This draft is already commited to history and is read-only");

    this->pvt_fsobject->SetInstanceData(typens, data, [ ifreadonly := "update" ]);
  }

  /** @short Save this draft to a new public draft
      @cell(string array) options.basefields If present, list of cells to save from fs_object
      @cell(string array) options.contenttypes If present, list of contenttypes to save
      @return The public draft into which this draft was merged */
  PUBLIC MACRO SaveAsNewPublicDraft(OBJECT user, RECORD options DEFAULTSTO DEFAULT RECORD) {
    options := ValidateOptions(CELL[], options);

    IF(this->pvt_source = 0)
      THROW NEW Exception("This draft no longer exists");
    IF(this->ispublic)
      THROW NEW Exception("This draft is already public");

    INTEGER snapshotparent := EnsureSnapshotsFolder(SELECT AS INTEGER parentsite FROM system.fs_objects WHERE id = this->source);
    DATETIME now := GetCurrentDatetime();
    //Move older drafts to the snapshot folder for safe keeping
    UPDATE system.fs_objects SET parent := snapshotparent
                           WHERE filelink = this->source
                                 AND parent = whconstant_whfsid_drafts
                                 AND id != this->id;
    //Move our version to the draft folder
    UPDATE system.fs_objects SET parent := whconstant_whfsid_drafts
                               , modificationdate := now
                           WHERE id = this->id;
    DELETE FROM system.fs_objects WHERE parent = whconstant_whfsid_autosaves
                                    AND filelink = this->source;

    /* TODO we shouldn't need to copy non-workflow instance data if renderers like draft preview are always smart enough to look at the
            the right object for instances. let's see if we can do without */

    //FIXME require a locked transaction with the proper source file locked ?
    //Get next version#
    RECORD curversion := GetLastSnapshotVersion(this->source);

    INSERT CELL [ fs_object := this->source
                , user := user->authobjectid
                , userdata := EncodeHSON(user->GetUserDataForLogging())
                , type := whconstant_historytype_saved
                , when := now
                , snapshot := this->id
                , version := `${curversion.major}.${curversion.minor + 1}`
                ] INTO system_internal.fs_history;

    RefreshDraftStatus(this->source);
    this->pvt_ispublic := TRUE;
  }

  /** @short Save this draft as the final version
      @param options
      @cell(stringarray) options.basefields If present, list of cells to save from fs_object
      @cell(stringarray) options.contenttypes If present, list of contenttypes to save */
  PUBLIC MACRO SaveAsFinal(OBJECT user, RECORD options DEFAULTSTO DEFAULT RECORD) {
    IF(this->pvt_source = 0)
      THROW NEW Exception("This draft no longer exists");

    options := ValidateOptions(CELL[], options);

    DATETIME now := GetCurrentDatetime();
    //Move the draft and any older public drafts to snapshots for safe keeping
    INTEGER snapshotparent := EnsureSnapshotsFolder(SELECT AS INTEGER parentsite FROM system.fs_objects WHERE id = this->source);
    UPDATE system.fs_objects SET parent := snapshotparent
                                , modificationdate := now
                            WHERE id = this->id;

    UPDATE system.fs_objects SET parent := snapshotparent
                           WHERE filelink = this->source
                                 AND parent IN [ whconstant_whfsid_drafts, whconstant_whfsid_autosaves ];

    //Copy managed data from this the draft to the final
    CopyWorkflowInstances(this->id, this->source);

    //And reapply managed fields
    RECORD sourcedata := SELECT data, title, description, keywords FROM system.fs_objects WHERE id = this->id;
    RECORD updates := PickCells(sourcedata, workflow_controlled_fields);
    OpenWHFSObject(this->source)->UpdateMetadata(CELL[...updates, modificationdate := now ]);

    RefreshDraftStatus(this->source);

    //Update version info (this is a copy of the other version code, but technically it should usually suffice to only look at the source file?)
    OBJECT versioninfotype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/version");
    RECORD curversion := GetLastSnapshotVersion(this->source);
    STRING nextversion := `${curversion.major + 1}.0`;
    RECORD userinfo := user->GetUserDataForLogging();

    OpenWHFSType("http://www.webhare.net/xmlns/publisher/version")->SetInstancedata(this->source,
      [ version := nextversion
      , editor := curversion.userdata
      , publisher := userinfo
      , published := now
      ], [ isvisibleedit := FALSE ]);

    //Add history record
    INSERT CELL [ fs_object := this->source
                , user := user->authobjectid
                , userdata := EncodeHSON(userinfo)
                , type := whconstant_historytype_approved
                , when := now
                , version := nextversion
                , snapshot := this->id
                ] INTO system_internal.fs_history;

    this->UnlinkThis(); //disable this object
  }

  PUBLIC MACRO DeleteSelf()
  {
    IF(this->pvt_source = 0)
      THROW NEW Exception("This draft no longer exists");

    INTEGER sourceid;
    IF(this->ispublic)
      sourceid := SELECT AS INTEGER filelink FROM system.fs_objects WHERE id = this->id;

    DELETE FROM system.fs_objects WHERE id = this->id;
    IF(sourceid != 0)
      RefreshDraftStatus(sourceid);

    this->UnlinkThis();
  }

  /** Returns the event masks for broadcasts fired for this object
  */
  PUBLIC STRING ARRAY FUNCTION GetEventMasks()
  {
    RETURN this->fsobject->GetEventMasks();
  }
>;


/** Returns all drafts for this file
    @return List of drafts
    @cell(integer) return.id Id of the draft
    @cell(boolean) return.ispublic Whether the draft is a public draft
    @cell(integer) return.parent Parent folder of the draft
    @cell(integer) return.user User that created the draft
    @cell(boolean) return.mine Whether the current user created the draft
    @cell(datetime) return.creationdate Creation date of the draft
*/
PUBLIC RECORD ARRAY FUNCTION GetDrafts(INTEGER objid)
{
  RETURN GetSomeDrafts(GetEffectiveUserID(), objid);
}

PUBLIC OBJECT FUNCTION OpenDraft(INTEGER objid, INTEGER draftid)
{
  OBJECT draft := OpenWHFSDraft(draftid);
  RETURN ObjectExists(draft) AND draft->source = objid ? draft : DEFAULT OBJECT;
}

PUBLIC OBJECT FUNCTION CreateNewTemporary(OBJECT owner, INTEGER newparent, RECORD metadata)
{
  INTEGER destid := MakeAutonumber(system.fs_objects, "id");
  OBJECT tempfile := OpenWHFSObject(whconstant_whfsid_autosaves)->CreateFile(
    CELL[ ...metadata, name := ToString(destid), id := destid, modifiedby := owner->authobjectid, publish := FALSE ]);
  tempfile->SetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata", [ parent := newparent ]);
  RETURN tempfile;
}

/** Start a workflow update (create an autosave to have an object that can receive a RTD being updated)
    @param objid - The ID of the object we're updating. Draft or final object id */
PUBLIC OBJECT FUNCTION StartWorkflowUpdate(INTEGER objid, RECORD options DEFAULTSTO DEFAULT RECORD) {
  options := ValidateOptions([ user := DEFAULT OBJECT ], options);
  IF(NOT ObjectExists(options.user))
    THROW NEW Exception(`StartWorkflowUpdate requires a user object`);

  // Determine the base object for the draft we're going to update
  INTEGER baseobjectid;
  RECORD objinfo := SELECT name, filelink, parent, isfolder, whfspath, type, data, title, description, keywords FROM system.fs_objects WHERE id = VAR objid;
  IF(objinfo.parent = whconstant_whfsid_drafts)
    baseobjectid := objinfo.filelink;
  ELSE IF(IsRecycleOrHistoryWHFSPath(objinfo.whfspath))
    THROW NEW Exception(`Cannot create a draft version from file #${objid} as it is in internal WHFS folder ${objinfo.whfspath}`);
  ELSE IF(objinfo.isfolder)
    THROW NEW Exception("Cannot create a draft version from a folder");
  ELSE
    baseobjectid := objid;

  // Set up the new object (the 'autosave', or at least it will be an autosave as soon as we start writing data from editdocument here)
  DATETIME now := GetCurrentDateTime();
  INTEGER destid := MakeAutonumber(system.fs_objects, "id");
  INSERT CELL [ id := destid
              , parent := whconstant_whfsid_autosaves
              , name := ToString(destid)
              , creationdate := now
              , modificationdate := now
              , ...PickCells(objinfo, STRING[...workflow_controlled_fields, "type"])
              , filelink := baseobjectid
              , modifiedby := options.user->authobjectid
             ] INTO system.fs_objects;

  CopyWorkflowInstances(objid, destid);

  OBJECT typeobj := OpenWHFSType("http://www.webhare.net/xmlns/publisher/draftmetadata");
  typeobj->SetInstancedata(destid,
      [ name :=       baseobjectid = objid ? objinfo.name : typeobj->GetInstanceData(objid).name
      , parent :=     objinfo.parent
      ], [ ifreadonly := "update" ]);

  OBJECT draft := NEW WHFSDraft(destid, FALSE, baseobjectid);
  RETURN draft;
}

/** @short Returns the public draft for this object, if it exists
    @param objid Id of the object
    @return(object %WHFSDraft) Public draft, if it exists
    @topic sitedev/whfs
    @public
    @loadlib mod::system/lib/whfs.whlib
*/
PUBLIC OBJECT FUNCTION GetPublicDraft(INTEGER objid)
{
  INTEGER draftid := SELECT AS INTEGER id FROM system.fs_objects WHERE filelink = objid AND parent = whconstant_whfsid_drafts;
  RETURN draftid = 0 ? DEFAULT OBJECT : NEW WHFSDraft(draftid, TRUE, objid);
}

/** Cleanup private drafts made by others */
PUBLIC MACRO CleanupOtherPrivateDrafts(INTEGER objid)
{
  DELETE FROM system.fs_objects WHERE filelink = VAR objid AND parent = whconstant_whfsid_autosaves AND modifiedby != GetEffectiveUserID();
}
/** Cleanup my drafts */
PUBLIC MACRO CleanupMyPrivateDrafts(INTEGER objid)
{
  DELETE FROM system.fs_objects WHERE filelink = VAR objid AND parent = whconstant_whfsid_autosaves AND modifiedby = GetEffectiveUserID();
}
