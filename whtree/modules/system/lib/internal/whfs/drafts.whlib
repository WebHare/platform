<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/contenttypes.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/events.whlib";
LOADLIB "mod::system/lib/internal/whfs/objects.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/history.whlib" ;
LOADLIB "mod::system/lib/internal/webhareconstants.whlib" ;

LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";

PUBLIC CONSTANT STRING ARRAY workflow_controlled_fields := ["DATA", "TITLE", "DESCRIPTION", "KEYWORDS" ];

CONSTANT STRING ARRAY eventnames := [ "recycled"   //0 whconstant_historytype_recycled
                                    , "saved"      //1 whconstant_historytype_saved
                                    , "#2"         //currently unused
                                    , "reverted"   //3 whconstant_historytype_reverted
                                    , "created"    //4 whconstant_historytype_created
                                    , "approved"   //5 whconstant_historytype_approved
                                    , "autosave"   //6 whconstant_historytype_autosave
                                    , "import"     //7 whconstant_historytype_import
                                    , "final"      //8 whconstant_historytype_final
                                    ];

RECORD FUNCTION StringVersionToParts(STRING stringversion)
{
  STRING ARRAY toks := Tokenize(stringversion, '.');
  IF(Length(toks) != 2)
    RETURN DEFAULT RECORD;

  RETURN CELL[ major := ToInteger(toks[0], 0)
             , minor := ToInteger(toks[1], 0)
             ];
}

PUBLIC RECORD FUNCTION GetLastSnapshotVersion(INTEGER source)
{
  RECORD ARRAY currentversions := SELECT version, userdata
                                    FROM system_internal.fs_history
                                   WHERE fs_object = VAR source
                                         AND version != "";
  currentversions := SELECT *, parts := StringVersionToParts(version) FROM currentversions;
  RETURN (SELECT AS RECORD CELL[ parts.major
                               , parts.minor
                               , userdata := DecodeHSONOrJSONRecord(userdata)
                               ] FROM currentversions
                                WHERE RecordExists(parts)
                                ORDER parts.major DESC, parts.minor DESC
                                LIMIT 1)
         ?? [ userdata := DEFAULT RECORD, major := 0, minor := 0 ];
}

PUBLIC INTEGER FUNCTION CreateFullSnapshot(DATETIME now, INTEGER baseobjectid, INTEGER modifiedby) {
  INTEGER destid := MakeAutonumber(system.fs_objects, "id");
  RECORD objinfo := SELECT name, filelink, parent, parentsite, isfolder, whfspath, type, data, title, description, keywords FROM system.fs_objects WHERE id = VAR baseobjectid;
  INSERT CELL [ id := destid
              , parent := EnsureSnapshotsFolder(objinfo.parentsite)
              , name := ToString(destid)
              , creationdate := now
              , modificationdate := now
              , ...PickCells(objinfo, STRING[...workflow_controlled_fields, "type"])
              , filelink := baseobjectid
              , modifiedby
              ] INTO system.fs_objects;

  //We're building a full snapshot. So instancesource (the snapshot) should receive all copyable instances from destid (the final)
  RECORD ARRAY snapshot_current_instances := ListInstances(baseobjectid);
  FOREVERY(RECORD inst FROM snapshot_current_instances)
    IF(inst.cloneonarchive) {
      OBJECT typeobj := OpenWHFSType(inst.namespace, [ openorphans := TRUE ]);
      typeobj->SetInstanceData(destid, typeobj->GetInstanceData(baseobjectid), [ ifreadonly := "update", isvisibleedit := FALSE, workflow := FALSE ]);
    }

  OBJECT typeobj := OpenWHFSType("http://www.webhare.net/xmlns/publisher/draftmetadata");
  typeobj->SetInstancedata(destid,
      [ name :=       objinfo.name
      ], [ ifreadonly := "update" ]);

  RETURN destid;
}

/** Get the change history for this object
    @return Change history items
    @cell(string) return.id History item id
    @cell(string) return.type One of 'recycled', 'saved', 'reverted', 'created', 'approved'
    @cell(integer) return.user User authobject id
    @cell(integer) return.snapshot WHFS id of the file with the contents for this history
    @cell(datetime) return.when Modification time
    @cell(datetime) return.isactive Whether this is the current active version
    @cell(string) return.version Version number. First version is 0.1, first published version is 1.0
*/
PUBLIC RECORD ARRAY FUNCTION ListObjectHistory(INTEGER objid)
{
  RECORD ARRAY historyitems :=
     SELECT id
          , type := type >= 0 AND type < Length(eventnames) ? eventnames[type] : "#" || type
          , user
          , userdata := DecodeHSONOrJSONRecord(userdata)
          , when
          , snapshot
          , version
          , isactive :=     snapshot = objid
          , name := currentname
       FROM system_internal.fs_history
      WHERE fs_object = objid
   ORDER BY when, id;

  INTEGER lastapproved := SELECT AS INTEGER id FROM historyitems WHERE type IN [ "approved", "created" ] ORDER BY when DESC LIMIT 1;
  RETURN
      SELECT *
           , isactive :=    id = lastapproved
        FROM historyitems;
}

PUBLIC MACRO CopyWorkflowInstances(INTEGER instancesource, INTEGER destid, INTEGER ARRAY addworkflowtypes, BOOLEAN isfinal) {
  RECORD ARRAY instances := ListInstances(instancesource);
  INTEGER ARRAY copiedtypes;

  FOREVERY(RECORD inst FROM instances) {
    IF(inst.workflow OR inst.fstype IN addworkflowtypes) {
      INSERT destid INTO copiedtypes AT END;
      OBJECT typeobj := OpenWHFSType(inst.namespace);
      typeobj->SetInstanceData(destid, typeobj->GetInstanceData(instancesource),
          [ ifreadonly := "update", isvisibleedit := FALSE, workflow := NOT isfinal ]);
    }
  }

  //Create explicit empty instances as needed
  IF(NOT isfinal)
    FOREVERY(INTEGER typ FROM addworkflowtypes) {
      IF(typ NOT IN copiedtypes) {
        RECORD typeinfo := SELECT namespace FROM system.fs_types WHERE id = typ;
        IF(RecordExists(typeinfo)) {
          OBJECT typeobj := OpenWHFSType(typeinfo.namespace);
          typeobj->SetInstanceData(destid, CELL[], [ ifreadonly := "update", isvisibleedit := FALSE, workflow := TRUE ]);
        }
      }
    }
}

PUBLIC OBJECT FUNCTION OpenWHFSDraft(INTEGER draftid)
{
  RECORD versioninfo := SELECT id, parent, filelink FROM system.fs_objects WHERE id = draftid AND parent IN [whconstant_whfsid_autosaves,whconstant_whfsid_drafts,17];//17 no longer exists
  IF(NOT RecordExists(versioninfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW WHFSDraft(versioninfo.id, versioninfo.parent = whconstant_whfsid_drafts, versioninfo.filelink);
}

STATIC OBJECTTYPE WHFSDraft <
  OBJECT pvt_fsobject;
  BOOLEAN pvt_ispublic;
  // The live object on which this draft is based
  INTEGER pvt_source;

  PUBLIC PROPERTY ispublic(pvt_ispublic, -);

  //TODO get rid of when, user and fsobject. They're caches and already hid some bugs in the versioning code, but we should probably wait until all Versioning code is removed - 90% of fsobject references are there.
  PUBLIC PROPERTY fsobject(pvt_fsobject,-);

  //The ID of the draft object (lives in private autosave/draft folders) which holds the changed (meta)data
  PUBLIC PROPERTY id(pvt_fsobject->id, -);

  //The ID of the live/original object on which this draft is based (lives in the original site)
  PUBLIC PROPERTY source(pvt_source, -);

  PUBLIC PROPERTY when(this->pvt_fsobject->creationdate, -);

  PUBLIC PROPERTY user(this->pvt_fsobject->modifiedby, -);

  MACRO NEW(INTEGER draftid, BOOLEAN ispublic, INTEGER source)
  {
    this->pvt_ispublic := ispublic;
    this->pvt_fsobject := OpenWHFSObject(draftid);
    this->pvt_source := source;
  }
  MACRO UnlinkThis()
  {
    this->pvt_ispublic := FALSE;
    this->pvt_fsobject := DEFAULT OBJECT;
    this->pvt_source := 0;
  }

  PUBLIC RECORD FUNCTION GetMetadata() {
    RECORD draftmeta := this->pvt_fsobject->GetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata");
    RECORD basefields := SELECT title, keywords, description, data FROM system.fs_objects WHERE id = this->id;
    RETURN CELL [ draftmeta.name, basefields.title, basefields.keywords, basefields.description, basefields.data ];
  }

  PUBLIC MACRO UpdateMetadata(RECORD updates) {
    updates := ValidateOptions(CELL[ name := "", title := "", description := "" , keywords := "", data := DEFAULT BLOB ], updates, [ optional := ["*"], title := "updates" ] );

    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");
    IF(this->ispublic)
      THROW NEW Exception("This draft has already been committed to history and is read-only");

    IF(CellExists(updates,'name'))
      this->pvt_fsobject->SetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata", CELL[  updates.name ], [ ifreadonly := "update" ]);

    RECORD directupdates :=  PickCells(updates, ["title","description","keywords","data"]);
    UPDATE system.fs_objects SET RECORD CELL[ ...directupdates
                                            , modificationdate := GetCurrentDatetime()
                                            ]
                           WHERE id = this->id;

    // Draft could have been moved, so we need to refetch parent
    INTEGER parent := SELECT AS INTEGER COLUMN parent FROM system.fs_objects WHERE id = this->id;
    GetWHFSCommitHandler()->ObjectUpdate(0, parent, this->id);
  }

  PUBLIC RECORD FUNCTION GetInstanceData(STRING typens) {
    RECORD typeinfo := LookupContentTypeByName(typens);
    IF(NOT RecordExists(typeinfo))
      THROW NEW Exception(`Type '${typens}' is not a known content type`);
    IF(NOT typeinfo.workflow)
      THROW NEW Exception(`Type '${typens}' does not support workflow and should not be retrieved from drafts`);
    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");

    RETURN this->pvt_fsobject->GetInstanceData(typens);
  }

  PUBLIC MACRO SetInstanceData(STRING typens, RECORD data) {
    RECORD typeinfo := LookupContentTypeByName(typens);
    IF(NOT RecordExists(typeinfo))
      THROW NEW Exception(`Type '${typens}' is not a known content type`);
    IF(NOT typeinfo.workflow)
      THROW NEW Exception(`Type '${typens}' does not support workflow and should not be set on drafts`);
    IF(NOT ObjectExists(this->pvt_fsobject))
      THROW NEW Exception("This draft no longer exists");
    IF(this->ispublic)
      THROW NEW Exception("This draft has already been committed to history and is read-only");

    this->pvt_fsobject->SetInstanceData(typens, data, [ ifreadonly := "update" ]);
  }

  /** Returns the event masks for broadcasts fired for this object
  */
  PUBLIC STRING ARRAY FUNCTION GetEventMasks()
  {
    RETURN this->fsobject->GetEventMasks();
  }
>;

/** Start a workflow update (create an autosave to have an object that can receive a RTD being updated)
    @param objid - The ID of the object we're updating. Draft or final object id */
PUBLIC OBJECT FUNCTION StartWorkflowUpdate(OBJECT baseobject, INTEGER objid, RECORD metadata, RECORD options DEFAULTSTO DEFAULT RECORD) {
  options := ValidateOptions([ user := DEFAULT OBJECT, workflowtypes := INTEGER[] ], options);

  // Set up the new object (the 'autosave', or at least it will be an autosave as soon as we start writing data from editdocument here)
  DATETIME now := GetCurrentDateTime();
  INTEGER destid := MakeAutonumber(system.fs_objects, "id");
  INSERT CELL [ id := destid
              , parent := whconstant_whfsid_autosaves
              , name := ToString(destid)
              , creationdate := now
              , modificationdate := now
              , ...PickCells(metadata, workflow_controlled_fields)
              , type := baseobject->type
              , filelink := baseobject->id
              , modifiedby := ObjectExists(options.user) ? options.user->authobjectid : 0
              ] INTO system.fs_objects;

  CopyWorkflowInstances(objid, destid, options.workflowtypes, FALSE);

  INSERT CELL [ fs_object := baseobject->id
              , user := ObjectExists(options.user) ? options.user->authobjectid : 0
              , userdata := EncodeHSON(ObjectExists(options.user) ? options.user->GetUserDataForLogging() : DEFAULT RECORD)
              , type := whconstant_historytype_autosave
              , when := now
              , snapshot := destid
              , currentname := metadata.name
              ] INTO system_internal.fs_history;


  IF(metadata.name != "" ) {
    OBJECT typeobj := OpenWHFSType("http://www.webhare.net/xmlns/publisher/draftmetadata");
    typeobj->SetInstancedata(destid, CELL[ metadata.name ], [ ifreadonly := "update", isvisibleedit := FALSE ]);
  }

  GetWHFSCommitHandler()->ObjectCreate(0, whconstant_whfsid_autosaves, destid);

  OBJECT draft := NEW WHFSDraft(destid, FALSE, baseobject->id);
  RETURN draft;
}

/** @short Returns the public draft for this object, if it exists
    @param objid Id of the object
    @return(object %WHFSDraft) Public draft, if it exists
    @topic sitedev/whfs
    @public
    @loadlib mod::system/lib/whfs.whlib
*/
PUBLIC OBJECT FUNCTION GetPublicDraft(INTEGER objid)
{
  INTEGER draftid := SELECT AS INTEGER id FROM system.fs_objects WHERE filelink = objid AND parent = whconstant_whfsid_drafts;
  RETURN draftid = 0 ? DEFAULT OBJECT : NEW WHFSDraft(draftid, TRUE, objid);
}

/** Cleanup private drafts made by others */
PUBLIC MACRO CleanupOtherPrivateDrafts(INTEGER objid)
{
  DELETE FROM system.fs_objects WHERE filelink = VAR objid AND parent = whconstant_whfsid_autosaves AND modifiedby != GetEffectiveUserID();
}
/** Cleanup my drafts */
PUBLIC MACRO CleanupMyPrivateDrafts(INTEGER objid)
{
  DELETE FROM system.fs_objects WHERE filelink = VAR objid AND parent = whconstant_whfsid_autosaves AND modifiedby = GetEffectiveUserID();
}

PUBLIC MACRO ImportCurrentState(INTEGER baseobjectid) {
  DATETIME now := GetCurrentDateTime();
  INTEGER destid := CreateFullSnapshot(now, baseobjectid, 0);

  //Add history record
  INSERT CELL [ fs_object := baseobjectid
              , type := whconstant_historytype_import
              , when := now
              , version := "1.0"
              , snapshot := destid
              ] INTO system_internal.fs_history;

  GetWHFSCommitHandler()->ObjectCreate(0, whconstant_whfsid_autosaves, destid);
}
