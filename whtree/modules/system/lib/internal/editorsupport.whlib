<?wh

// Minimze the loadlibs by this script, so it will also function to translate core library paths
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internal/interface.whlib";

LOADLIB "mod::system/lib/internal/whcore_interface.whlib";

/** @schemadef system
*/
PUBLIC SCHEMA
  < TABLE
    < STRING "fullpath" __ATTRIBUTES__(READONLY)
    , STRING "whfspath" __ATTRIBUTES__(READONLY)
    , INTEGER "highestparent" __ATTRIBUTES__(READONLY)
    , STRING "name"
    , INTEGER "id" NULL := 0
    , INTEGER "parent" NULL := 0
    ; KEY id
    > fs_objects
  , TABLE
    < INTEGER "id" NULL := 0
    , STRING "name"
    , INTEGER "outputweb" NULL := 0
    , STRING "outputfolder"
    , INTEGER "id" AS "root" NULL := 0 __ATTRIBUTES__(READONLY)
    ; KEY id
    > sites
  , TABLE
    < INTEGER "id" NULL := 0
    , STRING "diskfolder"
    ; KEY id
    > webservers
  , TABLE
    < INTEGER "id" NULL := 0
    , STRING "foldername"
    , STRING "diskfolder"
    , BOOLEAN "forcelowercase"
    ; KEY id
    > webdav_datafolders
  > local_system;

// Merge two urls together, and fix the '/'s at the merge point. No further checks
STRING FUNCTION MergeURL(STRING url, STRING append)
{
  IF (url NOT LIKE "*/")
    url := url || "/";
  IF (append LIKE "/*")
    append := SubString(append, 1);
  RETURN url || append;
}

MACRO EnsurePrimary()
{
  FUNCTION PTR haveprimarytransaction := MakeFunctionPTR("mod::system/lib/database.whlib#haveprimarytransaction", TypeID(BOOLEAN), DEFAULT INTEGER ARRAY);
  IF (NOT haveprimarytransaction())
  {
    FUNCTION PTR openprimary := MakeFunctionPTR("mod::system/lib/database.whlib#openprimary", TypeID(OBJECT), [ TypeID(RECORD) ]);
    OBJECT trans := OpenPrimary(DEFAULT RECORD);

    local_system := BindTransactionToSchema(trans->id, "system");
  }
  ELSE
  {
    FUNCTION PTR getprimary := MakeFunctionPTR("mod::system/lib/database.whlib#getprimary", TypeID(OBJECT), DEFAULT INTEGER ARRAY);
    local_system := BindTransactionToSchema(getprimary()->id, "system");
  }
}

STRING FUNCTION FSObjectsLookup(INTEGER base, STRING path)
{
  EnsurePrimary();
  STRING ARRAY parts := Tokenize(path, "/");

  FOREVERY (STRING part FROM parts)
  {
    IF (part = "")
      CONTINUE;

    base := SELECT AS INTEGER id FROM local_system.fs_objects WHERE ToUppercase(name) = ToUppercase(part) AND parent = base;
    IF (base = 0)
      BREAK;
  }

  IF (base = 0)
    RETURN "";

  RETURN "whfs::" || (SELECT AS STRING whfspath FROM local_system.fs_objects WHERE id = base);
}

STRING FUNCTION ResolveOutputBaseFolder(STRING folder)
{
  IF (folder NOT LIKE "/*")
  {
    STRING output_basefolder := __SYSTEM_WHCOREPARAMETERS().basedataroot || 'output/';
    folder := output_basefolder || folder;
  }
  IF (folder NOT LIKE "*/")
    folder := folder || "/";
  RETURN folder;
}


/** Try to translate any path to a mod:: or whfs:: path
    @param anyurl
    @return
    @cell return.filepath Path to file on disk (empty for whfs)
    @cell return.rootpath Translated url, '' if failed.
*/
PUBLIC RECORD FUNCTION TranslateURLToRootPath(STRING anyurl, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  TRY
  {
    STRING retval;
    STRING filepath;

    STRING proto := anyurl NOT LIKE "/*" ? Left(anyurl, SearchSubString(anyurl, ":")) : "";
    STRING path := SubString(anyurl, proto = "" ? 0 : LENGTH(proto) + 2);

    // Remove "!" parts
    path := Detokenize((SELECT AS STRING ARRAY elt FROM ToRecordArray(Tokenize(path, "/"), "ELT") WHERE elt NOT LIKE "!*"), "/");

    IF (proto IN [ "http", "https" ] AND UnpackURL(anyurl).urlpath LIKE "webdav/*")
      proto := Substitute(proto, "http", "webdav");

    IF (proto IN [ "webdav", "webdavs" ])
    {
      RECORD up := UnpackURL(anyurl);
      IF (up.urlpath LIKE "webdav/publisher/*")
        retval := "whfs::" || DecodeUrl(SubString(up.urlpath, 16)); // With '/' at start!
      ELSE IF (up.urlpath LIKE "webdav/system/modules/*")
      {
        STRING subpath := DecodeUrl(SubString(up.urlpath, 22));
        retval := "mod::" || subpath;
      }
      ELSE IF (up.urlpath LIKE "webdav/data/*")
      {
        STRING dataname := Tokenize(up.urlpath, "/")[2];

        EnsurePrimary();
        path := SELECT AS STRING diskfolder FROM local_system.webdav_datafolders WHERE foldername = dataname;
        path := MergePath(path, Substring(up.urlpath, 12 + Length(dataname)));
        proto := "";
      }
    }

    SWITCH (proto)
    {
      CASE "", "direct", "file"
      {
        WHILE (path LIKE "//*")
          path := SubString(path, 1);

        filepath := path;

        // Try to translate module paths to mod::
        FOREVERY (STRING module FROM __SYSTEM_GETINSTALLEDMODULENAMES())
        {
          STRING root := GetModuleInstallationRoot(module);
          IF (path LIKE root || "*")
            retval := MergeURL("mod::" || module, SubString(path, LENGTH(root)));
        }

        IF (retval = "")
        {
          EnsurePrimary();

          // ADDME: pickup output paths too
          RECORD webserver :=
              SELECT resolved_diskfolder := ResolveOutputBaseFolder(diskfolder)
                   , *
                FROM local_system.webservers
               WHERE diskfolder != "" AND ToUppercase(path) LIKE ToUppercase(ResolveOutputBaseFolder(diskfolder) || "*");

          IF (RecordExists(webserver))
          {
            STRING subpath := SubString(path, LENGTH(webserver.resolved_diskfolder) - 1);

            RECORD site :=
                SELECT *
                  FROM local_system.sites
                 WHERE outputweb = webserver.id
                   AND ToUppercase(subpath) LIKE ToUppercase(outputfolder || "*")
              ORDER BY LENGTH(outputfolder) DESC;

            IF (RecordExists(site))
            {
              STRING sitepath := SubString(subpath, LENGTH(site.outputfolder) - 1);
              retval := FSObjectsLookup(site.id, sitepath);
              filepath := "";
            }
          }
        }

        IF (retval = "")
          retval := "direct::" || path;
      }

      CASE "wh"
      {
        retval := MergeURL("mod::system/whlibs/", path);
        filepath := MergeURL(MergeURL(GetModuleInstallationRoot("system"), "/whlibs/"), path);
      }

      CASE "mod", "module", "modulescript", "moduleroot", "moduledata"
      {
        STRING module := Left(path, SearchSubString(path, "/"));
        path := __HS_INTERNAL_RESOLVEABSOLUTELIBRARY("", proto || "::" || path);

        retval := path;
        filepath := MergeURL(GetModuleInstallationRoot(module), SubString(path, SearchSubString(path, "/") + 1));
      }

      CASE "site"
      {
        EnsurePrimary();

        STRING sitepath := SubString(anyurl, 6);
        INTEGER pos := SearchSubString(sitepath, "/");

        STRING sitename := Left(sitepath, pos);
        STRING fullpath := SubString(sitepath, pos);

        //ABORT(sitename || " " || fullpath);

        RECORD site := SELECT root FROM local_system.sites WHERE ToUppercase(name) = ToUppercase(sitename);
        IF (RecordExists(site))
          retval := FSObjectsLookup(site.root, fullpath);
      }

      CASE "whfs"
      {
        EnsurePrimary();

        STRING whfspath := Substring(Substitute(anyurl, "::", ":"), 5);
        IF (whfspath NOT LIKE "/*")
          whfspath := "/" || whfspath;

        retval := "whfs::" || whfspath;
      }

/*      CASE "filebyid"
      {
        EnsurePrimary();

        INTEGER fileid := ToInteger(SubString(Substitute(anyurl, "::", ":"), 9), 0);
        RECORD file := SELECT whfspath FROM local_system.fs_objects WHERE id = fileid;

        IF (RecordExists(file))
          retval := "whfs::" || file.whfspath;
      }
*/
      CASE "http", "https"
      {
        EnsurePrimary();

        STRING urlpath := Tokenize(Tokenize(SubString(path, SearchSubString(path, "/", 1)), "?")[0], "#")[0];
        STRING ARRAY urlparts := Tokenize(urlpath, "/");

        IF (urlpath LIKE "/tollium_todd.res/*/*")
        {
          retval := "mod::" || urlparts[2] || "/web/resources/" || Detokenize(ArraySlice(urlparts, 3), "/");
          filepath := MergeURL(MergeURL(GetModuleInstallationRoot(urlparts[2]), "/web/resources/"), Detokenize(ArraySlice(urlparts, 3), "/"));
        }
        ELSE IF (urlpath LIKE "/.tollium/ui/*")
        {
          retval := "mod::tollium/web/ui/" || Detokenize(ArraySlice(urlparts, 3), "/");
          filepath := MergeURL(MergeURL(GetModuleInstallationRoot("tollium"), "/web/ui/"), Detokenize(ArraySlice(urlparts, 3), "/"));
        }
        ELSE
        {
          // Don't want to depend on the loadlib
          FUNCTION PTR lookuppublisherurl := MakeFunctionPTR("mod::publisher/lib/publisher.whlib#LookupPublisherURL", TypeID(RECORD), [ TypeID(STRING) ]);

          RECORD rec := LookupPublisherURL(Left(anyurl, SearchSubString(anyurl||"?","?")));
          IF (rec.file != 0)
          {
            RECORD file := SELECT whfspath FROM local_system.fs_objects WHERE id = rec.file;
            IF (RecordExists(file))
              retval := "whfs::" || file.whfspath;
          }
        }
      }
    }

    RETURN
        [ rootpath :=   retval
        , filepath :=   filepath
        ];
  }
  CATCH (OBJECT e)
  {
    // FIXME: log?
    RETURN DEFAULT RECORD;
  }
}

STRING FUNCTION RewriteFilenameToSite(STRING filename)
{
  IF (filename LIKE "whfs::*")
  {
    EnsurePrimary();
    FUNCTION PTR func := MakeFunctionPTR("mod::system/lib/whfs.whlib#OpenWHFSObjectByPath", TypeID(OBJECT), [ TypeID(STRING) ]);

    OBJECT obj := func(filename);
    IF (ObjectExists(obj) AND obj->highestparent != 0)
      filename := "site::" || obj->highestparentobject->name || obj->fullpath;
    ELSE IF (NOT ObjectExists(obj))
      RETURN "whfs::";

  }

  RETURN filename;
}

PUBLIC RECORD FUNCTION RecompileFile(STRING filename, RECORD options)
{
  RECORD result :=
      [ errors :=     DEFAULT RECORD ARRAY
      , warnings :=   DEFAULT RECORD ARRAY
      ];

  filename := RewriteFilenameToSite(filename);
  IF (filename LIKE "whfs::*")
  {
    result.errors :=
        [ filename :=   filename
        , message :=    filename = "whfs::" ? "File not found" : "Can only recompile files within a site"
        , line :=       1
        , pos :=        1
        , iserror :=    TRUE
        ];

    RETURN result;
  }

  BOOLEAN force := CellExists(options, "FORCE") ? options.force : FALSE;

  RETURN __SYSTEM_RECOMPILELIBRARY(filename, force);
}
