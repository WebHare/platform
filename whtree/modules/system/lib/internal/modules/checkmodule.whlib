<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::internal/interface.whlib";

LOADLIB "mod::publisher/lib/search/searchfilters.whlib";
LOADLIB "mod::publisher/lib/search/support.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/validation.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/modules/node.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/javascript.whlib";
LOADLIB "mod::system/lib/internal/validation/scan.whlib";


OBJECTTYPE CheckerObject <
  RECORD options;
  RECORD ARRAY seenissues;
  STRING module;
  RECORD validateconfig;

  MACRO AddTypedIssues(RECORD ARRAY issues) {
    FOREVERY(RECORD issue FROM issues)
      this->AddTypedIssue(issue);
  }

  MACRO AddTypedIssue(RECORD issue) {
    IF(NOT CellExists(issue,"type")) {
      dumpvalue(issue);
      THROW NEW Exception(`Issue is missing a type`);
    }

    this->AddIssue(issue, issue.type);
  }

  MACRO AddIssue(RECORD issue, STRING category)
  {
    IF(category = "warning" AND NOT CellExists(issue,'source'))
    {
      dumpvalue(issue);
      THROW NEW Exception(`Warning is missing a source`);
    }

    IF(this->validateconfig.futuremodule AND category = "error")
      category := "warning";
    ELSE IF(this->validateconfig.nowarnings AND category = "warning" AND issue.source NOT IN["eslint"])
      category := "error";

    RECORD rec := CELL[ issue.resourcename, issue.line, issue.col, issue.message, category ];
    RECORD pos := RecordLowerBound(this->seenissues, rec, [ "RESOURCENAME", "LINE", "COL", "CATEGORY", "MESSAGE" ]);
    IF (pos.found)
      RETURN;

    INSERT rec INTO this->seenissues AT pos.position;
    IF(this->options.printissues AND NOT (category = "hint" AND this->options.hidehints))
      Print(`${category="error"?`${AnsiCmd("red")}ERR!:`:category="warning"?"Warn:":"Hint:"}${AnsiCmd("reset")} ${issue.resourcename}:${issue.line}${issue.col > 0 ? ":" || issue.col : ""} ${UCTruncate(issue.message, 300)}\n`);
  }

  MACRO OnSkippedFile(STRING resourcename, STRING why)
  {
    IF(this->options.printissues AND NOT this->options.hidehints)
      Print(`Info: Skipping ${resourcename} because: ${why}\n`);
  }

  MACRO VerifyModuleDefinition(STRING modname)
  {
    RECORD moddef := GetWebhareModuleInfo(modname);
    STRING moddefname := `mod::${modname}/moduledefinition.xml`;

    //validate searchfilter objects
    __searchfilterprops := [ context := DEFAULT OBJECT ];
    FOREVERY (RECORD filter FROM moddef.searchfilters)
    {
      TRY
      {
        OBJECT filterobject := MakeObject(filter.filterobjname);

        IF (filterobject NOT EXTENDSFROM BaseSearchFilter)
          THROW NEW Exception(`Search filterobject '${filter.filterobjname}' does not derive from BaseSearchFilter`);

        ValidateOptions(
            [ matchlabel := ""
            , matchtype := DEFAULT RECORD ARRAY
            , textquery := ""
            , datequery := DEFAULT RECORD
            , valuequery := DEFAULT RECORD ARRAY
            , valuequerytype := ""
            , selectquery := DEFAULT RECORD
            , customquery := DEFAULT FUNCTION PTR
            ], filterobject->GetFields(),
            [ title := "fields"
            , optional := [ "*" ]
            //, notypecheck := [ "textquery" ] //ADDME: If we want to support input types other than text
            ]);

      }
      CATCH(OBJECT e)
      {
        this->AddIssue([ resourcename := moddefname, line := filter.linenum, col := 0, message := e->what ], "error"  );
      }
    }
  }

  PUBLIC MACRO Check(STRING modname, RECORD options) {
    this->module := modname;
    this->options := ValidateOptions([ printissues := FALSE
                                     , debug := FALSE
                                     , onlytids := FALSE
                                     , filemask := ""
                                     , color := FALSE
                                     , nowarnings := FALSE
                                     , hidehints := FALSE
                                     , checktypescript := TRUE
                                     , onlypaths := STRING[]
                                     ], options);

    IF(this->options.filemask = "")
      this->options.filemask := "*";
    IF (this->options.color)
      SetAnsiCmdMode("enabled");

    STRING ARRAY issues;
    STRING moddir;
    IF (modname != "jssdk")
    {
      moddir := GetModuleInstallationRoot(modname);
      IF(moddir="")
        THROW NEW Exception(`No such module '${modname}'`);
    }

    OBJECT typescriptresultpromise, checkformattingpromise;
    IF (this->options.checktypescript)
      typescriptresultpromise := CheckModuleTypeScriptFiles(modname IN whconstant_builtinmodules ? "platform" : modname);
    checkformattingpromise := CheckModuleJavascriptFormatting(modname, CELL[ this->options.onlypaths, this->options.filemask ]);

    this->validateconfig := GetModuleValidationConfig(modname = "jssdk" ? "system" : modname);
    IF(this->validateconfig.futuremodule)
      Print(`INFO: Module '${modname}' does not apply to this WebHare (${this->validateconfig.futuremodulewhy}) - all errors will be treated as warnings\n`);
    IF(this->options.nowarnings)
      this->validateconfig.nowarnings := TRUE;

    //verify node modules, if node_modules matches it (eg '*', '**' etc)
    IF("node_modules" LIKE this->options.filemask AND moddir != "")
    {
      RECORD ARRAY nodeissues := CheckNodeModulesInModule(moddir);
      FOREVERY(RECORD issue FROM nodeissues)
        this->AddIssue([ resourcename := GetResourceNameFromDiskPath(issue.basepath), line := 0, col := 0, message := issue.error ], "error");
    }

    //verify moduledefinition
    IF (modname != "jssdk")
      this->VerifyModuleDefinition(modname);

    RECORD validationoptions := CELL[ onlytids := this->options.onlytids
                                     , ...GetValidationOptionsFromConfig(this->validateconfig)
                                     ];

    //verify code
    IF(this->options.debug)
      Print(`Checking files matching '${this->options.filemask}' in module '${modname}'\n`);
    STRING ARRAY scanlist := GetValidatableFiles(this->validateconfig, modname
                                                 , [ onskippedfile := PTR this->OnSkippedFile
                                                   , filemask := this->options.filemask
                                                   ]);
    IF (IsValueSet(this->options.onlypaths))
      scanlist := SELECT AS STRING ARRAY name FROM ToRecordArray(scanlist,'name') WHERE GetWebHareResourceDiskPath(name) IN this->options.onlypaths;

    IF(this->options.debug)
      Print(`${modname} - got ${Length(scanlist)} files to scan\n`);


    STRING ARRAY exclusions := SELECT AS STRING ARRAY mask FROM this->validateconfig.excludemasks;
    RECORD ARRAY toscan := SELECT *
                                , isjs := GetExtensionFromPath(name) IN whconstant_javascript_extensions
                                , exclude := MatchesPathMasks(name, exclusions)
                             FROM ToRecordArray(scanlist,'name');

    RECORD ARRAY jsfiles := SELECT * FROM toscan WHERE isjs AND NOT exclude;
    RECORD ARRAY otherfiles := SELECT * FROM toscan WHERE NOT isjs AND NOT exclude;

    IF(this->options.printissues AND NOT this->options.hidehints)
      FOREVERY(RECORD excluded FROM SELECT * FROM toscan WHERE exclude)
        Print(`Info: Skipping ${excluded.name} because it matches an exclude mask\n`);

    RECORD ARRAY eslintfiles;
    FOREVERY(RECORD res FROM jsfiles) {
      STRING resnameformasks := Substring(res.name, SearchSubString(res.name,'/')+1);
      FOREVERY (STRING mask FROM this->validateconfig.eslintmasks)
        IF (ToUppercase(resnameformasks) LIKE ToUppercase(mask))
          INSERT CELL[ resourcepath := res.name ] INTO eslintfiles AT END;
    }

    IF(Length(eslintfiles) > 0 AND NOT this->options.onlytids) {
      IF(this->options.debug)
        Print(`${modname} - running ESLint on ${Length(eslintfiles)} files\n`);

      RECORD ARRAY messages := RunESLint(eslintfiles).messages;
      messages := ApplyIgnoreMessages(messages, validationoptions);
      this->AddTypedIssues(messages);
    }

    FOREVERY(RECORD entry FROM otherfiles) {
      IF(this->options.debug)
        Print(`Validating ${entry.name}\n`);

      RECORD result := ValidateSingleFile(entry.name, validationoptions);
      this->AddTypedIssues(result.messages);
    }

    FOREVERY(RECORD entry FROM jsfiles) {
      IF(this->options.debug)
        Print(`Tid/icon scanning ${entry.name}\n`);

      RECORD result := CELL[ messages := RECORD[], ... GetJSTexts(entry.name, GetWebhareResource(entry.name)) ];
      result := MergeTidIconIssues(result, validationoptions);
      result.messages := ApplyIgnoreMessages(result.messages, validationoptions);
      this->AddTypedIssues(result.messages);
    }

    IF (ObjectExists(typescriptresultpromise))
    {
      RECORD typescriptresult := WaitForPromise(typescriptresultpromise);
      FOREVERY (RECORD issue FROM typescriptresult.issues)
      {
        //We can't limit what TSC checks, but we can at least ignore the messages
        IF(GetNameFromPath(issue.resourcename) NOT LIKE this->options.filemask)
          CONTINUE;

        /* When checking non-core modules (as 'platform' requires special handling to not ignore the other modules/jssdk) ignore TS errors outside that module. They're not
           in the scope of the current check and may even point to errors in eg storage/system/generated which you probably can't fix anywway */
        IF(modname NOT IN whconstant_builtinmodules AND issue.resourcename NOT LIKE `mod::${modname}/*`)
          CONTINUE;

        //Exclusions are relative to the module root, so we need to compare with the module local part (TODO and perhaps we should be dropping anything outside the current module path given the filtering we had to do inside TSC ?)
        IF(issue.resourcename LIKE `mod::${modname}/*` AND MatchesPathMasks(Substring(issue.resourcename,SearchSubstring(issue.resourcename,'/')+1), exclusions))
          CONTINUE;

        this->AddTypedIssue(issue);
      }

    }

    RECORD formatresult := WaitForPromise(checkformattingpromise);
    FOREVERY (RECORD issue FROM formatresult.issues)
      this->AddIssue(issue, issue.category);
  }

  PUBLIC RECORD ARRAY FUNCTION GetIssues()
  {
    RETURN this->seenissues;
  }
>;

PUBLIC RECORD ARRAY FUNCTION CheckModule(STRING modulename, RECORD options DEFAULTSTO CELL[])
{
  OBJECT checker := NEW CheckerObject;
  checker->Check(modulename,options);

  RETURN checker->GetIssues();
}
