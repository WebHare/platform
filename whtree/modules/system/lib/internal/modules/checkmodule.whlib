<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::internal/interface.whlib";

LOADLIB "mod::publisher/lib/search/searchfilters.whlib";
LOADLIB "mod::publisher/lib/search/support.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/validation.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/modules/node.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/validation/config.whlib";
LOADLIB "mod::system/lib/internal/validation/javascript.whlib";
LOADLIB "mod::system/lib/internal/validation/scan.whlib";


OBJECTTYPE CheckerObject
<
  RECORD options;
  RECORD ARRAY seenissues;
  STRING module;
  RECORD validateconfig;

  MACRO AddIssue(RECORD issue, STRING category)
  {
    IF(category = "warning" AND NOT CellExists(issue,'source'))
    {
      dumpvalue(issue);
      THROW NEW Exception(`Warning is missing a source`);
    }

    IF(this->validateconfig.futuremodule AND category = "error")
      category := "warning";
    ELSE IF(this->validateconfig.nowarnings AND category = "warning" AND issue.source NOT IN["eslint"])
      category := "error";

    RECORD rec := CELL[ issue.resourcename, issue.line, issue.col, issue.message, category ];
    RECORD pos := RecordLowerBound(this->seenissues, rec, [ "RESOURCENAME", "LINE", "COL", "CATEGORY", "MESSAGE" ]);
    IF (pos.found)
      RETURN;

    INSERT rec INTO this->seenissues AT pos.position;
    IF(this->options.printissues AND NOT (category = "hint" AND this->options.hidehints))
      Print(`${category="error"?`${AnsiCmd("red")}ERR!:`:category="warning"?"Warn:":"Hint:"}${AnsiCmd("reset")} ${issue.resourcename}:${issue.line}${issue.col > 0 ? ":" || issue.col : ""} ${issue.message}\n`);
  }

  MACRO OnSkippedFile(STRING resourcename, STRING why)
  {
    IF(this->options.printissues AND NOT this->options.hidehints)
      Print(`Info: Skipping ${resourcename} because: ${why}\n`);
  }

  MACRO VerifyModuleDefinition(STRING modname)
  {
    RECORD moddef := GetWebhareModuleInfo(modname);
    STRING moddefname := `mod::${modname}/moduledefinition.xml`;

    //validate searchfilter objects
    __searchfilterprops := [ context := DEFAULT OBJECT ];
    FOREVERY (RECORD filter FROM moddef.searchfilters)
    {
      TRY
      {
        OBJECT filterobject := MakeObject(filter.filterobjname);

        IF (filterobject NOT EXTENDSFROM BaseSearchFilter)
          THROW NEW Exception(`Search filterobject '${filter.filterobjname}' does not derive from BaseSearchFilter`);

        ValidateOptions(
            [ matchlabel := ""
            , matchtype := DEFAULT RECORD ARRAY
            , textquery := ""
            , datequery := DEFAULT RECORD
            , valuequery := DEFAULT RECORD ARRAY
            , valuequerytype := ""
            , selectquery := DEFAULT RECORD
            , customquery := DEFAULT FUNCTION PTR
            ], filterobject->GetFields(),
            [ title := "fields"
            , optional := [ "*" ]
            //, notypecheck := [ "textquery" ] //ADDME: If we want to support input types other than text
            ]);

      }
      CATCH(OBJECT e)
      {
        this->AddIssue([ resourcename := moddefname, line := filter.linenum, col := 0, message := e->what ], "error"  );
      }
    }
  }

  PUBLIC MACRO Check(STRING modname, RECORD options)
  {
    this->module := modname;
    this->options := ValidateOptions([ printissues := FALSE
                                     , debug := FALSE
                                     , onlytids := FALSE
                                     , filemask := ""
                                     , color := FALSE
                                     , documentation := FALSE
                                     , nowarnings := FALSE
                                     , hidehints := FALSE
                                     , checktypescript := TRUE
                                     , onlypaths := STRING[]
                                     ], options);

    IF(this->options.filemask = "")
      this->options.filemask := "*";
    IF (this->options.color)
      SetAnsiCmdMode("enabled");

    STRING ARRAY issues;
    STRING moddir;
    IF (modname != "jssdk")
    {
      moddir := GetModuleInstallationRoot(modname);
      IF(moddir="")
        THROW NEW Exception(`No such module '${modname}'`);
    }

    OBJECT typescriptresultpromise, checkformattingpromise;
    IF (this->options.checktypescript)
      typescriptresultpromise := CheckModuleTypeScriptFiles(modname IN whconstant_builtinmodules ? "platform" : modname);
    checkformattingpromise := CheckModuleJavascriptFormatting(modname, CELL[ this->options.onlypaths, this->options.filemask ]);

    this->validateconfig := GetModuleValidationConfig(modname = "jssdk" ? "system" : modname);
    IF(this->validateconfig.futuremodule)
      Print(`INFO: Module '${modname}' does not apply to this WebHare (${this->validateconfig.futuremodulewhy}) - all errors will be treated as warnings\n`);
    IF(this->options.nowarnings)
      this->validateconfig.nowarnings := TRUE;

    //verify node modules, if node_modules matches it (eg '*', '**' etc)
    IF("node_modules" LIKE this->options.filemask AND moddir != "")
    {
      RECORD ARRAY nodeissues := CheckNodeModulesInModule(moddir);
      FOREVERY(RECORD issue FROM nodeissues)
        this->AddIssue([ resourcename := GetResourceNameFromDiskPath(issue.basepath), line := 0, col := 0, message := issue.error ], "error");
    }

    //verify moduledefinition
    IF (modname != "jssdk")
      this->VerifyModuleDefinition(modname);

    //verify code
    STRING ARRAY scanlist := GetValidatableFiles(this->validateconfig, modname
                                                 , [ onskippedfile := PTR this->OnSkippedFile
                                                   , filemask := this->options.filemask
                                                   ]);

    FOREVERY(STRING toscan FROM scanlist)
    {
      IF (IsValueSet(this->options.onlypaths))
      {
        STRING path := GetWebHareResourceDiskPath(toscan);
        IF (path NOT IN this->options.onlypaths)
          CONTINUE;
      }

      IF(this->options.debug)
        Print(`${toscan}\n`);

      RECORD result := ValidateSingleFile(toscan, [ onlytids := this->options.onlytids
                                                  , ...GetValidationOptionsFromConfig(this->validateconfig)
                                                  , documentation := this->options.documentation
                                                  ]);

      FOREVERY(RECORD issue FROM result.errors)
        this->AddIssue(issue,"error");
      FOREVERY(RECORD issue FROM result.warnings)
        this->AddIssue(issue,"warning");
      FOREVERY(RECORD issue FROM result.hints)
        this->AddIssue(issue,"hint");
    }

    IF (ObjectExists(typescriptresultpromise))
    {
      STRING ARRAY exclusions := SELECT AS STRING ARRAY mask FROM this->validateconfig.excludemasks;
      RECORD typescriptresult := WaitForPromise(typescriptresultpromise);
      FOREVERY (RECORD issue FROM typescriptresult.issues)
      {
        //We can't limit what TSC checks, but we can at least ignore the messages
        IF(GetNameFromPath(issue.resourcename) NOT LIKE this->options.filemask)
          CONTINUE;

        //Exclusions are relative to the module root, so we need to compare with the module local part (TODO and perhaps we should be dropping anything outside the current module path given the filtering we had to do inside TSC ?)
        IF(issue.resourcename LIKE `mod::${modname}/*` AND MatchesPathMasks(Substring(issue.resourcename,SearchSubstring(issue.resourcename,'/')+1), exclusions))
          CONTINUE;

        this->AddIssue(issue, issue.type);
      }

    }

    RECORD formatresult := WaitForPromise(checkformattingpromise);
    FOREVERY (RECORD issue FROM formatresult.issues)
      this->AddIssue(issue, issue.category);
  }

  PUBLIC RECORD ARRAY FUNCTION GetIssues()
  {
    RETURN this->seenissues;
  }
>;

PUBLIC RECORD ARRAY FUNCTION CheckModule(STRING modulename, RECORD options DEFAULTSTO CELL[])
{
  OBJECT checker := NEW CheckerObject;
  checker->Check(modulename,options);

  RETURN checker->GetIssues();
}
