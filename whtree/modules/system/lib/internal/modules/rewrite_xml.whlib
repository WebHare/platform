<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/validation.whlib";

CONSTANT STRING tollium_ns := "http://www.webhare.net/xmlns/tollium/screens";
CONSTANT STRING publisher_sp := "http://www.webhare.net/xmlns/publisher/siteprofile";
CONSTANT STRING publisher_ns := "http://www.webhare.net/xmlns/publisher/components";
CONSTANT STRING moduledef_ns := whconstant_xmlns_moduledef;
CONSTANT STRING dbschema_ns := "http://www.webhare.net/xmlns/whdb/databaseschema";
CONSTANT STRING wrd_ns := "http://www.webhare.net/xmlns/wrd/components";
CONSTANT STRING wrdschemadef_ns := "http://www.webhare.net/xmlns/wrd/schemadefinition";

CONSTANT RECORD ARRAY fixelements :=
  [ [ namespace := "*",        localnames := ["*"],        attributesorder :=  ["composition","cellname","name" //composition=.. name=.. had 1000+ hits, name=.. composition=.. was close to 500.. so close call
                                                                               ,"type","width","height","minwidth","minheight"]
                                                         , tidattributes := ["tid"]
    ]
  , [ namespace := tollium_ns, localnames := ["messagebox"],    attributesorder := ["name","icon","button"] ] //icon .. button was 400+ hits, button .. icon was about 100... and its deprecated anyway so just change as little as possible
  , [ namespace := tollium_ns, localnames := ["option"],       attributesorder := ["rowkey"] ]
  , [ namespace := tollium_ns, localnames := ["panel","cell","list","part"]
    , removeattributes := ["border"]
    ]
  , [ namespace := tollium_ns, localnames := ["list"]
    , xslistattributes := ["icons"]
    ]
  , [ namespace := wrd_ns, localnames := ["entitiesedit"]
    , xslistattributes := ["icons", "requestcolumns"]
    ]
  , [ namespace := tollium_ns, localnames := ["*"]
    , removeattributes := ["margintop","marginbottom","marginleft","marginright"]
    ]
  , [ namespace := tollium_ns, localnames := ["screens"],  subelementspacing := "betweenall" ]
  , [ namespace := tollium_ns, localnames := ["screen"],   subelementspacing := "internal" ]
  , [ namespace := tollium_ns, localnames := ["toolbar"],   eliminateifempty := TRUE ]
  //, [ namespace := tollium_ns, localnames := ["action"],   attributesorder :=  ["source","min","max","checkflags"] ]
  , [ namespace := tollium_ns, localnames := ["enableon"], attributesorder :=  ["source","min","max","checkflags"] ]
  , [ namespace := tollium_ns, localnames := ["textedit"], attributesorder :=  ["minlength","maxlength","minvalue","maxvalue"] ]
  , [ namespace := tollium_ns, localnames := ["list"],     removeattributes := ["rowselect"] ]

  , [ namespace := publisher_sp, localnames := ["siteprofile"],  subelementspacing := "betweenall"  ]
  , [ namespace := publisher_sp, localnames := ["contenttype"],  removeattributevalues := ["cloneoncopy=true"], attributesorder := ["namespace"] ]
  , [ namespace := publisher_sp, localnames := ["foldertype"], attributesorder := ["typedef"] ]
  , [ namespace := publisher_sp, localnames := ["filetype"], attributesorder := ["typedef"] ]
  , [ namespace := publisher_sp, localnames := ["to"], attributesorder := ["type","filetype","foldertype","parenttype"] ]
  , [ namespace := publisher_sp, localnames := ["extendproperties"], attributesorder := ["extension"] ]

  , [ namespace := publisher_ns, localnames := ["browseforobject"],  xslistattributes := ["accepttypes"]  ]

  , [ namespace := moduledef_ns, localnames := ["task", "runatstartup"], fixscriptpaths := ["script"]  ]
  , [ namespace := moduledef_ns, localnames := ["task", "runatstartup"], wraplineat := 300, attributesorder := ["runat", "runtz", "script", "tag"]  ]
  , [ namespace := moduledef_ns, localnames := ["module" ], subelementspacing := "betweenall"  ]
  , [ namespace := moduledef_ns, localnames := ["services","servicemanager","portal","publisher","moduleregistry","packaging","rights"],  subelementspacing := "internal", subelementjoinsamename := TRUE ]
  , [ namespace := moduledef_ns, localnames := ["version","description"],  subelementspacing := "none" ]

  , [ namespace := dbschema_ns, localnames := ["documentation"],  subelementspacing := "none" ]

  , [ namespace := wrdschemadef_ns, localnames := ["schema"], wraplineat := 300  ]
  ];

CONSTANT RECORD initialformattingstate :=
  [ indent := ""
  , indentstepsize := 2
  , wraplineat := 125
  , subelementspacing := ""
  , subelementjoinsamename := FALSE
  , resourcename := ""
  ];

STRING FUNCTION FixScriptPath(STRING resourcename, STRING inpath)
{
  STRING directpath := MakeAbsoluteResourcePath(resourcename, inpath);
  STRING testpath := "scripts/" || inpath;
  STRING implicitpath := MakeAbsoluteResourcePath(resourcename, testpath);

  IF(NOT RecordExists(RetrieveWebHareResource(directpath, [allowmissing := TRUE]))
     AND RecordExists(RetrieveWebHareResource(implicitpath, [allowmissing := FALSE])))
  {
    RETURN testpath;
  }
  RETURN inpath;
}

BOOLEAN FUNCTION IsPrefixUsed(OBJECT el, STRING findprefix)
{
  IF(el->prefix = findprefix)
    RETURN TRUE;
  IF(RecordExists(SELECT FROM el->ListAttributes() WHERE prefix = findprefix OR nodevalue LIKE prefix || ":*")) //assume a "xx:" is a qualify named references
    RETURN TRUE;
  FOREVERY(OBJECT child FROM el->ListChildren("*","*"))
    IF(IsPrefixUsed(child, findprefix))
     RETURN TRUE;
  RETURN FALSE;
}

STRING FUNCTION FixTid(STRING intid)
{
  IF(intid LIKE "tollium:common.actions.*" AND GetTid(intid) = GetTid("~" || Substring(intid,23)))
    RETURN "~" || Substring(intid,23);
  IF(intid LIKE "tollium:common.labels.*" AND GetTid(intid) = GetTid("~" || Substring(intid,22)))
    RETURN "~" || Substring(intid,22);
  IF(intid LIKE "tollium:common.buttons.*" AND GetTid(intid) = GetTid("~" || Substring(intid,23)))
    RETURN "~" || Substring(intid,23);
  RETURN intid;
}

STRING FUNCTION EncodeAttrValue(STRING text)
{
  text := Substitute(Substitute(text,'&','&amp;'),'<','&lt;');

  IF(text LIKE '*"*' AND text NOT LIKE "*'*") //if it contains a double quote but no single quote, prefer a single quote escape
    RETURN `'${Substitute(text,"'",'&apos;')}'`;
  ELSE
    RETURN `"${Substitute(text,'"','&quot;')}"`;
}

BOOLEAN FUNCTION HasContents(OBJECT node)
{
  FOR(node := node->firstchild; ObjectExists(node); node := node->nextsibling)
    IF(node->nodetype != 3 OR TrimWhitespace(node->nodevalue) != "")
      RETURN TRUE;
  RETURN FALSE;
}

STRING FUNCTION RewiteXMLElement(OBJECT el, RECORD formattingstate)
{
  STRING usenodename := el->nodename;
  BOOLEAN eliminateifempty;

  //some properties we reset at each level
  formattingstate.subelementspacing := initialformattingstate.subelementspacing;
  formattingstate.wraplineat := initialformattingstate.wraplineat;

  RECORD substate := formattingstate;

  RECORD ARRAY attrs := el->ListAttributes();
  RECORD ARRAY elsettings := SELECT *
                               FROM fixelements
                              WHERE (fixelements.namespace = "*" OR fixelements.namespace = el->namespaceuri)
                                     AND (el->localname IN fixelements.localnames OR "*" IN fixelements.localnames);

  attrs := SELECT * FROM attrs ORDER BY nodename;

  STRING ARRAY attributesorder, tidattributes, xslistattributes;
  FOREVERY(RECORD elsetting FROM elsettings)
  {
    //remove deprecated attributes
    IF(CellExists(elsetting, "removeattributes"))
      DELETE FROM attrs WHERE namespaceuri = "" AND attrs.nodename IN elsetting.removeattributes;

    IF(CellExists(elsetting, "removeattributevalues"))
      FOREVERY(STRING toremove FROM elsetting.removeattributevalues)
      {
        STRING attrname := Tokenize(toremove, '=')[0];
        STRING attrvalue := Substring(toremove, Length(attrname) + 1);
        DELETE FROM attrs WHERE namespaceuri = "" AND attrs.nodename = attrname AND attrs.nodevalue = attrvalue;
      }

    //order attributes in preferred order
    IF(CellExists(elsetting, "attributesorder"))
      attributesorder := attributesorder CONCAT elsetting.attributesorder;

    IF(CellExists(elsetting, "tidattributes"))
      tidattributes := tidattributes CONCAT elsetting.tidattributes;

    IF(CellExists(elsetting, "xslistattributes"))
      xslistattributes := xslistattributes CONCAT elsetting.xslistattributes;

    IF(CellExists(elsetting, "eliminateifempty"))
      eliminateifempty := elsetting.eliminateifempty;

    IF(CellExists(elsetting, "subelementspacing"))
      substate.subelementspacing := elsetting.subelementspacing;

    IF(CellExists(elsetting, "wraplineat"))
      substate.wraplineat := elsetting.wraplineat;

    IF(CellExists(elsetting, "fixscriptpaths"))
      UPDATE attrs SET nodevalue := FixScriptPath(formattingstate.resourcename, nodevalue) WHERE nodename IN elsetting.fixscriptpaths;

    IF(CellExists(elsetting, "subelementjoinsamename"))
      substate.subelementjoinsamename := elsetting.subelementjoinsamename;
  }

  IF(eliminateifempty AND NOT HasContents(el))
    RETURN "";

  //sort and detect lists
  attrs := SELECT *
                , isxslist := nodename IN xslistattributes
             FROM attrs
            ORDER BY nodename IN attributesorder ? SearchElement(attributesorder, nodename) : 10000+#attrs;

  UPDATE attrs SET nodevalue := FixTid(nodevalue) WHERE nodename IN tidattributes;
  UPDATE attrs SET nodevalue := Detokenize(ParseXSList(nodevalue),' ') WHERE isxslist;

  DELETE FROM attrs WHERE namespaceuri = "http://www.w3.org/2000/xmlns/" AND prefix != "" AND NOT IsPrefixUsed(el, localname);

  INTEGER numxmlnsattrs := Length(SELECT FROM attrs WHERE namespaceuri = "http://www.w3.org/2000/xmlns/");
  IF(numxmlnsattrs > 0)
  {
    //we always prefer xmlns= first
    attrs := SELECT * FROM attrs ORDER BY namespaceuri = "http://www.w3.org/2000/xmlns/" DESC;
  }

  //encode the attributes (in case we want to switch to single quotes)
  attrs := SELECT *, encoded := EncodeAttrValue(nodevalue) FROM attrs;

  //here we go!
  STRING result;

  result := result || formattingstate.indent || '<' || usenodename;
  STRING trysingleline := result;
  FOREVERY(RECORD attr FROM attrs)
    trysingleline := `${trysingleline} ${attr.nodename}=${attr.encoded}`;

  IF(Length(trysingleline) > substate.wraplineat  //too long, wrap it!
     OR numxmlnsattrs > 1) //we don't like more than one xmlns attribute unwrapped
  {
    FOREVERY(RECORD attr FROM attrs)
    {
      IF(#attr = 0)
        result := `${result} ${attr.nodename}=`;
      ELSE //next line,indent!
        result := `${result}\n${formattingstate.indent}${RepeatText(" ", Length(usenodename) + 1)} ${attr.nodename}=`;

      INTEGER curpos := Length(Tokenize(result,'\n')[END-1]);
      //rewrite xslist attributes into multiline versions? (eg long icon lists)
      IF(attr.isxslist AND curpos + Length(attr.encoded) > substate.wraplineat) //adding the attribute would cause us to exceed maximum line Length
      {
        STRING ARRAY items := ParseXSList(attr.nodevalue);
        FOREVERY(STRING val FROM items)
        {
          IF(#val = 0)
            result := `${result}"${EncodeAttributeValue(val)}`;
          ELSE
            result := `${result}${RepeatText(" ", curpos+1)}${EncodeAttributeValue(val)}`;

          IF(#val = Length(items) - 1)
            result := `${result}"`;
          ELSE
            result := `${result}\n`;
        }
      }
      ELSE
      {
        result := `${result}${attr.encoded}`;
      }
    }
  }
  ELSE
  {
    result := trysingleline;
  }

  IF(NOT HasContents(el))
  {
    RETURN result || ' />\n';
  }

  substate.indent := substate.indent || RepeatText(" ", substate.indentstepsize);

  result := result || '>';
  IF(substate.subelementspacing != "none")
    result := result || '\n';

  //Write our children
  result := result || RewriteChildren(el, substate);

  IF(substate.subelementspacing != "none")
    result := result ||formattingstate.indent;

  result := result ||  "</" || usenodename || ">\n";
  RETURN result;
}

STRING FUNCTION RewriteChildren(OBJECT node, RECORD formattingstate)
{
  STRING output;
  BOOLEAN onnextline := TRUE;
  BOOLEAN anycontent := FALSE;
  BOOLEAN justdidmultilinecomment := FALSE;

  FOR(node := node->firstchild; ObjectExists(node); node := node->nextsibling)
  {
    IF(node->nodetype = 1)
    {
      IF(formattingstate.subelementspacing = "betweenall" AND NOT anycontent AND NOT justdidmultilinecomment)
        output := output || '\n';

      justdidmultilinecomment := FALSE;

      STRING noderesult := RewiteXMLElement(node, formattingstate);
      IF(noderesult = "") //node cancelled itself
      {
        //should we 'onnextline'?
        CONTINUE;
      }

      output := output || noderesult;
      IF(formattingstate.subelementspacing = "betweenall"
         OR (formattingstate.subelementspacing = "internal" AND NOT node->IsSameNode(node->parentnode->lastelementchild)))
      {
        //potential vertical space....
        IF(NOT (formattingstate.subelementjoinsamename //we can join everything togheter?
                AND ObjectExists(node->nextelementsibling) //first node, so ignore samename join
                AND node->nextelementsibling->localname = node->localname))
        {
          output := output || '\n';
        }
      }

      onnextline := FALSE;
      anycontent := TRUE;
    }
    ELSE IF(node->nodetype = 3) //textcontent
    {
      justdidmultilinecomment := FALSE;

      STRING content := node->textcontent;
      onnextline := content LIKE "*\n*";

      content := TrimWhitespace(content);
      IF(content = "")
        CONTINUE;

      output := output || EncodeTextNode(content);
    }
    ELSE IF(node->nodetype = 8) //comment
    {
      justdidmultilinecomment := FALSE;

      //Reformat the coment. surround it with one space but don't add next to a linefeed
      STRING comment := node->nodevalue;
      WHILE(Left(comment,1) = ' ')
        comment := Substring(comment,1);
      IF(comment NOT LIKE "*\n*") //not a multiline comment (prevent reverse indenting the -->)
        WHILE(Right(comment,1) = ' ')
          comment := Left(comment,Length(comment)-1);
      IF(Left(comment,1) != '\n')
        comment := " " || comment;
      IF(Right(comment,1) NOT IN [' ',"\n"])
        comment := comment || " ";

      STRING encodedcomment := `<!--${comment}-->`;
      IF(NOT onnextline AND output LIKE "*\n" AND NOT node->parentnode->IsSameNode(node->ownerdocument))
      {
        //this comment was on the sameline as the last element in the source... should we combine it ?
        output := Left(output, Length(output) - 1);
        output := `${output}  ${encodedcomment}\n`;
      }
      ELSE
      {
        IF(ObjectExists(node->previouselementsibling) AND output NOT LIKE "*\n\n")
          output := output || "\n"; //if we're not the first subchild, we want an empty line above our comments so it acts as a group

        BOOLEAN mustindent := TRUE;
        //Unless we seem to start at the leftmost column, indent us
        IF(ObjectExists(node->previoussibling) AND node->previoussibling->nodevalue LIKE "*\n")
          mustindent := FALSE;

        output := `${output}${mustindent ? formattingstate.indent : ""}${encodedcomment}\n`;
      }
      onnextline := FALSE;
    }
    ELSE
    {
      ABORT(CELL[node->nodetype,node->nodevalue]);
    }
  }
  RETURN output;
}

MACRO ApplyWidgetRewrite(OBJECT widgetnode)
{
  IF(widgetnode->GetAttribute("editfragment") = "")
    RETURN;

  STRING fragmentpath := widgetnode->GetAttribute("editfragment");
  IF(Left(fragmentpath,1) NOT IN [".","#"])
    RETURN;

  //always replace . with #
  fragmentpath := "#" || Substring(fragmentpath,1);

  OBJECT ARRAY fragments := widgetnode->ownerdocument->ListElements(tollium_ns,"fragment");
  FOREVERY(OBJECT fragment FROM fragments)
    IF(fragment->GetAttribute("name") = Substring(fragmentpath,1))
    {
      IF(fragment->GetAttribute("implementation") != "none")
        RETURN; //don't dare to touch code-backed fragments

      OBJECT tabsextension := widgetnode->ownerdocument->CreateElementNS(tollium_ns,"tabsextension");
      tabsextension->SetAttribute("xmlns", tollium_ns);
      FOREVERY(RECORD attr FROM fragment->ListAttributes())
      {
        IF(attr.localname="xmlns")
          CONTINUE;
        IF(attr.nodename="implementation")
          CONTINUE;

        tabsextension->SetAttributeNS(attr.namespaceuri, attr.localname ?? attr.nodename, attr.nodevalue);
      }

      OBJECT newtab := widgetnode->ownerdocument->CreateElementNS(tollium_ns,"newtab");
      tabsextension->AppendChild(newtab);

      OBJECT contentsnode := fragment->ListChildren(tollium_ns,"contents")[0];
      FOREVERY(RECORD attr FROM contentsnode->ListAttributes())
      {
        IF(attr.localname="xmlns")
          CONTINUE;
        IF(attr.nodename="implementation")
          CONTINUE;

        newtab->SetAttributeNS(attr.namespaceuri, attr.localname ?? attr.nodename, attr.nodevalue);
      }

      //Migrate nodes
      WHILE(Objectexists(contentsnode->firstchild))
        newtab->AppendChild(contentsnode->firstchild);

      //Replace composition=contentdata with composition=fsinstance
      FOREVERY(OBJECT node FROM newtab->GetElements(`*[composition="fsinstance"]`))
        node->SetAttribute("composition", "contentdata");

      fragment->parentnode->replacechild(tabsextension, fragment);

      widgetnode->SetAttribute("editextension", fragmentpath);
      widgetnode->RemoveAttribute("editfragment");
      RETURN ;
   }
}

MACRO ApplyExtendPropertiesRewrite(OBJECT extendpropertiesnode)
{
  STRING propertyeditor := extendpropertiesnode->GetAttribute("name");
  IF(propertyeditor="")
    RETURN;

  OBJECT ARRAY fragments := extendpropertiesnode->ownerdocument->ListElements(publisher_sp,"propertyeditor");
  FOREVERY(OBJECT fragment FROM fragments)
    IF(fragment->GetAttribute("name") = propertyeditor)
    {
      OBJECT tabsextension := extendpropertiesnode->ownerdocument->CreateElementNS(tollium_ns,"tabsextension");
      tabsextension->SetAttribute("xmlns", tollium_ns);
      FOREVERY(RECORD attr FROM fragment->ListAttributes())
        tabsextension->SetAttributeNS(attr.namespaceuri, attr.localname ?? attr.nodename, attr.nodevalue);

      //Remove p:whfsinstance instance
      BOOLEAN foundfsinstance;
      FOREVERY(OBJECT whfsinstance FROM fragment->ListElements(publisher_ns,"whfsinstance"))
        IF(whfsinstance->GetAttribute("name") = "fsinstance")
        {
          extendpropertiesnode->SetAttribute("contenttype", whfsinstance->GetAttribute("typedef"));
          whfsinstance->Dispose();
          foundfsinstance := TRUE;
        }

      IF(NOT foundfsinstance)
        RETURN;

      OBJECT ARRAY compositions := fragment->ListElements(publisher_sp,"compositions");
      IF(Length(compositions) = 1)
      {
        IF(Length(compositions[0]->ListChildren("*","*")) > 0)
        {
          OBJECT newcompositions := extendpropertiesnode->ownerdocument->CreateElementNS(tollium_ns,"compositions");
          tabsextension->AppendChild(newcompositions);
          WHILE(ObjectExists(compositions[0]->firstchild))
            newcompositions->AppendChild(compositions[0]->firstchild);
        }
        compositions[0]->Dispose();
      }

      FOREVERY(OBJECT contentsnode FROM fragment->ListChildren("*","*"))
      {
        OBJECT newtabinsert := extendpropertiesnode->ownerdocument->CreateElementNS(tollium_ns,contentsnode->localname);
        tabsextension->AppendChild(newtabinsert);

        FOREVERY(RECORD attr FROM contentsnode->ListAttributes())
        {
          IF(attr.localname="xmlns")
            CONTINUE;
          IF(attr.nodename="implementation")
            CONTINUE;

          newtabinsert->SetAttributeNS(attr.namespaceuri, attr.localname ?? attr.nodename, attr.nodevalue);
        }

        //Migrate nodes
        WHILE(Objectexists(contentsnode->firstchild))
          newtabinsert->AppendChild(contentsnode->firstchild);
      }

      //Replace composition=contentdata with composition=fsinstance
      FOREVERY(OBJECT node FROM tabsextension->GetElements(`*[composition="fsinstance"]`))
        node->SetAttribute("composition", "contentdata");

      //Kill redundant namespace prefixes
      FOREVERY(OBJECT node FROM tabsextension->ListElements(tollium_ns,"*"))
        IF(node->prefix != "")
        {
          OBJECT betternode := extendpropertiesnode->ownerdocument->CreateElementNS(tollium_ns, node->localname);
          FOREVERY(RECORD attr FROM node->ListAttributes())
          {
            IF(attr.localname="xmlns")
              CONTINUE;
            betternode->SetAttributeNS(attr.namespaceuri, attr.localname ?? attr.nodename, attr.nodevalue);
          }
          WHILE(Objectexists(node->firstchild))
            betternode->AppendChild(node->firstchild);

          node->parentnode->replacechild(betternode, node);
        }

      fragment->parentnode->replacechild(tabsextension, fragment);

      extendpropertiesnode->SetAttribute("extension", "#"||propertyeditor);
      extendpropertiesnode->RemoveAttribute("name");
      RETURN ;
    }

  RETURN; //no match
}

MACRO ApplyTaskRuntimeRewrite(OBJECT tasknode)
{
  INTEGER interval := ToInteger(tasknode->GetAttribute("runinterval"),0);
  STRING runtime := tasknode->GetAttribute("runtime");
  IF(interval <= 0 OR runtime NOT LIKE "?*:??")
    RETURN; //cannot rewrite

  INTEGER hour := ToInteger(Tokenize(runtime,':')[0],-100) + 1; //add 1 hour, assume user meant Winter CET
  IF(hour = 24)
    hour := 0;
  IF(hour < 0)
    RETURN; //Wooooo! confused!

  INTEGER minute := ToInteger(Tokenize(runtime,':')[1],-100);
  IF(minute < 0 OR minute >= 60)
    RETURN; //Wooooo! confused!

  STRING runat;
  IF(60 % interval = 0 AND interval <= 60) //we run every hour or more often, on fixed intervals... easy fix!
  {
    STRING ARRAY intervals;
    //find first occurence
    WHILE(minute - interval > 0)
      minute := minute - interval;

    WHILE(minute < 60)
    {
      INSERT ToString(minute) INTO intervals AT END;
      minute := minute + interval;
    }

    runat := Detokenize(intervals,',') || " * * * *";
  }
  ELSE IF(1440 % interval = 0 AND interval % 60 = 0) //we run every day or more often, on fixed intervals and the same minute each hour
  {
    STRING ARRAY intervals;
    INTEGER hourinterval := interval / 60;
    //find first occurence
    WHILE(hour - hourinterval > 0)
      hour := hour - hourinterval;

    WHILE(hour < 24)
    {
      INSERT ToString(hour) INTO intervals AT END;
      hour := hour + hourinterval;
    }

    runat := minute || " " || Detokenize(intervals,',') || " * * *";
  }
  ELSE
  {
    RETURN;
  }

  tasknode->SetAttribute("runat", runat);
  tasknode->SetAttribute("runtz", "Europe/Amsterdam");
  tasknode->RemoveAttribute("runinterval");
  tasknode->RemoveAttribute("runtime");
}

MACRO ApplyRewrites(OBJECT xmldoc)
{
  FOREVERY(OBJECT widgetnode FROM xmldoc->ListElements(publisher_sp,"widgettype"))
    ApplyWidgetRewrite(widgetnode);

  FOREVERY(OBJECT extendpropertiesnode FROM xmldoc->ListElements(publisher_sp,"extendproperties"))
    ApplyExtendPropertiesRewrite(extendpropertiesnode);

  FOREVERY(OBJECT tasknode FROM xmldoc->ListElements(moduledef_ns,"task"))
    ApplyTaskRuntimeRewrite(tasknode);
}

PUBLIC STRING FUNCTION RewriteXMLFile(STRING infile, BLOB indata)
{
  OBJECT xmldoc := MakeXMLDocument(indata);
  IF(Length(xmldoc->GetParseErrors()) > 0)
    THROW NEW Exception(FormatValidationError(xmldoc->GetParseErrors()[0]));

  ApplyRewrites(xmldoc);

  RECORD formatting := initialformattingstate;
  formatting.resourcename := infile;
  STRING result := '<?xml version="1.0" encoding="UTF-8"?>\n' || RewriteChildren(xmldoc, formatting);
  RETURN result;
}
