<?wh
LOADLIB "wh::files.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/semver.whlib";


RECORD ARRAY FUNCTION ListNodePackageRoots(STRING basepath)
{
  RECORD ARRAY packageroots;
  IF (basepath NOT LIKE "*/")
    basepath := basepath || "/";

  IF(RecordExists(GetDiskFileProperties(basepath || "package.json")))
  {
    INSERT [ type := "root"
           , basepath := basepath
           , modulespath := MergePath(basepath,"node_modules")
           ] INTO packageroots AT END;
  }

  RECORD ARRAY webdesigns := ReadDiskDirectory(basepath || "webdesigns", "*");
  FOREVERY(RECORD webdesign FROM webdesigns)
    IF(webdesign.name NOT LIKE ".*" AND webdesign.type = 1 AND RecordExists(GetDiskFileProperties(webdesign.path || "/package.json")))
      INSERT [ type := "webdesign"
             , basepath := webdesign.path || "/"
             , modulespath := MergePath(webdesign.path,"node_modules")
             ] INTO packageroots AT END;

  RETURN packageroots;
}

RECORD ARRAY FUNCTION ListActualV2Packages(STRING packagedir, STRING path)
{
  RECORD ARRAY packages;

  FOREVERY(RECORD direntry FROM ReadDiskDirectory(packagedir,"*"))
  {
    IF(direntry.type != 1 OR direntry.name LIKE ".*")
      CONTINUE;

    STRING name := MergePath(path, direntry.name);
    IF(direntry.name LIKE "@*") //scoped packages
    {
      packages := packages CONCAT ListActualV2Packages(direntry.path, name);

      CONTINUE;
    }

    INSERT CELL
        [ name
        , direntry.modified
        ] INTO packages AT END;

    STRING submodules := MergePath(direntry.path, "node_modules");
    IF (RecordExists(GetDiskFileProperties(submodules)))
      packages := packages CONCAT ListActualV2Packages(submodules, MergePath(name, "node_modules"));
  }

  RETURN packages;
}

BOOLEAN FUNCTION NPMPackageVersionSatisfiesRange(STRING version, STRING semverrange)
{
  //https://docs.npmjs.com/cli/v7/configuring-npm/package-json#dependencies - lots of non semvers can go in here..
  IF(semverrange LIKE "*#*" OR semverrange LIKE "*/*")
    RETURN TRUE; //if we're matching against a hash or github url, just accept any version

  BOOLEAN satisfied := VersionSatisfiesRange(version, semverrange, [ comparemode := "npm" ]);
  //IF(NOT satisfied)
  //  DumpValue(CELL[version, semverrange]);
  RETURN satisfied;
}


RECORD FUNCTION GetLockFileV2Versions(STRING packagedir, RECORD ARRAY actualnodemodules)
{
  // FIXME: should check ALL installed modules, also in node-modules subpaths too
  DATETIME max_modified := SELECT AS DATETIME MAX(modified) FROM actualnodemodules;
  RECORD ARRAY issues;

  // Remove the errors from not having a version
  UPDATE actualnodemodules SET error := "Version info could not be found";

  STRING hidden_lockfile_path := MergePath(packagedir, ".package-lock.json");

  RECORD hidden_lockfile_props := GetDiskFileProperties(hidden_lockfile_path);
  IF (hidden_lockfile_props.modified < max_modified)
    INSERT [ error := `The installed packages have been modified after the last install. Please re-run 'npm install'` ] INTO issues AT 0;
  ELSE
  {
    VARIANT data := DecodeJSONBlob(GetDiskResource(hidden_lockfile_path), DEFAULT RECORD, [ wrapobjects := TRUE ]);
    IF (IsDefaultValue(data) OR TypeID(data) != TypeID(OBJECT))
      THROW NEW Exception(`Could not parse npm hidden lock file ${hidden_lockfile_path}`);

    OBJECT packages := data->GetProp("packages");

    STRING ARRAY packagenames := GetSortedSet(SELECT AS STRING ARRAY name FROM packages->Unpack());

    FOREVERY (RECORD rec FROM packages->Unpack())
    {
      IF (rec.name NOT LIKE "node_modules/*")
        CONTINUE;

      STRING version := rec.value->GetProp("version", [ fallback := "" ]);
      IF(version = "")
        THROW NEW Exception(`No version information in ${hidden_lockfile_path}`);
      STRING package := SubString(rec.name, 13);

      UPDATE actualnodemodules
         SET actualversion :=   version
           , error :=           ""
       WHERE name = package;
    }
  }

  RETURN CELL[ issues, actualnodemodules ];
}

/** Returns all toplevel/unused packages
    @param lockpackages
    @param rootpackages
    @return Issues
*/
RECORD ARRAY FUNCTION CheckV2Requests(RECORD ARRAY lockpackages, RECORD ARRAY rootpackages)
{
  RECORD ARRAY issues;

  lockpackages :=
      SELECT name
           , version :=       value->GetProp("version", [ fallback := "" ])
           , usedby :=        STRING[]
           , dependencies :=  RECORD
                              [ ...(SELECT name, range := value FROM value->GetProp("dependencies", [ fallback := CELL[] ])->Unpack())
                              , ...(SELECT name, range := value FROM value->GetProp("optionalDependencies", [ fallback := CELL[] ])->Unpack())
                              ]
        FROM lockpackages;

  INSERT
      [ name :=           ""
      , version :=        ""
      , usedby :=         STRING[ "*" ]
      , dependencies :=   rootpackages
      ] INTO lockpackages AT 0;

  FOREVERY (RECORD pkg FROM lockpackages)
  {
    FOREVERY (RECORD dep FROM pkg.dependencies)
    {
      STRING basepath := pkg.name = "" ? "" : pkg.name || "/";
      WHILE (TRUE)
      {
        RECORD pos := RecordLowerBound(lockpackages, [ name := `${basepath}node_modules/${dep.name}` ], [ "NAME" ]);
        IF (pos.found)
        {
          INSERT pkg.name INTO lockpackages[pos.position].usedby AT END;
          IF(lockpackages[pos.position].version = "")
            BREAK; //if npm didn't lock the version, not our problem..

          IF (pkg.name = "" AND NOT NPMPackageVersionSatisfiesRange(lockpackages[pos.position].version, dep.range))
          {
            RETURN [ [ error := `Installed module '${lockpackages[pos.position].name}' not in sync with package.json, please run 'wh fixmodules' (has version '${lockpackages[pos.position].version}', wanted range '${dep.range}')` ] ];
          }
        }
        INTEGER nmpos := SearchLastSubstring(basepath, "node_modules/");
        IF (nmpos = -1)
          BREAK;
        basepath := Left(basepath, nmpos);
      }
    }
  }

  RECORD ARRAY unused := SELECT * FROM lockpackages WHERE IsDefaultValue(usedby);
  RETURN
      SELECT error := `Module ${name} version ${version} is installed but not requested. Please run 'wh fixmodules'`
        FROM unused;
}

RECORD ARRAY FUNCTION CheckNodeFolder(RECORD nodefolder)
{
  RECORD ARRAY issues;

  TRY
  {
    //Get the actual modules and their versions
    VARIANT packagejson := DecodeJSONBlob(GetDiskResource(MergePath(nodefolder.basepath, "package.json")));
    VARIANT packagelockjson := DecodeJSONBlob(GetDiskResource(MergePath(nodefolder.basepath, "package-lock.json"), [ allowmissing := TRUE ]) ?? StringToBlob("{}"), DEFAULT RECORD, [ wrapobjects := TRUE ]);
    BLOB packagelockjsondata := GetDiskResource(MergePath(nodefolder.basepath, "package-lock.json"), [ allowmissing := TRUE ]);

    IF (IsDefaultValue(packagejson) OR TypeID(packagejson) != TypeID(RECORD))
      THROW NEW Exception(`Package folder ${nodefolder.basepath} contains an invalid package.json`);
    IF (IsDefaultValue(packagelockjson) OR TypeID(packagelockjson) != TypeID(OBJECT))
      THROW NEW Exception(`Package folder ${nodefolder.basepath} contains an invalid package-lock.json`);

    //Decode package.json modules
    RECORD deps := CellExists(packagejson, 'dependencies') ? packagejson.dependencies : CELL[];
    RECORD ARRAY flatmodules := SELECT name := ToLowercase(name), range := value FROM UnpackRecord(deps);

    FOREVERY (RECORD rec FROM SELECT * FROM flatmodules WHERE range = "" LIMIT 1)
      INSERT [ error := `Package '${rec.name}' in package.json has an empty version range. Please put one in.` ] INTO issues AT 0;

    IF(Length(packagelockjsondata) = 0) //there was no package-lock.json
    {
      IF(Length(UnpackRecord(deps)) = 0)
        RETURN issues; //No dependencies. Then it's okay to have no package-lock.json

      RETURN [ ...issues, [ error := `package-lock.json file missing. Please run 'npm install'` ] ];
    }

    IF (NOT packagelockjson->HasProp("lockfileVersion"))
    {
      RETURN [ ...issues, [ error := `package-lock.json missing version. Please run 'npm install'` ] ];
    }
    ELSE IF(packagelockjson->GetProp("lockfileVersion") < 2)
    {
      RETURN [ ...issues, [ error := `package-lock.json version '${packagelockjson->GetProp("lockfileVersion")}' not supported. Please run 'npm install'` ] ];
    }
    ELSE
    {
      // Read the packages from the package-lock.json
      RECORD ARRAY lockpackages := packagelockjson->HasProp("packages") ? SELECT * FROM packagelockjson->GetProp("packages")->Unpack() ORDER BY name : RECORD[];

      // Check if the deps in package "" from package-lock.json are a 1-to-1 match with the package.json
      RECORD ARRAY lockrootdeps_deps;
      OBJECT lockrootdeps := SELECT AS OBJECT value FROM lockpackages WHERE name = "";
      IF (ObjectExists(lockrootdeps))
      {
        lockrootdeps_deps := SELECT name, range := value FROM lockrootdeps->GetProp("dependencies", [ fallback := CELL[] ])->Unpack();
      }
      ELSE IF(Length(flatmodules) > 0)
        RETURN [ ...issues, [ error := "The package-lock.json is missing the root dependencies. Please run 'npm install'" ] ];

      IF (EncodeHSON(lockrootdeps_deps) != EncodeHSON(SELECT name, range FROM flatmodules ORDER BY name))
        RETURN [ ...issues, [ error := "The package-lock.json is not up to date with respect to the package.json. Please run 'npm install'" ] ];

      // Get the list of all installed packages on disk
      RECORD ARRAY ondiskpackages := SELECT * FROM ListActualV2Packages(nodefolder.modulespath, "node_modules") ORDER BY name;

      // Read the node_modules/.package-lock.json (with the current installed version info)
      STRING hidden_lockfile_path := MergePath(nodefolder.modulespath, ".package-lock.json");
      RECORD props := GetDiskFileProperties(hidden_lockfile_path);
      VARIANT hiddenpackagelockjson := FALSE;
      IF(RecordExists(props))
        hiddenpackagelockjson := DecodeJSONBlob(GetDiskResource(hidden_lockfile_path, [ allowmissing := TRUE ]) ?? StringToBlob("{}"), DEFAULT RECORD, [ wrapobjects := TRUE ]);

      IF (TypeID(hiddenpackagelockjson) != TypeID(OBJECT) OR NOT ObjectExists(hiddenpackagelockjson) OR NOT hiddenpackagelockjson->HasProp("packages"))
      {
        IF(Length(flatmodules) = 0 AND Length(ondiskpackages) = 0)
          RETURN issues; //it's okay to have no package-lock if there are no dependencies anyway

        RETURN [ ...issues, [ error := "No version info available for installed packages. Please run 'wh fixmodules'" ] ];
      }

      // modification date must be after the moddate of all ondisk package folders
      // this may give false alarms if run on a dev server after a module push, because all modtimes are then simply ordered by extraction order
      IF (props.modified < SELECT AS DATETIME MAX(modified) FROM ondiskpackages)
        RETURN [ ...issues, [ error := "Packages may have been manually modified after last installation. Please run 'wh fixmodules'" ] ];

      // Check if the package list is equal from listed to installed
      RECORD ARRAY packages := SELECT * FROM hiddenpackagelockjson->GetProp("packages")->Unpack() ORDER BY name;
      IF (LENGTH(packages) != LENGTH(ondiskpackages))
        RETURN [ ...issues, [ error := "Packages were manually modified after last installation. Please run 'wh fixmodules'" ] ];
      FOREVERY (RECORD package FROM packages)
        IF (ondiskpackages[#package].name != package.name)
          RETURN [ ...issues, [ error := "Packages were manually modified after last installation. Please run 'wh fixmodules'" ] ];

      // package-lock.json sometimes has extra packages that aren't installed - we just care about the ondisk package versions
      FOREVERY (RECORD package FROM packages)
      {
        // all installed packages should be named in the package lock
        RECORD pos := RecordLowerBound(lockpackages, package, [ "NAME" ]);
        IF (NOT pos.found)
          RETURN [ ...issues, [ error := "The installed packages are out of date with respect to the package-lock.json. Please run 'wh fixmodules'" ] ];

        // the version must match
        STRING seenpackageversion := package.value->GetProp("version", [ fallback := "" ]);
        STRING expectpackageversion := lockpackages[pos.position].value->GetProp("version", [ fallback := "" ]);
        IF (seenpackageversion != expectpackageversion)
          RETURN [ ...issues, [ error := "The installed packages are out of date with respect to the package-lock.json. Please run 'wh fixmodules'" ] ];
      }

      // check if all requested stuff is present on disk, and no extra modules installed
      issues := issues CONCAT CheckV2Requests(packages, flatmodules);
    }

    RETURN issues;
  }
  CATCH(OBJECT e)
  {
    RETURN RECORD[ ...issues, [ error := `Fatal exception: ${e->what}` ]];
  }
}

PUBLIC RECORD ARRAY FUNCTION CheckNodeModulesInModule(STRING modulerootdir)
{
  RECORD ARRAY issues;

  FOREVERY(RECORD nodefolder FROM ListNodePackageRoots(modulerootdir))
  {
    issues := issues CONCAT SELECT error
                                 , basepath := nodefolder.basepath
                              FROM CheckNodeFolder(nodefolder);
  }
  RETURN issues;
}
