<?wh
LOADLIB "wh::files.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/comparisons.whlib";
LOADLIB "wh::util/semver.whlib";


PUBLIC RECORD ARRAY FUNCTION ListNodePackageRoots(STRING basepath)
{
  RECORD ARRAY packageroots;
  IF (basepath NOT LIKE "*/")
    basepath := basepath || "/";

  IF(RecordExists(GetDiskFileProperties(basepath || "package.json")))
  {
    INSERT [ type := "root"
           , basepath := basepath
           , modulespath := MergePath(basepath,"node_modules")
           ] INTO packageroots AT END;
  }

  RECORD ARRAY webdesigns := ReadDiskDirectory(basepath || "webdesigns", "*");
  FOREVERY(RECORD designfolder FROM webdesigns)
    IF(designfolder.name NOT LIKE ".*" AND designfolder.type = 1 AND RecordExists(GetDiskFileProperties(designfolder.path || "/package.json")))
      INSERT [ type := "webdesign"
             , basepath := designfolder.path || "/"
             , modulespath := MergePath(designfolder.path,"node_modules")
             ] INTO packageroots AT END;

  RETURN packageroots;
}

PUBLIC RECORD ARRAY FUNCTION ListNodeModuleFolders(STRING basepath)
{
  // Quick scan
  // We only look:
  // - whether the module has a node_modules directory
  // - for each webdesign, whether they have a node_modules directory

  IF (basepath NOT LIKE "*/")
    basepath := basepath || "/";

  // Try to read /<module>/node_modules
  RECORD ARRAY nodemoduledirs :=
      //SELECT name
           //, modified
           //, COLUMN path
           //, size64
           //, type
      SELECT *
           , localpath := Substring(path, Length(basepath)) // path (in the module)
           , isnodemodule := TRUE
        FROM ReadDiskDirectory(basepath || "nodejs", "*") CONCAT ReadDiskDirectory(basepath || "js", "*")
       WHERE type > 0 AND name NOT IN [ ".DS_Store", ".git" ];

  RECORD ARRAY webdesigns :=
      SELECT *
           , localpath := Substring(path, Length(basepath)) // path (in the module)
           , isnodemodule := TRUE
        FROM ReadDiskDirectory(basepath || "webdesigns", "*")
       WHERE type > 0 AND name NOT IN [ ".DS_Store", ".git" ];

  FOREVERY(RECORD webdesign FROM webdesigns)
  {
    nodemoduledirs := nodemoduledirs CONCAT
      SELECT *
            , localpath := Substring(path, Length(basepath)) // path (in the module)
            , isnodemodule := TRUE
         FROM ReadDiskDirectory(webdesign.path || "/node_modules", "*")
        WHERE type > 0 AND name NOT IN [ ".DS_Store", ".git" ];
  }

  RETURN nodemoduledirs;
}

STRING FUNCTION GetPackageVersion(RECORD packagedata)
{
  IF(packagedata._requested.type = "git")
    RETURN packagedata._resolved;

  RETURN packagedata.version;
}

RECORD FUNCTION ParseV1Package(STRING scope, RECORD direntry)
{
  STRING jsonpath := MergePath(direntry.path, 'package.json');
  RECORD package := [ name := ToLowercase(scope || direntry.name)
                    , packagefile := jsonpath
                    , packagedata := DecodeJSONBlob(GetDiskResource(jsonpath, [ allowmissing := TRUE ]))
                    , error := ""
                    , reportedversion := ""
                    , actualversion := ""
                    , modified := direntry.modified
                    ];

  IF(NOT RecordExists(package.packagedata) OR NOT CellExists(package.packagedata,'_requested') OR NOT CellExists(package.packagedata._requested,'raw'))
  {
    package.error := "Missing or invalid package.json";
    RETURN package;
  }

  package.reportedversion := package.packagedata.version;
  package.actualversion := GetPackageVersion(package.packagedata);
  RETURN package;
}

RECORD ARRAY FUNCTION ListActualV1Packages(STRING packagedir)
{
  RECORD ARRAY packages;

  FOREVERY(RECORD direntry FROM ReadDiskDirectory(packagedir,"*"))
  {
    IF(direntry.type != 1 OR direntry.name LIKE ".*")
      CONTINUE;
    IF(direntry.name LIKE "@*") //scoped packages
    {
      FOREVERY(RECORD subdirentry FROM ReadDiskDirectory(direntry.path,"*"))
        INSERT ParseV1Package(direntry.name || "/", subdirentry) INTO packages AT END;
      CONTINUE;
    }
    INSERT ParseV1Package("",direntry) INTO packages AT END;
  }

  RETURN packages;
}

/** Recursively return all modules in a package-lock list, no grouping
*/
RECORD ARRAY FUNCTION FlattenLockedModules(RECORD ARRAY modules)
{
  RECORD ARRAY newmodules := modules;
  FOREVERY (RECORD rec FROM modules)
    IF (CellExists(rec, "dependencies"))
    {
      newmodules := newmodules CONCAT FlattenLockedModules(
          SELECT ...value
               , name :=    ToLowercase(name)
            FROM UnpackRecord(rec.dependencies));
    }
  RETURN newmodules;
}

/** Check if only requested modules are present in the package-lock
*/
RECORD ARRAY FUNCTION CheckRequests(RECORD ARRAY flatmodules, RECORD ARRAY flatlockmodules)
{
  RECORD ARRAY issues;

  /* Get all modules in the packagelock, ensure they have requires and dependencies cells.
     Order on name and version for quick access
  */
  flatlockmodules :=
      SELECT name
           , version
           , requires :=        (CellExists(row, "requires") ? row.requires : DEFAULT RECORD)
           , dependencies :=    (CellExists(row, "dependencies") ? row.dependencies : DEFAULT RECORD)
           , used :=            FALSE
        FROM FlattenLockedModules(flatlockmodules) AS row
    ORDER BY name, version;

  // Add position within array for updates of subselections
  flatlockmodules :=
      SELECT *
           , pos := #flatlockmodules
        FROM flatlockmodules;

  // List of all items scheduled at least once in the worklist
  STRING ARRAY scheduled := SELECT AS STRING ARRAY `${name}:${range}` FROM flatmodules;

  // Process all dependencies
  RECORD ARRAY worklist := flatmodules;
  WHILE (NOT IsDefaultValue(worklist))
  {
    RECORD item := worklist[0];
    DELETE FROM worklist AT 0;

    // Get all modules from the packagelock with this name
    RECORD ARRAY namematches :=
        SELECT *
             , satisfiesrange := NPMPackageVersionSatisfiesRange(version, item.range)
          FROM RecordRange(flatlockmodules, item, [ "NAME" ]);

    // Any matches?
    BOOLEAN anymatch := RecordExists(SELECT FROM namematches WHERE satisfiesrange);
    STRING wrongversion := Detokenize((SELECT AS STRING ARRAY version FROM namematches WHERE NOT satisfiesrange), ", ");

    FOREVERY (RECORD rec FROM namematches)
    {
      // If there are range match, process only those, otherwise process them all
      IF (anymatch AND NOT rec.satisfiesrange)
        CONTINUE;

      IF (NOT flatlockmodules[rec.pos].used)
      {
        // Mark as used
        flatlockmodules[rec.pos].used := TRUE;

        // Get all requires and dependencies
        RECORD ARRAY requires :=
            SELECT name := ToLowercase(name)
                 , range := value
              FROM UnpackRecord(rec.requires);

        requires := requires CONCAT
            SELECT name := ToLowercase(name)
                 , range := value.version
              FROM UnpackRecord(rec.dependencies);

        // Add unscheduled items into the worklist
        FOREVERY (RECORD req FROM requires)
        {
          STRING tag := `${req.name}:${req.range}`;
          IF (tag NOT IN scheduled)
          {
            INSERT req INTO worklist AT END;
            INSERT tag INTO scheduled AT END;
          }
        }
      }
    }

    IF (NOT anymatch)
    {
      IF (wrongversion != "")
      {
        INSERT [ error := `Wrong version for module ${item.name}, expect: ${item.range} but actual: ${wrongversion}` ] INTO issues AT END;
      }
      ELSE
      {
        INSERT [ error := `Missing module ${item.name}` ] INTO issues AT END;
      }
    }
  }

  // See if we have any modules that weren't requested. ADDME: try to process their requires/dependencies to return only the top-level package
  FOREVERY (RECORD rec FROM flatlockmodules)
    IF (NOT rec.used)
      INSERT [ error := `Module ${rec.name} version ${rec.version} is installed but not requested` ] INTO issues AT END;

  RETURN issues;
}

RECORD ARRAY FUNCTION ListActualV2Packages(STRING packagedir, STRING path)
{
  RECORD ARRAY packages;

  FOREVERY(RECORD direntry FROM ReadDiskDirectory(packagedir,"*"))
  {
    IF(direntry.type != 1 OR direntry.name LIKE ".*")
      CONTINUE;

    STRING name := MergePath(path, direntry.name);
    IF(direntry.name LIKE "@*") //scoped packages
    {
      packages := packages CONCAT ListActualV2Packages(direntry.path, name);

      CONTINUE;
    }

    INSERT CELL
        [ name
        , direntry.modified
        ] INTO packages AT END;

    STRING submodules := MergePath(direntry.path, "node_modules");
    IF (RecordExists(GetDiskFileProperties(submodules)))
      packages := packages CONCAT ListActualV2Packages(submodules, MergePath(name, "node_modules"));
  }

  RETURN packages;
}

BOOLEAN FUNCTION NPMPackageVersionSatisfiesRange(STRING version, STRING semverrange)
{
  IF(semverrange LIKE "*#*")
    RETURN TRUE; //if we're matching against a hash, just accept any version

  BOOLEAN satisfied := VersionSatisfiesRange(version, semverrange, [ comparemode := "npm" ]);
  //IF(NOT satisfied)
  //  DumpValue(CELL[version, semverrange]);
  RETURN satisfied;
}


RECORD FUNCTION GetLockFileV2Versions(STRING packagedir, RECORD ARRAY actualnodemodules)
{
  // FIXME: should check ALL installed modules, also in node-modules subpaths too
  DATETIME max_modified := SELECT AS DATETIME MAX(modified) FROM actualnodemodules;
  RECORD ARRAY issues;

  // Remove the errors from not having a version
  UPDATE actualnodemodules SET error := "Version info could not be found";

  STRING hidden_lockfile_path := MergePath(packagedir, ".package-lock.json");

  RECORD hidden_lockfile_props := GetDiskFileProperties(hidden_lockfile_path);
  IF (hidden_lockfile_props.modified < max_modified)
    INSERT [ error := `The installed packages have been modified after the last install. Please re-run 'npm install'` ] INTO issues AT 0;
  ELSE
  {
    OBJECT data := DecodeJSONBlob(GetDiskResource(hidden_lockfile_path) ?? StringToBlob("{}"), DEFAULT RECORD, [ wrapobjects := TRUE ]);
    OBJECT packages := data->GetProp("packages");

    STRING ARRAY packagenames := GetSortedSet(SELECT AS STRING ARRAY name FROM packages->Unpack());

    FOREVERY (RECORD rec FROM packages->Unpack())
    {
      IF (rec.name NOT LIKE "node_modules/*")
        CONTINUE;

      STRING version := rec.value->GetProp("version", [ fallback := "" ]);
      IF(version = "")
        THROW NEW Exception(`No version information in ${hidden_lockfile_path}`);
      STRING package := SubString(rec.name, 13);

      UPDATE actualnodemodules
         SET actualversion :=   version
           , error :=           ""
       WHERE name = package;
    }
  }

  RETURN CELL[ issues, actualnodemodules ];
}

/** Returns all toplevel/unused packages
    @param lockpackages
    @param rootpackages
    @return Issues
*/
RECORD ARRAY FUNCTION CheckV2Requests(RECORD ARRAY lockpackages, RECORD ARRAY rootpackages)
{
  RECORD ARRAY issues;

  lockpackages :=
      SELECT name
           , version :=       value->GetProp("version", [ fallback := "" ])
           , usedby :=        STRING[]
           , dependencies :=  RECORD
                              [ ...(SELECT name, range := value FROM value->GetProp("dependencies", [ fallback := CELL[] ])->Unpack())
                              , ...(SELECT name, range := value FROM value->GetProp("optionalDependencies", [ fallback := CELL[] ])->Unpack())
                              ]
        FROM lockpackages;

  INSERT
      [ name :=           ""
      , version :=        ""
      , usedby :=         STRING[ "*" ]
      , dependencies :=   rootpackages
      ] INTO lockpackages AT 0;

  FOREVERY (RECORD pkg FROM lockpackages)
  {
    FOREVERY (RECORD dep FROM pkg.dependencies)
    {
      STRING basepath := pkg.name = "" ? "" : pkg.name || "/";
      WHILE (TRUE)
      {
        RECORD pos := RecordLowerBound(lockpackages, [ name := `${basepath}node_modules/${dep.name}` ], [ "NAME" ]);
        IF (pos.found)
        {
          INSERT pkg.name INTO lockpackages[pos.position].usedby AT END;
          IF(lockpackages[pos.position].version = "")
            BREAK; //if npm didn't lock the version, not our problem..

          IF (pkg.name = "" AND NOT NPMPackageVersionSatisfiesRange(lockpackages[pos.position].version, dep.range))
          {
            RETURN [ [ error := `Installed module '${lockpackages[pos.position].name}' not in sync with package.json, please run 'wh fixmodules' (has version '${lockpackages[pos.position].version}', wanted range '${dep.range})` ] ];
          }
        }
        INTEGER nmpos := SearchLastSubstring(basepath, "node_modules/");
        IF (nmpos = -1)
          BREAK;
        basepath := Left(basepath, nmpos);
      }
    }
  }

  RECORD ARRAY unused := SELECT * FROM lockpackages WHERE IsDefaultValue(usedby);
  RETURN
      SELECT error := `Module ${name} version ${version} is installed but not requested. Please run 'wh fixmodules'`
        FROM unused;
}

RECORD ARRAY FUNCTION CheckNodeFolder(RECORD nodefolder)
{
  RECORD ARRAY issues;

  TRY
  {
    //Get the actual modules and their versions
    RECORD packagejson := DecodeJSONBlob(GetDiskResource(MergePath(nodefolder.basepath, "package.json")));
    OBJECT packagelockjson := DecodeJSONBlob(GetDiskResource(MergePath(nodefolder.basepath, "package-lock.json"), [ allowmissing := TRUE ]) ?? StringToBlob("{}"), DEFAULT RECORD, [ wrapobjects := TRUE ]);

    IF(NOT RecordExists(packagejson))
      THROW NEW Exception(`Package folder ${nodefolder.basepath} contains an invalid package.json`);
    IF(IsDefaultValue(packagelockjson))
      THROW NEW Exception(`Package folder ${nodefolder.basepath} contains an invalid package-lock.json`);

    //Decode package.json modules
    RECORD deps := CellExists(packagejson, 'dependencies') ? packagejson.dependencies : CELL[];
    RECORD ARRAY flatmodules := SELECT name := ToLowercase(name), range := value FROM UnpackRecord(deps);

    FOREVERY (RECORD rec FROM SELECT * FROM flatmodules WHERE range = "" LIMIT 1)
      INSERT [ error := `Package '${rec.name}' in package.json has an empty version range. Please put one in.` ] INTO issues AT 0;

    IF (NOT packagelockjson->HasProp("lockfileVersion") OR packagelockjson->GetProp("lockfileVersion") = 1)
    {
      // lockfile v1: resolve data is stored in package.json of all installed packages
      RECORD ARRAY actualnodemodules := ListActualV1Packages(nodefolder.modulespath);

      issues := issues CONCAT SELECT error := `${error} (${packagefile})` FROM actualnodemodules WHERE error != '';

      //Decode package-lock.json modules
      RECORD lockdeps := packagelockjson->HasProp('dependencies') ? packagelockjson->GetProp("dependencies", [ fallback := CELL[] ])->GetValue() : CELL[];
      RECORD ARRAY flatlockmodules := SELECT optional := FALSE, ...value, name := ToLowercase(name) FROM UnpackRecord(lockdeps);

      issues := issues CONCAT CheckRequests(flatmodules, flatlockmodules);

      IF (LENGTH(issues) != 0)
        RETURN [ ...issues, [ error := `package-lock.json is not in sync with package.json. package.json should not be modified manually. Please run 'npm install'` ] ];

      //Compare actual modules against packagelock.json
      RECORD ARRAY matchlockactual := JoinArrays(flatlockmodules, "name", actualnodemodules
                                        , [ packagedata := DEFAULT RECORD, actualversion := "" ]
                                        , [ rightouterjoin := TRUE, presentfield := "present", leftouterjoin := [ name := "", version := "", expectfrom := "" ] ]);

      // Allow missing packages when they are optional
      RECORD ARRAY installmismatches := SELECT * FROM matchlockactual WHERE (present != "both" OR version != actualversion) AND (present != "left" OR NOT optional);
      IF (RecordExists(installmismatches))
        RETURN [ ...issues, [ error := `Installed modules are not in sync with package-lock.json, please run 'wh fixmodules'` ] ];
    }
    ELSE IF (packagelockjson->GetProp("lockfileVersion") = 2)
    {
      // Read the packages from the package-lock.json
      RECORD ARRAY lockpackages := packagelockjson->HasProp("packages") ? SELECT * FROM packagelockjson->GetProp("packages")->Unpack() ORDER BY name : RECORD[];

      // Check if the deps in package "" from package-lock.json are a 1-to-1 match with the package.json
      RECORD ARRAY lockrootdeps_deps;
      OBJECT lockrootdeps := SELECT AS OBJECT value FROM lockpackages WHERE name = "";
      IF (ObjectExists(lockrootdeps))
      {
        lockrootdeps_deps := SELECT name, range := value FROM lockrootdeps->GetProp("dependencies", [ fallback := CELL[] ])->Unpack();
      }
      ELSE IF(Length(flatmodules) > 0)
        RETURN [ ...issues, [ error := "The package-lock.json is missing the root dependencies. Please run 'npm install'" ] ];

      IF (EncodeHSON(lockrootdeps_deps) != EncodeHSON(SELECT name, range FROM flatmodules ORDER BY name))
        RETURN [ ...issues, [ error := "The package-lock.json is not up to date with respect to the package.json. Please run 'npm install'" ] ];

      // Get the list of all installed packages on disk
      RECORD ARRAY ondiskpackages := SELECT * FROM ListActualV2Packages(nodefolder.modulespath, "node_modules") ORDER BY name;

      // Read the node_modules/.package-lock.json (with the current installed version info)
      STRING hidden_lockfile_path := MergePath(nodefolder.modulespath, ".package-lock.json");
      RECORD props := GetDiskFileProperties(hidden_lockfile_path);
      OBJECT hiddenpackagelockjson;
      IF(RecordExists(props))
        hiddenpackagelockjson := DecodeJSONBlob(GetDiskResource(hidden_lockfile_path, [ allowmissing := TRUE ]) ?? StringToBlob("{}"), DEFAULT RECORD, [ wrapobjects := TRUE ]);

      IF (NOT ObjectExists(hiddenpackagelockjson) OR NOT hiddenpackagelockjson->HasProp("packages"))
      {
        IF(Length(flatmodules) = 0 AND Length(ondiskpackages) = 0)
          RETURN issues; //it's okay to have no package-lock if there are no dependencies anyway

        RETURN [ ...issues, [ error := "No version info available for installed packages. Please run 'wh fixmodules'" ] ];
      }

      // modification date must be after the moddate of all ondisk package folders
      IF (props.modified < SELECT AS DATETIME MAX(modified) FROM ondiskpackages)
        RETURN [ ...issues, [ error := "Packages were manually modified after last installation. Please run 'wh fixmodules'" ] ];

      // Check if the package list is equal from listed to installed
      RECORD ARRAY packages := SELECT * FROM hiddenpackagelockjson->GetProp("packages")->Unpack() ORDER BY name;
      IF (LENGTH(packages) != LENGTH(ondiskpackages))
        RETURN [ ...issues, [ error := "Packages were manually modified after last installation. Please run 'wh fixmodules'" ] ];
      FOREVERY (RECORD package FROM packages)
        IF (ondiskpackages[#package].name != package.name)
          RETURN [ ...issues, [ error := "Packages were manually modified after last installation. Please run 'wh fixmodules'" ] ];

      // package-lock.json sometimes has extra packages that aren't installed - we just care about the ondisk package versions
      FOREVERY (RECORD package FROM packages)
      {
        // all installed packages should be named in the package lock
        RECORD pos := RecordLowerBound(lockpackages, package, [ "NAME" ]);
        IF (NOT pos.found)
          RETURN [ ...issues, [ error := "The installed packages are out of date with respect to the package-lock.json. Please run 'wh fixmodules'" ] ];

        // the version must match
        STRING seenpackageversion := package.value->GetProp("version", [ fallback := "" ]);
        STRING expectpackageversion := lockpackages[pos.position].value->GetProp("version", [ fallback := "" ]);
        IF (seenpackageversion != expectpackageversion)
          RETURN [ ...issues, [ error := "The installed packages are out of date with respect to the package-lock.json. Please run 'wh fixmodules'" ] ];
      }

      // check if all requested stuff is present on disk, and no extra modules installed
      issues := issues CONCAT CheckV2Requests(packages, flatmodules);
    }
    ELSE
      THROW NEW Exception(`Package-lock.json version ${packagelockjson->GetProp("lockfileVersion")} not supported`);

    RETURN issues;
  }
  CATCH(OBJECT e)
  {
    RETURN RECORD[ ...issues, [ error := `Fatal exception: ${e->what}` ]];
  }
}

PUBLIC RECORD ARRAY FUNCTION CheckNodeModulesInModule(STRING modulerootdir)
{
  RECORD ARRAY issues;

  FOREVERY(RECORD nodefolder FROM ListNodePackageRoots(modulerootdir))
  {
    issues := issues CONCAT SELECT error
                                 , basepath := nodefolder.basepath
                              FROM CheckNodeFolder(nodefolder);
  }
  RETURN issues;
}
