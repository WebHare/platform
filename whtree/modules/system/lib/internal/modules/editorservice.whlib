<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/internal/editorsupport.whlib";
LOADLIB "mod::system/lib/internal/modules/sourcemanipulation.whlib";


LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/internal/editorsupport.whlib";


/* Filename communications:

   The view on the filesystems can differ between the editor and the webhare installation (remote servers mounted over webdav, sshfs, etc.)

   The editor always passes its local translation info (found in a .wh.connect of .wh.webdavinfo file), and the referenced filenames are passed
   relative to the directory where the translation info was found (the editor base directory)

   (eg, connectinfo in /opt/webhare/whtree/.wh.connnectinfo, then mod::system/lib/database.whlib is passed as modules/system/lib/database.whlib)

   This service returns all disk paths in 'editorpath' cells, which are also relative to the editor base directory. Filename cells usually contain
   the resource name.
*/

MACRO ValidateAccessToken()
{
  STRING token := TrimWhitespace(NormalizeWhitespace(GetWebHeader("Authorization")));
  IF (ToUppercase(token) NOT LIKE "BEARER *" OR ToUppercase(token) LIKE "BEARER * *") // no two spaces!
    THROW NEW Exception("Missing/illegal authentication bearer token");

  token := Tokenize(token, " ")[1];

  RECORD decodedaccesstoken := DecryptForThisServer("system:editorservice", token);
  IF(decodedaccesstoken.trusteditoruntil <= GetCurrentDatetime())
    THROW NEW Exception("Expired access token");
}

RECORD FUNCTION ValidateTranslateInfo(STRING translateinfo)
{
  RECORD decodedtranslateinfo := DecryptForThisServer("system:translateinfo", translateinfo);
  IF (decodedtranslateinfo.pathtype = "webdav")
  {
    IF (decodedtranslateinfo.systempath NOT LIKE "/system/modules/*")
      THROW NEW Exception("Could not locate the current directory from the connection info");

    // remove the '/system/modules/' prefix
    STRING modpath := SubString(decodedtranslateinfo.systempath, 16);
    INTEGER spos := SearchSubString(modpath, "/");
    RETURN
        [ pathtype :=         "webdav"
        , resourceprefix :=   "mod::" || Left(modpath, spos)
        , resourcesubpath :=  SubString(modpath, spos)
        , path :=             decodedtranslateinfo.systempath
        ];
  }
  IF (decodedtranslateinfo.pathtype = "fs")
  {
    RETURN
        [ pathtype :=         "fs"
        , path :=             decodedtranslateinfo.systempath
        ];
  }

  RETURN DEFAULT RECORD;
}

STRING FUNCTION GetFileResourcePath(RECORD translatedata, STRING relfilename)
{
  // Already a resource path?
  IF (relfilename NOT LIKE "direct::*" AND relfilename LIKE "*::*")
    RETURN relfilename;

  IF (translatedata.pathtype = "webdav")
    RETURN translatedata.resourceprefix || MergePath(translatedata.resourcesubpath, relfilename);
  IF (translatedata.pathtype = "fs")
  {
    STRING path := MergePath(translatedata.path, relfilename);
    RETURN GetResourceNameFromDiskPath(path) ?? `direct::${path}`;
  }
  ABORT(`Unsupported pathtype ${translatedata.pathtype}`);
}

/* Auto-appends .es or /index.es to @mod import
*/
STRING FUNCTION ResolveJavascriptImport(STRING basefile, STRING resourcename)
{
  IF ((resourcename LIKE "./*" OR resourcename LIKE "../*") AND basefile != "")
    resourcename := MergePath(GetDirectoryFromPath(GetWebHareResourceDiskPath(basefile)), resourcename);
  ELSE IF (resourcename LIKE "@mod-*") // javascript load
    resourcename := "mod::" || SubString(resourcename, 5);
  ELSE IF (resourcename LIKE "@webhare-*") // javascript load
  {
    resourcename := "mod::" || SubString(resourcename, 9);
    INTEGER spos := SearchSubString(resourcename, "/");
    resourcename := Left(resourcename, spos) || "/js" || SubString(resourcename, spos);
  }
  ELSE
    RETURN resourcename;

  STRING path := resourcename LIKE "/*" ? resourcename : GetWebHareResourceDiskPath(resourcename);
  RECORD props := GetDiskFileProperties(path);
  IF (RecordExists(props) AND props.type = 0)
    RETURN resourcename;

  STRING testresource := resourcename;
  IF (RecordExists(props) AND props.type = 1) // directory?
  {
    path := path || "/index";
    testresource := resourcename || "/index";
  }

  IF (RecordExists(GetDiskFileProperties(path || ".es")))
    resourcename := testresource || ".es";
  ELSE IF (RecordExists(GetDiskFileProperties(path || ".js")))
    resourcename := testresource || ".js";

  RETURN resourcename;
}

STRING FUNCTION GetReturnPath(RECORD translatedata, STRING resourcename)
{
  IF (translatedata.pathtype = "webdav")
  {
    IF (resourcename = "")
      RETURN "";

    // Translate to canonical (mod::/wh::/whres:: prefixes)
    STRING path := resourcename LIKE "/*" ? resourcename : GetWebHareResourceDiskPath(resourcename);
    resourcename := GetResourceNameFromDiskPath(path);
    IF (resourcename = "")
      RETURN "";

    STRING webdavpath;
    IF (resourcename LIKE "mod::*")
      webdavpath := "/system/modules/" || SubString(resourcename, 5);
    ELSE IF (resourcename LIKE "wh::*")
      webdavpath := "/system/modules/system/whlibs/" || SubString(resourcename, 4);
    ELSE IF (resourcename LIKE "whres::*")
      webdavpath := "/system/modules/system/whres/" || SubString(resourcename, 7);

    IF (webdavpath = "")
      ABORT(`Unsupported resourcename ${resourcename}`);
    RETURN ResolveToRelativePath(translatedata.path, webdavpath);
  }
  IF (translatedata.pathtype = "fs")
  {
    IF (resourcename = "")
      RETURN "";

    TRY
    {
      STRING path := resourcename LIKE "/*" ? resourcename : GetWebHareResourceDiskPath(resourcename);
      RETURN ResolveToRelativePath(translatedata.path, path);
    }
    CATCH
      RETURN "";
  }
  ABORT(`Unsupported pathtype ${translatedata.pathtype}`);
}

PUBLIC RECORD FUNCTION RPC_Validate(STRING translateinfo, STRING filename, STRING source, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  RECORD translatedata := ValidateTranslateInfo(translateinfo);

  filename := GetFileResourcePath(translatedata, filename);
  RECORD rec := ValidateHarescriptSource(filename, StringToBlob(source), options);
  rec.messages := SELECT *, editorpath := GetReturnPath(translatedata, COLUMN filename) FROM rec.messages;
  RETURN
      [ errors :=     (SELECT * FROM rec.messages WHERE iserror)
      , warnings :=   (SELECT * FROM rec.messages WHERE NOT iserror)
      ];
}

PUBLIC RECORD FUNCTION RPC_SymbolSearch(STRING translateinfo, STRING filename, STRING query, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  RECORD translatedata := ValidateTranslateInfo(translateinfo);
  IF(NOT IsModuleInstalled("dev"))
    RETURN [ available := FALSE ];

  RECORD result := MakeFunctionPtr("mod::dev/lib/editorservices.whlib#SymbolSearch")(query);
  RETURN
      [ available := TRUE
      , results :=
          SELECT *
               , filename :=      path
               , editorpath :=    GetReturnPath(translatedata, path)
            FROM result.results
      ];
}

PUBLIC RECORD FUNCTION RPC_GetRemoteErrorList(STRING translateinfo, STRING filename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  RECORD translatedata := ValidateTranslateInfo(translateinfo);

  RECORD ARRAY errors;

  RECORD ARRAY logentries := GetLastNoticeErrors([ count := 20 ]);
  FOREVERY (RECORD entry FROM logentries)
  {
    RECORD rawentry := entry;
    IF (entry.message = "javascript-error")
      entry := AnalyzeJavascriptNoticeLogEntry(entry.data);
    ELSE
      entry := entry.data;

    RECORD ARRAY stack;
    IF (RecordExists(entry))
    {
      FOREVERY (RECORD item FROM entry.errors CONCAT entry.trace CONCAT entry.warnings)
      {
        IF (item.filename = "(hidden)")
        {
          IF (CellExists(entry, "SCRIPT"))
            item.filename := entry.script;
          IF (CellExists(entry, "REQUESTURL"))
            item.filename := entry.requesturl;
        }

        IF (LENGTH(stack) != 0
            AND stack[END-1].filename = item.filename
            AND stack[END-1].line = item.line
            AND stack[END-1].col = item.col)
          CONTINUE;

        INSERT item INTO stack AT END;
      }

      stack :=
          SELECT *
               , editorpath :=    GetReturnPath(translatedata, COLUMN filename)
            FROM stack;

      INSERT CELL[ stack, date := GetUnixTimeStamp(rawentry.when), groupid := rawentry.srhid ] INTO errors AT END;
    }
  }

  RECORD ARRAY stack;
  IF (NOT IsDefaultValue(errors))
    stack := errors[END - 1].stack;

  RETURN CELL[ stack, errors ];
}

PUBLIC RECORD FUNCTION RPC_DocumentationSearch(STRING translateinfo, STRING filename, STRING query, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  ValidateTranslateInfo(translateinfo);

  RECORD result;
  OpenPrimary();
  STRING refbaseurl := GetModuleInstallationRoot("dev") != "" ? ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(), "/reference/") : "https://www.webhare.dev/reference/";
  STRING url := UpdateURLVariables(refbaseurl || "search/", [ query := query, fromeditor := "1" ]);
  RETURN
      [ url := url
      ];
}

PUBLIC RECORD FUNCTION RPC_GetLoadLibSuggestions(STRING translateinfo, STRING filename, STRING symbol, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  RECORD translatedata := ValidateTranslateInfo(translateinfo);
  IF(NOT IsModuleInstalled("dev"))
    RETURN [ available := FALSE ];

  filename := GetFileResourcePath(translatedata, filename);

  RECORD retval := MakeFunctionPtr("mod::dev/lib/editorservices.whlib#GetLoadlibSuggestions")(symbol, CELL[ filename := filename ]);

  retval.results :=
      SELECT *
           , filename :=      path
           , editorpath :=    GetReturnPath(translatedata, path)
        FROM retval.results;

  RETURN CELL[ results := retval.results
             , filename := filename
             ]; //TODO originally returned hidden_definitions, for what?
}

PUBLIC RECORD FUNCTION RPC_AddLoadLibToSource(STRING translateinfo, STRING fileurl, STRING sourcedata, STRING path, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  ValidateTranslateInfo(translateinfo);
  RETURN GetLoadlibInsertInstructions(sourcedata, path);
}

/** Tries to resolve a resource name
    @param translateinfo Path translation info from the connect file
    @param fileurl Currently selected file (relative path)
    @param toresolve Webhare resource name
    @return
    @cell return.results
    @cell return.results.editorpath Relative path to resource ('' if not found)
    @cell return.results.line Always 1
    @cell return.results.col Always 1
*/
PUBLIC RECORD FUNCTION RPC_ResolveURI(STRING translateinfo, STRING fileurl, STRING toresolve, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  ValidateAccessToken();
  RECORD translatedata := ValidateTranslateInfo(translateinfo);

  STRING filename := GetFileResourcePath(translatedata, fileurl);
  toresolve := ResolveJavascriptImport(filename, toresolve);
  // ADDME: do relative resolve!

  RETURN
      [ results :=
            [ [ name :=         toresolve
              , filename :=     toresolve
              , editorpath :=   GetReturnPath(translatedata, toresolve)
              , line := 1
              , col := 1
              ]
            ]
      ];
}

