<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/registry.whlib";

RECORD secretkeys; //local cache to reduce adhocached pressure

STRING FUNCTION DoReadRegistryKey(STRING confkey)
{
  RECORD keyinfo := __GetRegistryKey(confkey, TRUE);
  IF(keyinfo.id = 0)
    THROW NEW Exception(`Missing regkey ${confkey}`);
  RETURN keyinfo.value;
}

RECORD FUNCTION GetSecretKeyFromDB(STRING whichkey)
{
  STRING keyname := "system.webserver.security." || whichkey;
  STRING secretvalue := RunInSeparatePrimary(PTR DoReadRegistryKey(keyname));
  //in principe these keys never change once set, so a 1hour cache should be fine
  RETURN [ value := secretvalue
         , ttl := secretvalue != "" ? 60 * 60 * 1000 : 0
         , eventmasks := GetRegistryKeyEventMasks([ keyname ])
         ];
}

STRING FUNCTION GetKeyForScope(STRING scope)
{
  STRING gcmsecret := GetClusterKeyBase("gcmsecret");
  RETURN GetHashForString(DecodeUFS(gcmsecret) || scope, "SHA-256");
}

PUBLIC STRING FUNCTION GetClusterKeyBase(STRING whichkey) //whichkey: cachesecret or cookiesecret
{
  IF(CellExists(secretkeys, whichkey)) //don't hit the adhoccache if we got the key, they shouldn't ever change anyway
    RETURN GetCell(secretkeys,whichkey);

  STRING secretkey := GetAdhocCached( [ whichkey := whichkey ], PTR RunInSeparatePrimary(PTR GetSecretKeyFromDB(whichkey)));
  secretkeys := CellInsert(secretkeys, whichkey, secretkey);
  RETURN secretkey;
}

/** @short Encrypt data with this server's local key
    @param scope Scope for encryption (must be unique for each Encrypt usage so you can't accidentally mix up calls)
    @param data Data to sign and encrypt. Will be encoded as necessary
    @cell options.algorithm Algorithm to use, defaults to 'SHA-1,BLOWFISH+CBC,8'
    @return UFS encoded encrypted and signed data
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC STRING FUNCTION EncryptForThisServer(STRING scope, VARIANT data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([algorithm := ""], options);
  IF(options.algorithm = "" OR TypeID(data)!=TypeID(STRING) OR data="" OR Left(data,5) = "hson:")
    data := EncodeHSON(data);

  IF(options.algorithm = "")
  {
    STRING keyforscope := GetKeyForScope(scope);
    STRING iv := Left(DecodeUFS(GenerateUFS128BitId()) || DecodeUFS(GenerateUFS128BitId()),12);
    RECORD parts := __DoEvpCrypt("aes-256-gcm", TRUE, keyforscope, data, iv, "");
    RETURN `${EncodeUFS(parts.data)}.${EncodeUFS(iv)}.${EncodeUFS(parts.tag)}`;
  }
  ELSE
  {
    RETURN EncryptAndSignData(data, options.algorithm, GetClusterKeyBase("cookiesecret") || scope);
  }
}

/** @short Decrypt data with this server's local key
    @param scope Scope for encryption (must match scope used when encrypting)
    @param data Data to encrypt
    @cell options.algorithm Algorithm to use, defaults to 'SHA-1,BLOWFISH+CBC,8'
    @cell options.fallback Fallback value if decryption failed. If not specified, the function will throw on decryption failure
    @return Decrypted data
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC VARIANT FUNCTION DecryptForThisServer(STRING scope, STRING data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ algorithm := ""
                              , fallback := DEFAULT RECORD
                              ], options, [ optional := ["fallback"], notypecheck := ["fallback" ] ]);

  STRING decrypted;
  BOOLEAN isgcm := options.algorithm = "" AND data LIKE "*.*.*" AND data NOT LIKE "*.*.*.*";
  IF(isgcm)
  {
    STRING ARRAY toks := Tokenize(data,'.');
    //Try JS AES-GCM compatible algorithm first
    STRING keyforscope := GetKeyForScope(scope);
    TRY
    {
      decrypted := __DoEvpCrypt("aes-256-gcm", FALSE, keyforscope, DecodeUFS(toks[0]), DecodeUFS(toks[1]), DecodeUFS(toks[2])).data;
    }
    CATCH(OBJECT error)
    {
      //decryption failed, just ignore
    }
  }
  ELSE
  {
    decrypted := DecryptSignedData(data, options.algorithm ?? "SHA-1,BLOWFISH+CBC,8", GetClusterKeyBase("cookiesecret") || scope);
  }

  IF(decrypted="")
  {
    IF(CellExists(options,'fallback'))
      RETURN options.fallback;
    THROW NEW Exception("Value decryption failed");
  }

  VARIANT retval;
  IF(Left(decrypted,5) = "hson:")
    retval := DecodeHSON(decrypted);
  ELSE IF(isgcm)
    RETURN DecodeJSON(decrypted, DEFAULT RECORD, [ typed := TRUE ]);
  ELSE
    retval := decrypted;

  IF(CellExists(options, 'fallback') AND TYPEID(options.fallback) != TYPEID(retval))
    THROW NEW Exception(`Invalid type in decrypted value, got ${GetTypeName(TYPEID(retval))} but expected ${GetTypeName(TYPEID(options.fallback))}`);
  RETURN retval;
}

//Create a signature for this server
PUBLIC STRING FUNCTION GetSignatureForThisServer(STRING scope, STRING text)
{
  RETURN EncodeUFS(GetHashForString(text || "\t" || scope || "\t" || GetClusterKeyBase("cookiesecret") , "SHA-256"));
}
//Validate a generated signature
PUBLIC BOOLEAN FUNCTION ValidateSignatureForThisServer(STRING scope, STRING text, STRING signature)
{
  RETURN GetSignatureForThisServer(scope, text) = signature;
}
