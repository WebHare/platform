<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/registry.whlib";

RECORD secretkeys; //local cache to reduce adhocached pressure

STRING FUNCTION DoReadRegistryKey(STRING confkey)
{
  RECORD keyinfo := __GetRegistryKey(confkey, TRUE);
  IF(keyinfo.id = 0)
    THROW NEW Exception(`Missing regkey ${confkey}`);
  RETURN keyinfo.value;
}

RECORD FUNCTION GetSecretKeyFromDB(STRING whichkey)
{
  RETURN [ value := RunInSeparatePrimary(PTR DoReadRegistryKey("system.webserver.security." || whichkey))
         , ttl := 60000
         ];
}

PUBLIC STRING FUNCTION GetClusterKeyBase(STRING whichkey) //whichkey: cachesecret, cookiesecret or elasticsecret
{
  IF(CellExists(secretkeys, whichkey))
    RETURN GetCell(secretkeys,whichkey);

  //introducing 'slots' to reduce contention on the secret key
  STRING secretkey := GetAdhocCached( [ whichkey := whichkey, slot := Random(0,15)], PTR RunInSeparatePrimary(PTR GetSecretKeyFromDB(whichkey)));
  secretkeys := CellInsert(secretkeys, whichkey, secretkey);
  RETURN secretkey;
}

/** @short Encrypt data with this server's local key
    @param scope Scope for encryption (must be unique for each Encrypt usage so you can't accidentally mix up calls)
    @param data Data to sign and encrypt. Will be encoded as necessary
    @cell options.algorithm Algorithm to use, defaults to 'SHA-1,BLOWFISH+CBC,8'
    @return UFS encoded encrypted and signed data
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC STRING FUNCTION EncryptForThisServer(STRING scope, VARIANT data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF(TypeID(data)!=TypeID(STRING) OR data="" OR Left(data,5) = "hson:")
    data := EncodeHSON(data);

  options := ValidateOptions([algorithm := "SHA-1,BLOWFISH+CBC,8"], options);
  RETURN EncryptAndSignData(data, options.algorithm, GetClusterKeyBase("cookiesecret") || scope);
}

/** @short Decrypt data with this server's local key
    @param scope Scope for encryption (must match scope used when encrypting)
    @param data Data to encrypt
    @cell options.algorithm Algorithm to use, defaults to 'SHA-1,BLOWFISH+CBC,8'
    @cell options.fallback Fallback value if decryption failed. If not specified, the function will throw on decryption failure
    @return Decrypted data
    @topic modules/services
    @public
    @loadlib mod::system/lib/services.whlib
*/
PUBLIC VARIANT FUNCTION DecryptForThisServer(STRING scope, STRING data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ algorithm := "SHA-1,BLOWFISH+CBC,8"
                              , fallback := DEFAULT RECORD
                              ], options, [ optional := ["fallback"], notypecheck := ["fallback" ] ]);

  STRING decrypted := DecryptSignedData(data, options.algorithm, GetClusterKeyBase("cookiesecret") || scope);
  IF(decrypted="")
  {
    IF(CellExists(options,'fallback'))
      RETURN options.fallback;
    THROW NEW Exception("Value decryption failed");
  }

  VARIANT retval;
  IF(Left(decrypted,5) = "hson:")
    retval := DecodeHSON(decrypted);
  ELSE
    retval := decrypted;

  IF(CellExists(options, 'fallback') AND TYPEID(options.fallback) != TYPEID(retval))
    THROW NEW Exception(`Invalid type in decrypted value, got ${GetTypeName(TYPEID(retval))} but expected ${GetTypeName(TYPEID(options.fallback))}`);
  RETURN retval;
}

//Create a signature for this server
PUBLIC STRING FUNCTION GetSignatureForThisServer(STRING scope, STRING text)
{
  RETURN EncodeUFS(GetHashForString(text || "\t" || scope || "\t" || GetClusterKeyBase("cookiesecret") , "SHA-256"));
}
//Validate a generated signature
PUBLIC BOOLEAN FUNCTION ValidateSignatureForThisServer(STRING scope, STRING text, STRING signature)
{
  RETURN GetSignatureForThisServer(scope, text) = signature;
}
