<?wh
LOADLIB "wh::devsupport.whlib";

LOADLIB "wh::ipc.whlib";

LOADLIB "mod::publisher/lib/internal/support.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/whfs/compilables.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

OBJECT trans;
BOOLEAN webhare_started;

//Handle completions
MACRo HandleCompletions(RECORD ARRAY completions)
{
  OBJECT torepub := CreateRepublishState();
  INTEGER ARRAY checkscripts;

  trans->BeginWork();

  //Combine
  completions := SELECT id, actions := GroupedValues(type) FROM completions GROUP BY id;

  //ADDME merge events and allow partial completions

  FOREVERY(RECORD compl FROM completions)
  {
    //PRINT("XX^ Handle completion\n" || AnyToString(compl, "tree"));

    IF("addfile" IN compl.actions OR "replacefile" IN compl.actions)
    {
        RECORD newfile := __FindFile(compl.id);
        IF(NOT RecordExists(newfile))
          CONTINUE;

        RECORD folder := __FindFolder(newfile.parent);
        RECORD site := __FindSite(folder.parentsite);
        IF(RecordExists(site))
        {
          IF("addfile" IN compl.actions)
          {
            torepub->AddDepsOf(newfile.id, 0/*metadata*/);
          }
          ELSE
          {
            torepub->AddDepsOf(newfile.id, 2/*created*/);
            torepub->AddDepsOf(folder.id, 2/*created*/);
          }
        }
        IF(newfile.type IN whconstant_whfstypes_scriptsondisk)
          INSERT newfile.id INTO checkscripts AT END;
    }

    // FIXME: unreachable? No mention of "updatefolder" in calls to completion
    IF("addfolder" IN compl.actions OR "updatefolder" IN compl.actions)
    {
      RECORD target := __FindFolder(compl.id);
      RECORD parentfolder := RecordExists(target) ? target.parent = 0 ? target : __FindFolder(target.parent) : DEFAULT RECORD;
      RECORD parentsite := RecordExists(parentfolder) ? __FindSite(parentfolder.parentsite) : DEFAULT RECORD;

      IF (RecordExists(parentsite)) //Folder gone, parent gone or out-of-site folder
      {
        IF("addfolder" IN compl.actions)
        {
          torepub->AddDepsOf(target.id, 3 /*created*/);
          torepub->AddDepsOf(parentfolder.id, 2/*created*/);
        }
        ELSE
        {
          torepub->AddDepsOf(target.id, 0 /*metadata change*/);
        }
      }
    }

    IF("deletechild" IN compl.actions)
    {
      RECORD parentfolder := __FindFolder(compl.id);
      RECORD parentsite := RecordExists(parentfolder) ? __FindSite(parentfolder.parentsite) : DEFAULT RECORD;

      IF(RecordExists(parentsite)) //parent gone or out-of-site folder
        torepub->AddDepsOf(parentfolder.id, 3/*content deleted*/);

      //FIXME rescan system.dbcode for deletable stuff?
    }
  }

  torepub->DoRepublishes();
  trans->CommitWork();

  IF(Length(checkscripts)>0) //make sure scripts are on disk
    ScanLimitedCompilables(checkscripts);
}

BOOLEAN log_eventcompletion := FALSE;

PUBLIC STATIC OBJECTTYPE EventCompletionPortHandler EXTEND IPCPortHandlerBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD ARRAY completions;
  BOOLEAN checksitesettings;

  OBJECT parentlink;
  INTEGER parentlinkcb;

  BOOLEAN state_started;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT port)
  : IPCPortHandlerBase(port)
  {
    this->flat_responses := TRUE;
    this->parentlink := GetIPCLinkToParent();
    this->parentlinkcb := RegisterHandleReadCallback(this->parentlink->handle, PTR this->OnParentMessage);

    CreateWHServiceStatePromise("started")->Then(PTR this->GotServiceStateStarted);
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO LogDebug(STRING message, VARIANT ARRAY args) __ATTRIBUTES__(VARARG)
  {
    INSERT message INTO args AT 0;
    INSERT "sys-eventcompletion" INTO args AT 0;
    CallMacroPTRVA(PTR LogDebug, args);
  }


  MACRO HandleCheckSiteSettings()
  {
    // Site settings need compiled siteprofiles, so don't execute these before state 'started'
    IF(this->checksitesettings AND this->state_started)
    {
      this->checksitesettings := FALSE;
      TRY
      {
        CallFunctionFromJob(Resolve("sitesettings.whlib#CheckSiteSettings"));
      }
      CATCH(OBJECT e)
      {
        LogHarescriptException(e);
        PrintTo(2, "Checksitesettings failure: " || e->what || "\n");
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotServiceStateStarted()
  {
    this->state_started := TRUE;
    IF (this->checksitesettings)
      this->HandleCheckSiteSettings();
  }

  UPDATE BOOLEAN FUNCTION HaveIdleWork()
  {
    RETURN Length(this->completions) > 0 OR (this->state_started AND this->checksitesettings);
  }

  UPDATE MACRO HandleIdleWork()
  {
    // Make sure WebHare service state 'started' has been reached
    IF (NOT webhare_started)
    {
      WaitForPromise(CreateWHServiceStatePromise("started"));
      webhare_started := TRUE;
    }

    IF(NOT ObjectExists(trans))
      trans := OpenPrimary ( [ clientname := "webserver completions" ]);


    this->HandleCheckSiteSettings();

    TRY
    {
      HandleCompletions(this->completions);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      IF(trans->IsWorkOpen())
        trans->RollbackWork();

      //Completions Republish attempts easily deadlock on running republishes... :/ If we fail, we'll retry *once*
      TRY
      {
        HandleCompletions(this->completions);
      }
      CATCH(OBJECT e2)
      {
        //After a double failure, just discard, as crashing the eventcompletion process is even worse
        LogHarescriptException(e2);
        LogWarning("system:eventcompletion", "Double completion failure, giving up on this batch", CELL [ what := e2->what, completions := this->completions ]);

        IF(trans->IsWorkOpen())
          trans->RollbackWork();
      }
    }
    this->completions := RECORD[]; //Discard all completions

    IF (NOT ObjectExists(this->parentlink))
    {
      IF (LENGTH(this->completions) = 0)
      {
        IF (log_eventcompletion)
          this->LogDebug("All completions of released script handled, terminating");
        TerminateScript();
      }
      ELSE IF (log_eventcompletion)
        this->LogDebug("Released script still has " || LENGTH(this->completions) || " completions to handle");
    }
  }

  UPDATE RECORD FUNCTION OnMessage(OBJECT link, RECORD message, INTEGER64 replyid)
  {
    IF(message.type="newcompletions")
    {
      this->completions := this->completions CONCAT message.data;
      this->checksitesettings := this->checksitesettings OR message.checksitesettings;
      RETURN [ result := "message", msg := [ type := "newcompletions-result", result := IsValueSet(this->completions) ] ];
    }
    IF(message.type="havependingcompletions")
      RETURN [ result := "message", msg := [ type := "havependingcompletions-result", result := IsValueSet(this->completions) ] ];

    RETURN [ result := "message"
           , msg := [ type := "unknowntype-result" ]
           ];
  }

  MACRO OnParentMessage()
  {
    RECORD res := this->parentlink->ReceiveMessage(DEFAULT DATETIME);
    IF (log_eventcompletion)
      this->LogDebug("Got mgmt message", res);

    IF (res.status = "gone")
    {
      UnregisterCallback(this->parentlinkcb);
      this->parentlink->Close();
      this->parentlink := DEFAULT OBJECT;
      RETURN;
    }
    IF (res.status = "timeout")
      RETURN;

    IF (res.msg.task = "tryrelease")
    {
      IF (IsScriptOutOfDate())
      {
        IF (log_eventcompletion)
          this->LogDebug("Out of date, releasing");
        IF (ObjectExists(this->pvt_port))
          this->pvt_port->Close();
        this->pvt_port := DEFAULT OBJECT;

        this->parentlink->SendMessage([ type := "tryrelease-ok" ]);

        UnregisterCallback(this->parentlinkcb);
        this->parentlink->Close();
        this->parentlink := DEFAULT OBJECT;

        this->HandleIdleWork();
      }
      ELSE
      {
        IF (log_eventcompletion)
          this->LogDebug("Not out of date, staying alive");
        this->parentlink->SendMessage([ type := "tryrelease-cancel" ]);
      }
    }
  }
>;

PUBLIC MACRO RunCompletionService()
{
  OBJECT completionport := CreateGlobalIPCPort("system:eventcompletion");

  OBJECT completionhandler := NEW EventCompletionPortHandler(completionport);
  completionhandler->Run();
}
