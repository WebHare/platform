<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::dbase/transaction.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/resources.whlib";


/** @param resourcename Resource name of the document with this node
    @param tasknode Node to parse
    @param mod Module name of this resource
    @cell options.ephemeral Whether this is an ephemeral task
    @return Tasktype
    @cell return.tasktype Name of the task type
    @cell return.ephemeral Whether this is an ephemeral task
    @cell return.library Name of the library that runs this task
    @cell return.objectname Name of the object that runs this task
    @cell return.applyerror Apply error (task may only run if this is empty)
    @cell return.cluster Name of the taskcluster this task should run in
*/
RECORD FUNCTION ParseTaskNode(STRING resourcename, OBJECT tasknode, STRING mod, RECORD options)
{
  STRING applyerror := GetApplicabilityError(GetMyApplicabilityInfo(), ReadApplicableToWebHareNode(tasknode));

  STRING type := tasknode->GetAttribute("type");
  STRING objectname := MakeAbsoluteResourcePath(resourcename, tasknode->GetAttribute("objectname"));
  STRING cluster := tasknode->GetAttribute("cluster");
  INTEGER timeout := ToInteger(tasknode->GetAttribute("timeout"), 0);
  INTEGER maxfailures := tasknode->HasAttribute("maxfailures") ? ParseXSInt(tasknode->GetAttribute("maxfailures")) : -1;
  INTEGER failreschedule := ToInteger(tasknode->GetAttribute("failreschedule"), whconstant_default_failreschedule);
  BOOLEAN allowifrestore := ParseXSBoolean(tasknode->GetAttribute("allowifrestore"));
  STRING libname;

  IF (cluster != "" AND cluster NOT LIKE "*:*")
    cluster := `${mod}:${cluster}`;

  INTEGER priority := ParseManagedTaskPriority(tasknode->GetAttribute("priority"));

  RETURN CELL[ objectname
             , tasktype :=     mod || ":" || type
             , applyerror :=   applyerror
             , cluster
             , ephemeral :=    options.ephemeral
             , priority
             , maxfailures
             , failreschedule
             , linenum := tasknode->linenum
             , timeout
             , allowifrestore
             , taskrunner := MakeAbsoluteResourcePath(resourcename, tasknode->GetAttribute("taskrunner"))
             ];
}

PUBLIC RECORD FUNCTION ParseModuleTasks(STRING modulename, STRING resname, OBJECT xmldoc)
{
  RECORD ARRAY clusters;
  RECORD ARRAY tasktypes;

  FOREVERY(OBJECT tasknode FROM xmldoc->GetElementsByTagnameNS("http://www.webhare.net/xmlns/system/moduledefinition", "managedtask")->GetCurrentElements())
    INSERT ParseTaskNode(resname, tasknode, modulename, [ ephemeral := FALSE ]) INTO tasktypes AT END;

  FOREVERY(OBJECT tasknode FROM xmldoc->GetElementsByTagnameNS("http://www.webhare.net/xmlns/system/moduledefinition", "ephemeraltask")->GetCurrentElements())
    INSERT ParseTaskNode(resname, tasknode, modulename, [ ephemeral := TRUE ]) INTO tasktypes AT END;

  FOREVERY(OBJECT clusternode FROM xmldoc->GetElementsByTagnameNS("http://www.webhare.net/xmlns/system/moduledefinition", "taskcluster")->GetCurrentElements())
  {
    INSERT
        [ tag :=                  `${modulename}:${clusternode->GetAttribute("tag")}`
        , harescriptworkers :=    ToInteger(clusternode->GetAttribute("harescriptworkers"), 1)
        , harescriptworkerthreads := ToInteger(clusternode->GetAttribute("harescriptworkerthreads"), 1)
        ] INTO clusters AT END;
  }

  RETURN CELL [ clusters, tasktypes ];
}

RECORD FUNCTION GetModuleTaskType(STRING tasktype, BOOLEAN ephemeral)
{
  IF(tasktype!=ToLowercase(tasktype) OR tasktype NOT LIKE "?*:?*" OR tasktype LIKE "*:*:*")
    THROW NEW Exception(`Invalid task type ${tasktype}`);

  STRING ARRAY toks := Tokenize(tasktype,':');
  STRING mod := toks[0];
  IF(NOT IsModuleInstalled(mod))
    THROW NEW Exception(`No such module ${mod}`);

  STRING resname := GetModuleDefinitionXMLResourceName(mod);
  OBJECT xmldoc := GetModuleDefinitionXML(mod);

  RECORD taskinfo;
  FOREVERY(OBJECT tasknode FROM xmldoc->GetElementsByTagnameNS("http://www.webhare.net/xmlns/system/moduledefinition", ephemeral ? "ephemeraltask" : "managedtask")->GetCurrentElements())
  {
    IF(tasknode->GetAttribute("type") != toks[1])
      CONTINUE;

    taskinfo := ParseTaskNode(resname, tasknode, mod, CELL[ ephemeral ]);
  }

  IF(NOT RecordExists(taskinfo))
    THROW NEW Exception(`No such ${ephemeral?"ephemeral":"managed"} task type '${tasktype}'`);

  RETURN [ value := taskinfo
         , ttl := 60*60*1000
         , eventmasks := GetResourceEventMasks([resname])
         ];
}

PUBLIC RECORD FUNCTION GetTaskTypeSettings(STRING tasktype, BOOLEAN ephemeral)
{
  RETURN GetAdhocCached([ tasktype := tasktype, isephemeral := ephemeral ], PTR GetModuleTaskType(tasktype, ephemeral));
}

PUBLIC RECORD FUNCTION GetTaskExecuteInfo(RECORD taskdata, RECORD taskinfo)
{
  RECORD executeinfo := [ queueid :=        taskdata.queueid
                        , isephemeral :=    taskdata.isephemeral
                        , tasktype :=       taskdata.tasktype
                        , objectname :=     taskinfo.objectname
                        , profile :=        taskinfo.profile
                        , taskrunner :=     taskinfo.taskrunner
                        ];

  IF(taskdata.isephemeral)
  {
    INSERT CELL data := taskdata.taskdata
              , options := taskdata.options
              , failures := 0 //ephemeral tasks do not support tempfailures (and will be phased out completely anyway)
           INTO executeinfo;
  }
  ELSE
  {
    RECORD taskrec :=
        SELECT COLUMN taskdata
             , auxdata
             , failures
          FROM system_internal.managedtasks
         WHERE id = VAR taskdata.id;

    IF (NOT RecordExists(taskrec))
      THROW NEW Exception(`Managed task ${taskdata.id} has disappeared`);

    RECORD data := DecodeHSON(taskrec.taskdata);
    IF(Length(taskrec.auxdata) > 0)
      data := CELL[...data, ...DecodeHSONBlob(taskrec.auxdata)];

    INSERT CELL dbid := taskdata.id
              , data := data
              , options := DEFAULT RECORD
              , failures := taskrec.failures
           INTO executeinfo;
  }
  RETURN executeinfo;
}

PUBLIC INTEGER FUNCTION ParseManagedTaskPriority(STRING priority)
{
  INTEGER pos := SearchElement([ "background", "normal", "interactive", "update", "updateinteractive" ], priority);
  IF (pos = -1)
    RETURN 0;

  RETURN [ 100, 0, -100, -200, -300 ][pos];
}

OBJECTTYPE TaskFinishHandler EXTEND TransactionFinishHandlerBase
<
  RECORD ARRAY tasks;

  UPDATE PUBLIC MACRO OnCommit()
  {
    GetPrimary()->BeginWork();
    this->QueueTasks();
    GetPrimary()->CommitWork();
  }
  MACRO QueueTasks()
  {
    DATETIME now;

    FOREVERY(RECORD task FROM this->tasks)
    {
      STRING tasktag := Substitute(task.tag,':','.'); //system.tasks uses "module.tag" instead of the usual "module:tag", so convert
      IF(task.when = DEFAULT DATETIME AND now = DEFAULT DATETIME)
        now := GetCurrentDatetime();

      DATETIME when := task.when ?? now;
      UPDATE system_internal.tasks
         SET nexttime := VAR when
       WHERE tasks.tag = VAR tasktag
             AND (tasks.nexttime = DEFAULT DATETIME  //not scheduled at all
                 OR when < tasks.nexttime            //we want to schedule it earlier than planned
                 OR (tasks.inapplicable != "" AND tasks.nexttime < GetCurrentDatetime() )); //inaplicable tasks? move time forward when in the past, easier when debugging

      GetPrimary()->BroadcastOnCommit("system:internal.scantasks", DEFAULT RECORD);
    }
  }

  PUBLIC MACRO ScheduleTask(STRING tag, DATETIME when)
  {
    INTEGER taskpos := SELECT AS INTEGER #tasks + 1 FROM this->tasks WHERE tasks.tag = VAR tag;
    IF(taskpos = 0)
      INSERT [ tag := tag, when := when ] INTO this->tasks AT END;
    ELSE IF(this->tasks[taskpos-1].when > when) //originally scheduled further in the future ? move back
      this->tasks[taskpos-1].when := when;
  }
>;

PUBLIC OBJECT FUNCTION GetTaskFinishHandler()
{
  OBJECT handler := GetPrimary()->GetFinishHandler("system:tasksfinish");
  IF (NOT ObjectExists(handler))
  {
    handler := NEW TaskFinishHandler;
    GetPrimary()->SetFinishHandler("system:tasksfinish", handler);
  }
  RETURN handler;
}
