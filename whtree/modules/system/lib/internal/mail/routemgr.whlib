<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::util/comparisons.whlib";

LOADLIB "mod::wrd/lib/api.whlib";

LOADLIB "mod::system/lib/configure.whlib";

RECORD FUNCTION GetCacheableMailRoutes()
{
  OBJECT configschema := OpenWRDSchema("system:config");
                    // See system config wrdschema for the various data structures
  RETURN [ value := [ mailroutes := configschema->^mailroute->RunQuery([ outputcolumns := [ "*" ]])
                    , mailsenders := configschema->^mailsender->RunQuery([ outputcolumns := [ "*" ]])
                    , mailrecipients := configschema->^mailrecipient->RunQuery([ outputcolumns := [ "*" ]])
                    , mailcorrections := configschema->^mailcorrection->RunQuery([ outputcolumns := [ "*" ]])
                    , mailservers := configschema->^mailserver->RunQuery([ outputcolumns := [ "*" ]])
                    , usemailfromfornonwhitelisted := ReadRegistryKey("system.services.smtp.usemailfromfornonwhitelisted")
                    ]
         , ttl := 60 * 1000 * 1000
         , eventmasks := configschema->^mailroute->GetEventMasks()
                         CONCAT configschema->^mailsender->GetEventMasks()
                         CONCAT configschema->^mailrecipient->GetEventMasks()
                         CONCAT configschema->^mailcorrection->GetEventMasks()
                         CONCAT configschema->^mailserver->GetEventMasks()
                         CONCAT GetRegistryKeyEventMasks([  "system.services.smtp.usemailfromfornonwhitelisted" ])
         ];
}

PUBLIC RECORD FUNCTION GetMailRoutes()
{
  RETURN GetAdhocCached([ type := "mailroutes" ], PTR GetCacheableMailRoutes);
}

CONSTANT RECORD base_anymailroute := [ recipientmasks := [[ mask := "*" ]]
                                     , sendermasks := [[ mask := "*" ]]
                                     , originmask := "*"
                                     , serverurl := ""
                                     , rewritemailaddress := ""
                                     , includeoriginaladdress := FALSE
                                     ];

/** Returns the list of e-mail SMTP routes, ordered on ordering, id
    @return E-mail routes @includecelldef #GetMailRoutes.return
*/
RECORD ARRAY FUNCTION GetSMTPRoutes()
{
  RECORD routedata := GetMailroutes();
  RECORD ARRAY baseroutes :=
                SELECT TEMPORARY matchserver := (SELECT * FROM routedata.mailservers WHERE wrd_id = mailroutes.server)
                     , *
                     , serverurl := rewritemailaddress = "null" ? "null" : RecordExists(matchserver) ? matchserver.serverurl : ""
                     , setheaders := RecordExists(matchserver) ? matchserver.setheaders : RECORD[]
                  FROM routedata.mailroutes;

  RECORD ARRAY mailroutes;

  //some tests inject routes with ordering < -999 which need to be above everything
  mailroutes := SELECT *
                     , DELETE wrd_id
                     , DELETE wrd_ordering
                  FROM baseroutes
                 WHERE wrd_ordering < -999
              ORDER BY wrd_ordering, wrd_id;

  INSERT CELL[ ...base_anymailroute
             , recipientmasks := [[ mask := "*@beta.webhare.net" ], [ mask := "*@*.beta.webhare.net" ]]
             , serverurl := "infinitedelay"
             ] INTO mailroutes AT END;

  mailroutes := mailroutes
                CONCAT
                SELECT *
                     , DELETE wrd_id
                     , DELETE wrd_ordering
                  FROM baseroutes
                 WHERE wrd_ordering >= -999
              ORDER BY wrd_ordering, wrd_id;

  RECORD defaultserver := SELECT * FROM routedata.mailservers WHERE wrd_tag = "DEFAULTSERVER";
  IF(RecordExists(defaultserver))
    INSERT CELL[ ...base_anymailroute
               , serverurl := defaultserver.serverurl
               , setheaders := defaultserver.setheaders
               ] INTO mailroutes AT END;

  RETURN mailroutes;
}

PUBLIC RECORD FUNCTION MatchMailRule(STRING lookfor, RECORD ARRAY masks) {
  RECORD match := SELECT * FROM masks WHERE ToUppercase(lookfor) LIKE ToUppercase(mask) ORDER BY Length(mask) DESC; //find most specific match
  IF(NOT RecordExists(match) AND lookfor LIKE "*+*@*") { //plus address ? check if the address without the plus is whitelisted
    lookfor := Tokenize(lookfor,'+')[0] || '@' || Tokenize(lookfor,'@')[1];
    match := SELECT * FROM masks WHERE ToUppercase(lookfor) LIKE ToUppercase(mask) ORDER BY Length(mask) DESC; //find most specific match
  }
  RETURN match;
}

BOOLEAN FUNCTION IsInLikeUC(STRING lookfor, RECORD ARRAY masks) {
  RETURN RecordExists(MatchMailRule(lookfor,masks));
}

PUBLIC INTEGER FUNCTION IsAllowedEmailSender(STRING email)
{
  RECORD mailroutes := GetMailroutes();
  IF(IsInLikeUC(email, mailroutes.mailsenders))
    RETURN 1; //permitted

  IF(mailroutes.usemailfromfornonwhitelisted) //every sender is acceptable..
    RETURN 2; //rewrite

  RETURN 0;
}

PUBLIC BOOLEAN FUNCTION IsAllowedEmailReceiver(STRING email)
{
  RECORD mailconfig := GetMailroutes();
  IF(IsInLikeUC(email, mailconfig.mailrecipients))
    RETURN TRUE;

  //if any rewrite rule would handle the outgoing mail, fine with us
  FOREVERY(RECORD rewriterule FROM mailconfig.mailroutes)
    IF(rewriterule.rewritemailaddress != ""  AND IsInLikeUC(email, rewriterule.recipientmasks) AND IsInLikeUC(rewriterule.rewritemailaddress, mailconfig.mailrecipients))
      RETURN TRUE;

  RETURN FALSE;
}

/** Returns the relevant mailroute for a sender, receiver and origin
    @param sender Sender address
    @param receiver Receiver address
    @param origin Origin
    @return Mail route @includecelldef #GetSMTPRoutes.return
*/
PUBLIC RECORD FUNCTION GetMailroute(STRING sender, STRING receiver, STRING origin DEFAULTSTO "")
{
  RETURN SELECT *
           FROM GetSMTPRoutes()
          WHERE IsInLikeUC(sender, COLUMN sendermasks)
                AND IsInLikeUC(receiver, COLUMN recipientmasks)
                AND (originmask="" OR ToUppercase(VAR origin) LIKE ToUppercase(originmask));
}


/** @short Suggest improvement to given suggestion
    @topic witty/api
    @public
    @loadlib mod::system/lib/mailer.whlib
    @param email Email to check (in 'user@domain' format)
    @return A default record if no suggestion is made
    @cell(string) return.suggestion Suggested better email address
    @cell(boolean) return.force If true, just fix the email address instead of merely suggesting
    @cell(boolean) return.blocked If true, do not accept this email address at all */
PUBLIC RECORD FUNCTION GetEmailAutocorrection(STRING email)
{
  RECORD ARRAY correctionrules := SELECT * FROM GetMailroutes().mailcorrections ORDER BY wrd_ordering, wrd_id;
  IF(Length(correctionrules) = 0)
    RETURN DEFAULT RECORD;

  STRING ARRAY toks := Tokenize(email,'@');
  IF(Length(toks) != 2)
    RETURN DEFAULT RECORD;

  FOREVERY(RECORD rule FROM correctionrules)
  {
    IF(NOT rule.block AND Left(rule.rewriteto,2)="*@")
    {
      IF(IsInLikeUC(email, rule.masks))
      {
        RETURN [ suggestion := toks[0] || Substring(rule.rewriteto,1)
               , force := TRUE
               , blocked := FALSE
               ];
      }

      STRING domain := ToUppercase(toks[1]);
      STRING matchdomain := ToUppercase(Substring(rule.rewriteto,2));
      IF(rule.suggestionfuzz > 0 AND domain != matchdomain)
      {
        INTEGER distance := CalculateLevenshteinDistance(domain, matchdomain);
        IF(distance <= rule.suggestionfuzz)
        {
          RETURN [ suggestion := toks[0] || Substring(rule.rewriteto,1)
                 , force := FALSE
                 , blocked := FALSE
                 ];
        }
      }
    }
    ELSE IF(rule.block)
    {
      IF(IsInLikeUC(email, rule.masks))
      {
        RETURN [ suggestion := ""
               , force := FALSE
               , blocked := TRUE
               ];
      }
    }
  }
  RETURN DEFAULT RECORD;
}
