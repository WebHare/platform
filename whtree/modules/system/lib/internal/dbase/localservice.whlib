<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::internal/transservices.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/services.whlib";

BOOLEAN iselevated;

RECORD FUNCTION GetCacheableServiceInfo(STRING servicename)
{
  STRING modname := Tokenize(servicename,':')[0];
  OBJECT xmldoc := GetModuleDefinitionXML(modname);
  IF(NOT ObjectExists(xmldoc))
  {
    RETURN
        [ ttl :=    60 * 60 * 1000
        , value :=  [ success := FALSE, msg := "No such module '" || modname || "'" ]
        , eventmasks := ["system:modulesupdate"]
        ];
  }

  STRING servicecallname := Substring(servicename, Length(modname)+1);

  OBJECT ARRAY servicecalls := xmldoc->GetElementsByTagNameNS("http://www.webhare.net/xmlns/system/moduledefinition", "localservice")->GetCurrentElements();
  OBJECT serviceobj;
  BOOLEAN persistent;
  FOREVERY(OBJECT node FROM servicecalls)
    IF(node->GetAttribute("name") = servicecallname)
    {
      STRING lib := "module::" || modname || "/" || node->GetAttribute("library");
      RETURN
          [ ttl :=    60 * 60 * 1000
          , value :=
                [ success := TRUE
                , lib := lib
                , objname := node->GetAttribute("objectname")
                , persistent := ParseXSBoolean(node->GetAttribute('reuse'))
                , withtransaction := node->HasAttribute('withtransaction') ? ParseXSBoolean(node->GetAttribute('withtransaction')) : TRUE
                ]
          , eventmasks := ["system:modulesupdate"]
          ];
    }

  RETURN
      [ ttl :=    60 * 60 * 1000
      , value :=  [ success := FALSE, msg := "Cannot find <localservice name='" || servicecallname || "' /> in module '" || modname || "'" ]
      , eventmasks := ["system:modulesupdate"]
      ];
}

RECORD FUNCTION OpenTheService(STRING servicename, RECORD info, VARIANT ARRAY arguments)
{
  IF(NOT info.success)
    THROW NEW Exception(info.msg);

  INSERT info.lib INTO arguments AT 0;
  INSERT info.objname INTO arguments AT 1;

  OBJECT obj := CallAnyPtrVA(PTR MakeObject, arguments);
  RETURN [ obj := obj, persistent := info.persistent, transid := 0,name := servicename ];
}

OBJECTTYPE ServiceProxy
<
  OBJECT trans;
  OBJECT targetobject;
  BOOLEAN withtransaction;

  MACRO NEW(OBJECT trans, STRING servicename, RECORD serviceinfo, VARIANT ARRAY arguments)
  {
    FUNCTION PTR remotingfunc := PTR this->__RemotingFunc;

    VARIANT ARRAY args;
    INSERT servicename INTO args AT 0;
    INSERT serviceinfo INTO args AT 1;
    INSERT arguments INTO args AT 2;

    //Print("service proxy, trans=" || (ObjectExists(trans)?"set":"null") || ", withtrans=" || (serviceinfo.withtransaction ? "true" : "false") || "\n");

    this->withtransaction := serviceinfo.withtransaction;
    this->trans := serviceinfo.withtransaction ? trans : DEFAULT OBJECT;

    RECORD service := this->InvokeInContext("NEW", args);
    this->targetobject := service.obj;

    RECORD description := DescribePublicInterface(service.obj);
    ReconstructInvokables(this, description, PTR this->__RemotingFunc);
  }

  VARIANT FUNCTION InvokeInContext(STRING name, VARIANT ARRAY args)
  {
    IF(ObjectExists(this->trans) AND GetTransactionObjectByIdInternal(this->trans->id) != this->trans)
      THROW NEW Exception("The transaction for this local service has been closed");

    INTEGER savetrans;
    BOOLEAN saveelevated := iselevated;

    TRY
    {
      IF(NOT this->withtransaction) //manage our own...
      {
        savetrans := GetPrimaryWebhareTransaction();
        //Print("setting trans from " || savetrans || " to " || (ObjectExists(this->trans) ? this->trans->id : 0) || "\n");
        SetPrimaryWebhareTransaction(ObjectExists(this->trans) ? this->trans->id : 0);
      }
      ELSE
      {
        //Print("invoke, keeping trans at " || GetPrimaryWebhareTransaction() || "\n");
      }

      iselevated := TRUE;
      RETURN CallAnyPtrVA(name = "NEW" ? PTR OpenTheService : GetObjectMethodPTR(this->targetobject, name),args);
    }
    FINALLY
    {
      iselevated := saveelevated;

      IF(NOT this->withtransaction)
      {
        this->trans := GetPrimaryWebhareTransactionObject();
        //Print("saving trans " || (ObjectExists(this->trans) ? this->trans->id : 0) || " and restoring trans to " || savetrans || "\n");
        SetPrimaryWebhareTransaction(savetrans);
      }
      ELSE
      {
        //Print("exit, keeping trans at " || GetPrimaryWebhareTransaction() || "\n");
      }
    }
  }

  /// Calls a remote function
  VARIANT FUNCTION __RemotingFunc(
    STRING name,
    VARIANT ARRAY args) __ATTRIBUTES__(SKIPTRACE, VARARG)
  {
    RETURN this->InvokeInContext(name, args);
  }
>;

PUBLIC STATIC OBJECTTYPE LocalServiceContext
<
  /// Cached services
  RECORD ARRAY reusableservices;

  OBJECT trans;

  MACRO NEW(OBJECT trans)
  {
    this->trans := trans;
  }

  PUBLIC RECORD FUNCTION GetServiceInfo(STRING servicename)
  {
    RETURN GetAdhocCached([ serviceinfo := servicename ], PTR GetCacheableServiceInfo(servicename));
  }

  /** Open an elevated service. */
  PUBLIC OBJECT FUNCTION OpenService(STRING servicename, VARIANT ARRAY arguments)
  {
    OBJECT reusable := SELECT AS OBJECT obj FROM this->reusableservices WHERE name=ToUppercase(servicename);
    IF(ObjectExists(reusable))
      RETURN reusable;

    RECORD serviceinfo := this->GetServiceInfo(servicename);
    IF(NOT serviceinfo.success)
      THROW NEW Exception(serviceinfo.msg);

    OBJECT proxy := NEW ServiceProxy(this->trans, servicename, serviceinfo, arguments);
    //RECORD service  := InvokePrivileged(PTR OpenTheService(servicename, serviceinfo, arguments));
    RECORD service := [ obj := proxy
//               , persistent := serviceinfo.persistent
               ];

/*      RECORD serviceinfo := this->__CallElevatorEntryPoint(servicename, [ method := "NEW", service := servicename, args := arguments] );
      service := [ obj := NEW ServiceProxy(this, serviceinfo, servicename)
                 , persistent := serviceinfo.persistent
                 ];*/

    IF(serviceinfo.persistent)
      INSERT [ obj := service.obj, name := ToUppercase(servicename) ] INTO this->reusableservices AT END;
    RETURN service.obj;
  }
>;
