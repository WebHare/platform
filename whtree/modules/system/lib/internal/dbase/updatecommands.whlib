<?wh

LOADLIB "wh::internal/transbase.whlib";

LOADLIB "mod::system/lib/internal/dbase/postgresql.whlib";

RECORD ARRAY FUNCTION ValidateSchemaSpecs(RECORD ARRAY schemaspecs)
{
  FOREVERY (RECORD rec FROM schemaspecs)
  {
    rec := ValidateOptions(
        [ name :=             ""
        , obsoletetables :=   RECORD[]
        , tables :=           RECORD[]
        ], rec,
        [ discard :=        STRING[ "success", "msgs", "documentation", "location" ]
        ]);

    rec.obsoletetables := ValidateObsoleteTables(rec.obsoletetables);
    rec.tables := ValidateTables(rec.tables);

    schemaspecs[#rec] := rec;
  }
  RETURN schemaspecs;
}

RECORD ARRAY FUNCTION ValidateObsoleteTables(RECORD ARRAY obsoletetables)
{
  FOREVERY (RECORD rec FROM obsoletetables)
  {
    obsoletetables[#rec] := ValidateOptions(
        [ name :=       ""
        , drop :=       ""
        ], rec,
        [ enums :=      [ drop := [ "restrict" ] ]
        ]);
  }
  RETURN obsoletetables;
}

RECORD ARRAY FUNCTION ValidateTables(RECORD ARRAY tables)
{
  FOREVERY (RECORD rec FROM tables)
  {
    rec := ValidateOptions(
        [ name :=                   ""
        , primarykey :=             ""
        , legacy_readaccessmgr :=   ""
        , legacy_writeaccessmgr :=  ""
        , parentlinkcolumn :=       ""
        , cols :=                   RECORD[]
        , indices :=                RECORD[]
        , obsoletecols :=           RECORD[]
        , obsoleteindices :=        RECORD[]
        ], rec,
        [ discard :=        STRING[ "documentation", "location" ]
        ]);

    rec.cols := ValidateColumns(rec.cols);
    rec.indices := ValidateIndices(rec.indices);
    rec.obsoletecols := ValidateObsoleteColumns(rec.obsoletecols);
    rec.obsoleteindices := ValidateObsoleteIndices(rec.obsoleteindices);

    tables[#rec] := rec;
  }
  RETURN tables;
}

RECORD ARRAY FUNCTION ValidateObsoleteColumns(RECORD ARRAY obsoletecolumns)
{
  FOREVERY (RECORD rec FROM obsoletecolumns)
  {
    obsoletecolumns[#rec] := ValidateOptions(
        [ name :=       ""
        ], rec);
  }
  RETURN obsoletecolumns;
}

RECORD ARRAY FUNCTION ValidateObsoleteIndices(RECORD ARRAY obsoleteindices)
{
  FOREVERY (RECORD rec FROM obsoleteindices)
  {
    obsoleteindices[#rec] := ValidateOptions(
        [ name :=         ""
        ], rec);
  }
  RETURN obsoleteindices;
}

RECORD ARRAY FUNCTION ValidateColumns(RECORD ARRAY columns)
{
  FOREVERY (RECORD rec FROM columns)
  {
    columns[#rec] := ValidateOptions(
        [ autonumberstart :=      0
        , dbtype :=               ""
        , defval :=               ""
        , internalcolumnname :=   ""
        , isunique :=             FALSE
        , maxlength :=            0
        , name :=                 ""
        , nullable :=             FALSE
        , noupdate :=             FALSE
        , ondelete :=             ""
        , references_schema :=    ""
        , references_table :=     ""
        ], rec,
        [ discard :=              [ "documentation", "location" ]
        , enums :=                [ ondelete :=   [ "", "cascade", "set default", "no action" ]
                                  , dbtype :=     [ "INTEGER", "BOOLEAN", "STRING", "VARCHAR", "INTEGER64", "FLOAT", "DATETIME", "BLOB", "BYTEA", "MONEY", "__LONGKEY", "NUMBER" ]
                                  ]
        ]);
  }
  RETURN columns;
}

RECORD ARRAY FUNCTION ValidateIndices(RECORD ARRAY indices)
{
  FOREVERY (RECORD rec FROM indices)
  {
    rec := ValidateOptions(
        [ name :=         ""
        , is_unique :=    FALSE
        , is_uppercase := FALSE
        , nonullstores := FALSE
        , columns :=      RECORD[]
        ], rec);

    FOREVERY (RECORD col FROM rec.columns)
    {
      rec.columns[#col] := ValidateOptions(
        [ name :=       ""
        , length :=     0
        ], col);
    }

    indices[#rec] := rec;
  }
  RETURN indices;
}


PUBLIC MACRO ClearAllSchemaCaches()
{
  ClearAllPostgreSQLSchemaCaches();
}

PUBLIC RECORD FUNCTION GenerateIndependentSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans)
{
  schemaspecs := ValidateSchemaSpecs(schemaspecs);
  RETURN GeneratePostgreSQLIndependentSQLCommands(schemaspecs, trans);
}

PUBLIC RECORD FUNCTION GeneratePostupdateSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans)
{
  schemaspecs := ValidateSchemaSpecs(schemaspecs);
  RETURN GeneratePostgreSQLPostupdateSQLCommands(schemaspecs, trans);
}

PUBLIC RECORD FUNCTION GenerateDependentSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans)
{
  schemaspecs := ValidateSchemaSpecs(schemaspecs);
  RETURN GeneratePostgreSQLDependentSQLCommands(schemaspecs, trans);
}

PUBLIC RECORD FUNCTION GetSchemaModuleDefinition(OBJECT trans, STRING schemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ withimplicitindices := FALSE ], options);
  RETURN GetPostgreSQLDatabaseSchemaDef(trans, schemaname, options);
}

PUBLIC MACRO ExecuteSQLUpdates(RECORD ARRAY cmds)
{
  FOREVERY(RECORD cmd FROM cmds)
  {
    //ADDME: IF a command caused an error, store that with the command for better error reporting
    IF (cmd.type = "transop")
      cmd.cmd();
    ELSE IF (cmd.type = "sql")
      cmd.execsql(cmd.cmd);
    ELSE
      ABORT(cmd.type);
  }
  IF(Length(cmds)>0)
    ClearAllSchemaCaches();
}

PUBLIC MACRO __LegacyCreateTable(OBJECT trans, STRING schemaname, STRING tablename, RECORD tabledef)
{
  tabledef := ValidateTableStructure(tabledef);

  // Translate to schema definition, run to table updater
  RECORD schemadef :=
      [ name :=       schemaname
      , tables :=     [ [ name :=           tablename
                        , primarykey :=     tabledef.primarykey
                        , cols :=           SELECT name :=                column_name
                                                 , dbtype :=              data_type
                                                 , maxlength :=           character_octet_length
                                                 , autonumberstart :=     autonumber_start
                                                 , nullable
                                                 , isunique
                                                 , noupdate
                                                 , references_schema :=   referenced_table_schema
                                                 , references_table :=    referenced_table_name
                                                 , ondelete :=            on_delete
                                              FROM tabledef.cols
                        ]
                      ]
      ];

  RECORD cmd := GenerateDependentSQLCommands([ schemadef ], trans);
  IF (LENGTH(cmd.errors) > 0)
    THROW NEW Exception(cmd.errors[0]);

  ExecuteSQLUpdates(cmd.commands);
}
