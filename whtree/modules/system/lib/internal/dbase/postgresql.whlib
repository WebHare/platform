<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/stringparser.whlib";
LOADLIB "wh::dbase/postgresql.whlib";


/** Varchars longer than this length are stored with a LEFT(...) expression
    Keep in sync with query generation in hsvm_pgsqlprovider.cpp!
    (rationale: a index record is max about 2100 bytes long.
    264 chars are max 1056 bytes (utf-8), so room for 2 max length strings
    in the index record)
*/
CONSTANT INTEGER max_varchar_indexcolsize := 264;

CONSTANT STRING autonumberfunc_procid := `autonrs:1`;

STATIC OBJECTTYPE ChangeContext
< /// Transaction
  PUBLIC OBJECT trans;

  /// List of current commands
  RECORD ARRAY commands;

  /// List of errors
  STRING ARRAY errors;

  MACRO NEW(OBJECT trans)
  {
    this->trans := trans;
  }

  /** Add a function ptr to execute
      @param cmd Function ptr to execute
  */
  PUBLIC MACRO AddTransOp(FUNCTION PTR cmd)
  {
    INSERT CELL[ type := "transop", cmd ] INTO this->commands AT END;
  }

  /** Add an SQL command to execute
      @param cmd SQL command
  */
  PUBLIC MACRO AddCommand(STRING cmd)
  {
    INSERT CELL
        [ type :=     "sql"
        , cmd
        , execsql :=  PTR this->trans->__ExecSQL(#1)
        ] INTO this->commands AT END;
  }

  /** Add an error
      @param err Error text
  */
  PUBLIC MACRO AddError(STRING err)
  {
    INSERT err INTO this->errors AT END;
  }

  /** Return results
      @return Modification commands/errors
      @cell(record array) return.commands Commands
      @cell(string) return.commands.type transop
      @cell(string) return.commands.cmd Command (function ptr/sql)
      @cell(string array) return.errors List of errors
  */
  PUBLIC RECORD FUNCTION ResultsSoFar()
  {
    RETURN CELL[ this->commands, this->errors ];
  }
>;


/** Quick and dirty parser for expression lists, with support for quoted
    strings and parentheses
*/
PUBLIC STRING ARRAY FUNCTION ParsePostgreSQLExpressionList(STRING exprs)
{
  STRING ARRAY result;
  OBJECT p := NEW StringParser(exprs);

  STRING curexpr;
  INTEGER slashes;
  WHILE (NOT p->eof)
  {
    curexpr := curexpr || p->ParseWhileNotInSet(`()[],"'`);
    SWITCH (p->current)
    {
      CASE `(`, '['   { curexpr := curexpr || p->ParseN(1); slashes := slashes + 1; }
      CASE `)`, ']'   { curexpr := curexpr || p->ParseN(1); slashes := slashes - 1; }
      CASE `"`, `'`
      {
        STRING quote := p->current;
        curexpr := curexpr || p->ParseN(1);
        WHILE (NOT p->eof)
        {
          curexpr := curexpr || p->ParseWhileNotInSet(quote || `\\`);
          if (p->current = "\\")
            curexpr := curexpr || p->ParseN(2);
          ELSE IF (p->current = quote)
          {
            curexpr := curexpr || p->ParseN(1);
            BREAK;
          }
        }
      }
      CASE `,`
      {
        IF (slashes = 0)
        {
          INSERT curexpr INTO result AT END;
          curexpr := "";
          p->Next();
        }
        ELSE
          curexpr := curexpr || p->ParseN(1);
      }
    }
  }

  IF (exprs != "")
    INSERT curexpr INTO result AT END;
  RETURN result;
}

BOOLEAN have_schemata, have_indices, have_triggers;
RECORD ARRAY schemata, allindices, alltriggers;

RECORD ARRAY FUNCTION GetSchemata(OBJECT trans)
{
  IF(NOT have_schemata)
  {
    SCHEMA is LIKE postgresql_information_schema;
    is := BindTransactionToSchema(trans->id, "information_schema");

    schemata :=
        SELECT *
             , have_tables :=   FALSE
             , tables :=        RECORD[]
          FROM is.schemata
      ORDER BY schema_name;
    have_schemata := TRUE;
  }
  RETURN schemata;
}

RECORD ARRAY FUNCTION GetTables(OBJECT trans, STRING schema_name)
{
  GetSchemata(trans);
  RECORD spos := RecordLowerBound(schemata, CELL[ schema_name ], [ "SCHEMA_NAME" ]);
  IF (NOT spos.found)
    RETURN RECORD[];

  IF (NOT schemata[spos.position].have_tables)
  {
    schemata[spos.position].have_tables := TRUE;
    schemata[spos.position].tables :=
          SELECT *
               , table_schema :=  schema_name
               , have_columns :=  FALSE
               , columns :=       RECORD[]
            FROM trans->GetTableListing(schema_name)
        ORDER BY table_name;
  }
  RETURN schemata[spos.position].tables;
}

STRING FUNCTION MapAction(STRING indata)
{
  SWITCH (indata)
  {
    CASE "a"  { RETURN "no action"; }
    CASE "r"  { RETURN "restrict"; }
    CASE "c"  { RETURN "cascade"; }
    CASE "n"  { RETURN "set null"; }
    CASE "d"  { RETURN "set default"; }
  }
  RETURN "";
}


RECORD ARRAY FUNCTION GetCachableColumns(OBJECT trans, STRING schemaname, STRING tablename, INTEGER table_oid)
{
  SCHEMA catalog LIKE postgresql_pg_catalog;
  catalog := BindTransactionToSchema(trans->id, "pg_catalog");
  SCHEMA is LIKE postgresql_information_schema;
  is := BindTransactionToSchema(trans->id, "information_schema");

  RECORD ARRAY constraints := trans->__ExecSQL(
      `SELECT conrelid
            , contype
            , confrelid
            , conkey
            , conname
            , confdeltype
            , pg_get_constraintdef(oid) AS check_expression
         FROM pg_catalog.pg_constraint
        WHERE conrelid = $1
          AND array_length(conkey, 1) = 1`, [ args := VARIANT[ table_oid ] ]);

  RECORD ARRAY refdtables :=
      SELECT confrelid :=                 pg_class.oid
           , referenced_table_name :=     relname
           , referenced_table_schema :=   nspname
        FROM catalog.pg_class
           , catalog.pg_namespace
       WHERE relnamespace = pg_namespace.oid
         AND pg_class.oid IN (SELECT AS INTEGER ARRAY DISTINCT confrelid FROM constraints WHERE confrelid != 0);

  constraints := JoinArrays(constraints, "confrelid", refdtables,
      [ referenced_table_name := ""
      , referenced_table_schema := ""
      ],
      [ rightouterjoin := TRUE
      ]);

  OBJECT sequence_generator := NEW Regex("^nextval\\((.*)\\)$");

  RECORD ARRAY columns :=
      SELECT TEMPORARY attr_constraints := (SELECT * FROM constraints WHERE constraints.conkey[0] = pg_attribute.attnum)
           , TEMPORARY foreignkey := (SELECT * FROM attr_constraints WHERE contype = "f")
           , column_name :=               attname
           , character_octet_length :=    attlen
           , character_maximum_length :=  atttypid IN [ 1042, 1043 ] ? atttypmod - 4 : atttypid IN [ 1560, 1562 ] ? atttypmod : 0 // https://stackoverflow.com/questions/52376045/why-does-atttypmod-differ-from-character-maximum-length
           , is_nullable :=               attnotnull = FALSE
           , data_type :=                 typname || (atttypid IN [ 1042, 1043 ] ? `(${atttypmod - 4})` : atttypid IN [ 1560, 1562 ] ? `(${atttypmod})` : "")
           , on_delete :=                 RecordExists(foreignkey) ? MapAction(foreignkey.confdeltype) : ""
           , is_unique :=                 RecordExists(SELECT FROM attr_constraints WHERE contype = "u" OR contype = "p")
           , is_unique_constraint_name := (SELECT AS STRING COLUMN conname FROM attr_constraints WHERE contype = "u" OR contype = "p")
           , referenced_table_name :=     RecordExists(foreignkey) ? foreignkey.referenced_table_name : ""
           , referenced_table_schema :=   RecordExists(foreignkey) ? foreignkey.referenced_table_schema : ""
           , check_expression :=          (SELECT AS STRING COLUMN check_expression FROM attr_constraints WHERE contype = "c")
           , check_constraint_name :=     (SELECT AS STRING COLUMN conname FROM attr_constraints WHERE contype = "c")
           , foreignkey_constraint_name := (SELECT AS STRING COLUMN conname FROM attr_constraints WHERE contype = "f")
        FROM catalog.pg_attribute
           , catalog.pg_type
       WHERE attrelid = table_oid
         AND pg_type.oid = atttypid
         AND attname NOT IN [ "cmin", "cmax", "ctid", "tableoid", "xmax", "xmin" ]; // hide system columns

  RECORD ARRAY is_cols :=
      SELECT column_name
           , autonumber_start :=          ToInteger64(identity_minimum, 0)
           , column_default
           , sequencename :=              ""
        FROM is.columns
       WHERE table_schema = schemaname
         AND table_name = tablename;

  FOREVERY (RECORD col FROM is_cols)
  {
    RECORD ARRAY match := sequence_generator->Exec(col.column_default);
    IF (RecordExists(match))
    {
      RECORD seq := trans->__ExecSQL(
          `SELECT seqrelid::text AS sequence_name
                , seqstart
             FROM pg_catalog.pg_sequence
            WHERE seqrelid = ${match[1].value}`);
      is_cols[#col].autonumber_start := RecordExists(seq) ? INTEGER(seq.seqstart) : 0;
      is_cols[#col].sequencename := seq.sequence_name;
    }
  }

  RETURN JoinArrays(columns, "column_name", is_cols, [ autonumber_start := 0i64, column_default := "", sequencename := "" ]);
}

RECORD ARRAY FUNCTION GetColumns(OBJECT trans, STRING table_schema, STRING table_name)
{
  GetTables(trans, table_schema);
  RECORD spos := RecordLowerBound(schemata, CELL[ schema_name := table_schema ], [ "SCHEMA_NAME" ]);
  IF (NOT spos.found)
    RETURN RECORD[];
  RECORD tpos := RecordLowerBound(schemata[spos.position].tables, CELL[ table_name ], [ "TABLE_NAME" ]);
  IF (NOT tpos.found)
    RETURN RECORD[];

  IF (NOT schemata[spos.position].tables[tpos.position].have_columns)
  {
    RECORD tablerec := schemata[spos.position].tables[tpos.position];
    schemata[spos.position].tables[tpos.position].columns :=
        SELECT *
             , table_id :=      tablerec.object_id
             , table_schema :=  table_schema
             , table_name :=    table_name
          FROM GetCachableColumns(trans, table_schema, table_name, schemata[spos.position].tables[tpos.position].object_id);
    schemata[spos.position].tables[tpos.position].have_columns := TRUE; //set columns first, if above might ever throw?
  }
  RETURN schemata[spos.position].tables[tpos.position].columns;
}

RECORD ARRAY FUNCTION GetIndices(OBJECT trans)
{
  IF(NOT have_indices)
  {
    SCHEMA catalog LIKE postgresql_pg_catalog;
    catalog := BindTransactionToSchema(trans->id, "pg_catalog");

    allindices := trans->__ExecSQL(`
SELECT n.nspname AS table_schema
     , rc.relname AS table_name
     , ic.relname AS index_name
     , i.indrelid
     , i.indisunique
     , i.indisprimary
     , i.indkey
     , i.indclass
     , i.indoption
     , pg_get_expr(i.indexprs, i.indrelid) as indexprs
     , pg_get_expr(i.indpred, i.indrelid) as indpred
     , a.amname
  FROM pg_catalog.pg_index i
       JOIN pg_catalog.pg_class ic ON indexrelid = ic.oid
       JOIN pg_catalog.pg_class rc ON indrelid = rc.oid
       JOIN pg_catalog.pg_namespace n ON rc.relnamespace = n.oid
       JOIN pg_am a ON a.oid = ic.relam
`);

    RECORD ARRAY allrefdcols := trans->__ExecSQL(`
        SELECT a.attrelid
             , a.attname
             , a.attnum
             , a.atttypid
          FROM pg_catalog.pg_index i
               JOIN pg_catalog.pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey)
      ORDER BY a.attrelid, a.attnum`);

    INTEGER ARRAY indclass_ids;
    FOREVERY (RECORD rec FROM allindices)
      indclass_ids := indclass_ids CONCAT rec.indclass;

    RECORD ARRAY indclasses :=
        SELECT oid
             , opcmethod
             , opcname
          FROM catalog.pg_opclass
         WHERE oid IN GetSortedSet(indclass_ids)
      ORDER BY oid;

    FOREVERY (RECORD rec FROM allindices)
    {
      STRING ARRAY exprs := ParsePostgreSQLExpressionList(rec.indexprs) CONCAT RepeatElement("", LENGTH(rec.indkey));
      STRING ARRAY preds := ParsePostgreSQLExpressionList(rec.indpred) CONCAT RepeatElement("", LENGTH(rec.indkey));

      RECORD ARRAY cols;
      INTEGER curexpr;
      FOREVERY (INTEGER k FROM rec.indkey)
      {
        RECORD cpos := RecordLowerBound(indclasses, [ oid := rec.indclass[#k] ], [ "OID" ]);
        IF (NOT cpos.found)
          THROW NEW Exception(`Could not find pg_opclass record #${rec.indclass[#k]}`);
        RECORD apos := RecordLowerBound(allrefdcols, [ attrelid := rec.indrelid, attnum := k ], [ "ATTRELID", "ATTNUM" ]);
        RECORD attr;
        IF (apos.found)
          attr := allrefdcols[apos.position];
        ELSE IF (k != 0)
          THROW NEW Exception(`Could not find pg_attribute record (${rec.indrelid}#${k})`);
        ELSE
        {
          curexpr := curexpr + 1;
        }

        INSERT CELL
            [ attnum :=         RecordExists(attr) ? attr.attnum : 0
            , attname :=        RecordExists(attr) ? attr.attname : ""
            , atttypid :=       RecordExists(attr) ? attr.atttypid : 0
            , indclass :=       rec.indclass[#k]
            , indclasses[cpos.position].opcname
            , indoption :=      rec.indoption[#k]
            , indexpr :=        k = 0 ? exprs[curexpr - 1] : ""
            , indpred :=        preds[#k]
            ] INTO cols AT END;
      }

      INSERT CELL cols := cols INTO allindices[#rec];
      DELETE CELL indkey, indoption, indclass FROM allindices[#rec];
    }

    have_indices := TRUE;
  }
  RETURN allindices;
}

RECORD ARRAY FUNCTION GetTriggers(OBJECT trans)
{
  IF(NOT have_triggers)
  {
    alltriggers := trans->__ExecSQL(`
        SELECT n.nspname AS table_schema
             , rc.relname AS table_name
             , t.tgname AS triggername
          FROM pg_catalog.pg_trigger t
               JOIN pg_catalog.pg_class rc ON tgrelid = rc.oid
               JOIN pg_catalog.pg_namespace n ON rc.relnamespace = n.oid
         WHERE t.tgname LIKE 'webhare_%'
      ORDER BY n.nspname, rc.relname`);

    have_triggers := TRUE;
  }
  RETURN alltriggers;
}

PUBLIC MACRO ClearAllPostgreSQLSchemaCaches()
{
  have_schemata := FALSE;
  have_indices:= FALSE;
}

PUBLIC RECORD FUNCTION GeneratePostgreSQLIndependentSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans)
{
  OBJECT context := NEW ChangeContext(trans);

  FOREVERY(RECORD schemaspec FROM schemaspecs)
  {
    RECORD schemadef := SELECT * FROM GetSchemata(trans) WHERE ToUppercase(schema_name)=ToUppercase(schemaspec.name);
    IF (NOT RecordExists(schemadef))
      context->AddTransOp(PTR trans->CreateSchema(schemaspec.name, "", ""));
  }

  RETURN context->ResultsSoFar();
}

PUBLIC RECORD FUNCTION GeneratePostgreSQLPostupdateSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans)
{
  OBJECT context := NEW ChangeContext(trans);

  /* Kill obsoleted tables */
  FOREVERY(RECORD schemaspec FROM schemaspecs)
  {
    RECORD ARRAY current_tables := GetTables(trans, schemaspec.name);

    FOREVERY(RECORD tablerec FROM schemaspec.obsoletetables)
      IF(RecordExists(SELECT FROM current_tables WHERE ToUppercase(table_name) = ToUppercase(tablerec.name)))
        context->AddTransOp(PTR trans->DropTable(schemaspec.name, tablerec.name));
  }
  RETURN context->ResultsSoFar();
}

/** Transforms a WebHare column definition into PostgreSQL column attrs
    @param context Change context
    @param table_schema Table schema
    @param table_name Table name
    @param colrec WebHare column record
    @param primarykey Name of the primary key
    @return PostgreSQL Column record
*/
RECORD FUNCTION TransformColumnDef(OBJECT context, STRING table_schema, STRING table_name, RECORD colrec, STRING primarykey)
{
  colrec := ValidateOptions(
      [ autonumberstart :=          0i64
      , dbtype :=                   ""
      , defval :=                   ""
      , isunique :=                 FALSE
      , maxlength :=                0
      , name :=                     ""
      , nullable :=                 FALSE
      , ondelete :=                 ""
      , references_schema :=        ""
      , references_table :=         ""
      , check :=                    ""
      , islongkey :=                FALSE
      ], colrec,
      [ required := [ "name", "dbtype" ]
      , discard := [ "internalcolumnname", "noupdate", "documentation", "location" ]
      ]);

  colrec.dbtype := ToLowercase(colrec.dbtype);

  IF (colrec.name = primarykey)
    colrec.isunique := TRUE;

  INSERT CELL sequencename := "" INTO colrec;
  INSERT CELL autonumbersfuncname := "" INTO colrec;

  // Type-specific conversions
  BOOLEAN validated_defval;
  SWITCH (colrec.dbtype)
  {
    CASE "integer", "__longkey"
    {
      IF (colrec.autonumberstart > 0)
      {
        IF (colrec.defval != "")
          context->AddError(`Column ${table_schema}.${table_name}(${colrec.name}) cannot have an autonumber and a default value`);
        ELSE
        {
          colrec.sequencename := `${table_schema}.webhare_seq_${table_name}_${colrec.name}`;

          // Lowercasing the column name because MakeAutoNumber is called with uppercase column names
          colrec.autonumbersfuncname := `${PostgreSQLEscapeIdentifier(table_schema)}.${PostgreSQLEscapeIdentifier(`webhare_autonrs_${table_name}_${ToLowercase(colrec.name)}`)}`;
          colrec.defval := `(${colrec.autonumbersfuncname}(1))[1]`;
          validated_defval := TRUE;
        }
      }
      IF (colrec.dbtype = "__longkey")
      {
        colrec.dbtype := "int8";
        colrec.check := `(((${PostgreSQLEscapeIdentifier(colrec.name)} >= '-2147483648'::integer) AND (${PostgreSQLEscapeIdentifier(colrec.name)} <= 2147483647)))`;
        colrec.islongkey := TRUE;
      }
      ELSE
        colrec.dbtype := "int4";
    }
    CASE "boolean"      { colrec.dbtype := "bool"; }
    CASE "datetime"     { colrec.dbtype := "timestamp"; }
    CASE "string"       { colrec.dbtype := "varchar"; }
    CASE "integer64"    { colrec.dbtype := "int8"; }
    CASE "money"        { colrec.dbtype := "numeric"; }
    CASE "blob"
    {
      colrec.dbtype := "webhare_blob";

      // No foreign key for webhare_internal.webhare_blob table
      IF (table_schema != "webhare_internal" OR table_name != "blob")
      {
        colrec.references_schema := "webhare_internal";
        colrec.references_table := "blob";
        colrec.ondelete := "no action";
      }
      ELSE
      {
        colrec.references_schema := "";
        colrec.references_table := "";
        colrec.ondelete := "";
      }
    }
  }

  IF (colrec.isunique)
    colrec.nullable := FALSE;

  // Default/references handling
  STRING defaultvalue;
  STRING nullcheck;
  IF (colrec.references_table = "") // non-referencing column
  {
    SWITCH (colrec.dbtype)
    {
      CASE "serial"
         , "bigserial"  { defaultvalue := ``; nullcheck := `((${PostgreSQLEscapeIdentifier(colrec.name)} <> 0))`; } // already has default by type
      CASE "int4"
         , "int8"
         , "float"
         , "numeric"    { defaultvalue := `0`; nullcheck := `((${PostgreSQLEscapeIdentifier(colrec.name)} <> 0))`; }
      CASE "varchar"    { defaultvalue := `''::text`; nullcheck := `(((${PostgreSQLEscapeIdentifier(colrec.name)})::text <> ''::text))`; }
      CASE "bool"       { defaultvalue := `false`; nullcheck := `((${PostgreSQLEscapeIdentifier(colrec.name)} <> false))`; }
      CASE "bytea"      { defaultvalue := `'\\x'::bytea`; nullcheck := `((${PostgreSQLEscapeIdentifier(colrec.name)} <> '\\x'::bytea))`; }
      CASE "timestamp"  { defaultvalue := `'-infinity'::timestamp without time zone`; nullcheck := `((${PostgreSQLEscapeIdentifier(colrec.name)} <> '-infinity'::timestamp without time zone))`; }
      CASE "webhare_blob" { defaultvalue := ``; }
      DEFAULT   { ABORT(`No default value for type '${colrec.dbtype}'`); }
    }

    IF (colrec.defval = "")
    {
      colrec.defval := defaultvalue;
      validated_defval := TRUE;
    }

    IF (NOT colrec.nullable)
    {
      IF (colrec.check != "")
      {
        // checks are in the form ( expr ). expr is (value op value op value op value)
        IF (colrec.check NOT LIKE "((*) AND (*))")
          colrec.check := `(${colrec.check})`;
        IF (nullcheck NOT LIKE "((*) AND (*))")
          nullcheck := `(${nullcheck})`;
        colrec.check := `${Left(colrec.check, LENGTH(colrec.check) - 2)} AND ${SubString(nullcheck, 2)}`;
      }
      ELSE
        colrec.check := nullcheck;
    }

    colrec.nullable := FALSE;
  }
  ELSE // reference to other table
  {
    // colrec.nullable can be used directly
    // Default value is NULL, standard insert behaviour
  }

  IF (colrec.defval != "" AND NOT validated_defval)
  {
    IF (colrec.defval != defaultvalue)
    {
      STRING accepted_defval;
      IF (colrec.dbtype IN [ "bool", "int4", "varchar" ])
      {
        SWITCH (colrec.dbtype)
        {
          CASE "bool"
          {
            IF (ToLowercase(colrec.defval) IN [ "true", "false" ])
              accepted_defval := ToLowercase(colrec.defval);
            ELSE
              context->AddError(`Invalid default value ${colrec.defval} for column ${table_schema}.${table_name}.${colrec.name}`);
          }
          CASE "int4", "int8"
          {
            VARIANT decoded := DecodeJSON(colrec.defval);
            IF (TypeID(decoded) IN [ TypeID(INTEGER), TypeID(INTEGER64) ])
              accepted_defval := ToString(decoded);
            ELSE
              context->AddError(`Invalid default value ${colrec.defval} for column ${table_schema}.${table_name}.${colrec.name}`);
          }
          CASE "varchar"
          {
            VARIANT decoded := DecodeJSON(colrec.defval);
            IF (TypeID(decoded) = TypeID(STRING))
              accepted_defval := `'${SubString(decoded, 1, LENGTH(decoded) - 1)}'`;
            ELSE
              context->AddError(`Invalid default value ${colrec.defval} for column ${table_schema}.${table_name}.${colrec.name}`);
          }
          DEFAULT
          {
            context->AddError(`Cannot validate default values of database type ${colrec.dbtype} for column ${table_schema}.${table_name}.${colrec.name}`);
          }
        }
      }
      colrec.defval := accepted_defval;
    }
  }

  RETURN colrec;
}


STRING FUNCTION GetColumnBaseDef(RECORD colrec)
{
  STRING def := `${PostgreSQLEscapeIdentifier(colrec.name)} ${colrec.dbtype}`;
  IF (colrec.dbtype = "varchar")
    def := def || "(" || colrec.maxlength || ")";
  IF (colrec.isunique)
    def := def || " UNIQUE";
  IF (NOT colrec.nullable)
    def := def || " NOT NULL";
  IF (colrec.defval != "" AND colrec.sequencename = "") // don't set a nextval() expression immediately
    def := def || ` DEFAULT ${colrec.defval}`;
  IF (colrec.check != "")
    def := def || ` CHECK${colrec.check}`;
  RETURN def;
}

MACRO DropColumnFkey(OBJECT context, STRING tableschema, STRING tablename, RECORD colrec)
{
  STRING def := `ALTER TABLE ${PostgreSQLEscapeIdentifier(tableschema)}.${PostgreSQLEscapeIdentifier(tablename)} DROP CONSTRAINT ${PostgreSQLEscapeIdentifier(colrec.foreignkey_constraint_name)}`;
  context->AddCommand(def);
}

MACRO SetColumnFkey(OBJECT context, STRING tableschema, STRING tablename, RECORD colrec)
{
  IF(colrec.references_table="")
    RETURN;

  STRING def := `ALTER TABLE ${PostgreSQLEscapeIdentifier(tableschema)}.${PostgreSQLEscapeIdentifier(tablename)} ADD FOREIGN KEY (${PostgreSQLEscapeIdentifier(colrec.name)})`;
  def := def || ` REFERENCES ${PostgreSQLEscapeIdentifier(colrec.references_schema)}.${PostgreSQLEscapeIdentifier(colrec.references_table)}`;
  def := def || ` ON DELETE ${ToUppercase(colrec.ondelete) ?? "NO ACTION"}`;
  def := def || ` ON UPDATE CASCADE`;
  def := def || ` INITIALLY DEFERRED`;
  context->AddCommand(def);
}

BOOLEAN FUNCTION AreExpressionsEquivalent(STRING frompostgresql, STRING canonical)
{
  IF (frompostgresql = canonical)
    RETURN TRUE;

  // Postgresql quotes only when necessesary. For now, the same expression minus some quotes is good enough.
  STRING ARRAY parts := Tokenize(canonical, `"`);
  FOREVERY (STRING part FROM parts)
  {
    INTEGER partlen := LENGTH(part);
    IF (Left(frompostgresql, partlen) = part)
      frompostgresql := Substring(frompostgresql, partlen);
    ELSE IF (Left(frompostgresql, partlen + 1) = `"${part}`)
      frompostgresql := Substring(frompostgresql, partlen + 1);
    ELSE IF (Left(frompostgresql, partlen + 1) = `"public"."${part}`)
      frompostgresql := Substring(frompostgresql, partlen + 1);
    ELSE
      RETURN FALSE;
  }

  RETURN frompostgresql = "";
}

STRING FUNCTION GetIndexColumnExpression(RECORD colrec, RECORD ind)
{
  STRING expr := PostgreSQLEscapeIdentifier(colrec.name);

  IF (colrec.dbtype = "varchar")
  {

    BOOLEAN too_long := colrec.maxlength > max_varchar_indexcolsize;
    STRING ARRAY conversions;
    IF (too_long AND NOT ind.is_unique)
      INSERT `"left"($1, ${max_varchar_indexcolsize})` INTO conversions AT END;
    IF (ind.is_uppercase)
      INSERT `upper($1)` INTO conversions AT END;
    IF (too_long AND ind.is_unique)
      INSERT `digest($1, 'sha256'::text)` INTO conversions AT END;

    // Make sure that the first )::text follows the column name directly!!
    // The schemadef parser currently depends on it.

    FOREVERY (STRING conv FROM conversions)
    {
      IF (expr NOT LIKE "*)")
        expr := `(${expr})::text`;
      expr := Substitute(conv, "$1", expr);
    }
  }

  RETURN expr;
}

STRING FUNCTION GenerateCreateIndexCommandFromSpec(RECORD schemaspec, RECORD tablerec, RECORD ind, STRING name)
{
  // Create the new index
  STRING cmd := "CREATE ";
  IF (ind.is_unique)
    cmd := cmd || "UNIQUE ";
  cmd := cmd || `INDEX ${PostgreSQLEscapeIdentifier(name)} ON ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}`;

  STRING colpart := "(";
  FOREVERY (RECORD col FROM ind.columns)
  {
    IF (#col != 0)
      colpart := colpart || ", ";

    RECORD colrec := SELECT * FROM tablerec.cols WHERE COLUMN name = col.name;
    IF (NOT RecordExists(colrec))
      THROW NEW Exception(`Column '${col.name}'' in index ${schemaspec.name}.${tablerec.name}.${ind.name} is could not be found in table definition`);

    colpart := colpart || GetIndexColumnExpression(colrec, ind);
  }
  colpart := colpart || ")";

  cmd := cmd || colpart;

  IF (ind.nonullstores)
  {
    cmd := cmd || " WHERE ";
    FOREVERY (RECORD col FROM ind.columns)
    {
      IF (#col != 0)
        cmd := cmd || " AND ";
      RECORD colrec := SELECT * FROM tablerec.cols WHERE COLUMN name = col.name;
      IF (NOT RecordExists(colrec))
        THROW NEW Exception(`Column '${col.name}'' in index ${schemaspec.name}.${tablerec.name}.${ind.name} is could not be found in table definition`);

      IF (colrec.dbtype = "webhare_blob" OR colrec.references_table != "")
        cmd := cmd || `(${PostgreSQLEscapeIdentifier(col.name)} IS NOT NULL)`;
      ELSE
        cmd := cmd || `${PostgreSQLEscapeIdentifier(col.name)} <> ${colrec.defval}`;
    }
  }

  RETURN cmd;
}

STRING FUNCTION DecodeIdentifier(STRING ident)
{
  IF (ident LIKE `U&"*`)
    ABORT(`Decoding U&-format identifiers not supported yet`);
  IF (ident NOT LIKE `"*`)
    RETURN ident;
  ident := TrimWhitespace(ident);
  RETURN Substitute(SubString(ident, 1, LENGTH(ident) - 2), `""`, `"`);
}

BOOLEAN FUNCTION TestNeedReplaceFunction(STRING name, STRING procversion)
{
  STRING namespace;
  IF (name LIKE "*.*")
  {
    STRING ARRAY parts := Tokenize(name, ".");
    namespace := DecodeIdentifier(parts[0]);
    name := parts[1];
  }
  name := DecodeIdentifier(name);

  INTEGER nsoid := namespace != ""
      ? SELECT AS INTEGER oid
          FROM postgresql_pg_catalog.pg_namespace
         WHERE nspname = namespace
      : 0;

  STRING cursrc :=
      SELECT AS STRING prosrc
        FROM postgresql_pg_catalog.pg_proc
       WHERE proname = name
         AND pronamespace = nsoid;

  STRING ARRAY parts := Tokenize(cursrc, "whprocversion:");
  IF (LENGTH(parts) = 1) // no version id?
    RETURN TRUE;

  STRING curversion := TrimWhitespace(Tokenize(parts[1], "*")[0]);
  RETURN curversion != procversion;
}

PUBLIC MACRO RebuildColumnAutonumberConfig(OBJECT context, STRING schemaname, STRING tablename, RECORD col)
{
  // Easier to re-create the sequence, our autonr function will skip over existing ids anyway (rebuild should not happen nilly-willy anyway)
  IF (context->trans->__ExecSQL(`SELECT to_regclass($1)::oid`, [ args := VARIANT[ col.sequencename ] ]).to_regclass != 0)
    context->AddCommand(`DROP SEQUENCE IF EXISTS ${col.sequencename}`);

  // Use int4 for __longkey, so the value is clamped and an integer is returned (useful for MakeAutoNumber)
  context->AddCommand(`CREATE SEQUENCE ${col.sequencename} MINVALUE ${col.autonumberstart}${col.dbtype = "int8" AND NOT col.islongkey ? "" : " MAXVALUE 2147483647"} START WITH ${col.autonumberstart} CYCLE OWNED BY ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)}.${PostgreSQLEscapeIdentifier(col.name)}`);

  // When updating the contents of this function, please update `autonumberfunc_procid` to replace the existing functions
  context->AddCommand(`CREATE OR REPLACE FUNCTION ${col.autonumbersfuncname}(count integer) RETURNS ${col.dbtype}[] VOLATILE LANGUAGE plpgsql AS $$
/* whprocversion: ${autonumberfunc_procid} */
DECLARE
  retval ${col.dbtype}[] := '{}';
  sel ${col.dbtype}[];
  currid ${col.dbtype};
  orgnextid ${col.dbtype};
  currbatchsize int;
  largebatchsize int;
BEGIN
  PERFORM pg_advisory_lock(${PostgreSQLEscapeLiteral(col.sequencename)}::regclass::int8);
  currid := nextval(${PostgreSQLEscapeLiteral(col.sequencename)}::regclass);
  orgnextid := currid;
  currbatchsize := count;
  largebatchsize := 500;

  WHILE count > 0 LOOP
    IF currbatchsize = 1 THEN
      /* fast path for selecting a single nr */
      IF EXISTS (SELECT
                   FROM ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)} tbl
                  WHERE tbl.${PostgreSQLEscapeIdentifier(col.name)} = currid) THEN
        sel := NULL;
      ELSE
        sel := ARRAY[ currid ];
      END IF;
    ELSE
      SELECT array_agg(newkey) INTO sel
        FROM (SELECT newkey
                FROM generate_series(currid, currid + currbatchsize - 1) AS keys(newkey)
               WHERE NOT EXISTS (SELECT FROM ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)} tbl WHERE tbl.${PostgreSQLEscapeIdentifier(col.name)} = keys.newkey)
               LIMIT count) AS foo;
    END IF;

    IF sel IS NULL THEN
      currid := currid + currbatchsize;
      currbatchsize := largebatchsize;
      CONTINUE;
    END IF;

    IF array_length(sel, 1) = count THEN
      currid := sel[count] + 1;
    ELSE
      currid := currid + currbatchsize;
    END IF;

    retval := retval || sel;
    count := count - array_length(sel, 1);
    currbatchsize := largebatchsize;
  END LOOP;

  IF currid != orgnextid + 1 THEN
    PERFORM setval(${PostgreSQLEscapeLiteral(col.sequencename)}::regclass, currid, FALSE);
  END IF;

  PERFORM pg_advisory_unlock(${PostgreSQLEscapeLiteral(col.sequencename)}::regclass::int8);
  RETURN retval;
END;$$`);

  context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaname)}.${PostgreSQLEscapeIdentifier(tablename)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(col.name)} SET DEFAULT ${col.defval}`);
}

PUBLIC RECORD FUNCTION GeneratePostgreSQLDependentSQLCommands(RECORD ARRAY schemaspecs, OBJECT trans, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ skipcreateforeignkeys :=  FALSE
      , skipcreateindices :=      FALSE
      ], options);

  OBJECT context := NEW ChangeContext(trans);

  RECORD ARRAY fkeys_to_update;

  /* CREATE and ALTER tables (but do NOT set foreign keys) */
  FOREVERY(RECORD schemaspec FROM schemaspecs)
  {
    RECORD ARRAY current_tables := SELECT table_name, object_id FROM GetTables(trans, schemaspec.name);

    FOREVERY(RECORD tablerec FROM schemaspec.tables)
    {
      RECORD curtab := SELECT * FROM current_tables WHERE table_name = tablerec.name;

      // Internal columns aren't stored in PostgreSQL
      DELETE FROM tablerec.cols WHERE internalcolumnname != "";

      // Convert to stuff we can update
      tablerec.cols :=
          SELECT AS RECORD ARRAY TransformColumnDef(context, schemaspec.name, tablerec.name, cols, tablerec.primarykey)
            FROM tablerec.cols;

      IF (RecordExists(curtab))
      {
        //FIXME: Verify that columns have the proper properties
        RECORD ARRAY curcols := GetColumns(trans, schemaspec.name, tablerec.name);

        FOREVERY(RECORD coldef FROM tablerec.cols)
        {
          RECORD curcol := SELECT * FROM curcols WHERE column_name = coldef.name;
          IF(RecordExists(curcol))
          {
            //foreign key mismatch?
            IF (curcol.referenced_table_schema != coldef.references_schema
                OR curcol.referenced_table_name != coldef.references_table
                OR (ToUppercase(curcol.on_delete) ?? "NO ACTION") != (ToUppercase(coldef.ondelete) ?? "NO ACTION"))
            {
              IF (curcol.referenced_table_name != "")
                DropColumnFkey(context, schemaspec.name, tablerec.name, curcol);
              IF(coldef.references_table != "")
                INSERT INTO fkeys_to_update(schemaname, tablename, colrec) VALUES(schemaspec.name, tablerec.name, coldef) AT END;
            }

            STRING expect_data_type := coldef.dbtype;
            IF (expect_data_type = "varchar")
              expect_data_type := `${expect_data_type}(${coldef.maxlength})`;

            // Convert data types
            IF (expect_data_type != curcol.data_type)
            {
              STRING alterbase := `ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)}`;
              IF(curcol.column_default != "")
              {
                // Conversion will fail when the column default can't be converted automatically, so just drop it
                // It will be re-initialized later
                // USING does not convert the default, see https://www.postgresql.org/docs/current/sql-altertable.html
                context->AddCommand(`${alterbase} DROP DEFAULT`);
                curcol.column_default := "";
              }

              STRING cmd := `${alterbase} TYPE ${expect_data_type}`;
              IF(expect_data_type = "bytea")
              {
                // conversion to bytea needs an explicit conversion function
                cmd := `${cmd} USING convert_to(${PostgreSQLEscapeIdentifier(coldef.name)}, 'UTF-8')`;
              }
              context->AddCommand(cmd);

              IF(coldef.defval != "")
                context->AddCommand(`${alterbase} SET DEFAULT ${coldef.defval}`);
            }

            IF(coldef.nullable != curcol.is_nullable)
              context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)}${coldef.nullable ? " DROP NOT NULL" : " SET NOT NULL"}`);
            IF(coldef.isunique != curcol.is_unique)
              IF(coldef.isunique)
              {
                context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ADD UNIQUE (${PostgreSQLEscapeIdentifier(coldef.name)})`);
              }
              ELSE
              {
                context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} DROP CONSTRAINT ${PostgreSQLEscapeIdentifier(curcol.is_unique_constraint_name)}`);
              }

            IF (NOT AreExpressionsEquivalent(curcol.check_expression, coldef.check = "" ? "" : `CHECK ${coldef.check}`))
            {

              IF (curcol.check_expression != "")
                context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} DROP CONSTRAINT ${PostgreSQLEscapeIdentifier(curcol.check_constraint_name)}`);
              IF (coldef.check != "")
                context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ADD CHECK ${coldef.check}`);
            }

            BOOLEAN rebuildautonumberconfig;
            IF (NOT AreExpressionsEquivalent(curcol.column_default, coldef.defval))
            {
              PRINT(`Non eq defaults: '${curcol.column_default}' vs '${coldef.defval}'\n`);
              IF (curcol.column_default != "")
                context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)} DROP DEFAULT`);
              IF (coldef.defval != "")
              {
                IF (coldef.autonumbersfuncname != "")
                  rebuildautonumberconfig := TRUE;
                ELSE
                  context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)} SET DEFAULT ${coldef.defval}`);
              }
            }

            IF (NOT rebuildautonumberconfig AND coldef.autonumbersfuncname != "" AND TestNeedReplaceFunction(coldef.autonumbersfuncname, autonumberfunc_procid))
              rebuildautonumberconfig := TRUE;

            IF (rebuildautonumberconfig)
              RebuildColumnAutonumberConfig(context, schemaspec.name, tablerec.name, coldef);

            IF(coldef.dbtype = "varchar" AND coldef.maxlength > curcol.character_maximum_length)
              context->AddCommand(`ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ALTER COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)} SET DATA TYPE VARCHAR(${coldef.maxlength})`);
          }
          ELSE
          {
            IF(coldef.name = tablerec.primarykey)
            {
              context->AddError(`Cannot change the primary column of table ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}`);
              CONTINUE;
            }

            STRING cmd := `ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} ADD COLUMN `;
            cmd := cmd || GetColumnBaseDef(coldef);
            IF(coldef.references_table != "")
              INSERT INTO fkeys_to_update(schemaname, tablename,colrec) VALUES(schemaspec.name, tablerec.name, coldef) AT END;
            context->AddCommand(cmd);
          }
        }

        RECORD ARRAY kill_columns := SELECT obsoletecols.*
                                       FROM tablerec.obsoletecols AS obsoletecols, curcols
                                      WHERE ToUppercase(obsoletecols.name) = ToUppercase(curcols.column_name);
        FOREVERY(RECORD coldef FROM kill_columns)
        {
          STRING cmd := `ALTER TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)} DROP COLUMN ${PostgreSQLEscapeIdentifier(coldef.name)}`;
          context->AddCommand(cmd);
        }

        RECORD ARRAY triggers := SELECT * FROM GetTriggers(trans) WHERE table_schema = schemaspec.name AND table_name = tablerec.name;
        IF (tablerec.legacy_writeaccessmgr != "")
        {
          STRING name := `webhare_${tablerec.name}_writeaccess`;
          IF (NOT RecordExists(SELECT FROM triggers WHERE triggername = name))
          {
            context->AddCommand(`
                CREATE TRIGGER ${PostgreSQLEscapeIdentifier("webhare_" || tablerec.name || "_writeaccess")}
                BEFORE INSERT OR UPDATE OR DELETE ON ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}
                   FOR EACH ROW
               EXECUTE FUNCTION ${PostgreSQLEscapeIdentifier(`webhare_trigger_${schemaspec.name}_${tablerec.name}_writeaccess`)}()`);
          }
          DELETE FROM triggers WHERE triggername = name;
        }

        FOREVERY (RECORD trigger FROM triggers)
          context->AddCommand(`DROP TRIGGER ${PostgreSQLEscapeIdentifier(trigger.triggername)} ON ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}`);
      }
      ELSE
      {
        //Create a table creation command
        STRING cmd := `CREATE TABLE ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}`;
        STRING coldefs;
        FOREVERY(RECORD col FROM tablerec.cols)
        {
          coldefs := coldefs || (coldefs != "" ? "\n, " : "") || GetColumnBaseDef(col);
          IF (col.name = tablerec.primarykey)
            coldefs := coldefs || " PRIMARY KEY";
        }
        cmd := cmd || "\n( " || coldefs || ")";

        context->AddCommand(cmd);

        // Create/update sequences
        FOREVERY(RECORD col FROM tablerec.cols)
        {
          IF (col.sequencename != "")
            RebuildColumnAutonumberConfig(context, schemaspec.name, tablerec.name, col);

          IF(col.references_table != "")
            INSERT INTO fkeys_to_update(schemaname, tablename,colrec) VALUES(schemaspec.name, tablerec.name, col) AT END;
        }

        FOREVERY(RECORD col FROM tablerec.cols)
          IF (CellExists(col, "autonumberstart") AND col.autonumberstart > 0) // autonumberstart must be handled elsewhere
            context->AddCommand(`ALTER SEQUENCE ${col.sequencename} START WITH ${col.autonumberstart} RESTART`);

        IF (tablerec.legacy_writeaccessmgr != "")
        {
          context->AddCommand(`
              CREATE TRIGGER ${PostgreSQLEscapeIdentifier("webhare_" || tablerec.name || "_writeaccess")}
              BEFORE INSERT OR UPDATE OR DELETE ON ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(tablerec.name)}
                 FOR EACH ROW
             EXECUTE FUNCTION ${PostgreSQLEscapeIdentifier(`webhare_trigger_${schemaspec.name}_${tablerec.name}_writeaccess`)}()`);
        }
      }

      {
        // Get current indices for the current table
        RECORD ARRAY current_indices :=
                                SELECT *
                                  FROM GetIndices(trans) AS indices
                                 WHERE table_schema = schemaspec.name
                                       AND table_name = tablerec.name;

        tablerec.indices :=
            SELECT *
                 , useindexname :=    `${tablerec.name}_wh_${name}`
              FROM tablerec.indices;

        // Add indices for all non-unique foreign keys
        FOREVERY (RECORD col FROM SELECT * FROM tablerec.cols WHERE references_table != '' AND NOT isunique ORDER BY name)
        {
          RECORD declared :=
              SELECT *
                FROM tablerec.indices
               WHERE NOT nonullstores
                 AND columns[0].name = col.name;

          IF (NOT RecordExists(declared))
          {
            INSERT
                [ useindexname :=     `${tablerec.name}_whfk_${col.name}`
                , is_unique :=        FALSE
                , is_uppercase :=     FALSE
                , nonullstores :=     FALSE
                , columns :=          [ CELL[ col.name, len := 0 ] ]
                ] INTO tablerec.indices AT END;
          }
        }

        FOREVERY (RECORD ind FROM tablerec.indices)
        {
          // Name used for the index in PostgreSQL
          STRING name := ind.useindexname;

          RECORD old_index := SELECT * FROM current_indices WHERE index_name = name;

          IF (RecordExists(old_index))
          {
            // Check if the indexdefinition is identical; if not delete the old index
            BOOLEAN is_identical := old_index.indisunique = ind.is_unique;

            IF (is_identical AND LENGTH(old_index.cols) != LENGTH(ind.columns))
              is_identical := FALSE;
            ELSE
            {
              STRING method := "btree";
              FOREVERY (RECORD col FROM ind.columns)
              {
                STRING expr := old_index.cols[#col].indexpr ?? old_index.cols[#col].attname;

                RECORD colrec := SELECT * FROM tablerec.cols WHERE COLUMN name = col.name;
                IF (NOT RecordExists(colrec))
                  THROW NEW Exception(`Column '${col.name}' in index ${schemaspec.name}.${tablerec.name}.${ind.name} could not be found in table definition`);

                STRING expect := GetIndexColumnExpression(colrec, ind);

                IF (NOT AreExpressionsEquivalent(expr, expect))
                  is_identical := FALSE;
                IF (old_index.amname != method)
                  is_identical := FALSE;
              }
            }
            IF (NOT is_identical)
            {
              STRING cmd := `DROP INDEX ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(name)}`;
              context->AddCommand(cmd);
            }
            ELSE
              CONTINUE; // Skip creation step, the old index is identical.
          }

          IF (options.skipcreateindices)
            CONTINUE;

          // Create the new index
          STRING cmd := GenerateCreateIndexCommandFromSpec(schemaspec, tablerec, ind, name);
          context->AddCommand(cmd);
        }

        RECORD ARRAY kill_indices := SELECT obsoleteindices.*
                                       FROM tablerec.obsoleteindices, current_indices
                                      WHERE ToUppercase(obsoleteindices.name) = ToUppercase(current_indices.index_name);
        FOREVERY(RECORD indexdef FROM kill_indices)
        {
          STRING cmd := `DROP INDEX ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(indexdef.name)}`;
          context->AddCommand(cmd);
        }
      }
    }

    /* Reduce impact of obsoleted tables (but physical drop will wait till the real end) */
    FOREVERY(RECORD tablerec FROM schemaspec.obsoletetables)
      IF(RecordExists(SELECT FROM current_tables WHERE table_name = tablerec.name))
      {
        RECORD ARRAY refercolumns := SELECT *
                                       FROM GetColumns(trans, schemaspec.name, tablerec.name)
                                      WHERE referenced_table_name!="";
        FOREVERY(RECORD refcol FROM refercolumns)
          DropColumnFkey(context, schemaspec.name, tablerec.name, refcol);

        // Get current indices for the current table
        RECORD ARRAY referindices := SELECT index_name
                                       FROM GetIndices(trans)
                                      WHERE table_schema = schemaspec.name
                                            AND table_name = tablerec.name
                              GROUP BY index_name;
        FOREVERY(RECORD ind FROM referindices)
        {
          IF (ind.index_name LIKE "*_pkey") // primary key constraint will prevent delete
            CONTINUE;
          STRING cmd := `DROP INDEX ${PostgreSQLEscapeIdentifier(schemaspec.name)}.${PostgreSQLEscapeIdentifier(ind.index_name)}`;
          context->AddCommand(cmd);
        }
      }
  }

  IF (NOT options.skipcreateforeignkeys)
  {
    /* Apply all foreign key contraints */
    FOREVERY(RECORD fkey FROM fkeys_to_update)
      SetColumnFkey(context, fkey.schemaname, fkey.tablename, fkey.colrec);
  }

  RETURN context->ResultsSoFar();
}

PUBLIC RECORD FUNCTION GetPostgreSQLDatabaseSchemaDef(OBJECT trans, STRING schemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ withimplicitindices := FALSE ], options);

  ClearAllPostgreSQLSchemaCaches();

  OBJECT sequence_generator := NEW Regex("^nextval\\((.*)\\)|\\(([^.]*\\.webhare_autonrs_.*)\\(1\\)\\)\\[1\\]$");

  RECORD schemainfo := SELECT * FROM GetSchemata(trans) WHERE ToUppercase(schema_name) = ToUppercase(schemaname);
  IF (NOT RecordExists(schemainfo))
    RETURN DEFAULT RECORD;

  RECORD schemadef :=
      [ name :=               schemainfo.schema_name
      , tables :=             RECORD[]
      , obsoletetables :=     RECORD[]
      ];

  FOREVERY(RECORD tablerec FROM (SELECT * FROM GetTables(trans, schemaname) ORDER BY table_name))
  {
    RECORD tabledef :=
        [ name :=                   tablerec.table_name
        , primarykey :=             tablerec.primary_key_name
        , cols :=                   RECORD[]
        , obsoletecols :=           RECORD[]
        , indices :=                RECORD[]
        , obsoleteindices :=        RECORD[]
        , legacy_readaccessmgr :=   ""
        , legacy_writeaccessmgr :=  ""
        , parentlinkcolumn :=       ""
        ];

    IF (schemainfo.schema_name = "system" AND tablerec.table_name IN [ "fs_objects", "sites" ])
      tabledef.legacy_writeaccessmgr := "WEBHARE";

    RECORD ARRAY columns :=
        SELECT *
          FROM GetColumns(trans, schemaname, tablerec.table_name)
      ORDER BY column_name = tablerec.primary_key_name DESC, column_name;

    FOREVERY(RECORD col FROM columns)
    {
      RECORD coldef :=
          [ name :=                     col.column_name
          , dbtype :=                   ToUppercase(col.data_type)
          , defval :=                   ""
          , internalcolumnname :=       ""
          , isunique :=                 col.is_unique
          , nullable :=                 FALSE
          , noupdate :=                 FALSE
          , ondelete :=                 ""
          , references_schema :=        ""
          , references_table :=         ""
          ];

      SWITCH (ToLowercase(coldef.dbtype))
      {
        CASE "bool"           { coldef.dbtype := "BOOLEAN"; }
        CASE "int4"           { coldef.dbtype := "INTEGER"; }
        CASE "int8"
        {
          coldef.dbtype := "INTEGER64";
          IF (coldef.name = tablerec.primary_key_name OR col.referenced_table_name != "")
            coldef.dbtype := "__LONGKEY";
        }
        CASE "float8"         { coldef.dbtype := "FLOAT"; }
        CASE "timestamp"      { coldef.dbtype := "DATETIME"; }
        CASE "numeric"        { coldef.dbtype := "MONEY"; }
        CASE "webhare_blob"   { coldef.dbtype := "BLOB"; }
        DEFAULT
        {
          IF (ToLowercase(coldef.dbtype) LIKE "varchar(*")
          {
            coldef.dbtype := "VARCHAR";
            col.data_type := "varchar";
          }
        }
      }

      IF (col.referenced_table_name!="" AND col.data_type != "webhare_blob")
      {
        coldef.references_schema := col.referenced_table_schema;
        coldef.references_table := col.referenced_table_name;
        coldef.ondelete := col.on_delete = "no action" ? "" : col.on_delete;
      }

      IF (col.column_name != tablerec.primary_key_name)
      {
        coldef.isunique := col.is_unique;
        coldef.nullable := (col.referenced_table_schema != "" ? col.is_nullable : col.check_expression = "") AND NOT col.is_unique;
      }

      INTEGER autonumberstart;
      IF (col.column_default != "")
      {
        STRING encoded_defval;
        BOOLEAN is_null_default;
        SWITCH (col.data_type)
        {
          CASE "bool"
          {
            IF (ToLowercase(col.column_default) = "true")
              encoded_defval := ToUppercase(col.column_default);
            ELSE
              is_null_default := ToLowercase(col.column_default) = "false";
          }
          CASE "int4", "int8", "float8", "numeric"
          {
            IF (ToInteger64(col.column_default, 0) != 0)
              encoded_defval := col.column_default;
            ELSE
            {
              is_null_default := col.column_default = "0" OR col.column_default LIKE "nextval(*" OR col.column_default LIKE "*.webhare_autonrs_*";

              RECORD ARRAY match := sequence_generator->Exec(col.column_default);
              IF (RecordExists(match))
              {
                STRING sequencename := match[1].value;
                IF (sequencename = "")
                {
                  // Assume that column_default is escaped so that regclass cast can parse it when encoded as string literal
                  sequencename := `${PostgresqlEscapeLiteral(Substitute(match[2].value, ".webhare_autonrs_", ".webhare_seq_"))}::regclass`;
                }

                RECORD seq := trans->__ExecSQL(`SELECT seqrelid, seqstart FROM pg_catalog.pg_sequence WHERE seqrelid = ${sequencename}`);
                autonumberstart := RecordExists(seq) ? INTEGER(seq.seqstart) : 0;
              }
            }
          }
          CASE "varchar"
          {
            IF (col.column_default = `''::text`)
              is_null_default := TRUE;
            ELSE IF (col.column_default LIKE `'*'::text`)
              encoded_defval := Left(col.column_default, LENGTH(col.column_default) - 6);
          }
          CASE "bytea"
          {
            IF (col.column_default = `'\\x'::bytea`)
              is_null_default := TRUE;
            ELSE IF (col.column_default LIKE `'*'::bytea`)
              encoded_defval := Left(col.column_default, LENGTH(col.column_default) - 7);
          }
          CASE "timestamp"
          {
            IF (col.column_default = `'-infinity'::timestamp without time zone`)
              is_null_default := TRUE;
          }
        }

        IF (encoded_defval != "")
          coldef.defval := encoded_defval;
        ELSE IF (NOT is_null_default)
          ABORT(`Do not support default value '${EncodeValue(col.column_default)}' for type '${col.data_type}'`);
      }

      IF (coldef.dbtype = "VARCHAR")
        INSERT CELL maxlength := col.character_maximum_length INTO coldef;
      IF (coldef.dbtype IN [ "INTEGER", "__LONGKEY" ])
        INSERT CELL autonumberstart := autonumberstart INTO coldef;

      INSERT coldef INTO tabledef.cols AT END;
    }

    RECORD ARRAY current_indices :=
        SELECT *
             , is_implicit :=   index_name NOT LIKE `${tabledef.name}_wh_*`
          FROM GetIndices(trans) AS indices
         WHERE table_schema = schemadef.name
           AND table_name = tabledef.name
           AND (options.withimplicitindices ? TRUE : index_name LIKE `${tabledef.name}_wh_*`)
           ;

    FOREVERY (RECORD ind FROM current_indices)
    {
      RECORD indexdef :=
          [ name :=           ind.is_implicit ? ind.index_name : SubString(ind.index_name, LENGTH(`${tabledef.name}_wh_`))
          , is_implicit :=    ind.is_implicit
          , is_unique :=      ind.indisunique
          , is_uppercase :=   FALSE
          , cols :=           RECORD[]
          ];

      INTEGER exprpos;

      FOREVERY (RECORD col FROM ind.cols)
      {
        IF (col.attnum != 0)
          INSERT [ name := col.attname, len := 0 ] INTO indexdef.cols AT END;
        ELSE
        {
          STRING expr := ParsePostgreSQLExpressionList(ind.indexprs)[exprpos];
          exprpos := exprpos + 1;

          // Assumed that the first )::text is after the column name, see GetIndexColumnExpression
          IF (expr NOT LIKE `*(*)::text*`)
            THROW NEW Exception(`Could not parse index expression '${expr}'`);

          INTEGER postfixpos := SearchSubString(expr, ")::text");
          INTEGER namestart := SearchLastSubString(expr, "(", postfixpos) + 1;
          STRING name := SubString(expr, namestart, postfixpos - namestart);
          IF (name LIKE `"*"`)
            name := Substring(name, 1, LENGTH(name) - 1);

          INSERT CELL[ name, len := 0 ] INTO indexdef.cols AT END;
          indexdef.is_uppercase := expr LIKE "upper(*)" OR expr LIKE "*(upper(*)";
        }
      }

      INSERT indexdef INTO tabledef.indices AT END;
    }

    INSERT tabledef INTO schemadef.tables AT END;
  }

  RETURN schemadef;
}

RECORD FUNCTION DecodePostgreSQLWHLogInfo(STRING logline)
{
  RECORD retval :=
      [ debuginfo :=        ""
      , debuginfohint :=    ""
      , debuginfotrace :=   RECORD[]
      ];

  OBJECT r := NEW Regex("^([^#]*)#([0-9]*)#([0-9]*)\\(([^)]*)\\)$");

  SWITCH (Left(logline, 1))
  {
    CASE "t"
    {
      STRING ARRAY parts := Tokenize(SubString(logline, 2, LENGTH(logline) - 3), ",");
      retval.debuginfo := (
          SELECT AS STRING uri
            FROM ToRecordArray(parts, "uri")
           WHERE uri != "mod::system/lib/database.whlib"
             AND uri NOT LIKE "wh::dbase/*"
             AND uri NOT LIKE "wh::internal/trans*"
             ) ?? parts[0];
      retval.debuginfohint := "Stack trace:\n" || Detokenize(parts, "\n");
      FOREVERY (STRING p FROM parts)
      {
        RECORD ARRAY matches := r->Exec(p);
        IF (RecordExists(matches))
        {
          INSERT
              [ filename :=     matches[1].value
              , line :=         ToInteger(matches[2].value, 1)
              , col :=          ToInteger(matches[3].value, 1)
              , func :=         matches[4].value
              ] INTO retval.debuginfotrace AT END;
        }
      }
    }
  }

  RETURN retval;
}


PUBLIC RECORD FUNCTION GetDatabaseMonitorInfo(OBJECT trans)
{
  SCHEMA catalog LIKE postgresql_pg_catalog;
  catalog := BindTransactionToSchema(trans->id, "pg_catalog");

  RECORD ARRAY translist := trans->__ExecSQL("SELECT * FROM pg_stat_activity ORDER BY pid");

  FOREVERY (RECORD transrec FROM translist)
  {
    STRING debuginfotxt;
    IF (transrec.query LIKE `/?whlog:*`)
    {
      INTEGER pos := SearchSubString(transrec.query, "*/");
      debuginfotxt := SubString(transrec.query, 8, pos - 8);
      transrec.query := SubString(transrec.query, pos + 2);
    }
    translist[#transrec] := CELL[ ...transrec, ...DecodePostgreSQLWHLogInfo(debuginfotxt) ];
  }

  RECORD ARRAY alllocks :=
        SELECT TEMPORARY hash := EncodeUFS(GetMD5Hash(EncodeHSON(CELL[ locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid ])))
             , *
             , hash :=      hash
             , rowkey :=    `${pid},${hash}`
          FROM catalog.pg_locks
      ORDER BY hash;

  STRING ARRAY notgranted_hashes := SELECT AS STRING ARRAY DISTINCT hash FROM alllocks WHERE NOT granted ORDER BY hash;

  RECORD ARRAY displaylocks :=
      SELECT *
        FROM alllocks
       WHERE hash IN notgranted_hashes;

  RECORD trans_default :=
      [ usename := ""
      , application_name := ""
      , backend_start :=    DEFAULT DATETIME
      , query_start :=      DEFAULT DATETIME
      , xact_start :=       DEFAULT DATETIME
      , state :=            ""
      , wait_event_type :=  ""
      , query :=            ""
      , debuginfo :=        ""
      , debuginfohint :=    ""
      , debuginfotrace :=   RECORD[]
      ];

  displaylocks := JoinArrays(displaylocks, "pid", translist, trans_default);

  RECORD ARRAY notgranted :=
      SELECT *
        FROM displaylocks
       WHERE NOT granted
         AND hash IN notgranted_hashes;

  RECORD ARRAY blockinglocks :=
      SELECT *
        FROM displaylocks
       WHERE granted
         AND hash IN notgranted_hashes;

  RECORD ARRAY interesting_tuples :=
      SELECT *
        FROM alllocks
       WHERE locktype = "tuple"
         AND pid IN (SELECT AS INTEGER ARRAY pid FROM notgranted)
    ORDER BY pid;

  RECORD ARRAY tupletables :=
      SELECT relation :=    pg_class.oid
           , tablename :=   `${nspname}.${relname}`
        FROM catalog.pg_class
           , catalog.pg_namespace
       WHERE relnamespace = pg_namespace.oid
         AND pg_class.oid IN (SELECT AS INTEGER ARRAY relation FROM interesting_tuples)
    ORDER BY pg_class.oid;

  interesting_tuples := JoinArrays(interesting_tuples, "relation", tupletables, [ tablename := "" ]);

  FOREVERY (RECORD rec FROM notgranted)
  {
    RECORD ARRAY tuples := RecordRange(interesting_tuples, rec, [ "PID" ]);
    STRING tables := Detokenize(
        (SELECT AS STRING ARRAY DISTINCT tablename
           FROM tuples
       ORDER BY tablename), ", ");
    INSERT CELL tuples := tuples INTO notgranted[#rec];
    INSERT CELL tables := tables INTO notgranted[#rec];
  }

  blockinglocks :=
      SELECT *
           , waiters :=   RecordRange(notgranted, blockinglocks, [ "HASH" ])
        FROM blockinglocks;

  RETURN CELL
      [ translist
      , blockinglocks
      , ownpid :=       trans->backendpid
      ];
}
