<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/stringparser.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";

STRING ARRAY FUNCTION ParseCmdLine(STRING cmdline)
{
  OBJECT parser := NEW StringParser(TrimWhitespace(cmdline));

  STRING ARRAY args;
  IF (parser->eof)
    RETURN args;

  STRING arg;
  WHILE (TRUE)
  {
    arg := arg || parser->ParseWhileNotInSet(' "');
    IF (parser->current = "" OR parser->current = " ")
    {
      IF (arg LIKE '"*"')
        arg := SubString(arg, 1, LENGTH(arg) - 2);

      INSERT arg INTO args AT END;
      IF (parser->eof)
        BREAK;

      arg := "";
      parser->ParseWhileInSet(" ");
      CONTINUE;
    }
    arg := arg || parser->ParseN(1);
    WHILE (NOT parser->eof AND parser->current != '"')
    {
      arg := arg || parser->ParseWhileNotInSet('\\"');
      IF (parser->current = '\\')
      {
        parser->Next();
        arg := arg || parser->ParseN(1);
      }
    }
    arg := arg || parser->ParseN(1);
  }
  RETURN args;
}

RECORD ARRAY FUNCTION GetModuleApps()
{
  RECORD ARRAY apps;
  RECORD ARRAY nodes := GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "apprunnerconfig");

  FOREVERY (RECORD node FROM nodes)
  {
    STRING library := node.node->GetAttribute("library");
    STRING func := node.node->GetAttribute("configfunction");

    IF(library = "")
    {
      func := MakeAbsoluteResourcePath(node.resource, func);
    }
    ELSE
    {
      library := library LIKE "*::*" ? library : MergePath("mod::" || node.module || "/lib/", library);
      func := library || "#" || func;
    }

    RECORD ARRAY scripts;
    TRY
    {
      // FIXME: the contents of the return should be checked within the job...
      scripts := CallFunctionFromJob(func);

      FOREVERY (RECORD script FROM scripts)
      {
        STRING ARRAY args := CellExists(script,"args") ? script.args : ParseCmdLine(script.cmdline);
        IF (LENGTH(args) = 0)
        {
          PRINT("Service " || script.name || " from module " || node.module || " has an wrongly formatted command line\n");
          CONTINUE;
        }

        STRING ARRAY databasemodes := CellExists(script, "databasemodes")
            ? script.databasemodes
            : [ "readonly", "online" ];

        IF ("readonly" NOT IN databasemodes AND NOT IsDatabaseWritable())
          CONTINUE;

        INSERT [ name := script.name
               , app := args[0]
               , args := ArraySlice(args,1)
               , runatsoftreset   := CellExists(script, "RUNATSOFTRESET") AND script.runatsoftreset
               , module := node.module
               ] INTO apps AT END;
      }
    }
    CATCH (OBJECT e)
    {
      PRINT("Could not get apprunner config from module " || node.module || ", lib " || library || " func " || func || "\n");
      LogHarescriptException(e);
    }
  }

  LogDebug("system:apprunner", SELECT name FROM apps ORDER BY name);

  RETURN apps;
}

PUBLIC RECORD ARRAY FUNCTION ListExpectedApps()
{
  RECORD ARRAY apps := GetModuleApps();
  UPDATE apps SET app := GetInstallationRoot() || "bin/" || app WHERE SearchSubString(app, "/") = -1;
  RETURN apps;
}

PUBLIC RECORD ARRAY FUNCTION ListRunningServices()
{
  OBJECT link := WaitForPromise(OpenWebHareService("system:apprunner"));
  RECORD ARRAY apprunner_services :=
      SELECT *
           , run :=               runatsoftreset ? "softreset" : "always"
           , owner :=             "system:apprunner"
        FROM WaitForPromise(link->GetReport()).report;
  link->CloseService();

  OBJECT smservice := WaitForPromise(OpenWebhareService("platform:servicemanager", [ timeout := 5000, notondemand := TRUE ]));
  RECORD ARRAY servicemanager_services :=
      SELECT name
           , enabled :=           TRUE
           , running :=           isrunning
           , runatsoftreset :=    FALSE
           , run
           , since :=             startedsince
           , lasterror :=         lastlogtext
           , regkey :=            ""
           , owner :=             "platform:servicemanager"
           , pid
        FROM EnforceStructure(
          [ [ startedsince :=     DEFAULT DATETIME
            , pid :=              -1
            ]
          ], WaitForPromise(smservice->getWebHareState()).availableservices);
  smservice->CloseService();

  RETURN apprunner_services CONCAT servicemanager_services;
}

PUBLIC OBJECTTYPE ServicesCheck EXTEND CustomCheckBase
<
  UPDATE PUBLIC RECORD ARRAY FUNCTION GetIssueList()
  {
    RECORD ARRAY deadservices := SELECT * FROM ListRunningServices() WHERE running = FALSE AND enabled = TRUE AND run != "always";
    RETURN
        SELECT msg := `:Service '${name}' is not running`
             , jumpto := [ app := "system:dashboard", panel := "system:servicemanager", service := name ]
          FROM deadservices;
  }
>;
