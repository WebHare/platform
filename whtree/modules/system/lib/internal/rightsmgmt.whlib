<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::dbase/dynquery.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::adhoccache.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/userrights/rightsparser.whlib";
LOADLIB "mod::system/lib/internal/userrights/dbmgmt.whlib";


/*  Rights management library, version 2.

    How rights work:

    - Rights have two modes, global and object.
      Object rights kan be granted for all objects (id = 0) and for specific objects.
      The id-mapping is custom per objecttype, and refers to the mapped table, specified
      in the module definitions.

    - Rights can be granted to users and to roles.
      Roles can be granted to users and to roles. Rights cannot be granted to units.

    The rights management works by splitting off a full rights weblet. All management
    functions are run by the weblet, so they can be run by less-privileged users.

    The grantor is taken from the primary transaction, or can be set by
    RequestWebletlessRightsManagement or InitializeRightsWeblet. Set as user 1
    (sysop) when FULLDB right is granted and no primary transaction is present.

    User id 1 is always sysop, used as shortcut in UserHasRight and UserHasRightOn.
    This shortcut is needed for startup! User creation needs to query rights
    for unitmgmt, and when sysop is created the sysop record ain't present yet.
*/

// FIXME: remove all references to allowobjref, replace by isglobal
// FIXME: implement right groups? (maybe just in module mgmt)
// FIXME: rename fullname naar rightname

// -----------------------------------------------------------------------------
//
// Global variables and such
//

/** Cache for rights records
    @cell 0 Full name of the right ('module:right')
    @cell right Id of the right
    @cell name Name of the right within the module
    @cell fullname Fully qualified right name
    @cell tablename Table this object types refers to ("" for global rights)
    @cell storagetable Table the grants are stored in
    @cell primarykey Primary key of the table this right refers to
    @cell parentfield Parent field of the table this right refers to
    @cell allowobjref Whether this right is any object-type rgith
*/
RECORD ARRAY rights_cache;

/** Cache for the rights id->name mapping
    @cell 0 Id of the right
    @cell name Full name of the right (in the form 'module:right')
*/
RECORD ARRAY rights_id_cache;

/// Cache for implied-bys
RECORD ARRAY impliedbyes_cache;

/// Cache for objecttypes
RECORD ARRAY objecttypes_cache;

PUBLIC MACRO __ResetRightsCaches() //tests require this. but can we avoid the need for our 'own' cache, or at least be smarter in flushing like whfstypes can do?
{
  rights_cache := RECORD[];
  rights_id_cache := RECORD[];
  impliedbyes_cache := RECORD[];
  objecttypes_cache := RECORD[];
}

/** Current (authenticated) user.
    The user will be able to modify this record and see all rights for everybody,
    but won't be able to access the copy in the weblet, which is used to change
    rights/roles/users (and to verify the rights to do so)
*/
//OBJECT cache_current_user;

/** Type record for which a describer is being built
*/
RECORD current_type_rec;

RECORD ARRAY FUNCTION GetRightsWithTables()
{
  RECORD mot := GetModuleObjectTypes();
  RECORD ARRAY objtypes := SELECT * FROM mot.objecttypes ORDER BY name;
  RECORD ARRAY rights := SELECT TEMPORARY pos := RecordLowerBound(VAR objtypes, CELL[name := objtype ?? "system:#global"],["name"])
                              , rights.*
                              , objtypeinfo := pos.found ? objtypes[pos.position] : DEFAULT RECORD
                           FROM mot.rights;
  rights := SELECT *
                 , storagetable := objtypeinfo.storagetable
                 , tablename := objtypeinfo.tablename
                 , objecttypename := objtypeinfo.name
                 , DELETE objtypeinfo
              FROM rights
             WHERE RecordExists(objtypeinfo);
  RETURN rights;
}

// -----------------------------------------------------------------------------
//
// Public objecttypes
//

/** Objecttype for use in object describers
    @topic modules/rights
    @public
    @loadlib mod::system/lib/userrights.whlib
*/
PUBLIC OBJECTTYPE ObjectTypeDescriber
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Record describing the type
  RECORD pvt_typerec;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /// List of names of rights that use this objecttype (STRING ARRAY)
  PROPERTY relevant_rights(PVT_GetRightsList, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  /// Constructor
  MACRO NEW()
  {
    this->pvt_typerec := current_type_rec;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING ARRAY FUNCTION PVT_GetRightsList()
  {
    RETURN SELECT AS STRING ARRAY fullname FROM this->pvt_typerec.rights;
  }

  // ---------------------------------------------------------------------------
  //
  // Public interface
  //

  /** Describe an object, no checking of visibility needed (already done)
      @param id of object
      @return Description of object, or DEFAULT RECORD when it does not exist.
      @cell return.name Local name of this object
      @cell return.icon Name of icon for this object
      @cell return.wrdschemaid Mapping to wrd schema (optional)
  */
  PUBLIC RECORD FUNCTION DescribeObject(INTEGER id)
  {
    RETURN
        [ name := "object #" || id
        , icon := ""
        ];
  }


  /** Returns the root visible objects. For presentation purposes only.
      @param user to calculate the visibility
      @return List of visible root objects, DEFAULT INTEGER ARRAY
          if object does not exist or no children visible
  */
  PUBLIC INTEGER ARRAY FUNCTION GetRootObjects(OBJECT user)
  {
    RETURN GetRootObjectsForRights(this->relevant_rights, user);
  }


  /** Return the children objects of a object. For presentation purposes only.
      @param obj Parent object
  */
  PUBLIC UPDATE INTEGER ARRAY FUNCTION GetObjectChildren(INTEGER obj, OBJECT user)
  {
    IF (this->pvt_typerec.parentfield = "" AND obj != 0)
      RETURN DEFAULT INTEGER ARRAY;

    STRING objecttypename := this->pvt_typerec.objecttypename;

    RECORD typedata := GetObjectTypeDataByNameInternal(objecttypename);

    IF (this->pvt_typerec.parentfield = "" AND obj != 0)
      RETURN DEFAULT INTEGER ARRAY;

    INTEGER trans := GetBindingFromSchema(system_internal).transaction;

    OBJECT query := NEW DynamicQuery;
    query->AddTable("query", trans, this->pvt_typerec.tablename, [ STRING(this->pvt_typerec.primarykey) ]);
    IF (this->pvt_typerec.parentfield != "")
      query->AddConstraint("query." || this->pvt_typerec.parentfield, "=", obj);
    RECORD ARRAY result := query->Execute();

    RETURN
        SELECT AS INTEGER ARRAY GetCell(result.query, this->pvt_typerec.primarykey)
          FROM result;
  }


  /** Returns if a specific object is visible for a user in the rights manager
      @param id Id of object to test
      @param user User to check visibility for
      @return Whether this object is visible for this object
  */
  PUBLIC BOOLEAN FUNCTION IsObjectVisibleForUser(INTEGER id, OBJECT user)
  {
    FOREVERY (STRING right FROM this->relevant_rights)
      IF (user->HasRightOn(right, id))
        RETURN TRUE;

    RETURN FALSE;
  }
>;


// -----------------------------------------------------------------------------
//
// (Cached) metadata info functions
//

/** Looks up a right, throws on any error.
    @return Returns right data
    @cell return.rightid Id of the right
    @cell return.name Name of this right (within the module)
    @cell return.fullname Fully qualified right name
    @cell return.tablename Table this right refers to
    @cell return.storagetable Name (with schema) of the rights table
    @cell return.allowobjref Whether this right refers to objects
*/
PUBLIC RECORD FUNCTION GetRightByNameInternal(STRING rightname)
{
  rightname := ToLowercase(rightname);
  INTEGER pos := __HS_SQL_GetGroupPosition(rights_cache, [ "0" := rightname ]);
  IF (pos >= 0)
    RETURN rights_cache[pos];

  RECORD rec;
  RECORD mot := GetModuleObjectTypes();
  RECORD rightinfo := SELECT * FROM mot.rights WHERE name = VAR rightname;
  IF (NOT RecordExists(rightinfo))
    THROW NEW Exception(`Right '${rightname}' does not exist or its module isn't initialized yet`);

  //TODO should we be less inconsistent whether objtype is "" or "system:#global" for global rights?
  RECORD objtype := SELECT * FROM mot.objecttypes WHERE name = (rightinfo.objtype ?? "system:#global");
  IF (NOT RecordExists(objtype))
    THROW NEW Exception(`Objecttype '${rightinfo.objtype}' (referred from right '${rightname}') does not exist`);

  rec := [ "0"                := rightname
         , fullname           := rightname
         , rightid            := rightinfo.id
         , modulename         := Tokenize(rightname,':')[0]
         , objecttypename     := objtype.name ?? "system:#global"
         , tablename          := objtype.tablename
         , storagetable       := objtype.storagetable
         , primarykey         := ToLowercase(objtype.primarykey)
         , parentfield        := ToLowercase(objtype.parentfield)
         , allowobjref        := objtype.tablename != ""
         , isglobal           := objtype.tablename = ""
         ];

  INSERT rec INTO rights_cache AT -pos - 1;
  RETURN rec;
}


RECORD FUNCTION GetCachableRightNameById(INTEGER rightid)
{
  STRING fullname :=
    SELECT AS STRING modules.name || ":" || module_rights.name
      FROM system_internal.modules
         , system_internal.module_rights
     WHERE modules.id = module_rights.module
       AND module_rights.id = rightid;

  IF (fullname = "")
    THROW NEW Exception("Right #"||rightid||" does not exist");

  RETURN [ value := fullname
         , eventmasks := ["system:config.rights"]
         ];
}

/** Returns a right from it's id
    @param rightid Id of the right
    @return Full name of the right, "" if it doesn't exist
*/
RECORD FUNCTION GetRightById(INTEGER rightid)
{
  INTEGER id_pos := __HS_SQL_GetGroupPosition(rights_id_cache, [ "0" := rightid ]);
  IF (id_pos >= 0)
    RETURN GetRightByNameInternal(rights_id_cache[id_pos].name);

  STRING fullname := GetAdhocCached([ type := "namebyid", rightid := rightid ], PTR GetCachableRightNameById(rightid));

  INSERT [ "0" := rightid, name := fullname ] INTO rights_id_cache AT -id_pos - 1;
  RETURN GetRightByNameInternal(fullname);
}


RECORD FUNCTION GetCachableImpliedBysById(INTEGER rightid)
{
  RECORD ARRAY impliedbys :=
      SELECT impliedby
           , fieldname
        FROM system_internal.module_impliedbys
       WHERE COLUMN right = rightid;

  RECORD ARRAY results;
  FOREVERY (RECORD rec FROM impliedbys)
  {
    RECORD rightdata := GetRightById(rec.impliedby);
    INSERT CELL fieldname := rec.fieldname INTO rightdata;

    INSERT rightdata INTO results AT END;
  }

  RETURN [ ttl := 5 * 60 * 1000
         , value := results
         , eventmasks := ["system:softreset"]
         ];
}

/** Returns list of impliedbys
    @param rightid Id of right for which the implies must be checked
    @return List of impliedbys
    @cell return.rightid Id of right that implies this right
    @cell return.storagetable
    @cell return.tablename
    @cell return.fieldname
    @cell return.objecttypename
*/
PUBLIC RECORD ARRAY FUNCTION GetImpliedBysById(INTEGER rightid)
{
  INTEGER pos := __HS_SQL_GetGroupPosition(impliedbyes_cache, [ "0" := rightid ]);
  IF (pos >= 0)
    RETURN impliedbyes_cache[pos].impliedbys;

  RECORD ARRAY results := GetAdhocCached([ type := "impliedbysbyid", rightid := rightid ], PTR GetCachableImpliedBysById(rightid));

  INSERT
      [ "0" := rightid
      , impliedbys := results
      ] INTO impliedbyes_cache AT -pos - 1;

  RETURN results;
}

/** Returns whether a specific right is global
    @param rightname Name of right to check
    @return Whether the right is a global right (as opposed to a object-right)
*/
PUBLIC BOOLEAN FUNCTION IsRightGlobal(STRING rightname)
{
  RECORD right := GetRightByNameInternal(rightname);
  RETURN NOT right.allowobjref;
}



/** Returns a listing of all rights
    @return List of all rights
    @cell return.modulename Module of this right
    @cell return.rightname Name of the right (prefixed with the name of the module and ':')
    @cell return.tablename Name of the table this right refers to
    @cell return.isglobal Whether the name is global
    @cell return.impliedbys List of rights that imply this right
    @cell return.impliedbys.modulename Module of this right
    @cell return.impliedbys.rightname Name of the right (prefixed with the name of the module and ':')
    @cell return.impliedbys.tablename Name of the table this right refers to
*/
PUBLIC RECORD ARRAY FUNCTION GetListOfRights()
{
  RETURN
      SELECT rightid := id
           , modulename := Tokenize(name,':')[0]
           , rightname  := name
           , tablename
           , objecttypename
           , isglobal := tablename = ""
           , impliedbys :=
               SELECT modulename
                    , rightname  := fullname
                    , tablename
                    , fieldname
                 FROM GetImpliedBysById(id)
        FROM GetRightsWithTables();
}

PUBLIC RECORD ARRAY FUNCTION GetListOfObjectTypes()
{
  RETURN SELECT name
              , module := Tokenize(name,':')[0]
           FROM GetModuleObjectTypes().objecttypes
          WHERE name != "system:#global";
}


/** Get data about a specific objecttype. Throws on error or not found.
    @param type Objecttype (fully qualified with modulename)
    @return Objecttype description
    @cell return.library Library with object describer objecttype
    @cell return.objecttypename Name of the objecttype
    @cell return.objectname Name of object describer objecttype
    @cell return.tablename Table this objecttype works on (empty for global objecttype)
    @cell return.primarykey Primary key of table
    @cell return.parentfield Parent field of table (empty when no parentfield is present)
*/
RECORD FUNCTION GetObjectTypeDataByNameInternal(STRING type)
{
  INTEGER pos := __HS_SQL_GetGroupPosition(objecttypes_cache, [ "0" := type ]);
  IF (pos >= 0)
    RETURN objecttypes_cache[pos];

  INTEGER mpos := SearchSubString(type, ":");
  IF (mpos = -1)
    THROW NEW Exception("Illegal objecttype name, expected a string in the form 'module:objecttype', got '"||type||"'");

  // FIXME: add a cache

  STRING modulename := LEFT(type, mpos);
  STRING objtype := SubString(type, mpos + 1);

  RECORD mot := GetModuleObjectTypes();
  RECORD rightobjtype := SELECT * FROM mot.objecttypes WHERE objecttypes.name = type;
  IF(NOT RecordExists(rightobjtype))
    THROW NEW Exception(`Object type '${type}' does not exist`);

  RECORD rec :=
       CELL[ "0" := type
           , objecttypename := type
           , modulename := modulename
           , rightobjtype.describer
           , rightobjtype.tablename
           , primarykey         := ToLowercase(rightobjtype.primarykey)
           , parentfield        := ToLowercase(rightobjtype.parentfield)
           ];
  IF (NOT RecordExists(rec))
    THROW NEW Exception("Object type '"||type||"' does not exist");

  INTEGER ARRAY rightids :=
      SELECT AS INTEGER ARRAY id
        FROM mot.rights
       WHERE COLUMN objtype = rec.objecttypename;

  RECORD ARRAY rights;
  FOREVERY (INTEGER id FROM rightids)
    INSERT GetRightById(id) INTO rights AT END;

  INSERT CELL rights := rights INTO rec;

  INSERT rec INTO objecttypes_cache AT -pos - 1;
  RETURN rec;
}


// -----------------------------------------------------------------------------
//
// Raw db ops
//



/** Returns the ids of the objects of specific grants of a list of rights to a list of grantees (0 for global rights)
    @param grantees List of grantees to check for
    @param right Id of right to check
    @param tablename Name of dynamic rights table
    @param ignore_object If TRUE,
    @param obj Id of object to check for, 0 for any object
    @param onlywithgrantoption If TRUE, only grants with grant option are returned
*/
INTEGER ARRAY FUNCTION GetSpecificRightsFor(INTEGER ARRAY grantees, INTEGER ARRAY rights, STRING tablename, BOOLEAN ignore_object, INTEGER ARRAY objs, BOOLEAN onlywithgrantoption)
{
  BindStorageTable(tablename);
  INTEGER ARRAY retval :=
      SELECT AS INTEGER ARRAY COLUMN "object"
        FROM rights_table
       WHERE COLUMN grantee IN grantees
         AND COLUMN "right" IN rights
         AND ( ignore_object ? TRUE : COLUMN "object" IN objs )
         AND ( onlywithgrantoption ? withgrantoption : TRUE );

  RETURN retval;
}



/** Returns all grants to any of the listed grantees for a specific right (and optionally object)
    @param grantees List of grantees to check for, pass empty to get data for all grantees
    @param right Id of right to check
    @param tablename Name of dynamic rights table
    @param obj Id of object to check for, 0 for any object
*/
RECORD ARRAY FUNCTION GetSpecificGrantDataFor(INTEGER ARRAY grantees, INTEGER right, STRING tablename, BOOLEAN ignore_object, INTEGER obj)
{
  BindStorageTable(tablename);

  RETURN
    SELECT *
      FROM rights_table
     WHERE (LENGTH(grantees) = 0 ? TRUE : COLUMN grantee IN grantees)
       AND COLUMN "right" = VAR right
       AND ( ignore_object ? TRUE : COLUMN "object" = obj )
   ORDER BY withgrantoption; //ensure that if we have to drop superfluous rights, one with the grantoption persists
}



/** Returns a list of all all grants to any of the listed grantees for a specific right (and optionally object)
    @param right Id of right to check
    @param tablename Name of dynamic rights table
    @param objs Id of objects to check for, DEFAULT INTEGER ARRAY for any object
*/
PUBLIC INTEGER ARRAY FUNCTION GetAllSpecificGranteesFor(INTEGER right, STRING tablename, INTEGER ARRAY objs)
{
  BindStorageTable(tablename);

  RETURN
      SELECT AS INTEGER ARRAY grantee
        FROM rights_table
       WHERE COLUMN "right" = VAR right
         AND (LENGTH(objs) = 0 ? TRUE : COLUMN "object" IN objs)
    GROUP BY grantee;
}




// -----------------------------------------------------------------------------
//
// Somewhat higher-level query stuff.
//

/** Returns the list of all authobjects that give rights to the given list
    of authobjects (the authobjects themselves and all the roles granted to them,
    recursively.
    @param authobjects Authobjects to process
    @return All authobjects that give rights to one or more of the original authobjects.
       Original authobjects are at front.
*/
INTEGER ARRAY FUNCTION ExpandAuthobjectsWithRoleGrants(INTEGER ARRAY authobjects, BOOLEAN recursive)
{
  INTEGER ARRAY grantlist := authobjects;
  WHILE (LENGTH(grantlist) != 0)
  {
    grantlist :=
        SELECT AS INTEGER ARRAY rolegrants.role
          FROM system_internal.rolegrants
             , system_internal.authobjects
         WHERE authobjects.id = rolegrants.role
           AND grantee IN grantlist
           AND authobjects.type = 3 /*role*/
           AND NOT authobjects.deactivated
           AND role NOT IN VAR authobjects;
    authobjects := authobjects CONCAT grantlist;
    IF (NOT recursive)
      BREAK;
  }
  RETURN authobjects;
}


/** Returns the subset of objectids on which the authobjects have specific right on
    @param objecttypedata Objecttype of the rights
    @param rights Rights to check
    @param authobjects Right-giving authobjects. You should have already expanded it with ExpandAuthobjectsWithRoleGrants(authobjects, TRUE)
    @param ignore_obj If true, ignore the list of objectids and returns [0] when the authobjects have right on any of the objects in this right
    @param objectids List of objects to check
    @param onlywithgrantoption Return only those objects which the authobjects have the right to grant on to others
    @return List of objects with rights
*/
INTEGER ARRAY FUNCTION FindObjectsWithRights(RECORD objecttypedata, INTEGER ARRAY rightids, INTEGER ARRAY authobjects, BOOLEAN ignore_obj, INTEGER ARRAY objectids, BOOLEAN onlywithgrantoption)
{
  IF (NOT ignore_obj AND LENGTH(objectids) = 0)
    RETURN DEFAULT INTEGER ARRAY;

  INTEGER ARRAY results;

  // Start the list to check with the current right
  RECORD ARRAY worklist :=
      [ [ rightids :=           rightids
        , storagetable :=       objecttypedata.storagetable
        , tablename :=          objecttypedata.tablename
        , parentfield :=        objecttypedata.parentfield
        , primarykey :=         objecttypedata.primarykey
        , objecttypename :=     objecttypedata.objecttypename
        , objectids :=          objectids
        ]
      ];

  // List of objects with rights we have found
  INTEGER ARRAY have_rights;

  // Iterate over the rights
  FOR(INTEGER iterations := 0; LENGTH(worklist) != 0 AND iterations < 20; iterations := iterations + 1)
  {
    RECORD rec := worklist[0];
    DELETE FROM worklist AT 0;

    RECORD ARRAY impliedbys;

    INTEGER ARRAY objecttype_rightids := rec.rightids;

    FOR (INTEGER i := 0; i < LENGTH(objecttype_rightids); i := i + 1)
    {
      INTEGER rightid := objecttype_rightids[i];

      // Get the impliedbyes of the same objecttype, for to process them immediately
      WHILE (TRUE)
      {
        RECORD ARRAY this_impliedbys := GetImpliedBysById(rightid);
        IF (LENGTH(this_impliedbys) = 1 AND this_impliedbys[0].objecttypename = rec.objecttypename)
        {
          rightid := this_impliedbys[0].rightid;
          IF (rightid IN objecttype_rightids)
            BREAK;
          ELSE
            INSERT rightid INTO objecttype_rightids AT END;
        }
        ELSE
        {
          impliedbys := impliedbys CONCAT this_impliedbys;
          BREAK;
        }
      }
    }

    IF (ignore_obj)
    {
      have_rights := GetSpecificRightsFor(authobjects, objecttype_rightids, rec.storagetable, TRUE, DEFAULT INTEGER ARRAY, onlywithgrantoption);

      IF (LENGTH(have_rights) != 0)
        RETURN have_rights;
    }
    ELSE
    {
      RECORD ARRAY objs :=
          SELECT objectid :=    id
               , children :=    [ INTEGER(id) ] // Only valid when objectid != 0
            FROM ToRecordArray(rec.objectids, "ID");

      INTEGER ARRAY tested_haverights; // INV: 0 NOT IN tested_haverights
      INTEGER ARRAY tested_norights;

      BOOLEAN firstround := TRUE;

      FOR(INTEGER inneriterations := 0; LENGTH(objs) != 0 AND inneriterations < 20; inneriterations := inneriterations + 1)
      {
        // List of [ objectid := X, children := [ XXX ] ] that certainly don't have rights
        RECORD ARRAY no_rights;

        // Filter fresh reparented objects
        IF (LENGTH(tested_norights) != 0 OR LENGTH(tested_haverights) != 0)
        {
          RECORD ARRAY newlist;

          FOREVERY (RECORD objrec FROM objs)
          {
            IF (objrec.objectid IN tested_haverights)
              have_rights := have_rights CONCAT objrec.children;
            ELSE IF (objrec.objectid IN tested_norights)
              INSERT objrec INTO no_rights AT END;
            ELSE
              INSERT objrec INTO newlist AT END;
          }

          IF (LENGTH(newlist) = 0 AND LENGTH(no_rights) = 0)
            BREAK;

          objs := newlist;
        }

        // Get object ids to test
        INTEGER ARRAY test :=
            SELECT AS INTEGER ARRAY objectid
              FROM objs;

        IF (LENGTH(test) != 0)
          test := GetSpecificRightsFor(authobjects, objecttype_rightids, rec.storagetable, FALSE, test, onlywithgrantoption);

        IF (0 IN test) // Right on 0: right on all.
        {
          // Sort and distinct 'm
          RETURN (SELECT AS INTEGER ARRAY DISTINCT id FROM ToRecordArray(objectids, "ID") ORDER BY id);
        }

        FOREVERY (RECORD objrec FROM objs)
        {
          IF (objrec.objectid IN test)
            have_rights := have_rights CONCAT objrec.children;
          ELSE
          {
            INSERT objrec.objectid INTO tested_norights AT END;
            INSERT objrec INTO no_rights AT END;
          }
        }

        tested_haverights := tested_haverights CONCAT test;

        IF (rec.parentfield = "")
        {
          // No parent field: 0 is the parent of all. No rights on 0 -> done.
          IF (0 IN tested_norights)
            BREAK;

          // 0 gives rights to all untested stuff
          objs :=
              [ [ objectid :=   0
                , children :=   DEFAULT INTEGER ARRAY // no need to fill this when testing for 0
                ]
              ];
        }
        ELSE
          objs := GetParentObjects(rec.objecttypename, no_rights).parents;

        firstround := FALSE;
      }
    }

    worklist := worklist CONCAT
        SELECT rightids :=          GroupedValues(rightid)
             , objectids :=         [ 0 ]
             , storagetable :=      Any(storagetable)
             , tablename :=         Any(tablename)
             , parentfield :=       Any(parentfield)
             , primarykey :=        Any(primarykey)
             , objecttypename :=    Any(objecttypename)
          FROM impliedbys
      GROUP BY objecttypename;
  }

  RETURN have_rights;
}

/** Returns all relevant grants for a specific right
    @param authobjects Authobjects to query
    @param rightname Right to check
    @param obj Object to check (0 if not relevant)
    @param get_all If FALSE, stop at first found grant
    @param ignore_inheritance If TRUE this function ignores role grants, impliedbys and parent objects.
    @param onlywithgrantoption If TRUE only grants with grant option are returned
    @return List of found grants
    @cell return.rightid Id of right that grants the user the specific right
    @cell return.objectid Id of object that grant was on
*/
RECORD ARRAY FUNCTION LocateGrantsFor(RECORD rightdata, INTEGER ARRAY authobjects, BOOLEAN ignore_obj, INTEGER objectid, BOOLEAN get_all, BOOLEAN ignore_inheritance, BOOLEAN onlywithgrantoption)
{
  // If we don't ignore inheritance
  IF (NOT ignore_inheritance)
    authobjects := ExpandAuthobjectsWithRoleGrants(authobjects, TRUE);

  // Start the list to check with the current right
  RECORD ARRAY worklist :=
      [ [ rightid :=            rightdata.rightid
        , storagetable :=       rightdata.storagetable
        , tablename :=          rightdata.tablename
        , parentfield :=        rightdata.parentfield
        , primarykey :=         rightdata.primarykey
        , objecttypename :=     rightdata.objecttypename
        , obj :=                objectid
        , fullname :=           rightdata.fullname
        ]
      ];

  RECORD ARRAY results;

  // While there are still rights to check
  WHILE (LENGTH(worklist) != 0)
  {
    RECORD ARRAY new_worklist;
    FOREVERY (RECORD rec FROM worklist)
    {
      // Check a specific right
      INTEGER this_obj := rec.obj;

      // Object loop.
      WHILE (TRUE)
      {
        // Check for all objects, their parent, their parent-parent, etc.
        INTEGER ARRAY object_ids := GetSpecificRightsFor(authobjects, [ INTEGER(rec.rightid) ], rec.storagetable, ignore_obj, [ this_obj ], onlywithgrantoption);
        IF (LENGTH(object_ids) != 0)
        {
          IF(NOT get_all)
          {
            // A grant has been found. If we don't need to find all grants, one will do.
//            PRINT("Found single grant:\n" ||AnyToString(retval, "tree"));
            RETURN [[ rightid       := rec.rightid
                   , objectid      := this_obj
                   ]];
          }

          FOREVERY(INTEGER obj FROM object_ids)
            INSERT [ rightid       := rec.rightid
                   , objectid      := obj
                   ] INTO results AT END;
        }

        // If there are no parents (or objects aren't important at all, or we may not check parents stop the object loop.
        IF (this_obj = 0 OR ignore_obj OR ignore_inheritance)
          BREAK;

        this_obj := GetParentObject(rec.objecttypename, this_obj);
      }

      // No inheritance? Return the results for the original right.
      IF (ignore_inheritance)
        RETURN results;

      // Get the rights that imply this right.
      RECORD ARRAY impliedbys := GetImpliedBysById(rec.rightid);

      FOREVERY (RECORD r FROM impliedbys)
      {
        IF (r.fieldname != "" OR r.tablename != "")
        {
          IF (r.fieldname = "")
          {
            // INV: r.tablename != ""
            IF (r.tablename = rec.tablename)
            {
              // reference to another right on the same object
              INSERT
                  [ rightid :=          r.rightid
                  , storagetable :=     r.storagetable
                  , tablename :=        r.tablename
                  , primarykey :=       r.primarykey
                  , parentfield :=      r.parentfield
                  , objecttypename :=   r.objecttypename
                  , obj :=              rec.obj
                  , fullname :=         r.fullname
                  ] INTO new_worklist AT END;
            }
            ELSE
            {
              // tablenames differ; need fieldname!
              THROW NEW Exception(`Global right '${rec.fullname}' cannot be implied by right '${r."0"}', because the latter refers to objects`);
            }
          }
          ELSE
          {
            /* What should be done:
              INTEGER new_obj :=
                  SELECT AS INTEGER (fieldname)
                    FROM (rec.tablename)
                   WHERE (primary key) = obj;

              INSERT [ rightid := r.id, storagetable := r.storagetable, obj := new_obj ] INTO new_worklist AT END;
            */
            THROW NEW Exception("Rights references with fieldnames are not supported yet");
          }
        }
        ELSE
        {
          // Right we need to check doesn't work on a table -> object id is 0.
          INSERT
              [ rightid :=      r.rightid
              , storagetable := r.storagetable
              , tablename :=    r.tablename
              , obj :=          0
              , primarykey :=   r.primarykey
              , parentfield :=  r.parentfield
              , fullname :=     r.fullname
              ] INTO new_worklist AT END;
        }
      }
    }
    worklist := new_worklist;
  }
//  PRINT("Found grants:\n" ||AnyToString(results, "tree"));
  RETURN results;
}

// -----------------------------------------------------------------------------
//
// Object definitions
//

STATIC OBJECTTYPE AuthObject
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  INTEGER __pvt_authobjectid;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY authobjectid(__pvt_authobjectid, -);

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Returns whether this user has a global right
      @param rightname Name of the right
      @return TRUE if the user has the right, FALSE if not. Throws on error.
      @see HasRightOn, HasRightOnAny
  */
  UPDATE PUBLIC BOOLEAN FUNCTION HasRight(STRING rightname)
  {
    RETURN FALSE;
  }

  /** Returns whether this user has an object-based right on an object.
      @param rightname Name of the right
      @param objectid Id of the object, 0 for a global grant on all objects.
      @return TRUE if the user has the right, FALSE if not. Throws on error.
      @see HasRight, HasRightOnAny
  */
  UPDATE PUBLIC BOOLEAN FUNCTION HasRightOn(STRING rightname, INTEGER objectid)
  {
    RETURN objectid IN this->HasRightOnMultiple(rightname, [ objectid ]);
  }


  /** Returns on which objects from a list this user has an object-based right on
      @param rightname Name of the right
      @param objectids Ids of the object, include 0 for a global grant on all objects.
      @return List of object ids the user has right on
      @see HasRight, HasRightOnAny
  */
  UPDATE PUBLIC INTEGER ARRAY FUNCTION HasRightOnMultiple(STRING rightname, INTEGER ARRAY objectids)
  {
    RETURN DEFAULT INTEGER ARRAY;
  }

  /** Returns whether this user has a right on any object for an object-based right, or, if
      no objects exist at all, whether the user would automatically have that right on newly
      created objects.
      @param rightname Right to query
      @return Whether the user has the queried right on any object (or newly created objects)
      @see HasRight, HasRightOn
  */
  UPDATE PUBLIC BOOLEAN FUNCTION HasRightOnAny(STRING rightname)
  {
    RETURN FALSE;
  }

  /** Return whether the object has the specified role */
  UPDATE PUBLIC BOOLEAN FUNCTION HasRole(INTEGER roleid)
  {
    RETURN FALSE;
  }

  /** @short List accessible root objects for a list of rights
      @long Given a list of rights of one specific objecttype, give the list of objects the user has any right (from the list) on, but not on the parent object.
      @param rights Rights to check. If the user has any of these rights (possibly implied) on an object, it will be returned
      @return The list of accessible object roots. [ 0 ] if the user has rights on all objects.
  */
  PUBLIC INTEGER ARRAY FUNCTION GetRootObjectsForRights(STRING ARRAY rights)
  {
    RETURN GetRootObjectsInDB(rights, this, FALSE, DEFAULT INTEGER ARRAY);
  }

  /** @short List accessible root objects for a list of rights
      @long Given a list of rights of one specific objecttype, give the list of objects the user has any right (from the list) on, but not on the parent object.
      @param rights Rights to check. If the user has any of these rights (possibly implied) on an object, it will be returned
      @return The list of accessible object roots. [ 0 ] if the user has rights on all objects.
  */
  PUBLIC INTEGER ARRAY FUNCTION GetRootObjectsForGrantableRights(STRING ARRAY rights)
  {
    RETURN GetRootObjectsInDB(rights, this, TRUE, DEFAULT INTEGER ARRAY);
  }

>;

/** Base object for querying rights
    This object can be queried if it has a right, and may be granted rights (when overridden)
*/
STATIC OBJECTTYPE RightsObject EXTEND AuthObject
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  BOOLEAN __pvt_supportsrights;


  INTEGER __pvt_rightsobjecttype;

  PUBLIC RECORD __userdataforlogging; //temporary workaround so we can reduce the amount of info passed to UpdateGrant

  INTEGER ARRAY cached_expandedauthobjects;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /** Can rights be granted to this authobject ? (eg it's a user, wrd user, role..>)
  */
  PUBLIC PROPERTY supportsrights(__pvt_supportsrights,-);

  /** Internal for now; don't use
      1: user
      2: unit
      3: role
  */
  PUBLIC PROPERTY __rightsobjecttype(__pvt_rightsobjecttype,-);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(INTEGER type, INTEGER id)
  {
    this->__pvt_rightsobjecttype := type;
    this->__pvt_authobjectid := id;
  }


  /// Returns list of all authobjects
  PUBLIC INTEGER ARRAY FUNCTION __PVT_GetAllAuthObjects()
  {
    RETURN DEFAULT INTEGER ARRAY;
  }

  /// Returns an recursively expanded list of authobjects (includes rolegrants)
  PUBLIC INTEGER ARRAY FUNCTION __PVT_GetExpandedAuthObjects(BOOLEAN resetgrants)
  {
    IF(Length(this->cached_expandedauthobjects)=0 OR resetgrants)
      this->cached_expandedauthobjects := ExpandAuthobjectsWithRoleGrants(this->__PVT_GetAllAuthObjects(), TRUE);

    RETURN this->cached_expandedauthobjects;
  }


  PUBLIC INTEGER FUNCTION __PVT_GetGrantTarget(BOOLEAN for_role)
  {
    THROW NEW Exception("This object cannot be granted to");
  }



  PUBLIC RECORD FUNCTION __PVT_GetExportdata()
  {
    THROW NEW Exception("The function __PVT_GetExportdata must be overridden");
  }



  PUBLIC INTEGER ARRAY FUNCTION __PVT_HasRightOn(RECORD rightdata, OBJECT grantee, BOOLEAN ignore_objectids, INTEGER ARRAY objectids)
  {
    // Add the role grants to the authobjects
    INTEGER ARRAY authobjects := this->__PVT_GetExpandedAuthObjects(FALSE);

    // Get all objects with rights
    RETURN FindObjectsWithRights(rightdata, [ INTEGER(rightdata.rightid) ], authobjects, ignore_objectids, objectids, FALSE);
  }


  // ---------------------------------------------------------------------------
  //
  // Public interface
  //

  /** Return user data for logging purposes
      @return User data for logging purposes
      @cell return.authobject Id of the authobject of this user
      @cell return.when When this data was retrieved
  */
  PUBLIC RECORD FUNCTION GetUserDataForLogging()
  {
    RETURN this->__userdataforlogging ?? CELL[ authobjectid := this->__pvt_authobjectid
                                             , when :=         GetCurrentDatetime()
                                             ];
  }

  UPDATE PUBLIC BOOLEAN FUNCTION HasRole(INTEGER roleid)
  {
    INTEGER ARRAY authobjects := this->__PVT_GetAllAuthObjects();

    RETURN RecordExists(
        SELECT
          FROM system_internal.rolegrants
         WHERE grantee IN authobjects
           AND role = roleid);
  }


  UPDATE PUBLIC BOOLEAN FUNCTION HasRight(STRING rightname)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (right.allowobjref)
      THROW NEW Exception("HasRight can only be used for global rights");

    RETURN 0 IN this->__PVT_HasRightOn(right, this, FALSE, [ 0 ]);
  }


  UPDATE PUBLIC BOOLEAN FUNCTION HasRightOn(STRING rightname, INTEGER objectid)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("HasRightOn can only be used for object rights");

    RETURN objectid IN this->__PVT_HasRightOn(right, this, FALSE, [ objectid ]);
  }


  UPDATE PUBLIC INTEGER ARRAY FUNCTION HasRightOnMultiple(STRING rightname, INTEGER ARRAY objectids)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("HasRightOnMultiple can only be used for object rights");

    RETURN this->__PVT_HasRightOn(right, this, FALSE, objectids);
  }


  UPDATE PUBLIC BOOLEAN FUNCTION HasRightOnAny(STRING rightname)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("HasRightOnAny can only be used for object rights");

    RETURN LENGTH(this->__PVT_HasRightOn(right, this, TRUE, DEFAULT INTEGER ARRAY)) != 0;
  }

  /** Returns whether this authobject has any grantable right
  */
  UPDATE PUBLIC BOOLEAN FUNCTION HasAnyGrantableRight()
  {
    RECORD ARRAY alltables :=
       SELECT rights := GroupedValues(rec)
            , storagetable
         FROM GetRightsWithTables() AS rec
     GROUP BY storagetable;

    INTEGER ARRAY authobjects := this->__PVT_GetExpandedAuthObjects(FALSE);

    RECORD ARRAY results;
    FOREVERY (RECORD tablerights FROM alltables)
    {
      STRING ARRAY nametoks := Tokenize(tablerights.storagetable,'.');
      IF(NOT GetPrimaryWebhareTransactionObject()->ColumnExists(nametoks[0], nametoks[1],"ID"))
        CONTINUE;

      BindStorageTable(tablerights.storagetable);

      IF (RecordExists(
          SELECT FROM rights_table
           WHERE grantee IN authobjects
             AND withgrantoption))
        RETURN TRUE;
    }

    RETURN FALSE;
  }


  /** Returns whether this object still exists in the database
  */
  UPDATE PUBLIC BOOLEAN FUNCTION ExistsInDatabase()
  {
    INTEGER ARRAY expect_ids := this->__PVT_GetAllAuthObjects();
    IF (LENGTH(expect_ids) = 0)
      RETURN FALSE;

    RECORD ARRAY exist_ids :=
        SELECT
          FROM system_internal.authobjects
         WHERE id IN expect_ids;

    RETURN LENGTH(expect_ids) = LENGTH(exist_ids);
  }
>;




STATIC OBJECTTYPE RightsRoleObject EXTEND RightsObject
< // webhare role

/*  INTEGER __pvt_Role;

  PUBLIC PROPERTY Role(__pvt_Role, -);
*/


  UPDATE PUBLIC INTEGER FUNCTION __PVT_GetGrantTarget(BOOLEAN for_role)
  {
    IF (for_role)
      THROW NEW Exception("Roles may not be granted to other roles " || this->__pvt_authobjectid);
    RETURN this->__pvt_authobjectid;
  }



  UPDATE PUBLIC INTEGER ARRAY FUNCTION __PVT_GetAllAuthObjects()
  {
    RETURN [ this->__pvt_authobjectid ];
  }



  MACRO NEW(RECORD userdata)
  : RightsObject(3, userdata.authobjectid)
  {
    IF (userdata.authobjectid = 0)
      THROW NEW Exception("Trying to create a role object with id 0");
    this->__pvt_supportsrights := TRUE;
  }



  PUBLIC UPDATE RECORD FUNCTION __PVT_GetExportdata()
  {
    RETURN
        [ type := "role"
        , authobjectid := this->__pvt_authobjectid
        ];
  }
>;



/** Base user object.
    This object can be queried if it has a right.
*/
STATIC OBJECTTYPE RightsUserObject EXTEND RightsObject
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /// Current user id
  PUBLIC PROPERTY id(__pvt_authobjectid, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  /* Constructor, builds a new rightsuser object
     @param userdata Descriptor for new object
     @cell userdata.authobjectid Id of webhare user
  */
  MACRO NEW(RECORD userdata)
  : RightsObject(1, userdata.authobjectid)
  {
    this->__pvt_supportsrights := TRUE;
  }

  STRING FUNCTION GetName()
  {
    RETURN SELECT AS STRING name FROM system_internal.authobjects WHERE authobjects.id = this->__pvt_authobjectid;
  }

  PUBLIC INTEGER FUNCTION __PVT_GetGrantorAuthobject()
  {
    RETURN this->__pvt_authobjectid;
  }

  UPDATE PUBLIC INTEGER FUNCTION __PVT_GetGrantTarget(BOOLEAN for_role)
  {
    // Currently all grants go to the webhare user
    RETURN this->__pvt_authobjectid;
  }



  UPDATE PUBLIC INTEGER ARRAY FUNCTION __PVT_GetAllAuthObjects()
  {
    RETURN [INTEGER(this->__pvt_authobjectid)];
  }




  PUBLIC UPDATE RECORD FUNCTION __PVT_GetExportdata()
  {
    RETURN
        [ type := "user"
        , authobjectid := this->__pvt_authobjectid
        ];
  }

  /** Grant, update or revoke the specified object right on the specified object to another user. Throws on failure.
      @param action grant/update/revoke. update does not grant a nonexisting right
      @param rightname Right to grant
      @param objectid Object to grant the right on (0 for all objects. always set to 0 for global rights!)
      @param(object #RightsUserObject) grantee User to grant the right to
      @cell(boolean) options.allowselfassignment If TRUE, skip rights validation if this is a self assignment
      @cell(boolean) options.withgrantoption If set, update 'withgrantoption'
      @cell(string) options.comment If set, update the comment
  */
  PUBLIC MACRO UpdateGrant(STRING action, STRING rightname, INTEGER objectid, OBJECT grantee, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ allowselfassignment := FALSE
                               , withgrantoption := FALSE
                               , comment := ""
                               ], options, [ optional := [ "withgrantoption", "comment" ]]);

    IF(action NOT IN ["grant","update","revoke"])
      THROW NEW Exception("The action must be one of 'grant', 'update' or 'revoke'");

    IF (NOT GetPrimary()->IsWorkOpen())
      THROW NEW Exception("This operation requires an explicitly opened transaction");

    // Check if the user has enough rights to grant this right
    RECORD rightdata := GetRightByNameInternal(rightname);
    IF(NOT (options.allowselfassignment AND this->authobjectid = grantee->authobjectid))
    {
      IF (NOT RecordExists(LocateGrantsFor(rightdata, ExpandAuthobjectsWithRoleGrants([ this->__pvt_authobjectid ], TRUE), FALSE, objectid, FALSE, FALSE, TRUE)))
        THROW NEW Exception("The grantor does not have the right to grant this right");
    }

    // Integrity check (objectrights and object)
    IF (NOT rightdata.allowobjref AND objectid != 0)
      THROW NEW Exception("Right '"||rightdata.fullname||"' does not apply to specific objects");

    // Get the grantee for this right
    INTEGER grantee_id := grantee->__PVT_GetAllAuthObjects()[0];
    IF (grantee_id = 0)
      THROW NEW Exception("Invalid grantee");

    // Lookup any existing rights assignment. Implies GetSpecificGrantDataFor
    RECORD ARRAY grants := GetSpecificGrantDataFor([ grantee_id ], rightdata.rightid, rightdata.storagetable, FALSE, objectid);
    IF(Length(grants) = 0 AND action != "grant") //anything to do?
        RETURN; //note that we don't throw on a non-existing update as we originally wouldn't on a non-existing revoke either)

    GetPrimary()->BroadcastOnCommit("system:rights.change", DEFAULT RECORD); //we don't worry yet about the no-op update case

    IF(Length(grants) = 0) //simply adding..
    {
      BOOLEAN withgrantoption := CellExists(options, 'withgrantoption') AND options.withgrantoption;
      STRING comment := CellExists(options, 'comment') ? options.comment : "";
      INSERT INTO rights_table(grantee, grantor, "object", "right", creationdate, withgrantoption, comment, grantordata)
             VALUES(grantee_id, this->authobjectid, objectid, rightdata.rightid, GetCurrentDateTime(), withgrantoption, comment, EncodeHSON(this->GetUserDataForLogging()));
      RETURN;
    }

    IF(action = "revoke") //we are removing a grant
    {
      DELETE FROM rights_table WHERE id IN (SELECT AS INTEGER ARRAY grants.id FROM grants);
      RETURN;
    }

    //If we get here, we're either granting an existing right, or explicitly updating
    IF(Length(grants) > 0) //delete superfluous grants
      DELETE FROM rights_table WHERE id IN ArraySlice((SELECT AS INTEGER ARRAY grants.id FROM grants), 1);

    //updating an existing grant.
    RECORD grantupdate;
    IF(CellExists(options,'comment') AND options.comment != grants[0].comment)
      INSERT CELL comment := options.comment INTO grantupdate;

    IF(CellExists(options,'withgrantoption') AND options.withgrantoption != grants[0].withgrantoption)
    {
      INSERT CELL withgrantoption := options.withgrantoption INTO grantupdate;

      IF(options.withgrantoption) //setting grant option ? then you 'own' this right now!
        INSERT CELL grantordata := EncodeHSON(this->GetUserDataForLogging()) INTO grantupdate;
    }

    IF(RecordExists(grantupdate))
      UPDATE rights_table SET RECORD grantupdate WHERE id = grants[0].id;
  }


  /** Grants the specified global right to another user. Throws on failure.
      @param grantee User object to grant the right to.
      @param rightname Right to grant
      @param allowselfassignment If TRUE, skip rights validation if this is a self assignment
      @see UpdateGrant
      @deprecated Switch to UpdateGrant in WH 4.32+
  */
  PUBLIC MACRO GrantRightTo(STRING rightname, OBJECT grantee, BOOLEAN withgrantoption, BOOLEAN allowselfassignment DEFAULTSTO FALSE, STRING comment DEFAULTSTO "", RECORD grantoruserdata DEFAULTSTO DEFAULT RECORD)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (right.allowobjref)
      THROW NEW Exception("GrantRightTo can only be used for global rights");

    IF(RecordExists(grantoruserdata))
      THROW NEW Exception("GrantRightTo(On) no longer allows explicit grantoruserdata to be specified");

    this->UpdateGrant("grant", rightname, 0, grantee, CELL[ withgrantoption
                                                          , comment
                                                          , allowselfassignment
                                                          ]);
  }


  /** Grants the specified object right on the specified object to another user. Throws on failure.
      @param grantee User to grant the right to
      @param rightname Right to grant
      @param objectid Object to grant the right on (0 for all objects)
      @param allowselfassignment If TRUE, skip rights validation if this is a self assignment
      @see UpdateGrant
      @deprecated Switch to UpdateGrant in WH 4.32+
  */
  PUBLIC MACRO GrantRightToOn(STRING rightname, OBJECT grantee, INTEGER objectid, BOOLEAN withgrantoption, BOOLEAN allowselfassignment DEFAULTSTO FALSE, STRING comment DEFAULTSTO "", RECORD grantoruserdata DEFAULTSTO DEFAULT RECORD)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("GrantRightToOn can only be used for object rights");

    IF(RecordExists(grantoruserdata))
      THROW NEW Exception("GrantRightTo(On) no longer allows explicit grantoruserdata to be specified");

    this->UpdateGrant("grant", rightname, objectid, grantee, CELL[ withgrantoption
                                                                 , comment
                                                                 , allowselfassignment
                                                                 ]);
  }


  /** Revokes the specified global right from another user. Throws on failure.
      @param grantee User object to revoke the right from.
      @param rightname Right to revoke
      @see UpdateGrant
      @deprecated Switch to UpdateGrant in WH 4.32+
  */
  PUBLIC MACRO RevokeRightFrom(STRING rightname, OBJECT grantee, BOOLEAN onlyremovegrantoption, BOOLEAN allowselfassignment DEFAULTSTO FALSE)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (right.allowobjref)
      THROW NEW Exception("RevokeRightFrom can only be used for global rights");

    this->UpdateGrant(onlyremovegrantoption ? "update" : "revoke", rightname, 0, grantee, CELL[ withgrantoption := FALSE
                                                                                              , allowselfassignment
                                                                                              ]);
  }


  /** Revokes the specified object right on the specified object from another user. Throws on failure.
      @param grantee User to revoke the right from
      @param rightname Right to revoke
      @param objectid Object to revoke the right on (0 for a grant on all objects). Revoking the right on objectid 0
          will only revoke a global grant, not grants on individual objects.
      @see UpdateGrant
      @deprecated Switch to UpdateGrant in WH 4.32+
  */
  PUBLIC MACRO RevokeRightFromOn(STRING rightname, OBJECT grantee, INTEGER objectid, BOOLEAN onlyremovegrantoption, BOOLEAN allowselfassignment DEFAULTSTO FALSE)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("RevokeRightFromOn can only be used for object rights");

    this->UpdateGrant(onlyremovegrantoption ? "update" : "revoke", rightname, objectid, grantee, CELL[ withgrantoption := FALSE
                                                                                                     , allowselfassignment
                                                                                                     ]);
  }

  /** Grant, update or revoke the a role. Throws on failure.
      @param action grant/update/revoke. update does not grant an ungranted role
      @param roleid Authobjectid of the role to grant
      @param(object #RightsUserObject) grantee User to grant the right to
      @cell(string) options.comment If set, update the comment
  */
  PUBLIC MACRO UpdateRoleGrant(STRING action, INTEGER roleid, OBJECT grantee, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ comment := ""
                               ], options, [ optional := [ "comment" ]]);

    IF(action NOT IN ["grant","update","revoke"])
      THROW NEW Exception("The action must be one of 'grant', 'update' or 'revoke'");

    IF (NOT GetPrimary()->IsWorkOpen())
      THROW NEW Exception("This operation requires an explicitly opened transaction");

    IF (NOT this->HasRightOn("system:manageroles", roleid))
      THROW NEW Exception("You do not have enough rights to grant this role");

    INTEGER grantee_id := grantee->__PVT_GetAllAuthObjects()[0];
    IF (grantee_id = 0)
      THROW NEW Exception("Invalid grantee");

    RECORD rolerec := SELECT * FROM system_internal.authobjects WHERE id = roleid AND type = 3;
    IF (NOT RecordExists(rolerec))
      THROW NEW Exception("The granted role does not exist");

    // Lookup any existing grants
    RECORD ARRAY grants := SELECT id, comment FROM system_internal.rolegrants WHERE COLUMN grantee = grantee_id AND role = roleid;
    IF(Length(grants) = 0 AND action != "grant") //anything to do?
        RETURN; //note that we don't throw on a non-existing update as we originally wouldn't on a non-existing revoke either)

    GetPrimary()->BroadcastOnCommit("system:rights.change", DEFAULT RECORD); //we don't worry yet about the no-op update case

    IF(Length(grants) = 0) //simply adding..
    {
      STRING comment := CellExists(options, 'comment') ? options.comment : "";
      INSERT INTO system_internal.rolegrants(role, grantee, creationdate, grantor, comment, grantordata)
           VALUES (roleid, grantee_Id, GetCurrentDateTime(), this->authobjectid, comment, EncodeHSON(this->GetUserDataForLogging()));

      grantee->__PVT_GetExpandedAuthObjects(TRUE);
      RETURN;
    }

    IF(action = "revoke") //we are removing a role grant
    {
      DELETE FROM system_internal.rolegrants WHERE id IN (SELECT AS INTEGER ARRAY grants.id FROM grants);
      grantee->__PVT_GetExpandedAuthObjects(TRUE);
      RETURN;
    }

    //If we get here, we're either granting an already existing role, or explicitly updating
    IF(Length(grants) > 0) //delete superfluous grants
      DELETE FROM system_internal.rolegrants WHERE id IN ArraySlice((SELECT AS INTEGER ARRAY grants.id FROM grants), 1);

    RECORD rolegrantupdate;
    IF(CellExists(options,'comment') AND options.comment != grants[0].comment)
      INSERT CELL comment := options.comment INTO rolegrantupdate;

    IF(CellExists(options,'withgrantoption') AND options.withgrantoption != grants[0].withgrantoption)
    {
      INSERT CELL withgrantoption := options.withgrantoption INTO rolegrantupdate;

      IF(options.withgrantoption) //setting grant option ? then you 'own' this right now!
        INSERT CELL grantordata := EncodeHSON(this->GetUserDataForLogging()) INTO rolegrantupdate;
    }

    IF(RecordExists(rolegrantupdate))
      UPDATE system_internal.rolegrants SET RECORD rolegrantupdate WHERE id = grants[0].id;
  }

  /** Grants a role to a user
      @param roleid Id of the role to grant
      @param(object #RightsUserObject) grantee User object to grant this role to
      @cell options.grantoruserdata Userdata of the grantor for logging
      @cell options.comment Comment for this grant
      @deprecated Switch to UpdateRoleGrant in WH 4.32+
  */
  PUBLIC MACRO GrantRoleTo(INTEGER roleid, OBJECT grantee, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    this->UpdateRoleGrant("grant", roleid, grantee, options);
  }

  PUBLIC MACRO RevokeRoleFrom(INTEGER roleid, OBJECT grantee)
  {
    this->UpdateRoleGrant("revoke", roleid, grantee);
  }


  PUBLIC BOOLEAN FUNCTION CanManageRight(STRING rightname)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (right.allowobjref)
      THROW NEW Exception("CanManageRight can only be used for global rights");

    // Add the role grants to the authobjects
    INTEGER ARRAY authobjects := this->__PVT_GetExpandedAuthObjects(FALSE);

    RETURN 0 IN FindObjectsWithRights(right, [ INTEGER(right.rightid) ], authobjects, FALSE, [ 0 ], TRUE);
  }



  PUBLIC BOOLEAN FUNCTION CanManageRightOn(STRING rightname, INTEGER objectid)
  {
    RECORD right := GetRightByNameInternal(rightname);
    IF (NOT right.allowobjref)
      THROW NEW Exception("CanManageRightOn can only be used for object rights, not for right '" || rightname || "'");

    INTEGER ARRAY authobjects := this->__PVT_GetExpandedAuthObjects(FALSE);

    RETURN objectid IN FindObjectsWithRights(right, [ INTEGER(right.rightid) ], authobjects, FALSE, [ objectid ], TRUE);
  }
>;

STATIC OBJECTTYPE WebhareUnitObject EXTEND AuthObject
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  BOOLEAN __pvt_supportsrights;


  INTEGER __pvt_rightsobjecttype;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /** Can rights be granted to this authobject ? (eg it's a user, wrd user, role..>)
  */
  PUBLIC PROPERTY supportsrights(__pvt_supportsrights,-);


  PUBLIC PROPERTY id(__pvt_authobjectid, -);


  PUBLIC PROPERTY __rightsobjecttype(__pvt_rightsobjecttype,-);

  PUBLIC PROPERTY name(GetName,-);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(INTEGER unitid)
  {
    this->__pvt_authobjectid := unitid;
    this->__pvt_rightsobjecttype := 2;
    this->__pvt_supportsrights := FALSE;
  }

  STRING FUNCTION GetName()
  {
    RETURN SELECT AS STRING name FROM system_internal.authobjects WHERE authobjects.id = this->__pvt_authobjectid;
  }


  /** Returns whether this object still exists in the database
  */
  UPDATE PUBLIC BOOLEAN FUNCTION ExistsInDatabase()
  {
    RETURN RecordExists(SELECT FROM system_internal.authobjects WHERE id = this->__pvt_authobjectid AND type = 2);
  }
>;



// -----------------------------------------------------------------------------
//
// Access to object type describers
//

OBJECT FUNCTION GetObjectTypeDescriber(RECORD typerec)
{
  //ABORT(typerec);
//  PRINT("Making object " || typerec.library || ":" || typerec.objectname || "\n");
  current_type_rec := typerec;
  OBJECT describer := MakeObject(typerec.describer);
  IF (NOT ObjectExists(describer))
    THROW NEW Exception("Couldn't load objecttype describer for objecttype '"||typerec.objecttypename||"'");

  RETURN describer;
}

// -----------------------------------------------------------------------------
//
// Browsing
//

RECORD ARRAY FUNCTION GetTreeLevel(OBJECT describer, INTEGER objid, OBJECT user, BOOLEAN recursive, BOOLEAN describe)
{
  INTEGER ARRAY children;

  // If the requested objid is 0, we need to know the root objects
  IF (objid = 0)
    children := describer->GetRootObjects(user);

  // If not requesting the root, or 0 is a root object, query the children of the object.
  IF (objid != 0 OR 0 IN children)
    children := describer->GetObjectChildren(objid, user);

  RECORD ARRAY result;
  FOREVERY (INTEGER child FROM children)
  {
    RECORD rec := describe ? describer->DescribeObject(child) : [ id := child ];
    IF (RecordExists(rec))
    {
      RECORD data := describe ?
          [ id :=               child
          , name :=             rec.name
          , icon :=             rec.icon
          , wrdschemaid :=      CellExists(rec, "WRDSCHEMAID") ? rec.wrdschemaid : 0
          , sortkey :=          CellExists(rec, "SORTKEY") ? rec.sortkey : ToUppercase(rec.name)
          ] : rec;

      IF (recursive)
      {
        INSERT CELL subnodes := GetTreeLevel(describer, child, user, TRUE, describe) INTO data;
        INSERT CELL haschildren := LENGTH(data.subnodes) > 0 INTO data;
      }
      ELSE IF(describe)
      {
        INTEGER ARRAY subchildren := describer->GetObjectChildren(child, user);
        INSERT CELL haschildren := LENGTH(subchildren) > 0 INTO data;
      }

      INSERT data INTO result AT END;
    }
  }

//  PRINT("GetTreeLevel " || objid || ":\n" || AnyToString(result, "boxed"));
  IF(describe)
    RETURN SELECT * FROM result ORDER BY sortkey, name, id;
  ELSE
    RETURN result;
}



/** Returns the children of an object (sorted on sortkey)
    @param objecttype Name of objecttype (fully qualified with module)
    @return List of children objects
    @cell return.id Id of object
    @cell return.name Local name of the object
    @cell return.icon Name of icon to display for this object
    @cell return.haschildren Whether the object itself has children
*/
PUBLIC RECORD ARRAY FUNCTION GetPresentationRightObjectsChildren(STRING type, OBJECT user, INTEGER parentobjid, BOOLEAN describe DEFAULTSTO TRUE)
{
  IF (NOT ObjectExists(user))
    RETURN DEFAULT RECORD ARRAY;

  IF(NOT user EXTENDSFROM RightsObject)
    THROW NEW Exception("The user object passed is not a RightsObject and cannot be used for rights validation");

  RECORD typerec := GetObjectTypeDataByNameInternal(type);
  OBJECT describer := GetObjectTypeDescriber(typerec);

  IF (parentobjid != 0 AND NOT describer->IsObjectVisibleForUser(parentobjid, user))
    RETURN DEFAULT RECORD ARRAY;

  RETURN GetTreeLevel(describer, parentobjid, user, FALSE, describe);
}


/** Returns the ids of rights and optionally the rights that imply them of the same objecttype
*/
INTEGER ARRAY FUNCTION GetRightTypeIds(STRING ARRAY rights, BOOLEAN withimpliedbys)
{
  RECORD ARRAY worklist :=
      SELECT AS RECORD ARRAY GetRightByNameInternal(name)
        FROM ToRecordArray(rights, "NAME");

  INTEGER ARRAY result;
  WHILE (LENGTH(worklist) != 0)
  {
    RECORD rec := worklist[0];
    DELETE FROM worklist AT 0;

    IF (rec.rightid IN result)
      CONTINUE;

    INSERT rec.rightid INTO result AT END;

    IF (withimpliedbys)
      worklist := worklist CONCAT GetImpliedBysById(rec.rightid);
  }
  RETURN result;
}


/** Given a list of rights of one specific objecttype, give the list of objects the user has
    any right (from the list) on, but not on the parent object.
    Returns [ 0 ] if the user has rights on all objects.
    Does not use object describers, so it returns the structure as seen in the database
*/
PUBLIC INTEGER ARRAY FUNCTION GetRootObjectsForRights(STRING ARRAY rights, OBJECT user, INTEGER ARRAY extra_roots DEFAULTSTO DEFAULT INTEGER ARRAY)
{
  RETURN GetRootObjectsInDB(rights, user, FALSE, extra_roots);
}


/** Given a list of rights of one specific objecttype, give the list of objects the user has
    any grantable right (from the list) on, but not on the parent object.
    Returns [ 0 ] if the user has rights on all objects.
    Does not use object describers, so it returns the structure as seen in the database
*/
PUBLIC INTEGER ARRAY FUNCTION GetRootObjectsForGrantableRights(STRING ARRAY rights, OBJECT user, INTEGER ARRAY extra_roots DEFAULTSTO DEFAULT INTEGER ARRAY)
{
  RETURN GetRootObjectsInDB(rights, user, TRUE, extra_roots);
}




PUBLIC RECORD ARRAY FUNCTION GetObjectsPaths(STRING ARRAY rights, OBJECT user, INTEGER ARRAY objectids, INTEGER ARRAY extra_roots)
{
  RECORD ARRAY rightdatas :=
      SELECT AS RECORD ARRAY GetRightByNameInternal(name)
        FROM ToRecordArray(rights, "NAME");

  // Fast check: any right on #0: return root objects [ 0 ]
  FOREVERY (RECORD right FROM rightdatas)
  {
    IF (right.objecttypename != rightdatas[0].objecttypename)
      THROW NEW Exception("Can only get root objects from rights with the same objecttype");
  }

  INTEGER ARRAY rightids := GetRightTypeIds(rights, TRUE);

  RECORD ARRAY result :=
      SELECT objectid
           , path :=    [ INTEGER(objectid) ]
           , done :=    FALSE
        FROM ToRecordArray(objectids, "OBJECTID")
    GROUP BY objectid
    ORDER BY objectid;

  INTEGER ARRAY to_check := objectids;
  RECORD ARRAY relations;

  BOOLEAN any_notdone := TRUE;
  FOR(INTEGER iteration; iteration < 100 AND any_notdone;iteration := iteration + 1)
  {
    any_notdone := FALSE;

    INTEGER ARRAY unknown_parents :=
        SELECT AS INTEGER ARRAY Any(path[0])
          FROM result
         WHERE NOT done
           AND path[0] != 0
           AND NOT RecordLowerBound(relations, [ child := path[0] ], [ "CHILD" ]).found
      GROUP BY path[0];

    IF (LENGTH(unknown_parents) != 0)
    {
      RECORD ARRAY to_ask :=
          SELECT objectid :=      id
               , children :=      DEFAULT INTEGER ARRAY
            FROM ToRecordArray(unknown_parents, "ID");

      RECORD res := GetParentObjects(rightdatas[0].objecttypename, to_ask);

      relations :=
          SELECT *
            FROM relations CONCAT res.rawdata
        ORDER BY child;
    }

    FOR (INTEGER i := 0, e := LENGTH(result); i < e; i := i + 1)
    {
      RECORD rec := RecordLowerBound(relations, [ child := result[i].path[0] ], ["CHILD"]);
      IF (rec.found)
      {
        INTEGER parent := relations[rec.position].parent;
        INSERT parent INTO result[i].path AT 0;
        IF (parent = 0)
          result[i].done := TRUE;
        ELSE
          any_notdone := TRUE;
      }
      ELSE
        result[i].done := TRUE;
    }
  }

  INTEGER ARRAY authobjs;
  FOREVERY (RECORD r FROM result)
  {
    INSERT r.objectid INTO authobjs AT END;
    authobjs := authobjs CONCAT r.path;
  }

  authobjs :=
      SELECT AS INTEGER ARRAY DISTINCT id
        FROM ToRecordArray(authobjs, "ID");

  INTEGER ARRAY checkauthobjects := ExpandAuthobjectsWithRoleGrants([ INTEGER(user->authobjectid) ], TRUE);
  authobjs := FindObjectsWithRights(rightdatas[0], rightids, checkauthobjects, FALSE, authobjs, FALSE);

  // Mix in extra roots
  authobjs :=
      SELECT AS INTEGER ARRAY DISTINCT id
        FROM ToRecordArray(authobjs CONCAT extra_roots, "ID")
    ORDER BY id;

  FOR (INTEGER i := 0, e := LENGTH(result); i < e; i := i + 1)
  {
    INTEGER ARRAY path := result[i].path;
    WHILE (LENGTH(path) != 0 AND NOT LowerBound(authobjs, path[0]).found)
      DELETE FROM path AT 0;

    result[i].path := path;
  }

  RETURN
      SELECT objectid
           , path
        FROM result;
}

// -----------------------------------------------------------------------------
//
// Weblet stubs
//

/** Elevated rights calls
*/
/** Given a right and an object, try to find the parent object. Must be run with full permissions.
    @param objecttypename Name of object type
    @param obj Object to find the parent of
    @return Id of parent object, 0 if none found
*/
PUBLIC INTEGER FUNCTION GetParentObject(STRING objecttypename, INTEGER obj)
{
    RECORD objtypedata := GetObjectTypeDataByNameInternal(objecttypename);
    IF (objtypedata.parentfield = "")
      RETURN 0;

    INTEGER trans := GetPrimaryWebhareTransaction();

    OBJECT query := NEW DynamicQuery;
    query->AddTable("query", trans, objtypedata.tablename, [ STRING(objtypedata.parentfield) ]);
    query->AddConstraint("query." || objtypedata.primarykey, "=", obj);
    RECORD result := query->Execute();

    IF (RecordExists(result))
      RETURN GetCell(result.query, objtypedata.parentfield);

    RETURN 0;
}


  /** Get the parent object for a specific object.
      @param objecttypename Name of objecttype
      @param elements Elements to get the parent for (sorted on objectid)
      @cell elements.objectid
      @cell elements.children
      @return
      @cell(integer array) return.notfound
      @cell(record array) return.parents
      @cell(integer) return.objectid
      @cell(integer array) return.children
  */
  RECORD FUNCTION GetParentObjects(STRING objecttypename, RECORD ARRAY elements)
  {
    // Get the object ids
    INTEGER ARRAY objs :=
        SELECT AS INTEGER ARRAY objectid
          FROM elements;

    RECORD objtypedata := GetObjectTypeDataByNameInternal(objecttypename);
    IF (objtypedata.parentfield = "")
    {
      // No type with parent, we're done
      RETURN
          [ notfound :=   objs
          , parents :=    DEFAULT RECORD ARRAY
          ];
    }

    INTEGER trans := GetPrimaryWebhareTransaction();

    // Get the relevant records
    OBJECT query := NEW DynamicQuery;
    query->AddTable("query", trans, objtypedata.tablename, [ STRING(objtypedata.parentfield), objtypedata.primarykey ]);
    query->AddConstraint("query." || objtypedata.primarykey, "IN", objs);
    RECORD ARRAY rawdata := query->Execute();

    // Get the right cells, sorted on child (to quickly find parent id)
    rawdata :=
        SELECT child :=     GetCell(rawdata.query, objtypedata.primarykey)
             , parent :=    GetCell(rawdata.query, objtypedata.parentfield)
          FROM rawdata;

    // Generate the result record array, sorted on parent
    RECORD ARRAY parents :=
        SELECT objectid :=      parent
             , children :=      DEFAULT INTEGER ARRAY
          FROM rawdata
      GROUP BY parent;

    // Mix the position of the parent in the result array
    RECORD ARRAY data :=
        SELECT *
             , parentpos := RecordLowerBound(parents, [ objectid := parent ], [ "OBJECTID" ]).position
          FROM rawdata
      ORDER BY child;

    INTEGER ARRAY notfound;

    // Add the children from the original record into the result array
    FOREVERY (RECORD rec FROM elements)
    {
      RECORD pos := RecordLowerBound(data, [ child := rec.objectid ], [ "CHILD" ]);
      IF (pos.found)
      {
        INTEGER parentpos := data[pos.position].parentpos;
        parents[parentpos].children := parents[parentpos].children CONCAT rec.children;
      }
      ELSE
        INSERT rec.objectid INTO notfound AT END;
    }

    RETURN
        [ notfound :=   notfound
        , parents :=    parents
        , rawdata :=    SELECT *
                          FROM rawdata
                      ORDER BY child
        ];
  }




/** Returns the tree with all visible objects of a specific type
    @param type Name of objecttype (fully qualified with module)
    @return Root object
    @cell return.id Id of root object (must be 0)
    @cell return.name Local name of the object
    @cell return.fullname Full name of the object (must be unique among all objects)
    @cell return.icon Name of icon to display for this object
    @cell return.sortkey Case-sensitive string the children are sorted on
    @cell return.subnodes List of subnodes for this object type
    @cell return.haschildren Whether the object has children
*/
PUBLIC RECORD FUNCTION GetPresentationRightObjectsTree(STRING type, OBJECT user)
{
  OBJECT trans := __INTERNAL_GetSystemSchemaBinding();

  IF (NOT ObjectExists(user))
    RETURN DEFAULT RECORD;

  IF(NOT user EXTENDSFROM RightsObject)
    THROW NEW Exception("The user object passed is not a RightsObject and cannot be used for rights validation");


    RECORD typerec := GetObjectTypeDataByNameInternal(type);
    OBJECT describer := GetObjectTypeDescriber(typerec);

    RECORD ARRAY subnodes := GetTreeLevel(describer, 0, user, TRUE, FALSE);

    RETURN
        [ id :=           0
        , name :=         ""
        , icon :=         ""
        , wrdschemaid :=  0
        , sortkey :=      ""
        , subnodes :=     subnodes
        , haschildren :=  LENGTH(subnodes) != 0
        ];
}


/** Returns the path of an object to the root of the object tree for a specific user. Returns a partial
    path if objects in the path have disappeared.
    @param type Name of objecttype (fully qualified with module)
    @param user User under whose rights the path must be calculated
    @param objectid Object to calculate the path to
    @return Path to object, and whether it is visible
    @cell return.visible Whether the object is visible for this user
    @cell return.path Path to object
    @cell return.path.id
    @cell return.path.name
    @cell return.path.icon
*/
PUBLIC RECORD FUNCTION GetPresentationRightsObjectPath(STRING type, INTEGER objectid, OBJECT user)
{
    RECORD typerec := GetObjectTypeDataByNameInternal(type);
    OBJECT describer := GetObjectTypeDescriber(typerec);

    IF (NOT describer->IsObjectVisibleForUser(objectid, user))
    {
      RETURN
          [ visible :=  FALSE
          , path :=     DEFAULT RECORD ARRAY
          ];
    }

    RECORD ARRAY path;
    WHILE (TRUE)
    {
      RECORD rec := describer->DescribeObject(objectid);
      IF (NOT RecordExists(rec))
      {
        // Allow missing description of objectid 0
        IF (objectid != 0)
          RETURN DEFAULT RECORD ARRAY;

        rec := [ name := "", icon := "" ];
      }

      RECORD data :=
          [ id :=         objectid
          , name :=       rec.name
          , icon :=       rec.icon
          ];

      INSERT data INTO path AT 0;

      IF (objectid = 0)
        BREAK;

      objectid := GetParentObject(type, objectid);

      IF (NOT describer->IsObjectVisibleForUser(objectid, user))
        BREAK;
    }

    RETURN
        [ visible :=    TRUE
        , path :=       path
        ];
  }


/** Return the list of objects on which the user has a (grantable) right from the list, but not
    on the parent of the object.
    Returns [ 0 ] if the user has rights on all objects.
    Does not use object describers, so it returns the structure as seen in the database
*/
  INTEGER ARRAY FUNCTION GetRootObjectsInDB(STRING ARRAY rights, OBJECT user, BOOLEAN onlygrantable, INTEGER ARRAY extra_roots)
  {
    IF (LENGTH(rights) = 0)
      RETURN DEFAULT INTEGER ARRAY;

    RECORD ARRAY rightdatas :=
        SELECT AS RECORD ARRAY GetRightByNameInternal(name)
          FROM ToRecordArray(rights, "NAME");

    // Fast check: any right on #0: return root objects [ 0 ]
    FOREVERY (RECORD right FROM rightdatas)
    {
      IF (right.objecttypename != rightdatas[0].objecttypename)
        THROW NEW Exception("Can only get root objects from rights with the same objecttype");

      IF (onlygrantable)
      {
        IF (right.isglobal ? user->CanManageRight(right.fullname) : user->CanManageRightOn(right.fullname, 0))
          RETURN [ 0 ];
      }
      ELSE
      {
        IF (right.isglobal ? user->HasRight(right.fullname) : user->HasRightOn(right.fullname, 0))
          RETURN [ 0 ];
      }
    }

    IF (rightdatas[0].isglobal)
      RETURN DEFAULT INTEGER ARRAY;

    INTEGER ARRAY rightids := GetRightTypeIds(rights, TRUE);
    INTEGER ARRAY grantees := user->__PVT_GetAllAuthObjects() CONCAT GetIdsOfRolesGrantedTo(user);

    /// List of all objectids, add extra roots and eliminate duplicates
    INTEGER ARRAY objectids := GetSpecificRightsFor(grantees, rightids, rightdatas[0].storagetable, TRUE, DEFAULT INTEGER ARRAY, onlygrantable);
    objectids := GetSortedset(objectids CONCAT extra_roots);

    // Eliminate the objectids that are the parent of an other objectid
    // ADDME: use IN to handle multiple nodes at once.
    INTEGER ARRAY out_objectids;

    FOREVERY (INTEGER objectid FROM objectids)
    {
      INTEGER id := objectid;
      IF (id != 0)
      {
        WHILE (TRUE)
        {
          id := GetParentObject(rightdatas[0].objecttypename, id);
          IF (id = 0 OR id IN objectids)
            BREAK;
        }
      }
      IF (id = 0)
        INSERT objectid INTO out_objectids AT END;
    }

  //  PRINT("RoFR: " || AnyToString(rights, "tree") || "Result: " || AnyToString(out_objectids, "tree"));
    RETURN out_objectids;
  }


// -----------------------------------------------------------------------------
//
// Enumeration and explanation
//



/** Returns list of grants for a right to a specific user. Inheritance is ignored.
    @param user User to check
    @param right Right to check
    @return List of objects for which a grant is done (0 for global rights)
*/
PUBLIC INTEGER ARRAY FUNCTION GetObjectIdsOfDirectGrantsTo(STRING rightname, OBJECT user, BOOLEAN onlywithgrantoption)
{
  RECORD rightdata := GetRightByNameInternal(rightname);

  INTEGER ARRAY authobjects := user->__PVT_GetAllAuthObjects();
  INTEGER ARRAY objectids := GetSpecificRightsFor(authobjects, [ INTEGER(rightdata.rightid) ], rightdata.storagetable, TRUE, DEFAULT INTEGER ARRAY, onlywithgrantoption);
//  PRINT("Results: " || AnyToString(objectids, "tree"));
  RETURN objectids;
}


/** Returns list of grants for a right for any user. Inheritance is ignored.
    For usage in rights diagnostic (to count the amount of grants of a right)
    @param rightname Right to check
    @return Record with object and grantee
    @cell return.grantee Authobject of grantee
    @cell return.object Object for which the right has been granted (0 for global rights)
    @cell return.withgrantoption Whether the right was granted with the right to grant it to others
*/
PUBLIC RECORD ARRAY FUNCTION GetDirectGrantsForRight(STRING rightname)
{
  RECORD rightdata := GetRightByNameInternal(rightname);

  BindStorageTable(rightdata.storagetable);

  RETURN
      SELECT COLUMN "object"
           , COLUMN grantee
           , COLUMN withgrantoption
           , comment
           , grantor
           , grantordata := grantordata != "" ? DecodeHSON(grantordata) : DEFAULT RECORD
           , creationdate
        FROM rights_table
       WHERE COLUMN "right" = VAR rightdata.rightid;
}


/** Returns the list of all grants directly against a user/role
    @return Records with all grants
    @cell return.grantee
    @cell return.objectid
    @cell return.withgrantoption
    @cell return.rightname
*/
PUBLIC RECORD ARRAY FUNCTION GetDirectGrantsTo(OBJECT user)
{
  RECORD ARRAY alltables :=
     SELECT rights := GroupedValues(rec)
          , storagetable
       FROM GetRightsWithTables() AS rec
   GROUP BY storagetable;

  INTEGER ARRAY authobjects := user->__PVT_GetAllAuthObjects();

  RECORD ARRAY results;
  FOREVERY (RECORD tablerights FROM alltables)
  {
    BindStorageTable(tablerights.storagetable);

    RECORD ARRAY grants :=
      SELECT objectid   := COLUMN "object"
           , grantee
           , withgrantoption
           , rightid    := COLUMN "right"
           , comment
        FROM rights_table
       WHERE grantee IN authobjects;

    FOREVERY (RECORD right FROM tablerights.rights)
      results := results CONCAT
          SELECT *
               , rightname := right.name
            FROM grants
           WHERE rightid = right.id;
  }
  RETURN results;
}



/** Returns all the roles granted to a specific user
    @param user
    @return All roles granted to that user (recursively)
*/
INTEGER ARRAY FUNCTION GetIdsOfRolesGrantedTo(OBJECT user)
{
  INTEGER ARRAY authobjects := user->__PVT_GetAllAuthObjects();

  INTEGER ARRAY expanded := ExpandAuthobjectsWithRoleGrants(authobjects, FALSE);

  // Delete the original authobjects.
  FOREVERY (INTEGER i FROM authobjects)
    DELETE FROM expanded AT 0;

  RETURN expanded;
}



/** Returns why someone has a right
    @return List of grants for a right (or none when no right is present)
    @param ignore_inheritance Return only grants on the object itself (ignore inheritance)
    @cell return.inherited Whether this is an inherited rights
    @cell return.grantedright Original right this right is inherited from
    @cell return.grantedobject Object of the original right this right is inherited from
    @cell return.grantor The id of the grantor
    @cell return.creationdate The time of the grant
    @cell return.withgrantoption If this grant was given with grant option
*/
PUBLIC RECORD ARRAY FUNCTION ExplainRightGrantedToOn(STRING rightname, OBJECT grantee, INTEGER obj, BOOLEAN ignore_inheritance)
{
/* FIXME is this even a good idea? effectiveuser may not be a full user
  IF (NOT ObjectExists(grantee))
    grantee := GetEffectiveUser();
*/

//  RECORD grantee := GetEffectiveGrantee(granteeid);

//  PRINT("Explain right " || grantee || " " || rightname || " "||obj ||"\n");
  /*
    @cell module Id of the module
    @cell right Id of the right
    @cell storagetable Name (with schema) of the rights table
  */
  RECORD rightdata := GetRightByNameInternal(rightname);
  INTEGER ARRAY grantee_authobjects:= grantee->__PVT_GetAllAuthObjects();

  // Get the relevant grants (returns right-id and object)
  RECORD ARRAY grants := LocateGrantsFor(rightdata, grantee_authobjects, FALSE, obj, TRUE, ignore_inheritance, FALSE);

  // Calculate all authobjects that give our grantee rights (just like LocateGrantsFor does)
  INTEGER ARRAY all_authobjects := ignore_inheritance ?
        grantee_authobjects :
        ExpandAuthobjectsWithRoleGrants(grantee_authobjects, TRUE);

//  Print("Explain found grants:\n"||AnyToString(grants, "boxed"));
  RECORD ARRAY results;
  FOREVERY (RECORD rec FROM grants)
  {
    // Get the right data for the grant
    RECORD org_right := GetRightById(rec.rightid);

    // Get all the grants for that right/object
    RECORD ARRAY grantdata := GetSpecificGrantDataFor(all_authobjects, rec.rightid, org_right.storagetable, FALSE, rec.objectid);

    // And return em
    FOREVERY (RECORD grant FROM grantdata)
      INSERT
          [ grantid         := grant.id
          , inherited       := grant.grantee NOT IN grantee_authobjects OR rec.rightid != rightdata.rightid OR rec.objectid != obj
          , grantedright    := org_right.fullname
          , grantedobject   := rec.objectid
          , grantee         := grant.grantee
          , grantor         := grant.grantor
          , creationdate    := grant.creationdate
          , withgrantoption := grant.withgrantoption
          , comment         := grant.comment
          , grantordata     := grant.grantordata != "" ? DecodeHSON(grant.grantordata) : DEFAULT RECORD
          ] INTO results AT END;
  }
//  Print("Explain results:\n"||AnyToString(results, "boxed"));
  RETURN results;
}


/** Returns why someone has a role
    @param roleid Role
    @param grantee Grantee
*/
PUBLIC RECORD FUNCTION ExplainRoleGrantedTo(INTEGER roleid, OBJECT grantee)
{
  IF (NOT ObjectExists(grantee))
    grantee := GetEffectiveUser();

  RECORD rightdata := GetRightByNameInternal("system:manageroles");
  INTEGER ARRAY grantee_authobjects:= grantee->__PVT_GetAllAuthObjects();

  RETURN
      SELECT grantid :=         id
           , grantee :=         COLUMN grantee
           , creationdate :=    creationdate
           , grantor :=         grantor
           , comment
           , grantordata :=     grantordata != "" ? DecodeHSON(grantordata) : DEFAULT RECORD
        FROM system_internal.rolegrants
       WHERE role = roleid
         AND COLUMN grantee IN grantee_authobjects;
}

/** Returns whether a right is implied by another right
    @param rightname Right to determine of whether it is implied by another right
    @param impliedbyright Right to check if it implied the right @a rightname
    @returns Returns whether right @a impliedbyright implies right @a rightname
*/
PUBLIC BOOLEAN FUNCTION IsRightImpliedByOtherRight(STRING rightname, STRING impliedbyright)
{
  STRING ARRAY worklist := [ rightname ];
  STRING ARRAY visited := DEFAULT STRING ARRAY;

  WHILE (LENGTH(worklist) != 0)
  {
    STRING current := worklist[0];
    IF (current = impliedbyright)
      RETURN TRUE;

    DELETE FROM worklist AT 0;

    IF (current IN visited)
      CONTINUE;
    INSERT current INTO visited AT END;

    RECORD data := GetRightByNameInternal(current);
    RECORD ARRAY impliedbys := GetImpliedBysById(data.rightid);

    worklist := worklist CONCAT
        SELECT AS STRING ARRAY fullname
          FROM impliedbys;
  }
  RETURN FALSE;
}



// -----------------------------------------------------------------------------
//
// Object access/creation functions
//

PUBLIC OBJECT FUNCTION GetWebhareUserObject(INTEGER userid)
{
  IF (userid = 0)
    RETURN GetEffectiveUser();
  RETURN NEW RightsUserObject([ authobjectid := userid ]);
}



PUBLIC OBJECT FUNCTION GetRoleObject(INTEGER roleid)
{
  IF (roleid = 0)
    THROW NEW Exception("Trying to create a role object for role 0");
  RETURN NEW RightsRoleObject([ authobjectid := roleid ]);
}

PUBLIC OBJECT FUNCTION GetWebhareUnitObject(INTEGER unitid)
{
  RETURN NEW WebhareUnitObject(unitid);
}


PUBLIC INTEGER FUNCTION GetUnitOfAuthObject(INTEGER authobject)
{
  RETURN
      SELECT AS INTEGER parent
        FROM system_internal.authobjects
       WHERE id = authobject;
}


PUBLIC OBJECT FUNCTION GetWebhareRightsObject(INTEGER authobject)
{
  IF (authobject = 0)
    THROW NEW Exception("Trying to create a rights object for an authobject with id #0");

  RECORD rec :=
      SELECT type
        FROM system_internal.authobjects
       WHERE id = authobject;

  IF (NOT RecordExists(rec))
    RETURN NEW RightsObject(0, authobject);

  SWITCH (rec.type)
  {
  CASE 1 { RETURN GetWebhareUserObject(authobject); }
  CASE 2 { RETURN GetWebhareUnitObject(authobject); }
  CASE 3 { RETURN GetRoleObject(authobject); }
  DEFAULT { THROW NEW Exception("Could not open a rights object for an authobject with type #" || rec.type); }
  }
}


// -----------------------------------------------------------------------------
//
// Big revoke functions for userrights
//

/** Determines whether a list of revokes are 'dangerous' (cannot be restored with grants alone)
    @param grantor
    @param revokes
    @cell revokes.grantee
    @cell revokes.objectid
    @cell revokes.rightname
    @param role_revokes
    @cell revokes.grantee
    @cell revokes.roleid
*/
PUBLIC BOOLEAN FUNCTION AreRevokesDangerous(OBJECT myself, RECORD ARRAY revokes, RECORD ARRAY role_revokes)
{
  TRY
  {
    // Construct the list of all rights that will be revoked, either directly or in a role
    RECORD ARRAY effective_revokes;
    FOREVERY (RECORD rec FROM revokes)
    {
      OBJECT user := GetWebhareRightsObject(rec.grantee);
      IF (NOT user->ExistsInDatabase())
        CONTINUE;

      RECORD explained := ExplainRightGrantedToOn(rec.rightname, user, rec.objectid, /*ignore_inheritance=*/TRUE);
      IF (RecordExists(explained))
      {
        INSERT CELL withgrantoption := explained.withgrantoption INTO rec;
        INSERT rec INTO effective_revokes AT END;
      }
    }

    // Grants on a role are only dangerous revoked when revoked from myself
    FOREVERY (RECORD rec FROM role_revokes)
    {
      OBJECT grantee := GetWebhareRightsObject(rec.grantee);
      OBJECT roleobj := GetWebhareRightsObject(rec.roleid);

      IF (NOT grantee->ExistsInDatabase() OR NOT roleobj->ExistsInDatabase())
        CONTINUE;

      IF (grantee->__PVT_GetGrantTarget(TRUE) = rec.grantee)
        effective_revokes := effective_revokes CONCAT GetDirectGrantsTo(roleobj);
    }

//    PRINT("ard: effective\n"||AnyToString(effective_revokes, "boxed"));

    // Determine which revokes are potentially dangerous (those with grant option)
    RECORD ARRAY dangerous_revokes :=
        SELECT *
          FROM effective_revokes
         WHERE withgrantoption;

    BOOLEAN is_dangerous := TRUE;
    FOREVERY (RECORD rec FROM dangerous_revokes)
    {
      // A revoke is dangerous when all of the source rights of that rights are also revoked
      RECORD ARRAY sources := ExplainRightGrantedToOn(rec.rightname, myself, rec.objectid, /*ignore_inheritance=*/FALSE);

//      PRINT("ard: sources for \n"||AnyToString(rec, "boxed") || "Are:" || AnyToString(sources, "boxed"));

      BOOLEAN independent_grant := FALSE;
      FOREVERY (RECORD source FROM sources)
      {
        IF (NOT source.withgrantoption)
          CONTINUE;

        // Is this grant in the list of revokes? If not, it is independent
        IF (NOT RecordExists(
            SELECT
              FROM dangerous_revokes
             WHERE rightname = source.grantedright
               AND objectid = source.grantedobject
               AND grantee = source.grantee))
        {
//          PRINT("Found independent!\n");
          independent_grant := TRUE;
          BREAK;
        }
      }
      IF (NOT independent_grant)
        RETURN TRUE;
    }
  }
  CATCH (OBJECT e)
  {
    RETURN TRUE;
  }

  RETURN FALSE;
}
