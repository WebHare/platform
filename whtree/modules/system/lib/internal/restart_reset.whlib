<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";

LOADLIB "mod::system/lib/checks.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/services.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";
LOADLIB "mod::system/lib/internal/logging/logfiles.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/backend/users.whlib";
LOADLIB "mod::system/lib/internal/dbase/bootstrap.whlib";
LOADLIB "mod::system/lib/validation.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/modules/disk.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/modules/migrations.whlib";
LOADLIB "mod::system/lib/internal/modules/moduleregistry.whlib";

LOADLIB "mod::tollium/lib/internal/support.whlib";

BOOLEAN showinfo;
BOOLEAN any_messages := FALSE;

//RECORD settings;

BOOLEAN FUNCTION ReportOnInit(RECORD result)
{
  BOOLEAN any_error;
  IF(showinfo)
  {
    FOREVERY(RECORD msg FROM result.commands)
    {
      IF(msg.type="whdb")
        Print(msg.module || " sql command sent: " || msg.cmd || "\n");
      any_messages := TRUE;
    }
  }
  FOREVERY(RECORD msg FROM result.commitmessages)
  {
    Print(msg.module || " schema update error: " || msg.text || "\n");
    any_messages := TRUE;
    any_error := TRUE;
  }
  RETURN any_error;
}

MACRO HandleRunonceOutput(RECORD module, RECORD ro_result)
{
  FOREVERY(STRING msg FROM ro_result.messages)
  {
    Print(module.name || " startup script: " || msg || "\n");
    any_messages := TRUE;
  }
}

PUBLIC MACRO WebHareStartup(STRING ARRAY limitmodules, BOOLEAN debug)
{
  RECORD ARRAY modlist := GetWebHareModules();
  modlist := SELECT * FROM modlist WHERE name IN limitmodules;

  IF(debug)
    Print("Initializing: " || Detokenize((SELECT AS STRING ARRAY name FROM modlist),',') || '\n');
  StartupModules(modlist, FALSE); //FIXME when do we ever run with TRUE? what did this break ?
}

MACRO StartupModules(RECORD ARRAY modlist, BOOLEAN init_all_modules)
{
  modlist := SELECT TEMPORARY validator := GetModuleXMLValidator(name)
                  , *
                  , databaseschemas := GetModuleDatabaseSchema(name)
                  , runoncescripts := ParseModuleDefRunonce(validator)
               FROM modlist;

  FOREVERY(RECORD mod FROM modlist)
    FOREVERY(RECORD dbschema FROM mod.databaseschemas)
      IF(Length(dbschema.msgs)>0)
      {
        FOREVERY(RECORD msg FROM dbschema.msgs)
          Print("Module " || mod.name || " definition:" || msg.line || ":" || msg.text || "\n");
      }

  RECORD result := InitModuleIndependents(modlist, init_all_modules, TRUE);
  BOOLEAN any_db_error := ReportOnInit(result);

  //And their startup scripts
  FOREVERY(RECORD module FROM modlist)
  {
    RECORD ro_result := RunRunOnceScripts(module, "afterschemacreation", showinfo);

    FOREVERY(STRING msg FROM ro_result.messages)
    {
      Print(module.name || " startup script: " || msg || "\n");
      any_messages := TRUE;
    }
    IF (ro_result.error)
    {
      PRINT("Got runonce script error: \n" || AnyToString(ro_result, "tree"));
    }
  }


  FOREVERY(RECORD module FROM modlist)
  {
    IF(showinfo)
      Print(">> " || module.name || " >> inittables\n");
    RECORD output := InitModuleTables(module);
    ReportOnInit(output);
  }

  FOREVERY(RECORD module FROM modlist)
  {
    RECORD ro_result_2 := RunRunOnceScripts(module, "aftertablesbeforerights", showinfo);
    HandleRunonceOutput(module, ro_result_2);
  }

  IF(showinfo)
    Print(">> modulerights\n");

  RECORD output2 := InitModuleRights(modlist, FALSE);
  ReportOnInit(output2);

  IF(GetPrimary()->IsWorkOpen())
  {
    PRINT("ERROR! Work was still open after InitModuleRights\n");
    GetPrimary()->RollbackWork();
  }

  FOREVERY(RECORD module FROM modlist)
  {
    RECORD ro_result := RunRunOnceScripts(module, "aftertablecreation", showinfo);
    HandleRunonceOutput(module, ro_result);
  }

  IF (NOT any_db_error)
  {
    IF(showinfo)
      Print(">> InitModuleIndependents\n");

    result := InitModuleIndependents(modlist, init_all_modules, FALSE); //post updates
    ReportOnInit(result);

    IF(showinfo)
      Print(">> InitModuleRegistryKeys\n");

    result := InitModuleRegistryKeys(SELECT AS STRING ARRAY name FROM modlist);
    ReportOnInit(result);
  }

  FOREVERY(RECORD module FROM modlist)
    IF (module.name = "system")
    {
      IF(showinfo)
        Print(">> UpdateSystemConfigurationRecord\n");
      UpdateSystemConfigurationRecord();
    }

  FOREVERY(RECORD module FROM modlist)
  {
    RECORD ro_result := RunRunOnceScripts(module, "afterregistryupdate", showinfo);
    HandleRunonceOutput(module, ro_result);
  }
}

PUBLIC RECORD ARRAY FUNCTION ValidateModules()
{
  STRING ARRAY checkmodules := GetInstalledModuleNames();
  RECORD ARRAY messages;

  STRING ARRAY moduledefinitions;

  FOREVERY (STRING module FROM checkmodules)
  {
    STRING modpath := GetModuleDefinitionXMLResourceName(module);
    IF(RecordExists(RetrieveWebHareResource(modpath, [allowmissing := TRUE ])))
    {
      RECORD result := ValidateSingleFile(GetModuleDefinitionXMLResourceName(module));
      messages := messages CONCAT SELECT *, msg := resourcename || ":" || line || ":" || col || ": " || message FROM result.errors;
    }
  }
  RETURN messages;
}

ASYNC MACRO RequestRecompile(OBJECT service) {
  INTEGER64 now := GetUnixTimestampMsecs(GetCurrentDateTime());
  AWAIT service->RequestRecompile();
  service->CloseService();
  IF(showinfo)
    Print("Recompiled site profiles in " || (GetUnixTimestampMsecs(GetCurrentDateTime()) - now) || "ms\n");
}

/** @param issoftreset We're invoked by wh softreset, so we're supposed to be thorough, not fast as we would be during startup */
PUBLIC MACRO RunRestartReset(BOOLEAN debug, BOOLEAN issoftreset)
{
  showinfo := debug;

  // If not softresetting, configure the logfiles before anything else
  IF (debug)
    Print("Reconfiguring log files\n");
  ReconfigureLogFiles();

  //Make sure installedmodules folder exists
  CreateDiskDirectoryRecursive(GetWebHareConfiguration().varroot || "installedmodules", TRUE);

  // If the database is in readonly mode, there isn't much we can do anymore
  IF (NOT IsDatabaseWritable())
  {
    ReloadWebhareConfig2("ALL", [ nowait := TRUE ]);
    RETURN;
  }

  //bootstrap chicken&egg tables first
  IF (debug)
    Print("WebHare database bootstrap\n");
  BootstrapDatabase();

  //core modules first
  IF (debug)
    Print("WebHare startup rest\n");
  WebHareStartup(whconstant_builtinmodules, debug);

  //any init_whfs should have resolved now... just make sure we have all the module dirs and an override user!
  GetPrimary()->BeginWork();
  EnsureModulePrivateFolders();
  EnsureCreatedMagicSysop("<overrideuser>");
  GetPrimary()->CommitWork();
  EnsureModuleStorageFolders(FALSE);

  IF(issoftreset) { //then the rest
    STRING ARRAY modules := SELECT AS STRING ARRAY module FROM ToRecordArray(GetInstalledModuleNames(),'module') WHERE module NOT IN whconstant_builtinmodules;
    IF(Length(modules) > 0)
    {
      IF (debug)
        Print("WebHare startup other modules\n");
      WebHareStartup(modules, debug);
    }
  }

  IF (debug)
    Print("WRD schemas, siteprofiles\n");

  //Connect and start remote SP compiler
  OBJECT spcompile := OpenWebHareService("system:spcompiler")->Then(PTR RequestRecompile);

  //Apply WRD config
  TRY {
    INTEGER64 now := GetUnixTimestampMsecs(GetCurrentDateTime());
    ApplyWebHareConfiguration([ __bootstrap := NOT issoftreset, subsystems := ["wrd"], modules := issoftreset ? GetInstalledModuleNames() : whconstant_builtinmodules, source := "startup" ]); //TODO some regenerators might be pushed off to an async task, remaining code shouldn't be depending on a deleted module anyway
    IF(debug)
      Print(`WRD schemas took ${GetUnixTimestampMsecs(GetCurrentDateTime()) - now}ms to apply\n`);
    } CATCH(OBJECT e) {
    LogHarescriptException(e);
    PrintTo(2, `Fatal exception updating WRD schemas: ${e->what}\n`);
  }

  TRY {
    INTEGER64 now := GetUnixTimestampMsecs(GetCurrentDateTime());
    WaitForPromise(spcompile);
    IF(debug)
      Print(`Site profiler took ${GetUnixTimestampMsecs(GetCurrentDateTime()) - now}ms to catch up with us\n`);
  } CATCH(OBJECT e) {
    LogHarescriptException(e);
    PrintTo(2, `Fatal exception during siteprofile compilation: ${e->what}\n`);
  }

  IF (debug)
    Print("Reloading WebHare configuration\n");

  ReloadWebhareConfig2("ALL", [ nowait := TRUE ]);
}

PUBLIC MACRO RunSoftReset(BOOLEAN debug)
{
  OBJECT eventmgr := NEW EventManager;
  eventmgr->RegisterInterest("system:internal.servicestate.poststartdone");

  // Make sure config.json is up-to-date, the user might have moved module dirs around manually and is now trying to wh softreset to fix things
  ApplyWebHareConfiguration([ subsystems := ["config.base"], source := "RunSoftReset" ]);

  // Reload modules on all processes (updates module installation paths)
  ReloadWebhareConfig2("MODULES");

  OBJECT validationpromise;
  validationpromise := AsyncCallFunctionFromJob("mod::system/lib/internal/restart_reset.whlib#ValidateModules");

  IF (debug)
    Print("Running restart/reset\n");

  RunRestartReset(debug, TRUE);

  DATETIME waitlimit := AddTimeToDate(5 * 60 * 1000,GetCurrentDatetime());

  // Wait for validation to finish
  IF(ObjectExists(validationpromise))
  {
    IF (debug)
      Print("Wait for validation\n");
    RECORD ARRAY messages := WaitForPromise(validationpromise);
    FOREVERY(RECORD msg FROM messages)
      Print(`${msg.resourcename}(${msg.line}:${msg.col}): ${msg.msg}\n`);
  }

  WHILE(TRUE)
  {
    IF (debug)
      Print("Waiting for poststart to be done\n");

    RECORD event := eventmgr->ReceiveEvent(waitlimit);
    IF (event.status = "timeout")
      ABORT("Module upgrade tasks are taking more than 5 minutes to complete");
    IF(CellExists(event.msg,'finished'))
    {
      IF (debug)
        Print("Got poststartdone event\n");
      BREAK;
    }
  }
  eventmgr->Close();

  //ADDME inform other backends, enumerate all userapis, or setup a global global channel
  IF (debug)
    Print("Broadcast dashboard refresh\n");
  BroadcastToAllSessions( [ type := "tollium:shell.refreshdashboard" ]);
}

PUBLIC INTEGER FUNCTION PrintIssueOverview()
{
  RECORD ARRAY messages := SELECT * FROM GetCurrentCheckIssues() ORDER BY is_critical DESC;
  UPDATE messages SET message_text := "CRITICAL: " || message_text WHERE is_critical;

  INTEGER num_snoozed := LENGTH(SELECT FROM messages WHERE snoozed);
  DELETE FROM messages WHERE snoozed;

  IF(Length(messages)>1)
  {
    Print(" - " || Length(messages) || " issues!");
    IF (num_snoozed != 0)
      PRINT(` (and ${num_snoozed} snoozed ${num_snoozed=1?"message":"messages"})\n`);
    ELSE
      PRINT("\n");
    FOREVERY(RECORD msg FROM messages)
      Print(msg.message_text || "\n");
  }
  ELSE IF(Length(messages)=1)
  {
    Print(" - " || messages[0].message_text);
    IF (num_snoozed != 0)
      PRINT(` (and ${num_snoozed} snoozed ${num_snoozed=1?"message":"messages"})\n`);
    ELSE
      PRINT("\n");
  }
  ELSE
  {
    Print(" - all ok!");
    IF (num_snoozed != 0)
      PRINT(` (${num_snoozed} snoozed ${num_snoozed=1?"message":"messages"})\n`);
    ELSE
      PRINT("\n");
  }
  RETURN RecordExists(SELECT FROM messages WHERE is_critical) ? 2 /* Critical */: Length(messages) > 0 ? 1 /*warning*/ : 0 /*ok*/;
}
