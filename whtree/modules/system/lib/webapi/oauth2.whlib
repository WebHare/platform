<?wh
/** @topic webapis/oauth2 */

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::internet/http.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";

PUBLIC CONSTANT RECORD oauthbaseoptions := CELL[ clientid := ""
                                               , clientsecret := ""
                                               , clientregistrykey := ""
                                               , rpclogsource := ""
                                               , redirecturl := ""
                                               ];

PUBLIC CONSTANT RECORD oauth2options := CELL[ ...oauthbaseoptions
                                            , clientcomponent := DEFAULT OBJECT
                                            , authorizeurl := ""
                                            , authtokenurl := ""
                                            ];

// Autorization with PKCE code verifier: https://www.rfc-editor.org/rfc/rfc7636

// Note that the list of allowed characters for a code verifier is [A-Z] / [a-z] / [0-9] / "-" / "." / "_" / "~", using
// GenerateUFS128BitId eliminates "." and "~" from this list, resulting in a slightly less random code verifier
PUBLIC STRING FUNCTION CreateCodeVerifier(INTEGER len DEFAULTSTO 56)
{
  IF (len < 43 OR len > 128)
    THROW NEW Exception("A code verifier must be between 43 and 128 characters long");
  STRING result;
  WHILE (Length(result) < len)
    result := result || GenerateUFS128BitId();
  RETURN Left(result, len);
}

STRING FUNCTION CreateCodeChallenge(STRING verifier, STRING method)
{
  SWITCH (method)
  {
    CASE "plain"
    {
      RETURN verifier;
    }
    CASE "S256"
    {
      RETURN EncodeUFS(GetHashForString(verifier, "SHA-256"));
    }
    DEFAULT
    {
      THROW NEW Exception(`Invalid code challenge method '${method}', allowed are 'plain' or 'S256`);
    }
  }
}

/** Manages the oauth2 %WebBrowser */
PUBLIC STATIC OBJECTTYPE Oauth2Connection
<
  RECORD oauthconfig;
  OBJECT __browser;
  RECORD __token;

  PUBLIC PROPERTY browser(__browser, -);
  PUBLIC PROPERTY token(__token,SetToken);

  ///Some providers (eg Zoho) requirer a different token than "Bearer" as authorization type
  PUBLIC STRING authorization_header_type;
  ///Some providers (eg Zoho) set a wrong unit for 'expires_in'
  PUBLIC BOOLEAN expires_in_msecs;

  /** @cell(string) options.redirectto Where to redirect after authorization
      @cell(string) options.clientregistrykey Registry node containing client id and secret */
  MACRO NEW(RECORD options)
  {
    this->oauthconfig := ValidateOptions(oauth2options, options);

    IF(ObjectExists(this->oauthconfig.clientcomponent))
    {
      IF(NOT MemberExists(this->oauthconfig.clientcomponent, "__isOauth2Client"))
        THROW NEW Exception("The object passed to 'clientcomponent' must be an Oauth2Client Tollium component");

      IF(RecordExists(this->oauthconfig.clientcomponent->value))
      {
        IF(this->oauthconfig.clientid = "")
          this->oauthconfig.clientid := this->oauthconfig.clientcomponent->value.clientid;
        IF(this->oauthconfig.clientsecret = "")
          this->oauthconfig.clientsecret := this->oauthconfig.clientcomponent->value.clientsecret;
        IF(this->oauthconfig.redirecturl = "")
          this->oauthconfig.redirecturl := this->oauthconfig.clientcomponent->value.redirecturl;
      }
    }

    IF(this->oauthconfig.clientregistrykey != "")
    {
      RECORD keyinfo := ReadRegistryKey(this->oauthconfig.clientregistrykey, [fallback := DEFAULT RECORD]);
      IF(RecordExists(keyinfo))
      {
        keyinfo := EnforceStructure(oauthbaseoptions, keyinfo);
        IF(this->oauthconfig.clientid = "")
          this->oauthconfig.clientid := keyinfo.clientid;
        IF(this->oauthconfig.clientsecret = "")
          this->oauthconfig.clientsecret := keyinfo.clientsecret;
        IF(this->oauthconfig.redirecturl = "")
          this->oauthconfig.redirecturl := keyinfo.redirecturl;
      }
    }

    DELETE CELL ignored, clientcomponent, clientregistrykey FROM this->oauthconfig;

    this->authorization_header_type := "Bearer";
    this->__browser := NEW WebBrowser;
    this->__browser->onrequest := PTR this->OnBrowserRequest(#1, this->__browser->onrequest);
    IF(this->oauthconfig.rpclogsource != "")
      LogRPCForWebbrowser(this->oauthconfig.rpclogsource, "", this->__browser);
  }

  MACRO SetToken(RECORD token)
  {
    IF(RecordExists(token))
      ValidateOptions([ "access_token" := ""
                      , "request_token" := ""
                      ], token, [ title := "token", required := ["access_token"], passthroughin := "x" ]);
    this->__token := token;
  }

  RECORD FUNCTION OnBrowserRequest(RECORD req, FUNCTION PTR nextinchain)
  {
    IF(RecordExists(this->token))
    {
      DELETE FROM req.headers WHERE ToUppercase(field)="AUTHORIZATION";
      INSERT [ field := "Authorization", value := this->authorization_header_type || " " || this->token.access_token ] INTO req.headers AT END;
    }
    RETURN nextinchain(req);
  }

  //https://www.oauth.com/oauth2-servers/oauth2-clients/server-side-apps/
  //request an authorization code you can trade in later
  STRING FUNCTION GetAuthorizationCodeURL(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ scopes := STRING[]
                               , state := ""
                               , access_type := "online"
                               , code_verifier := ""
                               , extraparameters := DEFAULT RECORD
                               , redirect_uri := ""
                               ], options, [ enums := [ access_type := ["offline","online"] ]]);

    IF(this->oauthconfig.authorizeurl = "")
      THROW NEW Exception(`Oauth autorizeurl not set!`);

    STRING redirect_uri := options.redirect_uri ?? this->oauthconfig.redirecturl ?? GetDefaultOauth2RedirectURL();

    STRING url := UpdateURLVariables(this->oauthconfig.authorizeurl,
      [ client_id := this->oauthconfig.clientid
      , response_type := "code"
      , scope := Detokenize(options.scopes,' ')
      , redirect_uri := redirect_uri
      , state := options.state
      , access_type := options.access_type
      , ...(options.code_verifier != "" ? [ code_challenge := CreateCodeChallenge(options.code_verifier, "S256"), code_challenge_method := "S256" ] : DEFAULT RECORD)
      , ...options.extraparameters
      ]);
    RETURN url;
  }

  /** @short Prepare the data needed to start an authorization flow
      @long Like %AuthorizeClient this function starts an authentication flow, but gathers data for eg Tollium to handle the actual flow
      @cell(string array) options.scopes Requested scopes
      @cell(string) options.access_type 'offline' to request a refresh_token. defaults to 'online'
      @cell(record) options.extraparameters Any extra parameters, eg [ prompt := "consent" ]
      @cell(string) options.code_verifier A PKCE code verifier to use for authorization
      @return Record with authorization flow info
  */

  PUBLIC RECORD FUNCTION GetAuthorizeContext(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(CellExists(options,'state'))
      THROW NEW Exception("The 'state' option is reserved by StartRedirectAuthorizationFlow and cannot be used");

    IF(this->oauthconfig.clientsecret = "")
      THROW NEW Exception("Cannot start an authorization flow without a client secret");

    RETURN [ __oauth2_authflow := [ url := this->GetAuthorizationCodeURL(CELL[ ...options ])
                                  , state := [ oauthconfig := this->oauthconfig
                                             , tokeninfo := DEFAULT RECORD
                                             , requeststart := GetCurrentDatetime()
                                             , redirect_uri := CellExists(options, 'redirect_uri') ? options.redirect_uri : ""
                                               // Store the code verifier in the state, so it's available to the landing page handler
                                             , code_verifier := CellExists(options, "code_verifier") ? options.code_verifier : ""
                                             ]
                                  ]
           ];
  }

  PUBLIC RECORD FUNCTION __CreateFinalToken(RECORD sessdata)
  {
    IF(CellExists(sessdata.tokeninfo,"access_token"))
    {
      RETURN CELL[ ...sessdata.tokeninfo
                 , __meta := [ requeststart := sessdata.requeststart
                             ]
                 ];
    }
    RETURN DEFAULT RECORD;
  }

  /** @short Get the submitinstruction to start an authorziation flow
      @param finalreturnurl URL to return
      @cell(string array) options.scopes Requested scopes
      @cell(string) options.access_type 'offline' to request a refresh_token. defaults to 'online'
      @cell(record) options.extraparameters Any extra parameters, eg [ prompt := "consent" ]
      @cell(string) options.code_verifier A PKCE code verifier to use for authorization
      @return Submit instruction to execute
  */
  PUBLIC RECORD FUNCTION StartAuthorizeClient(STRING finalreturnurl, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD authcontext := this->GetAuthorizeContext(options);
    INSERT CELL finalreturnurl := finalreturnurl INTO authcontext.__oauth2_authflow.state;
    STRING oauth2session := CreateWebSession("system:oauth2", authcontext.__oauth2_authflow.state, [ maxidle_minutes := 90]);
    RETURN [ type := "redirect"
           , url := UpdateURLVariables(authcontext.__oauth2_authflow.url, [ state := oauth2session ])
           ];
  }

  PUBLIC RECORD FUNCTION HandleAuthorizedLanding(STRING oauth2session)
  {
    RECORD sessdata := GetWebSessionData(oauth2session, "system:oauth2");
    RECORD tok := this->__CreateFinalToken(sessdata);
    IF(RecordExists(tok))
    {
      this->token := tok;
      RETURN [ success := TRUE ];
    }
    RETURN [ success := FALSE ];
  }

  /** @short Start a redirecting authorization flow from the current page
      @long This function is designed to run the same webpage twice - first it will notice the oauthsession2= variable
            missing and redirect to the oauth pages. Oauth will then redirect back to the page, and we will return the token
      @cell(string array) options.scopes Requested scopes
      @cell(string) options.access_type 'offline' to request a refresh_token. defaults to 'online'
      @cell(record) options.extraparameters Any extra parameters, eg [ prompt := "consent" ]
      @cell(string) options.code_verifier A PKCE code verifier to use for authorization
      @return Success information
      @cell(boolean) return.success True if we've succesfully authorized the client. AuthorizeClient redirects to the oauth2 flow if we don't have the token yet */
  PUBLIC RECORD FUNCTION AuthorizeClient(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    STRING sessid := GetWebVariable("oauth2session");
    IF(sessid != "")
      RETURN this->HandleAuthorizedLanding(sessid);

    Redirect(this->StartAuthorizeClient(GetRequestURL(), options).url);
  }

  /** @short Is this token still usable?
      @cell options.validuntil Check if the token is valid until this time, by default we'll check if the token will work for at least 5 more minutes
      @return True if the token has expired
  */
  PUBLIC BOOLEAN FUNCTION IsAccessTokenExpired(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ validuntil := DEFAULT DATETIME ], options);
    IF(NOT RecordExists(this->token))
      RETURN TRUE;//an empty token is always expired

    IF(NOT CellExists(this->token,'expires_in'))
      THROW NEW Exception("Access token lacks information to determine expiration");

    DATETIME expiry := AddTimeToDate(INTEGER64(this->token.expires_in) * (this->expires_in_msecs ? 1 : 1000), this->token.__meta.requeststart);
    DATETIME until := options.validuntil ?? AddTimetoDate(5*60*1000, GetCurrentDatetime());
    RETURN expiry <= until;
  }

  /** @short Get a new accesstoken using our refresh token. This call updates this->token if succesful
      @cell return.success Whether the renewal failed
      @cell return.message Error message
   */
  PUBLIC RECORD FUNCTION RefreshAccessToken()
  {
    IF(NOT RecordExists(this->token)) //no token set at all
      RETURN [ success := FALSE, message := "No token set" ];
    IF(NOT CellExists(this->token,'refresh_token')) //not everyone (eg facebook) will give us a refresh_token
      RETURN [ success := FALSE, message := "Token cannot be refreshed" ];

    DATETIME requeststart := GetCurrentDatetime();
    BLOB body := CreateHTTPUrlencodedRequest(
                  [[ name := "refresh_token", value := this->token.refresh_token ]
                  //TODO shouldn't this be safer in a authorization header ?
                  ,[ name := "client_id",     value := this->oauthconfig.clientid ]
                  ,[ name := "client_secret", value := this->oauthconfig.clientsecret ]
                  ,[ name := "grant_type",    value := "refresh_token" ]
                  ]).body;

    // Temporarily clear authorization token (if we're refreshing the token, it probably isn't valid anymore)
    RECORD token := this->token;
    this->token := DEFAULT RECORD;
    TRY
    {
      IF(NOT this->browser->SendRawRequest("POST", this->oauthconfig.authtokenurl,
          [[ field := "Content-Type", value := "application/x-www-form-urlencoded" ]], body))
      {
        RETURN [ success := FALSE, message := `Unable to retrieve request token: ${this->browser->GetHTTPStatusText()}` ];
      }
    }
    FINALLY
    {
      this->token := token;
    }

    RECORD newtoken := DecodeJSONBlob(this->browser->content);
    IF(CellExists(newtoken,"access_token"))
    {
      this->token := CELL[ ...this->token  //keep any refresh_token
                         , ...newtoken
                         , __meta := [ requeststart := requeststart ]
                         ];
      RETURN [ success := TRUE, message := "" ];
    }
    RETURN [ success := FALSE, message := "No new accesstoken received" ];
  }

  /** @short Start an oauth2 authorization
      @return options.promise Promise that will resolve when the oauth2 process is complete
      @return options.url URL for the user to visit */
  //PUBLIC RECORD FUNCTION StartOauth2Authorization(RECORD options DEFAULTSTO DEFAULT RECORD)
  //{
  //  IF(CellExists(options,'state'))
  //    THROW NEW Exception("The 'state' option is reserved by StartOauth2Authorization and cannot be used");

  //  //TODO use something more persistent and more flexible than a websession
  //  RECORD defer := CreateDeferredPromise();
  //  STRING oauth2session := CreateWebSession("system:oauth2", DEFAULT RECORD, 90, FALSE);
  //  options := CELL [ ...options, state := oauth2session];

  //  RETURN [ promise := defer.promise
  //         , url := this->GetAuthorizationCodeURL(options)
  //         ];
  //}

  //trade in the authorization code for a request token
  PUBLIC RECORD FUNCTION RequestToken(STRING code, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ redirect_uri := ""
                               , code_verifier := ""
                               ], options);


    STRING redirect_uri := options.redirect_uri ?? this->oauthconfig.redirecturl ?? GetDefaultOauth2RedirectURL();

    BLOB body := CreateHTTPUrlencodedRequest(
                  [[ name := "code",          value := code ]
                  //TODO shouldn't this be safer in a authorization header ?
                  ,[ name := "client_id",     value := this->oauthconfig.clientid ]
                  ,[ name := "client_secret", value := this->oauthconfig.clientsecret ]
                  ,[ name := "redirect_uri",  value := redirect_uri ]
                  ,[ name := "grant_type",    value := "authorization_code" ]
                  ,...(options.code_verifier != "" ? [[ name := "code_verifier", value := options.code_verifier ]] : RECORD[])
                  ]).body;

    IF(NOT this->browser->SendRawRequest("POST", this->oauthconfig.authtokenurl,
        [[ field := "Content-Type", value := "application/x-www-form-urlencoded" ]], body))
    {
      THROW NEW Exception(`Unable to retrieve request token: ${this->browser->GetHTTPStatusText()}`);
    }

    RECORD token := EnforceStructure([ access_token := "", refresh_token := "", expires_in := 0, token_type := "" ], DecodeJSONBLob(this->browser->content));
    RETURN token;
  }

  /** Request client credentials (authorizing the app itself, not a specific user)
      @cell(string array) options.scopes Requested scopes
  */
  PUBLIC RECORD FUNCTION RequestClientCredentials(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ scopes := STRING[]
                               //password grants are deprecated. probably not worth extending the API for this
                               , username := ""
                               , password := ""
                               ], options);

    //TODO shouldn't this be safer in a authorization header ?
    RECORD ARRAY vars := [[ name := "client_id",     value := this->oauthconfig.clientid ]
                         ,[ name := "client_secret", value := this->oauthconfig.clientsecret ]
                        ];
    IF(options.username != "")
    {
      vars := vars CONCAT [[ name := "grant_type",   value := "password" ]
                          ,[ name := "username",     value := options.username ]
                          ,[ name := "password",     value := options.password ]
                          ];
    }
    ELSE
    {
      vars := vars CONCAT [[ name := "grant_type",    value := "client_credentials" ]
                          ];
    }

    IF(Length(options.scopes) > 0)
      INSERT CELL [ name := "scope", value := Detokenize(options.scopes,' ') ] INTO vars AT END;

    BLOB body := CreateHTTPUrlencodedRequest(vars).body;

    IF(NOT this->browser->SendRawRequest("POST", this->oauthconfig.authtokenurl,
        [[ field := "Content-Type", value := "application/x-www-form-urlencoded" ]], body))
    {
      THROW NEW Exception(`Unable to retrieve request token: ${this->browser->GetHTTPStatusText()}`);
    }

    RECORD token := EnforceStructure([ access_token := "", refresh_token := "", expires_in := 0, token_type := "" ], DecodeJSONBLob(this->browser->content));
    RETURN token;
  }

  /** Grab client credentials from a registry key, requesting or extending if necessary.
      @long This call wrpas client token request and storage. It should be called outside open work
      @param keyname Registry key to store the token in. The key itself must be of type 'record'
      @cell(string array) options.scopes Requested scopes
      @cell(boolean) return.success If true, credentials were succesfully renewed */
  PUBLIC RECORD FUNCTION SetupClientCredentialsUsingRegistryKey(STRING keyname, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ scopes := STRING[]
                               //password grants are deprecated. probably not worth extending the registry components for this
                               , username := ""
                               , password := ""
                               ], options);

    IF(GetPrimary()->IsWorkOpen())
      THROW NEW Exception("SetupClientCredentialsUsingRegistryKey cannot be used with open work"); //we need control, plus shouldn't do remote requests with open transactions

    this->token := ReadRegistryKey(keyname);

    BOOLEAN rerequest := this->IsAccessTokenExpired();
    IF(NOT rerequest)
    {
      //if not expired, token record exists
      RECORD meta := EnforceStructure([ requestedscopes := STRING[] ], this->token.__meta);
      FOREVERY(STRING scope FROM options.scopes)
        IF(scope NOT IN meta.requestedscopes)
          rerequest := tRUE;
    }

    IF(rerequest)
    {
      // Use a mutex to prevent two processes from refreshing the access token using the same refresh token
      OBJECT lock := OpenLockManager()->LockMutex(`system:oauth2.refreshtoken.${keyname}`);
      TRY
      {
        // Another process might have updated the token, read it again
        this->token := ReadRegistryKey(keyname);
        IF (this->IsAccessTokenExpired())
        {
          DATETIME requeststart := GetCurrentDatetime();
          this->token := DEFAULT RECORD; //reset bearer token to prevent confusion on the API's side
          RECORD result := this->RequestClientCredentials(options);
          IF(result.access_token = "")
            RETURN [ success := FALSE ];

          this->token := CELL[ ...result
                             , __meta := [ requeststart := requeststart
                                         , requestedscopes := options.scopes
                                         ] ];
          GetPrimary()->BeginWork();
          WriteRegistryKey(keyname, this->token);
          GetPrimary()->CommitWork();
        }
      }
      FINALLY
      {
        lock->Release();
      }
    }
    RETURN [ success := TRUE ];
  }

  /// Grab a token from a registry key, extending it if necessary
  PUBLIC RECORD FUNCTION SetupTokenUsingRegistryKey(STRING keyname)
  {
    IF(GetPrimary()->IsWorkOpen())
      THROW NEW Exception("SetupTokenUsingRegistryKey cannot be used with open work"); //we need control, plus shouldn't do remote requests with open transactions

    this->token := ReadRegistryKey(keyname);

    IF(this->IsAccessTokenExpired())
    {
      // Use a mutex to prevent two processes from refreshing the access token using the same refresh token
      OBJECT lock := OpenLockManager()->LockMutex(`system:oauth2.refreshtoken.${keyname}`);
      TRY
      {
        // Another process might have updated the token, read it again
        this->token := ReadRegistryKey(keyname);

        IF(this->IsAccessTokenExpired())
        {
          RECORD refreshres := this->RefreshAccessToken();
          IF(refreshres.success)
          {
            GetPrimary()->BeginWork();
            WriteRegistryKey(keyname, this->token);
            GetPrimary()->CommitWork();
          }
          RETURN refreshres;
        }
      }
      FINALLY
      {
        lock->Release();
      }
    }
    RETURN [ success := TRUE ];
  }
>;

/** Get the default landing page for this WebHare
    @return URL to the landing page */
PUBLIC STRING FUNCTION GetDefaultOauth2RedirectURL()
{
  RETURN ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(), "/.wh/common/oauth2/");
}

/** @short Run the oauth2 landing page (normally hosted as /.wh/common/oauth2/ - use `wh auth get-callback-url` to get the preferred location)
    @param options No options available yet
*/
PUBLIC MACRO RunOAuth2LandingPage(RECORD options DEFAULTSTO DEFAULT RECORD) {
  options := ValidateOptions(CELL[], options);

  STRING sessid := GetWebVariable("state");
  IF(sessid = "")
    AbortWithHTTPError(400, "Missing state variable", [ htmlbody := `<html><head><title>OAuth endpoint</title><body>This page is the landing page for OAuth requests, and not intended to be accessed directly (missing 'state' variable)</body></html>` ]);

  RECORD sessdata;
  OBJECT connection;
  IF(sessid LIKE "ipc:*") {
    connection := ConnectToIPCPort(DecryptForThisServer("system:oauth2.portname", Substring(sessid,4)));
    IF(ObjectExists(connection)) {
      RECORD msg := connection->ReceiveMessage(MAX_DATETIME); //get state
      sessdata := msg.msg.__oauth2_authflow.state;
    }
  } ELSE {
    sessdata := GetWebSessionData(sessid, "system:oauth2");
  }

  STRING error := GetWebVariable("error");
  STRING error_description := GetWebVariable("error_description");
  IF(error != "") //Ensure we have at least 'something'
    LogDebug("system:oauth2-error", CELL[ error, error_description, state := sessid]);

  IF(NOT RecordExists(sessdata)) //We've seen mostly bots do this though, following really old URLs
    AbortWithHTTPError(400, "Session expired", [ htmlbody := `<html><head><title>Session expired</title><body>Your login attempt has expired, please try again.</body></html>` ]);

  OBJECT oauthconnection := NEW Oauth2Connection(sessdata.oauthconfig);
  RECORD tokeninfo;
  STRING code := GetWebVariable("code");
  IF(code != "")
    tokeninfo := oauthconnection->RequestToken(code,
        [ redirect_uri := CellExists(sessdata,'redirect_uri') ? sessdata.redirect_uri : ""
        , code_verifier := CellExists(sessdata,'code_verifier') ? sessdata.code_verifier : ""
        ]);

  sessdata := CELL[...sessdata, tokeninfo := tokeninfo ];

  IF(ObjectExists(connection))
  {
    connection->SendMessage(oauthconnection->__CreateFinalToken(sessdata));
    ExecuteSubmitInstruction([ type := "close" ]);
  }
  ELSE IF(CellExists(sessdata,"callback"))
  {
    RECORD finaltoken := oauthconnection->__CreateFinalToken(sessdata);
    MakeFunctionPtr(sessdata.callback)(sessdata.callbackstate, finaltoken);
  }
  ELSE
  {
    StoreWebSessionData(sessid, "system:oauth2", sessdata);
    Redirect(UpdateURLVariables(sessdata.finalreturnurl, [ oauth2session := sessid ]));
  }
}
