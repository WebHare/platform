<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "relative::awsbase.whlib";

STRING ns_s320060301 := "http://s3.amazonaws.com/doc/2006-03-01/";

PUBLIC STATIC OBJECTTYPE AmazonAWSS3Interface EXTEND AmazonAWSInterface
<
  STRING endpoint;

  /** Create a new S3 interface
      @param zone S3 zone
      @param accesskey Access key
      @param accesssecret Secret key
      @cell options.endpoint Endpoint override
  */
  MACRO NEW(STRING zone, STRING accesskey, STRING accesssecret, RECORD options DEFAULTSTO DEFAULT RECORD)
  : AmazonAWSInterface(zone, accesskey, accesssecret)
  {
    options := ValidateOptions(
        [ endpoint :=     ""
        ], options);

    this->endpoint := options.endpoint ?? `https://s3.${zone}.amazonaws.com/`;
  }

  /** List all buckets
      @return List of buckets
      @cell return.name Bucket name
      @cell return.creationdate Bucket creation date
  */
  PUBLIC RECORD ARRAY FUNCTION ListAllBuckets()
  {
    this->RawAWS4Request("s3","GET",this->endpoint);
//    this->S3Request("GET","/",DEFAULT RECORD ARRAY,DEFAULT BLOB);

    RECORD ARRAY buckets;
    FOREVERY(OBJECT bucket FROM this->browser->document->GetElementsByTagNameNS(ns_s320060301, "Bucket")->GetCurrentElements())
    {
      RECORD bucketrec := [ name := bucket->GetElementsBytagNameNS(ns_s320060301, "Name")->childrentext
                          , creationdate := MakeDateFromText(bucket->GetElementsBytagNameNS(ns_s320060301, "CreationDate")->childrentext)
                          ];
      INSERT bucketrec INTO buckets AT END;
    }
    RETURN buckets;
  }

  /** Get bucket tags
      @param bucket Bucket name
      @return List of tags
      @cell(string) return.tag Key name
      @cell(string) return.value Key value
  */
  PUBLIC RECORD ARRAY FUNCTION GetBucketTagging(STRING bucket)
  {
    STRING url := this->endpoint || bucket;

    this->RawAWS4Request("s3", "GET", url
                          , [ urlparameters := [ [ name := "tagging", value := "" ]
                                               ]]);

    RECORD ARRAY tags;
    FOREVERY(OBJECT tag FROM this->browser->document->ListElements("*","Tag"))
    {
      INSERT CELL [ tag := tag->ListChildren("*", "Key")[0]->textcontent
                  , value := tag->ListChildren("*", "Value")[0]->textcontent
                  ] INTO tags AT END;
    }
    RETURN tags;
  }

  //PUBLIC MACRO MakeBucketPublic(STRING bucket)
  //{
  //  STRING id := "MakePublic" || EncodeBase16(GetMD5Hash(bucket));
  //  STRING req :=  '{'
  //                || '"Version": "2008-10-17",'
  //                || '"Id": "' || EncodEJava(id) || '",'
  //                || '"Statement": ['
  //                  || '{ "Sid": "AllowPublicRead",'
  //                    || '"Effect": "Allow",'
  //                    || '"Principal": {"AWS": ["*"] },'
  //                    || '"Action": ["s3:GetObject"],'
  //                    || '"Resource": "arn:aws:s3:::' || EncodeJava(bucket) || '/*"'
  //                  || '}]'
  //              || '}';
  //  this->S3Request("PUT","/?policy",[[ field := "Host", value := bucket ]],StringToBlob(req));
  //}

/*
      {
 "Version": "2008-10-17",
 "Id": "Public",
 "Statement": [
              {
                "Sid": "AllowPublicRead",
                "Effect": "Allow",
                "Principal": { "AWS": ["*"] },
              "Action": ["s3:GetObject"],
              "Resource": "arn:aws:s3:::MyBucketName/*"
              }
              ]
}*/

  UPDATE MACRO ProcessAWSError()
  {
    IF(ObjectExists(this->browser->document))
    {
      OBJECT errorcodenode := this->browser->QS("Error > Code");
      OBJECT errormessagenode := this->browser->QS("Error > Message");
      IF(ObjectExists(errorcodenode) AND ObjectExists(errormessagenode))
        THROW NEW Exception(`S3: ${errorcodenode->textcontent}: ${errormessagenode->textcontent}`);
    }
    //override this for service specific error handling. they should throw on error
    THROW NEW Exception("Request failure");
  }

  /** List the contents of a bucket, paginated.
      @param bucket Bucket name
      @cell(string) options.delimiter Delimiter
      @cell(string) options.prefix Return only objects with this prefix
      @cell(string) options.marker Start listing at this marker (pass 'nextmarker' returned
          by a previous call)
      @cell(integer) options.maxkeys Maximum number of objects to return (limited to 1000)
      @return Bucket contents
      @cell(record array) return.objects List of objects
      @cell(string) return.objects.name Object name
      @cell(datetime) return.objects.lastmodified Last modification of the object
      @cell(integer) return.objects.size Size of the object
      @cell(integer64) return.objects.size64 Size of the object
      @cell(string) return.objects.etag Etag
      @cell(string array) return.commonprefixes Common prefixes grouped by delimiter (eg 'subdirectories')
      @cell(boolean) return.truncated Whether more objects are present in the bucket
      @cell(string) return.nextmarker Marker to pass to this function to get the next list of objects
  */
  PUBLIC RECORD FUNCTION GetBucket(STRING bucket, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ delimiter := "", prefix := "", marker := "", maxkeys := 1000 ], options);

    //http://docs.aws.amazon.com/AmazonS3/latest/API/RESTBucketGET.html
//    STRING path := UpdateURLVariables("/", );
//    this->S3Request("GET", path, [[ field := "Host", value := bucket ]], DEFAULT BLOB);

    STRING url := this->endpoint || bucket;

    this->RawAWS4Request("s3", "GET", url
                          , [ urlparameters := [ [ name := "delimiter", value := options.delimiter ]
                                               , [ name := "marker", value := options.marker ]
                                               , [ name := "prefix", value := options.prefix ]
                                               , [ name := "max-keys", value := ToString(options.maxkeys) ]
                                               ]]);

    RECORD ARRAY objects;
    STRING ARRAY commonprefixes;
    BOOLEAN truncated := ParseXSBoolean(this->browser->document->GetElementsByTagNameNS(ns_s320060301, "IsTruncated")->Item(0)->textcontent);
    STRING nextmarker := truncated
        ? this->browser->document->GetElementsByTagNameNS(ns_s320060301, "NextMarker")->Item(0)->textcontent
        : "";

    FOREVERY(OBJECT content FROM this->browser->document->GetElementsByTagNameNS(ns_s320060301, "Contents")->GetCurrentElements())
    {
      STRING sizestr := content->GetElementsBytagNameNS(ns_s320060301, "Size")->childrentext;
      RECORD objectrec := [ name := content->GetElementsBytagNameNS(ns_s320060301, "Key")->childrentext
                          , lastmodified := MakeDateFromText(content->GetElementsBytagNameNS(ns_s320060301, "LastModified")->childrentext)
                          , size := ParseXSInt(sizestr)
                          , size64 := ParseXSInt64(sizestr)
                          , etag := content->GetElementsBytagNameNS(ns_s320060301, "ETag")->childrentext
                          //ADDME owner id, displayname
                          ];
      INSERT objectrec INTO objects AT END;
    }

    FOREVERY (OBJECT commonprefixesnode FROM this->browser->document->ListElements(ns_s320060301, "CommonPrefixes"))
      FOREVERY(OBJECT prefix FROM commonprefixesnode->ListChildren(ns_s320060301, "Prefix"))
        INSERT prefix->textcontent INTO commonprefixes AT END;

    RETURN [ objects := objects
           , truncated := truncated
           , nextmarker := nextmarker
           , commonprefixes := commonprefixes
           ];
  }

  /** List the full contents of a bucket
      @param bucket Bucket name
      @param path Directory name
      @return @includecelldef #GetBucket.return.objects
      @cell(boolean) return.isfolder True if this object is a subdirectory (a common prefix as S3 does not have real subdirectories)
  */
  PUBLIC RECORD ARRAY FUNCTION GetDirectory(STRING bucket, STRING path)
  {
    IF(path LIKE "/*")
      path := Substring(path,1);
    IF(path != "" AND path NOT LIKE "*/") //without a slash terminator you're not getting the directory contentes and might even trigger accessdenieds
      path := path || "/";

    RECORD ARRAY results;
    STRING marker;
    WHILE (TRUE)
    {
      RECORD res := this->GetBucket(bucket, CELL[ delimiter := "/", prefix := path, marker ]);
      results := results
                 CONCAT (SELECT *, isfolder := FALSE FROM res.objects)
                 CONCAT (SELECT name := Left(name,Length(name)-1), lastmodified := DEFAULT DATETIME, size := 0, size64 := 0i64, etag := "", isfolder := TRUE FROM ToRecordArray(res.commonprefixes,'name'));
      IF (NOT res.truncated)
        BREAK;
      marker := res.nextmarker;
      IF (marker = "") // just in case
        BREAK;
    }

    RETURN results;
  }

  /** Describe the object without retrieving its contents
      @param bucket Bucket name
      @param path Path of the object
      @return Body of object, DEFAULT RECORD if the object does not exist
      @cell return.body Object contents
  */
  PUBLIC RECORD FUNCTION HeadObject(STRING bucket, STRING path)
  {
    this->RawAWS4Request("s3", "HEAD", this->PathToUrl(bucket,path), [ accept404 := TRUE ]);
    IF(this->browser->GetHTTPStatusCode()=404)
      RETURN DEFAULT RECORD;

    RETURN [ contentlength := ToInteger64(this->browser->GetResponseHeader("Content-Length"),-1)
           , contenttype := this->browser->GetResponseHeader("Content-Type")
           ];
  }

  /** Get the contents of an object
      @param bucket Bucket name
      @param path Path of the object
      @return Body of object, DEFAULT RECORD if the object does not exist
      @cell return.body Object contents
  */
  PUBLIC RECORD FUNCTION GetObject(STRING bucket, STRING path)
  {
    this->RawAWS4Request("s3", "GET", this->PathToUrl(bucket,path), [ accept404 := TRUE ]);
    IF(this->browser->GetHTTPStatusCode()=404)
      RETURN DEFAULT RECORD;
    RETURN [ body := this->browser->content ];
  }

  STRING FUNCTION PathToURL(STRING bucket, STRING path)
  {
    IF(Left(path,1)='/')
      path := Substring(path,1);
    RETURN this->endpoint || bucket || "/" || path;
  }

  /** Stores an object
      @param bucket Bucket name
      @param path Path of the object
      @param data Data for the object
      @cell(string) options.contenttype Mime-type for the object (determined automatically with %ScanBlob when not set)
      @cell(string) options.cachecontrol Optional cachecontrol settings
      @return
      @cell(string) return.etag Etag
      @cell(string) return.amzid2
      @cell(string) return.contentmd5 MD5 hash of the data
  */
  PUBLIC RECORD FUNCTION PutObject(STRING bucket, STRING path, BLOB data, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ contenttype := ""
                                , cachecontrol := ""
                                ], options);

    IF(options.contenttype = "")
      options.contenttype := ScanBlob(data, path).mimetype;

    STRING md5 := EncodeBase64(GetHashForBlob(data, "MD5"));
    RECORD ARRAY headers := [[ field := "Content-Type", value := options.contenttype ]
                            ,[ field := "Content-MD5", value := md5 ]
                            ];

    IF(options.cachecontrol != "")
      INSERT [ field := "Cache-Control", value := options.cachecontrol ] INTO headers AT END;

    this->RawAWS4Request("s3", "PUT", this->PathToUrl(bucket,path), CELL[ headers, body := data]);

    RETURN [ etag := this->browser->GetResponseHeader("ETag")
           , amzid2 := this->browser->GetResponseHeader("x-amz-id-2")
           , contentmd5 := md5
           ];
  }

  /** Copies an object
      @param bucket Bucket name
      @param sourcepath Path of the object to copy
      @param targetpath Path for the new copy
      @cell options.sourcebucket Copy the object from this bucket
      @return
      @cell(string) return.etag Etag
  */
  PUBLIC RECORD FUNCTION CopyObject(STRING bucket, STRING sourcepath, STRING targetpath, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ sourcebucket := ""
                                   , contenttype := ""
                                   , cachecontrol := ""
                                   ], options, [ Optional := ["contenttype", "cachecontrol" ]]);

    RECORD ARRAY headers := [[ field := "x-amz-copy-source", value := `${options.sourcebucket ?? bucket}/${sourcepath}` ]
                            ];
    IF(CellExists(options, "contenttype"))
      INSERT [ field := "Content-Type", value := options.contenttype ] INTO headers AT END;
    IF(CellExists(options, "cachecontrol"))
      INSERT [ field := "Cache-Control", value := options.cachecontrol ] INTO headers AT END;

    this->RawAWS4Request("s3", "PUT", this->PathToUrl(bucket, targetpath), CELL[ headers, body := DEFAULT BLOB ]);

    RETURN [ etag := this->browser->GetResponseHeader("ETag")
           ];
  }

  /** Deletes an object
      @param bucket Bucket name
      @param path Path of the object to delete
  */
  PUBLIC MACRO DeleteObject(STRING bucket, STRING path)
  {
    this->RawAWS4Request("s3", "DELETE", this->PathToUrl(bucket,path));
  }

  /** Sync the contents of a S3 directory locally (eg to grab logfiles for local processing)
      @param destpath Destination path (will be created if necessary)
      @param bucket Bucket to read from
      @param path Path to download
      @cell(datetime) options.notbefore Do not download files modified before this date
      @cell(boolean) options.printdownloads Print rpgoress
  */
  PUBLIC MACRO SyncToLocal(STRING destpath, STRING bucket, STRING path, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ notbefore := DEFAULT DATETIME
                               , printdownloads := FALSE
                               ], options);

    CreateDiskDirectoryRecursive(destpath,TRUE);

    RECORD ARRAY remotelogs := this->GetDirectory(bucket, path);
    remotelogs := SELECT *, lastmodified := GetRoundedDatetime(lastmodified, 1000) FROM remotelogs;

    RECORD ARRAY locallogs := ReadDiskDirectory(destpath, "*");
    FOREVERY(RECORD aborteddownload FROM SELECT * FROM locallogs WHERE name LIKE "*.tmpdownload")
      DeleteDiskFile(aborteddownload.path);

    FOREVERY (RECORD remotelog FROM remotelogs)
    {
      IF(remotelog.lastmodified < options.notbefore)
        CONTINUE; //too old, not interested

      STRING filename := GetNameFromPath(remotelog.name);
      RECORD match := SELECT * FROM locallogs WHERE locallogs.name = VAR filename;

      IF(RecordExists(match) AND match.size = remotelog.size AND match.modified >= remotelog.lastmodified) //our version is up to date
        CONTINUE;

      IF(options.printdownloads)
        PRINT(`Downloading ${RecordExists(match) ? "updated" : "new"} file '${filename}'... `);

      RECORD logfile := this->GetObject(bucket, remotelog.name);
      STRING finalname := MergePath(destpath, filename);
      STRING tempname := finalname || '.tmpdownload';

      StoreDiskFile(tempname, logfile.body, [ overwrite := TRUE ]);
      SetFileModificationDate(tempname, remotelog.lastmodified);
      IF(NOT MoveDiskPath(tempname, finalname))
        THROW NEW Exception(`Failed to move ${tempname} into place`);

      IF(options.printdownloads)
        PRINT(`done\n`);
    }
  }

  PUBLIC RECORD FUNCTION ListMultipartUploads(STRING bucket, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ ], options);

    this->RawAWS4Request("s3", "GET", this->PathToUrl(bucket,"")
                       , [ urlparameters := [[ name := "uploads", value := ""]]
                                            ]);

    RECORD retval := [ uploads := RECORD[] ];
    FOREVERY(OBJECT upload FROM this->browser->document->ListElements("*", "Upload"))
    {
      RECORD uploadinfo := [ uploadid := PickFirst(upload->listChildren("*", "UploadId"))->textcontent
                           , uploadkey := PickFirst(upload->listChildren("*", "Key"))->textcontent
                           ];
      INSERT uploadinfo INTO retval.uploads AT END;
    }
    RETURN retval;
  }

  PUBLIC MACRO AbortMultipartUpload(STRING bucket, STRING path, STRING uploadid)
  {
    this->RawAWS4Request("s3", "DELETE", this->PathToUrl(bucket, path)
                       , [ urlparameters := [[ name := "uploadId", value := uploadid]]
                                            ]);
  }

  PUBLIC RECORD FUNCTION CreateMultipartUpload(STRING bucket, STRING path, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ contenttype := ""
                                , cachecontrol := ""
                                ], options);

    RECORD ARRAY headers;
    IF(CellExists(options, "contenttype"))
      INSERT [ field := "Content-Type", value := options.contenttype ] INTO headers AT END;
    IF(CellExists(options, "cachecontrol"))
      INSERT [ field := "Cache-Control", value := options.cachecontrol ] INTO headers AT END;


    this->RawAWS4Request("s3", "POST", this->PathToUrl(bucket,path)
                       , [ headers := headers
                         , urlparameters := [[ name := "uploads", value := ""]]
                                            ]);
    OBJECT initiatemultipartuploadresult := this->browser->document->documentelement;
    RETURN CELL[ bucket := Pickfirst(initiatemultipartuploadresult->ListChildren("*","Bucket"))->textcontent
               , uploadkey := Pickfirst(initiatemultipartuploadresult->ListChildren("*","Key"))->textcontent
               , uploadid := Pickfirst(initiatemultipartuploadresult->ListChildren("*","UploadId"))->textcontent
               ];
  }

  PUBLIC RECORD ARRAY FUNCTION GenerateUploadPartURLs(RECORD upload, INTEGER64 expectedsize)
  {
    //divide in up to 1000 parts, but never smaller than 5MB
    INTEGER64 partsize := MAX[](INTEGER64[5*1024*1024, expectedsize / 999]);

    //and generate the parts!
    RECORD ARRAY urls;
    INTEGER64 off := 0, bytesleft := expectedsize;
    WHILE(bytesleft > 0)
    {
      RECORD req := this->PrepareAWS4Request("s3", "PUT", this->PathToUrl(upload.bucket, upload.uploadkey),
          [ signedrequest := TRUE
          , urlparameters := [[ name := "partNumber", value := ToString(Length(urls) + 1) ]
                             ,[ name := "uploadId", value := upload.uploadid ]
                             ]
          , expires := 86400 //one day
          , unsignedpayload := TRUE
          ]);

      INTEGER size := INTEGER(MIN[]([bytesleft, partsize]));
      INSERT CELL[ off := off
                 , size := size
                 , req.url
                 ] INTO urls AT END;

      bytesleft := bytesleft - size;
      off := off + size;
    }
    RETURN urls;
  }

  PUBLIC RECORD FUNCTION CompleteMultipartUpload(RECORD upload, STRING ARRAY etags)
  {
    RECORD ARRAY parts := SELECT partnumber := #etags + 1
                               , etag
                            FROM ToRecordArray(etags,"etag") AS etags;
    BLOB body := LoadWittyLibrary(Resolve("s3.witty"), "XML")->RunComponentToBlob("completemultipartupload", CELL[ parts ]);
    this->RawAWS4Request("s3", "POST", this->PathToUrl(upload.bucket, upload.uploadkey)
                       , [ urlparameters := [[ name := "uploadId", value := upload.uploadid]
                                            ]
                         , body := body
                         , headers := [[ field := "Content-Type", value := "text/xml" ]]
                         ]);

    OBJECT completemultipartuploadresult := this->browser->document->documentelement;
    RETURN CELL[ bucket := Pickfirst(completemultipartuploadresult->ListChildren("*","Bucket"))->textcontent
               , location := Pickfirst(completemultipartuploadresult->ListChildren("*","Location"))->textcontent
               , objectkey := Pickfirst(completemultipartuploadresult->ListChildren("*","Key"))->textcontent
               , etag := Pickfirst(completemultipartuploadresult->ListChildren("*","ETag"))->textcontent
               ];
  }
>;


