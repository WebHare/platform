<?wh

/** @topic modules/migrations */

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";

INTEGER64 ARRAY FUNCTION GetInstanceTreeIds(INTEGER64 settingid)
{
  // recursively build a list to our parent.
  RETURN settingid != 0 ? GetInstanceTreeIds(SELECT AS INTEGER64 parent FROM system.fs_settings WHERE id = settingid) CONCAT [settingid] : INTEGER64[];
}
RECORD ARRAY FUNCTION SortByDepth(RECORD ARRAY todolist)
{
  RETURN SELECT * FROM todolist ORDER BY Length(GetInstanceTreeIds(settingid)) DESC;
}

/** Convert contenttypes
    @long Rewrite content types (and widgets) to the specified type. Instances (eg widgets in RTDs) of the source type will be changed to the destination type
    @param srctype Source instance type
    @cell(function ptr) options.mapcallback Callback to invoke on instance records for conversion. If it returns a DEFAULT RECORD, this instance will not be converted
    @cell(string) options.desttype Destination type. If empty, assumed to equal the source type
    @cell(boolean) options.sourceorphans Open source type and data as an oprhan (access deleted types and members)
    @return A list of fsobjects converted, suitable for passing into %RepublishWHFSObjectReferences
    @cell(integer array) return.fsobject fsobject ID containing the instance
    */
PUBLIC RECORD ARRAY FUNCTION ConvertContentType(STRING srctype, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ mapcallback := DEFAULT FUNCTION PTR
                              , desttype := srctype
                              , sourceorphans := FALSE
                              ], options);

  OBJECT type := OpenWHFSType(srctype, [ openorphans := options.sourceorphans ]);
  IF(NOT ObjectExists(type) OR type->id = 0)
    THROW NEW Exception(`No such source whfs type '${srctype}'`);

  OBJECT desttype := options.desttype != srctype ? OpenWHFSType(options.desttype) : type;
  IF(NOT ObjectExists(type) OR desttype->id = 0)
    THROW NEW Exception(`No such destination whfs type '${options.desttype}'`);

  RECORD ARRAY refs;
  RECORD ARRAY todolist := type->ListAllInstances();
  //doing bottom-up prevents us from prematurely invalidating rows from ListInstances (Because setting a parent rewrote the IDs)
  todolist := SortByDepth(todolist);

  FOREVERY(RECORD instance FROM todolist)
  {
    RECORD data := type->GetInstanceDataByDirectRef(instance.directref, [ orphans := options.sourceorphans ]);
    IF(NOT RecordExists(data))
      THROW NEW Exception("Instance disappeared during conversion!"); //is our bottom-up approach broken?

    IF(options.mapcallback != DEFAULT FUNCTION PTR)
    {
      data := options.mapcallback(data, CELL[ fsobject := instance.fsobject
                                            ]);
      IF(NOT RecordExists(data))
        CONTINUE;
    }

    INSERT [ fsobject := instance.fsobject ] INTO refs AT END;
    DELETE CELL whfsfileid, whfssetingid, whfstype FROM instance;

    IF(CellExists(data, 'whfstype'))
      data.whfstype := desttype->namespace;

    desttype->SetInstanceDataByDirectRef(instance.directref, data, [ isvisibleedit := FALSE, ifreadonly := "update" ]);

    IF(desttype->namespace != type->namespace AND instance.settingid = 0) //top level, so we should explicitly delete..
      type->SetInstanceData(instance.fsobject, type->defaultinstance, [ isvisibleedit := FALSE, ifreadonly := "update" ]);
  }

  RETURN refs;
}
