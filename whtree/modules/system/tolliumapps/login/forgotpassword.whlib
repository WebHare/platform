<?wh

LOADLIB "wh::crypto.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/screens/userrights/support.whlib";

LOADLIB "mod::wrd/lib/auth/passwordpolicy.whlib";


PUBLIC STATIC OBJECTTYPE ForgotPassword EXTEND TolliumScreenBase
<
  MACRO Init()
  {
    IF(NOT ReadRegistryKey("system.backend.security.allowpasswordreset"))
    {
      this->tolliumresult := "cancel";
      RETURN;
    }
  }

  BOOLEAN FUNCTION OnEmailNext()
  {
    OBJECT work := this->BeginWork([validate := OBJECT[^email]]);
    IF(NOT work->Finish())
      RETURN FALSE;

    OBJECT wrdauth := this->contexts->controller->wrdauthplugin;
    wrdauth->HandleForgotPassword(^email->value, [ currenturl := this->contexts->controller->baseurl ]);
    RETURN TRUE;
  }
>;

PUBLIC STATIC OBJECTTYPE ResetPassword EXTEND TolliumScreenBase
<
  OBJECT userentity;
  STRING ed;
  STRING verifier;
  STRING validationchecks;

  MACRO Init()
  {
    //If you get here, the policy was allowing password resets when you sent the request, so no need to double check it

    this->ed := SELECT AS STRING value FROM this->contexts->controller->webvariables WHERE name = "_ed";
    this->verifier := SELECT AS STRING value FROM this->contexts->controller->webvariables WHERE name = "verifier";
    RECORD result := this->contexts->controller->wrdauthplugin->ProcessVerificationLink(this->ed, this->verifier);

    OBJECT wrdschema := this->contexts->userapi->wrdschema;
    this->userentity := wrdschema->accounttype->GetEntity(result.entityid);

    IF(result.expired OR result.failed OR NOT ObjectExists(this->userentity))
    {
      this->RunSimpleScreen("error", this->GetTid(".linkisexpired"));
      this->tolliumresult := "cancel";
      RETURN;
    }

    ^verificationcode->visible := result.success = FALSE;
    ^verificationcodeexplain->visible := ^verificationcode->visible;
    ^verificationcode->required := ^verificationcode->visible;

    ^username->value := this->userentity->GetField(wrdschema->accountlogintag);

    RECORD policy := GetPolicyForUser(this->contexts, result.entityid);
    this->validationchecks := policy.passwordvalidationchecks;
    RECORD ARRAY parsed := ParsePasswordChecks(policy.passwordvalidationchecks);

    INTEGER minlength :=
        (SELECT AS INTEGER value + 1
           FROM parsed
          WHERE check = "minlength") - 1;

    ^password->minlength := minlength > 0 ? minlength : -1;
    ^password->showcounter := minlength > 0;
    ^validationchecksfield->value := DescribePasswordChecks(policy.passwordvalidationchecks);
    ^validationchecksfield->visible := ^validationchecksfield->value != "";
  }
  BOOLEAN FUNCTION Submit()
  {
    RECORD result := this->contexts->controller->wrdauthplugin->ProcessVerificationLink(this->ed, ^verificationcode->value ?? this->verifier);

    OBJECT wrdschema := this->contexts->userapi->wrdschema;
    OBJECT work := this->BeginWork();
    IF(^password->value != ^passwordrepeat->value AND ^passwordrepeat->value != "")
      work->AddErrorFor(^passwordrepeat, GetTid("tollium:common.errors.passwordmismatch"));
    ELSE IF (this->validationchecks != "")
    {
      RECORD rec := CheckPassword(this->validationchecks, ^password->value);
      IF (NOT rec.success)
        work->AddErrorFor(^password, rec.message);
    }

    IF(NOT result.success)
      IF(result.failed_incorrectverifier)
        work->AddErrorFor(^verificationcode, this->GetTid(".verifiermismatch"));
      ELSE
        work->AddError(this->GetTid(".linkisexpired"));

    IF(NOT work->HasFailed())
    {
      this->userentity->UpdateEntity(CellInsert(CELL[], wrdschema->accountpasswordtag, CreateWebharePasswordHash(^password->value)));
      work->AddWarning(this->GetTid(".passwordupdated"));
    }

    RETURN work->Finish();
  }
>;
