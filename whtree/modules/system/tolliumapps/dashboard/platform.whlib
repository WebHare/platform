<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::os.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/screenbase.whlib";

LOADLIB "mod::system/lib/tasks.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/checks.whlib";
LOADLIB "mod::system/lib/internal/checks/checker.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/screenbase.whlib";


PUBLIC STATIC OBJECTTYPE PlatformPanel EXTEND DashboardPanelBase
<
  RECORD ARRAY columns;

  MACRO Init()
  {
    this->columns := ^results->columns;
    this->OnWithHistoryChange();
  }

  UPDATE PUBLIC INTEGER FUNCTION GetSuggestedRefreshFrequency()
  {
    RETURN 0; //no auto refresh
  }

  UPDATE PUBLIC MACRO RefreshDashboardPanel()
  {
    ^results->Invalidate();
    this->RefreshPlatformInfo();
  }

  /** @short This monitor has been activated, start refreshing */
  UPDATE PUBLIC MACRO EnableRefresh()
  {
    ^results->eventmasks := OpenWRDSchema("system:config")->^server_check->GetEventMasks();
  }
  /** @short This monitor has been deactivated, stop refreshing */
  UPDATE PUBLIC MACRO DisableRefresh()
  {
    ^results->eventmasks := STRING[];
  }

  MACRO RefreshPlatformInfo()
  {
    // get the system description
    STRING systemdescr := GetSystemOsName();

    IF (GetSystemNumProcessors() > 1)
      systemdescr := systemdescr || "; " || GetSystemNumProcessors() || " CPUs";

    // get the server uptime
    RECORD startupdata := EnforceStructure([ start := DEFAULT DATETIME], PollWHServiceState("startup"));
    DATETIME boottime := startupdata.start;
    DATETIME webserverboottime := GetHostingProcessStartTime();
    DATETIME now := GetCurrentDatetime();

    INTEGER numdays := GetDayCount(now) - GetDayCount(boottime);
    INTEGER numMsecs := GetMsecondCount(now) - GetMsecondCount(boottime);

    INTEGER numwebdays := GetDayCount(now) - GetDayCount(webserverboottime);
    INTEGER numwebMsecs := GetMsecondCount(now) - GetMsecondCount(webserverboottime);

    ///////////////////////////////////////////////////////////////////////////////
    //
    // Setup the page
    //

    RECORD versioninfo := GetWHVersionInfo();
    STRING restoreinfo := GetEnvironmentVariable("WEBHARE_ISRESTORED");
    IF(restoreinfo != "")
      restoreinfo := restoreinfo = "1" ? " / restored" : " (" || restoreinfo || ")";

    ^txtServer->value      := versioninfo.versionname || " " || GetDTAPStage() || restoreinfo;
    ^buildinfo->value      := versioninfo.built;
    ^buildinfo->visible    := versioninfo.built != "";
    ^txtPlatform->value    := systemdescr;
    ^txtDateTime->value    := this->tolliumuser->FormatDateTime(now, "minutes", TRUE, FALSE);
    ^txtUptime->value      := this->Gettid(".uptimedata",
                                  this->tolliumuser->FormatTimespan(numdays, nummsecs, "minutes"),
                                  this->tolliumuser->FormatDateTime(boottime, "minutes", TRUE, FALSE),
                                  this->tolliumuser->FormatTimespan(numwebdays, numwebmsecs, "minutes"),
                                  this->tolliumuser->FormatDateTime(webserverboottime, "minutes", TRUE, FALSE));

    ^results->Invalidate();
  }

  MACRO OnWithHistoryChange()
  {
    ^results->columns := SELECT * FROM this->columns WHERE (name != "stopped" OR ^withhistory->value);
    ^results->Invalidate();
  }

  RECORD ARRAY FUNCTION OnGetErrors()
  {
    RECORD ARRAY messages :=
         SELECT TEMPORARY rowicon := snoozed ? 2 : stopped = DEFAULT DATETIME ? is_critical ? 3 : 1 : 0
              , *
              , message :=      message_text
              , sortmessage :=  (rowicon = 3 ? "0" : "1") || ToLowercase(message_text) //sort critical issues first, reusing rowicon's evaluation
              , canjumpto :=    RecordExists(jump_to)
              , cansnooze :=    is_manageable AND NOT snoozed
              , canunsnooze :=  is_manageable AND snoozed
              , canrecheck :=   is_manageable AND CellExists(row, "CHECK_TASK") AND row.check_task != ""
              , rowicon :=      rowicon
           FROM GetCurrentCheckIssues( [ withhistory := ^withhistory->value ]) AS row;

    RETURN messages;
  }

  MACRO DoGotoTask()
  {
    RECORD jumpto := ^results->selection[0].jump_to;
    STRING reusemode := CellExists(jumpto,'reusemode') ? jumpto.reusemode : "whennotbusy";
    IF(CellExists(jumpto,'target'))
      this->tolliumcontroller->StartApplication(jumpto.app, jumpto.target, DEFAULT RECORD, CELL[ reusemode ]);
    ELSE //legacy approach... using target is safer!
      this->tolliumcontroller->StartApplication(jumpto.app, DEFAULT RECORD, jumpto, CELL[ reusemode ]);
  }

  MACRO DoDetails()
  {
    IF(^results->value[0] > 0)
      this->RunScreen("#details", [ id := ^results->value[0] ]);
    ELSE //eg 'periodic status checks are failing'. these don't exist in the database so we can't open the details
      this->RunSimpleScreen("info", ^results->selection[0].message_text);
  }

  MACRO DoSnooze()
  {
    this->RunScreen("#snooze", [ tosnooze := ^results->selection ]);
  }
  MACRO DoUnSnooze()
  {
    IF(this->RunSimpleScreen("confirm", this->GetTid(".confirm-unsnooze")) != "yes")
      RETURN;

    OBJECT work := this->BeginUnvalidatedWork();
    FOREVERY (INTEGER id FROM ^results->value)
      UnsnoozeIssue(id);

    work->Finish();
  }

  MACRO DoRecheck()
  {
    OBJECT work := this->BeginUnvalidatedWork();
    ScheduleTimedTask(^results->selection[0].check_task);
    IF (work->Finish())
      this->RunSimpleScreen("info", this->GetTid(".recheck-scheduled"));
  }

  MACRO DoRunIntervalChecks()
  {
    OBJECT work := this->BeginUnvalidatedWork();
    ScheduleTimedTask("system:intervalchecks");
    IF (work->Finish())
      this->RunSimpleScreen("info", this->GetTid(".intervalchecks-scheduled"));
  }

  MACRO DoEditCustomCheckMessages()
  {
    this->RunScreen("platform.xml#customcheckmessages", DEFAULT RECORD);
  }
>;

PUBLIC STATIC OBJECTTYPE Snooze EXTEND DashboardPanelBase
<
  RECORD ARRAY items;

  MACRO NEW()
  {
    this->contexts->wrdschema := OpenWRDSchema("system:config");
  }
  MACRO Init(RECORD data)
  {
    this->items := data.tosnooze;

    // After 9:00 local time, place next at the next day
    DATETIME next := AddTimeToDate(15 * 60 * 60 * 1000, UTCToLocal(GetCurrentDateTime(), "CET"));
    next := GetRoundedDateTime(next, 86400 * 1000);

    // Always at 10:00, on workdays
    next := AddTimeToDate(10 * 60 * 60 * 1000, next);
    IF (UnpackDateTime(next).dayofweek >= 6) // saturday or sunday
      next := AddDaysToDate(8 - UnpackDateTime(next).dayofweek, next);
    next := LocalToUTC(next, "CET");

    ^until->value := next;

    IF (LENGTH(this->items) = 1)
    {
      ^messagetidatsnooze->value := this->items[0].message_text;

       //offer last snooze message as a prefill
      RECORD lastsnoozemessage := SELECT * FROM this->contexts->wrdschema->^server_check_history->RunQuery(
          [ outputcolumns := CELL[ "comment","wrd_creationdate"]
          , filters := [ [ field := "wrd_leftentity", value := data.tosnooze[0].rowkey ]
                       , [ field := "event", value := "snooze" ]
                       ]
          , historymode := "all"
          ]) ORDER BY wrd_creationdate DESC;

      IF(RecordExists(lastsnoozemessage))
        ^comment->value := lastsnoozemessage.comment;
    }
    ELSE
    {
      ^messagetidatsnooze->value := this->GetTid(".multiplemessages");
    }
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    IF (^until->value < GetCurrentDateTime())
      work->AddErrorFor(^until, this->GetTid(".untilinpast"));
    IF (work->HasFailed())
      RETURN work->Finish();

    FOREVERY (RECORD rec FROM this->items)
      SnoozeIssue(rec.rowkey, ^until->value, [ comment := ^comment->value, whuser := this->contexts->user->GetUserDataForLogging() ]);

    RETURN work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE Details EXTEND TolliumScreenBase
<
  MACRO NEW()
  {
    this->contexts->wrdschema := OpenWRDSchema("system:config");
  }
  MACRO Init(RECORD data)
  {
    ^entity->Load(data.id);
    RECORD ARRAY history := this->contexts->wrdschema->^server_check_history->RunQuery(
        [ outputcolumns := CELL[ "wrd_id", "event","message_text","comment","wh_user","wrd_creationdate"]
        , filters := [ [ field := "wrd_leftentity", value := data.id ]
                     ]
        ]);
    ^history->rows := SELECT rowkey := wrd_id
                           , event := GetTid("system:tolliumapps.dashboard.platform.eventtypes." || event)
                           , message := event="snooze" ? comment : message_text
                           , wh_user := CellExists(wh_user,"login") ? wh_user.login : ""
                           , when := wrd_creationdate
                        FROM history;
    ^entity->^wrd_limitdate->visible := ^entity->^wrd_limitdate->value != MAX_DATETIME;
    ^entity->^more_info_link->visible := ^entity->^more_info_link->value != "";

    IF(this->contexts->user->ShowDeveloperOptions())
    {
      RECORD metafields := ^entity->wrdentity->Getfields(CELL["metadata","type","check_task"]);
      ^metadata->value := EncodeJSON(metafields);
    }
    ELSE
    {
      ^metadata->visible := FALSE;
    }

    RECORD lastsnooze := SELECT * FROM history WHERE event="snooze" ORDER BY wrd_creationdate DESC;
    IF(RecordExists(lastsnooze))
    {
      ^lastsnoozedby->value := CellExists(lastsnooze.wh_user,"login") ? lastsnooze.wh_user.login : "";
      ^lastsnoozemessage->value := lastsnooze.comment;
    }
    ELSE
    {
      ^entity->^snoozed_until->visible := FALSE;
      ^lastsnoozedby->visible := FALSE;
      ^lastsnoozemessage->visible := FALSE;
    }
  }
>;

STRING FUNCTION MapConditionType(STRING type)
{
  SWITCH (type)
  {
    CASE "webhareVersion"       { RETURN GetTid("system:tolliumapps.dashboard.platform.customcheckmessages.conditiontypes.webhareversion"); }
    CASE "dateRange"             { RETURN GetTid("system:tolliumapps.dashboard.platform.customcheckmessages.conditiontypes.fromdate"); }
    CASE "moduleVersion"        { RETURN GetTid("system:tolliumapps.dashboard.platform.customcheckmessages.conditiontypes.moduleversion"); }
    DEFAULT                     { RETURN type; }
  }
}

STRING FUNCTION EncodeCondition(RECORD conditionrow)
{
  SWITCH (conditionrow.type)
  {
    CASE "webhareVersion"
      {
        RETURN conditionrow.semver_range;
      }
    CASE "dateRange"
      {
        RETURN conditionrow.date_range;
      }
    CASE "moduleVersion"
      {
        RETURN conditionrow.module || " " || conditionrow.semver_range;
      }
    DEFAULT
      {
        RETURN "";
      }
  }
}

STRING FUNCTION EncodeMultipleConditions(RECORD ARRAY conditions)
{
  RETURN Detokenize((SELECT AS STRING ARRAY `${MapConditionType(type)}: ${EncodeCondition(conditions)}` FROM conditions), ", ");
}

PUBLIC STATIC OBJECTTYPE CustomCheckMessages EXTEND TolliumScreenBase
< MACRO NEW()
  {
    this->contexts->wrdschema := OpenWRDSchema("system:config");
  }

  MACRO Init(RECORD data)
  {
  }

  RECORD ARRAY FUNCTION OnMapCustomCheckMessageRows(RECORD ARRAY baserows)
  {
    RETURN
        SELECT *
             , conditions := EncodeMultipleConditions(conditions.conditions)
          FROM baserows;
  }
>;

PUBLIC STATIC OBJECTTYPE CustomCheckMessage EXTEND WRDEntityEditScreenBase
< BOOLEAN initializing;

  UPDATE MACRO Init(RECORD data)
  {
    ^moduleVersion_module->options := ToRecordArray(GetInstalledModuleNames(), "TITLE");
    this->initializing := TRUE;
    WRDEntityEditScreenBase::Init(data);
    this->initializing := FALSE;
    this->GotAnyChange();
  }

  MACRO GotAnyChange()
  {
    IF (this->initializing)
      RETURN;

    OBJECT feedback := this->BeginFeedback();
    RECORD ARRAY conditions := this->ReadConditionsFromComponents(feedback);
    IF (feedback->HasFailed())
    {
      ^checkresult->value := ObjectExists(feedback->errors[0].comp)
          ? `${feedback->errors[0].comp->errorlabel ?? feedback->errors[0].comp->title}: ${feedback->errors[0].text}`
          : feedback->errors[0].text;
    }
    ELSE
    {
      RECORD fails := CheckCustomMessageConditions(conditions).failingcondition;
      IF (RecordExists(fails))
      {
        STRING name := fails.type;
        SWITCH (fails.type)
        {
          CASE "webhareVersion" { name := this->GetTid(".webhareversion"); }
          CASE "dateRange" { name := this->GetTid(".date"); }
          CASE "moduleVersion" { name := this->GetTid(".moduleversion"); fails.current := fails.current ?? this->GetTid(".nosuchmodule"); }
        }
        ^checkresult->value := this->GetTid(".conditionfails", name, fails.current);
      }
      ELSE
        ^checkresult->value := this->GetTid(".allconditionsmatch");
    }
    feedback->Cancel();
    ^dirtylistener->ClearDirty();
  }

  RECORD FUNCTION GotLoad(RECORD data)
  {
    this->InitConditionsView(data.conditions.conditions);
    RETURN data;
  }

  MACRO InitConditionsView(RECORD ARRAY conditions)
  {
    RECORD ARRAY parsed := CheckCustomMessageConditions(conditions).parsed;
    FOREVERY (RECORD row FROM parsed)
    {
      IF (NOT RecordExists(row.parsed))
        CONTINUE;

      SWITCH (row.type)
      {
        CASE "webhareVersion"
          {
            ^webhareVersion->value := TRUE;
            ^webhareVersion_semver_range->value := row.semver_range;
          }
        CASE "dateRange"
          {
            ^dateRange_fromdate->value := row.parsed.date_from;
            IF (row.parsed.date_from != MAX_DATETIME)
              ^dateRange_untildate->value := row.parsed.date_until;
          }
        CASE "moduleVersion"
          {
            ^moduleVersion->value := TRUE;
            ^moduleVersion_module->value := row.module;
            ^moduleVersion_semver_range->value := row.semver_range;
          }
      }
    }
  }

  RECORD ARRAY FUNCTION ReadConditionsFromComponents(OBJECT work)
  {
    RECORD ARRAY conditions;
    IF (^webhareversion->value)
    {
      IF (IsValueSet(ImportJS("semver")->validRange(^webhareVersion_semver_range->value)))
        INSERT CELL[ type := "webhareVersion", semver_range := ^webhareVersion_semver_range->value ] INTO conditions AT END;
      ELSE IF (ObjectExists(work))
        work->AddErrorFor(^webhareVersion_semver_range, this->GetTid(".notavalidsemverrange"));
    }
    IF (^dateRange->value)
    {
      IF (IsValueSet(^dateRange_fromdate->value) OR IsValueSet(^dateRange_untildate->value))
      {
        STRING date_range := "";
        IF (IsValueSet(^dateRange_fromdate->value))
          date_range := ">= " || FormatISO8601DateTime(^dateRange_fromdate->value) || " ";
        IF (IsValueSet(^dateRange_untildate->value))
          date_range := date_range || "< " || FormatISO8601DateTime(^dateRange_untildate->value) || " ";
        INSERT CELL[ type := "dateRange", date_range := TrimWhitespace(date_range) ] INTO conditions AT END;
      }
      ELSE IF (ObjectExists(work))
        work->AddErrorFor(^dateRange_fromdate, this->GetTid(".atleastonedaterequired"));
    }
    IF (^moduleVersion->value)
    {
      IF (IsValueSet(ImportJS("semver")->validRange(^moduleVersion_semver_range->value)))
        INSERT CELL[ type := "moduleVersion", module := ^moduleVersion_module->value, semver_range := ^moduleVersion_semver_range->value ] INTO conditions AT END;
      ELSE IF (ObjectExists(work))
        work->AddErrorFor(^moduleVersion_semver_range, this->GetTid(".notavalidsemverrange"));
    }
    RETURN conditions;
  }

  UPDATE RECORD FUNCTION Submitter(OBJECT work, RECORD updatevalue)
  {
    RETURN CELL[ ...updatevalue, conditions := [ conditions := this->ReadConditionsFromComponents(work) ] ];
  }
>;
