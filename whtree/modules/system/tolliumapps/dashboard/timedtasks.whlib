<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/screenbase.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";



PUBLIC STATIC OBJECTTYPE TimedTasks EXTEND DashboardPanelBase <
  UPDATE PUBLIC MACRO RefreshDashboardPanel()
  {
    ^tasks->Invalidate();
    ^runningtasks->Invalidate();
  }

  MACRO OnMessage(RECORD message)
  {
    IF (CellExists(message, "TASKID") AND message.taskid > 0)
      ^tasks->value := message.taskid;
  }

  INTEGER FUNCTION GetTaskIcon(RECORD task)
  {
    STRING iconname;

    IF (NOT task.enabled OR (task.inapplicable != "" AND task.inapplicable NOT LIKE "*allowifrestore*")) //very ugly approach, we should probably get better state by directly communicating with the executetasks script
      iconname := "tollium:status/negative";
    ELSE IF(task.nexttime != DEFAULT DATETIME AND task.nexttime < GetCurrentDatetime())
      iconname := "tollium:status/wait";
    ELSE IF (task.error != "")
      iconname := "tollium:status/serious_error";
    ELSE
      iconname := "tollium:status/checked";

    RETURN ^tasks->GetIcon(iconname);
  }

  RECORD ARRAY FUNCTION OnGetTasks()
  {
    RECORD ARRAY newlist := SELECT TEMPORARY isenabled := enabled AND inapplicable = ""
                                 , error
                                 , inapplicable
                                 , running :=     currentstart = DEFAULT DATETIME ? 0 : ^tasks->GetIcon("tollium:status/neutral")
                                 , currentstart
                                 , nexttime
                                 , script
                                 , description
                                 , rowkey := id
                                 , enabled  //raw from the database
                                 , isenabled := isenabled //this one is conditional on 'inapplicable'
                                 , listrowclasses := isenabled ? STRING[] : STRING["grayedout"]
                                 , tag := Substitute(tag, '.', ':') //database records them with a '.' because that's how old WebHares initially stored the tags
                                 , canreschedulefailed := isenabled AND error != "" AND nexttime > GetCurrentDatetime()
                              FROM system_internal.tasks;

    ^rescheduleallfailed->enabled := RecordExists(SELECT FROM newlist WHERE canreschedulefailed);
    RETURN SELECT *, icon := this->GetTaskIcon(newlist) FROM newlist;
  }

  RECORD ARRAY FUNCTION OnGetRunningTasks() {
    RECORD ARRAY newlist;

    OBJECT link := ConnectToGlobalIPCPort("system:executetasks");
    IF (ObjectExists(link) AND link->SendMessage([ task := "listprocesses" ]).status = "ok") {
      RECORD retval := link->ReceiveMessage(AddTimeToDate(250, GetCurrentDateTime()));
      IF (retval.status = "ok" AND retval.msg.status = "ok") {
        newlist :=
            SELECT rowkey :=    procid
                 , procid
                 , taskid
                 , script
                 , tag
                 , starttime
                 , killtime
              FROM retval.msg.processes;
        ^runningtasks->empty := this->GetTid(".notasksrunning");
      } ELSE
        ^runningtasks->empty := this->GetTid(".notavailable");
    } ELSE
      ^runningtasks->empty := this->GetTid(".notavailable");

    IF(ObjectExists(link))
      link->Close();

    RETURN newlist;
  }

  MACRO DoTaskProperties()
  {
    this->RunScreen("#taskproperties", [ id := ^tasks->value ]);
  }

  MACRO DoScheduleTaskNow()
  {
    OBJECT work := this->BeginWork();
    UPDATE system_internal.tasks SET nexttime := GetCurrentDatetime() WHERE id = ^tasks->value;
    GetPrimary()->BroadcastOnCommit("system:internal.scantasks", DEFAULT RECORD);
    work->AddWarning(this->GetTid(".taskscheduled"));
    work->Finish();
  }

  MACRO DoRescheduleAllFailed()
  {
    RECORD ARRAY toreschedule := SELECT * FROM ^tasks->rows WHERE canreschedulefailed;
    OBJECT work := this->BeginWork();
    UPDATE system_internal.tasks SET nexttime := GetCurrentDatetime() WHERE id IN (SELECT AS INTEGER ARRAY rowkey FROM toreschedule);
    work->AddWarning(this->GetTid(".rescheduledfailedtasks", ToString(Length(toreschedule))));
    GetPrimary()->BroadcastOnCommit("system:internal.scantasks", DEFAULT RECORD);
    work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE taskproperties EXTEND TolliumScreenBase
<
  INTEGER id;

  MACRO Init(RECORD data)
  {
    this->id := data.id;

    RECORD taskinfo := SELECT * FROM system_internal.tasks WHERE id=data.id;
    STRING commandline := `wh run ${taskinfo.script}`;
    IF(taskinfo.parameters LIKE " |params| *")
    {
      STRING ARRAY cmdlineargs := DecodeHSON(Substring(taskinfo.parameters,10));
      FOREVERY(STRING arg FROM cmdlineargs)
        IF(arg = GetSafeName(arg)) //crude detection whether it needs an escape
          commandline := commandline || " " || arg;
        ELSE
          commandline := commandline || ' "' || EncodeJava(arg) || '"';
    }

    ^description->value := taskinfo.description;
    ^commandline->value := commandline;
    ^tag->value := taskinfo.tag;
    ^lastmessages->value := taskinfo.error;
    ^nexttime->value := taskinfo.nexttime;
    ^enabled->enabled := taskinfo.enabled OR taskinfo.inapplicable = "";
    ^enabled->value := taskinfo.enabled;
    ^inapplicable->value := taskinfo.inapplicable;
    ^inapplicable->visible := taskinfo.inapplicable != "";

    ^timeout->value := taskinfo.timeout > 0 ? taskinfo.timeout || " " || GetTid("tollium:common.units.minutes")
                                                 : this->GetTid(".defaulttimeout", ReadRegistryKey("system.tasks.defaulttimeout") || " " || GetTid("tollium:common.units.minutes"));
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    UPDATE system_internal.tasks
           SET nexttime := ^nexttime->value
             , enabled := ^enabled->value
           WHERE id=this->id;
    GetPrimary()->BroadcastOnCommit("system:internal.scantasks", DEFAULT RECORD);
    RETURN work->Finish();
  }
>;
