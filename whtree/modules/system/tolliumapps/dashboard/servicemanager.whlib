<?wh
LOADLIB "mod::system/lib/screenbase.whlib";

LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/services/apprunner.whlib";

/////////////////////////////////////////////////////////////////////
//
// Service Manager (AppRunner controller)
//
PUBLIC STATIC OBJECTTYPE ServiceManager EXTEND DashboardPanelBase
<
  UPDATE PUBLIC INTEGER FUNCTION GetSuggestedRefreshFrequency()
  {
    RETURN 1;
  }
  /** @short This monitor has been activated, start refreshing */
  UPDATE PUBLIC MACRO EnableRefresh()
  {
    ^listener->enabled := TRUE;
  }
  /** @short This monitor has been deactivated, stop refreshing */
  UPDATE PUBLIC MACRO DisableRefresh()
  {
    ^listener->enabled := FALSE;
  }

  UPDATE MACRO OnMessage(RECORD msg)
  {
    IF (CellExists(msg, "service"))
      ^applist->value := msg.service;
  }

  MACRO OnAppRunnerRefreshEvent(RECORD ARRAY events)
  {
    this->RefreshDashboardPanel();
  }

  UPDATE PUBLIC MACRO RefreshDashboardPanel()
  {
    TRY
    {
      RECORD ARRAY hs_services := ListRunningServices();

      ^applist->rows :=
            SELECT TEMPORARY ondemand := run != "always"
                 , rowkey := name
                 , icon :=        NOT enabled
                                      ? 3 // not enabled
                                      : running
                                            ? ondemand
                                                  ? 4 // neutral (task running)
                                                  : 1 // checked (running now)
                                            : ondemand
                                                  ? lasterror IN [ "Terminated", "" ]
                                                        ? 1 // checked, should not be running
                                                        : 2
                                                  : 2 // terminated
                 , type :=        run = "always" ? this->GetTid(".persistent")
                                    : run = "on-demand" ? this->GetTid(".ondemand")
                                    : run = "once" ? this->GetTid(".startup")
                                    : run = "softreset" ? this->GetTid(".softreset")
                                    : run
                 , status :=      running
                                      ? this->GetTid(".running")
                                      : lasterror IN [ "", "Terminated" ] AND ondemand
                                            ? this->GetTid(".inactive")
                                            : this->GetTid(".notrunning")
                 , owner
                 , since
                 , lasterror :=   lasterror = "Terminated" AND ondemand ? "" : lasterror
                 , regkey
                 , canedit :=     regkey != ""
                 , canenable :=   owner = "system:apprunner"
                 , enabled
                 , pid :=         pid <= 0 ? "" : ToString(pid)
              FROM ListRunningServices()
          ORDER BY name;

      ^applist->empty := ""; //this is currently not happening in practice, so no need to provide a "there are no processes configured" text
    }
    CATCH(OBJECT e)
    {
      ^applist->empty := this->GetTid(".apprunnerdown");
      ^applist->rows := DEFAULT RECORD ARRAY;
    }
  }

  MACRO DoRestart()
  {
    RECORD res := ^applist->selection;
    TRY
    {
      IF (res.owner = "system:apprunner")
      {
        OBJECT link := WaitForPromise(OpenWebHareService("system:apprunner"));
        WaitForPromise(link->Restart(res.rowkey));
        link->CloseService();
      }
      ELSE
      {
        OBJECT link := WaitForPromise(OpenWebHareService("platform:servicemanager"));
        WaitForPromise(link->RestartService(res.rowkey));
        link->CloseService();
      }
    }
    CATCH(OBJECT e)
    {
      this->RunSimpleScreen("error", this->GetTid(".restartfailed", res.rowkey));
    }
  }
  MACRO SetEnabled(STRING appname, BOOLEAN doenable)
  {
    TRY
    {
      OBJECT link := WaitForPromise(OpenWebHareService("system:apprunner"));
      RECORD response := WaitForPromise(link->SetEnabled(appname, doenable));
      link->CloseService();
    }
    CATCH(OBJECT e)
    {
    }
  }

  MACRO DoEnable()
  {
    this->SetEnabled(^applist->value, TRUE);
  }

  MACRO DoDisable()
  {
    this->SetEnabled(^applist->value, FALSE);
  }
>;
