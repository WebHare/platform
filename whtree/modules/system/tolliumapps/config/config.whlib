<?wh
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/asynctools.whlib";
LOADLIB "mod::system/lib/internal/moduleimexport.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

STRING FUNCTION GetWebsiteForRepository(STRING type, STRING repository_url)
{
  IF(type = "git")
  {
    IF(repository_url LIKE "*@gitlab.*:*/*" OR repository_url LIKE "*@www.gitlab.*:*/*")
    {
      /* eg:
           git@gitlab.webhare.com:webhare/blexdev_formsapi.git == https://gitlab.webhare.com/webhare/blexdev_formsapi.git (and it will redirect itself)
           a@b:c/d == https://b/c/d/
           */
      repository_url := Tokenize(repository_url,'@')[1];
      STRING ARRAY toks := Tokenize(repository_url,':');
      RETURN `https://${toks[0]}/${toks[1]}`;
    }
  }
  RETURN "";
}

PUBLIC RECORD ARRAY FUNCTION GetModuleDetails(STRING langcode) //do we even need to do this async now that we ignore git ?
{
  //TODO yield statusses as they come in?
  SetTidLanguage(langcode);
  RECORD ARRAY enriched;

  //Gather statusses from manifests
  RECORD ARRAY modlist := EnrichInstalledModulesWithManifests(GetInstalledModulesOverview(FALSE)); //don't get deleted modules
  FOREVERY(RECORD mod FROM modlist)
  {
    IF(RecordExists(SELECT FROM enriched WHERE name = mod.name))
      CONTINUE; // already seen

    IF(mod.source_revision != "")
    {
      INSERT [ name := mod.name
             , revision := mod.source_revision || (mod.source_uncommittedchanges ? " " || GetTid("system:tolliumapps.config.main.uncommittedchanges") : "")
             , gitinfo := DEFAULT RECORD
             , website := ""
             ] INTO enriched AT END;
    }
  }

  RETURN enriched;
}

PUBLIC STATIC OBJECTTYPE Main EXTEND TolliumScreenBase
<
  RECORD ARRAY moduledetails;
  RECORD peerconnectinfo;
  RECORD ARRAY peermods;
  RECORD ARRAY modulecolumns;

  RECORD hookinguserdata;

  OBJECT revisionupdatefifo;

  MACRO Init(RECORD data)
  {
    this->revisionupdatefifo := NEW FIFO;
    this->modulecolumns := ^modules->columns;
    this->RefreshPermissions();
    this->LoadRevisionInfo();

    IF(RecordExists(data.message))
    {
      this->OnMessage(data.message);
    }
    ELSE IF(Length(data.params) > 0)
    {
      ^modules->SetValueIfValid(data.params[0]);
      ^configuremodule->TolliumClick();
    }
  }

  MACRO OnMessage(RECORD msg)
  {
    msg := EnforceStructure([ panel := "" , module := "", registrykey := "" ], msg);

    IF(msg.panel = "registry") //used by dashboard warning about this regkey TODO remove by jumping straight to webserver tweaks
    {
      this->RunScreen("mod::system/screens/sysmgmt/registry.xml#editreg", [ selectkey := msg.registrykey ]);
    }
    ELSE IF(msg.module != "") //used by dashboard error list
    {
      ^modules->SetValueIfValid(msg.module);
    }
  }

  MACRO GotUnload()
  {
    this->revisionupdatefifo->Close();
  }

  MACRO RefreshPermissions()
  {
    this->frame->flags.developer := GetDtapStage() = "development";

    ^connectremotebutton->visible := this->frame->flags.developer;
    ^modules->Invalidate();
  }

  MACRO DoRefresh()
  {
    this->revisionupdatefifo->Push([ modules := [ "*" ] ]);
  }

  MACRO DoClose()
  {
    this->tolliumresult:= "ok";
  }

  RECORD ARRAY FUNCTION GetModules()
  {
    RECORD ARRAY overview := GetInstalledModulesOverview(^showdeleted->value);
    STRING ARRAY peermodules := SELECT AS STRING ARRAY name FROM this->peermods;

    overview := SELECT *
                     , details := (SELECT * FROM this->moduledetails WHERE moduledetails.name = overview.name)
                     , isinstalledonpeer := name IN peermodules
                  FROM overview;

    RETURN SELECT name
                , path
                , version
                , description
                , lastmodified
                , typeicon := isdeleted ? 0 : isinstalled ? 3 : isbuiltin ? 2 : 4
                //, revision := source_revision || (source_uncommittedchanges ? " " || this->GetTid(".uncommittedchanges") : "")
                , details
                , revision       := RecordExists(details) ? details.revision : ""
                , havewebsite    := RecordExists(details) AND details.website != ""
                , listrowclasses := isdeleted ? ["grayedout"] : STRING[]
                , rowkey         := name
                , isavailable    := NOT isdeleted
                , configscreen
                , isconfigurable := configscreen != ""
                , configicon     := (configscreen != "") ? 5 : 0
                , canmanage      := isinstalled AND packagingupgrade
                , canseeversions := isinstalled OR isdeleted
              FROM overview;
  }

  ASYNC MACRO LoadRevisionInfo()
  {
    STRING ARRAY modules := [ "*" ];
    WHILE (LENGTH(modules) != 0)
    {
      // ADDME: update only the modules that need updating
      this->moduledetails := AWAIT AsyncCallFunctionFromJob(Resolve("#GetModuleDetails"), GetTidLanguage());
      ^modules->Invalidate();
      ^peermodules->Invalidate();

      // Get new list of modules to update - and batch them by reading synchronously until the fifo is empty
      modules := STRING[];
      RECORD rec := AWAIT this->revisionupdatefifo->AsyncShift();
      AWAIT NEW WaitableTimer(100); // batch updates a bit better
      WHILE (RecordExists(rec))
      {
        modules := modules CONCAT rec.modules;
        rec := this->revisionupdatefifo->Shift();
      }
      modules := GetSortedSet(modules);
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotModuleEvent(RECORD ARRAY events)
  {
    ^modules->Invalidate();
  }

  MACRO OnShowDeletedChange()
  {
    ^modules->Invalidate();
  }

  MACRO GotGitEvent(RECORD ARRAY events)
  {
    STRING ARRAY modules;
    FOREVERY (RECORD event FROM events)
      INSERT Tokenize(Tokenize(event.event, "/")[0] , "mod::")[1] INTO modules AT END;

    this->revisionupdatefifo->Push([ modules := GetSortedSet(modules) ]);
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoEditReg()
  {
    this->LoadScreen("sysmgmt/registry.editreg")->RunModal();
  }

  MACRO DoAdHocCache()
  {
    this->LoadScreen("sysmgmt/adhoccache.status")->RunModal();
  }

  MACRO DoRemoting()
  {
    this->LoadScreen("sysmgmt/remoting.main")->RunModal();
  }

  MACRO DoBackend()
  {
    this->RunScreen("settings.xml#settings");
    this->RefreshPermissions(); //in case DTAP mode changed
  }

  MACRO DoMailRoutes()
  {
    this->RunScreen(Resolve("mailrouting.xml#mailroutes"));
  }

  MACRO DoWebdavData()
  {
    this->LoadScreen("sysmgmt/webdav.webdav_data")->RunModal();
  }


  MACRO DoScheduler()
  {
    this->LoadScreen("scheduler.main")->RunModal();
  }

  MACRO DoAppRunner()
  {
    this->LoadScreen("sysmgmt/apprunner.apprunner")->RunModal();
  }

  MACRO DoConfigModule()
  {
    OBJECT scr := this->LoadScreen(^modules->selection.configscreen);
    IF(ObjectExists(scr))
      scr->RunModal();
  }

  MACRO OnOpenWebsite(OBJECT receiver)
  {
    RECORD details := ^modules->selection.details;
    IF(RecordExists(details) AND details.website != "")
      receiver->SendURL(details.website);
  }

  MACRO DoUploadModule(RECORD upload_result)
  {
    OBJECT work := this->BeginFeedback();
    RECORD result := ImportModule(upload_result.data);
    FOREVERY(STRING error FROM result.errors)
      work->AddError(error);
    FOREVERY(STRING warning FROM result.warnings)
      work->AddWarning(warning);

    work->Finish();
    IF(Length(result.errors) = 0)
    {
      ^modules->Invalidate(); //manually invalidate, it takes some time for the events to do it.
      ^modules->SetValueIfValid(result.importmodulename);
    }
  }

  MACRO DoDeleteModule()
  {
    STRING modulename := ^modules->selection.name;
    IF(this->RunSimpleScreen("confirm", this->GetTid(".deletemodule", modulename)) != "yes")
      RETURN;

    IF(NOT DeleteModule(modulename))
      this->RunSimpleScreen("error", this->GetTid(".deletemodulefailed", modulename));
  }

  MACRO ShowInfoForModule(RECORD row)
  {
    this->RunScreen("moduleinfo.xml#moduleinfo", [ modulename := row.name, path := row.path ]);
  }

  MACRO DoShowModuleInfo()
  {
    this->ShowInfoForModule(^modules->selection);
  }

  MACRO DoVersions()
  {
    this->RunScreen("moduleinfo.xml#moduleversions", [ modulename := ^modules->value ]);
  }

  MACRO DoConnectRemote()
  {
    //Transitional warning that this is no longer done here
    this->RunSimpleScreen("info", this->GetHTMLTid(".deploymentrequiresdev"), [ html := TRUE ]);
  }
>;
