<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::filetypes/pkcs.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/keystore.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::wrd/lib/database.whlib";


STRING FUNCTION GetKeyPath(STRING keyname)
{
  STRING keydir := GetModuleInstallationRoot("system") || "keys";
  RETURN keydir || "/" || keyname || ".key";
}


RECORD ARRAY FUNCTION GetInstalledKeys()
{
  RECORD ARRAY keypairs := ListKeyPairs( [ requirecert := FALSE ]);

  RECORD ARRAY rows;
  DATETIME now := GetCurrentDateTime();

  FOREVERY (RECORD keypairrec FROM keypairs)
  {
    OBJECT obj := OpenKeyPair(keypairrec.id);

    RECORD keydata := DecodePEMFile(BlobToString(obj->privatekey));

    STRING basename := obj->name;

    RECORD certdata;
    STRING certfile := BlobToString(obj->certificatechain);
    IF (LENGTH(certfile) != 0)
    {
      certdata := DecodePEMFile(certfile);
      IF (certdata.type = "multiple")
        certdata := RECORD(certdata.parts);
      IF (NOT RecordExists(certdata) OR certdata.type != "certificate")
        certdata := DEFAULT RECORD;
    }

    INTEGER keylength;
    STRING modulus;
    IF (keydata.algorithm != "RSA encryption" OR TypeID(keydata.privatekey.modulus) != TypeID(STRING))
    {
      keydata := DEFAULT RECORD;
    }
    ELSE
    {
      modulus := keydata.privatekey.modulus;
      WHILE (LENGTH(modulus) > 2 AND Left(modulus, 2) = "00")
        modulus := SubString(modulus, 2);
      keylength := LENGTH(modulus) * 4;
    }

    RECORD row :=
        [ rowkey :=       keypairrec.id
        , keyfile :=      basename
        , keylength :=    keylength > 0 ? ToString(keylength) : "???"
        , publickeymodulus := RecordExists(keydata) ? keydata.privatekey.modulus : ""
        , have_certfile := certfile != ""
        , candelete :=    basename != "fallback"
        , certhash :=     GetHashForString(certfile, "SHA-256")
        , certfile :=     certfile
        , certificate :=  RecordExists(certdata)
                                ? certdata.valid_until < now
                                      ? 1 // error
                                      : certdata.valid_until < AddDaysToDate(28, now)
                                            ? 2 // warning
                                            : 3 // ok
                                : 0
        , validuntil :=   RecordExists(certdata) ? certdata.valid_until : DEFAULT DATETIME
        ];

    INSERT row INTO rows AT END;
  }
  RETURN rows;
}

PUBLIC STATIC OBJECTTYPE Main EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->frame->flags.issysop := this->tolliumuser->HasRight("system:sysop");
    IF (CellExists(data, "VALUE"))
      ^keys->value := data.value;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotEvents(RECORD ARRAY events)
  {
    ^keys->Invalidate();
  }

  RECORD ARRAY FUNCTION OnGetKeys(RECORD parent)
  {
    IF(RecordExists(parent))
      RETURN DEFAULT RECORD ARRAY;

    RECORD ARRAY keys := GetInstalledKeys();

    INTEGER keystore_folder := LookupWHFSObject(0, "/webhare-private/system/keystore");
    IF (keystore_folder = -1)
      keystore_folder := LookupWHFSObject(0, "/webhare-private/system");

    STRING ARRAY masks := [ "system:whfs.folder." || keystore_folder ];
    FOREVERY (RECORD keyrec FROM keys)
      INSERT "system:whfs.folder." || keyrec.rowkey INTO masks AT END;

    ^eventlistener->masks := masks;
    RETURN keys;
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoAddKey()
  {
    ^keys->value := this->RunScreen("#createkey");
  }

  MACRO DoUploadKey(RECORD ARRAY files)
  {
    FOREVERY(RECORD file FROM files)
    {
      RECORD chaindata;
      TRY chaindata := DecodePEMFile(BlobToString(file.data));
      CATCH;

      IF(NOT RecordExists(chaindata) OR chaindata.type NOT IN [ "private key", "rsa private key" ])
      {
        this->RunSimpleScreen("error", this->GetTid(".invalidkeyfile", file.filename));
        RETURN;
      }

      OBJECT work := this->BeginUnvalidatedWork();
      OBJECT keypair := CreateKeyPair(GetbasenameFromPath(file.filename), file.data, [ title := file.filename, generateuniquename := TRUE ]);
      IF(NOT work->Finish())
        RETURN;

      IF (#file = 0 AND LENGTH(files) = 1)
        ^keys->value := keypair->id;
    }
  }

  MACRO DoDownloadKey(OBJECT receiver)
  {
    OBJECT obj := OpenKeyPair(^keys->selection.rowkey);
    receiver->SendFile(obj->privatekey, "application/pkcs8", obj->name || ".key");
  }

  MACRO DoDownloadCertificate(OBJECT receiver)
  {
    OBJECT obj := OpenKeyPair(^keys->selection.rowkey);
    receiver->SendFile(obj->certificatechain, "application/x-x509-ca-cert", obj->name || ".cer");
  }

  MACRO DoDeleteKey()
  {
    IF (this->RunSimpleScreen("confirm", this->GetTid(".suredeletekey", ^keys->selection.keyfile)) != "yes")
      RETURN;

    OBJECT work := this->BeginWork();
    RECORD port := SELECT * FROM system.ports WHERE COLUMN keypair = ^keys->value;
    IF (RecordExists(port))
      work->AddError(this->GetTid(".keystillreferencedbyport", port.ip, ToString(port.port)));
    RECORD ARRAY entities :=
        SELECT DISTINCT schemaname :=   schemas.name
                      , typetag :=      types.tag
                      , typetitle :=    types.title
                      , entitytag :=    entities.tag
          FROM wrd.schemas
             , wrd.types
             , wrd.entities
             , wrd.entity_settings
             , wrd.entity_settings_whfslink
         WHERE fsobject = ^keys->value
           AND entity_settings_whfslink.id = entity_settings.id
           AND entity_settings.entity = entities.id
           AND entities.type = types.id
           AND types.wrd_schema = schemas.id
           AND schemas.name NOT LIKE "$deleted$*";

    IF (RecordExists(entities))
      work->AddError(this->GetTid(".keystillreferencedbyentity", entities[0].schemaname, entities[0].typetitle || " (" || entities[0].typetag || ")", entities[0].entitytag));

    IF (NOT work->HasFailed())
      OpenKeyPair(^keys->value)->RecycleSelf();

    work->Finish();

    // Reload the webserver config
    ReloadWebhareConfig(TRUE, FALSE);
  }

  MACRO DoGenerateCSR()
  {
    IF(^keys->value != 0)
      this->LoadScreen(".generatecsr", [ keyid := ^keys->value ])->RunModal();
  }

  MACRO DoUploadCertificate(RECORD certfile)
  {
    OBJECT keypair := OpenKeyPair(^keys->value);
    RECORD res := keypair->TestCertificate(certfile.data);

    OBJECT work := this->BeginWork();
    IF(res.success)
    {
      keypair->UpdateMetadata([ certificatechain := res.finalkey ]);
    }
    ELSE
    {
      work->AddError(res.message);
    }
    IF(NOT work->Finish())
      RETURN;

    // Reload the webserver config
    ReloadWebhareConfig(TRUE, FALSE);
  }

  MACRO DoViewCertificateChain()
  {
    this->LoadScreen(".viewcertificatechain", [ id := ^keys->value ])->RunModal();
  }

  MACRO DoCreateSelfSignedCert()
  {
    IF (^keys->selection.have_certfile)
    {
      // ADDME: don't ask this question for self-signed certificates
      IF (this->RunSimpleScreen("confirm", this->GetTid(".overwritewithselfsigned")) != "yes")
        RETURN;
    }

    this->LoadScreen(".createselfsignedcert", [ keypair := OpenKeyPair(^keys->value) ])->RunModal();
  }
>;

PUBLIC STATIC OBJECTTYPE CreateKey EXTEND TolliumScreenBase
<
  INTEGER FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    IF(RecordExists(SELECT FROM GetInstalledKeys() WHERE ToUppercase(keyfile) = ToUppercase(^name->value)))
      work->AddErrorFor(^name, this->GetTid(".duplicatekeyfile", ^name->value));
    IF(NOT IsValidWHFSName(^name->value, FALSE))
      work->AddErrorFor(^name, this->GetTid(".invalidname", ^name->value));

    OBJECT keypair;
    IF(NOT work->HasFailed())
    {
      OBJECT evpkey := GenerateCryptoKey("RSA", ^bits->value);
      keypair := CreateKeyPair(^name->value, StringToBlob(evpkey->privatekey), [ title := ^title->value ]);
    }
    RETURN work->Finish() ? keypair->id : 0;
  }
>;

PUBLIC STATIC OBJECTTYPE GenerateCSR EXTEND TolliumScreenBase
<
  OBJECT keypair;

  MACRO Init(RECORD data)
  {
    this->keypair := OpenKeyPair(data.keyid);
    this->ReadData();
  }

  MACRO ReadData()
  {
    // Have a certificate? Read the settings from the certificate
    BLOB cert := this->keypair->certificate;
    IF (LENGTH(cert) = 0)
      RETURN;

    RECORD decoded := DecodePEMFile(BlobToString(cert));

    RECORD altnames_ext :=
        SELECT *
          FROM decoded.extensions
         WHERE extnid = "2.5.29.17";

    STRING altnames;
    IF (RecordExists(altnames_ext))
    {
      altnames := Detokenize((
            SELECT AS STRING ARRAY dnsname
              FROM altnames_ext.decoded
             WHERE __field = "dNSName"), " ");
    }
    ^organizationunit->value := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="OU";
    ^country->value          := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="C";
    ^state->value            := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="ST";
    ^locality->value         := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="L";
    ^organization->value     := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="O";
    ^webserver->value        := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="CN";
    ^altnames->value := altnames;
  }

  MACRO DoGenerate()
  {
    // Check for missing fields first
    IF (NOT this->BeginFeedback()->Finish())
      RETURN;

    ^country->value := ToUppercase(^country->value);

    //FIXME don't think we support wildcards everywhere, so build a better check
    IF (NOT IsValidHostName(Substitute(^webserver->value,'*','x')))
    {
      IF (this->RunSImpleScreen("confirm", this->GetTid(".invalidhostname", ^webserver->value)) != "yes")
        RETURN;
    }

    OBJECT work := this->BeginWork();

    STRING altnames := "DNS:" || ^webserver->value;
    FOREVERY(STRING host FROM ParseXSList(^altnames->value))
    {
      IF(host="")
        CONTINUE;

      IF(NOT IsValidHostName(Substitute(host,'*','x')))
        work->AddErrorFor(^altnames, this->GetTid(".invalidhostname", host));
      ELSE
        altnames := (altnames = "" ? "" : altnames || ", ") || "DNS:" || host;
    }

    IF(NOT work->Finish())
      RETURN;

    STRING keydata := BlobToString(this->keypair->privatekey);
    OBJECT evpkey2 := MakeCryptoKey(keydata);
    IF(NOT Objectexists(evpkey2))
      THROW NEW Exception("Unable to read private key");

    STRING csr := evpkey2->GenerateCSR([[ field := "C", value := ^country->value ]
                                       ,[ field := "ST", value := ^state->value ]
                                       ,[ field := "L", value := ^locality->value ]
                                       ,[ field := "O", value := ^organization->value ]
                                       ,[ field := "CN", value := ^webserver->value ]
                                       ,[ field := "OU", value := ^organizationunit->value ]
                                       ], altnames);

    IF(csr="")
      THROW NEW Exception("Unable to generate request");

    ^csr->value := csr;
  }
>;

PUBLIC STATIC OBJECTTYPE CreateSelfSignedCert EXTEND TolliumScreenBase
< OBJECT keypair;

  MACRO Init(RECORD data)
  {
    this->keypair := data.keypair;
    BLOB cert := this->keypair->certificate;
    IF (LENGTH(cert) != 0)
    {
      RECORD decoded := DecodePEMFile(BlobToString(cert));
      ^subject->value := [ ou := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="OU"
                         , c := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="C"
                         , st :=SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="ST"
                         , l :=SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="L"
                         , o :=SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="O"
                         , cn := SELECT AS STRING value FROM decoded.subjectfields WHERE fieldname="CN"
                         ];
      RECORD altnames_ext :=
          SELECT *
            FROM decoded.extensions
           WHERE extnid = "2.5.29.17";

      IF (RecordExists(altnames_ext))
      {
        ^altnames->value := Detokenize((
              SELECT AS STRING ARRAY dnsname
                FROM altnames_ext.decoded
               WHERE __field = "dNSName"), " ");
      }
    }
    ^validuntil->value := AddYearsToDate(1, GetCurrentDateTime());
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    IF (^validuntil->value < GetCurrentDateTime())
    {
      work->AddError(this->GetTid(".valituntilmustbeinfuture"));
      RETURN work->Finish();
    }

    RECORD csr_options := ^subject->value;
    INSERT CELL dnsaltnames :=
       (SELECT AS STRING ARRAY host
          FROM ToRecordArray(ParseXSList(^altnames->value), "HOST")
         WHERE host != "") INTO csr_options;

    BLOB csr := this->keypair->GenerateCSR(csr_options);
    RECORD certdata := this->keypair->SignCertificateRequest(csr, [ selfsign := TRUE, validuntil := ^validuntil->value ]);

    this->keypair->UpdateMetadata([ certificatechain := certdata.certificatechain ]);
    IF (work->Finish())
    {
      // Reload the webserver config
      ReloadWebhareConfig(TRUE, FALSE);
      RETURN TRUE;
    }

    RETURN FALSE;
  }
>;

PUBLIC STATIC OBJECTTYPE ViewCertificateChain EXTEND TolliumScreenBase
<
  OBJECT keypair;

  MACRO Init(RECORD data)
  {
    RECORD certdata;
    BLOB certfile;
    this->keypair := OpenKeyPair(data.id);
    ^keyfolder->Load(data.id);

    IF (LENGTH(this->keypair->certificatechain) != 0)
    {
      certdata := DecodePEMFile(BlobTostring(this->keypair->certificatechain));
      IF (certdata.type != "multiple")
        certdata := [ parts := [ certdata  ] ];
    }
    ^warnexpirydays->placeholder := ToString(whconstant_default_warnexpirydays);
    ^certificates->rows :=
        SELECT rowkey :=  #parts + 1
             , *
             , commonname := (SELECT AS STRING value FROM parts.subjectfields WHERE fieldname="CN")
          FROM certdata.parts;

    ^certificates->selection := ^certificates->rows[0];
  }

  MACRO OnCertificateSelect()
  {
    RECORD sel := ^certificates->selection;
    IF (NOT RecordExists(sel))
    {
      sel := ^certificates->rows[END - 1];
      ^certificates->selection := sel;
    }

    ^validfrom->value := sel.valid_from;
    ^validuntil->value := sel.valid_until;

    DATETIME now := GetCurrentDateTime();

    if (sel.valid_until < now)
      ^validuntil_expire->htmlvalue := this->GetHTMLTid(".expired");
    ELSE
    {
      RECORD diff := GetDateTimeDifference(now, sel.valid_until);
      IF (diff.days < 28)
        ^validuntil_expire->htmlvalue := this->GetHTMLTid(".expires_soon_in_days", ToString(diff.days));
      ELSE
        ^validuntil_expire->htmlvalue := this->GetHTMLTid(".expires_in_days", ToString(diff.days));
    }

    ^subject->value := sel.subject;
    ^dns_altnames->value := Detokenize(sel.dns_altnames, "\n");

    IF (CheckPKCSSignature(sel, [ signingcert := sel ]).success)
      ^signaturestatus->value := this->GetTid(".selfsigned");
    ELSE
    {
      RECORD nextcert := SELECT * FROM ^certificates->rows WHERE rowkey > sel.rowkey ORDER BY rowkey;
      IF (RecordExists(nextcert))
      {
        IF (CheckPKCSSignature(sel, [ signingcert := nextcert ]).success)
          ^signaturestatus->value := this->GetTid(".signedbynextcert");
        ELSE
          ^signaturestatus->value := this->GetTid(".notsignedbynextcert");
      }
      ELSE // FIXME: create and use a certificate root store
        ^signaturestatus->value := this->GetTid(".signaturenotchecked");
    }
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    ^keyfolder->Store(work, this->keypair->id);
    RETURN work->Finish();
  }
>;
