<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/comparisons.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/semver.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/validation.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/moduleimexport.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/internal/modules/node.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";



/** Creates an archive of a module
    @param module Name of the module
    @param userlogin Login name of the current user
    @param userrealname Real name of the current user
    @return Module archive
    @cell(boolean) return.success Whether the module archive was created successfully
    @cell(string) return.errormessage Error message, only present when `success` is FALSE
    @cell(string) return.archivename Name for the module archive file
    @cell(blob) return.data Archive data
    @cell(string) return.moduleversion
    @cell(record) return.manifest Contents of module manifest
*/
RECORD FUNCTION PrepareModuleDownload(STRING module, STRING userlogin, STRING userrealname)
{
  OBJECT archiver := NEW ModuleArchiver;
  archiver->SetUserData(userlogin, userrealname);

  RECORD moduledata  := archiver->CreateArchive(module);

  RETURN [ archivename :=   GetSafeFilename("whmodule-" || module || "-" || FormatDatetime("%Y-%m-%d", GetcurrentDatetime())) || ".tar.gz"
         , data :=          moduledata
         , moduleversion := moduledata.fullversion
         , manifest :=      moduledata.manifest
         ];
}

PUBLIC BOOLEAN FUNCTION DoPushModule(OBJECT parent, STRING modulename)
{
  // Get the list of external modules
  RECORD ARRAY modules := parent->contexts->^peer->InvokeAdminService("ListInstalledModules");
  // Recheck remote applicability info
  RECORD peerinfo := parent->contexts->^peer->InvokeAdminService("Connect");
  RECORD localmoduleinfo := GetWebhareModuleInfo(modulename);

  OBJECT work := parent->BeginUnvalidatedFeedback();

  RECORD ARRAY nodeissues := CheckNodeModulesInModule(GetModuleInstallationRoot(modulename));
  FOREVERY (RECORD issue FROM nodeissues)
    work->AddError(issue.basepath || ": " || issue.error);

  FOREVERY (RECORD error FROM ValidateSingleFile(GetModuleDefinitionXMLResourceName(modulename)).errors)
    work->AddError(FormatValidationError(error));

  STRING whymismatch := GetApplicabilityError(peerinfo.applicability, localmoduleinfo.packagingapplicability);
  IF(whymismatch!="")
    work->AddError("This module is not compatible with that server:\n" ||whymismatch); //FIXME langfile

  FOREVERY (RECORD rec FROM localmoduleinfo.requiredmodules)
  {
    // Skip base and substite modules, they aren't listed in installed modules
    IF (rec.name IN whconstant_builtinmodules OR rec.name IN substitutemodules)
      CONTINUE;

    RECORD existing := SELECT * FROM modules WHERE name = rec.name;
    IF (NOT RecordExists(existing))
      work->AddError(GetTid("system:tolliumapps.config.deploy.deploymodule.missingrequiredmoduleonpeer", rec.name));
    ELSE IF(rec.moduleversion != "" AND NOT VersionSatisfiesRange(existing.version, rec.moduleversion))
      work->AddError(GetTid("system:tolliumapps.config.deploy.deploymodule.invalidversion", rec.name, existing.version, rec.moduleversion));
  }

  IF (NOT work->Finish())
    RETURN FALSE;

  work := DEFAULT OBJECT;

  RECORD mod := SELECT * FROM modules WHERE ToUppercase(name) = ToUppercase(modulename);
  RECORD moduledata := PrepareModuleDownload(modulename, parent->contexts->user->login, parent->contexts->user->realname);

//    PRINT("Prepared: " || LENGTH(moduledata.data.data) || " " || EncodeBase16(GetHashForBlob(moduledata.data.data, "SHA-1")) || "\n");

  IF (moduledata.manifest.original_source = "git")
  {
    IF (moduledata.manifest.source_revision != moduledata.manifest.source_localremoterevision OR moduledata.manifest.source_revision != moduledata.manifest.source_remoterevision)
    {
      IF (moduledata.manifest.source_remoterevision != "" AND moduledata.manifest.source_localremoterevision != moduledata.manifest.source_remoterevision)
      {
        IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.notgituptodate")) != "yes") // need to fetch
          RETURN FALSE;
      }
      IF (moduledata.manifest.source_localremoterevision = "")
      {
        // Local remote is ancestor of current commit - so current commit just hasn't been pushed yet
        IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.branchnotonorigin")) != "yes")
          RETURN FALSE;
      }
      ELSE IF (moduledata.manifest.source_revision != moduledata.manifest.source_localremoterevision)
      {
        // Either uncommitted changes or not rebased yet
        IF (RecordExists(SELECT FROM moduledata.manifest.commits WHERE id = moduledata.manifest.source_localremoterevision))
        {
          // Local remote is ancestor of current commit - so current commit just hasn't been pushed yet
          IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.unpushedchanges")) != "yes")
            RETURN FALSE;
        }
        ELSE
        {
          // Remote is not an ancestor of current version - have older version checked out or need to rebase
          IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.notatbranchhead")) != "yes")
            RETURN FALSE;
        }
      }
    }

    IF (moduledata.manifest.has_modifications)
    {
      IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.uncommittedchanges")) != "yes")
        RETURN FALSE;
    }

    IF (RecordExists(mod))
    {
      IF (moduledata.manifest.source_repository_url != "" AND mod.source_repository_url != "")
      {
        IF (moduledata.manifest.source_repository_uuid != mod.source_repository_uuid)
        {
          IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.differentrepository", moduledata.manifest.source_repository_uuid, mod.source_repository_uuid)) != "yes")
            RETURN FALSE;
        }
        ELSE IF (moduledata.manifest.source_repository_url != mod.source_repository_url)
        {
          STRING local_branch := Tokenize(moduledata.manifest.source_repository_url || "\t", "\t")[1];
          STRING remote_branch := Tokenize(mod.source_repository_url || "\t", "\t")[1];

          IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.differentbranch", local_branch, remote_branch)) != "yes")
            RETURN FALSE;
        }
        // ADDME: downgrade detection?
      }
    }
  }

  IF (RecordExists(mod))
  {
    RECORD changes := parent->contexts->^peer->InvokeAdminService("GetModuleChangedFiles", modulename);
    IF (changes.success AND LENGTH(changes.changedfiles) != 0)
    {
      IF(parent->RunScreen("mod::system/tolliumapps/config/deploy.xml#peerchangeswarning",
          [ modulename :=     modulename
          , changedfiles :=   changes.changedfiles
          ]) != "yes")
        RETURN FALSE;

    }
  }
  ELSE
  {
    IF (parent->RunSimpleScreen("confirm", GetTid("system:tolliumapps.config.deploy.deploymodule.uploadnewmodule")) != "yes")
      RETURN FALSE;
  }

  work := parent->BeginUnvalidatedFeedback();

  RECORD checkresult := parent->contexts->^peer->InvokeAdminService("uploadmodule", modulename, moduledata.data.data);

  IF (NOT checkresult.success)
  {
    SWITCH (checkresult.code)
    {
      CASE "CANNOTREPLACE"
      {
        work->AddError(GetTid("system:tolliumapps.config.deploy.deploymodule.cannotreplacemodule", modulename));
      }
      CASE "ERRORS", "WARNINGS"
      {
        FOREVERY (STRING str FROM checkresult.errors)
          work->AddError(str);
        FOREVERY (STRING str FROM checkresult.warnings)
          work->AddWarning(str);
      }
    }

    IF (work->HasFailed())
    {
      work->Finish();
      RETURN FALSE;
    }
  }
  ELSE
  {
    LogAuditEvent(
        "system:modules",
        [ action :=       "push"
        , module :=       modulename
        , version :=      moduledata.moduleversion
        , manifestdata := GetAuditLogDataFromManifest(moduledata.manifest)
        , peerurl :=      parent->contexts->^peer->url
        ]);
  }

  work->Finish();
  RETURN TRUE;
}

PUBLIC OBJECTTYPE PeerChangesWarning EXTEND TolliumScreenBase
<
  RECORD data;


  MACRO Init(RECORD data)
  {
    this->data := data;
  }

  MACRO DoReviewChanges()
  {
    this->RunScreen("#reviewmodulepeerchanges", this->data);
  }
>;

PUBLIC STATIC OBJECTTYPE ReviewRemoteToLocalDiff EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  STRING modulename;
  OBJECT localmodulearchive;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO Init(RECORD data)
  {
    this->modulename := data.modulename;

    this->frame->title := this->GetTid(".reviewremotetolocaldiff", this->modulename);

    // Create local module
    RECORD localmodule := PrepareModuleDownload(this->modulename, this->tolliumuser->login, this->tolliumuser->realname);
    RECORD remotemodule := this->contexts->^peer->InvokeAdminService("GetModuleChangedFiles", this->modulename);

    RECORD ARRAY local_sourcefiles :=
        SELECT *
             , pos :=         1
          FROM localmodule.manifest.sourcefiles
      ORDER BY path;

    // Reset sha1hash for all changed files
    STRING ARRAY changedpaths := SELECT AS STRING ARRAY path FROM remotemodule.changedfiles ORDER BY path;
    RECORD ARRAY remote_sourcefiles :=
        SELECT *
             , sha1hash :=    LowerBound(changedpaths, path).found ? "" :  sha1hash
             , pos :=         -1
          FROM remotemodule.sourcefiles
      ORDER BY path;

    // Add all added files
    remote_sourcefiles := remote_sourcefiles CONCAT
        SELECT path
             , sha1hash :=    ""
             , pos :=         -1
          FROM remotemodule.changedfiles
         WHERE status = "added";

    // Remove all deleted files
    STRING ARRAY deletedpaths := SELECT AS STRING ARRAY path FROM remotemodule.changedfiles WHERE status = "removed" ORDER BY path;
    DELETE
      FROM remote_sourcefiles
     WHERE LowerBound(deletedpaths, path).found;

    IF (LENGTH(remote_sourcefiles) = 0)
    {
      OBJECT feedback := this->BeginFeedback();
      feedback->AddError(this->GetTid(".remotemodulehasnofilelist"));
      feedback->Finish();
      this->tolliumresult := "cancel";
      RETURN;
    }

    this->localmodulearchive := OpenExistingArchive(localmodule.data.data);

//    PRINT(AnyToString(local_sourcefiles, "boxed"));
//    PRINT(AnyToString(remote_sourcefiles, "boxed"));

    RECORD ARRAY changes :=
        SELECT status :=  SUM(pos) < 0
                              ? "removed"
                              : SUM(pos) > 0
                                    ? "added"
                                    : "modified"
             , path
          FROM local_sourcefiles CONCAT remote_sourcefiles
      GROUP BY path
        HAVING SUM(pos) != 0 OR this->HaveDifferentHashes(GroupedValues(sha1hash));

    ^files->rows := changes;
  }

  BOOLEAN FUNCTION Cancel()
  {
    IF (ObjectExists(this->localmodulearchive))
      this->localmodulearchive->Close();

    this->localmodulearchive := DEFAULT OBJECT;
    RETURN TRUE;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  BOOLEAN FUNCTION HaveDifferentHashes(STRING ARRAY hashes)
  {
    RETURN LENGTH(hashes) > 1 AND LENGTH(SELECT AS STRING ARRAY DISTINCT hash FROM ToRecordArray(hashes, "HASH")) != 1;
  }

  BLOB FUNCTION GetRemoteModuleFile(STRING path)
  {
    STRING url := ResolveToAbsoluteURL(this->contexts->^peer->url, "/webdav/system/modules/" || this->modulename || "/" || path);
    IF (NOT this->contexts->^peer->browser->GotoWebPage(url))
      THROW NEW Exception("Could not download needed file from peer");

    RETURN this->contexts->^peer->browser->content;
  }

  MACRO ShowDiffWindow(RECORD ARRAY selectedfiles)
  {
    RECORD ARRAY files;

    FOREVERY (RECORD sel FROM selectedfiles)
    {
      BLOB orgfile, newfile;

      TRY
      {
        IF (sel.status != "added")
          orgfile := this->GetRemoteModuleFile(sel.path);
      }
      CATCH (OBJECT e)
      {
      }

      IF (sel.status != "removed")
        newfile := this->localmodulearchive->GetFile(this->modulename || "/" || sel.path);

      INSERT
          [ path :=         sel.path
          , orgfile :=      orgfile
          , newfile :=      newfile
          , have_newfile := sel.status != "removed"
          , have_orgfile := sel.status != "added"
          , org_suffix :=   ".remote"
          , new_suffix :=   ".local"
          ] INTO files AT END;
    }

    OBJECT screen := this->LoadScreen(".modulefilediff",
        [ modulename :=   this->modulename
        , files :=        files
        ]);

    screen->RunModal();
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoShowDiff()
  {
    this->ShowDiffWindow([ RECORD(^files->selection) ]);
  }

  MACRO DoShowFullDiff()
  {
    this->ShowDiffWindow(^files->rows);
  }
>;

PUBLIC STATIC OBJECTTYPE ReviewModulePeerChanges EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  STRING modulename;

  RECORD ARRAY changedfiles;

  BLOB sourcezip;

  OBJECT sourcearchive;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->modulename := data.modulename;
    this->changedfiles := data.changedfiles;

    ^files->rows :=
        SELECT rowkey :=    path
             , path
             , status
          FROM this->changedfiles;

    IF (NOT this->GetSourceZip())
      this->tolliumresult := "cancel";
  }

  // Cleanup
  BOOLEAN FUNCTION Cancel()
  {
    this->sourcearchive->Close();
    this->sourcearchive := DEFAULT OBJECT;
    this->sourcezip := DEFAULT BLOB;
    RETURN TRUE;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  BLOB FUNCTION GetModuleFile(STRING path)
  {
    STRING url := ResolveToAbsoluteURL(this->contexts->^peer->url, "/webdav/system/modules/" || this->modulename || "/" || path);

    IF (NOT this->contexts->^peer->browser->GotoWebPage(url))
      THROW NEW Exception("Could not download needed file from peer");

    RETURN this->contexts->^peer->browser->content;
  }

  BOOLEAN FUNCTION GetSourceZip()
  {
    TRY
    {
      this->sourcezip := this->GetModuleFile("history/source.zip");
      this->sourcearchive := OpenExistingArchive(this->sourcezip);
    }
    CATCH (OBJECT e)
    {
      Print("history/source.zip not found: " || e->what);
      this->RunSimpleScreen("error", this->GetTid(".moduledoesnothavesourcezip"));
    }
    RETURN TRUE;
  }

  MACRO ShowDiffWindow(RECORD ARRAY selectedfiles)
  {
    RECORD ARRAY files;

    FOREVERY (RECORD file FROM selectedfiles)
    {
      STRING path := file.path;

      STRING archivepath := this->modulename || "/" || path;

      BLOB orgfile, newfile;
      BOOLEAN have_orgfile := RecordExists(SELECT FROM this->sourcearchive->entries WHERE fullpath = archivepath);
      IF (have_orgfile)
        orgfile := this->sourcearchive->GetFile(this->modulename || "/" || path);
      BOOLEAN have_newfile;
      TRY
      {
        newfile := this->GetModuleFile(path);
        have_newfile := TRUE;
      }
      CATCH (OBJECT e)
      {
      }

      INSERT
          [ path :=     path
          , orgfile :=      orgfile
          , newfile :=      newfile
          , have_newfile := have_newfile
          , have_orgfile := have_orgfile
          ] INTO files AT END;
    }

    OBJECT screen := this->LoadScreen(".modulefilediff",
        [ modulename :=   this->modulename
        , files :=        files
        ]);

    screen->RunModal();
  }



  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoShowDiff()
  {
    this->ShowDiffWindow([ RECORD(^files->selection) ]);
  }

  MACRO DoShowFullDiff()
  {
    this->ShowDiffWindow(^files->rows);
  }
>;

PUBLIC OBJECTTYPE ModuleFileDiff EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD params;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD params)
  {
    this->params := params;

    // Default to ignoring whitespace on line (fixes \r differences). Whitespace isn't significant for
    // all the text file formats we currently exchange via modules.
    this->ignorewhitespace->value := TRUE;

    this->Refresh();
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotChange()
  {
    this->Refresh();
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO Refresh()
  {
    RECORD params := this->params;

    IF (LENGTH(params.files) = 1)
      this->frame->title := this->GetTid(".title", params.modulename, params.files[0].path);
    ELSE
      this->frame->title := this->GetTid(".titlemultiple", params.modulename);
//    STRING
//        "Diff of original " || LENGTH(data.orgfile) || " bytes\n" ||
//        "and modified " || LENGTH(data.newfile) || " bytes\n";

    STRING s;

    FOREVERY (RECORD data FROM params.files)
    {
      STRING org_suffix := CellExists(data, "ORG_SUFFIX") ? data.org_suffix : ".original";
      STRING new_suffix := CellExists(data, "NEW_SUFFIX") ? data.new_suffix : "";

      IF (NOT data.have_orgfile)
      {
        s := s || "File '" || data.path || "' (length " || LENGTH(data.newfile) || ") has been added\n\n";
      }
      ELSE IF (NOT data.have_newfile)
      {
        s := s || "File '" || data.path || "' (length " || LENGTH(data.orgfile) || ") has been deleted\n\n";
      }
      ELSE
      {
        RECORD det := ScanBlob(data.have_newfile ? data.newfile : data.orgfile, GetNameFromPath(data.path));
        IF (NOT RecordExists(det) OR (
            det.mimetype NOT LIKE "text*" AND
            det.mimetype NOT LIKE "application/*webhare*" AND
            det.mimetype NOT IN [ "application/x-javascript" ]))
        {
          // Binary, not diffable
          IF (LENGTH(data.orgfile) != LENGTH(data.newfile)
              OR GetHashForBlob(data.orgfile,"MD5") != GetHashForBlob(data.newfile,"MD5") ) //ADDME block-by-block comparison is most efficient and allows us to tell where it differs (just don't blobstring -1 huge zip files)
          {
            s := s || "Binary file original " || data.path || " (" || LENGTH(data.orgfile) || " bytes) and new file (" || Length(data.newfile) || " bytes) differ (" || det.mimetype || ")\n\n";
          }
        }
        ELSE
        {
          OBJECT differ := MakeTextDiffGenerator();
          differ->trimwhitespace := this->ignorewhitespace->value;

          differ->LoadOldVersion(data.orgfile);
          differ->LoadNewVersion(data.newfile);

          RECORD ARRAY diff := differ->GetDifferences();

          IF (LENGTH(diff) != 0)
          {
            s := s || "--- " || data.path || org_suffix || "\n";
            s := s || "+++ " || data.path || new_suffix || "\n";
            FOREVERY (RECORD x FROM diff)
            {
              s := s || "@@ -" || x.minstart + 1 || "," || x.minlines || " +" || x.plusstart + 1 || "," || x.pluslines  || " @@\n";
              s := s || Detokenize(x.lines, "\n") || "\n\n";
            }
          }
        }
      }
    }

    this->diff->value := s;
  }
>;

PUBLIC OBJECTTYPE ReviewIncomingCommits EXTEND TolliumScreenBase
<
  BLOB FUNCTION GetRemoteModuleFile(STRING module, STRING path)
  {
    STRING url := ResolveToAbsoluteURL(this->contexts->^peer->url, "/webdav/system/modules/" || module || "/" || path);
    IF (NOT this->contexts->^peer->browser->GotoWebPage(url))
      THROW NEW Exception("Could not download needed file from peer");

    RETURN this->contexts->^peer->browser->content;
  }

  MACRO Init(RECORD data)
  {
    // Get and parse remote manifest
    BLOB manifest_blob := this->GetRemoteModuleFile(data.module, "history/manifest.xml");
    RECORD remote_manifest := ParseModuleManifest(MakeXMLDocument(manifest_blob));
    RECORD localmoduleinfo := GetRevisionOfSingleModule(data.module);

    STRING ARRAY got_commits :=
        SELECT AS STRING ARRAY id
          FROM remote_manifest.commits;
    RECORD ARRAY new_commits :=
        SELECT *
          FROM localmoduleinfo.commits
         WHERE id NOT IN got_commits;

    this->commits->rows :=
        SELECT *
             , author :=    author.name != "" ? author.name || (author.email != "" ? " (" || author.email || ")" : "") : author.email
             , date
             , rowkey :=    id
          FROM new_commits;
  }

  MACRO OnSelect()
  {
    this->commit->value := this->commits->selection ??
        [ id :=       ""
        , date :=     DEFAULT DATETIME
        , author :=   ""
        , message :=  ""
        ];
  }
>;
