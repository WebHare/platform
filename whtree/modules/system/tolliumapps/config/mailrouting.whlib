<?wh
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/screenbase.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/smtpmgr.whlib";

STRING FUNCTION HideSMTPPassword(STRING url)
{
  IF(url="")
    RETURN "";
  RECORD smtpurl := UnpackURL(url);
  if (smtpurl.password != "")
    smtpurl.password := "*";
  RETURN Substitute(RepackURL(smtpurl), ":%2A@", ":******@"); //undo the encoding, it's just presentation anyway
}

PUBLIC RECORD FUNCTION TestSMTP(STRING url)
{
  RECORD retval := [ success := FALSE
                   , error := ""
                   ];

  OBJECT smtpmgr := NEW WebHareSMTPManager;
  TRY
  {
    RECORD conninfo := smtpmgr->GetSMTPconnection(url);
    IF(NOT ObjectExists(conninfo.conn))
    {
      retval.error := conninfo.errors;
      RETURN retval;
    }

    //Try an outgoing mail.
    RECORD res;
    res := conninfo.conn->SendCommand("MAIL FROM: <>");
    IF(res.code != 250)
    {
      retval.error := "The empty MAIL FROM address was not accepted: " || res.code || ": " || res.message;
      RETURN retval;
    }

    res := conninfo.conn->SendCommand("RCPT TO: <info@pr1.pronuntio.com>");
    IF(res.code != 250)
    {
      retval.error := "Mail to an external address was not accepted: " || res.code || ": " || res.message;
      RETURN retval;
    }

    retval.success := TRUE;
    RETURN retval;
  }
  FINALLY
  {
    smtpmgr->Close();
  }
}


PUBLIC STATIC OBJECTTYPE MailRoutes EXTEND TolliumScreenBase <
  RECORD ARRAY columns;

  STRING smtpserverurl;

  MACRO NEW() {
    this->contexts->wrdschema := OpenWRDSchema("system:config");
  }

  MACRO Init() {
    ^mailservers->embeddedlist->highlightname := "highlight";
    this->RefreshConfig();
  }

  MACRO RefreshConfig() {
    ^snsendpoint->value := GetSNSEndpoint();
    ^mailfrom->value := ReadRegistryKey("system.services.smtp.mailfrom");
  }

  MACRO DoSenderConfig() {
    this->RunScreen("#senderconfig");
  }

  RECORD ARRAY FUNCTION OnMapServers(RECORD ARRAY routes) {
    RETURN SELECT *
                , serverurl :=     HideSMTPPassword(serverurl)
                , highlight := wrd_tag = "DEFAULTSERVER"
          FROM routes;
  }

  RECORD ARRAY FUNCTION OnMapRoutes(RECORD ARRAY routes) {
    RETURN SELECT *
                , sendermasks :=    Detokenize((SELECT AS STRING ARRAY mask FROM sendermasks),"\n")
                , recipientmasks := Detokenize((SELECT AS STRING ARRAY mask FROM recipientmasks),"\n")
                , server :=         rewritemailaddress = "null" ? this->GetTid('.ignore') : this->contexts->wrdschema->^mailroute->GetDomValTitle("server", server)
          FROM routes;
  }

  RECORD ARRAY FUNCTION OnMapCorrections(RECORD ARRAY corrections) {
    RETURN SELECT *
                , masks := Detokenize((SELECT AS STRING ARRAY mask FROM masks),"\n")
                , target := block ? this->GetTid(".blocked") : rewriteto
             FROM corrections;
  }
>;

PUBLIC STATIC OBJECTTYPE SenderConfig EXTEND TolliumScreenBase
<
  MACRO Init()
  {
    ^usefornonwhitelisted->value := ReadRegistryKey("system.services.smtp.usemailfromfornonwhitelisted");
    ^mailfrom->value := ReadRegistryKey("system.services.smtp.mailfrom");
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    IF (work->HasFailed())
      RETURN FALSE;

    WriteRegistryKey("system.services.smtp.mailfrom", ^mailfrom->value);
    WriteRegistryKey("system.services.smtp.usemailfromfornonwhitelisted", ^usefornonwhitelisted->value);
    RETURN work->Finish();
  }
>;


PUBLIC STATIC OBJECTTYPE EditMailServer EXTEND WRDEntityEditScreenBase <
  UPDATE MACRO Init(RECORD data) {
    WRDEntityEditScreenBase::Init(data);
    IF(data.id != 0 AND ^entity->wrdentity->GetField("WRD_TAG") = "DEFAULTSERVER") {
      ^defaultserver->value := TRUE;
      ^defaultserver->enabled := FALSE;
    }
  }
  STRING FUNCTION OnGetServerURL() {
    RECORD rec := UnpackURL("smtp://"); // get a record with all URL fields and protcol prefilled
    // RepackURL uses the schemspecificpart?
    rec.host     := ^hostname->value;
    rec.port     := ^port->value;
    rec.user     := ^authusername->value;
    rec.password := ^authpassword->value;
    RETURN RepackURL(rec);
  }

  MACRO OnSetServerURL(STRING url) {
    RECORD rec := url != "" ? UnpackURL(url) : CELL[port := 0, user := "", password := "", host := ""];
    ^port->value         := rec.port;
    ^authusername->value := rec.user;
    ^authpassword->value := rec.password;
    ^hostname->value     := rec.host;
  }

  MACRO DoTestSMTPServer()
  {
    RECORD result := TestSMTP(^serverurl->value);

    IF (result.success)
      this->RunSimpleScreen("info", this->GetTid(".smtp_test_success"));
    ELSE
      this->RunSimpleScreen("error", this->GetTid(".smtp_test_error", result.error));
  }

  UPDATE RECORD FUNCTION Submitter(OBJECT work, RECORD updatevalue) {
    BOOLEAN setasdefault := (^defaultserver->value AND ^defaultserver->enabled)
                            OR
                            Length(this->contexts->wrdschema->^mailserver->RunQuery(CELL[])) = 0; //first mailserver!

    IF (setasdefault) {
      updatevalue := CELL[...updatevalue, wrd_tag := "DEFAULTSERVER"];
      //clear the other one
      FOREVERY(RECORD other FROM this->contexts->wrdschema->^mailserver->RunQuery(
        [ outputcolumns := CELL[ "wrd_id" ]
        , filters := [[ field := "wrd_tag", value := "DEFAULTSERVER" ]
                     ,[ field := "wrd_id", matchtype := "!=", value := ^entity->entityid ]]
        ]))
        this->contexts->wrdschema->^mailserver->UpdateEntity(other.wrd_id, CELL[ wrd_tag := "" ]);
    }

    RETURN updatevalue;
  }
>;


PUBLIC STATIC OBJECTTYPE EditMailRoute EXTEND WRDEntityEditScreenBase
<
  STRING smtpserverurl;
  BOOLEAN org_nullroute;

  UPDATE MACRO Init(RECORD params) {
    ^entity->^server->options := SELECT *, rowkey := id FROM this->contexts->wrdschema->^mailroute->ListDomVals("server") ORDER BY ToUppercase(title);
    WRDEntityEditScreenBase::Init(params);
    IF(^entity->entityid = 0) { // Is this a new route?
      ^smtpserver->value := "use";
      ^entity->^server->selection := SELECT * FROM ^entity->^server->options WHERE tag = "DEFAULTSERVER";
      ^entity->^sendermasks->value := [[ mask := "*" ]];
      ^entity->^recipientmasks->value := [[ mask := "*" ]];
    }
    this->org_nullroute := ^smtpserver->value = "null";
  }

  STRING FUNCTION GetRewriteMailAddress() {
    RETURN ^smtpserver->value = "null" ? "null" : ^outgoingredirect->value ? ^outgoingmailaddress->value : "";
  }

  MACRO SetRewriteMailAddress(STRING address) {
    ^smtpserver->value := address = "null" ? "null" : "use";
    ^outgoingmailaddress->value := address;
    ^outgoingredirect->value := address != "";
  }

  MACRO OnSMTPServerChange() {
    ^outgoingredirect->enabled := ^smtpserver->value != "null";
  }

  // workaround so we can also support getting multiple rows back when editting a single row
  RECORD ARRAY FUNCTION DoEditMailRouteRule_From(RECORD row)
  {
    RETURN this->DoEditMailRouteRule(^masks_from, row);
  }

  RECORD ARRAY FUNCTION DoEditMailRouteRule_To(RECORD row)
  {
    RETURN this->DoEditMailRouteRule(^masks_to, row);
  }

  RECORD ARRAY FUNCTION DoEditMailRouteRule(OBJECT arrayedit, RECORD row)
  {
    OBJECT dialog := this->LoadScreen(".editmailrouterule", [ mask := RecordExists(row) ? row.mask : DEFAULT STRING ]);
    IF (dialog->RunModal() != "ok")
      RETURN DEFAULT RECORD ARRAY;

    // This serves two purposes:
    // A) workaround to support editting morphing a single row into multiple rows
    // B) to remove duplicates
    IF (RecordExists(row))
    {
      RECORD ARRAY rows := arrayedit->value;
      DELETE FROM rows WHERE mask = row.mask;
      rows := rows CONCAT ToRecordArray(dialog->value, "mask");
      arrayedit->value := SELECT DISTINCT(mask) FROM rows;

      RETURN DEFAULT RECORD ARRAY; // we handled it, make the <arrayedit> think we canceled editting
    }

    RETURN ToRecordArray(dialog->value, "mask"); // Return each (space separated) mask as separate row
  }

  UPDATE BOOLEAN FUNCTION Submit()
  {
    IF(NOT this->BeginFeedback()->Finish())
      RETURN FALSE;

    IF (this->org_nullroute = FALSE AND ^smtpserver->value = "null") {
      IF (this->RunSimpleScreen("confirm", this->GetTid(".suredontsendemail")) != "yes")
        RETURN FALSE;
    }

    RETURN WRDEntityEditScreenBase::Submit();
  }
>;


PUBLIC STATIC OBJECTTYPE EditMailRouteRule EXTEND TolliumScreenBase
<
  PUBLIC STRING ARRAY value;

  MACRO Init(RECORD data)
  {
    ^mask->value := data.mask;
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT feedback := this->BeginFeedback();
    IF (feedback->HasFailed())
      RETURN feedback->Finish();

    this->value := ^mask->value != "" ? Tokenize(^mask->value, " ") : DEFAULT STRING ARRAY;

    RETURN feedback->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE EditCorrection EXTEND WRDEntityEditScreenBase
<
  UPDATE MACRO Validator(OBJECT work, RECORD updatevalue)
  {
    IF(NOT ^entity->^block->value AND Left(^entity->^rewriteto->value,2) != "*@")
      work->AddErrorFor(^entity->^rewriteto, this->GetTid(".invalidredirectto"));
  }
>;
