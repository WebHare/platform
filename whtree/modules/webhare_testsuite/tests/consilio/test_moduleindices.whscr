<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::os.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::consilio/lib/internal/updateindices.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

STRING ARRAY testcatalogs := [ "webhare_testsuite:testindex"
                             , "webhare_testsuite:module_reference"
                             , "webhare_testsuite:duplicate_fieldnames"
                             , "webhare_testsuite:circular_index_direct"
                             , "webhare_testsuite:circular_index_indirect"
                             , "webhare_testsuite:circular_module_reference"
                             ];
RECORD testindex;
INTEGER builtin_opensearch_id;

MACRO Prepare()
{
  IF(GetEnvironmentVariable("WEBHARE_PREFERINDEXMANAGER") != "")
    Print(`Note that moduleindices explicitly runs against OpenSearch even when legacy indexmanager is thhe default\n`);

  TestEq(1, Length(SELECT FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin), "One OpenSearch must exist");
  RECORD builtin_opensearch := SELECT * FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin;
  builtin_opensearch_id := builtin_opensearch.id;

  testfw->BeginWork();

  //Verify and cleanup from any previously (aborted)? testrun
  FOREVERY(STRING usedcatalog FROM testcatalogs)
  {
    OBJECT cat := OpenConsilioCatalog(usedcatalog);
    TestEq(TRUE, ObjectExists(cat), `Catalog "${usedcatalog}" should exist`);
    FOREVERY(RECORD toremove FROM cat->ListAttachedIndices())
      cat->DetachIndex(toremove.id);
    TestEq(RECORD[], cat->ListAttachedIndices(), `Catalog "${usedcatalog}" should have all attachments removed after initial cleanup`);
  }

  testfw->CommitWork();

  FixConsilioIndices();

  //Attach them
  testfw->BeginWork();
  FOREVERY(STRING usedcatalog FROM testcatalogs)
  {
    OBJECT cat := OpenConsilioCatalog(usedcatalog);
    TestEq(RECORD[], cat->ListAttachedIndices(), `Catalog "${usedcatalog}" should not start with any initially attached indices`);
    TestThrowsLike("Unexpected *INDEXMANAGER*", PTR cat->UpdateCatalog([ indexmanager := builtin_opensearch.id]), "Old API has been dropped");

    INTEGER index1id := cat->AttachIndex(builtin_opensearch_id);
    IF(#usedcatalog = 0) //we'll use testindex for some further tests
    {
      testindex := cat->ListAttachedIndices()[0];
      TestEqLike("c_??*", testindex.indexname, "test for properly structured builtin indexname");

      TestEqMembers([[ id := index1id
                     , indexmanager := builtin_opensearch.id
                     , type := "opensearch"
                     , primary := TRUE
                     , indexname := testindex.indexname
                     ]
                    ], cat->ListAttachedIndices(), "*");
    }

    Print(cat->GetStorageInfo()||"\n");
  }
  testfw->CommitWork();
}

MACRO TestESCreationAPIs()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");

  testfw->BeginWork();
  TestThrowsLike("No such indexmanager*", PTR catalog->AttachIndex(9999999));

  //we'll be rolling back this externalindex, just testing the API.
  INTEGER mock_external_index := MakeAutonumber(consilio.indexmanagers, "id");
  INSERT CELL[ id := mock_external_index
             , address := `http://127.0.0.1:${GetWebhareConfiguration().baseport + 6}/`
             , type := whconstant_consilio_indexmanager_opensearch
             , name := "mock_external_index"
             ] INTO consilio.indexmanagers;
  TestThrowsLike("*indexname*required*", PTR catalog->AttachIndex(mock_external_index));
  TestThrowsLike("*indexname*lowercase*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "_U" ]));
  TestThrowsLike("*Invalid*indexname*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "-u" ]));
  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname" ]);

  testfw->RollbackWork();

  // Ensure it doesn't exist in ES ... we'll do a raw action
  SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);

  // EnsureIt still doesn't exist on the index manager
  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Try the low level API first. Make sure it does exist
  catalog->EnsureIndex();
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(RECORD[[ suffix := "" ]], catalog->ListSuffixes());

  RECORD checkindex := SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "GET", `/${testindex.indexname}/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname).mappings.properties.keyword.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex.indexname).mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  catalog->EnsureIndex(); //calling twice should be okay, it's "Ensure" not "Create"

  // Delete it again from the index manager
  catalog->DeleteIndex();
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Create a subindex
  catalog->EnsureIndex([suffix := "suffix"]);
  result := GetIndexManagerIndexList(testindex.indexmanager, [ indexsuffixes := catalog->id ]);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(TRUE, "suffix" IN result.suffixes);
  TestEq(RECORD[[ suffix := "suffix" ]], catalog->ListSuffixes());

  checkindex := SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(),  "GET", `/${testindex.indexname}-suffix/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname || "-suffix").mappings.properties.keyword.type);

  catalog->EnsureIndex([suffix := "suffix"]); //calling twice should be okay, it's "Ensure" not "Create"

  // Delete it again from the index manager
  catalog->DeleteIndex();
  result := GetIndexManagerIndexList(testindex.indexmanager, [ indexsuffixes := catalog->id ]);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(FALSE, "suffix" IN result.suffixes);
  TestEq(RECORD[], catalog->ListSuffixes());

  // Create two subindices
  catalog->EnsureIndex([ suffix := "suffix1" ] );
  catalog->EnsureIndex([ suffix := "suffix2" ] );
  result := GetIndexManagerIndexList(testindex.indexmanager, [ indexsuffixes := catalog->id ]);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(2, Length(result.suffixes));
  TestEq(TRUE, "suffix1" IN result.suffixes);
  TestEq(TRUE, "suffix2" IN result.suffixes);
  TestEq(RECORD[[ suffix := "suffix1" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // Delete one of the subindices
  catalog->DeleteIndex([ suffix := "suffix1" ]);
  result := GetIndexManagerIndexList(testindex.indexmanager, [ indexsuffixes := catalog->id ]);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(1, Length(result.suffixes));
  TestEq(FALSE, "suffix1" IN result.suffixes);
  TestEq(TRUE, "suffix2" IN result.suffixes);
  TestEq(RECORD[[ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // We should be able open to the catalog
  catalog := OpenConsilioCatalog("webhare_testsuite:module_reference");
  TestEq(TRUE, ObjectExists(catalog));

  // It still doesn't exist on the index manager
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Make sure it does exist
  catalog->EnsureIndex();
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Delete it again from the index manager
  catalog->DeleteIndex();
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Check if duplicate fieldnames through including field groups are properly detected
  catalog := OpenConsilioCatalog("webhare_testsuite:duplicate_fieldnames");
  TestEq(TRUE, ObjectExists(catalog));
  TestThrowsLIKE("Duplicate property name 'textfield'", PTR catalog->EnsureIndex());

  // Check if circular fieldgroup references are properly detected
  catalog := OpenConsilioCatalog("webhare_testsuite:circular_index_direct");
  TestEq(TRUE, ObjectExists(catalog));
  TestThrowsLIKE("Index is too deep!", PTR catalog->EnsureIndex());
  catalog := OpenConsilioCatalog("webhare_testsuite:circular_index_indirect");
  TestEq(TRUE, ObjectExists(catalog));
  TestThrowsLIKE("Index is too deep!", PTR catalog->EnsureIndex());

  // Check if circular fieldgroup references are properly detected
  catalog := OpenConsilioCatalog("webhare_testsuite:circular_module_reference");
  TestEq(TRUE, ObjectExists(catalog));
  TestThrowsLIKE("Index is too deep!", PTR catalog->EnsureIndex());
}

MACRO TestESBulkInsertion()
{
  // Ensure index doesn't exist in ES ... we'll do a raw action
  SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);

  // Make sure it's indeed nonexistent
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  TestEq(TRUE, ObjectExists(catalog));
  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  //Offering an undeclared cell must fail (this tests ES error handling, if we start catching errors earlier we might need something else or a raw mode to explicitly trigger ES error handling)
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ 'no.such.field.yet' := 42 ]
                    ]],[ suffix := "sub1"]));

  //But we should be able to manually offer it if we specify a mapping containing it
  catalog->EnsureIndex( [ suffix := "sub1", fieldgroups := [ "webhare_testsuite:nosuchfieldyet" ] ]);
  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // Test record mapping
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // In Elasticsearch, all fields can contain arrays
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
          [ no :=
              [ [ such :=
                  [ field :=
                      [ [ yet := 41 ]
                      , [ yet := 45 ]
                      ]
                  ]
                ]
              , [ such :=
                  [ field :=
                      [ yet := [ 42, 43, 44 ] ]
                  ]
                ]
              ]
          ]
        ]
      ], [ suffix := "sub1", synchronous := TRUE ]);
  // Test record array mapping
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq(
      [ no :=
          [ [ such :=
              [ field :=
                    // Single 'yet' values got converted to arrays as per requested mapping
                  [ [ yet := [ 41 ] ]
                  , [ yet := [ 45 ] ]
                  ]
              ]
            ]
          , [ such :=
                // Single 'field' value got converted to array as per requested mapping
              [ field :=
                  [ [ yet := [ 42, 43, 44 ] ] ]
              ]
            ]
          ]
      ], res.results[0]);

  // Add more objects
  catalog->AddObjects(
      [ [ objectid := "test2"
        , documentfields := [ no := [ such := [ field := [ yet := [ 2, 42, 55 ] ] ] ] ]
        ]
      , [ objectid := "test3"
        , documentfields := [ no := [ such := [ field := [ yet := [ 100 ] ] ] ] ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  // Sort results by 'no.such.field.yet' ascending, checks for minimum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      ]);
  TestEq(
        // min(no.such.field.yet) = 2
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // min(no.such.field.yet) = 41
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // min(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending, checks for maximum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      , orderdesc := TRUE
      ]);
  TestEq(
        // max(no.such.field.yet) = 100
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 55
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 45
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending using the average 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // avg(no.such.field.yet) = 43
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // avg(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Delete the object
  catalog->DeleteObjects([ "test1", "test2", "test3" ], [ suffix := "sub1", synchronous := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  //Test store-only fields
  catalog->EnsureIndex([ suffix := "sub1", fieldgroups := [ "webhare_testsuite:storeonly" ] ]);
  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ indexed := "test", stored := "test" ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // 'indexed:test' can be found, the 'stored' field returned
  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("indexed", "=", "test"),
      [ mapping := [ indexed := "", stored := "" ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ indexed := "test", stored := "test" ], res.results[0]);

  // The 'stored' field cannot be searched on
  TestThrowsLike("*Cannot search*stored*not indexed*", PTR RunConsilioSearch("webhare_testsuite:testindex", CQMatch("stored", "=", "test"), [ throwonfailure := TRUE ]));

  //Can't offer xyz yet to our unspecified_record
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]));

  //But we should be able to set it through a wildcard if we add it
  catalog->EnsureIndex( [ suffix := "sub1", fieldgroups := [ "webhare_testsuite:unspecifiedwildcards" ] ]);
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]);

  // Once dynamically initialized, the type is fixed
  TestThrowsLike("*(mapper_parsing_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := "XYZ" ]
        ]
      ],[ suffix := "sub1" ]));
  // The string "44" can be converted to an integer
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := "44" ]
        ]
      ],[ suffix := "sub1" ]);

  // Add a datetime property
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
            [ unspecified_record :=
                [ "datetime" := AddTimeToDate(789, MakeDateTime(2000, 1, 2, 12, 34, 56))
                , "integer" := 1234
                , "integer64" := 1024i64 * 1024 * 1024 * 1024
                , "money" := 1234.56
                , "float" := .015625
                , "string" := "1234"
                ]
            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:testindex", CQHas("unspecified_record.datetime"),
      [ mapping :=
          [ unspecified_record :=
              [ "datetime" := DEFAULT DATETIME
              , "integer" := 0
              , "integer64" := 0i64
              , "money" := 0m
              , "float" := 0f
              , "string" := ""
              ]
          ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEQ(
      [ unspecified_record :=
          [ "datetime" := AddTimeToDate(789, MakeDateTime(2000, 1, 2, 12, 34, 56))
          , "integer" := 1234
          , "integer64" := 1024i64 * 1024 * 1024 * 1024
          , "money" := 1234.56
          , "float" := .015625
          , "string" := "1234"
          ]
      ], res.results[0]);

  //Ensure dynamic templates work
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'group_record_field.ds_text' := 44 ]
        ]
      ],[ suffix := "sub1" ]);

  //Verify ds_Text's mapping
  RECORD checkindex := SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "GET", `${testindex.indexname}-sub1/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname || "-sub1").mappings.properties.group_record_field.properties.ds_text.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex.indexname || "-sub1").mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  // Throw some objects into a suffix. We want the index to sort it out
  RECORD ARRAY docs;
  //2*28*24 * 3 = 4032 events
  FOR(INTEGER month := 1; month <= 2; month := month + 1)
    FOR(INTEGER day := 1; day <= 28; day := day + 1)
      FOR(INTEGER hour := 0; hour <= 23; hour := hour + 1)
        FOR(INTEGER hit := 0; hit <= 2; hit := hit + 1)
      {
        DATETIME ts := MakeDatetime(2018,month,day,hour,0,0);
        STRING tstext := FormatISO8601Datetime(ts);
        INSERT CELL[ objectid := "obj_" || hit || "_" || tstext
                   , documentfields := [ "@timestamp" := ts
                                       , "title" := `My lovely doc for ${tstext} hit #${hit}`
                                       , int_field := (((month*100)+day)*100+hour)*100+hit
                                       ]
                   ] INTO docs AT END;

      }

  //Blast my docs into ES
  catalog->AddObjects(docs, [ suffix := "sub2"
                            , synchronous := TRUE
                            , chunksize := Length(docs)/2 + 2
                            ]);

  //Verify subindex was properly ensured
  checkindex := SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "GET", `${testindex.indexname}-sub2/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname || "-sub2").mappings.properties.keyword.type);

  res := RunConsilioSearch("webhare_testsuite:testindex", CQMatch("int_field", "=", docs[END-1].documentfields.int_field));
  //dumpvalue(res,'tree');
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);

  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery('"My lovely doc for 2018-02-28T23:00:00Z hit #2"'));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);
}

MACRO TestESLangFeatures()
{
  // Recreate the index
  SendRawJSONToElasticsearch(GetBuiltinElasticSearchId(), "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  catalog->EnsureIndex();

  // As defined in the module definition
  TestEq("nl", catalog->lang);

  // Add a document with some Dutch and English words
  RECORD doc :=
      [ objectid := "objectid_1"
      , documentfields := [ title := "boekjes booking" ]
      ];
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // Find the document using Dutch stemming (both 'boekjes' and 'geboekt' will be stemmed down to 'boek')
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(1, res.totalcount);
  // It cannot be found using English stemming, because the document is indexed using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(0, res.totalcount);

  // Change the language
  testfw->BeginWork();
  TestEq(TRUE, catalog->UpdateCatalog([ lang := "en" ]));
  TestEq("en", catalog->lang);
  testfw->CommitWork();

  // Reindex the document (an unmanaged index isn't rebuilt automatically)
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // The document can no longer be found using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(0, res.totalcount);
  // But it can be found using English stemming (both 'booking' and 'booked' are stemmed down to 'book')
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(1, res.totalcount);

  // Reset the language
  testfw->BeginWork();
  catalog->UpdateCatalog([ lang := "nl" ]);
  testfw->CommitWork();
}

MACRO TestESDeletion()
{
  // Delete the catalog itself - FIXME dont touch our main testing catalog, it will unlink it from the ES instance, annoying testers
  testfw->BeginWork();
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  //catalog->DeleteSelf();
  testfw->CommitWork();

  // We cannot check if the index is deleted from the index manager, because that happens in a separate task, which we cannot wait upon

  //FIXME we should not leave the system in an inconsistent state (deleting and index that should exist due to module  definition ruels)  test with a scratch api?
}

RunTestframework(
    [ PTR Prepare
    , PTR TestESCreationAPIs
    , PTR TestESBulkInsertion
    , PTR TestESLangFeatures
    , PTR TestESDeletion
    ]);
