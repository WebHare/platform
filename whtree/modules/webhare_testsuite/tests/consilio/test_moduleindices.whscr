<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/updateindices.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";

LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

RECORD testindex, testindex_suffixed;
RECORD builtin_opensearch;

MACRO TestAPI()
{
  TestEq(FALSE, IsValidConsilioIndexName("_abc"));
  TestEq(FALSE, IsValidConsilioIndexName(".kibana"));
  TestEq(FALSE, IsValidConsilioIndexName("KIBANA"));
  TestEq(TRUE, IsValidConsilioIndexName("mydata"));
  TestEq(FALSE, IsValidConsilioIndexName("mydata-"));
  TestEq(FALSE, IsValidConsilioIndexName("mydata_"));
  TestEq(TRUE, IsValidConsilioIndexName("my_data"));
  TestEq(FALSE, IsValidConsilioIndexName(""));

  TestEq(FALSE, IsValidConsilioIndexName("2022"));
  TestEq(FALSE, IsValidConsilioIndexName("2022-05"));

  TestEq(TRUE, IsValidConsilioIndexSuffix("2022"));
  TestEq(TRUE, IsValidConsilioIndexSuffix("2022-05"));
  TestEq(FALSE, IsValidConsilioIndexSuffix(""));
  TestEq(FALSE, IsValidConsilioIndexSuffix("-abc"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("_abc"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("ABC"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("abc-"));
  TestEq(TRUE, IsValidConsilioIndexSuffix("abc"));

  RECORD testsitecatalogdef := CalculateExpectedConfiguration(["webhare_testsuite:pagelistfields"], TRUE, INTEGER[]);
  dumpvalue(testsitecatalogdef,'tree');
  TestEqMembers([[ name := "myfield1", type := "text" ]], (SELECT * FROM testsitecatalogdef.fields WHERE name = "myfield1"),"*");
  TestEqMembers([[ name := "groupid", type := "keyword" ]], (SELECT * FROM testsitecatalogdef.fields WHERE name = "groupid"),"*");

  RECORD testindexfieldsdef := CalculateExpectedConfiguration(["webhare_testsuite:testindexfields"], TRUE, INTEGER[]);
  TestEqMembers([[ name := "record_field", type := "record"
                 , properties := [[ name := "record_text_field", type := "text" ]
                                 ,[ name := "dn_*", type := "integer" ]
                                 ]
                ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "record_field"),"*");

  TestEqMembers([[ name := "group_int_field", type := "integer" ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "group_int_field"),"*", `group_int_field should have been included through <addfieldgroup ref="testgroup" />`);
  TestEqMembers([[ name := "group_record_field", type := "record"
                 , properties := [[ name := "group_record_text_field", type := "text" ]
                                 ,[ name := "ds_*", type := "keyword" ]
                                 ,[ name := "when", type := "datetime" ]
                                 ,[ name := "where", type := "latlng" ]
                                 ,[ name := "db_*", type := "boolean" ]
                                 ]
                ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "group_record_field"),"*");

  // Check if duplicate fieldnames through including field groups are properly detected
  TestThrowsLike("Duplicate property name 'textfield'", PTR CalculateExpectedConfiguration(["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"], FALSE, INTEGER[]));

  testfw->BeginWork();
  TestThrowsLike("Duplicate property name 'textfield'", PTR CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, fieldgroups := ["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"] ]));
  OBJECT catalog := CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, fieldgroups := ["webhare_testsuite:fields_1" ]]);
  TestThrowsLike("Duplicate property name 'textfield'", PTR catalog->UpdateCatalog([fieldgroups := ["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"]]));
  testfw->RollbackWork();

  // Check if circular fieldgroup references are properly detected
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["webhare_testsuite:circular"], FALSE, INTEGER[]), `Test <catalog tag="circular_index_direct" managed="false" fieldgroups="circular" />`);
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["webhare_testsuite:circular_1"], FALSE, INTEGER[]), `Test <catalog tag="circular_index_indirect" managed="false" fieldgroups="circular_1" />`);
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["consilio:circular_test_reference_group"], FALSE, INTEGER[]), `<catalog tag="circular_module_reference" managed="false" fieldgroups="consilio:circular_test_reference_group" />`);
}

MACRO TestUpdateIndicesMetadata()
{
  //Is updateindices setting up all metadata properly
  TestEq(1, Length(SELECT FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin), "One OpenSearch must exist");

  testfw->BeginWork();

  //Force deletion and recreation, they'll be garbage collected - but leave managed indices alone, our test doesn't use them and recreation takes time
  DELETE FROM consilio.catalogs WHERE name LIKE "webhare_testsuite:*" AND type = whconstant_consilio_catalogtype_unmanaged;
  testfw->CommitWork();

  FixConsilioIndices([ catalogmask := "webhare_testsuite:*" ]);

  RECORD ARRAY toolslog_mapping := OpenConsilioCatalog("webhare_testsuite:toolslog")->GetExpectedMapping();
  TestEq(TRUE, RecordExists(toolslog_mapping), "Should have been able to parse it");
  //dumpvalue(toolslog_mapping,'tree');
  TestEqMembers([[ name := "@timestamp", type := "datetime" ]], (SELECT * FROM toolslog_mapping WHERE name = "@timestamp"),"*");
  TestEqMembers([[ name := "minfin", type := "record", defaultvalue:= DEFAULT RECORD
                 , properties := [[ name := "theme",     type := "keyword" ]
                                 ,[ name := "tool",      type := "keyword" ]
                                 ,[ name := "type",      type := "keyword" ]
                                 ,[ name := "versionnr", type := "integer" ]
                                 ]
                ]], (SELECT * FROM toolslog_mapping WHERE name = "minfin"),"*");

  //TODO maybe we should get rid of the broken indices and only CalculateExpectedConfiguration them to keep logs clean?
  TestEq(RECORD[], OpenConsilioCatalog("webhare_testsuite:duplicate_fieldnames")->GetExpectedMapping());
}

MACRO PrepareIndices()
{
  builtin_opensearch := SELECT * FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin;

  //Verify the found opensearch url is correct
  TestEq(TRUE, testfw->browser->GotoWebPage(builtin_opensearch.url || "_cluster/health"));
  TestEq(TRUE, CellExists(DecodeJSONBlob(testfw->browser->content), "cluster_name"));
}

MACRO TestInitialAttachment()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  TestEq(FALSE, catalog->IsReadyForStorage(), "Can't be ready, no attached indices");

  testfw->BeginWork();
  INTEGER index1id := catalog->AttachIndex(builtin_opensearch.id);
  testindex := catalog->ListAttachedIndices()[0];
  TestEqLike("c_??*", testindex.indexname, "test for properly structured builtin indexname");

  TestEqMembers([[ id := index1id
                 , indexmanager := builtin_opensearch.id
                 , type := "opensearch"
                 , searchpriority := 100
                 , indexname := testindex.indexname
                 , readonly := FALSE
                 ]
                ], catalog->ListAttachedIndices(), "*");

  catalog->AttachIndex(builtin_opensearch.id, [ readonly := TRUE ]);
  Print(catalog->GetStorageInfo() || "\n");
  TestEq(FALSE, catalog->IsReadyForStorage(), "An unsuffixed index is not ready until attachment are commited");
  testfw->CommitWork();

  TestEq(TRUE, catalog->IsReadyForStorage(), "Has to be ready, CommitWork after AttachIndex synchronously applies the configuration");
}

MACRO TestMappingUpdates()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");

  //Test fieldgroup updates
  testfw->BeginWork();
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");
  TestEq(["webhare_testsuite:testindexfields"], catalog->fieldgroups);
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:nosuchfieldyet", ...catalog->fieldgroups ] ]);
  TestEqMembers([[name := "nosuchfieldyet_extra" ]], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");

  RECORD ARRAY diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["missing"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "missing"));

  testfw->CommitWork();

  //After commit, the catalogchange should be applied and no issues should remain
  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEQ(RECORD[], diff);

  //Now undo the fieldgroup change...
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := STRING[] ]);
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");

  catalog->UpdateCatalog(CELL[ fieldgroups := STRING["webhare_testsuite:testindexfields"] ]);
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");

  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["superfluous"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "superfluous"));

  testfw->CommitWork();

  //Commit doesn't change a thing - there's no way to get rid of existing mappings
  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["superfluous"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "superfluous"));
}

MACRO TestESCreationAPIs()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");

  testfw->BeginWork();
  TestThrowsLike("No such indexmanager*", PTR catalog->AttachIndex(9999999));
  TestThrowsLike("*managed*suffix*", PTR CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, suffixed := TRUE ]));

  //we'll be rolling back this externalindex, just testing the API.
  INTEGER mock_external_index := MakeAutonumber(consilio.indexmanagers, "id");
  INSERT CELL[ id := mock_external_index
             , address := builtin_opensearch.url
             , type := whconstant_consilio_indexmanager_opensearch
             , name := "mock_external_index"
             ] INTO consilio.indexmanagers;
  TestThrowsLike("*indexname*required*", PTR catalog->AttachIndex(mock_external_index));
  TestThrowsLike("*indexname*lowercase*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "_U" ]));
  TestThrowsLike("*Invalid*indexname*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "-u" ]));
  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname", readonly := TRUE ]);

  TestEq(TRUE, catalog->IsReadyForStorage(), "Should appear ready, readonly indices not relevant");

  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname2", readonly := FALSE ]);
  TestEq(FALSE, catalog->IsReadyForStorage(), "Can't be ready, not commited");

  testfw->RollbackWork();

  // Verify the readonly index was not created
  RECORD ARRAY indices := catalog->ListAttachedIndices();
  TestEq(TRUE, indices[1].readonly);

  TestEq(TRUE, RecordExists(SendRawJSONToElasticsearch(indices[0].indexmanager, "GET", `/${indices[0].indexname}`, DEFAULT RECORD).result));
  TestThrowsLike("*404*", PTR SendRawJSONToElasticsearch(indices[1].indexmanager, "GET", `/${indices[1].indexname}`, DEFAULT RECORD));

  // Explicitly delete from ES
  SendRawJSONToElasticsearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM result.indices WHERE indexid = catalog->id);
  TestEq(RECORD[], catalog->ListSuffixes());
  TestEq(FALSE, catalog->IsReadyForStorage(), "With the index gone, we're no longer ready");

  // Recreate it
  catalog->ApplyConfiguration();
  TestEq(TRUE, catalog->IsReadyForStorage(), "ApplyConfiguration should have fixed it");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(RECORD[[ suffix := "" ]], catalog->ListSuffixes());

  RECORD checkindex := SendRawJSONToElasticsearch(testindex.indexmanager, "GET", `/${testindex.indexname}/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname).mappings.properties.keyword.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex.indexname).mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  __did_opensearch_close_and_reopen := FALSE; //it seems we lack another way to observe an unneeded change happening
  catalog->ApplyConfiguration(); //calling twice should be okay, it's an Ensure not a "Create"
  TestEq(FALSE, __did_opensearch_close_and_reopen, "Apply should have been a no-op");

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM result.indices WHERE indexid = catalog->id);

  // Create a subindex
  catalog := OpenConsilioCatalog("webhare_testsuite:testindex_suffixed");
  TestEq(RECORD[], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);
  testfw->BeginWork();
  catalog->AttachIndex(0);
  catalog->AttachIndex(0, [ readonly := TRUE ]);
  Print(catalog->GetStorageInfo() || "\n");
  TestEq(TRUE, catalog->IsReadyForStorage(), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
  testindex_suffixed := catalog->ListAttachedIndices()[0];
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:testindexfields" ] ]);
  testfw->CommitWork();

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);
  TestEq(RECORD[[ suffix := "suffix" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager,  "GET", `/${testindex_suffixed.indexname}-suffix/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-suffix").mappings.properties.keyword.type);

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);  //calling twice should be okay, it's "Ensure" not "Create"

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  TestEq(RECORD[], catalog->ListSuffixes());

  // Create two subindices
  catalog->ApplyConfiguration([ suffixes := ["suffix1","suffix2"]]);
  TestEq(RECORD[[ suffix := "suffix1" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // Delete one of the subindices
  catalog->DeleteSuffix("suffix1");
  TestEq(RECORD[[ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // We should be able open to the catalog
  catalog := OpenConsilioCatalog("webhare_testsuite:module_reference");
  TestEq(TRUE, ObjectExists(catalog));

  testfw->BeginWork();
  catalog->AttachIndex(0);
  testfw->CommitWork();

  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));
}

MACRO TestESBulkInsertion()
{
  // Ensure index doesn't exist in ES ... we'll do a raw action
  SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "DELETE", `/${testindex_suffixed.indexname}*`, DEFAULT RECORD);

  // Make sure it's indeed nonexistent
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex_suffixed");
  TestEq(TRUE, ObjectExists(catalog));
  TestEq(TRUE, catalog->IsReadyForStorage(), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
  Print(catalog->GetStorageInfo()||"\n");

  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  //Offering an undeclared cell must fail (this tests ES error handling, if we start catching errors earlier we might need something else or a raw mode to explicitly trigger ES error handling)
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ 'no.such.field.yet' := 42 ]
                    ]],[ suffix := "sub1"]));

  //But we should be able to manually offer it if we specify a mapping containing it
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:nosuchfieldyet" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // Test searching for nothing (some queries optimize to CQNothing - this shouldn't crash)
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQNothing(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEqMembers([ totalcount := 0, results := RECORD[]], res, "*");

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAll(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQNot(CQNothing()),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // Test record mapping
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAnd([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQOr([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // In Elasticsearch, all fields can contain arrays
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
          [ no :=
              [ [ such :=
                  [ field :=
                      [ [ yet := 41 ]
                      , [ yet := 45 ]
                      ]
                  ]
                ]
              , [ such :=
                  [ field :=
                      [ yet := [ 42, 43, 44 ] ]
                  ]
                ]
              ]
          ]
        ]
      ], [ suffix := "sub1", synchronous := TRUE ]);

  // Test record array mapping
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq(
      [ no :=
          [ [ such :=
              [ field :=
                    // Single 'yet' values got converted to arrays as per requested mapping
                  [ [ yet := [ 41 ] ]
                  , [ yet := [ 45 ] ]
                  ]
              ]
            ]
          , [ such :=
                // Single 'field' value got converted to array as per requested mapping
              [ field :=
                  [ [ yet := [ 42, 43, 44 ] ] ]
              ]
            ]
          ]
      ], res.results[0]);

  // Add more objects
  catalog->AddObjects(
      [ [ objectid := "test2"
        , documentfields := [ nosuchfieldyet_extra := "Test2"
                            , no := [ such := [ field := [ yet := [ 2, 42, 55 ] ] ] ]
                            ]
        ]
      , [ objectid := "test3"
        , documentfields := [ nosuchfieldyet_extra := "Test3"
                            , no := [ such := [ field := [ yet := [ 100 ] ] ] ]
                            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  // Sort results by 'no.such.field.yet' ascending, checks for minimum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      ]);
  TestEq(
        // min(no.such.field.yet) = 2
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // min(no.such.field.yet) = 41
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // min(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending, checks for maximum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      , orderdesc := TRUE
      ]);
  TestEq(
        // max(no.such.field.yet) = 100
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 55
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 45
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending using the average 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // avg(no.such.field.yet) = 43
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // avg(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Test raw query ability
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAnd( [ CQMatch("no.such.field.yet", "IN", [ 42, 100 ])
                                                                          , CQOpenSearch( [ match := [ nosuchfieldyet_extra := "Test3" ]])
                                                                          ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Delete the object
  catalog->DeleteObjects([ "test1", "test2", "test3" ], [ suffix := "sub1", foreground := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  //Test store-only fields
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:storeonly" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ indexed := "test", stored := "test" ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // 'indexed:test' can be found, the 'stored' field returned
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("indexed", "=", "test"),
      [ mapping := [ indexed := "", stored := "" ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ indexed := "test", stored := "test" ], res.results[0]);

  // The 'stored' field cannot be searched on
  TestThrowsLike("*Cannot search*stored*not indexed*", PTR RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("stored", "=", "test")));

  //Can't offer xyz yet to our unspecified_record
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]));

  //But we should be able to set it through a wildcard if we add it
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:testindexfields"  ] ]);
  testfw->CommitWork();

  //WAS: Ensure dynamic templates work. NOW: ensure the field coes not get added
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'group_record_field.ds_text' := 44 ]
        ]
      ],[ suffix := "sub1" ]);

  //Verify ds_Text's mapping
  RECORD checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub1/_mapping`, DEFAULT RECORD);
  TestEq(FALSE, CelLExists(GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties, "ds_text"));
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  // Throw some objects into a suffix. We want the index to sort it out
  RECORD ARRAY docs;
  //2*28*24 * 3 = 4032 events
  FOR(INTEGER month := 1; month <= 2; month := month + 1)
    FOR(INTEGER day := 1; day <= 28; day := day + 1)
      FOR(INTEGER hour := 0; hour <= 23; hour := hour + 1)
        FOR(INTEGER hit := 0; hit <= 2; hit := hit + 1)
      {
        DATETIME ts := MakeDatetime(2018,month,day,hour,0,0);
        STRING tstext := FormatISO8601Datetime(ts);
        INSERT CELL[ objectid := "obj_" || hit || "_" || tstext
                   , documentfields := [ "@timestamp" := ts
                                       , "title" := `My lovely doc for ${tstext} hit #${hit}`
                                       , int_field := (((month*100)+day)*100+hour)*100+hit
                                       ]
                   ] INTO docs AT END;

      }

  //Blast my docs into ES
  catalog->AddObjects(docs, [ suffix := "sub2"
                            , synchronous := TRUE
                            , chunksize := Length(docs)/2 + 2
                            ]);

  //Verify subindex was properly ensured
  checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub2/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-sub2").mappings.properties.keyword.type);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("int_field", "=", docs[END-1].documentfields.int_field));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQParseUserQuery('"My lovely doc for 2018-02-28T23:00:00Z hit #2"'));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);
}

MACRO TestESLangFeatures()
{
  // Recreate the index
  SendRawJSONToElasticsearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  catalog->ApplyConfiguration();

  // As defined in the module definition
  TestEq("nl", catalog->lang);

  // Add a document with some Dutch and English words
  RECORD doc :=
      [ objectid := "objectid_1"
      , documentfields := [ title := "boekjes booking" ]
      ];
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // Find the document using Dutch stemming (both 'boekjes' and 'geboekt' will be stemmed down to 'boek')
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(1, res.totalcount);
  // It cannot be found using English stemming, because the document is indexed using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(0, res.totalcount);

  // Change the language
  testfw->BeginWork();
  TestEq(TRUE, catalog->UpdateCatalog([ lang := "en" ]));
  TestEq("en", catalog->lang);
  TestThrowsLike("*must commit*", PTR catalog->AddObjects([ doc ], [ synchronous := TRUE ]));
  testfw->CommitWork();

  // Reindex the document (an unmanaged index isn't rebuilt automatically)
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // The document can no longer be found using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(0, res.totalcount);
  // But it can be found using English stemming (both 'booking' and 'booked' are stemmed down to 'book')
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(1, res.totalcount);

  // Reset the language
  testfw->BeginWork();
  catalog->UpdateCatalog([ lang := "nl" ]);
  testfw->CommitWork();
}

MACRO TestESDeletion()
{
  // Delete the catalog itself - FIXME dont touch our main testing catalog, it will unlink it from the ES instance, annoying testers
  testfw->BeginWork();
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  //catalog->DeleteSelf();
  testfw->CommitWork();

  // We cannot check if the index is deleted from the index manager, because that happens in a separate task, which we cannot wait upon

  //FIXME we should not leave the system in an inconsistent state (deleting and index that should exist due to module  definition ruels)  test with a scratch api?
}

RunTestframework(
    [ PTR TestAPI
    , PTR TestUpdateIndicesMetadata
    , PTR PrepareIndices
    , PTR TestInitialAttachment
    , PTR TestMappingUpdates
    , PTR TestESCreationAPIs
    , PTR TestESBulkInsertion
    , PTR TestESLangFeatures
    , PTR TestESDeletion
    ]);
