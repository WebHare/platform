<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/updateindices.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/stats.whlib";

LOADLIB "mod::system/lib/tasks.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/logging.whlib";

RECORD testindex, testindex_suffixed;
RECORD builtin_opensearch;

MACRO TestAPI()
{
  TestEq(FALSE, IsValidConsilioIndexName("_abc"));
  TestEq(FALSE, IsValidConsilioIndexName(".kibana"));
  TestEq(FALSE, IsValidConsilioIndexName("KIBANA"));
  TestEq(TRUE, IsValidConsilioIndexName("mydata"));
  TestEq(FALSE, IsValidConsilioIndexName("mydata-"));
  TestEq(FALSE, IsValidConsilioIndexName("mydata_"));
  TestEq(TRUE, IsValidConsilioIndexName("my_data"));
  TestEq(FALSE, IsValidConsilioIndexName(""));

  TestEq(FALSE, IsValidConsilioIndexName("2022"));
  TestEq(FALSE, IsValidConsilioIndexName("2022-05"));

  TestEq(TRUE, IsValidConsilioIndexSuffix("2022"));
  TestEq(TRUE, IsValidConsilioIndexSuffix("2022-05"));
  TestEq(FALSE, IsValidConsilioIndexSuffix(""));
  TestEq(FALSE, IsValidConsilioIndexSuffix("-abc"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("_abc"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("ABC"));
  TestEq(FALSE, IsValidConsilioIndexSuffix("abc-"));
  TestEq(TRUE, IsValidConsilioIndexSuffix("abc"));

  RECORD testsitecatalogdef := CalculateExpectedConfiguration(["webhare_testsuite:pagelistfields"], TRUE, "", RECORD[], "");
  TestEqMembers([[ name := "myfield1", type := "text" ]], (SELECT * FROM testsitecatalogdef.fields WHERE name = "myfield1"),"*");
  TestEqMembers([[ name := "groupid", type := "keyword" ]], (SELECT * FROM testsitecatalogdef.fields WHERE name = "groupid"),"*");

  RECORD testindexfieldsdef := CalculateExpectedConfiguration(["webhare_testsuite:testindexfields"], TRUE, "", RECORD[], "");
  TestEqMembers([[ name := "record_field", type := "record"
                 , properties := [[ name := "record_text_field", type := "text" ]
                                 ,[ name := "dn_*", type := "integer" ]
                                 ]
                ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "record_field"),"*");

  TestEqMembers([[ name := "group_int_field", type := "integer" ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "group_int_field"),"*", `group_int_field should have been included through <addfieldgroup ref="testgroup" />`);
  TestEqMembers([[ name := "group_record_field", type := "record"
                 , properties := [[ name := "group_record_text_field", type := "text" ]
                                 ,[ name := "ds_*", type := "keyword" ]
                                 ,[ name := "when", type := "datetime" ]
                                 ,[ name := "where", type := "latlng" ]
                                 ,[ name := "db_*", type := "boolean" ]
                                 ]
                ]], (SELECT * FROM testindexfieldsdef.fields WHERE name = "group_record_field"),"*");

  // Check if duplicate fieldnames through including field groups are properly detected
  TestThrowsLike("Duplicate property name 'textfield'", PTR CalculateExpectedConfiguration(["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"], FALSE, "", RECORD[], ""));

  testfw->BeginWork();
  TestThrowsLike("Duplicate property name 'textfield'", PTR CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, fieldgroups := ["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"] ]));
  OBJECT catalog := CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, fieldgroups := ["webhare_testsuite:fields_1" ]]);
  TestThrowsLike("Duplicate property name 'textfield'", PTR catalog->UpdateCatalog([fieldgroups := ["webhare_testsuite:fields_1", "webhare_testsuite:fields_2"]]));
  testfw->RollbackWork();

  // Check if circular fieldgroup references are properly detected
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["webhare_testsuite:circular"], FALSE, "", RECORD[], ""), `Test <catalog tag="circular_index_direct" managed="false" fieldgroups="circular" />`);
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["webhare_testsuite:circular_1"], FALSE, "", RECORD[], ""), `Test <catalog tag="circular_index_indirect" managed="false" fieldgroups="circular_1" />`);
  TestThrowsLike("Index is too deep!", PTR CalculateExpectedConfiguration(["consilio:circular_test_reference_group"], FALSE, "", RECORD[], ""), `<catalog tag="circular_module_reference" managed="false" fieldgroups="consilio:circular_test_reference_group" />`);
}

MACRO TestUpdateIndicesMetadata()
{
  //Is updateindices setting up all metadata properly
  TestEq(1, Length(SELECT FROM ListIndexManagers() WHERE isbuiltin), "One OpenSearch must exist");

  testfw->BeginWork();

  //Force deletion and recreation, they'll be garbage collected - but leave managed indices alone, our test doesn't use them and recreation takes time
  DELETE FROM consilio.catalogs WHERE name LIKE "webhare_testsuite:*" AND type = whconstant_consilio_catalogtype_unmanaged;
  testfw->CommitWork();

  FixConsilioIndices([ catalogmask := "webhare_testsuite:*" ]);

  RECORD ARRAY toolslog_mapping := OpenConsilioCatalog("webhare_testsuite:toolslog")->GetExpectedMapping();
  TestEq(TRUE, RecordExists(toolslog_mapping), "Should have been able to parse it");
  TestEqStructure([[name := "", type := "", definedby := "" ]], SELECT name,type,definedby FROM toolslog_mapping);
  //dumpvalue(toolslog_mapping,'tree');
  TestEqMembers([[ name := "@timestamp", type := "datetime" ]], (SELECT * FROM toolslog_mapping WHERE name = "@timestamp"),"*");
  TestEqMembers([[ name := "minfin", type := "record", defaultvalue:= DEFAULT RECORD
                 , properties := [[ name := "theme",     type := "keyword" ]
                                 ,[ name := "tool",      type := "keyword" ]
                                 ,[ name := "type",      type := "keyword" ]
                                 ,[ name := "versionnr", type := "integer" ]
                                 ]
                ]], (SELECT * FROM toolslog_mapping WHERE name = "minfin"),"*");
}

MACRO PrepareIndices()
{
  builtin_opensearch := SELECT * FROM ListIndexManagers() WHERE isbuiltin;

  //Verify the found opensearch url is correct
  TestEq(TRUE, testfw->browser->GotoWebPage(builtin_opensearch.url || "_cluster/health"));
  TestEq(TRUE, CellExists(DecodeJSONBlob(testfw->browser->content), "cluster_name"));
}

MACRO TestInitialAttachment()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  TestEq(FALSE, catalog->managed);
  TestEq(FALSE, catalog->IsReadyForStorage(), "Can't be ready, no attached indices");

  testfw->BeginWork();
  INTEGER index1id := catalog->AttachIndex(builtin_opensearch.id);
  testindex := catalog->ListAttachedIndices()[0];
  TestEqLike("c_??*", testindex.indexname, "test for properly structured builtin indexname");

  TestEqMembers([[ id := index1id
                 , indexmanager := builtin_opensearch.id
                 , searchpriority := 100
                 , indexname := testindex.indexname
                 , readonly := FALSE
                 ]
                ], catalog->ListAttachedIndices(), "*");

  catalog->AttachIndex(builtin_opensearch.id, [ readonly := TRUE ]);
  Print(catalog->GetStorageInfo() || "\n");
  TestEq(FALSE, catalog->WaitReady(DEFAULT DATETIME), "An unsuffixed index can't be ready before attachments are commited");
  testfw->CommitWork();

  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME));
}

MACRO TestMappingUpdates()
{
  //Setup the index we'll be testing against, give it an intial config
  testfw->BeginWork();
  OBJECT catalog := CreateConsilioCatalog("webhare_testsuite:tmpindex", [ fieldgroups := ["webhare_testsuite:testindexfields"], managed := FALSE , lang := "nl"]);
  catalog->AttachIndex(0);
  testfw->CommitWork();

  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));
  testindex := catalog->ListAttachedIndices()[0];

  //Test fieldgroup updates
  testfw->BeginWork();
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");
  TestEq(["webhare_testsuite:testindexfields"], catalog->fieldgroups);
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:nosuchfieldyet", ...catalog->fieldgroups ]
                             , title := "added nosuchfieldyet"
                             , priority := 2
                             ]);
  TestEqMembers([[name := "nosuchfieldyet_extra" ]], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");
  TestEq("added nosuchfieldyet", catalog->title);
  TestEq(2, catalog->priority);

  //Note that as we didn't commit the changes from the last UpdateCatalog yet, we'll be comparing against the initial situation
  RECORD ARRAY diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["missing"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra","nosuchfieldyet_extra2"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "missing"));
  testfw->CommitWork();

  TestEq("added nosuchfieldyet", OpenConsilioCatalog(catalog->tag)->title);
  TestEq(2, OpenConsilioCatalog(catalog->tag)->priority);

  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  //After commit, the catalogchange should be applied and no issues should remain
  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEQ(RECORD[], diff);

  //Cannot add objects with a suffix to an unsuffixed index
  TestThrowsLike("Cannot AddObjects*to a suffix*", PTR catalog->AddObjects(
                    [[ objectid := "fieldtest1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]));

  catalog->AddObjects(
                    [[ objectid := "fieldtest1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ synchronous := TRUE ]);

  RECORD searchres := RunConsilioSearch(catalog->tag, CQAll(), [ refresh := TRUE ]).results[0];
  TestAssert(CellExists(searchres, 'no')); //'no.such.field' exists because it's registered in the default mapping

  //Now undo the fieldgroup change...
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := STRING[]
                             , title := ""
                             , priority := 0
                             ]);
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");

  catalog->UpdateCatalog(CELL[ fieldgroups := STRING["webhare_testsuite:testindexfields"] ]);
  TestEqMembers(RECORD[], (SELECT * FROM catalog->GetExpectedMapping() WHERE name = "nosuchfieldyet_extra"), "*");

  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["superfluous"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra","nosuchfieldyet_extra2"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "superfluous"));

  testfw->CommitWork();

  searchres := RunConsilioSearch(catalog->tag, CQAll(), [ refresh := TRUE ]).results[0];
  TestAssert(NOT CellExists(searchres, 'no')); //'no.such.field' should not exist because it's no longer registered in the mapping

  TestEq("", OpenConsilioCatalog(catalog->tag)->title);
  TestEq("", catalog->title);
  TestEq(0, OpenConsilioCatalog(catalog->tag)->priority);

  //Commit doesn't change a thing - there's no way to get rid of existing mappings
  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["superfluous"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["no","no.such","no.such.field","no.such.field.yet","nosuchfieldyet_extra","nosuchfieldyet_extra2"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "superfluous"));

  //Now set a fieldgroup that ignores 'no' and 'no.such'
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := STRING["webhare_testsuite:testindexfields", "webhare_testsuite:ignore_nosuchfieldyet"] ]);
  testfw->CommitWork();

  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["superfluous"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["nosuchfieldyet_extra2"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "superfluous"));

  searchres := RunConsilioSearch(catalog->tag, CQAll(), [ refresh := TRUE ]).results[0];
  TestEq([ such := CELL[] ], searchres.no, "The mapping should end at 'such'");

  //Make sure that we won't crash create a mapping for the ignored fields. Recreate the index
  SendRawJSONToOpenSearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  TestEq(FALSE, catalog->WaitReady(DEFAULT DATETIME, [forstorage := TRUE ]), "With the index gone, we're no longer ready");
  catalog->ApplyConfiguration();
  TestEq(TRUE, catalog->WaitReady(DEFAULT DATETIME, [forstorage := TRUE ]), "ApplyConfiguration should have fixed it");

  //Test direct conflicts
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:conflicttest_blue" ] ]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:conflicttest_red" ] ]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  diff := VerifyOpensearchMapping(testindex.indexmanager, testindex.indexname, "", catalog->GetExpectedMapping());
  TestEq(["parammismatch", "superfluous","typemismatch"], GetSortedSet(SELECT AS STRING ARRAY issue FROM diff));
  TestEq(["c_keyword","c_text"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "typemismatch"));
  TestEq(["c_ignoreabove","c_indexoptions","c_nested"], GetSortedSet(SELECT AS STRING ARRAY field FROM diff WHERE issue = "parammismatch"));

  // Reset configuration for later tests
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:testindexfields" ] ]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));
}

MACRO TestESCreationAPIs()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  testindex := catalog->ListAttachedIndices()[0];

  testfw->BeginWork();
  TestThrowsLike("No such indexmanager*", PTR catalog->AttachIndex(9999999));
  TestThrowsLike("*managed*suffix*", PTR CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, suffixed := TRUE ]));

  //we'll be rolling back this externalindex, just testing the API.
  INTEGER mock_external_index := MakeAutonumber(consilio.indexmanagers, "id");
  INSERT CELL[ id := mock_external_index
             , address := builtin_opensearch.url
             , name := "mock_external_index"
             ] INTO consilio.indexmanagers;
  TestThrowsLike("*indexname*required*", PTR catalog->AttachIndex(mock_external_index));
  TestThrowsLike("*indexname*lowercase*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "_U" ]));
  TestThrowsLike("*Invalid*indexname*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "-u" ]));
  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname", readonly := TRUE ]);

  TestEq(TRUE, catalog->WaitReady(DEFAULT DATETIME, [ forstorage := TRUE ]), "Should appear ready, readonly indices not relevant");

  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname2", readonly := FALSE ]);
  TestEq(FALSE, catalog->WaitReady(DEFAULT DATETIME, [ forstorage := TRUE ]), "Can't be ready, not commited");

  testfw->RollbackWork();

  // Verify the readonly index was not created
  RECORD ARRAY indices := catalog->ListAttachedIndices();
  TestEq(TRUE, indices[1].readonly);

  TestEq(TRUE, RecordExists(SendRawJSONToOpenSearch(indices[0].indexmanager, "GET", `/${indices[0].indexname}`, DEFAULT RECORD).result));
  TestThrowsLike("*404*", PTR SendRawJSONToOpenSearch(indices[1].indexmanager, "GET", `/${indices[1].indexname}`, DEFAULT RECORD));

  // Explicitly delete from ES
  SendRawJSONToOpenSearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM indices WHERE indexid = catalog->id);
  TestEq(RECORD[], catalog->ListSuffixes());
  TestEq(FALSE, catalog->IsReadyForStorage(), "With the index gone, we're no longer ready");

  // Recreate it
  catalog->ApplyConfiguration();
  TestEq(TRUE, catalog->IsReadyForStorage(), "ApplyConfiguration should have fixed it");
  indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM indices WHERE indexid = catalog->id));
  TestEq(RECORD[[ suffix := "" ]], catalog->ListSuffixes());

  RECORD checkindex := SendRawJSONToOpenSearch(testindex.indexmanager, "GET", `/${testindex.indexname}/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname).mappings.properties.keyword.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex.indexname).mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  __did_opensearch_close_and_reopen := FALSE; //it seems we lack another way to observe an unneeded change happening
  catalog->ApplyConfiguration(); //calling twice should be okay, it's an Ensure not a "Create"
  TestEq(FALSE, __did_opensearch_close_and_reopen, "Apply should have been a no-op");

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM indices WHERE indexid = catalog->id);

  // Create a subindex
  testfw->BeginWork();
  catalog := CreateConsilioCatalog("consilio:testfw_testindex_suffixed", [ managed := FALSE, suffixed := TRUE]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  TestEq(RECORD[], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);
  testfw->BeginWork();
  catalog->AttachIndex(0);
  catalog->AttachIndex(0, [ readonly := TRUE ]);
  Print(catalog->GetStorageInfo() || "\n");
  TestEq(TRUE, catalog->WaitReady(DEFAULT DATETIME, [ forstorage := TRUE ]), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
  testindex_suffixed := catalog->ListAttachedIndices()[0];
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:testindexfields" ] ]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);
  TestEq(RECORD[[ suffix := "suffix" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  checkindex := SendRawJSONToOpenSearch(testindex_suffixed.indexmanager,  "GET", `/${testindex_suffixed.indexname}-suffix/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-suffix").mappings.properties.keyword.type);

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);  //calling twice should be okay, it's "Ensure" not "Create"

  // Delete it again from the index manager
  TestThrowsLike("*suffix*", PTR catalog->DeleteSuffix(""));
  catalog->DeleteSuffix("suffix");
  catalog->DeleteSuffix("suffix2");
  TestEq(RECORD[], catalog->ListSuffixes());

  // Create two subindices
  catalog->ApplyConfiguration([ suffixes := ["suffix1","suffix2"]]);
  TestEq(RECORD[[ suffix := "suffix1" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // Delete one of the subindices
  catalog->DeleteSuffix("suffix1");
  TestEq(RECORD[[ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // We should be able open to the catalog
  catalog := OpenConsilioCatalog("webhare_testsuite:module_reference");
  TestEq(TRUE, ObjectExists(catalog));

  testfw->BeginWork();
  catalog->AttachIndex(0);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE ]));

  indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM indices WHERE indexid = catalog->id));

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM indices WHERE indexid = catalog->id));
}

MACRO TestESBulkInsertion()
{
  //Setup the index we'll be testing against, give it an intial config
  testfw->BeginWork();
  OBJECT catalog := CreateConsilioCatalog("webhare_testsuite:tmpindex_suffixed2", [ fieldgroups := ["webhare_testsuite:testindexfields"], managed := FALSE, suffixed := TRUE ]);
  TestEq(RECORD[], catalog->ListAttachedIndices(), "A fresh suffixed unmanaged index should not be attached yet");
  catalog->AttachIndex(0);
  testfw->CommitWork();

  testindex_suffixed := catalog->ListAttachedIndices()[0];

  // Make sure it's indeed nonexistent
  TestEq(TRUE, catalog->IsReadyForStorage(), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
  Print(catalog->GetStorageInfo()||"\n");

  RECORD ARRAY indices := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM indices WHERE indexid = catalog->id));

  //Offering an undeclared cell must fail (this tests ES error handling, if we start catching errors earlier we might need something else or a raw mode to explicitly trigger ES error handling)
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ 'no.such.field.yet' := 42 ]
                    ]],[ suffix := "sub1"]));

  //But we should be able to manually offer it if we specify a mapping containing it
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:nosuchfieldyet" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // Test searching for nothing (some queries optimize to CQNothing - this shouldn't crash)
  RECORD res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQNothing(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEqMembers([ totalcount := 0, results := RECORD[]], res, "*");

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQAll(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQNot(CQNothing()),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // Test record mapping
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQAnd([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  //Empty CQOr should not return anything - this regressed and triggers a 'fail open' if a list of clauses is empty (eg publisher search with no access at all)
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQOr(RECORD[]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  //CQAnd with an empty CQOr should not return anything - this regressed and triggers a 'fail open' if a list of clauses is empty (eg publisher search with no access at all)
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQAnd([CQMatch("no.such.field.yet", "=", 42), CQOr(RECORD[])]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQOr([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // In OpenSearch, all fields can contain arrays
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
          [ no :=
              [ [ such :=
                  [ field :=
                      [ [ yet := 41 ]
                      , [ yet := 45 ]
                      ]
                  ]
                ]
              , [ such :=
                  [ field :=
                      [ yet := [ 42, 43, 44 ] ]
                  ]
                ]
              ]
          ]
        ]
      ], [ suffix := "sub1", synchronous := TRUE ]);

  // Test record array mapping
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq(
      [ no :=
          [ [ such :=
              [ field :=
                    // Single 'yet' values got converted to arrays as per requested mapping
                  [ [ yet := [ 41 ] ]
                  , [ yet := [ 45 ] ]
                  ]
              ]
            ]
          , [ such :=
                // Single 'field' value got converted to array as per requested mapping
              [ field :=
                  [ [ yet := [ 42, 43, 44 ] ] ]
              ]
            ]
          ]
      ], res.results[0]);

  // Add more objects
  catalog->AddObjects(
      [ [ _id := "test2"
        , objectid := "test2"
        , documentfields := [ nosuchfieldyet_extra := "Test2"
                            , no := [ such := [ field := [ yet := [ 2, 42, 55 ] ] ] ]
                            ]
        ]
      , [ objectid := "test3"
        , documentfields := [ nosuchfieldyet_extra := "Test3"
                            , no := [ such := [ field := [ yet := [ 100 ] ] ] ]
                            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  // Sort results by 'no.such.field.yet' ascending, checks for minimum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      ]);
  TestEq(
        // min(no.such.field.yet) = 2
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // min(no.such.field.yet) = 41
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // min(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending, checks for maximum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      , orderdesc := TRUE
      ]);
  TestEq(
        // max(no.such.field.yet) = 100
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 55
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 45
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending using the average 'yet' value
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // avg(no.such.field.yet) = 43
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // avg(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Test raw query ability
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQAnd( [ CQMatch("no.such.field.yet", "IN", [ 42, 100 ])
                                                                          , CQOpenSearch( [ match := [ nosuchfieldyet_extra := "Test3" ]])
                                                                          ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Do a raw search to check if there is a document with _id 'test2'
  RECORD result := SendRawJSONToOpenSearch(testindex_suffixed.indexmanager, "GET", `/${testindex_suffixed.indexname}*/_search`,
      [ query := [ match_all := CELL[] ], _source := FALSE ]);
  TestEq(3, Length(result.result.hits.hits));
  TestEq(TRUE, RecordExists(SELECT FROM result.result.hits.hits WHERE _id = "test2"));
  TestEq(FALSE, RecordExists(SELECT FROM result.result.hits.hits WHERE _id = "test3"));

  // Delete the object
  catalog->DeleteObjects([ "test1", "test2", "test3" ], [ suffix := "sub1", foreground := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount); // test2 isn't deleted as it doesn't have a generated _id

  catalog->DeleteObjects([ "test2" ], [ suffix := "sub1", foreground := TRUE, raw_ids := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount); // test2 isn't deleted as it doesn't have a generated _id


  //Test store-only fields
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:storeonly" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ indexed := "test", stored := "test" ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // 'indexed:test' can be found, the 'stored' field returned
  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("indexed", "=", "test"),
      [ mapping := [ indexed := "", stored := "" ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ indexed := "test", stored := "test" ], res.results[0]);

  // The 'stored' field cannot be searched on
  TestThrowsLike("*Cannot search*stored*not indexed*", PTR RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("stored", "=", "test")));

  //Can't offer xyz yet to our unspecified_record
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]));

  //But we should be able to set it through a wildcard if we add it
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:testindexfields"  ] ]);
  testfw->CommitWork();

  //WAS: Ensure dynamic templates work. NOW: ensure the field does not get added
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'group_record_field.ds_text' := 44 ]
        ]
      ],[ suffix := "sub1" ]);

  //Verify ds_Text's mapping
  RECORD checkindex := SendRawJSONToOpenSearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub1/_mapping`, DEFAULT RECORD);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties, "ds_text"));
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  //Check adding arrays
  catalog->AddObjects(
      [ [ objectid := "test2"
        , documentfields := [ group_record_field := [ ds_text := 45, db_conspiracy := TRUE ]
                            , group_int_field := 1045
                            , documents := [ [ title := "XY en Z", slug := "slug1" ]
                                           , [ title := "XY en B", slug := "slug2" ]
                                           ]
                            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);

  //Test some query field validation
  TestThrowsLike("No such*objectid*", PTR RunConsilioSearch(catalog->tag, CQMatch("objectid", "=", "test2")), "an unmanaged doesn't record objectid unless explicitly created as field");
  TestThrowsLike("*ds_text*not indexed*wildcard*", PTR RunConsilioSearch(catalog->tag, CQMatch("group_record_field.ds_text", "=", "test2")), "an unmanaged doesn't record objectid unless explicitly created as field");

  res := RunConsilioSearch(catalog->tag, CQMatch("group_int_field", '=', 1045));
  TestEq([ ds_text := "45", db_conspiracy := TRUE, group_record_text_field := "", when := default datetime, "where" := "" ], res.results[0].group_record_field, "Should not leak through ds_* fields");

  res := RunConsilioSearch(catalog->tag, CQMatch("group_int_field", '=', 1045), [ mapping := [ documents := RECORD[[ title := "", slug := "" ] ]]]);
  TestEq([ [ title := "XY en Z", slug := "slug1" ]
         , [ title := "XY en B", slug := "slug2" ]
         ], res.results[0].documents, "Properly retrieve objects stored as an array");

  // Throw some objects into a suffix. We want the index to sort it out
  RECORD ARRAY docs;
  //2*28*24 * 3 = 4032 events
  FOR(INTEGER month := 1; month <= 2; month := month + 1)
    FOR(INTEGER day := 1; day <= 28; day := day + 1)
      FOR(INTEGER hour := 0; hour <= 23; hour := hour + 1)
        FOR(INTEGER hit := 0; hit <= 2; hit := hit + 1)
      {
        DATETIME ts := MakeDatetime(2018,month,day,hour,0,0);
        STRING tstext := FormatISO8601Datetime(ts);
        INSERT CELL[ objectid := "obj_" || hit || "_" || tstext
                   , documentfields := [ "@timestamp" := ts
                                       , "title" := `My lovely doc for ${tstext} hit #${hit}`
                                       , int_field := (((month*100)+day)*100+hour)*100+hit
                                       ]
                   ] INTO docs AT END;

      }

  //Blast my docs into ES
  catalog->AddObjects(docs, [ suffix := "sub2"
                            , synchronous := TRUE
                            , chunksize := Length(docs)/2 + 2
                            ]);

  //Verify subindex was properly ensured
  checkindex := SendRawJSONToOpenSearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub2/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-sub2").mappings.properties.keyword.type);

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQMatch("int_field", "=", docs[END-1].documentfields.int_field));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);

  res := RunConsilioSearch("webhare_testsuite:tmpindex_suffixed2", CQParseUserQuery('"My lovely doc for 2018-02-28T23:00:00Z hit #2"'));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);

  // Test stats
  RECORD ARRAY testcatalogs := SELECT * FROM ListConsilioCatalogs() WHERE tag LIKE "webhare_testsuite:*" ORDER BY tag;
  testcatalogs := EnrichCatalogsWithStats(testcatalogs, GatherIndexManagersSizes());
  TestEqMembers([[ docs := -1, tag := "webhare_testsuite:emptycatalog" ] //we never had anything attach here
                ,[ docs := 0, tag := "webhare_testsuite:module_reference" ]  //this one was connected in an earlier test
                ,[ docs := 0, tag := "webhare_testsuite:testindex" ] //all were deleted
                ,[ docs := -1, tag := "webhare_testsuite:testindex_suffixed" ]
                ,[ tag := "webhare_testsuite:testsitecatalog" ]
                ,[ docs := 0, tag := "webhare_testsuite:tmpindex" ]
                ,[ docs := 4032+2, tag := "webhare_testsuite:tmpindex_suffixed2" ]
                ,[ tag := "webhare_testsuite:toolslog" ]
                ], testcatalogs, "*");
}

MACRO TestESLangFeatures()
{
  // Recreate the index
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:tmpindex");
  testindex := catalog->ListAttachedIndices()[0];
  SendRawJSONToOpenSearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  catalog->ApplyConfiguration();

  // As defined in the module definition
  TestEq("nl", catalog->lang);

  // Add a document with some Dutch and English words
  RECORD doc :=
      [ objectid := "objectid_1"
      , documentfields := [ title := "boekjes booking" ]
      ];
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // Find the document using Dutch stemming (both 'boekjes' and 'geboekt' will be stemmed down to 'boek')
  RECORD res := RunConsilioSearch(catalog->tag, CQParseUserQuery("geboekt"));
  TestEq(1, res.totalcount);
  // It cannot be found using English stemming, because the document is indexed using Dutch stemming
  res := RunConsilioSearch(catalog->tag, CQParseUserQuery("booked"));
  TestEq(0, res.totalcount);

  // Change the language
  writelogmarker("change the language");
  testfw->BeginWork();
  catalog->UpdateCatalog([ lang := "en" ]);
  TestEq("en", catalog->lang);
  testfw->CommitWork();

  // Reindex the document (an unmanaged index isn't rebuilt automatically)
  writelogmarker("wait for ready");
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE, forstorage := TRUE ]));
  writelogmarker("ready");
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // The document can no longer be found using Dutch stemming
  res := RunConsilioSearch(catalog->tag, CQParseUserQuery("geboekt"));
  TestEq(0, res.totalcount);
  // But it can be found using English stemming (both 'booking' and 'booked' are stemmed down to 'book')
  res := RunConsilioSearch(catalog->tag, CQParseUserQuery("booked"));
  TestEq(1, res.totalcount);

  // Reset the language
  testfw->BeginWork();
  catalog->UpdateCatalog([ lang := "nl" ]);
  testfw->CommitWork();
  TestEq(TRUE, catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE, forstorage := TRUE ]));

  // Verify multiple languages don't cause unneeded close/reopens
  __did_opensearch_close_and_reopen := FALSE;
  catalog->ApplyConfiguration();
  TestEq(FALSE,__did_opensearch_close_and_reopen);
}

MACRO TestESDeletion()
{
  // Delete the catalog itself - FIXME dont touch our main testing catalog, it will unlink it from the ES instance, annoying testers
  testfw->BeginWork();
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:tmpindex");
  catalog->DeleteSelf();
  testfw->CommitWork();

  // We cannot check if the index is deleted from the index manager, because that happens in a separate task, which we cannot wait upon

  //FIXME we should not leave the system in an inconsistent state (deleting and index that should exist due to module  definition ruels)  test with a scratch api?
}

MACRO TestObsoleteCatalog()
{
  testfw->BeginWork();
  IF(NOT ObjectExists(OpenConsilioCatalog("webhare_testsuite:obsoletecatalog")))
    CreateConsilioCatalog("webhare_testsuite:obsoletecatalog");
  testfw->CommitWork();

  TestEq(TRUE, ObjectExists(OpenConsilioCatalog("webhare_testsuite:obsoletecatalog")));
  FixConsilioIndices([ catalogmask := "webhare_testsuite:obsoletecatalog" ]);
  TestEq(FALSE, ObjectExists(OpenConsilioCatalog("webhare_testsuite:obsoletecatalog")));
}

RunTestframework(
    [ PTR TestAPI
    , PTR TestUpdateIndicesMetadata
    , PTR PrepareIndices
    , PTR TestInitialAttachment
    , PTR TestMappingUpdates
    , PTR TestESCreationAPIs
    , PTR TestESBulkInsertion
    , PTR TestESLangFeatures
    , PTR TestESDeletion
    , PTR TestObsoleteCatalog
    ]);
