<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::os.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::consilio/lib/internal/updateindices.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";

LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

STRING ARRAY testcatalogs := [ "webhare_testsuite:testindex"
                             , "webhare_testsuite:testindex_suffixed"
                             , "webhare_testsuite:module_reference"
                             ];
RECORD testindex, testindex_suffixed;
RECORD builtin_opensearch;

MACRO Prepare()
{
  TestEq(1, Length(SELECT FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin), "One OpenSearch must exist");
  builtin_opensearch := SELECT * FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin;

  //Verify the found opensearch url is correct
  TestEq(TRUE, testfw->browser->GotoWebPage(builtin_opensearch.url || "_cluster/health"));
  TestEq(TRUE, CellExists(DecodeJSONBlob(testfw->browser->content), "cluster_name"));

  testfw->BeginWork();

  //Force deletion and recreation... they'll be garbage collected...
  DELETE FROM consilio.catalogs WHERE name IN testcatalogs;
  testfw->CommitWork();

  FixConsilioIndices([ limitmodule := "webhare_testsuite" ]);

  //Verify and cleanup from any previously (aborted)? testrun
  testfw->BeginWork();
  FOREVERY(STRING usedcatalog FROM testcatalogs)
  {
    OBJECT cat := OpenConsilioCatalog(usedcatalog);
    TestEq(TRUE, ObjectExists(cat), `Catalog "${usedcatalog}" should exist`);
    FOREVERY(RECORD toremove FROM cat->ListAttachedIndices())
      cat->DetachIndex(toremove.id);

    TestEq(FALSE, cat->IsReadyForStorage(), "Can't be ready, no attached indices");

    INTEGER index1id := cat->AttachIndex(builtin_opensearch.id);
    IF(#usedcatalog = 0) //we'll use testindex for some further tests
    {
      testindex := cat->ListAttachedIndices()[0];
      TestEqLike("c_??*", testindex.indexname, "test for properly structured builtin indexname");

      TestEqMembers([[ id := index1id
                     , indexmanager := builtin_opensearch.id
                     , type := "opensearch"
                     , searchpriority := 100
                     , indexname := testindex.indexname
                     , readonly := FALSE
                     ]
                    ], cat->ListAttachedIndices(), "*");

      cat->AttachIndex(builtin_opensearch.id, [ readonly := TRUE ]);
    }
    ELSE IF(#usedcatalog = 1)
    {
      testindex_suffixed := cat->ListAttachedIndices()[0];
    }

    Print(cat->GetStorageInfo()||"\n");

    IF(cat->suffixed)
      TestEq(TRUE, cat->IsReadyForStorage(), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
    ELSE
      TestEq(FALSE, cat->IsReadyForStorage(), "An unsuffixed index is not ready until attached");
  }
  testfw->CommitWork();
}

MACRO TestESCreationAPIs()
{
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");

  TestEq(TRUE, catalog->IsReadyForStorage(), "Has to be ready, CommitWork after AttachIndex synchronously applies the configuration");

  testfw->BeginWork();
  TestThrowsLike("No such indexmanager*", PTR catalog->AttachIndex(9999999));
  TestThrowsLike("*managed*suffix*", PTR CreateConsilioCatalog("consilio:testfw_invalidindex", [ managed := TRUE, suffixed := TRUE ]));

  //we'll be rolling back this externalindex, just testing the API.
  INTEGER mock_external_index := MakeAutonumber(consilio.indexmanagers, "id");
  INSERT CELL[ id := mock_external_index
             , address := builtin_opensearch.url
             , type := whconstant_consilio_indexmanager_opensearch
             , name := "mock_external_index"
             ] INTO consilio.indexmanagers;
  TestThrowsLike("*indexname*required*", PTR catalog->AttachIndex(mock_external_index));
  TestThrowsLike("*indexname*lowercase*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "_U" ]));
  TestThrowsLike("*Invalid*indexname*", PTR catalog->AttachIndex(mock_external_index, [ indexname := testindex.indexname || "-u" ]));
  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname", readonly := TRUE ]);

  TestEq(TRUE, catalog->IsReadyForStorage(), "Should appear ready, readonly indices not relevant");

  catalog->AttachIndex(mock_external_index, [ indexname := "dummyname2", readonly := FALSE ]);
  TestEq(FALSE, catalog->IsReadyForStorage(), "Can't be ready, not commited");

  testfw->RollbackWork();

  // Verify the readonly index was not created
  RECORD ARRAY indices := catalog->ListAttachedIndices();
  TestEq(TRUE, indices[1].readonly);

  TestEq(TRUE, RecordExists(SendRawJSONToElasticsearch(indices[0].indexmanager, "GET", `/${indices[0].indexname}`, DEFAULT RECORD).result));
  TestThrowsLike("*404*", PTR SendRawJSONToElasticsearch(indices[1].indexmanager, "GET", `/${indices[1].indexname}`, DEFAULT RECORD));

  // Explicitly delete from ES
  SendRawJSONToElasticsearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM result.indices WHERE indexid = catalog->id);
  TestEq(RECORD[], catalog->ListSuffixes());
  TestEq(FALSE, catalog->IsReadyForStorage(), "With the index gone, we're no longer ready");

  // Recreate it
  catalog->ApplyConfiguration();
  TestEq(TRUE, catalog->IsReadyForStorage(), "ApplyConfiguration should have fixed it");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));
  TestEq(RECORD[[ suffix := "" ]], catalog->ListSuffixes());

  RECORD checkindex := SendRawJSONToElasticsearch(testindex.indexmanager, "GET", `/${testindex.indexname}/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex.indexname).mappings.properties.keyword.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex.indexname).mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  __did_opensearch_close_and_reopen := FALSE; //it seems we lack another way to observe an unneeded change happening
  catalog->ApplyConfiguration(); //calling twice should be okay, it's an Ensure not a "Create"
  TestEq(FALSE, __did_opensearch_close_and_reopen, "Apply should have been a no-op");

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestEq(RECORD[], SELECT * FROM result.indices WHERE indexid = catalog->id);

  // Create a subindex
  catalog := OpenConsilioCatalog("webhare_testsuite:testindex_suffixed");
  TestEq(RECORD[], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:testindexfields" ] ]);
  testfw->CommitWork();

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);
  TestEq(RECORD[[ suffix := "suffix" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager,  "GET", `/${testindex_suffixed.indexname}-suffix/_mapping`, DEFAULT RECORD);
  //dumpvalue(checkindex,'tree');
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-suffix").mappings.properties.keyword.type);

  catalog->ApplyConfiguration([ suffixes := ["suffix2","suffix"]]);  //calling twice should be okay, it's "Ensure" not "Create"

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  TestEq(RECORD[], catalog->ListSuffixes());

  // Create two subindices
  catalog->ApplyConfiguration([ suffixes := ["suffix1","suffix2"]]);
  TestEq(RECORD[[ suffix := "suffix1" ], [ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // Delete one of the subindices
  catalog->DeleteSuffix("suffix1");
  TestEq(RECORD[[ suffix := "suffix2" ]], SELECT * FROM catalog->ListSuffixes() ORDER BY suffix);

  // We should be able open to the catalog
  catalog := OpenConsilioCatalog("webhare_testsuite:module_reference");
  TestEq(TRUE, ObjectExists(catalog));

  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsValueSet(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Delete it again from the index manager
  catalog->DeleteSuffix("");
  result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  // Check if duplicate fieldnames through including field groups are properly detected
  testfw->BeginWork();
  catalog := OpenConsilioCatalog("webhare_testsuite:duplicate_fieldnames");
  TestEq(TRUE, ObjectExists(catalog));
  catalog->AttachIndex(0);
  TestThrowsLike("Duplicate property name 'textfield'", PTR catalog->ApplyConfiguration());

  // Check if circular fieldgroup references are properly detected
  catalog := OpenConsilioCatalog("webhare_testsuite:circular_index_direct");
  TestEq(TRUE, ObjectExists(catalog));
  catalog->AttachIndex(0);
  TestThrowsLike("Index is too deep!", PTR catalog->ApplyConfiguration());

  catalog := OpenConsilioCatalog("webhare_testsuite:circular_index_indirect");
  TestEq(TRUE, ObjectExists(catalog));
  catalog->AttachIndex(0);
  TestThrowsLike("Index is too deep!", PTR catalog->ApplyConfiguration());

  // Check if circular fieldgroup references are properly detected
  catalog := OpenConsilioCatalog("webhare_testsuite:circular_module_reference");
  TestEq(TRUE, ObjectExists(catalog));
  catalog->AttachIndex(0);
  TestThrowsLike("Index is too deep!", PTR catalog->ApplyConfiguration());

  testfw->RollbackWork();
}

MACRO TestESBulkInsertion()
{
  // Ensure index doesn't exist in ES ... we'll do a raw action
  SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "DELETE", `/${testindex_suffixed.indexname}*`, DEFAULT RECORD);

  // Make sure it's indeed nonexistent
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex_suffixed");
  TestEq(TRUE, ObjectExists(catalog));
  TestEq(TRUE, catalog->IsReadyForStorage(), "A suffixed index will create the indices on demand, so ready for storage as long as we're attached");
  Print(catalog->GetStorageInfo()||"\n");

  RECORD result := GetIndexManagerIndexList(testindex.indexmanager);
  TestAssert(IsDefaultValue(SELECT * FROM result.indices WHERE indexid = catalog->id));

  //Offering an undeclared cell must fail (this tests ES error handling, if we start catching errors earlier we might need something else or a raw mode to explicitly trigger ES error handling)
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ 'no.such.field.yet' := 42 ]
                    ]],[ suffix := "sub1"]));

  //But we should be able to manually offer it if we specify a mapping containing it
  testfw->BeginWork();
  catalog->UpdateCatalog(CELL[ fieldgroups := [ "webhare_testsuite:nosuchfieldyet" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ no := [ such := [ field := [ yet := 42 ] ] ] ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // Test searching for nothing (some queries optimize to CQNothing - this shouldn't crash)
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQNothing(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEqMembers([ totalcount := 0, results := RECORD[]], res, "*");

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAll(),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQNot(CQNothing()),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // Test record mapping
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAnd([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQOr([CQNothing(), CQMatch("no.such.field.yet", "=", 42)]),
      [ mapping := [ no := [ such := [ field := [ yet := 0 ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ no := [ such := [ field := [ yet := 42 ] ] ] ], res.results[0]);

  // In Elasticsearch, all fields can contain arrays
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
          [ no :=
              [ [ such :=
                  [ field :=
                      [ [ yet := 41 ]
                      , [ yet := 45 ]
                      ]
                  ]
                ]
              , [ such :=
                  [ field :=
                      [ yet := [ 42, 43, 44 ] ]
                  ]
                ]
              ]
          ]
        ]
      ], [ suffix := "sub1", synchronous := TRUE ]);

  // Test record array mapping
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq(
      [ no :=
          [ [ such :=
              [ field :=
                    // Single 'yet' values got converted to arrays as per requested mapping
                  [ [ yet := [ 41 ] ]
                  , [ yet := [ 45 ] ]
                  ]
              ]
            ]
          , [ such :=
                // Single 'field' value got converted to array as per requested mapping
              [ field :=
                  [ [ yet := [ 42, 43, 44 ] ] ]
              ]
            ]
          ]
      ], res.results[0]);

  // Add more objects
  catalog->AddObjects(
      [ [ objectid := "test2"
        , documentfields := [ nosuchfieldyet_extra := "Test2"
                            , no := [ such := [ field := [ yet := [ 2, 42, 55 ] ] ] ]
                            ]
        ]
      , [ objectid := "test3"
        , documentfields := [ nosuchfieldyet_extra := "Test3"
                            , no := [ such := [ field := [ yet := [ 100 ] ] ] ]
                            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  // Sort results by 'no.such.field.yet' ascending, checks for minimum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      ]);
  TestEq(
        // min(no.such.field.yet) = 2
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // min(no.such.field.yet) = 41
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // min(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending, checks for maximum 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , orderby := "no.such.field.yet"
      , orderdesc := TRUE
      ]);
  TestEq(
        // max(no.such.field.yet) = 100
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 55
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // max(no.such.field.yet) = 45
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
      ], res.results);
  // Sort results by 'no.such.field.yet' descending using the average 'yet' value
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "IN", [ 42, 100 ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 2, 42, 55 ] ] ] ] ] ]
        ]
        // avg(no.such.field.yet) = 43
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 41 ] ], [ yet := [ 45 ] ] ] ] ]
            , [ such := [ field := [ [ yet := [ 42, 43, 44 ] ] ] ] ]
            ]
        ]
        // avg(no.such.field.yet) = 100
      , [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Test raw query ability
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQAnd( [ CQMatch("no.such.field.yet", "IN", [ 42, 100 ])
                                                                          , CQOpenSearch( [ match := [ nosuchfieldyet_extra := "Test3" ]])
                                                                          ]),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      , ordering := [ [ orderby := "no.such.field.yet", ordermode := "avg" ] ]
      ]);
  TestEq(
        // avg(no.such.field.yet) = 33
      [ [ no :=
            [ [ such := [ field := [ [ yet := [ 100 ] ] ] ] ] ]
        ]
      ], res.results);

  // Delete the object
  catalog->DeleteObjects([ "test1", "test2", "test3" ], [ suffix := "sub1", synchronous := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("no.such.field.yet", "=", 42),
      [ mapping := [ no := [ [ such := [ field := [ [ yet := INTEGER[] ] ] ] ] ] ]
      , summaryfield := ""
      ]);
  TestEq(0, res.totalcount);

  //Test store-only fields
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:storeonly" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
                    [[ objectid := "test1"
                     , documentfields := [ indexed := "test", stored := "test" ]
                    ]],[ suffix := "sub1", synchronous := TRUE ]);

  // 'indexed:test' can be found, the 'stored' field returned
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("indexed", "=", "test"),
      [ mapping := [ indexed := "", stored := "" ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEq([ indexed := "test", stored := "test" ], res.results[0]);

  // The 'stored' field cannot be searched on
  TestThrowsLike("*Cannot search*stored*not indexed*", PTR RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("stored", "=", "test")));

  //Can't offer xyz yet to our unspecified_record
  TestThrowsLike("*(strict_dynamic_mapping_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]));

  //But we should be able to set it through a wildcard if we add it
  testfw->BeginWork();
  catalog->UpdateCatalog([ fieldgroups := [ "webhare_testsuite:testindexfields", "webhare_testsuite:unspecifiedwildcards" ] ]);
  testfw->CommitWork();

  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := 43 ]
        ]
      ],[ suffix := "sub1" ]);

  // Once dynamically initialized, the type is fixed
  TestThrowsLike("*(mapper_parsing_exception)", PTR catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := "XYZ" ]
        ]
      ],[ suffix := "sub1" ]));
  // The string "44" can be converted to an integer
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'unspecified_record.xyz' := "44" ]
        ]
      ],[ suffix := "sub1" ]);

  // Add a datetime property
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields :=
            [ unspecified_record :=
                [ "datetime" := AddTimeToDate(789, MakeDateTime(2000, 1, 2, 12, 34, 56))
                , "integer" := 1234
                , "integer64" := 1024i64 * 1024 * 1024 * 1024
                , "money" := 1234.56
                , "float" := .015625
                , "string" := "1234"
                ]
            ]
        ]
      ],[ suffix := "sub1", synchronous := TRUE ]);
  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQHas("unspecified_record.datetime"),
      [ mapping :=
          [ unspecified_record :=
              [ "datetime" := DEFAULT DATETIME
              , "integer" := 0
              , "integer64" := 0i64
              , "money" := 0m
              , "float" := 0f
              , "string" := ""
              ]
          ]
      , summaryfield := ""
      ]);
  TestEq(1, res.totalcount);
  TestEQ(
      [ unspecified_record :=
          [ "datetime" := AddTimeToDate(789, MakeDateTime(2000, 1, 2, 12, 34, 56))
          , "integer" := 1234
          , "integer64" := 1024i64 * 1024 * 1024 * 1024
          , "money" := 1234.56
          , "float" := .015625
          , "string" := "1234"
          ]
      ], res.results[0]);

  //Ensure dynamic templates work
  catalog->AddObjects(
      [ [ objectid := "test1"
        , documentfields := [ 'group_record_field.ds_text' := 44 ]
        ]
      ],[ suffix := "sub1" ]);

  //Verify ds_Text's mapping
  RECORD checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub1/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties.ds_text.type);
  TestEq(FALSE, CellExists(GetCell(checkindex.result, testindex_suffixed.indexname || "-sub1").mappings.properties.group_record_field.properties,"ds_*"), "DONT create the wildcards as a real field!");

  // Throw some objects into a suffix. We want the index to sort it out
  RECORD ARRAY docs;
  //2*28*24 * 3 = 4032 events
  FOR(INTEGER month := 1; month <= 2; month := month + 1)
    FOR(INTEGER day := 1; day <= 28; day := day + 1)
      FOR(INTEGER hour := 0; hour <= 23; hour := hour + 1)
        FOR(INTEGER hit := 0; hit <= 2; hit := hit + 1)
      {
        DATETIME ts := MakeDatetime(2018,month,day,hour,0,0);
        STRING tstext := FormatISO8601Datetime(ts);
        INSERT CELL[ objectid := "obj_" || hit || "_" || tstext
                   , documentfields := [ "@timestamp" := ts
                                       , "title" := `My lovely doc for ${tstext} hit #${hit}`
                                       , int_field := (((month*100)+day)*100+hour)*100+hit
                                       ]
                   ] INTO docs AT END;

      }

  //Blast my docs into ES
  catalog->AddObjects(docs, [ suffix := "sub2"
                            , synchronous := TRUE
                            , chunksize := Length(docs)/2 + 2
                            ]);

  //Verify subindex was properly ensured
  checkindex := SendRawJSONToElasticsearch(testindex_suffixed.indexmanager, "GET", `${testindex_suffixed.indexname}-sub2/_mapping`, DEFAULT RECORD);
  TestEq("keyword", GetCell(checkindex.result, testindex_suffixed.indexname || "-sub2").mappings.properties.keyword.type);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQMatch("int_field", "=", docs[END-1].documentfields.int_field));
  //dumpvalue(res,'tree');
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);

  res := RunConsilioSearch("webhare_testsuite:testindex_suffixed", CQParseUserQuery('"My lovely doc for 2018-02-28T23:00:00Z hit #2"'));
  TestEq(1, res.totalcount);
  TestEq(docs[END-1].documentfields.title, res.results[0].title);
}

MACRO TestESLangFeatures()
{
  // Recreate the index
  SendRawJSONToElasticsearch(testindex.indexmanager, "DELETE", `/${testindex.indexname}*`, DEFAULT RECORD);
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  catalog->ApplyConfiguration();

  // As defined in the module definition
  TestEq("nl", catalog->lang);

  // Add a document with some Dutch and English words
  RECORD doc :=
      [ objectid := "objectid_1"
      , documentfields := [ title := "boekjes booking" ]
      ];
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // Find the document using Dutch stemming (both 'boekjes' and 'geboekt' will be stemmed down to 'boek')
  RECORD res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(1, res.totalcount);
  // It cannot be found using English stemming, because the document is indexed using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(0, res.totalcount);

  // Change the language
  testfw->BeginWork();
  TestEq(TRUE, catalog->UpdateCatalog([ lang := "en" ]));
  TestEq("en", catalog->lang);
  TestThrowsLike("*must commit*", PTR catalog->AddObjects([ doc ], [ synchronous := TRUE ]));
  testfw->CommitWork();

  // Reindex the document (an unmanaged index isn't rebuilt automatically)
  catalog->AddObjects([ doc ], [ synchronous := TRUE ]);

  // The document can no longer be found using Dutch stemming
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("geboekt"));
  TestEq(0, res.totalcount);
  // But it can be found using English stemming (both 'booking' and 'booked' are stemmed down to 'book')
  res := RunConsilioSearch("webhare_testsuite:testindex", CQParseUserQuery("booked"));
  TestEq(1, res.totalcount);

  // Reset the language
  testfw->BeginWork();
  catalog->UpdateCatalog([ lang := "nl" ]);
  testfw->CommitWork();
}

MACRO TestESDeletion()
{
  // Delete the catalog itself - FIXME dont touch our main testing catalog, it will unlink it from the ES instance, annoying testers
  testfw->BeginWork();
  OBJECT catalog := OpenConsilioCatalog("webhare_testsuite:testindex");
  //catalog->DeleteSelf();
  testfw->CommitWork();

  // We cannot check if the index is deleted from the index manager, because that happens in a separate task, which we cannot wait upon

  //FIXME we should not leave the system in an inconsistent state (deleting and index that should exist due to module  definition ruels)  test with a scratch api?
}

RunTestframework(
    [ PTR Prepare
    , PTR TestESCreationAPIs
    , PTR TestESBulkInsertion
    , PTR TestESLangFeatures
    , PTR TestESDeletion
    ]);
