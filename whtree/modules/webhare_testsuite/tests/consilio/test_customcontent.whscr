<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::float.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/testfw/indexactions.whlib";
LOADLIB "mod::consilio/lib/internal/queuemgmt.whlib";

LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/internal/editorsupport.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::webhare_testsuite/lib/database.whlib";


OBJECT search_obj;
OBJECT contentsource;

RECORD ARRAY FUNCTION SearchAll(STRING searchquery, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ extrafields :=    DEFAULT RECORD
      , storequery :=     FALSE
      ], options);

  search_obj->empty_result_record :=
      [ groupid :=        ""
      , objectid :=       ""
      , date_indexdate := DEFAULT DATETIME
      , ...options.extrafields
      ];
  search_obj->save_searches := options.storequery;

  RECORD query := CQMatch("contentsource", "=", contentsource->id);
  IF (searchquery != "")
    query := CQAnd([ query, CQParseUserQuery(searchquery) ]);
    dumpvalue(query,'tree');
  RECORD res := search_obj->SearchQuery(query, 0, 1000);
  RETURN
      SELECT groupid
           , objectid
           , indexdate :=     date_indexdate
           , ...MakeReplacedRecord(options.extrafields, results)
        FROM res.results
    ORDER BY groupid, objectid;
}

// Wait for command completion, then require that index & db are fully synced
MACRO TestCompleteSyncAfterCommand()
{
  testfw->WaitQueueEmpty();
  TestEQ((SELECT groupid, objectid, indexdate FROM webhare_testsuite.consilio_index ORDER BY groupid, objectid), SearchAll(""));
}

MACRO TestCustomContent()
{
  OBJECT catalog := OpenConsilioCatalog(testfw->GetCatalogName_1());
  BOOLEAN is_opensearch := catalog->indexmanager.type = whconstant_consilio_indexmanager_opensearch;

  //having indexnames makes log analysis easier
  Print(`${catalog->tag} (${catalog->id}) => ${catalog->indexname}\n`);

  search_obj := OpenSearchObject("en", testfw->GetCatalogName_1());
  RECORD res;

  // Prefix for object/group ids, just to stress the itf
  STRING idprefix := "\n\r\t()[]{}^$+-%!\"";//" \n\r\t()[]{}^$+-%!\"";

  testfw->BeginWork();

  // Clear the current contents
  DELETE FROM webhare_testsuite.consilio_index;

  contentsource := catalog->AddCustomContentSource(testfw->GetCustomContentName(), "mod::webhare_testsuite/lib/consilio/dbindex.whlib#DBContent",
      [ title :=            "BETA_CUSTOMSOURCE"
      , maxgroupobjects :=  1000
      , discardsummaries := TRUE
      ]);

  TestThrowsLike(`*contentsource with tag '${testfw->GetCustomContentName()}' already exists*`, PTR catalog->AddCustomContentSource(testfw->GetCustomContentName(), "mod::webhare_testsuite/lib/consilio/dbindex.whlib#DBContent",
      [ title :=            "BETA_CUSTOMSOURCE"
      , maxgroupobjects :=  1000
      , discardsummaries := TRUE
      ]));

  testfw->CommitWork();

  // Clear the index
  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  TestEQ(0, LENGTH(SearchAll("")));

  testfw->BeginWork();
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, adate, text)
      VALUES(idprefix||"a", idprefix||"a1", MakeDate(1970, 1, 10), MakeDate(2010, 1, 1), "a a1");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, adate, text)
      VALUES(idprefix||"a", idprefix||"a2", MakeDate(1970, 1, 10), MakeDate(2011, 1, 1), "a a2");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"b", idprefix||"b1", MakeDate(1970, 1, 10), "b b1");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"c", idprefix||"c1", MakeDate(1970, 1, 10), "c c1");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"c", idprefix||"c2", MakeDate(1970, 1, 10), "c c2");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"c", idprefix||"c3", MakeDate(1970, 1, 10), "c c3");
  testfw->CommitWork();

  // Rebuild the index
  catalog->ReindexCatalog();

  TestCompleteSyncAfterCommand();

  // Test stored user queries
  TestEq(0, Length(SELECT FROM consilio.query_results WHERE catalogid = catalog->id));
  RECORD ARRAY results := SearchAll("a", [ storequery := TRUE ]);
  TestEQ((SELECT groupid, objectid, indexdate FROM webhare_testsuite.consilio_index WHERE groupid = idprefix||"a" ORDER BY groupid, objectid), results);
  RECORD ARRAY queries := SELECT * FROM consilio.query_results WHERE catalogid = catalog->id;
  TestEq(1, Length(queries));
  TestEq("a", queries[0].query);
  TestEq(2, queries[0].results);
  TestEq(TRUE, queries[0].sess != "");

  // Test content source id in custom content source object
  res := search_obj->Search("+indexed_by:"||contentsource->id, 0, 1000);
  TestEQ(6, res.totalcount);

  // Test date range search
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:["||DateTimeToString(MakeDate(2010,1,1))||",}", 0, 1000);
  TestEQ(2, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));

  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{"||DateTimeToString(MakeDate(2010,1,1))||",}", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(FALSE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));

  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(FALSE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));

  // Test date match queries
  // Date match queries aren't fully supported by Consilio, so they're rewritten as date range filters. As a result, you
  // cannot just search for a date, so the query must include a non-date query.
  res := search_obj->SearchQuery(CQAnd([ CQMatch("indexed_by", "=", contentsource->id), CQMatch("date_adate", ">=", MakeDate(2010,1,1)) ]), 0, 1000);
  TestEQ(2, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));

  res := search_obj->SearchQuery(CQAnd([ CQMatch("indexed_by", "=", contentsource->id), CQMatch("date_adate", ">", MakeDate(2010,1,1)) ]), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(FALSE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));

  res := search_obj->SearchQuery(CQAnd([ CQMatch("indexed_by", "=", contentsource->id), CQMatch("date_adate", "<=", MakeDate(2010,1,1)) ]), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(FALSE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a2"));


  // Test result fields
  search_obj->ResetEmptyResultRecord(); // By default all known fields are returned, in this case "initialfilter" and
                                        // "date_adate", supplemented with the default fields "groupid" and "objectid"
                                        // Also, if summary_length > 0 (which it is by default), a "_summary" is returned
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      , initialfilter := "obj://" || idprefix||"a" || "/" || idprefix||"a1"
      , date_adate := MakeDate(2010, 1, 1)
      , summary := is_opensearch ? "a a1" : "" // OpenSearch doesn't support discardsummaries
      , indexed_by := ToString(contentsource->id)
      , datafrom := "fetch"
      , mapping_boolean := FALSE
      , mapping_integer := 0
      , mapping_integer64 := 0i64
      , mapping_money := 0m
      , mapping_float := 0f
      , mapping_datetime := DEFAULT DATETIME
      , mapping_boolean_array := BOOLEAN[]
      , mapping_integer_array := INTEGER[]
      , mapping_integer64_array := INTEGER64[]
      , mapping_money_array := MONEY[]
      , mapping_float_array := FLOAT[]
      , mapping_datetime_array := DATETIME[]
      , fieldgroup_integer := 0
      , fieldgroup_integer64 := 0i64
      , fieldgroup_float := 0f
      , fieldgroup_boolean := FALSE
      , fieldgroup_datetime := DEFAULT DATETIME
      , myfield1 := ""
      ], res.results[0]);

  search_obj->summary_length := 0; // Don't return "summary"
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      , initialfilter := "obj://" || idprefix||"a" || "/" || idprefix||"a1"
      , date_adate := MakeDate(2010, 1, 1)
      , indexed_by := ToString(contentsource->id)
      , datafrom := "fetch"
      , mapping_boolean := FALSE
      , mapping_integer := 0
      , mapping_integer64 := 0i64
      , mapping_money := 0m
      , mapping_float := 0f
      , mapping_datetime := DEFAULT DATETIME
      , mapping_boolean_array := BOOLEAN[]
      , mapping_integer_array := INTEGER[]
      , mapping_integer64_array := INTEGER64[]
      , mapping_money_array := MONEY[]
      , mapping_float_array := FLOAT[]
      , mapping_datetime_array := DATETIME[]
      , fieldgroup_integer := 0
      , fieldgroup_integer64 := 0i64
      , fieldgroup_float := 0f
      , fieldgroup_boolean := FALSE
      , fieldgroup_datetime := DEFAULT DATETIME
      , myfield1 := ""
      ], res.results[0]);

  search_obj->empty_result_record :=
      DEFAULT RECORD; // By default "groupid" and "objectid" are returned
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      ], res.results[0]);

  search_obj->empty_result_record :=
      [ _score := 0f // Generated field "_score"
      ];
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      ], CELL[ ...res.results[0], DELETE _score ]);
  TestEq(TRUE, res.results[0]._score > 0);

  search_obj->empty_result_record :=
      [ score := 0f // If "score" is requested and "_score" is not, the "_score" field is returned as "score"
      ];
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      ], CELL[ ...res.results[0], DELETE score ]);
  TestEq(TRUE, res.results[0].score > 0);

  search_obj->empty_result_record :=
      [ date_adate := DEFAULT DATETIME // Return custom field "date_adate"
      ];
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      , date_adate := MakeDate(2010, 1, 1)
      ], res.results[0]);

  search_obj->empty_result_record :=
      [ nonexisting := "doesn't exist" // Undefined field is filled with default value in Consilio
      ];
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:{,"||DateTimeToString(MakeDate(2010,1,1))||"]", 0, 1000);
  TestEq(
      [ groupid := idprefix||"a"
      , objectid := idprefix||"a1"
      , nonexisting := is_opensearch ? "doesn't exist" : ""
      ], res.results[0]);

  //Find nothing
  res := RunConsilioSearch(testfw->GetCatalogName_1(), DEFAULT RECORD);
  TestEq(0,Length(res.results));

  res := RunConsilioSearch(testfw->GetCatalogName_1(), CQAll());
  TestEq(6,Length(res.results));

  res := RunConsilioSearch(testfw->GetCatalogName_1(), CQParseUserQuery(""));
  TestEq(0,Length(res.results));

  // Rebuild testing update object, delete object, delete group, keep group, add group/object
  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
   WHERE objectid = idprefix||"a1";
  DELETE FROM webhare_testsuite.consilio_index WHERE objectid = idprefix||"a2";
  DELETE FROM webhare_testsuite.consilio_index WHERE groupid = idprefix||"b";
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate)
      VALUES(idprefix||"d", idprefix||"d1", MakeDate(1970, 1, 10));
  testfw->CommitWork();

  catalog->ReindexCatalog();

  TestCompleteSyncAfterCommand();

  // check a single group
  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 10)
   WHERE objectid = idprefix||"a1";
  testfw->CommitWork();

  contentsource->ReindexGroup(idprefix||"a", [ rebuild := TRUE ]);

  TestCompleteSyncAfterCommand();

  // check a single object
  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
   WHERE objectid = idprefix||"a1";
  testfw->CommitWork();

  contentsource->ReindexObject(idprefix||"a", idprefix||"a1");

  TestCompleteSyncAfterCommand();

  // delete a single group & object, check new object & group
  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index
   WHERE objectid = idprefix||"a1";
  DELETE FROM webhare_testsuite.consilio_index
   WHERE objectid = idprefix||"d1";
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate)
      VALUES(idprefix||"e", idprefix||"e1", MakeDate(1970, 1, 10));
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate)
      VALUES(idprefix||"f", idprefix||"f1", MakeDate(1970, 1, 10));
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, spiderfrom)
      VALUES(idprefix||"f", idprefix||"f2", MakeDate(1970, 1, 10), (SELECT AS INTEGER id FROM webhare_testsuite.consilio_index WHERE objectid = idprefix||"f1"));
  testfw->CommitWork();

  contentsource->DeleteGroup(idprefix||"a");
  contentsource->DeleteObject(idprefix||"d1");
  contentsource->ReindexGroup(idprefix||"e");
  contentsource->ReindexObject(idprefix||"f", idprefix||"f1"); // Must spider to f2

  TestCompleteSyncAfterCommand();

  // Updates
  testfw->BeginWork();
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate)
      VALUES(idprefix||"a", idprefix||"a1", MakeDate(1970, 1, 10));
  UPDATE webhare_testsuite.consilio_index
     SET indexdate :=                   MakeDate(1970, 1, 11)
       , objectrequiredindexdate :=     MakeDate(1970, 1, 10)
       , grouprequiredindexdate :=      MakeDate(1970, 1, 12)
   WHERE objectid = idprefix||"c1";
  UPDATE webhare_testsuite.consilio_index
     SET indexdate :=                   MakeDate(1970, 1, 11)
       , objectrequiredindexdate :=     MakeDate(1970, 1, 12)
       , grouprequiredindexdate :=      MakeDate(1970, 1, 10)
   WHERE objectid = idprefix||"c2";
  UPDATE webhare_testsuite.consilio_index
     SET indexdate :=                   MakeDate(1970, 1, 11)
       , objectrequiredindexdate :=     MakeDate(1970, 1, 12)
       , grouprequiredindexdate :=      MakeDate(1970, 1, 12)
   WHERE objectid = idprefix||"c3";
  DELETE FROM webhare_testsuite.consilio_index
   WHERE objectid = idprefix||"e1";

  testfw->CommitWork();

  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();
  TestEQ(
      [ [ groupid := idprefix||"a",   objectid := idprefix||"a1",     indexdate := MakeDate(1970, 1, 10) ]
      , [ groupid := idprefix||"c",   objectid := idprefix||"c1",     indexdate := MakeDate(1970, 1, 10) ]
      , [ groupid := idprefix||"c",   objectid := idprefix||"c2",     indexdate := MakeDate(1970, 1, 10) ]
      , [ groupid := idprefix||"c",   objectid := idprefix||"c3",     indexdate := MakeDate(1970, 1, 11) ]
      , [ groupid := idprefix||"f",   objectid := idprefix||"f1",     indexdate := MakeDate(1970, 1, 10) ]
      , [ groupid := idprefix||"f",   objectid := idprefix||"f2",     indexdate := MakeDate(1970, 1, 10) ]
      ], SearchAll(""));

  // Prepare for data in list tests
  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index;

  {
    INTEGER b1_id := MakeAutonumber(webhare_testsuite.consilio_index, "id");
    FOREVERY (RECORD rec FROM
        [ [ groupid := idprefix||"a",   objectid := idprefix||"a1_withdata",          indexdate := MakeDate(1970, 1, 10) ]
        , [ groupid := idprefix||"b",   objectid := idprefix||"b1_withdata",          indexdate := MakeDate(1970, 1, 11), id := b1_id ]
        , [ groupid := idprefix||"b",   objectid := idprefix||"b2_withdata",          indexdate := MakeDate(1970, 1, 12), spiderfrom := b1_id ]
        , [ groupid := idprefix||"b",   objectid := idprefix||"b3",                   indexdate := MakeDate(1970, 1, 13), spiderfrom := b1_id ]
        , [ groupid := idprefix||"c",   objectid := idprefix||"c1",                   indexdate := MakeDate(1970, 1, 14) ]
        , [ groupid := idprefix||"d",   objectid := idprefix||"d1_withdata_fromlist", indexdate := MakeDate(1970, 1, 15) ]
        ])
    {
      INSERT rec INTO webhare_testsuite.consilio_index;
    }
  }
  testfw->CommitWork();

  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  TestEQ(
      [ [ groupid := idprefix||"a",   objectid := idprefix||"a1_withdata",          indexdate := MakeDate(1970, 1, 10), datafrom := "list" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b1_withdata",          indexdate := MakeDate(1970, 1, 11), datafrom := "list" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b2_withdata",          indexdate := MakeDate(1970, 1, 12), datafrom := "fetch-list" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b3",                   indexdate := MakeDate(1970, 1, 13), datafrom := "fetch" ]
      , [ groupid := idprefix||"c",   objectid := idprefix||"c1",                   indexdate := MakeDate(1970, 1, 14), datafrom := "fetch" ]
      , [ groupid := idprefix||"d",   objectid := idprefix||"d1_withdata_fromlist", indexdate := MakeDate(1970, 1, 15), datafrom := "list" ]
      ], SearchAll("", [ extrafields := [ datafrom := "" ] ]));

  contentsource->ReindexObject(idprefix||"a", idprefix||"a1_withdata");
  contentsource->ReindexObject(idprefix||"b", idprefix||"b2_withdata");
  contentsource->ReindexObject(idprefix||"d", idprefix||"d1_withdata_fromlist");
  testfw->WaitQueueEmpty();

  TestEQ(
      [ [ groupid := idprefix||"a",   objectid := idprefix||"a1_withdata",          indexdate := MakeDate(1970, 1, 10), datafrom := "fetch" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b1_withdata",          indexdate := MakeDate(1970, 1, 11), datafrom := "list" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b2_withdata",          indexdate := MakeDate(1970, 1, 12), datafrom := "fetch" ]
      , [ groupid := idprefix||"b",   objectid := idprefix||"b3",                   indexdate := MakeDate(1970, 1, 13), datafrom := "fetch" ]
      , [ groupid := idprefix||"c",   objectid := idprefix||"c1",                   indexdate := MakeDate(1970, 1, 14), datafrom := "fetch" ]
      , [ groupid := idprefix||"d",   objectid := idprefix||"d1_withdata_fromlist", indexdate := MakeDate(1970, 1, 15), datafrom := "fetchfromlist-list" ]
      ], SearchAll("", [ extrafields := [ datafrom := "" ] ]));

  // Clear for error tests
  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index;
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"b", idprefix||"b1", MakeDate(1970, 1, 10), "");
  testfw->CommitWork();

  catalog->ReindexCatalog();
  TestCompleteSyncAfterCommand();

  // Throw in fetchobject; old content must remain & error must be reported
  DATETIME starttest := GetCurrentDatetime();

  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
       , text:=       "THROW";
  testfw->CommitWork();

  __ConsilioClearErrors(contentsource->id);
  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  RECORD ARRAY relevanterrors;
  relevanterrors := SELECT * FROM GetLastNoticeErrors() WHERE channel='ERROR' AND when >= starttest;
  relevanterrors := SELECT * FROM relevanterrors WHERE CellExists(data,'info') AND data.info.context='consilio:fetcher' AND data.info.contentsourceid = VAR contentsource->id;
  TestEq(1,Length(relevanterrors), "Cannot find my error - may also imply a backwards-incompatible notice.log error format change!");
  TestEq("Exception: THROWN", relevanterrors[0].data.errors[0].message);
  TestEQ(
      [ [ groupid := idprefix||"b",   objectid := idprefix||"b1",     indexdate := MakeDate(1970, 1, 10) ]
      ], SearchAll(""));

  // Abort in fetchobject; old content must remain & error must be reported
  starttest := GetCurrentDatetime();
  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
       , text:=       "ABORT";
  testfw->CommitWork();

  __ConsilioClearErrors(contentsource->id);
  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  relevanterrors := SELECT * FROM GetLastNoticeErrors() WHERE channel='ERROR' AND when >= starttest;
  relevanterrors := SELECT * FROM relevanterrors WHERE CellExists(data,'info') AND data.info.context='consilio:fetcher' AND data.info.contentsourceid = VAR contentsource->id;
  TestEq(1,Length(relevanterrors));
  TestEq("Custom error message: 'ABORT'.", relevanterrors[0].data.errors[0].message);
  TestEQ(
      [ [ groupid := idprefix||"b",   objectid := idprefix||"b1",     indexdate := MakeDate(1970, 1, 10) ]
      ], SearchAll(""));

  // Abort in fetchobject; old content must remain & error must be reported
  starttest := GetCurrentDatetime();
  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
       , text:=       "CRASH";
  testfw->CommitWork();

  __ConsilioClearErrors(contentsource->id);
  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  TestEQ(TRUE, (SELECT AS STRING what FROM __ConsilioGetErrors().errors WHERE COLUMN contentsourceid = VAR contentsource->id) LIKE "*process exited with exit code 1*");
  TestEQ(
      [ [ groupid := idprefix||"b",   objectid := idprefix||"b1",     indexdate := MakeDate(1970, 1, 10) ]
      ], SearchAll(""));

  testfw->BeginWork();
  UPDATE webhare_testsuite.consilio_index
     SET indexdate := MakeDate(1970, 1, 11)
       , text:=       "";
  testfw->CommitWork();

  __ConsilioClearErrors(contentsource->id);
  contentsource->ReindexGroup(idprefix||"b", [ foreground := TRUE ]);

  TestEQ(
      [ [ groupid := idprefix||"b",   objectid := idprefix||"b1",     indexdate := MakeDate(1970, 1, 11) ]
      ], SearchAll(""));


  // Prepare for field existence query tests
  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index;
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, adate)
      VALUES(idprefix||"a", idprefix||"a1", MakeDate(1970, 1, 10), MakeDate(2010, 1, 1));
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, adate, text)
      VALUES(idprefix||"b", idprefix||"b1", MakeDate(1970, 1, 10), MakeDate(2010, 2, 2), "b b1");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, text)
      VALUES(idprefix||"c", idprefix||"c1", MakeDate(1970, 1, 10), "c c1");
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate)
      VALUES(idprefix||"d", idprefix||"d1", MakeDate(1970, 1, 10));
  testfw->CommitWork();

  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  TestEQ(
      [ [ groupid := idprefix||"a", objectid := idprefix||"a1", indexdate := MakeDate(1970, 1, 10), date_adate := MakeDate(2010, 1, 1) ]
      , [ groupid := idprefix||"b", objectid := idprefix||"b1", indexdate := MakeDate(1970, 1, 10), date_adate := MakeDate(2010, 2, 2) ]
      , [ groupid := idprefix||"c", objectid := idprefix||"c1", indexdate := MakeDate(1970, 1, 10), date_adate := DEFAULT DATETIME ]
      , [ groupid := idprefix||"d", objectid := idprefix||"d1", indexdate := MakeDate(1970, 1, 10), date_adate := DEFAULT DATETIME ]
      ], SearchAll("", [ extrafields := [ date_adate := DEFAULT DATETIME ] ]));

  // Test exists queries
  res := search_obj->Search("+contentsource:"||contentsource->id||" +date_adate:*", 0, 1000);
  TestEQ(2, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));

  res := search_obj->Search("+contentsource:"||contentsource->id||" +body:*", 0, 1000);
  TestEQ(2, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"c1"));

  // Because there is no dedicated exists query in Consilio, these are being rewritten to range filters, which are always
  // applied after searching, so "+(body:* date_adate:*)" is effectively interpreted as "+body:* +date_adate:*"
  IF (is_opensearch)
  {
    res := search_obj->Search("+contentsource:"||contentsource->id||" +(body:* date_adate:*)", 0, 1000);
    TestEQ(3, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"c1"));
  }
  ELSE
  {
    res := search_obj->Search("+contentsource:"||contentsource->id||" +(body:* date_adate:*)", 0, 1000);
    TestEQ(1, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));
  }

  res := search_obj->Search("+contentsource:"||contentsource->id||" +body:* +date_adate:*", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));

  // Because there is no dedicated exists query in Consilio, these are being rewritten to range filters, which cannot be
  // negated and are always applied after searching, so "-body:*" is effectively interpreted as "+body:*"
  IF (is_opensearch)
  {
    res := search_obj->Search("+contentsource:"||contentsource->id||" -body:*", 0, 1000);
    TestEQ(2, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"d1"));
  }
  ELSE
  {
    res := search_obj->Search("+contentsource:"||contentsource->id||" -body:*", 0, 1000);
    TestEQ(2, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"c1"));
  }

  res := RunConsilioSearch(testfw->GetCatalogName_1(), CQAnd([ CQMatch("contentsource", "=", contentsource->id), CQHas("date_adate") ]));
  TestEQ(2, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"b1"));

  // Prepare for non-ASCII query tests
  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index;
  INSERT INTO webhare_testsuite.consilio_index(groupid, objectid, indexdate, adate, text)
      VALUES(idprefix||"a", idprefix||"a1", MakeDate(1970, 1, 10), MakeDate(2010, 1, 1), "å1 🍻");
  testfw->CommitWork();

  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();

  res := search_obj->Search("+body:a1", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->Search("+body:å1", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->Search("+body:\"å1\"", 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->SearchQuery(CQMatch("body", "CONTAINS", "a1"), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->SearchQuery(CQMatch("body", "CONTAINS", "å1"), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->SearchQuery(CQMatch("body", "=", "a1"), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  res := search_obj->SearchQuery(CQMatch("body", "=", "å1"), 0, 1000);
  TestEQ(1, res.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

  // OpenSearch searches for the term 'å1"\r\n€', which isn't indexed, Consilio tokenizes the term and will find the 'å1' result
  res := search_obj->SearchQuery(CQMatch("body", "=", "å1\"\r\n€"), 0, 1000);
  IF (is_opensearch)
  {
    TestEQ(0, res.totalcount);

    // Consilio doesn't support emoji parsing
    res := search_obj->SearchQuery(CQMatch("body", "=", "🍻"), 0, 1000);
    TestEQ(1, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

    res := search_obj->SearchQuery(CQMatch("body", "CONTAINS", "🍻"), 0, 1000);
    TestEQ(1, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

    res := search_obj->SearchQuery(CQParseUserQuery("🍻"), 0, 1000);
    TestEQ(1, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));

    res := search_obj->SearchQuery(CQMatch("body", "=", "🍺"), 0, 1000);
    TestEQ(0, res.totalcount);
  }
  ELSE
  {
    TestEQ(1, res.totalcount);
    TestEq(TRUE, RecordExists(SELECT FROM res.results WHERE objectid = idprefix||"a1"));
  }

  testfw->BeginWork();
  DELETE FROM webhare_testsuite.consilio_index;
  testfw->CommitWork();

  catalog->ReindexCatalog();
  testfw->WaitQueueEmpty();
}

MACRO TestTypes()
{
  OBJECT catalog := OpenConsilioCatalog(testfw->GetCatalogName_1());
  OBJECT maincatalog := OpenConsilioCatalog("webhare_testsuite:testsitecatalog");
  OBJECT maincontentsource := maincatalog->OpenContentSource("webhare_testsuite:dbindex");
  BOOLEAN is_opensearch := catalog->indexmanager.type = whconstant_consilio_indexmanager_opensearch;

  //having indexnames makes log analysis easier
  Print(`${catalog->tag} (${catalog->id}) => ${catalog->indexname}, ${maincatalog->tag} (${maincatalog->id}) => ${maincatalog->indexname}\n`);

  // Prefix for object/group ids, just to stress the itf
  STRING idprefix := "\n\r\t()[]{}^$+-%!\"";//" \n\r\t()[]{}^$+-%!\"";

  testfw->BeginWork();

  // Clear the current contents
  DELETE FROM webhare_testsuite.consilio_index;

  // Add some test data
  DATETIME now := GetCurrentDateTime();
  INSERT
      [ groupid := idprefix || "a"
      , objectid := idprefix || "a1"
      , extradata := EncodeHSON(
          [ mapping_integer := 2147483647
          , mapping_integer64 := 9223372036854775807i64//TODO: Any number outside the 32-bit INTEGER range is decoded as a FLOAT
          , mapping_money := 90071992547.40991m // A scaled float is returned as a double with 53-bit precision (and decoded as a FLOAT anyway)
          , mapping_float := 9223372036854775808
          , mapping_boolean := TRUE
          , mapping_datetime := MakeDateTime(2000, 1, 1, 12, 34, 56, 789)
          , mapping_integer_array := INTEGER[ 0, 1, 1, 2, 3, 5, 8 ]
          , mapping_integer64_array := INTEGER64[ 9876543210i64, 7521 ]
          , mapping_money_array := [ 3.14, 5, 90071992547.40990m, 45035996273.70496m ]
          , mapping_float_array := [ pi, 5 ]
          , mapping_boolean_array := [ FALSE, TRUE, FALSE ]
          , mapping_datetime_array := [ MakeDateTime(2000, 1, 1, 12, 34, 56, 789), DEFAULT DATETIME, now ]
          , fieldgroup_integer := 1234
          , fieldgroup_integer64 := 2147483648i64
          , fieldgroup_float := 2.20371f
          , fieldgroup_boolean := TRUE
          , fieldgroup_datetime := MakeDate(2038, 1, 19)
          ])
      ] INTO webhare_testsuite.consilio_index;

  testfw->CommitWork();

  catalog->ReindexCatalog();
  maincatalog->ReindexCatalog();
  testfw->WaitQueueEmpty();
  WaitForCatalogDone(maincatalog);

  RECORD res := RunConsilioSearch(catalog->tag, CQMatch("objectid", "=", idprefix || "a1"));
  TestEq(
      [ groupid := idprefix || "a"
      , objectid := idprefix || "a1"
      , initialfilter := "obj://" || idprefix || "a" || "/" || idprefix || "a1"
      , date_adate := DEFAULT DATETIME
      , summary := ""
      , indexed_by := ToString(contentsource->id)
      , datafrom := "fetch"
      , mapping_integer := 2147483647
      , mapping_integer64 := 9223372036854775807i64
      , mapping_money := 90071992547.40991m
      , mapping_float := 9223372036854775808
      , mapping_boolean := TRUE
      , mapping_datetime := MakeDateTime(2000, 1, 1, 12, 34, 56, 789)
      , mapping_boolean_array := [ FALSE, TRUE, FALSE ]
      , mapping_integer_array := INTEGER[ 0, 1, 1, 2, 3, 5, 8 ]
      , mapping_integer64_array := INTEGER64[ 9876543210i64, 7521 ]
      , mapping_money_array := MONEY[ 3.14, 5m, 90071992547.40990m, 45035996273.70496m ]//TODO: 45035996273.70496 gets rounded to 45035996273.70497 by EnforceStructure
      , mapping_float_array := FLOAT[ pi, 5f ]
      , mapping_datetime_array := [ MakeDateTime(2000, 1, 1, 12, 34, 56, 789), DEFAULT DATETIME, now ]
      , fieldgroup_integer := 1234
      , fieldgroup_integer64 := 2147483648i64
      , fieldgroup_float := 2.20371f
      , fieldgroup_boolean := TRUE
      , fieldgroup_datetime := MakeDate(2038, 1, 19)
      , myfield1 := ""
      ], res.results[0]);

  res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64", "=", 9223372036854775807i64));
  TestEq(1, res.totalcount);
  res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64_array", "CONTAINS", 7521));
  TestEq(1, res.totalcount);
  IF (is_opensearch)
  {
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64", "<=", 9223372036854775807i64));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64", ">=", 9223372036854775807i64));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64", "<", 9223372036854775807i64));
    TestEq(0, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_integer64", ">", 9223372036854775806i64));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money", "=", 90071992547.40991m));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money_array", "CONTAINS", 3.14m));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money", "<=", 90071992547.40991m));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money", ">=", 90071992547.40991m));
    TestEq(1, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money", "<", 90071992547.40991m));
    TestEq(0, res.totalcount);
    res := RunConsilioSearch(catalog->tag, CQMatch("mapping_money", ">", 90071992547.40990m));
    TestEq(1, res.totalcount);
  }
  ELSE
  {
    // Consilio doesn't support numeric range queries
    TestThrowsLike("Invalid match type '<=' for INTEGER match query", PTR CQMatch("mapping_integer", "<=", 1, [ __opensearch := FALSE ]));
    TestThrowsLike("Invalid match type '>=' for INTEGER64 match query", PTR CQMatch("mapping_integer64", ">=", 1i64, [ __opensearch := FALSE ]));
    TestThrowsLike("Invalid value type 'MONEY' for match query", PTR CQMatch("mapping_money", "<", 1m, [ __opensearch := FALSE ]));
    TestThrowsLike("Invalid value type 'FLOAT' for match query", PTR CQMatch("mapping_float", ">", 1f, [ __opensearch := FALSE ]));
  }

  res := RunConsilioSearch(maincatalog->tag, CQMatch("objectid", "=", idprefix || "a1"));
  TestEq(
      [ groupid := idprefix || "a"
      , objectid := idprefix || "a1"
      , initialfilter := "obj://" || idprefix || "a" || "/" || idprefix || "a1"
      , date_adate := DEFAULT DATETIME
      , summary := ""
      , indexed_by := ToString(maincontentsource->id)
      , datafrom := "fetch"
      , mapping_integer := 2147483647
      , mapping_integer64 := 9223372036854775807i64
      , mapping_money := 90071992547.40991m
      , mapping_float := 9223372036854775808
      , mapping_boolean := TRUE
      , mapping_datetime := MakeDateTime(2000, 1, 1, 12, 34, 56, 789)
      , mapping_boolean_array := [ FALSE, TRUE, FALSE ]
      , mapping_integer_array := INTEGER[ 0, 1, 1, 2, 3, 5, 8 ]
      , mapping_integer64_array := INTEGER64[ 9876543210i64, 7521 ]
      , mapping_money_array := MONEY[ 3.14, 5m, 90071992547.40990m, 45035996273.70496m ]//TODO: 45035996273.70496 gets rounded to 45035996273.70497 by EnforceStructure
      , mapping_float_array := FLOAT[ pi, 5f ]
      , mapping_datetime_array := [ MakeDateTime(2000, 1, 1, 12, 34, 56, 789), DEFAULT DATETIME, now ]
      , fieldgroup_integer := 1234
      , fieldgroup_integer64 := 2147483648i64
      , fieldgroup_float := 2.20371f
      , fieldgroup_boolean := TRUE
      , fieldgroup_datetime := MakeDate(2038, 1, 19)
      , myfield1 := ""

      , date_modified := DEFAULT DATETIME
      , date_whmodification := DEFAULT DATETIME
      , date_test := DEFAULT DATETIME
      , description := ""
      , filetype := ""
      , keywords := ""
      , size := 0
      , testdate := ""
      , title := ""
      , url := ""
      , validuser := ""
      , whfspath := ""
      , _suggested := DEFAULT RECORD
      ], res.results[0]);
}

RunTestframework(
    [ PTR TestCustomContent
    , PTR TestTypes
    ],
    [ consilio := TRUE
    , testusers :=
        [ [ login := "sysop", grantrights := [ "system:sysop" ] ]
        ]
    ]);
