<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/richdocument.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/internal/whfscatalog/indexfields.whlib";

LOADLIB "mod::publisher/lib/dialogs.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/search/richdocuments.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/updateindices.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/api.whlib";

LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/whfs/events.whlib";
LOADLIB "mod::system/lib/database.whlib";

LOADLIB "mod::tollium/lib/testframework.whlib";

LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";

OBJECT testroot;
INTEGER testsiteid;
OBJECT file_1, file_3, file_2, file_4, file_5, file_7;
OBJECT beforerepositoryfolder, privatetestfile1;
OBJECT subfolder;

MACRO CommitAndWaitForPublisherIndex()
{
  OBJECT promise := GetWHFSCommitHandler()->WaitForChangesIndexed();
  testfw->CommitWork();
  Print("waiting for changes indexed...\n");
  WaitForPromise(promise);
  Print("it's indexed\n");
}

MACRO TestIndexFields()
{
  RECORD ARRAY inputmapping := GetIndexFields().mapping;

  RECORD inputmapping_webharetestsuite := SELECT * FROM inputmapping WHERE name = "mod_webhare_testsuite";
  TestEq(TRUE, RecordExists(inputmapping_webharetestsuite));

  RECORD inputmapping_webharetestsuite_arrayfield := SELECT * FROM inputmapping_webharetestsuite.properties WHERE name = "arrayfield";
  TestEq(TRUE, RecordExists(inputmapping_webharetestsuite_arrayfield));

  RECORD inputmapping_webharetestsuite_arrayfield_libraryfield := SELECT * FROM inputmapping_webharetestsuite_arrayfield.properties WHERE name = "libraryfield";
  TestEq(TRUE, RecordExists(inputmapping_webharetestsuite_arrayfield_libraryfield));

  testfw->BeginWork(); //temporary

  OBJECT publishersearchtesttype := OpenWHFSType("http://www.webhare.net/xmlns/webhare_testsuite/publisher/publishersearchtest");
  INTEGER rootid := GetTestsuiteTempFolder()->id;
  OBJECT testfile := GetTestsuiteTempFolder()->CreateFile([name:="testfile7.txt", title := "blafile7", type := publishersearchtesttype->id , data := StringToBlob("blabla7") , publish := TRUE ]);

  publishersearchtesttype->SetInstanceData(testfile->id,
      [ testfield := testfile->id
      , test_whfsrefarray := INTEGER[ testfile->id ]
      , keywordfield := "K1"
      ]);

  //If the array is empty but the type matches we should still synthesize one element - this was the existing behaviour for arrayfields
  TestEqMembers([ mod_webhare_testsuite := [ contenttypefield := testfile->id
                                           , arrayfield := [ arrayfield := ""
                                                           , date_otherfield := DEFAULT DATETIME
                                                           , libraryfield := "array_" || testfile->id  || "_0"
                                                           , deeper_whfsrefarray := INTEGER[]
                                                           ]
                                           , purearray :=  [ libraryfield := "array_" || testfile->id  || "_0"
                                                           ]
                                           , test_whfsrefarray := INTEGER[ testfile->id ]
                                           , keywordfield := "K1"
                                           ]
                ], GetParsedIndexFields(testfile, 0), '*', "Without a set array, we should still see *one* result");
  TestEqMembers([ mod_webhare_testsuite := [ contenttypefield := testfile->id
                                           , purearray :=  [ libraryfield := "array_" || testfile->id  || "_1"
                                                           ]
                                           ]
                ], GetParsedIndexFields(testfile, 1), '*', "And arrays that only contain funtions, have no problems generating nonexisting arrays ");

  publishersearchtesttype->SetInstanceData(testfile->id,
      [ testfield := testfile->id
      , testarray := [ [ arrayfield := testfile->id || "_bla"
                       , otherfield := MakeDate(2016, 12, 31)
                       ]
                     , [ arrayfield := testfile->id || "_test"
                       , otherfield := MakeDate(2017, 1, 1)
                       , deeper_whfsrefarray := [rootid]
                       ]
                     ]
      ]);

  TestEqMembers([ mod_webhare_testsuite := [ contenttypefield := testfile->id
                                           , arrayfield := [ arrayfield := testfile->id  || "_bla"
                                                           , date_otherfield := MakeDate(2016, 12, 31)
                                                           , libraryfield := "array_" || testfile->id  || "_0"
                                                           , deeper_whfsrefarray := INTEGER[]
                                                           ]
                                           ]
                ], GetParsedIndexFields(testfile, 0), '*');

  TestEqMembers([ mod_webhare_testsuite := [ contenttypefield := testfile->id
                                           , arrayfield := [ arrayfield := testfile->id  || "_test"
                                                           , date_otherfield := MakeDate(2017,1,1)
                                                           , libraryfield := "array_" || testfile->id  || "_1"
                                                           , deeper_whfsrefarray := [rootid]
                                                           ]
                                           ]
                ], GetParsedIndexFields(testfile, 1), '*');

  testfile->UpdateMetadata([typens := "http://www.webhare.net/xmlns/publisher/richdocumentfile"]);
  TestEq([ contenttypefield := testfile->id
         , libraryfield := ToString(testfile->id)
         , keywordfield := "K1"
         , textfield := ""
         , test_whfsrefarray := INTEGER[ testfile->id ]
         ], GetParsedIndexFields(testfile, 0).mod_webhare_testsuite, "Type mismatch, so no arrayfield anymore");

  //B..B..But if the array is empty we STILL synthesize a record
  publishersearchtesttype->SetInstanceData(testfile->id,
      [ testarray := RECORD[]
      ]);
  TestEq([ contenttypefield := testfile->id
         , libraryfield := ToString(testfile->id)
         , keywordfield := "K1"
         , textfield := ""
         , arrayfield := [ arrayfield := ""
                         , date_otherfield := DEFAULT DATETIME
                         , libraryfield := "array_" || testfile->id  || "_0"
                         , deeper_whfsrefarray := INTEGER[]
                         ]
         , purearray := [ libraryfield := "array_" || testfile->id  || "_0" ]
         , test_whfsrefarray := INTEGER[ testfile->id ]
         ], GetParsedIndexFields(testfile, 0).mod_webhare_testsuite);

  testfile->SetInstanceData("http://www.webhare.net/xmlns/webhare_testsuite/publisher/publishersearchtest2", [ keywordfield := "K2" ]);
  TestEqMembers([ keywordfield := "K2" ], GetParsedIndexFields(testfile, 0).mod_webhare_testsuite, "*");

  testfw->RollbackWork(); //only exists to test our APIs

}

MACRO TestWHFSCatalog()
{
  FixConsilioIndices([ catalogmask := whconstant_consilio_catalog_whfs ]);

  OBJECT fsobjectssource := OpenConsilioCatalog(whconstant_consilio_catalog_whfs);
  Print(fsobjectssource->GetStorageInfo() || "\n");

  RECORD ARRAY fields := fsobjectssource->GetExpectedMapping();
  TestEqMembers(RECORD[], (SELECT * FROM fields WHERE name LIKE "*.*"),"*");
  TestEqMembers([[ name := "whfstree", type := "integer"
                ]], (SELECT * FROM fields WHERE name = "whfstree"), "*");

  RECORD mod_webhare_testsuite := SELECT * FROM fields WHERE name = "mod_webhare_testsuite";
  TestEqMembers([ name := "mod_webhare_testsuite"
                , type := "record"
                ], mod_webhare_testsuite, "*");

  TestEqMembers([[ name := "arrayfield"
                 , type := "record"
                 , defaultvalue := [ arrayfield := "", date_otherfield := DEFAULT DATETIME, libraryfield := "" ]
                 , properties := [[ name := "arrayfield", type := "keyword" ]
                                 ,[ name := "date_otherfield", type := "datetime" ] //NOTE implicit adding of date_
                                 ,[ name := "libraryfield", type := "keyword" ]
                                 ,[ name := "deeper_whfsrefarray", type := "integer", defaultvalue := INTEGER[] ]
                                 ]
                ]], (SELECT * FROM mod_webhare_testsuite.properties WHERE name = "arrayfield"), "*");
  TestEqMembers([[ name := "textfield", type := "text"
                ]], (SELECT * FROM mod_webhare_testsuite.properties WHERE name = "textfield"), "*");
  TestEqMembers([[ name := "keywordfield", type := "keyword"
                ]], (SELECT * FROM mod_webhare_testsuite.properties WHERE name = "keywordfield"), "*");
}

MACRO TestWHFSContentHandler()
{
  //Clean leftovers from any aborted catalog test run
  STRING ARRAY leftovers := SELECT AS STRING ARRAY objectid
                              FROM RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([ CQMatch("whfstree", "CONTAINS", OpenTestsuiteSite()->id ) ])).results
                             WHERE whfspath LIKE "*/tmp/*";
  IF(Length(leftovers) > 0)
    OpenConsilioCatalog(whconstant_consilio_catalog_whfs)->DeleteObjects(leftovers);

  // Create and fill the test site
  testfw->BeginWork();

  //test in a subfolder of temp so we don't rely on an earlier publisher index to have indexed the tempfolder
  testroot := GetTestsuiteTempFolder()->EnsureFolder([name := "publishersearch"]);
  subfolder := testroot->CreateFolder([ name := "subfolder", title := "blafolder <>" ]);
  testsiteid := testroot->parentsite;

  OBJECT richdoctype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/richdocumentfile");
  OBJECT publishersearchtesttype := OpenWHFSType("http://www.webhare.net/xmlns/webhare_testsuite/publisher/publishersearchtest");

  file_1 := testroot->CreateFile([name:="testfile1.txt", title := "blafile & co", data := StringToBlob("blabla"), publish := TRUE]);
  file_3 := testroot->CreateFile([name:="testfile2.shtml", title := "blafile", data := StringToBlob("<?wh LOADLIB 'currentsite::testfile2.whlib' EXPORT RunDynamicPage;"), publish := TRUE]);
  file_2 := testroot->CreateFile([name:="testfile3.whlib", title := "blafile", data := StringToBlob("<?wh PUBLIC MACRO RunDynamicPage() { PRINT('blabla3'); }") ]);
  file_4 := testroot->CreateFile([name:="testfile4.txt", title := "blafile", data := StringToBlob("blabla4"), publish := TRUE]);
  file_5 := testroot->CreateFile([name:="testfile5.rtd", title := "blafile", type := richdoctype->id, publish := TRUE]);
  file_7 := testroot->CreateFile([name:="testfile7.txt", title := "blafile7", type := publishersearchtesttype->id , data := StringToBlob("blabla7") , publish := TRUE ]);
  publishersearchtesttype->SetInstanceData(file_7->id,
      [ testfield := file_7->id
      , testarray := [ [ arrayfield := file_7->id || "_bla"
                       , otherfield := MakeDate(2016, 12, 31)
                       ]
                     , [ arrayfield := file_7->id || "_test"
                       , otherfield := MakeDate(2017, 1, 1)
                       ]
                     ]
      ]);

  OBJECT myrichdoc := NEW RichDocument;
  myrichdoc->ImportFromRecord([ htmltext := StringToBlob('<html><head></head><body>'
                                 || '<p class="normal">blabla5 <a href="#">blabla5link</a></p>'
                                 || '</body></html>')
                 , embedded := [ MakeMergedRecord(WrapBlob(GetHarescriptResource("mod::system/web/tests/snowbeagle.jpg"),"bob.jpg"), [ contentid := "imagecid-81400" ]) ]
                 ]);
  richdoctype->SetInstanceData(file_5->id, [data := myrichdoc->ExportAsRecord()]);

  //ensure structuredef documents are still (somewhat) indexed (otherwise we'd regress too early on these)
  OBJECT applytester := GetApplytesterForObject(file_5->id);
  RECORD indexable := GetRichDocumentIndexableContent(myrichdoc->ExportAsRecord(), CELL[applytester]);
  TestEqLike("*blabla5*blabla5link*", BlobToString(indexable.htmltext));

  beforerepositoryfolder := OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/beforerepository");
  IF(ObjectExists(beforerepositoryfolder->OpenByName("privatetestfile1.txt")))
    beforerepositoryfolder->OpenByName("privatetestfile1.txt")->RecycleSelf();
  privatetestfile1 :=  beforerepositoryfolder->EnsureFile([name:="privatetestfile1.txt", title := "private blafile", data := StringToBlob("blabliblo"), publish := TRUE]);

  INTEGER ARRAY expected_addtowhfsindex := INTEGER[ OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/beforerepository/boosted_more")->id
                                                  , OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/beforerepository/boosted")->id
                                                  , beforerepositoryfolder->id
                                                  , OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/beforesites")->id
                                                  , OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/aftersites")->id
                                                  , OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/anywhere")->id
                                                  ];

  OBJECT promise := GetWHFSCommitHandler()->WaitForChangesIndexed();
  testfw->CommitWork();

  // While we wait for the background contenthandlers to do their work.. we can inspect it directly too
  OBJECT catalog := OpenConsilioCatalog(whconstant_consilio_catalog_whfs);
  Testeq(TRUE, ObjectExists(catalog), `Catalog '${whconstant_consilio_catalog_whfs}' gone?`);
  Print(catalog->GetStorageInfo() || "\n");

  OBJECT provider := catalog->OpenContentSource("consilio:whfsobjects")->__OpenProvider();
  // The proxy object CustomContentProvider we get is pretty useless for deeper testing
  RECORD initdata := provider->__GetCCPInitData();
  OBJECT realprovider := MakeObject(`${initdata.library}#${initdata.contentobject}`, initdata);
  RECORD ARRAY startingpoints := realprovider->GetWHFSStartingPoints();

  //Verify the field structure
  RECORD ARRAY resultobjects := realprovider->ListObjects3(DEFAULT DATETIME, "fsobj_" || file_7->id, RECORD[], [ rebuild := TRUE ]).objects;
  //dumpvalue(resultobjects,'tree');
  TestEqMembers([[ data := [ document_fields := [ mod_webhare_testsuite := [ contenttypefield := file_7->id
                                                                           , arrayfield := [ arrayfield := file_7->id  || "_bla" ]
                                                                           ]
                                                ]
                           ]
                 ]
                ,[ data := [ document_fields := [ mod_webhare_testsuite := [ contenttypefield := file_7->id
                                                                           , arrayfield := [ arrayfield := file_7->id  || "_test" ]
                                                                           ]
                                                ]
                           ]
                 ]
                ], resultobjects, '*');

  //Test that the expected folders are indeed their in their expected order
  TestEq(expected_addtowhfsindex, SELECT AS INTEGER ARRAY folder FROM startingpoints WHERE folder IN expected_addtowhfsindex);
  TestEq(FALSE, RecordExists(SELECT FROM startingpoints WHERE folder = whconstant_whfsid_webharebackend), "WebHare backend is secret and should not be indexed");

  INTEGER ARRAY expected_offsets := SELECT AS INTEGER ARRAY #startingpoints FROM startingpoints WHERE folder IN expected_addtowhfsindex;
  TestEq(TRUE, expected_offsets[2] < (SELECT AS INTEGER #startingpoints FROM startingpoints WHERE folder = whconstant_whfsid_repository), "our beforerepository should be before repository");
  TestEq(TRUE, expected_offsets[3] > (SELECT AS INTEGER #startingpoints FROM startingpoints WHERE folder = whconstant_whfsid_repository), "our beforesites should be AFTER repository");
  TestEq(TRUE, expected_offsets[3] < (SELECT AS INTEGER #startingpoints FROM startingpoints WHERE folder = testroot->parentsite), "our beforesites should be BEFORE the test site");
  TestEq(TRUE, expected_offsets[4] > (SELECT AS INTEGER #startingpoints FROM startingpoints WHERE folder = testroot->parentsite), "our aftersites should be AFTER the test site");

  print("counting... ");
  STRING ARRAY groupids := SELECT AS STRING ARRAY id FROM realprovider->ListGroups(DEFAULT DATETIME).groups ORDER BY id;
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || whconstant_whfsid_repository) != -1);
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || whconstant_whfsid_lostandfound) != -1);
  TestEq(FALSE, BinaryFind(groupids, "fsobj_" || whconstant_whfsid_private_system) != -1);
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || testroot->id) != -1, "Test folder should be in scope of publisher search");
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || file_1->id) != -1, "For now individual files are still in sope");
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || subfolder->id) != -1, "Test subfolder should also be in scope of publisher search");
  TestEq(TRUE, BinaryFind(groupids, "fsobj_" || whconstant_whfsid_repository) < BinaryFind(groupids, "fsobj_" || OpenWHFSPrivateFolder("webhare_testsuite")->OpenByPath("addtowhfsindex/beforerepository/nonboosted")->id), "Non-boosted repository file should be indexed after repository");

  // No duplicates
  TestEQ(LENGTH(GetSortedSet(groupids)), LENGTH(groupids));

  resultobjects := realprovider->ListObjects3(DEFAULT DATETIME, "fsobj_" || testroot->id, RECORD[], [ rebuild := TRUE ]).objects;
  TestEq(TRUE, RecordExists(SELECT FROM resultobjects WHERE id = "fsobj_" || testroot->id));

  Print("waiting for our preparation to be indexed...\n");
  WaitForPromise(promise);
  Print("it's indexed\n");
}

MACRO PublisherSearchTest()
{
  // Empty contain should not crash
  RECORD result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfstree", "CONTAINS", INTEGER[]));
  TestEq(0, result.totalcount);
  TestEQ(STRING[], result.eventmasks, "A nothing query will never return anything, so no events to listen to");

  // Search for all objects within the test folder
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfstree", "CONTAINS", testroot->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = testroot->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = subfolder->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_1->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_2->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_3->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_4->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));
  TestEq(9, result.totalcount,"also 2 results from file_7");
  TestEQ(TRUE, Length(result.eventmasks) > 0); //FIXME actually test/use this eventmask, or if nothing else, at least verify it..

  // Check for some returned fields
  RECORD resultobj := SELECT * FROM result.results WHERE whfsid = file_5->id;
  TestEq(TRUE, RecordExists(resultobj));
  TestEq("fsobj_" || file_5->id, resultobj.groupid);
  TestEq("fsobj_" || file_5->id, resultobj.objectid);
  TestEq(file_5->id, resultobj.whfsid);
  TestEq("file", resultobj.whfsobject);
  TestEq(testroot->id, resultobj.whfsparent);
  TestEq(file_5->whfspath, resultobj.whfspath);
  TestEq([ whconstant_whfsid_webhare_tests, testroot->parentobject->parent, testroot->parent, testroot->id, file_5->id ], resultobj.whfstree);

  OBJECT richdoctype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/richdocumentfile");
  TestEq(richdoctype->id, resultobj.whfstype);

  // Search for other fields
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder")]));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = subfolder->id));

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafile")]));
  TestEq(5, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_1->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_2->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_3->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_4->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));

  RECORD ARRAY items;
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder blafile", [ querymode := "OR" ])]), [ highlightfields := ["title"] ]);
  TestEq(6, result.totalcount);

  items := SELECT * FROM result.results ORDER BY whfspath;
  TestEq("<span class=\"consilio--highlight\">blafolder</span> &#60;&#62;", items[0].title);
  TestEq("blabla5 blabla5link", items[5].summary); //'summary' by default
  TestEq(FALSE, CellExists(items[5], 'score'));
  TestEq(FALSE, CellExists(items[5], '_score'));
  TestEq(FALSE, CellExists(items[5], '_summary'));

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder blafile", [ querymode := "OR" ])]), [ highlightfields := ["_summary"], summaryfield := "_summary" ]);
  TestEq(6, result.totalcount);

  items := SELECT * FROM result.results ORDER BY whfspath;
  TestEq("blafolder <>", items[0].title);
  TestEq("blabla5 blabla5link", items[5]._summary);

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder blafile", [ querymode := "OR" ])]), [ highlightfields := ["summary"], summaryfield := "summary", scorefield := "points" ]);
  TestEq(6, result.totalcount);

  items := SELECT * FROM result.results ORDER BY whfspath;
  TestEq("blafolder <>", items[0].title);
  TestEq("blabla5 blabla5link", items[5].summary);
  TestEq(TYPEID(FLOAT), TYPEID(items[5].points), 'ensure score exists and is of proper type');

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder blafile", [ querymode := "OR" ])]), [ summaryfield := "" ]);
  TestEq(6, result.totalcount);

  items := SELECT * FROM result.results ORDER BY whfspath;
  TestEq(FALSE, CellExists(items[5],"_summary"));
  TestEq(FALSE, CellExists(items[5],"summary"));

  //TestEq("blafile", items[0]._summary);

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blafolder blafile")]));
  TestEq(0, result.totalcount);

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blabla")]));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_1->id));
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blabla4")]));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_4->id));
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blabla5")]));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQAnd([CQMatch("whfstree", "CONTAINS", testsiteid), CQParseUserQuery("blabla5link")]));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));

  // Search for the site root object
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", testroot->id));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = testroot->id));

  // Search for all objects directly within the site root (shouldn't return the site root itself)
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsparent", "=", testroot->id));
  TestEq(8, result.totalcount);
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE whfsid = testroot->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = subfolder->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_1->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_2->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_3->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_4->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));

  // Recycle a file, it should no longer be found
  testfw->BeginWork();

  file_4->RecycleSelf();

  CommitAndWaitForPublisherIndex();

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_4->id));
  TestEq(0, result.totalcount, "RecycleSelf file still found, race?");

  // Restore the file, it should return
  testfw->BeginWork();
  OpenWHFSObject(file_4->id)->MoveTo(testroot, "");
  CommitAndWaitForPublisherIndex();

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_4->id));
  TestEq(1, result.totalcount, "Restore file not found, race?");

  // Delete a file, it should no longer be found either
  testfw->BeginWork();

  file_4->DeleteSelf();

  CommitAndWaitForPublisherIndex();

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_4->id));
  TestEq(0, result.totalcount, "DeleteSelf file still found, race?");

  // Move a file, it should have a new parent
  testfw->BeginWork();

  file_1->MoveTo(subfolder, "");

  CommitAndWaitForPublisherIndex();

  file_1->Refresh();
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_1->id));
  TestEq(1, result.totalcount);
  resultobj := SELECT * FROM result.results WHERE whfsid = file_1->id;
  TestEq(TRUE, RecordExists(resultobj));
  TestEq("fsobj_" || file_1->id, resultobj.groupid);
  TestEq("fsobj_" || file_1->id, resultobj.objectid);
  TestEq(file_1->parent, resultobj.whfsparent);

  // Search for all objects directly within the site root (should no longer return the moved and deleted files)
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsparent", "=", testroot->id));
  TestEq(6, result.totalcount);
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE whfsid = testroot->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = subfolder->id));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE whfsid = file_1->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_2->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_3->id));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE whfsid = file_4->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE whfsid = file_5->id));

  // Delete the subfolder, file 1 should no longer be found
  testfw->BeginWork();
  subfolder->DeleteSelf();
  CommitAndWaitForPublisherIndex();

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_1->id), [ refresh := TRUE ]);
  TestEq(0, result.totalcount);

  // The file should not be found by the custom index field (it hasn't been set yet)
  OBJECT search_obj := OpenSearchObject("en", whconstant_consilio_catalog_whfs);

  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.contenttypefield", "=", file_5->id), 0, -1);
  TestEq(0, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", file_5->id), 0, -1);
  TestEq(0, result.totalcount);

  testfw->BeginWork();

  OBJECT publishersearchtesttype := OpenWHFSType("http://www.webhare.net/xmlns/webhare_testsuite/publisher/publishersearchtest");
  publishersearchtesttype->SetInstanceData(file_5->id, [ testfield := file_5->id ]);

  CommitAndWaitForPublisherIndex();

  // Find 'file_5' by id and check custom module field
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_5->id));
  TestEq(1, result.totalcount);
  TestEq(TRUE, CellExists(result.results[0], 'mod_webhare_testsuite'));
  TestEq(TRUE, CellExists(result.results[0].mod_webhare_testsuite, 'contenttypefield'));
  TestEq(file_5->id, result.results[0].mod_webhare_testsuite.contenttypefield);
  TestEq(TRUE, CellExists(result.results[0].mod_webhare_testsuite, 'libraryfield'));
  TestEq(ToString(file_5->id), result.results[0].mod_webhare_testsuite.libraryfield);

  // Find by module field
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("mod_webhare_testsuite.contenttypefield", "=", file_5->id));
  TestEq(1, result.totalcount);
  TestEq(file_5->id, result.results[0].whfsid);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", file_5->id), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_5->id, result.results[0].whfsid);

  testfw->BeginWork();

  publishersearchtesttype->SetInstanceData(file_5->id, [ testfield := testroot->id ]);

  CommitAndWaitForPublisherIndex();

  // Find 'file_5' by id and check updated custom module field
  result := search_obj->SearchQuery(CQMatch("whfsid", "=", file_5->id), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(testroot->id, result.results[0].mod_webhare_testsuite.contenttypefield);
  TestEq("", result.results[0].mod_webhare_testsuite.libraryfield);

  // It should only be found by the new id
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.contenttypefield", "=", file_5->id), 0, -1);
  TestEq(0, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.contenttypefield", "=", testroot->id), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_5->id, result.results[0].whfsid);
  // It should not be found by the libraryfield, as it only returns the object id
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", file_5->id), 0, -1);
  TestEq(0, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", testroot->id), 0, -1);
  TestEq(0, result.totalcount);

  // Silently update the testfield
  testfw->BeginWork();

  publishersearchtesttype->SetInstanceData(file_5->id, [ testfield := file_5->id ], [ isvisibleedit := FALSE ]);

  CommitAndWaitForPublisherIndex();

  // Find 'file_5' by id and check updated custom module field
  result := search_obj->SearchQuery(CQMatch("whfsid", "=", file_5->id), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_5->id, result.results[0].mod_webhare_testsuite.contenttypefield);
  TestEq(ToString(file_5->id), result.results[0].mod_webhare_testsuite.libraryfield);

  // It should now be found again by the file's id and by the libraryfield
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.contenttypefield", "=", file_5->id), 0, -1);
  TestEq(1, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.contenttypefield", "=", testroot->id), 0, -1);
  TestEq(0, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", file_5->id), 0, -1);
  TestEq(1, result.totalcount);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.libraryfield", "=", testroot->id), 0, -1);
  TestEq(0, result.totalcount);

  testfw->BeginWork();

  publishersearchtesttype->SetInstanceData(file_5->id,
      [ testfield := file_5->id
      , testarray := [ [ arrayfield := file_5->id || "_bla" ]
                     , [ arrayfield := file_5->id || "_test" ]
                     ]
      ]);

  CommitAndWaitForPublisherIndex();

  // Find 'file_5' objects by id, the array fields should not be present as they follow subfiles presence
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_5->id));
  TestEq(1, result.totalcount);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.contenttypefield = file_5->id));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_5->id || "_bla"));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_5->id || "_test"));

  // Find 'file_7' objects by id and check custom module fields
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_7->id));
  TestEq(2, result.totalcount, `testfile7.txt #${file_7->id} splits into two subfiles, so we expect 2 results`);
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_bla"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_test"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.date_otherfield = MakeDate(2016, 12, 31)));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.date_otherfield = MakeDate(2017, 1, 1)));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.libraryfield = "array_" || file_7->id || "_0"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.libraryfield = "array_" || file_7->id || "_1"));

  // Find each object separately, should both return the same object
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("mod_webhare_testsuite.arrayfield.arrayfield", "=", file_7->id || "_bla"));
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq("array_" || file_7->id || "_0", result.results[0].mod_webhare_testsuite.arrayfield.libraryfield);
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("mod_webhare_testsuite.arrayfield.arrayfield", "=", file_7->id || "_test"));
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq("array_" || file_7->id || "_1", result.results[0].mod_webhare_testsuite.arrayfield.libraryfield);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.arrayfield.libraryfield", "=", "array_" || file_7->id || "_0"), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq(file_7->id || "_bla", result.results[0].mod_webhare_testsuite.arrayfield.arrayfield);
  result := search_obj->SearchQuery(CQMatch("mod_webhare_testsuite.arrayfield.libraryfield", "=", "array_" || file_7->id || "_1"), 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq(file_7->id || "_test", result.results[0].mod_webhare_testsuite.arrayfield.arrayfield);

  // Find each object by default body search
  result := search_obj->Search(file_7->id || "_bla", 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq("array_" || file_7->id || "_0", result.results[0].mod_webhare_testsuite.arrayfield.libraryfield);
  result := search_obj->Search(file_7->id || "_test", 0, -1);
  TestEq(1, result.totalcount);
  TestEq(file_7->id, result.results[0].whfsid);
  TestEq("array_" || file_7->id || "_1", result.results[0].mod_webhare_testsuite.arrayfield.libraryfield);

  // Find each object using range filters
  RECORD rangequery := CQAnd(
      [ CQMatch("mod_webhare_testsuite.arrayfield.date_otherfield", ">=", MakeDate(2016, 12, 31))
      , CQMatch("whfstree", "CONTAINS", testsiteid)
      ]);
  result := search_obj->SearchQuery(rangequery, 0, -1);
  TestEq(2, result.totalcount);
  TestEq(2, Length(SELECT FROM result.results WHERE whfsid = file_7->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_bla"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_test"));

  //*this* is a range query
  rangequery := CQAnd(
      [ CQRange("mod_webhare_testsuite.arrayfield.date_otherfield", MakeDate(2016, 12, 31), TRUE, MakeDate(2017,1,1), FALSE)
      , CQMatch("whfstree", "CONTAINS", testsiteid)
      ]);
  result := search_obj->SearchQuery(rangequery, 0, -1);
  TestEq(1, result.totalcount);
  TestEq(1, Length(SELECT FROM result.results WHERE whfsid = file_7->id));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_bla"));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_test"));

  rangequery := CQAnd(
      [ CQMatch("mod_webhare_testsuite.arrayfield.date_otherfield", ">=", MakeDate(2017, 1, 1))
      , CQMatch("whfstree", "CONTAINS", testsiteid)
      ]);
  result := search_obj->SearchQuery(rangequery, 0, -1);
  TestEq(1, result.totalcount);
  TestEq(1, Length(SELECT FROM result.results WHERE whfsid = file_7->id));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_bla"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_test"));

  rangequery := CQAnd(
      [ CQMatch("mod_webhare_testsuite.arrayfield.date_otherfield", ">", MakeDate(2016, 12, 31))
      , CQMatch("whfstree", "CONTAINS", testsiteid)
      ]);
  result := search_obj->SearchQuery(rangequery, 0, -1);
  TestEq(1, result.totalcount);
  TestEq(1, Length(SELECT FROM result.results WHERE whfsid = file_7->id));
  TestEq(FALSE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_bla"));
  TestEq(TRUE, RecordExists(SELECT FROM result.results WHERE results.mod_webhare_testsuite.arrayfield.arrayfield = file_7->id || "_test"));
}

ASYNC MACRO InspectConsilio()
{
  AWAIT ExpectScreenChange(+1, PTR RunFSObjectInspectDialog(GetTestController(), file_5->id));
  TTClick(":Reindex");
  AWAIT ExpectScreenChange(-1, PTR TTEscape);

  RECORD result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_5->id), [ debug:=true]);
  TestEq(1, result.totalcount);

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", privatetestfile1->id), [ debug:=true]);
  TestEq(1, result.totalcount);

  AWAIT ExpectScreenChange(+1, PTR RunFSObjectInspectDialog(GetTestController(), privatetestfile1->id));
  TTClick(":Reindex");

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", privatetestfile1->id));
  TestEq(1, result.totalcount);

  testfw->BeginWork();
  OBJECT tokill := beforerepositoryfolder->parentobject->OpenByName(privatetestfile1->name);
  IF(ObjectExists(tokill))
    tokill->DeleteSelf(); //destroy remnant from a previous test

  //Manually move our testfile away .. so no consilio events trigger
  UPDATE system.fs_objects SET parent := beforerepositoryfolder->parent WHERE id=privatetestfile1->id;
  testfw->CommitWork();

  //A reindex of a file outside a starting point should delete it`
  TTClick(":Reindex");
  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", privatetestfile1->id), [ refresh := TRUE ]);
  TestEq(0, result.totalcount);

  AWAIT ExpectScreenChange(-1, PTR TTEscape);
}

MACRO TestUpdateCheckIndex()
{
  //moved these tests to the end as they can be slow on a large database
  // Update the index, both objects should still be present
  OBJECT fsobjectssource := OpenConsilioCatalog(whconstant_consilio_catalog_whfs)->OpenContentSource("consilio:whfsobjects");
  fsobjectssource->ReindexContentSource();
  fsobjectssource->WaitForIndexingDone([ verbose := TRUE ]);

  INTEGER catalogid := (SELECT AS INTEGER id FROM consilio.catalogs WHERE name = whconstant_consilio_catalog_whfs);
  RECORD result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_7->id));
  TestEq(2, result.totalcount, `testfile7.txt #${file_7->id} splits into two subfiles, so we expect 2 results`);

  // Check the index, both objects should still be present
  fsobjectssource->ReindexContentSource([ rebuild := TRUE ]);
  fsobjectssource->WaitForIndexingDone([ verbose := TRUE ]);

  result := RunConsilioSearch(whconstant_consilio_catalog_whfs, CQMatch("whfsid", "=", file_7->id));
  TestEq(2, result.totalcount, `testfile7.txt #${file_7->id} splits into two subfiles, so we expect 2 results`);

  // Delete the file, no objects should no longer be found
  testfw->BeginWork();

  file_7->RecycleSelf();

  CommitAndWaitForPublisherIndex();

  OBJECT search_obj := OpenSearchObject("en", whconstant_consilio_catalog_whfs);
  result := search_obj->SearchQuery(CQMatch("whfsid", "=", file_7->id), 0, -1);
  TestEq(0, result.totalcount, "This test may have failed because of a race condition, you may wish to retry");
}

RunTestframework([ PTR TestIndexFields
                 , PTR TestWHFSCatalog
                 , PTR TestWHFSContentHandler
                 , PTR InspectConsilio
                 , PTR PublisherSearchTest
                 , PTR TestUpdateCheckIndex
                 ]
                 , [ testusers := [[ login := "sysop", grantrights := ["system:sysop"] ]
                   ]]);
