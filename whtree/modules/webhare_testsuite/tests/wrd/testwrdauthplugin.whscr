<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";
LOADLIB "wh::util/otp.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::publisher/lib/testframework.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::tollium/lib/testframework.whlib";
LOADLIB "mod::wrd/lib/auth.whlib";
LOADLIB "mod::wrd/lib/dialogs.whlib";

LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";

LOADLIB "mod::webhare_testsuite/lib/internal/testsite.whlib";


/*******************************************************************************
 *
 * Test WRD authentication using the webdesign plugin API
 */
//ADDME: Using the plugin seems to always make the login persistent

STRING baseurl;
RECORD thirdpartytest;
STRING thirdpartyurl;
INTEGER entityid;

RECORD FUNCTION DoReq(RECORD vars, BOOLEAN thirdparty DEFAULTSTO FALSE)
{
  IF(NOT testfw->browser->GotoWebPage(UpdateURLVariables(thirdparty ? thirdpartyurl : baseurl, vars)) OR testfw->browser->contenttype!="application/x-hson")
  {
    SendBlobTo(0,testfw->browser->content);
    Abort("get failure on " || testfw->browser->url);
  }
  RETURN DecodeHSON(BlobToString(testfw->browser->content,-1));
}

MACRO PrepareServer()
{
  RECORD testport := testfw->GetLocalhostWebinterface();
  thirdpartytest  := testfw->CreateWebserverPort([ outputserver := TRUE, virtualhosts := ["localhost.beta.webhare.net"]]); //note: localhost.webhare.com maps to 127.0.0.1

  testfw->BeginWork();

  baseurl := testport.baseurl || "wrd/authtest/webhare_testsuite.shtml?";
  thirdpartyurl := thirdpartytest.webservers[0].url || "wrd/authtest/webhare_testsuite.shtml?";

  INSERT INTO system.access(webserver, path, matchtype, hostingsrc, hostingpath)
         VALUES(testport.webserverid, "/wrd/authtest/webhare_testsuite.shtml", 0/*exact*/, 3/*exact file*/, GetModuleInstallationRoot("webhare_testsuite") || "tests/wrd/authplugin.shtml");

  INSERT INTO system.access(webserver, path, matchtype, hostingsrc, hostingpath)
         VALUES(thirdpartytest.webservers[0].id, "/wrd/authtest/webhare_testsuite.shtml", 0/*exact*/, 3/*exact file*/, GetModuleInstallationRoot("webhare_testsuite") || "tests/wrd/authplugin.shtml");

  testfw->CommitWork();

  testfw->RefreshWebserverConfig();
}

MACRO CreateMyTestSchema()
{
  RECORD result;

  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  TestEq(TRUE, ObjectExists(schemaobj));

  OBJECT persontype := schemaobj->GetType("WRD_PERSON");
  OBJECT auditlogtype := schemaobj->GetType("WRD_AUDITLOG");
//  persontype->CreateAttribute("EMAIL", "Email address", "", "WRD_CONTACT_EMAIL", "");
//  persontype->CreateAttribute("PASSWORD", "Password", "", "PASSWORD", "");

//  OBJECT domain := CreateWRDAuthDomain(persontype, "TESTDOMAIN", "WRD_CONTACT_EMAIL", "PASSWORD");

  OBJECT entity := persontype->CreateEntity(
      [ wrd_contact_email := "testaccount@test.invalid"
      , whuser_password := CreateAuthenticationSettingsFromPasswordHash(testfw->hashedpasswords.secret)
      , whuser_unit := testfw->testunit
      ]);
  entityid := entity->id;

  testfw->CommitWork();

  //ADDME some sort of automatic backing off/delays/even captcha? to prevent excessive login attempts ?

  result := DoReq( [ action := "login", username := "testaccount@test.invali", pwd := "wrongpassword", browsertriplet := "mac-chrome-01" ]);
  TestEq(FALSE, result.success);
  TestEq("UNKNOWNLOGIN", result.code);
  TestAuditEvent(
      [ entity := 0
      , type := "wrd:login:failed"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invali"
      , impersonated := FALSE
      , data := EncodeHSON([failurecode := "UNKNOWNLOGIN"])
      , browsertriplet := "mac-chrome-01"
      , byentity := 0
      , bylogin := "testaccount@test.invali"
      ]);

  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "wrongpassword", browsertriplet := "mac-chrome-01" ]);
  TestEq(FALSE, result.success);
  TestEq("INCORRECTPASSWORD", result.code);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:failed"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := EncodeHSON([failurecode := "INCORRECTPASSWORD"])
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "secret", browsertriplet := "mac-chrome-01" ]);
  TestEq(TRUE, result.success);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  result := DoReq( [ action := "checkstatus" ]);
  TestEq(TRUE, result.isloggedin);
  TestEq("testaccount@test.invalid", result.loginname);
  TestEq(entity->id, result.entityid);

  //regression test. issue #5989, early use of GetLoggedinEntity() or GetLoginName() causes a re-login
  result := DoReq( [ action := "logout-checkstatus", browsertriplet := "mac-chrome-01"  ]);
  TestEq(TRUE, result.oldstatus.isloggedin);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:logout"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  //set up last login and last ip fields
  testfw->BeginWork();
  persontype->CreateAttribute("LASTLOGIN",  "DATETIME");
  persontype->CreateAttribute("LASTIP",     "FREE");
  OBJECT domaintype := testfw->GetWRDSchema()->GetType("WRD_AUTHDOMAIN");
  domaintype->GetEntity(domaintype->Search("WRD_TAG","MYBACKEND"))->UpdateEntity(
    [ WRDAUTH_LASTLOGINFIELD := "LASTLOGIN"
    , WRDAUTH_LASTIPFIELD := "LASTIP"
    ]);
  testfw->CommitWork();

  //failed login shouldn't set these fields
  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "wrongpassword", browsertriplet := "mac-chrome-02" ]);
  TestEq(FALSE, result.success);
  TestEq("INCORRECTPASSWORD", result.code);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:failed"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := EncodeHSON([failurecode := "INCORRECTPASSWORD"])
      , browsertriplet := "mac-chrome-02"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  TestEq(DEFAULT DATETIME, entity->GetField("LASTLOGIN"));
  TestEq("", entity->GetField("LASTIP"));

  //neither should a 'master' (impersonated) login
  result := DoReq( [ action := "loginid", userid := ToString(entityid), impersonation := "1", browsertriplet := "mac-chrome-02" ]);
  TestEq(TRUE, result.success);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := TRUE
      , data := ""
      , browsertriplet := "mac-chrome-02"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      , impersonator_entity := entityid
      , impersonator_login := "testaccount@test.invalid"
      ]);

  TestEq(DEFAULT DATETIME, entity->GetField("LASTLOGIN"));
  TestEq("", entity->GetField("LASTIP"));

  result := DoReq( [ action := "logout-checkstatus", browsertriplet := "mac-chrome-02" ]);
  TestEq(TRUE, result.oldstatus.isloggedin);
  TestEq(FALSE, result.isloggedin);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:logout"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-02"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  DATETIME now := GetCurrentDatetime();
  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "secret", browsertriplet := "mac-chrome-03"]);
  TestEq(TRUE, result.success);

  TestEq(TRUE, entity->GetField("LASTLOGIN") >= now);
  TestEq(TRUE, entity->GetField("LASTIP") LIKE "*.*.*.*" OR entity->GetField("LASTIP") LIKE "*::*");

  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-03"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);
}

MACRO TestModuleDefIPRules()
{
  //testfw->browser->debug := TRUE;
  TestEq(FALSE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop/"));
  TestEq(403, testfw->browser->GetHTTPStatusCode(),"should receive 403 as our current user is unprivileged");

  TestEq(FALSE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop-or-consilio/"));
  TestEq(403, testfw->browser->GetHTTPStatusCode());

  OBJECT trustedbrowser := NEW WebBrowser;
  //trustedbrowser->debug := TRUE;
  trustedbrowser->autofollow := FALSE;
  trustedbrowser->SetupWebHareTrustedPort(GetWebhareConfiguration().trustedhost, GetWebhareConfiguration().trustedport, fetcher_trusted_ip);

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop/"));
  TestEq(303, trustedbrowser->GetHTTPStatusCode(), "should be redirect to login page as we have no session");

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop-or-consilio/"));
  TestEq(200, trustedbrowser->GetHTTPStatusCode());
}

MACRO TestPersistentLogin()
{
  OBJECT auditlogtype := testfw->GetWRDSchema()->GetType("WRD_AUDITLOG");

  RECORD result;
  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "secret", browsertriplet := "mac-chrome-04" ]);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-04"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  RECORD logincookie := SELECT * FROM testfw->browser->GetAllCookies() WHERE ToUppercase(name)="WEBHARELOGIN-TESTSUITE-PORTAL1";
  TEstEq(TRUE, RecordExists(logincookie));
  TestEQ(DEFAULT DATETIME, logincookie.expires);

  //Invalidate the sessionid stored in the webhare login cookie
  TestEq(TRUE, testfw->browser->GetCookie("webharelogin-testsuite-portal1") != "");
  testfw->browser->SetSessionCookie("webharelogin-testsuite-portal1", "d_VFv-saZMPc0TyZ7Wi1Gg " || Tokenize(testfw->browser->GetCookie("webharelogin-testsuite-portal1"),' ')[1]);

  //Should autorestore because of the data in the cookie. Browser triplet cannot be stored
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(TRUE, result.isloggedin);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:logincookie"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := ""
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  //Completely clear the session
  testfw->browser->DeleteCookie("webharelogin-testsuite-portal1");

  //Should not recover
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);

//testfw->browser->debug:=TRUE;
  result := DoReq( [ action := "login", username := "testaccount@test.invalid", pwd := "secret", persistent := "1", browsertriplet := "mac-chrome-04" ]);
  TestEq(TRUE, testfw->browser->GetCookie("webharelogin-testsuite-portal1") != "");
  testfw->browser->SetSessionCookie("webharelogin-testsuite-portal1", "d_VFv-saZMPc0TyZ7Wi2Gg " || Tokenize(testfw->browser->GetCookie("webharelogin-testsuite-portal1"),' ')[1]);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-04"
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  //Should still recover from this (from the persistent cookie). Browser triplet not available in this path
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(TRUE, result.isloggedin);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:logincookie"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := ""
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);

  //Completely clear the session
  testfw->browser->DeleteCookie("webharelogin-testsuite-portal1");

  //Should now also recover from this. Browser triplet not available in this path
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(TRUE, result.isloggedin);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:logincookie"
      , login := "testaccount@test.invalid"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := ""
      , byentity := entityid
      , bylogin := "testaccount@test.invalid"
      ]);
}

VARIANT ARRAY FUNCTION MakeVA(VARIANT ARRAY args) __ATTRIBUTES__(VARARG)
{
  RETURN args;
}

MACRO TestCrossDomainLogin()
{
  OBJECT auditlogtype := testfw->GetWRDSchema()->GetType("WRD_AUDITLOG");
  testfw->browser->DeleteAllCookies();

  STRING loginrequiringurl := thirdpartyurl || "action=requirelogin";

  TestEq(TRUE, testfw->browser->GotoWebPage(loginrequiringurl), loginrequiringurl);
  TesteqLike("*wh-tollium--app*", testfw->browser->document->documentelement->GetAttribute("class")); //ensure we're talking to some sort of tollium

  //We should be seeing the tollium page above. Do a WRD login
//  testfw->browser->debug:=TRUE;
  STRING loginpage := testfw->browser->href;
  RECORD rec := testfw->browser->InvokeJSONRPC("/wh_services/wrd/auth", "Login",
                  MakeVA(testfw->browser->href, testfw->GetUserLogin("mysysop"), testfw->GetUserPassword("mysysop"), FALSE, [ browsertriplet := "mac-chrome-05" ]));

  TestEq(TRUE, rec.success);
  TestEq('reload', rec.result.submitinstruction.type);
  TestAuditEvent(
      [ entity := testfw->GetUserWRDId("mysysop")
      , type := "wrd:login:ok"
      , login := "mysysop@beta.webhare.net"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := "mac-chrome-05"
      , byentity := testfw->GetUserWRDId("mysysop")
      , bylogin := "mysysop@beta.webhare.net"
      ]);

  TestEq(TRUE, testfw->browser->GotoWebPage(loginpage));
  TestEq(200, testfw->browser->GetHTTPStatusCode()); // another redirect to clean the location
  TEstEq(loginrequiringurl, testfw->browser->href);

  //Find the _e cookie
  STRING e_cookiename := SELECT AS STRING name FROM testfw->browser->GetAllCookies() WHERE name LIKE 'webharelogin*_e';
  TestEq(TRUE, e_cookiename != "", "Cannot locate the webhare external access cookie");
  //change the sessionid, simulating a lost _e session
  testfw->browser->SetSessionCookie(e_cookiename, "V_DFv-saZMPa5TyZ7Wi2Gg " || Tokenize(testfw->browser->GetCookie(e_cookiename),' ')[1]);

  TestEq(TRUE, testfw->browser->GotoWebPage(loginrequiringurl)); //should still work
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  TestEq(TRUE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop"));
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  TestEq(TRUE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1/requiresysop-or-consilio"));
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  // Log the user out on the main page (TODO can we invalidate the external thirdparty logins to?). browsertriplet not availale
  TestAuditEvent(DEFAULT RECORD); //check log is still empty
  testEq(TRUE, testfw->browser->GotoWebPage(GetTestsuiteWRDauthPlugin()->GetLogoutLink()));
  TestAuditEvent(
      [ entity := testfw->GetUserWRDId("mysysop")
      , type := "wrd:logout"
      , login := "mysysop@beta.webhare.net"
      , impersonated := FALSE
      , data := ""
      , browsertriplet := ""
      , byentity := testfw->GetUserWRDId("mysysop")
      , bylogin := "mysysop@beta.webhare.net"
      ]);
}

RECORD onshowdata;
MACRO RecordOnShowData(RECORD data)
{
  onshowdata := data;
}

OBJECT ASYNC FUNCTION TestAuditDialog()
{
  AWAIT ExpectScreenChange(+1, PTR RunWRDAuditLogDialog(GetTestController(),
    [ wrdschema := testfw->GetWRDSchema()
    , accountid := testfw->GetUserWRDId("mysysop")
    , onshow := PTR RecordOnShowData
    ]));
  TestEq(2, Length(topscreen->events->rows));

  topscreen->events->selection := (SELECT * FROM topscreen->events->rows ORDER BY wrd_creationdate)[0];
  TestEq(FALSE, RecordExists(onshowdata));
  topscreen->events->openaction->TolliumClick();
  TestEq(TRUE, RecordExists(onshowdata));

  //dumpvalue(onshowdata);
  TestEq(testfw->GetUserWRDId("mysysop"), onshowdata.entity);
  TestEq("wrd:login:ok", onshowdata.type);

  topscreen->events->selection := (SELECT * FROM topscreen->events->rows ORDER BY wrd_creationdate)[1];
  topscreen->events->openaction->TolliumClick();
  TestEq(TRUE, RecordExists(onshowdata));

  //dumpvalue(onshowdata);
  TestEq(testfw->GetUserWRDId("mysysop"), onshowdata.entity);
  TestEq("wrd:logout", onshowdata.type);

  AWAIT ExpectScreenChange(-1, PTR topscreen->TolliumExecuteCancel);
  RETURN TRUE;
}

MACRO TestLoginDenied()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  TestEq(TRUE, ObjectExists(schemaobj));

  OBJECT persontype := schemaobj->GetType("WRD_PERSON");
  OBJECT auditlogtype := schemaobj->GetType("WRD_AUDITLOG");

  OBJECT entity := persontype->CreateEntity(
      [ wrd_contact_email := "logindenied@test.invalid"
      , whuser_password := CreateAuthenticationSettingsFromPasswordHash(testfw->hashedpasswords.secret)
      , whuser_unit := testfw->testunit
      ]);
  entityid := entity->id;

  testfw->CommitWork();

  // Make sure the current user is logged out
  RECORD result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  // Login is denied when logging in by username and password
  result := DoReq( [ action := "login", username := "logindenied@test.invalid", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEq(FALSE, result.success);
  TestEq("NOACCESS", result.code);
  TestEq(TRUE, CellExists(result, "USERINFO"));
  TestEq(FALSE, CellExists(result, "_INTERNAL"));
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:failed"
      , ip := "127.0.0.1"
      , login := "logindenied@test.invalid"
      , impersonated := FALSE
      , data :=
          EncodeHSON([ userinfo := [ wrd_contact_email := "logindenied@test.invalid" ]
                     , failurecode := "NOACCESS"
                     ])
      , browsertriplet := "mac-chrome-06"
      , byentity := entityid
      , bylogin := "logindenied@test.invalid"
      ]);

  // User still not logged in
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  DATETIME logcheckstart := GetCurrentDatetime();

  // Login is denied when logging in by id
  result := DoReq( [ action := "loginid", userid := ToString(entityid), browsertriplet := "mac-chrome-06" ]);
  TestEq(FALSE, result.success);
  TestEq("NOACCESS", result.code);
  TestEq(TRUE, CellExists(result, "USERINFO"));
  TestEq(FALSE, CellExists(result, "_INTERNAL"));
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:failed"
      , ip := "127.0.0.1"
      , login := "logindenied@test.invalid"
      , impersonated := FALSE
      , data :=
          EncodeHSON([ userinfo := [ wrd_contact_email := "logindenied@test.invalid" ]
                     , failurecode := "NOACCESS"
                     ])
      , browsertriplet := "mac-chrome-06"
      , byentity := entityid
      , bylogin := "logindenied@test.invalid"
      ]);

  // User still not logged in
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  // Login is not denied when impersonating login
  result := DoReq( [ action := "loginid", userid := ToString(entityid), impersonation := "1", browsertriplet := "mac-chrome-06" ]);
  TestEq(TRUE, result.success);
  TestEq(FALSE, RecordExists(result.submitinstruction));
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:ok"
      , login := "logindenied@test.invalid"
      , impersonated := TRUE
      , data := ""
      , browsertriplet := "mac-chrome-06"
      , byentity := entityid
      , bylogin := "logindenied@test.invalid"
      , impersonator_entity := entityid
      , impersonator_login := "logindenied@test.invalid"
      ]);

  OBJECT logstream := OpenWebHareLogStream("audit", logcheckstart, MAX_DATETIME);
  BOOLEAN found_logentry;
  WHILE (TRUE)
  {
    RECORD rec := logstream->ReadRecord();
    IF (NOT RecordExists(rec))
      BREAK;

    IF (rec.time < logcheckstart)
      CONTINUE;

    IF (rec.parts[0] = "wrd:auth")
    {
      RECORD auditcontext := DecodeHSON(rec.parts[2]);
      RECORD message := DecodeHSON(rec.parts[3]);

      IF (auditcontext.affecteduser_login = "logindenied@test.invalid" AND auditcontext.type = "wrd:loginbyid:failed")
      {
        TestEQ(
            [ affecteduser_entityid :=  entityid
            , affecteduser_login :=     'logindenied@test.invalid'
            , browsertriplet :=         'mac-chrome-06'
            , country :=                ''
            , impersonator_entityid :=  entityid
            , impersonator_login :=     'logindenied@test.invalid'
            , remoteip :=               '127.0.0.1'
            , type :=                   'wrd:loginbyid:failed'
            , user_authobject :=        0
            , user_entityid :=          entityid
            , user_login :=             'logindenied@test.invalid'
            ], auditcontext);

        TestEQ(
            [ userinfo := [ wrd_contact_email := "logindenied@test.invalid" ]
            , failurecode := "NOACCESS"
            ], message);
      }
    }
  }
  logstream->Close();
}

MACRO TestPasswordValidation()
{
  RECORD result;

  testfw->BeginWork();
  OBJECT wrdschema :=  testfw->GetWRDSchema();

  wrdschema->SetSchemaSetting("wrd:auth.passwordpolicy.validationchecks", "hibp");

  OBJECT newunit := testfw->GetWRDSchema()->^whuser_unit->CreateEntity(
      [ wrd_leftentity :=           testfw->testunit
      , wrd_title :=                "pvoverride"
      , override_passwordchecks :=  TRUE
      , passwordchecks :=           "uppercase:1"
      ]);

  OBJECT pwroot := testfw->userapi->GetUser(testfw->userapi->CreateUser(
      [ whuser_unit :=        testfw->testunit
      , wrd_contact_email :=  "pwroot@allow2fa.test.webhare.net"
      , wrd_firstname :=      "pwroot"
      , wrd_lastname :=       "McTestsuite"
      , whuser_password :=
            [ version :=      1
            , passwords :=    [ [ validfrom :=      AddDaysToDate(-2, GetCurrentDateTime())
                                , passwordhash :=   testfw->hashedpasswords.secret
                                ]
                              ]
            ]
      ]));

  OBJECT pwunitoverride := testfw->userapi->GetUser(testfw->userapi->CreateUser(
      [ whuser_unit :=        newunit->id
      , wrd_contact_email :=  "pwunitoverride@allow2fa.test.webhare.net"
      , wrd_firstname :=      "pwunitoverride"
      , wrd_lastname :=       "McTestsuite"
      , whuser_password :=
            [ version :=      1
            , passwords :=    [ [ validfrom :=      AddDaysToDate(-2, GetCurrentDateTime())
                                , passwordhash :=   testfw->hashedpasswords.secret
                                ]
                              ]
            ]
      ]));

  testfw->CommitWork();

  result := DoReq( [ action := "login", username := "pwroot@allow2fa.test.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEQMembers(
      [ success := FALSE
      , code := "FAILEDVALIDATIONCHECKS"
      ], result, "*");
  TestAuditEvent(
      [ [ entity := pwroot->entityid
        , type := "wrd:login:failedvalidationchecks"
        , login := "pwroot@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , data := EncodeHSON([ failurecode := "FAILEDVALIDATIONCHECKS", failedvalidationchecks := [ "hibp" ] ])
        , browsertriplet := "mac-chrome-06"
        , byentity := pwroot->entityid
        , bylogin := "pwroot@allow2fa.test.webhare.net"
        ]
      , [ entity := pwroot->entityid
        , type := "wrd:getresetlink"
        , login := "pwroot@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , __ignoredata := TRUE
        , browsertriplet := "mac-chrome-06"
        , byentity := pwroot->entityid
        , bylogin := "pwroot@allow2fa.test.webhare.net"
        ]
      ]);

  testfw->BeginWork();
  wrdschema->SetSchemaSetting("wrd:auth.passwordpolicy.validationchecks", "");
  testfw->CommitWork();

  result := DoReq( [ action := "login", username := "pwunitoverride@allow2fa.test.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEQMembers(
      [ success := FALSE
      , code := "FAILEDVALIDATIONCHECKS"
      ], result, "*");
  TestAuditEvent(
      [ [ entity := pwunitoverride->entityid
        , type := "wrd:login:failedvalidationchecks"
        , login := "pwunitoverride@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , data := EncodeHSON([ failurecode := "FAILEDVALIDATIONCHECKS", failedvalidationchecks := [ "complexity" ] ])
        , browsertriplet := "mac-chrome-06"
        , byentity := pwunitoverride->entityid
        , bylogin := "pwunitoverride@allow2fa.test.webhare.net"
        ]
      , [ entity := pwunitoverride->entityid
        , type := "wrd:getresetlink"
        , login := "pwunitoverride@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , __ignoredata := TRUE
        , browsertriplet := "mac-chrome-06"
        , byentity := pwunitoverride->entityid
        , bylogin := "pwunitoverride@allow2fa.test.webhare.net"
        ]
      ]);

  testfw->BeginWork();
  newunit->UpdateEntity([ passwordchecks := "maxage:P1D" ]);
  testfw->CommitWork();

  result := DoReq( [ action := "login", username := "pwunitoverride@allow2fa.test.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEQMembers(
      [ success := FALSE
      , code := "FAILEDVALIDATIONCHECKS"
      ], result, "*");
  TestAuditEvent(
      [ [ entity := pwunitoverride->entityid
        , type := "wrd:login:failedvalidationchecks"
        , login := "pwunitoverride@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , data := EncodeHSON([ failurecode := "FAILEDVALIDATIONCHECKS", failedvalidationchecks := [ "maxage" ]  ])
        , browsertriplet := "mac-chrome-06"
        , byentity := pwunitoverride->entityid
        , bylogin := "pwunitoverride@allow2fa.test.webhare.net"
        ]
      , [ entity := pwunitoverride->entityid
        , type := "wrd:getresetlink"
        , login := "pwunitoverride@allow2fa.test.webhare.net"
        , impersonated := FALSE
        , __ignoredata := TRUE
        , browsertriplet := "mac-chrome-06"
        , byentity := pwunitoverride->entityid
        , bylogin := "pwunitoverride@allow2fa.test.webhare.net"
        ]
      ]);

  testfw->BeginWork();
  newunit->UpdateEntity([ passwordchecks := "maxage:P1D" ]);
  testfw->CommitWork();
}


MACRO TestSecondFactorLogin()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  TestEq(TRUE, ObjectExists(schemaobj));

  OBJECT persontype := schemaobj->GetType("WRD_PERSON");
  OBJECT auditlogtype := schemaobj->GetType("WRD_AUDITLOG");

  STRING totpsecret := GenerateOTPSecret();

  OBJECT testunit := testfw->GetWRDSchema()->^whuser_unit->CreateEntity(
      [ wrd_leftentity :=           testfw->testunit
      , wrd_title :=                "secondfactorlogin"
      ]);

  OBJECT entity := persontype->CreateEntity(
      [ wrd_contact_email := "loginsecondfactor@beta.webhare.net"
      , whuser_password :=
              [ version :=      1
              , passwords :=    [ [ validfrom :=    GetCurrentDatetime()
                                  , passwordhash := testfw->hashedpasswords.secret
                                  ]
                                ]
              , totp :=         [ url := GetTOTPUrl(totpsecret, "loginsecondfactor@beta.webhare.net", "Webhare")
                                , backupcodes := [ [ code := "012345AA" ], [ code := "012345AB" ] ]
                                ]
              ]
      , whuser_unit := testunit->id
      ]);
  entityid := entity->id;

  testfw->CommitWork();
  RECORD result;

  // STORY: succesfull login
  result := DoReq( [ action := "login", username := "loginsecondfactor@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);

  TestEQStructure(
      [ code :=               "REQUIRESECONDFACTOR"
      , success :=            FALSE
      , secondfactordata :=   [ totp :=             TRUE
                              , totpattemptsleft := 6
                              , firstfactorproof := ""
                              , challenge :=        ""
                              ]
      , submitinstruction :=  DEFAULT RECORD
      ], result);

  STRING challenge := result.secondfactordata.challenge;

  TestEQMembers(
      [ code :=     "REQUIRESECONDFACTOR"
      , success :=  FALSE
      , secondfactordata :=
                    [ totp :=             TRUE
                    , totpattemptsleft := 6
                    ]
      ], result, "*");

  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:requiresecondfactor"
      , login := "loginsecondfactor@beta.webhare.net"
      , impersonated := FALSE
      , data := EncodeHSON(
                    [ failurecode := "REQUIRESECONDFACTOR"
                    , secondfactordata := CELL
                          [ challenge
                          ]
                    ])
      , browsertriplet := "mac-chrome-06"
      , byentity := entityid
      , bylogin := "loginsecondfactor@beta.webhare.net"
      ]);

  STRING code := GetTOTPCode(totpsecret);
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON(CELL[ code ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQ(
      [ code :=               ""
      , success :=            TRUE
      , submitinstruction :=  [ type := "reload" ]
      ], result);

  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:login:secondfactor:ok"
      , login := "loginsecondfactor@beta.webhare.net"
      , impersonated := FALSE
      , data := EncodeHSON(
                    [ secondfactordata := CELL
                          [ usedchallenge :=    challenge
                          , code
                          ]
                    ])
      , browsertriplet := "mac-chrome-06"
      , byentity := entityid
      , bylogin := "loginsecondfactor@beta.webhare.net"
      ]);

  // STORY: relogin with invalid code
  result := DoReq( [ action := "login", username := "loginsecondfactor@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);

  TestEQ(FALSE, challenge = result.secondfactordata.challenge, "challenge must change between requests");
  challenge := result.secondfactordata.challenge;

  STRING invalidcode;
  FOR (INTEGER i := 0; i < 10000000; i := i + 1)
  {
    invalidcode := Right("00000" || i, 6);
    IF (NOT TestTOTPCode(totpsecret, invalidcode, [ allowdrift := 120 ]).success) // allow large drift to test won't fail
      BREAK;
  }

  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON(CELL[ code := invalidcode ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQStructure(
      [ code :=               ""
      , success :=            FALSE
      , secondfactordata :=   [ totp :=             TRUE
                              , totpattemptsleft := 6
                              , firstfactorproof := ""
                              , challenge :=        ""
                              ]
      , submitinstruction :=  DEFAULT RECORD
      ], result);

  TestEQMembers(
      [ code :=               "TOTPINVALIDCODE"
      , submitinstruction :=  DEFAULT RECORD
      , secondfactordata :=
                    [ totp :=             TRUE
                    , totpattemptsleft := 5
                    ]
      ], result, "*");

  TestEQ(FALSE, challenge = result.secondfactordata.challenge, "challenge must change between requests");
  challenge := result.secondfactordata.challenge;

  // STORY: relogin with already used valid code
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON(CELL[ code ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQStructure(
      [ code :=               "REQUIRESECONDFACTOR"
      , success :=            FALSE
      , secondfactordata :=   [ totp :=             TRUE
                              , totpattemptsleft := 5
                              , firstfactorproof := ""
                              , challenge :=        ""
                              ]
      , submitinstruction :=  DEFAULT RECORD
      ], result);

  TestEQMembers(
      [ code :=               "TOTPREUSEDCODE"
      , submitinstruction :=  DEFAULT RECORD
      , secondfactordata :=
                    [ totp :=             TRUE
                    , totpattemptsleft := 5
                    ]
      ], result, "*");

  TestEQ(FALSE, challenge = result.secondfactordata.challenge, "challenge must change between requests");
  challenge := result.secondfactordata.challenge;

  // a future code must be accepted
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON([ code := GetTOTPCode(totpsecret, [ now := AddTimeToDate(30000, GetCurrentDatetime() )]) ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQ(
      [ code :=               ""
      , success :=            TRUE
      , submitinstruction :=  [ type := "reload" ]
      ], result);

  // no crashing on invalid first factor data
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , firstfactorproof := "invaliddata"
      , type := "totp"
      , data := EncodeJSON([ code := GetTOTPCode(totpsecret, [ now := AddTimeToDate(30000, GetCurrentDatetime() )]) ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQMembers(
      [ code :=               "INVALIDDATA"
      , success :=            FALSE
      , submitinstruction :=  DEFAULT RECORD
      ], result, "*");

  // Locking after 6 invalid codes
  result := DoReq( [ action := "login", username := "loginsecondfactor@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEQ(6, result.secondfactordata.totpattemptsleft);

  FOR (INTEGER i := 6; i >= 0; i := i - 1)
  {
    result := DoReq(CELL
        [ action := "loginsecondfactor"
        , result.secondfactordata.firstfactorproof
        , type := "totp"
        , data := EncodeJSON([ code := invalidcode ])
        , browsertriplet := "mac-chrome-06"
        ]);

    TestEQMembers(
        [ code :=               i <= 1 ? "TOTPLOCKED" : "TOTPINVALIDCODE"
        , success :=            FALSE
        , secondfactordata :=   [ totpattemptsleft := Max[]([ 0, i - 1 ]) ]
        , submitinstruction :=  DEFAULT RECORD
        ], result, "*");
  }

  TestEQ(FALSE, challenge = result.secondfactordata.challenge, "challenge must change between requests");
  challenge := result.secondfactordata.challenge;

  // Test backup code login and no reuse
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON([ code := "012345AA" ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQ(TRUE, result.success);

  result := DoReq( [ action := "login", username := "loginsecondfactor@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  result := DoReq(CELL
      [ action := "loginsecondfactor"
      , result.secondfactordata.firstfactorproof
      , type := "totp"
      , data := EncodeJSON([ code := "012345AA" ])
      , browsertriplet := "mac-chrome-06"
      ]);

  TestEQ(FALSE, result.success);

  // STORY: require2fa for user without 2fa set
  testfw->BeginWork();
  testunit->UpdateEntity(
      [ override_passwordchecks :=  TRUE
      , passwordchecks :=           "require2fa"
      ]);
  entity->UpdateEntity(
      [ whuser_password :=
              [ version :=      1
              , passwords :=    [ [ validfrom :=    GetCurrentDatetime()
                                  , passwordhash := testfw->hashedpasswords.secret
                                  ]
                                ]
              ]
      ]);
  testfw->CommitWork();

  result := DoReq( [ action := "login", username := "loginsecondfactor@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-06"]);
  TestEQMembers(
      [ code :=               "REQUIRESETUPSECONDFACTOR"
      , success :=            FALSE
      , submitinstruction :=  DEFAULT RECORD
      ], result, "*");

  TestEQ("setupsecondfactor", GetVariableFromURL(result.setuplink, "wrd_pwdaction"));
}


MACRO TestWRDAuthRouter()
{
  DoSetupWRDAuth();

  testfw->BeginWork();
  testfw->GetWRDSchema()->^wrd_person->CreateEntity([ wrd_contact_email := "testwrdauthrouter@beta.webhare.net"
                                                    , password := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO"  //secret
                                                    , whuser_unit := testfw->testunit
                                                    ]);
  testfw->CommitWork();

  //just login first
  STRING testbaseurl := OpenTestsuiteSite()->webroot || "testpages/";
  RECORD loginres := testfw->browser->CallJSONRPC("/wh_services/wrd/auth", "Login", testbaseurl || "wrdauthtest-router"
                                                 , "testwrdauthrouter@beta.webhare.net", "secret", FALSE);
  TestEq(TRUE, loginres.success);

  OBJECT wrdplugin := GetWRDAuthPlugin(testbaseurl || "wrdauthtest-router/");
  RECORD wittydata := wrdplugin->GetWRDAuthRouterWittyData(testbaseurl || "wrdauthtest-router/");
  TestEqLike("http*", wittydata.forgotpasswordlink);
  TestEq("", wittydata.emailchangelink);

  wrdplugin := GetWRDAuthPlugin(testbaseurl || "wrdauthtest-router-extended/");
  wittydata := wrdplugin->GetWRDAuthRouterWittyData(testbaseurl || "wrdauthtest-router-extended/");
  TestEqLike("http*", wittydata.forgotpasswordlink);
  TestEqLike("http*", wittydata.emailchangelink);

  testfw->browser->autofollow := FALSE;
  TestEq(TRUE, testfw->browser->GotoWebPage(wittydata.emailchangelink));
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  TestEq(FALSE, testfw->browser->GotoWebPage(Substitute(wittydata.emailchangelink, "wrdauthtest-router-extended", "wrdauthtest-router")));
  TestEq(403, testfw->browser->GetHTTPStatusCode(), "should explicitly show emailchange as forbidden");

  testfw->browser->DeleteAllCookies(); //force logout otherwise can't access the reset

  //Let's get to the password reset. -broken truncates password lifetime to 0 minutes, giving us an invalid link to test
  TestEq(TRUE, testfw->browser->GotoWebPage(Substitute(wittydata.forgotpasswordlink, "wrdauthtest-router-extended", "wrdauthtest-router-broken")));

  //Submit it for our test user
  OBJECT tester := OpenFormsapiFormTester(testfw->browser);
  RECORD submitrec := CELL[ email := "testwrdauthrouter@beta.webhare.net" ];
  RECORD res := tester->SubmitForm(submitrec);
  TestEq(TRUE,res.success);

  RECORD ARRAY emails := testfw->ExtractAllMailFor("testwrdauthrouter@beta.webhare.net");
  TestEq(1,length(emails));
  TestEq(1,Length(emails[0].links));

  STRING fixedlink := Substitute(emails[0].links[0].href, "wrdauthtest-router-broken", "wrdauthtest-router-extended"); //otherwise it'll just break again
  TestEq(TRUE, testfw->browser->GotoWebPage(fixedlink));

  TestEq(TRUE, ObjectExists(testfw->browser->document->GetElement(".wh-wrdauth-linkexpired")));
  //TODO the page should offer a way to re-request the password

  //Let's get to the password set.
  INTEGEr user := testfw->wrdschema->^wrd_person->Search("WRD_CONTACT_EMAIL", "testwrdauthrouter@beta.webhare.net");
  RECORD passwordsetter := wrdplugin->CreatePasswordResetLink(wittydata.forgotpasswordlink, user, [ routerpage := "setpassword" ]);
  TestEq(TRUE, testfw->browser->GotoWebPage(passwordsetter.verifiedlink));
  TestEq(TRUE, ObjectExists(testfw->browser->document->GetElement(".wh-wrdauth-setpassword")));
}

Runtestframework( [ PTR PrepareServer
                  , PTR CreateMyTestSchema
                  , PTR TestModuleDefIPRules
                  , PTR TestPersistentLogin
                  , PTR TestCrossDomainLogin
                  , PTR TestAuditDialog
                  , PTR TestLoginDenied
                  , PTR TestPasswordValidation
                  , PTR TestSecondFactorLogin
                  , PTR TestWRDAuthRouter
                  ], [ testusers := [[ login := "mysysop", grantrights := ["system:sysop"] ]
                                    ]
                     ]);
