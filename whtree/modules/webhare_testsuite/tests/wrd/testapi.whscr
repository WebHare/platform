<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::util/otp.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/cache.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";
LOADLIB "mod::system/lib/internal/whfs/objects.whlib";

LOADLIB "mod::wrd/lib/payments.whlib";
LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/imexport.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/internal/tasks.whlib";
LOADLIB "mod::wrd/lib/internal/queries.whlib";

LOADLIB "mod::webhare_testsuite/lib/internal/rtetesthelpers.whlib";
LOADLIB "mod::webhare_testsuite/lib/internal/wrdtesthelpers.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::publisher/lib/rtd.whlib";

RECORD attrstructure := [ id := 0, attributetypename := "", attributetype := 0, base := FALSE, description := ""
                        , domain := 0
                        , isreadonly := FALSE, isrequired := FALSE, isunique := FALSE, isinherited := FALSE, isunsafetocopy := FALSE
                        , localtag := "", maxlength := 0, checklinks := FALSE, multiline := FALSE
                        , parent := 0, tag := "", title := "", isordered := FALSE, allowedvalues := DEFAULT STRING ARRAY
                        ];

MACRO TestImageFileField(OBJECT persontype, INTEGER testpersonid, BOOLEAN currently_has_file)
{
  TestEq(NOT currently_has_file, testpersonid IN persontype->RunQuery(
      [ outputcolumn := "WRD_ID"
      , filters := [ [ field := "TEST_IMAGE", matchtype := "=", value := DEFAULT RECORD ]
                   ]
      ]));
  TestEq(NOT currently_has_file, testpersonid IN persontype->RunQuery(
      [ outputcolumn := "WRD_ID"
      , filters := [ [ field := "TEST_FILE", matchtype := "=", value := DEFAULT RECORD ]
                   ]
      ]));

  TestEq(currently_has_file, testpersonid IN persontype->RunQuery(
      [ outputcolumn := "WRD_ID"
      , filters := [ [ field := "TEST_IMAGE", matchtype := "!=", value := DEFAULT RECORD ]
                   ]
      ]));
  TestEq(currently_has_file, testpersonid IN persontype->RunQuery(
      [ outputcolumn := "WRD_ID"
      , filters := [ [ field := "TEST_FILE", matchtype := "!=", value := DEFAULT RECORD ]
                   ]
      ]));
}

MACRO TestSchema()
{
  BLOB testimage_blob := GetWebhareResource("mod::system/web/tests/goudvis.png");
  RECORD testimage := WrapBlob(testimage_blob,"goudvis.png");

  OBJECT schemaobj := testfw->GetWRDSchema();
  TestEq("mod::system/lib/testframework.whlib#testframework#cleanuptests", schemaobj->creationsource);
  TestEq(TRUE, schemaobj->creationdate != DEFAULT DATETIME);
  OBJECT persontype := schemaobj->^wrd_person;

  TestThrowsLike("*requires*transaction*", PTR persontype->GetNewEntityId());
  TestEqLike('wrd:*', persontype->GetNewEntityGUID(), 'GetNewEntityGUID should work outside work');
  TestEq(TRUE, IsValidWRDGuid(persontype->GetNewEntityGUID()));
  TestEq(FALSE, IsValidWRDGuid(persontype->GetNewEntityGUID()||'a'));

  TestEq(TRUE, schemaobj->GetSchemaSetting("wrd:auth.domainsecret", [ fallback := "" ]) != "", "wrd:auth.domainsecret should be auto-set on schema generation");
  TestEq("WRD_CONTACT_EMAIL_1", persontype->GenerateUniqueAttributeTag("", "WRD Contact Email"));
  TestEq("TEST_INT", persontype->GenerateUniqueAttributeTag("", "Test int"));
  TestEq("TEST_INT_1", persontype->GenerateUniqueAttributeTag("TEST_ARRAY", "Test int"));

  testfw->BeginWork();

  INTEGER newentid := persontype->GetNewEntityId();
  TestEq(TRUE, newentid != 0, 'getnewentity should work inside work');
  OBJECT newent := persontype->CreateEntity([wrd_firstname := "test", wrd_id := newentid]);
  Testeq(newent->id, newentid, "Setting WRD_ID hwen creating should be honored");

  testfw->RollbackWork();

  testfw->BeginWork();
  TestEqLike('wrd:*', persontype->GetNewEntityGUID());

  TestThrowsLike("*wrd:testschema*exists*",PTR CreateWRDSchema(testfw->GetWRDSchema()->tag));


  TestThrowsLike("Cannot delete base*", PTR persontype->DeleteAttribute("WRD_FIRSTNAME"));
  TestThrowsLike("*empty*", PTR persontype->UpdateAttribute("WRD_CONTACT_PHONE_XX", [tag := "" ]));
  TestThrowsLike("*already exists*", PTR persontype->UpdateAttribute("WRD_CONTACT_PHONE_XX", [tag := "WRD_CONTACT_PHONE" ]));

  TestEq("WebHare testsuite test schema", schemaobj->title);
  TestEq("The webhare_testsuite WRD schema", schemaobj->description);

  //test initial init, and whether it's safe to copy
  TestEq(TRUE, persontype->GetAttribute("TEST_FREE_NOCOPY").isunsafetocopy);
  persontype->UpdateAttribute("TEST_FREE_NOCOPY", [ isunsafetocopy := FALSE ]);
  TestEq(FALSE, persontype->GetAttribute("TEST_FREE_NOCOPY").isunsafetocopy);
  persontype->UpdateAttribute("TEST_FREE_NOCOPY", [ isunsafetocopy := TRUE ]);
  TestEq(TRUE, persontype->GetAttribute("TEST_FREE_NOCOPY").isunsafetocopy);

  TestEq(TRUE, RecordExists(persontype->GetAttribute("WRD_CONTACT_PHONE")));
  persontype->DeleteAttribute("WRD_CONTACT_PHONE");
  TestEq(FALSE, RecordExists(persontype->GetAttribute("WRD_CONTACT_PHONE")));

  TestThrowsLike("No such attribute*", PTR persontype->DeleteAttribute("WRD_CONTACT_PHONE"));
  persontype->UpdateAttribute("WRD_CONTACT_PHONE_XX", [tag := "WRD_CONTACT_PHONE" ]);
  TestEq(TRUE, RecordExists(persontype->GetAttribute("WRD_CONTACT_PHONE")));
  TestEq(FALSE, RecordExists(persontype->GetAttribute("WRD_CONTACT_PHONE_XX")));

  // Test all fields
  INTEGER testpersonid := persontype->Search("WRD_CONTACT_EMAIL", "other@example.com");
  OBJECT testpersonobj := persontype->GetEntity(testpersonid);

  RECORD testpersonrec;
  testpersonrec := persontype->GetEntityFields(testpersonid, [ "*" ]);

  TestEq(domain1value1->id, testpersonrec.test_single_domain);
  TestEq("Free field", testpersonrec.test_free);
  //FIXME TestEq(addressrec, testpersonrec.test_address);
  TestEq("email@example.com", testpersonrec.test_email);
  TestEq("012-3456789", testpersonrec.test_phone);
  TestEq(MakeDate(2006, 1, 1), testpersonrec.test_date);
  // Test TEST_PASSWORD (FIXME => Create a password, test with login functions)
  TestEq(SortArray([ INTEGER(domain2value3->id) ]), SortArray(testpersonrec.test_multiple_domain));

  // Test cached query
  TestEQ(testpersonrec, persontype->GetEntityFields(testpersonid, [ "*" ], [ cachettl := 60000 ]));
  TestEQ(testpersonrec, persontype->GetEntityFields(testpersonid, [ "*" ], [ cachettl := 60000 ]));
  TestEQ(testpersonrec, persontype->GetEntity(testpersonid)->GetFields([ "*" ], [ cachettl := 60000 ]));

  // test that we can query for existince of test_image and test_file
  TestImageFileField(persontype, testpersonid, TRUE);

  TestThrowsLike("*only*DEFAULT RECORD*", PTR persontype->RunQuery(
      [ filters := [ [ field := "TEST_IMAGE", matchtype := "=", value := testimage ] ]]));
  TestThrowsLike("*only*DEFAULT RECORD*", PTR persontype->RunQuery(
      [ filters := [ [ field := "TEST_FILE", matchtype := "=", value := testimage ] ]]));

  TestEq(testimage_blob, testpersonrec.test_image.data);
  TestEq(TRUE, CellExists(testpersonrec.test_image, "IMAGEID"));
  TestEq(TRUE, CellExists(testpersonrec.test_file, "FILEID"));
  TestEq(MakeTime (15, 24, 34), testpersonrec.test_time);
  TestEq(MakeDateTime (2006, 1, 1, 15, 24, 34), testpersonrec.test_datetime);
  TestEq(150.0, testpersonrec.test_money);
  TestEq(5, testpersonrec.test_integer);
  TestEq(TRUE, testpersonrec.test_boolean);

  TestEq(TypeID(RECORD ARRAY), TypeID(testpersonrec.test_array));
  TestEq(2, Length(testpersonrec.test_array));
  TestEq(1, testpersonrec.test_array[0].test_int);
  TestEq(TRUE, CellExists(testpersonrec.test_array[0], "WRD_SETTINGID"));
  TestEq(12, testpersonrec.test_array[1].test_int);
  TestEq("Free", testpersonrec.test_array[0].test_free);
  TestEq("Willy!", testpersonrec.test_array[1].test_free);
  TestEq(0, LENGTH(testpersonrec.test_array[0].test_array2));
  TestEq(2, LENGTH(testpersonrec.test_array[1].test_array2));
  TestEq(6, testpersonrec.test_array[1].test_array2[0].test_int2);
  TestEq(10, testpersonrec.test_array[1].test_array2[1].test_int2);

  TestEq(addressrec.country, testpersonrec.test_address.country);
  TestEq(FALSE, CellExists(testpersonrec.test_address, "COUNTRY_FULL"));

  // Test GetEntityField
  FOREVERY (RECORD rec FROM UnpackRecord(testpersonrec))
  {
    TestEq(rec.value, persontype->GetEntityField(testpersonid, rec.name));
    TestEq(rec.value, persontype->GetEntityField(testpersonid, rec.name, [ cachettl := 60000 ]));
    TestEq(rec.value, persontype->GetEntityField(testpersonid, rec.name, [ cachettl := 60000 ])); // 2nd cached time
    TestEq(rec.value, persontype->GetEntity(testpersonid)->GetField(rec.name));
    TestEq(rec.value, persontype->GetEntity(testpersonid)->GetField(rec.name, [ cachettl := 60000 ]));
    VARIANT expected := GetTypeDefaultValue(TypeID(rec.value));
    IF (rec.name = "WRD_ADDRESS_FORMAL")
      expected := "Sir/Madam";
    ELSE IF (rec.name = "WRD_SALUTE_FORMAL")
      expected := "Dear Sir/Madam";
    TestEq(expected, persontype->GetEntityField(0, rec.name), rec.name);
  }

  // test historymode
  TestEq(testpersonrec.test_datetime, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "__getfields" ]));
  TestEq(testpersonrec.test_datetime, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "now" ]));
  TestEq(testpersonrec.test_datetime, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "at", when := GetCurrentDatetime() ]));
  TestEq(DEFAULT DATETIME, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "at", when := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(DEFAULT DATETIME, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "range", when_start := DEFAULT DATETIME, when_limit := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(testpersonrec.test_datetime, persontype->GetEntityField(testpersonid, "test_datetime", [ historymode := "range", when_start := MakeDate(2000, 1, 1), when_limit := GetCurrentDatetime() ]));

  TestEq(testpersonrec.test_datetime, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "__getfields" ]).test_datetime);
  TestEq(testpersonrec.test_datetime, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "now" ]).test_datetime);
  TestEq(testpersonrec.test_datetime, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "at", when := GetCurrentDatetime() ]).test_datetime);
  TestEq(DEFAULT RECORD, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "at", when := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(DEFAULT RECORD, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "range", when_start := DEFAULT DATETIME, when_limit := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(testpersonrec.test_datetime, persontype->GetEntityFields(testpersonid, [ "test_datetime" ], [ historymode := "range", when_start := MakeDate(2000, 1, 1), when_limit := GetCurrentDatetime() ]).test_datetime);

  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "__getfields" ]));
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "now" ]));
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "at", when := GetCurrentDatetime() ]));
  TestEq(DEFAULT DATETIME, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "at", when := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(DEFAULT DATETIME, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "range", when_start := DEFAULT DATETIME, when_limit := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetField("test_datetime", [ historymode := "range", when_start := MakeDate(2000, 1, 1), when_limit := GetCurrentDatetime() ]));

  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "__getfields" ]).test_datetime);
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "now" ]).test_datetime);
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "at", when := GetCurrentDatetime() ]).test_datetime);
  TestEq(DEFAULT RECORD, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "at", when := MakeDate(2000, 1, 1) ])); // entity didn't exist then
  TestEq(DEFAULT RECORD, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "range", when_start := DEFAULT DATETIME, when_limit := MakeDate(2000, 1, 1) ]));
  TestEq(testpersonrec.test_datetime, persontype->GetEntity(testpersonid)->GetFields([ "test_datetime" ], [ historymode := "range", when_start := MakeDate(2000, 1, 1), when_limit := GetCurrentDatetime() ]).test_datetime);

  //test remapping getentityfields
  testpersonrec := persontype->GetEntityFields(testpersonid, [ title := "WRD_TITLE" ]);
  TestEq("John Doe", testpersonrec.title);


  //test image wrapping GetEntityFields
  testpersonrec := persontype->GetEntityFields(testpersonid, [ bigimage  := WrapImageField("TEST_IMAGE", [ method := "fit", setwidth:=100, setheight:=100])
                                                             , thumbnail := WrapImageField("TEST_IMAGE", [ method := "fit", setwidth:=25, setheight:=25])
                                                             , title := "WRD_TITLE"
                                                             ]);

  TestEq(TRUE, CellExists(testpersonrec.bigimage,'link'));
  TestEqLike("/.uc/*", testpersonrec.bigimage.link);
  TestEq(FALSE, CellExists(testpersonrec.bigimage,'data'));
  TestEq(TRUE, CellExists(testpersonrec.bigimage,'width'));
  TestEq(TRUE, CellExists(testpersonrec.bigimage,'height'));

  schemaobj := OpenWRDSchemaById(schemaobj->id);

  TestThrowsLike("Column*#*not allowed*", PTR persontype->RunQuery( [ outputcolumns := ["test_free#wrd_limitdate"] ] ));
  TestThrowsLike("Column*.*not allowed*", PTR persontype->RunQuery( [ outputcolumns := ["test_array.test_single"] ] ));



  // Test source_fsobjects in images/files
  OBJECT destlink := OpenTestsuitesite()->OpenByPath("/testpages/imgeditfile.jpeg");
  RECORD testfile := [ data := DEFAULT BLOB
                     , mimetype := "application/msword"
                     , filename := "testfile.doc"
                     , extension := "doc"
                     ];

  testimage.source_fsobject := destlink->id;
  INSERT CELL source_fsobject := destlink->id INTO testfile;

  TestThrowsLike('Trying to update*type*', PTR schemaobj->^wrd_organization->UpdateEntity(testpersonid, [ wrd_orgname := "X" ]));
  TestThrowsLike('Trying to update non-existing entity*', PTR schemaobj->^wrd_organization->UpdateEntity(2147483647, [ wrd_orgname := "X" ]));

  persontype->GetEntity(testpersonid)->UpdateEntity([ test_image := testimage, test_file := testfile ]);

  TestEq(destlink->id, persontype->GetEntity(testpersonid)->GetField("TEST_IMAGE").source_fsobject);
  TestEq(destlink->id, persontype->GetEntity(testpersonid)->GetField("TEST_FILE").source_fsobject);

  persontype->UpdateEntity(testpersonid, [test_image := DEFAULT RECORD, test_file := DEFAULT RECORD]);

  //deleted the file, so check the opposite queries
  TestImageFileField(persontype, testpersonid, FALSE);

  testpersonobj->DeleteEntity();

  TestThrowsLike('*WRD_LIMITDATE*', PTR persontype->CreateEntity([ wrd_limitdate := DEFAULT DATETIME ]));
  TestThrowsLike('*non-UTF8*', PTR persontype->CreateEntity([ test_free := "Bad free value \xEE" ]));
  TestThrowsLike('*non-UTF8*', PTR persontype->CreateEntity([ wrd_firstname := "Bad first name \x80" ]));

  OBJECT accepted := persontype->CreateEntity([ test_free := "Bad free value \xEE, valid utf-8: \u00eb", wrd_Firstname := "Bad first name \xA4" ], [ decodeinvalidutf8as := "ISO-8859-15" ]);
  TestEq("Bad free value \u00EE, valid utf-8: \u00eb", accepted->GetField("test_free"));
  TestEq("Bad first name \u20ac", accepted->GetField("wrd_firstname"));
  accepted->DeleteEntity();

  DATETIME now := GetCurrentdatetime();
  TestThrowsLike('*WRD_LIMITDATE*', PTR persontype->CreateEntity([ wrd_creationdate := now, wrd_limitdate := AddTimeToDate(-1,now) ]));

  OBJECT tempentity := persontype->CreateEntity([ wrd_creationdate := now, wrd_limitdate := now ]);
  tempentity->DeleteEntity();

  testfw->CommitWork();

  //verify that the attribute APIs agree on the structure
  TestEqStructure( [ attrstructure ], persontype->ListAttributes(0));
  TestEqStructure(attrstructure, persontype->GetAttribute("WRD_ID"));

  TestEQ("ab", DecodeInvalidUTF8Chars("\xfe\xff\x00a\x00b", "ISO-8859-15"));
  TestEQ("\u00eea\u00eeb", DecodeInvalidUTF8Chars("\xeea\xeeb", "ISO-8859-15"));
}
MACRO ImageCache()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  STRING baseurl := OpenTestsuitesite()->webroot;

  BLOB testimage_blob := GetWebhareResource("mod::system/web/tests/goudvis.png");
  INTEGER entityid1 := wrdperson->CreateEntity([ test_image := WrapBlob(testimage_blob,"")
                                               ] )->id;
  INTEGER entityid2 := wrdperson->CreateEntity([ test_array := [ [ test_image := WrapBlob(testimage_blob,"") ], DEFAULT RECORD ]
                                               ] )->id;

  RECORD entity := wrdperson->RunQuery( [ outputcolumns := [ imageid := "TEST_IMAGE.IMAGEID", arrayimages := "TEST_ARRAY.TEST_IMAGE.IMAGEID" ]
                                        , filters := [[ field := "WRD_ID", value := entityid1 ]
                                                     ]
                                        ]);
  TestEq(TRUE, entity.imageid != 0);
  TestEQ(INTEGER[entity.imageid], wrdperson->RunQuery( [ outputcolumn := "TEST_IMAGE.IMAGEID", filters := [[ field := "WRD_ID", value := entityid1 ]] ]));

  INTEGER entityid1_imageid := entity.imageid;
  TestEq(0, Length(entity.arrayimages));

  entity := wrdperson->RunQuery( [ outputcolumns := [ imageid := "TEST_IMAGE.IMAGEID", arrayimages := "TEST_ARRAY.TEST_IMAGE.IMAGEID", test_array := "TEST_ARRAY" ]
                                 , filters := [[ field := "WRD_ID", value := entityid2 ]
                                              ]
                                 ]);

  TestEq(TRUE, entity.imageid = 0);
  TestEq(2, Length(entity.arrayimages));
  TestEq(TRUE, entity.arrayimages[0]!=0);
  TestEq(0, entity.arrayimages[1]);

  testfw->CommitWork();

  STRING legacy_imagelink := GetCachedWRDImageURL(baseurl, entityid1_imageid, [method := "none"]);
  STRING imagelink := GetCachedImageLink(wrdperson->GetEntityFields(entityid1, ["TEST_IMAGE"]).test_image, [ method := "none", baseurl := baseurl ]);
  TestEq(imagelink, Substitute(legacy_imagelink, "data.png", "noname.png"));

  RECORD wrappedinfo := GetWrappedSourceFromURL(imagelink);
  TestEq('noname.png', wrappedinfo.filename);
  TestEq(385, wrappedinfo.width);

  //Test images with a WHFS source
  testfw->BeginWork();
  BLOB toupload2 := GetWebhareResource("mod::webhare_testsuite/tests/system/testdata/homersbrain.bmp");
  OBJECT homer := GetTestsuiteTempFolder()->CreateFile( [ data := toupload2, publish := FALSE, name := "homersbrain.bmp" ]);
  wrdperson->UpdateEntity(entityid1, [ test_image := CELL[...WrapBlob(toupload2, "homersbrain.bmp"), source_fsobject := homer->id ]]);
  testfw->CommitWork();

  RECORD wrappedresized := WrapCachedImage(wrdperson->GetEntityFields(entityid1, ["TEST_IMAGE"]).test_image, [ method := "fit", setwidth := 64, setheight := 52, baseurl := GetPrimaryWebhareInterfaceURL() ]);
  TestEq(TRUE, testfw->browser->GotoWebPage(wrappedresized.link));
  TestEqMembers([width:=64, mimetype:="image/png"], ScanBlob(testfw->browser->content), "MIMEWIDTH,TYPE");
}

MACRO TestGUID()
{
  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;

  testfw->BeginWork();
  OBJECT testpersonobj2 := persontype->CreateEntity([ wrd_guid := "wrd:0123456789ABCDEF0123456789ABCDE0" ]);
  TestEq("wrd:0123456789ABCDEF0123456789ABCDE0", testpersonobj2->GetField("WRD_GUID"));

  INTEGER id := persontype->Search("WRD_GUID", "wrd:0123456789ABCDEF0123456789ABCDE0");
  TestEq(testpersonobj2->id, id, "Expected to find an entity while with GUID lookup");

  // Case sensitive lookups
  TestEq(id, persontype->Search("WRD_GUID", "wrd:0123456789ABCDEF0123456789ABCDE0"));
  TestEq(0, persontype->Search("WRD_GUID", "WRD:0123456789ABCDEF0123456789ABCDE0"));
  TestEq(0, persontype->Search("WRD_GUID", "wrd:0123456789abcdef0123456789abcde0"));

  // No value IN
  TestEq(DEFAULT RECORD ARRAY, persontype->RunQuery(
              [ outputcolumns := [ "WRD_ID" ]
              , filters := [ [ field := "WRD_GUID", matchtype := "IN", value := DEFAULT STRING ARRAY ] ]
              ]));

  TestEq(INTEGER[], persontype->RunQuery(
              [ outputcolumn := "WRD_ID"
              , filters := [ [ field := "WRD_GUID", matchtype := "IN", value := DEFAULT STRING ARRAY ] ]
              ]));

  // Single value IN
  TestEq(
      [ [ wrd_id :=   id
        , wrd_guid := "wrd:0123456789ABCDEF0123456789ABCDE0" // test value
        ]
      ], persontype->RunQuery(
              [ outputcolumns := [ "WRD_ID", "WRD_GUID" ]
              , filters := [ [ field := "WRD_GUID", matchtype := "IN", value := [ "wrd:0123456789ABCDEF0123456789ABCDE0" ] ] ]
              ]));

  // Multi-value IN
  TestEq(
      [ [ wrd_id :=   id
        ]
      ], persontype->RunQuery(
              [ outputcolumns := [ "WRD_ID" ]
              , filters := [ [ field := "WRD_GUID", matchtype := "IN", value := [ "wrd:0123456789ABCDEF0123456789ABCDE0", "wrd:00112233445566778899AABBCCDDEEFF" ] ] ]
              ]));


  testfw->RollbackWork();
}

MACRO TestTitleAttr()
{
  testfw->BeginWork();

  OBJECT schemaobj := testfw->GetWRDSchema();
  OBJECT schemaobj2 := OpenWRDSchemaById(testfw->GetWRDSchema()->id);
  OBJECT persontype := schemaobj->^wrd_person;
  TestEq(TRUE, RecordExists(persontype->GetAttribute("WRD_TITLE")));
  TestEq(TRUE, persontype->GetAttribute("WRD_TITLE").isreadonly);

  //Let's test the 'hat' cache while we're at it
  OBJECT customrelationtype := schemaobj->CreateType("CUSTOMTYPE");
  TestEq(customrelationtype, schemaobj->GetType("customtype"));
  TestEq(customrelationtype, schemaobj->^customtype);
  TestEQ(TRUE, schemaobj->^customtype->isobject);
  TestEQ(TRUE, schemaobj2->^customtype->isobject);

  INTEGER customrelationtypeid := customrelationtype->id;

  customrelationtype->DeleteSelf();
  TestEq(FALSE, ObjectExists(schemaobj->GetType("customtype")));
  TestEq(FALSE, ObjectExists(schemaobj2->GetType("customtype")));
  TestThrowsLike("No such*CUSTOMTYPE*", PTR GetMember(schemaobj, "^customtype"));
  TestThrowsLike("No such*CUSTOMTYPE*", PTR GetMember(schemaobj2, "^customtype"));

  customrelationtype := schemaobj->CreateType("CUSTOMTYPE");
  TestEQ(TRUE, schemaobj->^customtype->isobject);
  TestEQ(TRUE, schemaobj2->^customtype->isobject);
  Testeq(FALSE, schemaobj->^customtype->id = customrelationtypeid, "ID reused? cached version probably!");

  //In HEAD, we stopped doing this. Please create your own WRD_TITLE attribute and let it materialize or use a translator...
  TestEq(FALSE, RecordExists(customrelationtype->GetAttribute("WRD_TITLE")));
  customrelationtype->CreateAttribute("WRD_TITLE", "FREE");

  TestEq(TRUE, RecordExists(customrelationtype->GetAttribute("WRD_TITLE")));
  TestEq(FALSE, customrelationtype->GetAttribute("WRD_TITLE").isreadonly);

  RECORD titleinfo := DescribeWRDAttribute(customrelationtype->GetAttribute("WRD_TITLE").id);
  TestEQ("WRD_TITLE", titleinfo.attributetag);
  TestEQ("CUSTOMTYPE", titleinfo.wrdtypetag);
  TestEQ(customrelationtype->id, titleinfo.wrdtype);
  TestEQ(schemaobj->id, titleinfo.wrdschema);

  INTEGER entid := customrelationtype->CreateEntity([wrd_title:="that's my name"])->id;
  TestEq([wrd_title:="that's my name"], customrelationtype->GetEntityFields(entid, ["WRD_TITLE"]));
  TestEq("that's my name", customrelationtype->GetEntityField(entid, "WRD_TITLE"));
  TestEq(entid, customrelationtype->Search("WRD_TITLE","THAT'S MY NAME",[matchcase:=FALSE]));

  testfw->CommitWork();
}

MACRO TestHSONAttr()
{
  testfw->BeginWork();

  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;
  persontype->CreateAttribute("EXTRADATA", "RECORD");
  INTEGER extradata_attributeid := persontype->GetAttribute("EXTRADATA").id;
  TestEq("RECORD", persontype->GetAttribute("EXTRADATA").attributetypename);

  OBJECT  testperson := persontype->CreateEntity([ wrd_contact_email := "hsonattr@example.com" ]);

  TestEq([ extradata := DEFAULT RECORD ], testperson->GetFields(["extradata"]));

  TestThrowsLike("*must be of type RECORD*", PTR testperson->UpdateEntity([ extradata := 45 ])); //only records!

  testperson->UpdateEntity([ extradata := [ x := 42 ]]);
  TestEq([ extradata := [ x := 42 ] ], testperson->GetFields(["extradata"]));

  //verify that a single record exists in the database
  TestEq(1, Length(SELECT FROM wrd.entity_settings WHERE entity = testperson->id AND attribute = extradata_attributeid));

  testperson->UpdateEntity([ extradata := CELL[] ]);
  TestEq([ extradata := CELL[] ], testperson->GetFields(["extradata"]));
  testperson->UpdateEntity([ extradata := DEFAULT RECORD ]);
  TestEq([ extradata := DEFAULT RECORD ], testperson->GetFields(["extradata"]));

  //verify that it's cleared in the database
  TestEq(0, Length(SELECT FROM wrd.entity_settings WHERE entity = testperson->id AND attribute = extradata_attributeid));

  BLOB goudvis := GetWebhareResource("mod::system/web/tests/goudvis.png");
  testperson->UpdateEntity([ extradata := [ goudvis := goudvis ]]); //overlong data
  TestEq([ goudvis := goudvis ], testperson->GetField("extradata"));

  testfw->CommitWork();
}

MACRO TestEnumAttr()
{
  testfw->BeginWork();

  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;
  persontype->CreateAttribute("EXTRAENUM_SINGLE", "ENUM", [ allowedvalues := ["v2"]]);
  persontype->CreateAttribute("EXTRAENUM_MULTIPLE", "ENUMARRAY");

  INTEGER extraenum_single_attributeid := persontype->GetAttribute("EXTRAENUM_SINGLE").id;
  INTEGER extraenum_multiple_attributeid := persontype->GetAttribute("EXTRAENUM_MULTIPLE").id;
  TestEq("ENUM",  persontype->GetAttribute("EXTRAENUM_SINGLE").attributetypename);
  TestEq("ENUMARRAY", persontype->GetAttribute("EXTRAENUM_MULTIPLE").attributetypename);
  TestEq(["v2"], persontype->GetAttribute("EXTRAENUM_SINGLE").allowedvalues);
  TestEq(DEFAULT STRING ARRAY, persontype->GetAttribute("EXTRAENUM_MULTIPLE").allowedvalues);

  OBJECT testperson := persontype->CreateEntity([ wrd_contact_email := "enumattr@example.com" ]);
  TestEq([ extraenum_single := "",extraenum_multiple := DEFAULT STRING ARRAY ], testperson->GetFields(["EXTRAENUM_SINGLE","EXTRAENUM_MULTIPLE"]));

  TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([extraenum_single := "v1"]));
  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["v1","V2"]]);

  testperson->UpdateEntity([extraenum_single := "v1"]);
  TestEq([ extraenum_single := "v1" ], testperson->GetFields(["EXTRAENUM_SINGLE"]));
  testperson->UpdateEntity([extraenum_single := "V2"]);
  TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([extraenum_single := "v2"]));
  TestEq([ extraenum_single := "V2" ], testperson->GetFields(["EXTRAENUM_SINGLE"]));
  TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([extraenum_single := "v3"]));

  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["v1"]]);
  TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([extraenum_single := "V2"]), 'cannot set it even though its already set');

  //sanity checks
  TestThrowsLike("*Incorrect*type*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := [1,2] ]));
  TestThrowsLike("*Incorrect*type*", PTR persontype->UpdateAttribute("EXTRAENUM_MULTIPLE", [ allowedvalues := [1,2] ]));
  TestThrowsLike("*Empty*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := [""] ]),"Empty values should be prevented");
  TestThrowsLike("*Illegal value*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := [" A"] ]),"Trimmable values should be prevented");
  TestThrowsLike("*Duplicate*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["A","A"] ]),"Dupe values should be prevented");
  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["a","A"] ]);//case sensitive so this is okay
  TestEq(["A","a"], persontype->GetAttribute("EXTRAENUM_SINGLE").allowedvalues);

  //we restrict both tabs, spaces and glob characters so we have room to relax one of those in the future
  FOREVERY(STRING badchar FROM [' ','\t',',','/','\\'])
    TestThrowsLike("*Illegal value*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["A" || badchar || "B"] ]), `Illegal char '${badchar}' was tolerated`);
  TestThrowsLike("*Too many*", PTR persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := [RepeatText("A",2048),RepeatText("B",2048)] ]),"Total size of enums may not exceed 4096");

  //we explicitly accept the colon and dot, and glob matches
  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["a:b.c" ] ]);

  //multi enum
  persontype->UpdateAttribute("EXTRAENUM_MULTIPLE", [ allowedvalues := ["c","b","a", "x?*"] ]);
  Testeq(["a","b","c","x?*"], persontype->GetAttribute("EXTRAENUM_MULTIPLE").allowedvalues);

  TestThrowsLike("*must be of type*", PTR testperson->UpdateEntity([extraenum_multiple := "b,c,a"]));
  testperson->UpdateEntity([extraenum_multiple := ["b","c","a"]]);
  TestEq(["a","b","c"], testperson->GetField("EXTRAENUM_MULTIPLE"));
  TestThrowsLike("*duplicate*", PTR testperson->UpdateEntity([extraenum_multiple := ["a","a"]]));
  testperson->UpdateEntity([extraenum_multiple := ["a"]]);
  TestEq(["a"], testperson->GetField("EXTRAENUM_MULTIPLE"));
  testperson->UpdateEntity([extraenum_multiple := ["a","b"]]);

  TestEq(2, Length(SELECT FROM wrd.entity_settings WHERE entity = testperson->id AND attribute IN [extraenum_single_attributeid, extraenum_multiple_attributeid]));

  //query support

  //testperson's EXTRAENUM_SINGLE is still 'V2' at this point
  TestThrowsLike("*acceptable value*", PTR persontype->Search("EXTRAENUM_SINGLE", "V2"));
  TestEq(testperson->id, persontype->Search("EXTRAENUM_SINGLE", "V2", [ ignoreallowedvalues := TRUE ]));

  TestThrowsLike("*acceptable value*", PTR persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "IN", value := ["V2"] ]]]));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "IN", value := ["V2"], ignoreallowedvalues := TRUE ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", value := "" ]]])));

  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["v1","v2","v3"]]);
  testperson->UpdateEntity([extraenum_single := "v1"]);
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "IN", value := ["v1"] ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", value := ["v2","v1"] ]]])));
  TestEq(0, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", value := ["v2"] ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "IN", value := [""] ]]])));
  TestEq(3, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "IN", value := ["","v1","v2"] ]]])));

  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "!=", value := "" ]]])));
  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "!=", value := "v1" ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "LIKE", value := "" ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "LIKE", value := "v*" ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_SINGLE", matchtype := "LIKE", value := "*1" ]]])));

  // Queryies for multiple enum
  TestThrowsLike("*acceptable value*", PTR persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_MULTIPLE", matchtype := "INTERSECTS", value := ["badvalue"] ]]]));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_MULTIPLE", matchtype := "INTERSECTS", value := ["a","c"] ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRAENUM_MULTIPLE", matchtype := "CONTAINS", value := "a" ]]])));

  testperson->UpdateEntity([extraenum_single := "", extraenum_multiple := DEFAULT STRING ARRAY]);
  TestEq([ extraenum_single := "",extraenum_multiple := DEFAULT STRING ARRAY ], testperson->GetFields(["EXTRAENUM_SINGLE","EXTRAENUM_MULTIPLE"]));
  TestEq(0, Length(SELECT FROM wrd.entity_settings WHERE entity = testperson->id AND attribute IN [extraenum_single_attributeid, extraenum_multiple_attributeid]));

  //Test for glob searching
  persontype->UpdateAttribute("EXTRAENUM_SINGLE", [ allowedvalues := ["a:b.c", "x?*"] ]);

  TestThrowsLike("*acceptable value*", PTR persontype->Search("EXTRAENUM_SINGLE", "x"));
  TestEq(0, persontype->Search("EXTRAENUM_SINGLE", "x1"));
  TestThrowsLike("*acceptable value*", PTR testperson->UpdateEntity([extraenum_single := "x"]));
  TestThrowsLike("*acceptable value*", PTR testperson->UpdateEntity([extraenum_single := "X12"]));
  testperson->UpdateEntity([extraenum_single := "x12" ]);
  TestEq(testperson->id, persontype->Search("EXTRAENUM_SINGLE", "x12"));

  TestThrowsLike("*Illegal value*", PTR testperson->UpdateEntity([extraenum_multiple := ["x"]]));
  testperson->UpdateEntity([extraenum_multiple := ["x1"]]);
  TestEq(["x1"], testperson->GetField("EXTRAENUM_MULTIPLE"));

  //setting evil values inside a globmatch should STILL be prevented
  FOREVERY(STRING badchar FROM [' ','\t',',','/','\\'])
    TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([extraenum_single := "x12" || badchar]));

  testfw->RollbackWork();
}

MACRO TestStatusRecordAttr()
{
  testfw->BeginWork();

  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;
  persontype->CreateAttribute("EXTRASTATUS", "STATUSRECORD", [ allowedvalues := ["ok","error"] ]);

  //sanity checks
  TestThrowsLike("*Incorrect*type*", PTR persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := [1,2] ]));
  TestThrowsLike("*Empty*", PTR persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := [""] ]),"Empty values should be prevented");
  TestThrowsLike("*Illegal value*", PTR persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := [" A"] ]),"Trimmable values should be prevented");
  TestThrowsLike("*Duplicate*", PTR persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := ["A","A"] ]),"Dupe values should be prevented");

  TestEq("STATUSRECORD",  persontype->GetAttribute("EXTRASTATUS").attributetypename);
  TestEq(["error","ok"], persontype->GetAttribute("EXTRASTATUS").allowedvalues);

  OBJECT testperson := persontype->CreateEntity([ wrd_contact_email := "statusrecord@example.com" ]);
  TestEq(DEFAULT RECORD, testperson->GetField("EXTRASTATUS"));

  TestThrowsLike("*not*acceptable*", PTR testperson->UpdateEntity([ extrastatus := [ status := "warning" ]]));
  TestThrowsLike("*must be of type RECORD*", PTR testperson->UpdateEntity([ extrastatus := "warning" ]));
  TestThrowsLike("*tatus*must be of type*", PTR testperson->UpdateEntity([ extrastatus := [ status := ["warning","error"] ]]));
  TestThrowsLike("*tatus*must be of type*", PTR testperson->UpdateEntity([ extrastatus := [ status := [1,2] ]]));
  TestThrowsLike("Missing status*", PTR testperson->UpdateEntity([ extrastatus := [ otherdata := 42 ]]));

  persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := ["ok","warning","error"]]);
  TestEq(["error","ok","warning"], persontype->GetAttribute("EXTRASTATUS").allowedvalues);

  testperson->UpdateEntity([extrastatus := [ status := "warning", otherdata := 42 ]]);
  TestEq([ status := "warning", otherdata := 42 ], testperson->GetField("EXTRASTATUS"));
  TestThrowsLike("Status*not an acceptable*", PTR testperson->UpdateEntity([extrastatus := [ status := "", otherdata := 42 ]]));

  //Set overlong data, requiring overflow into blob space.
  STRING overflown := GeneratePassword("OVERLONG", 8192); //high-entropy data just in case someone ever gets the idea to deflate data
  testperson->UpdateEntity([extrastatus := [ status := "ok", otherdata := 42, overflow := overflown ]]);
  TestEq([ status := "ok", otherdata := 42, overflow := overflown ], testperson->GetField("EXTRASTATUS"));

  persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := ["warning","error"]]);


  //query support

  //testperson's statusrecord is still 'ok' at this point
  TestThrowsLike("*not an acceptable*", PTR persontype->Search("EXTRASTATUS", "ok"));
  TestEq(testperson->id, persontype->Search("EXTRASTATUS", "ok", [ ignoreallowedvalues := TRUE ]));

  TestThrowsLike("*not an acceptable*", PTR persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "IN", value := ["ok"] ]]]));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "IN", value := ["ok"], ignoreallowedvalues := TRUE ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", value := "" ]]])));

  persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := ["warning","ok","error"]]);
  testperson->UpdateEntity([extrastatus := [ status := "warning"]]);
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "IN", value := ["warning"] ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", value := ["warning","ok"] ]]])));
  TestEq(0, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", value := ["ok"] ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "IN", value := [""] ]]])));
  TestEq(3, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "IN", value := ["","warning","ok"] ]]])));

  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "!=", value := "" ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "!=", value := "warning" ]]])));

  TestEq(2, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "LIKE", value := "" ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "LIKE", value := "w*" ]]])));
  TestEq(1, Length(persontype->RunQuery( [ filters := [[ field := "EXTRASTATUS", matchtype := "LIKE", value := "*g" ]]])));

  //Test for glob searching
  persontype->UpdateAttribute("EXTRASTATUS", [ allowedvalues := ["warning","fail:?*"] ]);
  TestThrowsLike("*not an acceptable*", PTR persontype->Search("EXTRASTATUS", "fail:"));
  TestEq(0, persontype->Search("EXTRASTATUS", "fail:we-broke-it"));

  TestThrowsLike("*not an acceptable*", PTR testperson->UpdateEntity([extrastatus := [ status := "fail:"] ]));
  testperson->UpdateEntity([extrastatus := [ status := "fail:we-broke-it" ] ]);
  TestEq(testperson->id, persontype->Search("EXTRASTATUS", "fail:we-broke-it"));

  //Setting required should enforce there being a record
  testperson->UpdateEntity([extrastatus := DEFAULT RECORD]);
  TestEq(DEFAULT RECORD, testperson->GetField("EXTRASTATUS"));
  testperson->UpdateEntity([extrastatus := [ status := "warning"]]);
  TestEq([ status := "warning"], testperson->GetField("EXTRASTATUS"));

  persontype->UpdateAttribute("EXTRASTATUS", [ isrequired := TRUE ]);
  TestThrowsLike("*required*", PTR testperson->UpdateEntity([extrastatus := DEFAULT RECORD]));

  testfw->RollbackWork(); //FIXME commit!
}

MACRO TestAuthenticationAttrs()
{
  testfw->BeginWork();

  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;
  persontype->CreateAttribute("AUTHSETTINGS", "AUTHENTICATIONSETTINGS");

  TestEq("AUTHENTICATIONSETTINGS",  persontype->GetAttribute("AUTHSETTINGS").attributetypename);

  OBJECT testperson := persontype->CreateEntity([ wrd_contact_email := "authattrs@example.com" ]);
  TestEq(DEFAULT RECORD, testperson->GetField("AUTHSETTINGS"));

  TestThrowsLike("*must be of type RECORD*", PTR testperson->UpdateEntity( [ authsettings := "warning" ]));
  TestThrowsLike("*VERSION*", PTR testperson->UpdateEntity( [ authsettings := CELL[] ]));
  TestThrowsLike("*version 1*", PTR testperson->UpdateEntity( [ authsettings := CELL[ version := -1] ]));
  TestThrowsLike(`Expected version 1 while parsing value for attribute "AUTHSETTINGS"`, PTR testperson->UpdateEntity( [ authsettings := CELL[ version := -1 ] ]));
  TestThrowsLike(`Unexpected cell 'DOESNOTEXIST' in data while *`, PTR testperson->UpdateEntity(
      [ authsettings := [ version := 1
                        , doesnotexist := 1
                        ]
      ]));

  STRING totpurl := GetTOTPUrl("01234567891234567890", "authattrs@example.com", "webhare_testsuite");

  testperson->UpdateEntity(
      [ authsettings := [ version := 1
                        , passwords :=    [ [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            ]
                                          , [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            , validfrom :=    MakeDate(1999, 2, 2)
                                            ]
                                          , [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            , validfrom :=    MakeDate(1999, 2, 3)
                                            ]
                                          ]
                        , totp :=         [ url :=            totpurl
                                          , backupcodes :=    [ [ code := "C1" ] ]
                                          ]
                        ]
      ]);

  TestEQ(
      [ authsettings := [ version := 1
                        , passwords :=    [ [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            , validfrom :=    DEFAULT DATETIME
                                            ]
                                          , [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            , validfrom :=    MakeDate(1999, 2, 2)
                                            ]
                                          , [ passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO" // secret
                                            , validfrom :=    MakeDate(1999, 2, 3)
                                            ]
                                          ]
                        , totp :=         [ url :=            totpurl
                                          , locked :=         DEFAULT DATETIME
                                          , backupcodes :=    [ [ code := "C1", used := DEFAULT DATETIME ] ]
                                          ]
                        ]
      ], testperson->GetFields([ "authsettings" ]));

  persontype->CreateAttribute("AUTHSETTINGS_CONVERTTEST", "PASSWORD");

  RECORD ARRAY tests :=
      SELECT wrd_id :=    persontype->CreateEntity([ authsettings_converttest := orgdata ])->id
           , *
        FROM [ [ orgdata := ""
               , expect := DEFAULT RECORD
               ]
             , [ orgdata := "*"
               , expect :=  [ version := 1
                            , passwords :=  [ [ validfrom := DEFAULT DATETIME
                                              , passwordhash := "*"
                                              ]
                                            ]
                            , totp :=       DEFAULT RECORD
                            ]
               ]
             , [ orgdata := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO"
               , expect :=  [ version := 1
                            , passwords :=  [ [ validfrom := DEFAULT DATETIME
                                              , passwordhash := "WHBF:$2y$10$V0b0ckLtUivNWjT/chX1OOljYgew24zn8/ynfbUNkgZO9p7eQc2dO"
                                              ]
                                            ]
                            , totp :=       DEFAULT RECORD
                            ]
               ]
             ] AS row;

  persontype->UpdateAttribute("AUTHSETTINGS_CONVERTTEST", [ attributetypename := "AUTHENTICATIONSETTINGS" ]);

  tests := persontype->Enrich(tests, "wrd_id", [ got := "authsettings_converttest" ]);
  FOREVERY (RECORD test FROM tests)
    TestEQ(test.expect, test.got, `Convert password ${EncodeJSON(test.orgdata)}`);

  FOREVERY (RECORD rec FROM tests)
    persontype->UpdateEntity(rec.wrd_id, [ authsettings_converttest := rec.got ]);

  tests := persontype->Enrich(tests, "wrd_id", [ got2 := "authsettings_converttest" ]);
  FOREVERY (RECORD test FROM tests)
    TestEQ(test.expect, test.got2, `Identity-setting authentication settings from converted pasword`);

  persontype->UpdateAttribute("AUTHSETTINGS_CONVERTTEST", [ attributetypename := "PASSWORD" ]);
  tests := persontype->Enrich(tests, "wrd_id", [ got3 := "authsettings_converttest" ]);

  // Test if searching also works for backconverted authentication settings
  FOREVERY (RECORD test FROM tests)
  {
    TestEQ(test.orgdata, test.got3, `Back-convert authentication settings to password`);
    TestEQ(test.orgdata = "" ? INTEGER[ test.wrd_id ] : INTEGER[],
        persontype->RunQuery(
            [ outputcolumn := "wrd_id"
            , filters := [ [ field := "wrd_id", value := test.wrd_id ]
                         , [ field := "AUTHSETTINGS_CONVERTTEST", value := "" ]
                         ]
            ]));
    TestEQ(test.orgdata != "" ? INTEGER[ test.wrd_id ] : INTEGER[],
        persontype->RunQuery(
            [ outputcolumn := "wrd_id"
            , filters := [ [ field := "wrd_id", value := test.wrd_id ]
                         , [ field := "AUTHSETTINGS_CONVERTTEST", matchtype := "!=", value := "" ]
                         ]
            ]));
  }

  testfw->RollbackWork(); //FIXME commit!
}

MACRO TestGenderDomain()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;
  RECORD ARRAY genderdomain := persontype->ListDomVals("WRD_GENDER");
  TestEq(2,Length(genderdomain));

  testfw->CommitWork();
}
INTEGER FUNCTION MapOther(INTEGER outval, STRING tag, STRING inval)
{
  RETURN inval = "MY-OTHER" ? outval : 0;
}

MACRO TestDomains()
{
  testfw->BeginWork();

  OBJECT schemaobj := testfw->GetWRDSchema();
  OBJECT newdomain := schemaobj->CreateDomain("TIMEDDOMAIN");
  TestEq('', newdomain->title);

  INTEGER obsoleteid := newdomain->CreateEntity( [ wrd_tag := "DOMVAL", wrd_title := "Expired value", wrd_creationdate := MakeDate(2001,1,1), wrd_limitdate := MakeDate(2010,1,1) ])->id;
  INTEGER workingid  := newdomain->CreateEntity( [ wrd_tag := "DOMVAL", wrd_title := "Working value", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ])->id;
  INTEGER otherid    := newdomain->CreateEntity( [ wrd_tag := "OTHER",  wrd_title := "Other value" ])->id;

  TestEq(workingid, newdomain->Search("WRD_TITLE", "Working value"));
  TestEq(0, newdomain->Search("WRD_TITLE", "Expired value"));

  OBJECT persontype := schemaobj->^wrd_person;
  persontype->CreateAttribute("TIMEDVALUE",     "DOMAIN", [ title := "Timed value", domaintag := "TIMEDDOMAIN" ]);
  persontype->CreateAttribute("NONDOMAINVALUE", "DOMAIN", [ title := "Non-domain value", domaintag := "WRD_PERSON" ]);
  TestEq(2, Length(persontype->ListDomVals("TIMEDVALUE")));
  TestEq(FALSE, RecordExists(SELECT FROM persontype->ListDomVals("TIMEDVALUE") WHERE title = "Expired value"));

  TestEq("DOMVAL", persontype->GetDomValTag("TIMEDVALUE", obsoleteid));
  TestEq("DOMVAL", persontype->GetDomValTag("TIMEDVALUE", workingid));
  TestEq("Expired value", persontype->GetDomValTitle("TIMEDVALUE", obsoleteid));
  TestEq("Working value", persontype->GetDomValTitle("TIMEDVALUE", workingid));
  TestEq(["Expired value","Working value"], persontype->GetDomValTitles("TIMEDVALUE", [obsoleteid, workingid]));
  TestEq(workingid, persontype->GetDomVal("TIMEDVALUE", "DOMVAL"));
  TestEq("", persontype->GetDomValTag("TIMEDVALUE", 0));
  TestEq("", persontype->GetDomValTitle("TIMEDVALUE", 0));
  TestEq(["","DOMVAL"], persontype->GetDomValTags("TIMEDVALUE", [0,workingid]));


  // Test mismatching
  OBJECT testperson := persontype->CreateEntity([wrd_contact_email:="testmismatch@example.com", wrd_firstname := "Test", wrd_lastname := "Mismatch"]);
  TestThrowsLike("*is of*WRD_PERSON*must*TEST_DOMAIN_1*", PTR testperson->UpdateEntity( [ test_single_domain := testperson->id ]));
  // Test mismatching in arrays
  TestThrowsLike("*is of*WRD_PERSON*must*TEST_DOMAIN_1*", PTR testperson->UpdateEntity( [ test_array := [[ test_single := testperson->id ]]] ));

  testfw->CommitWork();

  // GetDomVal should also work on non-domains
  testfw->BeginWork();
  testperson->UpdateEntity([ wrd_tag := "NONDOMAINTEST" ]);
  TestEq(testperson->id, persontype->GetDomVal("NONDOMAINVALUE", "NONDOMAINTEST"));
  TestEq("NONDOMAINTEST", persontype->GetDomValTag("NONDOMAINVALUE", testperson->id));
  TestEq("Test Mismatch", persontype->GetDomValTitle("NONDOMAINVALUE", testperson->id));
  TestEq(3, Length(persontype->ListDomVals("NONDOMAINVALUE")));
  testfw->RollbackWork();

  // Domain value caches should update
  testfw->BeginWork();
  newdomain->UpdateEntity(workingid, [ wrd_title := "Working value - crispy" ]);
  TestEq("Working value - crispy", persontype->GetDomValTitle("TIMEDVALUE", workingid));
  testfw->CommitWork();
  TestEq("Working value - crispy", persontype->GetDomValTitle("TIMEDVALUE", workingid));

  // On rollback, they shouldn't keep the changes
  testfw->BeginWork();
  newdomain->UpdateEntity(workingid, [ wrd_title := "Working value - extra crispy" ]);
  TestEq("Working value - extra crispy", persontype->GetDomValTitle("TIMEDVALUE", workingid));
  testfw->RollbackWork();
  //FIXME TestEq("Working value - crispy", persontype->GetDomValTitle("TIMEDVALUE", workingid), "Domain value cache not invalidated at rollback");

  // Test domain tree
  testfw->BeginWork();
  INTEGER subotherid  := newdomain->CreateEntity( [ wrd_tag := "SUBOTHER1", wrd_leftentity := otherid, wrd_title := "Subvalue #1" ])->id;
  INTEGER subotherid2 := newdomain->CreateEntity( [ wrd_tag := "SUBOTHER2", wrd_leftentity := "MY-OTHER", wrd_title := "Subvalue #2" ], [ onmapdomvalue := PTR MapOther(otherid, #1, #2)])->id;
  INTEGER subsubotherid  := newdomain->CreateEntity( [ wrd_leftentity := subotherid ])->id;

  TestEq(INTEGER[], newdomain->GetDescendantIds(-1));
  TestEq(SortArray([subotherid,subotherid2,subsubotherid]), SortArray(newdomain->GetDescendantIds(otherid)));
  TestEq(SortArray([subsubotherid]), SortArray(newdomain->GetDescendantIds(subotherid)));

  TestEq(SortArray(SELECT AS INTEGER ARRAY wrd_id FROM newdomain->RunQuery(
                    [ outputcolumns := [ "WRD_ID" ]])), SortArray(newdomain->GetDescendantIds(0)));

  testfw->RollbackWork();

  TestTHrowsLike("*WRD_PERSON*does not link*", PTR persontype->GetDescendantIds(0));

  testfw->BeginWork();
  testperson->DeleteEntity();
  persontype->DeleteAttribute("TIMEDVALUE");
  persontype->DeleteAttribute("NONDOMAINVALUE");
  newdomain->DeleteAllEntities();
  newdomain->DeleteSelf();
  testfw->CommitWork();
}

MACRO RichDoc()
{
  testfw->BeginWork();
  OBJECT destlink  := OpenTestsuiteSite()->OpenByPath("tmp")->EnsureFile([name := "destlink"]);
  OBJECT destlink2 := OpenTestsuiteSite()->OpenByPath("tmp")->EnsureFile([name := "destlink2"]);

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;

  INTEGER testpersonid := wrdperson->CreateEntity([wrd_contact_email:="richdoc@example.com"])->id;
  OBJECT testpersonobj := wrdperson->GetEntity(testpersonid);
  TestEq(TRUE, ObjectExists(testpersonobj));

  OBJECT myrichdoc := NEW RichDocument;
  myrichdoc->ImportFromMHTML(testfw->GetModuleTestBlob("webhare_testsuite","system/testdata/b-lex.mht"));
  RECORD myrichexp := myrichdoc->ExportAsRecord();

  testpersonobj->UpdateEntity([ richie := myrichexp
                              , testinstance := [ whfstype := "http://www.webhare.net/xmlns/beta/embedblock1"
                                                , id := "TestInstance-1"
                                                , fsref := destlink->id
                                                ]
                              , testintextlink := [ internallink := destlink->id, externallink := "", append := "#bla" ]
                              ] );

  RECORD ARRAY rawsettings := SELECT * FROM wrd.entity_settings where entity = testpersonobj->id;
  INTEGER64 rawsetting_testinstance := SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINSTANCE").id;
  INTEGER64 rawsetting_testintextlink := SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINTEXTLINK").id;
  RECORD rawlink_testinstance := SELECT * FROM wrd.entity_settings_whfslink WHERE id = rawsetting_testinstance;
  RECORD rawlink_testintextlink := SELECT * FROM wrd.entity_settings_whfslink WHERE id = rawsetting_testintextlink;

  TestEq(TRUE, RecordExists(rawlink_testinstance));
  TestEq(TRUE, RecordExists(rawlink_testintextlink));
  TestEq(FALSE, rawlink_testinstance.fsobject IN GetWRDObsoleteWHFSObjects());
  TestEq(FALSE, rawlink_testintextlink.fsobject IN GetWRDObsoleteWHFSObjects());

  //ensure updating works
  testpersonobj->UpdateEntity([ testintextlink := [ internallink := destlink->id, externallink := "", append := "" ]
                              ] );
  testpersonobj->UpdateEntity([ testintextlink := [ internallink := destlink->id, externallink := "", append := "#test" ]
                              ] );

  rawsettings := SELECT * FROM wrd.entity_settings where entity = testpersonobj->id;
  TestEq(rawsetting_testintextlink, SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINTEXTLINK").id);

  testfw->CommitWork();
  RECORD org_testrec1 := wrdperson->GetEntityFields(testpersonid, ["RICHIE", "TESTINSTANCE", "TESTINTEXTLINK"]);
  RECORD testrec1 := org_testrec1;

  BLOB fragment := GetRichDocumentAsHtmlFragment(testrec1.richie);

  FOREVERY (RECORD rec FROM testrec1.richie.embedded)
    TestEQ(TRUE, CellExists(rec, "WRD_SETTINGID"));

  myrichexp.embedded := RecurseDeleteSettingIds(myrichexp.embedded, ["HASH", "LINK"]);
  testrec1.richie.embedded  := RecurseDeleteSettingIds(testrec1.richie.embedded,  ["HASH", "LINK"]);
  TestEq(myrichexp, testrec1.richie);
  TestTestInstance(testrec1.testinstance);
  TestEq(OpenTestsuiteSite()->OpenByPath("tmp/destlink")->id, testrec1.testintextlink.internallink);
  TestEq("#test", testrec1.testintextlink.append);

  RECORD ARRAY queryres := wrdperson->RunQuery( [ outputcolumns := [ "RICHIE", "TESTINSTANCE", "TESTINTEXTLINK" ]
                                                , filters := [[ field := "WRD_ID", value := testpersonid ]]
                                                ]);
  TestEq(1,Length(queryres));

  FOREVERY (RECORD rec FROM queryres[0].richie.embedded)
  {
    TestEq(TRUE, CellExists(rec, "WRD_SETTINGID"));
    TestEq(TRUE, CellExists(rec, "__BLOBSOURCE"));
  }
  queryres[0].richie.embedded := RecurseDeleteSettingIds(queryres[0].richie.embedded, ["HASH", "LINK"]);
  TestEq(myrichexp, queryres[0].richie);
  TEstTestInstance( queryres[0].testinstance);
  TestEq(OpenTestsuiteSite()->OpenByPath("tmp/destlink")->id, queryres[0].testintextlink.internallink);
  TestEq("#test", queryres[0].testintextlink.append);

  // Change only the htmltext, to make sure it's being detected
  testfw->BeginWork();
  myrichexp.htmltext := StringToBlob("!!!" || BlobToString(myrichexp.htmltext,-1));
  testpersonobj->UpdateEntity([ richie := myrichexp ] );
  RECORD org_testrec3 := wrdperson->GetEntityFields(testpersonid, ["RICHIE"]).richie;
  RECORD testrec3 := org_testrec3;
  testrec3.embedded := RecurseDeleteSettingIds(testrec3.embedded, ["HASH", "LINK"]);
  TestEq(myrichexp, testrec3);
//  TestEq(org_testrec1.embedded, org_testrec3.embedded); // Stability of image ids - not implemented.

  // Now try updating it without images
  myrichdoc->ImportFromPlainText("Hi Everybody!");
  myrichexp := myrichdoc->ExportAsRecord();
  testpersonobj->UpdateEntity([ richie := myrichexp ] );
  testrec1 := wrdperson->GetEntityFields(testpersonid, ["RICHIE"]).richie;
  TestEq(myrichexp, testrec1);

  // Again, change only the htmltext, to make sure it's being detected
  myrichexp.htmltext := StringToBlob("!!!" || BlobToString(myrichexp.htmltext,-1));
  testpersonobj->UpdateEntity([ richie := myrichexp ] );
  testrec1 := wrdperson->GetEntityFields(testpersonid, ["RICHIE"]).richie;
  TestEq(myrichexp, testrec1);

  // Let the link point to destlink2, delete it. Then reset the link to destlink
  // (was regression: could not store extlinks after delete)
  testpersonobj->UpdateEntity([ testintextlink := [ internallink := destlink2->id, externallink := "", append := "" ]
                              ] );
  OpenTestsuiteSite()->OpenByPath("tmp/destlink2")->DeleteSelf();
  testpersonobj->UpdateEntity([ testintextlink := [ internallink := destlink->id, externallink := "", append := "" ]
                              ] );
  TestEq(OpenTestsuiteSite()->OpenByPath("tmp/destlink")->id, wrdperson->GetEntity(testpersonid)->GetField("TESTINTEXTLINK").internallink);

  // Are source_fsobjects in embedded images stored?
  myrichdoc->ImportFromMHTML(testfw->GetModuleTestBlob("webhare_testsuite","system/testdata/b-lex.mht"));
  myrichexp := myrichdoc->ExportAsRecord();
  myrichexp.embedded[0].source_fsobject := destlink->id;
  testpersonobj->UpdateEntity([ richie := myrichexp ] );
  TestEq(destlink->id, testpersonobj->GetField("RICHIE").embedded[0].source_fsobject);

  // Store a richdoc with instances. This directly triggers RTD overflow to WHFS
  RECORD basertd := GetTestRTD();
  testpersonobj->UpdateEntity([ richie := basertd ] );
  basertd.instances[0].data.html := "UPDATED HTML";
  testpersonobj->UpdateEntity([ richie := basertd ] );
  TestEq("UPDATED HTML", testpersonobj->GetField("RICHIE").instances[0].data.html);

  // IDs still stable
  rawsettings := SELECT * FROM wrd.entity_settings where entity = testpersonobj->id;
  TestEq(rawsetting_testinstance, SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINSTANCE").id);
  TestEq(rawsetting_testintextlink, SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINTEXTLINK").id);

  testpersonobj->UpdateEntity([ testinstance := DEFAULT RECORD
                              , testintextlink := DEFAULT RECORD
                              ] );

  rawsettings := SELECT * FROM wrd.entity_settings where entity = testpersonobj->id;
  TestEq(0i64, SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINSTANCE").id);
  TestEq(0i64, SELECT AS INTEGER64 id FROM rawsettings WHERE attribute = wrdperson->GetAttribute("TESTINTEXTLINK").id);
  TestEq(TRUE, rawlink_testinstance.fsobject IN GetWRDObsoleteWHFSObjects(), "The instance will no longer be referred");
  TestEq(FALSE, rawlink_testintextlink.fsobject IN GetWRDObsoleteWHFSObjects(), "Linktype 2s point straight towards their object, so they'll never get on the obsolete list");

  testfw->CommitWork();
}

MACRO RichDocEmbed()
{
  testfw->BeginWork();

  OBJECT destlink := OpenTestsuitesite()->OpenByPath("tmp")->EnsureFile([name := "destlink"]);

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;

  INTEGER testpersonid := wrdperson->CreateEntity([wrd_contact_email:="richdocembedded2@example.com"])->id;
  OBJECT testpersonobj := wrdperson->GetEntity(testpersonid);

  /* Add a RTD with embedded objects */
  RECORD withembedded := wrdtest_withembedded;

  INTEGER destlinkid := OpenTestsuiteSite()->OpenByPath("tmp/destlink")->id;
  testpersonobj->UpdateEntity([ richie := withembedded
                               , testinstance := [ whfstype := "http://www.webhare.net/xmlns/beta/embedblock1"
                                                 , id := "TestInstance-1"
                                                 , fsref := destlinkid
                                                 ]
                               , testintextlink := [ internallink := destlinkid, externallink := "", append := "#jantje" ]
                               ] );
  RECORD testrec1 := wrdperson->GetEntityFields(testpersonid, ["RICHIE","TESTINSTANCE"]);
  TestRichieEmbedded(testrec1.richie);
  TestTestInstance(testrec1.testinstance);

  testfw->CommitWork();

  testfw->BeginWork();

  /* Update it with a different one. this takes a shortcut path through setwrdattribute4 which used to forget updating the whfs id */
  withembedded.instances[0].data.html := "UPDATED!";
  testpersonobj->UpdateEntity([ richie := withembedded ] );
  testrec1 := wrdperson->GetEntityFields(testpersonid, ["RICHIE"]).richie;
  TestEq("UPDATED!", testrec1.instances.data.html);
  testfw->RollbackWork();
}

MACRO TestAttributes(STRING tag)
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT typeobj := schemaobj->GetType(tag);
  TestEq(TRUE, ObjectExists(typeobj));

  RECORD ARRAY attrs := typeobj->ListAttributes(0);

  OBJECT entity := typeobj->CreateEntity(DEFAULT RECORD); //create an empty, lonely entiy

  FOREVERY (RECORD attr FROM attrs)
  {
    IF (attr.isreadonly OR attr.tag IN ["WRD_CREATIONDATE","WRD_LIMITDATE","WRD_MODIFICATIONDATE","WRD_GUID"])
      CONTINUE;
    //PRINT("Doing attribute " || attr.tag || " " || attr.attributetype || "\n");

    VARIANT data := entity->GetField(attr.tag);

    RECORD ARRAY testvalues;
    SWITCH (attr.attributetype)
    {
    CASE 2
        { testvalues :=
            [ [ value := "", valid := NOT attr.isrequired ]
            , [ value := "a", valid := TRUE ]
            , [ value := GetStringOfLength(attr.maxlength), valid := TRUE ]
            , [ value := GetStringOfLength(attr.maxlength+1), valid := FALSE ]
            ];
        }
    CASE 15
        { testvalues :=
            [ [ value := 0, valid := NOT attr.isrequired ]
            , [ value := 1, valid := TRUE ]
            , [ value := 2, valid := TRUE ]
            ];
        }
    CASE 6, 12
        { testvalues :=
            [ [ value := DEFAULT DATETIME
              , valid := NOT attr.isrequired
              ]
            , [ value := MakeDate(2006, 10, 1), valid := TRUE ]
            ];
        }
    CASE 1
        {
          IF (attr.tag = "WRD_GENDER")
            CONTINUE;

          OBJECT type := schemaobj->GetTypeById(attr.domain);
          RECORD ARRAY entities := type->RunQuery([ outputcolumns := [ id := "WRD_ID" ]
                                                  , filters := [[ field := "WRD_ID", matchtype := "!=", value := entity->id ]]
                                                  ]);

          testvalues :=
            [ [ value := 0, valid := NOT attr.isrequired ]
            , [ value := (SELECT AS INTEGER id FROM entities), valid := TRUE ]
            ];
        }
    CASE 8
        {
          OBJECT type := schemaobj->GetTypeById(attr.domain);
          RECORD ARRAY entities := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := type, outputcolumns := [ id := "WRD_ID" ] ] ] ]);

          testvalues :=
            [ [ value := DEFAULT INTEGER ARRAY, valid := NOT attr.isrequired ]
            , ...( Length(entities) >= 1 ? [[ value := [ SELECT AS INTEGER id FROM entities ], valid := TRUE ]] : RECORD[]) //only insert if at least one value
            , [ value := (SELECT AS INTEGER ARRAY id FROM entities), valid := TRUE ]
            ];
        }
    DEFAULT
        {
//          PRINT("Untestable type " || attr.attributetype || "\n");
          CONTINUE;
        }
    }

    FOREVERY (RECORD rec FROM testvalues)
    {
      IF(NOT rec.valid)
      {
        TestThrowsLike("*", PTR entity->UpdateEntity(CellInsert(DEFAULT RECORD, attr.tag, rec.value)));
        CONTINUE;
      }
      entity->UpdateEntity(CellInsert(DEFAULT RECORD, attr.tag, rec.value));

      VARIANT changeddata := entity->GetField(attr.tag);
      TestWRDAttributeValuesEqual(rec.value, changeddata);

      // See what query engine returns for current value
      RECORD entityrec := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ] ], outputcolumns := [ value := attr.tag ] ] ] ]);
      TestWRDAttributeValuesEqual(rec.value, entityrec.value);

      // See what query engine equality filtering is ok
      VARIANT different_value := testvalues[(#rec + 1) % LENGTH(testvalues)].value;
      IF(EncodeHSON(different_value) != EncodeHSON(rec.value))
      {
        entityrec := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj
                                           , historymode := "all"
                                           , filters := [ [ field := "wrd_id", value := entity->id ]
                                                        , [ field := attr.tag, value := different_value ]
                                                        ]
                                           , outputcolumns := [ id := "WRD_ID" ]
                                           ]
                                         ]
                            ]);
        TestEq(FALSE, RecordExists(entityrec));
      }

      // See what query engine equality filtering is ok
      entityrec := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ], [ field := attr.tag, value := rec.value ] ], outputcolumns := [ id := "WRD_ID" ] ] ] ]);
      TestEq([ id := entity->id ], entityrec);

      // See what query engine inequality filtering is ok
      entityrec := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ], [ field := attr.tag, match_type := "!=", value := rec.value ] ], outputcolumns := [ id := "WRD_ID" ] ] ] ]);
      TestEq(DEFAULT RECORD, entityrec);
    }

    entity->UpdateEntity(CellInsert(DEFAULT RECORD, attr.tag, data));
    VARIANT backdata := entity->GetField(attr.tag);
    TestWRDAttributeValuesEqual(data, backdata);

    // See if the query engine returns the right value
    RECORD qdata := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ] ], outputcolumns := [ value := attr.tag ] ] ] ]);
    TestWRDAttributeValuesEqual(data, qdata.value);

    // See what query engine equality filtering is ok
    qdata := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ], [ field := attr.tag, value := data ] ], outputcolumns := [ id := "WRD_ID" ] ] ] ]);
    TestEq([ id := entity->id ], qdata);

    // See what query engine inequality filtering is ok
    qdata := testfw->GetWRDSchema()->RunQuery([ sources := [ [ type := typeobj, historymode := "all", filters := [ [ field := "wrd_id", value := entity->id ], [ field := attr.tag, match_type := "!=", value := data ] ], outputcolumns := [ id := "WRD_ID" ] ] ] ]);
    TestEq(DEFAULT RECORD, qdata);
  }

  typeobj->DeleteEntity(entity->id);
  testfw->CommitWork();
}

MACRO TestDomainTagTranslation()
{
  testfw->BeginWork();

  OBJECT schemaobj:= testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;

  OBJECT test_domain := schemaobj->CreateDomain("DT_DOMAIN");
  OBJECT e_dom := test_domain->CreateEntity([ wrd_tag := "E_1"]);

  OBJECT test_nondomain := schemaobj->CreateDomain("DT_NONDOMAIN");
  OBJECT e_nondom := test_nondomain->CreateEntity([ wrd_tag := "E_3"]);

  OBJECT type_ref := schemaobj->CreateType("DR_REF");
  type_ref->CreateAttribute("SD", "DOMAIN",       [ domaintag := "DT_DOMAIN" ]);
  type_ref->CreateAttribute("MD", "DOMAINARRAY",  [ domaintag := "DT_DOMAIN" ]);
  type_ref->CreateAttribute("SND", "DOMAIN",      [ domaintag := "DT_NONDOMAIN" ]);
  type_ref->CreateAttribute("MND", "DOMAINARRAY", [ domaintag := "DT_NONDOMAIN" ]);

  TestEQ(
      [ sd :=   e_dom->id
      , md :=   [ INTEGER(e_dom->id) ]
      , snd :=  e_nondom->id
      , mnd :=  [ INTEGER(e_nondom->id) ]
      ], type_ref->CreateEntity([ sd := "E_1", md := [ "E_1" ], snd := "E_3", mnd := [ "E_3" ] ])->GetFields([ "SD", "MD", "SND", "MND" ]));

  RECORD fails := [ sd := "EFAIL1", md := [ "FAIL" ], snd := "FAIL", mnd := [ "FAIL" ] ];
  FOREVERY (RECORD rec FROM UnpackRecord(fails))
    TestThrowsLike("No such domain value*", PTR type_ref->CreateEntity(CellInsert(DEFAULT RECORD, rec.name, rec.value)));

  testfw->CommitWork();
}

MACRO TestHistoryMode()
{
  OBJECT schemaobj := testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;

  {
    testfw->BeginWork();

    OBJECT person := wrdperson->GetEntity(wrdperson->CreateEntity([ wrd_lastname := "FuturePerson", wrd_creationdate := AddDaysToDate(1,GetCurrentdatetime()) ])->id);

    RECORD ARRAY results;
    results :=  wrdperson->RunQuery([ outputcolumns := [ id := "WRD_ID" ], filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]]);
    TestEq(0, Length(results));

    results := wrdperson->RunQuery(
        [ outputcolumns := [ id := "WRD_ID" ]
        , filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]
        , historymode := "all"
        ]);
    TestEq(1, Length(results));
    testEq(person->id, results[0].id);

    TestEQ(RECORD[], wrdperson->RunQuery(
        [ outputcolumns := [ id := "WRD_ID" ]
        , filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]
        , historymode := "at"
        , when := GetCurrentDatetime()
        ]));

    TestEQ([ CELL[ person->id ] ], wrdperson->RunQuery(
        [ outputcolumns := [ id := "WRD_ID" ]
        , filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]
        , historymode := "at"
        , when := AddDaysToDate(1,GetCurrentdatetime())
        ]));

    TestEQ(RECORD[], wrdperson->RunQuery(
        [ outputcolumns := [ id := "WRD_ID" ]
        , filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]
        , historymode := "range"
        , when_start := DEFAULT DATETIME
        , when_limit := GetCurrentDatetime()
        ]));

    TestEQ([ CELL[ person->id ] ], wrdperson->RunQuery(
        [ outputcolumns := [ id := "WRD_ID" ]
        , filters := [[ field := "WRD_LASTNAME", value := "FuturePerson" ]]
        , historymode := "range"
        , when_start := GetCurrentDatetime()
        , when_limit := MAX_DATETIME
        ]));

    testfw->RollbackWork();
  }
}

MACRO TestEnrichBulk()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;

  RECORD testimage := WrapBlob(GetWebhareResource("mod::system/web/tests/goudvis.png"),"goudvis.png");

  INTEGER p2 := wrdperson->CreateEntity( [ test_email := "bulk_p2@example.com", wrd_firstname := "Person 2", test_single_domain := "TEST_DOMAINVALUE_1_2", test_image := testimage ])->id;
  INTEGER p1 := wrdperson->CreateEntity( [ test_email := "bulk_p1@example.com", wrd_firstname := "Person 1", test_single_domain := 0 ])->id;

  INTEGER p_gone := wrdperson->CreateEntity( [ test_email := "bulk_pgone@example.com", wrd_firstname := "Person Gone" ])->id;
  wrdperson->DeleteEntity(p_gone);

  RECORD ARRAY result;

  result := wrdperson->Enrich([[ getid := p1 ]
                              ,[ getid := p2 ]
                              ], "GETID"
                              , [ email := "test_email", firstname := "wrd_firstname" ]);
  TestEq( [[ getid := p1, email := "bulk_p1@example.com", firstname := "Person 1"]
          ,[ getid := p2, email := "bulk_p2@example.com", firstname := "Person 2"]
          ], result);

  result := wrdperson->Enrich([[ getid := p1 ]
                              ,[ getid := p2 ]
                              ], "GETID"
                              , [ email := "test_email", firstname := "wrd_firstname" ]
                              , [ cachettl := 60*1000 ]);
  TestEq( [[ getid := p1, email := "bulk_p1@example.com", firstname := "Person 1"]
          ,[ getid := p2, email := "bulk_p2@example.com", firstname := "Person 2"]
          ], result);

  result := wrdperson->Enrich([[ getid := p2 ]
                              ], "GETID"
                              , [ img := WrapImageField("TEST_IMAGE", [ method := "fitcanvas", setwidth:=120, setheight:=90])  ]);
  TestEqLike("/.uc/*", result[0].img.link);

  result := wrdperson->Enrich([[ getid := p1 ]
                              ,[ getid := p_gone ]
                              ,[ getid := 0 ]
                              ], "GETID"
                              , [ email := "test_email", firstname := "wrd_firstname" ]);

  TestEq( [[ getid := p1, email := "bulk_p1@example.com", firstname := "Person 1"]
          ], result);

  RECORD outputcols := [ email := "test_email", firstname := "wrd_firstname" ];
  RECORD ARRAY allitems := SELECT * FROM wrdperson->RunQuery([ outputcolumns := CellInsert(outputcols,"GETID","WRD_ID"), historymode := "all" ]) ORDER BY getid;
  RECORD ARRAY expectinner := [[ getid := p1, email := "bulk_p1@example.com", firstname := "Person 1"]
                              ,[ getid := p_gone, email := "", firstname := ""]
                              ,[ getid := 0, email := "", firstname := ""]
                              ];
  RECORD ARRAY expectinnersub := [[ getid := p1,     sub := [ email := "bulk_p1@example.com", firstname := "Person 1" ]]
                                 ,[ getid := p_gone, sub := [ email := "", firstname := "" ]]
                                 ,[ getid := 0,      sub := [ email := "", firstname := ""]]
                                 ];
  RECORD ARRAY joinwith := [[ getid := p1 ]
                           ,[ getid := p_gone ]
                           ,[ getid := 0 ]
                           ];

  //test that right outer join with missing records should not return 'wrdid:' but just ''
  result := wrdperson->Enrich(joinwith, "GETID", [ wrd_guid := "WRD_GUID"], [ rightouterjoin := TRUE ]);
  TestEq(3,Length(result));
  TestEq("",result[1].wrd_guid,'returned "wrd:" for missing refs earlier');

  result := wrdperson->Enrich(joinwith, "GETID", outputcols, [ rightouterjoin := TRUE ]);
  TestEq(expectinner, result);

  result := wrdperson->Enrich(joinwith, "GETID", [ sub := outputcols ], [ rightouterjoin := TRUE ]);
  TestEq(expectinnersub, result);

  result := wrdperson->Enrich(joinwith, "GETID", outputcols, [ rightouterjoin := TRUE, leftouterjoin := CELL[], presentfield := "ispresent" ]);

  RECORD ARRAY expectouter := (SELECT *, ispresent := getid=p1?"both":"left" FROM expectinner)
                              CONCAT
                              (SELECT getid,email,firstname,ispresent:="right" FROM allitems WHERE getid NOT IN [p1,p_gone,0]);

  TestEq(expectouter,result);

  result := wrdperson->Enrich([[ getid := 0 ]
                              ], "GETID"
                              , outputcols
                              , [ rightouterjoin := TRUE, presentfield := "present" ]);

  TestEq( [[ getid := 0, email := "", firstname := "", present := "left" ]
          ], result);

  //Using enrichment to enrich domain values
  OBJECT domvaltype := schemaobj->GetType("TEST_DOMAIN_1");
  RECORD ARRAY base := SELECT * FROM wrdperson->RunQuery([ outputcolumns := [ id := "WRD_ID", test_single_domain := "TEST_SINGLE_DOMAIN" ]
                                                         , filters := [[ field := "WRD_ID", matchtype := "IN", value := [p1, p2] ]
                                                                      ]
                                                         ]) ORDER BY id;
  result := domvaltype->Enrich(base, "TEST_SINGLE_DOMAIN", [ x := "WRD_TITLE" ]);
  TestEq(1, Length(result));
  TestEq("Domain value 1.2", result[0].x);

  result := domvaltype->Enrich(base, "TEST_SINGLE_DOMAIN", [ test_single_domain := "WRD_TITLE" ]);

  TestEq(1, Length(result));
  TestEq("Domain value 1.2", result[0].test_single_domain);

  result := domvaltype->Enrich(base, "TEST_SINGLE_DOMAIN", [ test_single_domain := "WRD_TITLE" ], [rightouterjoin := TRUE]);

  TestEq(2, Length(result));
  TestEq("Domain value 1.2", result[0].test_single_domain);
  TestEq("", result[1].test_single_domain); //should be defaulted
  //ABORT(result,'boxed');

  result := wrdperson->Enrich([ [ getid := p1, source := "list" ] ], "GETID", outputcols, [ leftouterjoin := CELL[ source := "leftouterjoin" ], presentfield := "ispresent" ]);
  TestEQ(
      [ [ getid := p1, ispresent := "both",   source := "list",           email := "bulk_p1@example.com", firstname := "Person 1" ]
      , [ getid := p2, ispresent := "right",  source := "leftouterjoin",  email := "bulk_p2@example.com", firstname := "Person 2" ]
      ], SELECT * FROM result WHERE getid IN [ p1, p2 ] ORDER BY email);

  result := wrdperson->Enrich(RECORD[], "GETID", outputcols, [ leftouterjoin := CELL[ source := "leftouterjoin" ], presentfield := "ispresent" ]);
  TestEQ(
      [ [ getid := p1, ispresent := "right",  source := "leftouterjoin",  email := "bulk_p1@example.com", firstname := "Person 1" ]
      , [ getid := p2, ispresent := "right",  source := "leftouterjoin",  email := "bulk_p2@example.com", firstname := "Person 2" ]
      ], SELECT * FROM result WHERE getid IN [ p1, p2 ] ORDER BY email);

  result := wrdperson->Enrich([ [ getid := [ p1 ], source := "list" ] ], "GETID[]", outputcols, [ leftouterjoin := CELL[ source := "leftouterjoin" ], presentfield := "ispresent" ]);
  TestEQ(2, LENGTH(result));
  TestEQ([ getid := [ [ ispresent := "both",  email := "bulk_p1@example.com", firstname := "Person 1" ] ], source := "list" ], result[0]);
  TestEQ("leftouterjoin", result[1].source);
  TestEQ([ [ ispresent := "right",  email := "bulk_p2@example.com", firstname := "Person 2" ] ], SELECT * FROM result[1].getid WHERE email != "");

  result := wrdperson->Enrich(RECORD[], "GETID[]", outputcols, [ leftouterjoin := CELL[ source := "leftouterjoin" ], presentfield := "ispresent" ]);
  TestEQ(1, LENGTH(result));
  TestEQ([ [ ispresent := "right",  email := "bulk_p1@example.com", firstname := "Person 1" ]
         , [ ispresent := "right",  email := "bulk_p2@example.com", firstname := "Person 2" ]
         ], SELECT * FROM result[0].getid WHERE email != "" ORDER BY email);

  testfw->RollbackWork();
}

MACRO TestWRDQuery()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  INTEGER personid := wrdperson->CreateEntity([ wrd_lastname := "QueryTest" ])->id;
  RECORD ARRAY results;

  OBJECT person := wrdperson->GetEntity(personid);
  TestEq(TRUE, ObjectExists(person));

  person->UpdateEntity([ wrd_contact_email := "Test123@example.com" ]);

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , name := "" //empty name shouldn't crash it, but be treated like an anonymous name
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "test123@example.com"
                                          , match_case := FALSE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  // Also test passing type by tag
  TestEq(DEFAULT RECORD ARRAY, testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson->tag
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "test123@example.com"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "Test123@example.com"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "test123@example.com"
                                          , match_case := FALSE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq(DEFAULT RECORD ARRAY, testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "test123@example.com"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "Test123@example.com"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "test*"
                                          , match_case := FALSE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq(DEFAULT RECORD ARRAY, testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "test*"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "LIKE"
                                          , value := "Test*"
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "IN"
                                          , value := [ "test123@example.com" ]
                                          , match_case := FALSE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq(DEFAULT RECORD ARRAY, testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "IN"
                                          , value := [ "test123@example.com" ]
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "IN"
                                          , value := [ "a", "Test123@example.com" ]
                                          , match_case := TRUE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n := "QueryTest" ] ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME" ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , match_type := "IN"
                                          , value := [ "a", "Test123@example.com" ]
                                          , match_case := FALSE
                                          ]
                                        ]
                          ]
                        ]
      ]));

  //test de-duplication
  INTEGER ARRAY lots_of_ids;
  FOR(INTEGER i:=0;i<2048;i:=i+1)
    INSERT personid INTO lots_of_ids AT END;

  RECORD ARRAY inquery := wrdperson->RunQUery( [ outputcolumns := [ id := "WRD_ID" ]
                                               , filters := [[ field := "WRD_ID", matchtype := "IN", value := lots_of_ids ]]
                                               ]);
  TestEq([[id := personid]], inquery);


  //test cacheable queries

  RECORD basequery := [ outputcolumns := [ id:="WRD_ID", fullname := "WRD_FULLNAME" ]
                      , filters := [[ field := "WRD_ID", value := personid ]]
                      ];
  RECORD cacheablequery := [...basequery
                           , cachettl := 15000
                           ];

  testfw->CommitWork();

  TestEq([[fullname := "QueryTest", id := personid]], wrdperson->RunQuery(basequery));
  TestEq([[fullname := "QueryTest", id := personid]], wrdperson->RunQuery(cacheablequery));

  testfw->BeginWork();
  UPDATE wrd.entities SET lastname := "Bladiebla" WHERE id = personid; //direct access cannotinvalidate our RunQuery cache
  testfw->CommitWork();

  TestEq([[fullname := "Bladiebla", id := personid]], wrdperson->RunQuery(basequery));
  TestEq([[fullname := "QueryTest", id := personid]], wrdperson->RunQuery(cacheablequery), "If we see Bladiebla, we weren't caching");

  testfw->BeginWork();
  wrdperson->UpdateEntity(personid, [ wrd_lastname := "Blobdieblob" ]);
  //TestEq([[fullname := "Blobdieblob", id := personid]], wrdperson->RunQuery(cacheablequery)); //ADDME? should we perhaps directly invalidate caches so we can see new info here?
  testfw->CommitWork();

  TestEq([[fullname := "Blobdieblob", id := personid]], wrdperson->RunQuery(basequery));
  TestEq([[fullname := "Blobdieblob", id := personid]], wrdperson->RunQuery(cacheablequery));
}

MACRO TestWRDQuery_AfterFilters()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  INTEGER personid := wrdperson->CreateEntity(
      [ wrd_lastname := "QueryTest"
      , test_integer := -1
      ])->id;

  INTEGER ARRAY results;

  results := wrdperson->FindIds([ filters := [ [ field := "TEST_INTEGER", value := [ 0, 1 ] ] ]]);
  TestEQ(FALSE, personid IN results);

  results := SELECT AS INTEGER ARRAY wrd_id FROM wrdperson->RunQuery(
      [ outputcolumns := [ "WRD_ID", "TEST_INTEGER" ]
      , filters := [ [ field := "TEST_INTEGER", match_type := "IN", value := [ -1, 0 ] ] ]
      ]);
  TestEQ(TRUE, personid IN results);

  results := SELECT AS INTEGER ARRAY wrd_id FROM wrdperson->RunQuery(
      [ outputcolumns := [ "WRD_ID", "TEST_INTEGER" ]
      , filters := [ [ field := "TEST_INTEGER", match_type := "IN", value := [ 0 ] ] ]
      ]);
  TestEQ(FALSE, personid IN results);

  testfw->CommitWork();
}

MACRO TestWRDQuery_Password()
{
  testfw->BeginWork();
  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;

  INTEGER nopwd := persontype->CreateEntity( [ wrd_contact_email := "nopwd@example.net", test_password := "" ])->id;
  INTEGER testpwd := persontype->CreateEntity( [ wrd_contact_email := "testpwd@example.net", test_password := testfw->hashedpasswords.test ])->id;
  INTEGER secretpwd := persontype->CreateEntity( [ wrd_contact_email := "secretpwd@example.net", test_password := testfw->hashedpasswords.secret ])->id;

  RECORD ARRAY results;
  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID" ]
                                   , filters := [[ field := "TEST_PASSWORD", value := "test"]]
                                   ]);
  TestEq(1, Length(results));
  TestEq(testpwd, results[0].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID" ]
                                   , filters := [[ field := "TEST_PASSWORD", value := ""]]
                                   ]);
  TestEq(1, Length(SELECT FROM results WHERE id IN [nopwd]));
  TestEq(0, Length(SELECT FROM results WHERE id IN [testpwd,secretpwd]));

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID" ]
                                   , filters := [[ field := "TEST_PASSWORD", match_type := "!=", value := ""]]
                                   ]);
  TestEq(2, Length(results));
  TestEq(1, Length(SELECT FROM results WHERE id IN [secretpwd]));
  TestEq(2, Length(SELECT FROM results WHERE id IN [testpwd,secretpwd]));

  TestEq(TRUE, persontype->GetEntity(testpwd)->VerifyPassword("TEST_PASSWORD", "test"));

  //Verify we're allowed to set XSHA passwords
  persontype->UpdateEntity(testpwd, [ test_password := `XSHA1:iKpIAloyCwAktfBHf4u8oAQFAqnCWMmOVr8fKg==`]);
  //but bogus pwds still get rejected
  TestThrowsLike("*unhashed*", PTR persontype->UpdateEntity(testpwd, [ test_password := `XSHA1:iKpIAloyCwAktfBHf4u8oAQFAqnCWMmOVr8fKg`]));

  testfw->CommitWork();
}

MACRO TestWRDQuery_ContainsAndMDEqual()
{
  testfw->BeginWork();
  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;

  //We still have  domainattr8: persontype->CreateAttribute("DOMAINARRAY", "Multiple attribute", "", "TEST_MULTIPLE_DOMAIN", domain2_obj->tag);
  // possible domain values TEST_DOMAINVALUE_2_1, TEST_DOMAINVALUE_2_2 and TEST_DOMAINVALUE_2_3
  INTEGER dval2_1 := persontype->GetDomVal("TEST_MULTIPLE_DOMAIN", "TEST_DOMAINVALUE_2_1");
  INTEGER dval2_2 := persontype->GetDomVal("TEST_MULTIPLE_DOMAIN", "TEST_DOMAINVALUE_2_2");
  INTEGER dval2_3 := persontype->GetDomVal("TEST_MULTIPLE_DOMAIN", "TEST_DOMAINVALUE_2_3");
  TestEq(TRUE, dval2_1!=0);
  TestEq(TRUE, dval2_2!=0);
  TestEq(TRUE, dval2_3!=0);
  TestEq([dval2_1, dval2_3, dval2_2], persontype->GetDomVals("TEST_MULTIPLE_DOMAIN", ["TEST_DOMAINVALUE_2_1", "TEST_DOMAINVALUE_2_3", "TEST_DOMAINVALUE_2_2" ]));

  INTEGER dval2_3_byguid := persontype->GetDomVal("TEST_MULTIPLE_DOMAIN", "wrd:00000000002030000002030000002030");
  TestEq(dval2_3, dval2_3_byguid);

  INTEGER t      := persontype->CreateEntity( [ wrd_contact_email := "t@example.net", test_multiple_domain := DEFAULT INTEGER ARRAY])->id;
  INTEGER t1     := persontype->CreateEntity( [ wrd_contact_email := "t1@example.net", test_multiple_domain := [ dval2_1,dval2_1 ]])->id;
  INTEGER t1_2   := persontype->CreateEntity( [ wrd_contact_email := "t1_2@example.net" ])->id;
  INTEGER t1_2_3 := persontype->CreateEntity( [ wrd_contact_email := "t1_2_3@example.net", test_multiple_domain := [ "wrd:00000000002010000002010000002010", "wrd:00000000002020000002020000002020", "wrd:00000000002030000002030000002030" ]])->id;

  persontype->GetEntity(t1_2)->UpdateEntity([ test_multiple_domain := [ "TEST_DOMAINVALUE_2_1", "TEST_DOMAINVALUE_2_2", "TEST_DOMAINVALUE_2_1" ] ]);

  TestEq([dval2_1],                 SortArray(persontype->GetEntity(t1)->GetField("TEST_MULTIPLE_DOMAIN")));
  TestEq([dval2_1,dval2_2],         SortArray(persontype->GetEntity(t1_2)->GetField("TEST_MULTIPLE_DOMAIN")));
  TestEq([dval2_1,dval2_2,dval2_3], SortArray(persontype->GetEntity(t1_2_3)->GetField("TEST_MULTIPLE_DOMAIN")));

  //used to throw because it didnt trust '0' with CONTAINS
  TestEq(0, Length(persontype->RunQuery( [filters := [[ field := "TEST_MULTIPLE_DOMAIN", value := 0 ]]])));

  RECORD ARRAY results;
  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "CONTAINS", value := dval2_2 ]]
                                   ]);
  results := SELECT * FROM results ORDER BY email;
  TestEq(2,Length(results));
  TestEq(t1_2,results[0].id);
  TestEq(t1_2_3,results[1].id);

  TestEQMembers([ [ id := t1_2 ], [ id := t1_2_3 ] ],
                (SELECT * FROM persontype->RunQuery([ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                                    , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "CONTAINS", value := "TEST_DOMAINVALUE_2_2" ]]
                                                    ]) ORDER BY email), "*");

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", value := dval2_3 ]]
                                   ]);
  results := SELECT * FROM results ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t1_2_3,results[0].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "CONTAINS", value := dval2_3 ]]
                                   ]);
  results := SELECT * FROM results ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t1_2_3,results[0].id);

  TestThrowsLike("*'0'*", PTR persontype->RunQuery( [ filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "INTERSECTS", value := [dval2_2,dval2_3,0] ]]]));

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "INTERSECTS", value := [dval2_2,dval2_3] ]]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;

  TestEq(2,Length(results));
  TestEq(t1_2,results[0].id);
  TestEq(t1_2_3,results[1].id);

  // Test domain tag translation
  TestEQMembers([ [ id := t1_2 ], [ id := t1_2_3 ] ],
                (SELECT * FROM persontype->RunQuery([ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                                    , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "INTERSECTS", value := [ "TEST_DOMAINVALUE_2_2", "TEST_DOMAINVALUE_2_3" ] ]]
                                                    ]) WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email), "*");

  TestEQMembers([ [ id := t1_2 ], [ id := t1_2_3 ] ],
                (SELECT * FROM persontype->RunQuery([ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                                    , filters := [ [ type := "or"
                                                                   , filters := [ [ field := "TEST_MULTIPLE_DOMAIN", matchtype := "INTERSECTS", value := [ "TEST_DOMAINVALUE_2_2", "TEST_DOMAINVALUE_2_3" ] ] ]
                                                                   ]
                                                                 ]
                                                    ]) WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email), "*");


  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "=", value := DEFAULT INTEGER ARRAY ]]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t,results[0].id);

  // it shouldn't matter whether we look for 'dval2_2, dval2_1' or 'dval2_1, dval2_2'
  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "=", value := [  dval2_2, dval2_1 ] ]
                                                ]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t1_2,results[0].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "=", value := [  dval2_1, dval2_2] ]
                                                ]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t1_2,results[0].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "!=", value := [  dval2_2, dval2_1 ] ]
                                                ]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(3,Length(results));
  TestEq(t1,results[0].id);
  TestEq(t1_2_3,results[1].id);
  TestEq(t,results[2].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "!=", value := [  dval2_1 , dval2_2] ]
                                                ]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(3,Length(results));
  TestEq(t1,results[0].id);
  TestEq(t1_2_3,results[1].id);
  TestEq(t,results[2].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "=", value := [ dval2_1 ]]]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(1,Length(results));
  TestEq(t1,results[0].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "!=", value := DEFAULT INTEGER ARRAY ]]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(3,Length(results));
  TestEq(t1,results[0].id);
  TestEq(t1_2,results[1].id);
  TestEq(t1_2_3,results[2].id);

  results := persontype->RunQuery( [ outputcolumns := [ id := "WRD_ID", email := "WRD_CONTACT_EMAIL", domvals := "TEST_MULTIPLE_DOMAIN" ]
                                   , filters := [[ field := "TEST_MULTIPLE_DOMAIN", matchtype := "!=", value := [ dval2_1 ]]]
                                   ]);
  results := SELECT * FROM results WHERE id IN [ t, t1, t1_2, t1_2_3 ] ORDER BY email;
  TestEq(3,Length(results));
  TestEq(t1_2,results[0].id);
  TestEq(t1_2_3,results[1].id);
  TestEq(t,results[2].id);

  testfw->CommitWork();
}

MACRO TestWRDQuery_DeepOutputColumns()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  OBJECT wrdrelation := schemaobj->GetType("WRD_RELATION");
  OBJECT person := wrdperson->CreateEntity([ wrd_firstname := "Deep", wrd_lastname := "Test", wrd_contact_email := "deeptest@example.com" ]);
  person->UpdateEntity([ personlink := person->guid, relationlink := person->id ]);

  TestEq(TRUE, ObjectExists(person));

  TestEq([ [ n := "Test"
           , d := [ fn:="Deep",ln:="Test",email:="deeptest@example.com"] ]
         ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , outputcolumns := [ n := "WRD_LASTNAME", d := [ fn := "WRD_FIRSTNAME", ln := "WRD_LASTNAME", email := "WRD_CONTACT_EMAIL" ] ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "deeptest@example.com"
                                          ]
                                        ]
                          ]
                        ]
      ]));

  TestEq([ [ n1 := "Test"
           , n2 := "Test"
           , d1 := [ fn:="Deep",ln:="Test",email:="deeptest@example.com"]
           , d2 := [ fn:="Deep",ln:="Test",email:="deeptest@example.com"]
           ]
         ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , name :=     "left"
                          , outputcolumns := [ n1 := "WRD_LASTNAME", d1 := [ fn := "WRD_FIRSTNAME", ln := "WRD_LASTNAME", email := "WRD_CONTACT_EMAIL" ] ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "deeptest@example.com"
                                          ]
                                        ]
                          ]
                        , [ type :=     wrdperson
                          , name :=     "right"
                          , outputcolumns := [ n2 := "WRD_LASTNAME", d2 := [ fn := "WRD_FIRSTNAME", ln := "WRD_LASTNAME", email := "WRD_CONTACT_EMAIL" ] ]
                          ]
                        ]
      , links :=        [ [ left :=     "left"
                          , right :=    "right"
                          , field :=    "PERSONLINK"
                          ]
                        ]
      ]));

  TestEq([ [ n1 := "Test"
           , rightfullname := "Deep Test"
           , d1 := [ fn:="Deep",ln:="Test",email:="deeptest@example.com"]
           ]
         ], testfw->GetWRDSchema()->RunQuery(
      [ sources :=      [ [ type :=     wrdperson
                          , name :=     "left"
                          , outputcolumns := [ n1 := "WRD_LASTNAME", d1 := [ fn := "WRD_FIRSTNAME", ln := "WRD_LASTNAME", email := "WRD_CONTACT_EMAIL" ] ]
                          , filters :=  [ [ field := "WRD_CONTACT_EMAIL"
                                          , value := "deeptest@example.com"
                                          ]
                                        ]
                          ]
                        , [ type :=     wrdrelation
                          , name :=     "right"
                          , outputcolumns := [ rightfullname := "WRD_TITLE"  ]
                          ]
                        ]
      , links :=        [ [ left :=     "left"
                          , right :=    "right"
                          , field :=    "RELATIONLINK"
                          ]
                        ]
      ]));

  testfw->CommitWork();

}

ASYNC MACRO TestMerge()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  INTEGER newpersonid := wrdperson->CreateEntity([ wrd_firstname := "New", wrd_lastname := "Test", wrd_contact_email := "newtest@example.com" ])->id;
  INTEGER deeppersonid := wrdperson->Search("wrd_contact_email","deeptest@example.com");

  schemaobj->CreateType("PERSONLINK", [ title := "Test person link", linkfrom := schemaobj->^wrd_person->id, linkto := schemaobj->^wrd_person->id ]);

  INTEGER attachmentid := schemaobj->^personattachment->CreateEntity([ wrd_leftentity := deeppersonid ])->id;
  INTEGER rightlinkid := schemaobj->^personlink->CreateEntity([ wrd_leftentity := newpersonid, wrd_rightentity := deeppersonid ])->id;

  RECORD info := wrdperson->GetEntityFields(deeppersonid, ["PERSONLINK", "RELATIONLINK", "WRD_MODIFICATIONDATE"]);
  TestEq(deeppersonid, info.personlink);
  TestEq(deeppersonid, info.relationlink);

  testfw->CommitWork();
  Sleep(2); // ensure modificationdate changes
  testfw->BeginWork();

  DATETIME beforemerge := GetCurrentDatetime();
  TestEQ(TRUE, info.wrd_modificationdate < beforemerge);

  OBJECT eventwaiter := testfw->GetAsyncEventWaiter();
  wrdperson->GetEntity(deeppersonid)->MergeEntityInto(newpersonid);

  // Check fields of the original merged entity, it is closed now, but should also be renumbered
  info := wrdperson->GetEntityFields(deeppersonid, ["PERSONLINK", "RELATIONLINK", "WRD_MODIFICATIONDATE"]);
  TestEq(newpersonid, info.personlink);
  TestEq(newpersonid, info.relationlink);
  TestEq(TRUE, info.wrd_modificationdate >= beforemerge);

  TestEQ(TRUE, schemaobj->^personattachment->GetEntityField(attachmentid, "wrd_modificationdate") >= beforemerge);
  TestEQ(newpersonid, schemaobj->^personattachment->GetEntityField(attachmentid, "wrd_leftentity"));

  TestEQ(TRUE, schemaobj->^personlink->GetEntityField(rightlinkid, "wrd_modificationdate") >= beforemerge);
  TestEQ(newpersonid, schemaobj->^personlink->GetEntityField(rightlinkid, "wrd_rightentity"));

  testfw->CommitWork();

  eventwaiter->AddEvent(
      [ mask :=     `wrd:type.${schemaobj->^wrd_person->id}.change`
      , datatest := PTR IsEventDataEqual(#1,
                        [ allinvalidated :=   FALSE
                        , created :=          INTEGER[]
                        , deleted :=          INTEGER[]
                        , updated :=          INTEGER[ deeppersonid ]
                        ])
      ]);
  eventwaiter->AddEvent(
      [ mask :=     `wrd:type.${schemaobj->^personattachment->id}.change`
      , datatest := PTR IsEventDataEqual(#1,
                        [ allinvalidated :=   FALSE
                        , created :=          INTEGER[]
                        , deleted :=          INTEGER[]
                        , updated :=          INTEGER[ attachmentid ]
                        ])
      ]);
  eventwaiter->AddEvent(
      [ mask :=     `wrd:type.${schemaobj->^personlink->id}.change`
      , datatest := PTR IsEventDataEqual(#1,
                        [ allinvalidated :=   FALSE
                        , created :=          INTEGER[]
                        , deleted :=          INTEGER[]
                        , updated :=          INTEGER[ rightlinkid ]
                        ])
      ]);

  AWAIT eventwaiter->CheckNow();
}

MACRO TestWRDQuery_Mentions_Single()
{
  testfw->BeginWork();

  /* FIXME
     test mentions 0
     */

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;
  INTEGER dom11 := wrdperson->GetDomVal("TEST_ARRAY.TEST_SINGLE", "TEST_DOMAINVALUE_1_1");
  INTEGER dom12 := wrdperson->GetDomVal("TEST_ARRAY.TEST_SINGLE", "TEST_DOMAINVALUE_1_2");
  INTEGER dom13 := wrdperson->GetDomVal("TEST_ARRAY.TEST_SINGLE", "TEST_DOMAINVALUE_1_3");

  TestEq(FALSE, dom11 = 0);
  TestEq(FALSE, dom12 = 0);
  TestEq(FALSE, dom13 = 0);

  //simple test account
  INTEGER person1id := wrdperson->CreateEntity([ wrd_firstname := "Mentions1"
                                               , wrd_lastname := "Test"
                                               , wrd_contact_email := "mentionstest1@example.com"
                                               , test_array := [[ test_single := dom11 ]
                                                               ,[ test_single := dom13 ]
                                                               ,[ test_multiple := [ dom11 ] ]
                                                               ,[ test_multiple := [ dom13 ] ]
                                                               ]
                                               ])->id;

  //one with multiple occurrences, which may only be returned once
  INTEGER person2id := wrdperson->CreateEntity([ wrd_firstname := "Mentions2"
                                               , wrd_lastname := "Test"
                                               , wrd_contact_email := "mentionstest2@example.com"
                                               , test_array := [[ test_single := dom11 ]
                                                               ,[ test_single := dom11 ]
                                                               ,[ test_single := dom11 ]
                                                               ,[ test_single := dom11 ]
                                                               ,[ test_multiple := [ dom11 ] ]
                                                               ,[ test_multiple := [ dom11 ] ]
                                                               ,[ test_multiple := [ dom11 ] ]
                                                               ,[ test_multiple := [ dom11 ] ]
                                                               ]
                                               ])->id;

  //person with only dom12
  OBJECT person3 := wrdperson->CreateEntity([ wrd_firstname := "Mentions3"
                                             , wrd_lastname := "Test"
                                             , wrd_contact_email := "mentionstest3@example.com"
                                             , wrd_creationdate := MakeDate(2014,1,1)
                                             , test_array := [[ test_single := dom12
                                                              , test_single_other := dom11  //setting this attribute to prove that MENTIONS actually looked at the proper attribute
                                                              ]
                                                             ]
                                            ]);

  //person with both
  INTEGER person4id := wrdperson->CreateEntity([ wrd_firstname := "Mentions4"
                                               , wrd_lastname := "Test"
                                               , wrd_contact_email := "mentionstest4@example.com"
                                               , test_array := [[ test_single := dom11 ]
                                                               ,[ test_single := dom12 ]
                                                               ,[ test_multiple := [ dom11, dom12 ] ]
                                                               ,[ test_multiple := [ dom11, dom12 ] ]
                                                               ]
                                               ])->id;


  TestThrowsLike("*=*not supported*",
              PTR testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "=", value := dom11 ]
                                                                ]
                                                  ]]
                                     ]));

  RECORD ARRAY result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONS", value := dom11 ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions1" ],[fn := "Mentions2" ],[fn := "Mentions4" ]], result);

  TestThrowsLike("*0*not allowed*",
      PTR testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                           , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                           , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONS", value := 0 ]
                                                         ]
                                           ]]
                             ]));

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONS", value := dom12 ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONSANY", value := [dom12] ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONSANY", value := [dom11,dom12] ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions1" ],[fn := "Mentions2" ],[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  // Bug: array elements closed will still be picked up for mentions
  OBJECT person4 := wrdperson->GetEntity(person4id);
  person4->UpdateEntity(
      [ test_array := DEFAULT RECORD ARRAY
      ]);

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                      , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                      , filters := [[ field := "TEST_ARRAY.TEST_SINGLE", matchtype := "MENTIONSANY", value := [dom12] ]
                                                   ]
                                     ]]
                       ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions3" ]], result);

  // Mentions of FREE attribute
  person3->UpdateEntity([ test_array := [ [ test_free := "1" ], [ test_free := "2" ], [ test_free := "1" ] ] ]);
  TestEQ([ [ wrd_id := person3->id ] ], wrdperson->RunQuery(
      [ outputcolumns := [ "WRD_ID" ]
      , filters := [ [ field := "TEST_ARRAY.TEST_FREE", matchtype := "MENTIONS", value := "1" ]]
      ]));

  person3->UpdateEntity([ test_array := DEFAULT RECORD ARRAY ]);
  TestEQ(DEFAULT RECORD ARRAY, wrdperson->RunQuery(
      [ outputcolumns := [ "WRD_ID" ]
      , filters := [ [ field := "TEST_ARRAY.TEST_FREE", matchtype := "MENTIONS", value := "1" ]]
      ]));

  // Search for non-existing values
  person3->UpdateEntity([ test_array := [ [ test_free := "1" ], [ test_free := "2" ] ] ]);
  TestEQ(DEFAULT RECORD ARRAY, wrdperson->RunQuery(
      [ outputcolumns := [ "WRD_ID" ]
      , filters := [ [ field := "TEST_ARRAY.TEST_FREE", matchtype := "MENTIONS", value := "3" ]]
      ]));


  /* FIXME
     test mentions 0
     */

  person3->UpdateEntity([ test_array := [[ test_multiple := [ dom12 ]
                                        ]]
                        ]);
  person4->UpdateEntity([ test_array := [[ test_multiple := [ dom11, dom12 ] ]
                                        ,[ test_multiple := [ dom11, dom12 ] ]
                                        ] ]);

  TestThrowsLike("*not*valid value*",
                           PTR wrdperson->RunQuery([ outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "=", value := dom11 ]
                                                                ]
                                                   ]));

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "MENTIONS", value := dom11 ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions1" ],[fn := "Mentions2" ],[fn := "Mentions4" ]], result);

  TestThrowsLike("*0*not allowed*", PTR testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                           , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                           , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "MENTIONS", value := 0 ]
                                                         ]
                                           ]]
                             ]));

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "MENTIONS", value := dom12 ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "MENTIONSANY", value := [dom12] ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  result := testfw->GetWRDSchema()->RunQuery([ sources := [[ type := wrdperson
                                                   , outputcolumns := [ fn := "WRD_FIRSTNAME" ]
                                                   , filters := [[ field := "TEST_ARRAY.TEST_MULTIPLE", matchtype := "MENTIONSANY", value := [dom11,dom12] ]
                                                                ]
                                                  ]]
                                     ]);
  result := SELECT * FROM result ORDER BY fn;
  TestEq([[fn := "Mentions1" ],[fn := "Mentions2" ],[fn := "Mentions3" ],[fn := "Mentions4" ]], result);

  testfw->CommitWork();
}

MACRO TestWRDQuery_ExpImp()
{
  //ADDME regression tests with predefined query XMLs
  //FIXME test queries with subrecords in outputcolumns - THESE BREAK NOW!

  OBJECT schemaobj :=  testfw->GetWRDSchema();
  RECORD query := [ sources := [[ type := "WRD_PERSON"
                                , outputcolumns := [ arrayimages := "TEST_ARRAY.TEST_IMAGE.IMAGEID" ]
                                , filters := [[ type := "NOT"
                                              , filter := [ type := "OR"
                                                          , filters := [[ field := "TEST_SINGLE_DOMAIN", domainvaluetag := "TEST_DOMAINVALUE_1_1" ]
                                                                       ]
                                                          ]
                                             ]]
                               ]]
                  ];
  RECORD ARRAY result := schemaobj->RunQuery(query);

  OBJECT domimpl := NEW XmlDOMImplementation;
  OBJECT doc := domimpl->CreateDocument("", "test", DEFAULT OBJECT);
  OBJECT queryxml := ExportWRDQueryDefinition(schemaobj, query, doc);

  RECORD retrievedquery := ImportWRDQueryDefinition(schemaobj, queryxml);
  TestEq(1, Length(retrievedquery.sources));
  TestEq(schemaobj->^wrd_person, retrievedquery.sources[0].type);
  TestEq(query.sources[0].outputcolumns, retrievedquery.sources[0].outputcolumns);
  TestEq(query.sources[0].filters, retrievedquery.sources[0].filters);
  RECORD ARRAY result2 := schemaobj->RunQuery(retrievedquery);

  TestEq(result,result2);

  //Test broken query - referring to nonexisting domain field
  STRING brokenquery := '<query xmlns="http://www.webhare.net/xmlns/wrd/query">'
  || '<sources xmlns:hs="http://www.webhare.net/xmlns/hs/xmlrecord">'
  || '<source type="WRD_PERSON" name="__source0">'
  || '<outputcolumns><outputcolumn name="ARRAYIMAGES" attribute="TEST_ARRAY" subselect="TEST_IMAGE.IMAGEID"/></outputcolumns>'
  || '<filters><filter type="not"><filter type="or"><filter field="NONEXISTING_DOMAINFIELD" value="12345"/></filter></filter></filters>'
  || '</source></sources></query>';
  TestThrowsLike("*", PTR ImportWRDQueryDefinition(schemaobj, MakeXMLDocument(StringToBlob(brokenquery))->documentelement));

  //Test broken query - referring to nonexisting type
   brokenquery := '<query xmlns="http://www.webhare.net/xmlns/wrd/query">'
  || '<sources xmlns:hs="http://www.webhare.net/xmlns/hs/xmlrecord">'
  || '<source type="BLADIEBLA" name="__source0">'
  || '<outputcolumns><outputcolumn name="ARRAYIMAGES" attribute="TEST_ARRAY" subselect="TEST_IMAGE.IMAGEID"/></outputcolumns>'
  || '<filters><filter type="not"><filter type="or"><filter field="NONEXISTING_DOMAINFIELD" value="12345"/></filter></filter></filters>'
  || '</source></sources></query>';
  TestThrowsLike("*", PTR ImportWRDQueryDefinition(schemaobj, MakeXMLDocument(StringToBlob(brokenquery))->documentelement));
}

MACRO TestRegressions()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;
  schemaobj->CreateType("CLASSIFICATION", [ title := "Classifiction", linkfrom := persontype->id ]);
  TestEQ(FALSE, schemaobj->^classification->isobject);
  TestEQ(TRUE, schemaobj->^classification->isattachment);

  OBJECT classificationtype := schemaobj->GetType("CLASSIFICATION");
  TestThrowsLike("*WRD_LEFTENTITY*required*", PTR classificationtype->CreateEntity([wrd_tag:="TEST"]));

  TestEqStructure( [ attrstructure ], classificationtype->ListAttributes(0));
  TestEqStructure(attrstructure, classificationtype->GetAttribute("WRD_LEFTENTITY"));

  //required fields should actually require
  OBJECT testrequiredtype := schemaobj->CreateType("TESTREQUIRED",[title := "Test required fields"]);
  testrequiredtype->CreateAttribute("FREEFIELD", "FREE", [isrequired := TRUE]);
  TestThrowsLike("*FREEFIELD*required*", PTR testrequiredtype->CreateEntity([wrd_tag:="TEST"]));
  TestThrowsLike("*FREEFIEL*does not exist*FREEFIELD*", PTR testrequiredtype->CreateEntity([ freefiel := ""]), "We don't want the REQUIRED error to supersede the invalid cellname error, it sets you on the wrong track when you made a typo");

  TestEq([ wrd_firstname := ""
         , wrd_contact_email := ""
         , wrd_gender := 0
         , test_multiple_domain := DEFAULT INTEGER ARRAY
         , richie := DEFAULT RECORD
         ], persontype->GetDefaultValues(["WRD_FIRSTNAME", "WRD_CONTACT_EMAIL", "WRD_GENDER", "TEST_MULTIPLE_DOMAIN","RICHIE"]));

  testfw->CommitWork();
}

MACRO TestUpdateEntityFields() //TODO cleanup? - this test is pretty much irrelevant without history
{
  testfw->BeginWork();

  DATETIME now := GetCurrentDateTime();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  OBJECT persontype := schemaobj->^wrd_person;

  persontype->CreateAttribute("UE_INT", "INTEGER");
  persontype->CreateAttribute("UE_FILE", "FILE");
  persontype->CreateAttribute("UE_ARRAY", "ARRAY");
  persontype->CreateAttribute("UE_ARRAY.UE_INT", "INTEGER");
  INTEGER testperson_1 := persontype->CreateEntity(DEFAULT RECORD)->id;
  INTEGER testperson_2 := persontype->CreateEntity([ UE_INT := 1 ])->id;
  INTEGER testperson_3 := persontype->CreateEntity(DEFAULT RECORD)->id;
  OBJECT testperson_1_obj := persontype->GetEntity(testperson_1);
  OBJECT testperson_2_obj := persontype->GetEntity(testperson_2);
  OBJECT testperson_3_obj := persontype->GetEntity(testperson_3);

  DATETIME value_2_cd := DEFAULT DATETIME;

  INTEGER ue_int_id := persontype->GetAttribute("UE_INT").id;
  INTEGER fileue_int_id := persontype->GetAttribute("UE_FILE").id;
  INTEGER arrayue_int_id := persontype->GetAttribute("UE_ARRAY").id;
  INTEGER arraysubue_int_id := persontype->GetAttribute("UE_ARRAY.UE_INT").id;
/*
  PRINT("Current contents\n" || AnyToString(
         (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id), "boxed"));
*/
  TestEq(
      [ [ entity :=         testperson_2
        , rawdata :=        "1"
        ]
      ], (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id));

  // Must do an inline update
  testperson_2_obj->UpdateEntity([ UE_INT := 2 ]);

  TestEq(
      [ [ entity :=         testperson_2
        , rawdata :=        "2"
        ]
      ], (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id
        ORDER BY entity));

  // Entire period is empty, so should add [ min-datetime to max_datetime >
  testperson_1_obj->UpdateEntity([ UE_INT := 3 ]);

  // FIXME: Should be DEFAULT DATETIME!
  DATETIME value_3_cd;// := (SELECT AS DATETIME creationdate FROM wrd.entity_settings WHERE entity = testperson_1 AND attribute = ue_int_id);

  TestEq(
      [ [ entity :=         testperson_1
        , rawdata :=        "3"
        ]
      , [ entity :=         testperson_2
        , rawdata :=        "2"
        ]
      ], (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id
        ORDER BY entity));

  // Will clear out current range: empties everything
  testperson_2_obj->UpdateEntity([ UE_INT := 0 ]);

  TestEq(
      [ [ entity :=         testperson_1
        , rawdata :=        "3"
        ]
      ], (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id
        ORDER BY entity));

  testperson_2_obj->UpdateEntity([ UE_INT := 4 ]);

  TestEq(
      [ [ entity :=         testperson_1
        , rawdata :=        "3"
        ]
      , [ entity :=         testperson_2
        , rawdata :=        "4"
        ]
      ], (SELECT entity, rawdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_1, testperson_2] AND attribute = ue_int_id
        ORDER BY entity));

  // Setting after gap, to same value (test not updating existing value)
  BLOB testblob := StringToBlob("testdata");
  BLOB testblob2 := StringToBlob("testdat2");
  testperson_3_obj->UpdateEntity([ UE_FILE := [ filename := "filename", data := testblob ] ]);

  TestEq(
      [ [ entity :=         testperson_3
        , rawdata :=        "hson:{\"f\":\"filename\",\"x\":\"gQ_y-yQqXe5CIPLLDmpRmJH7Z_L4KKbKtO-IlGM7H1A\"}"
        , blobdata :=       testblob
        ]
      ], (SELECT entity, rawdata, blobdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute = fileue_int_id
        ORDER BY entity));

  testperson_3_obj->UpdateEntity([ UE_FILE := [ filename := "filename", data := testblob2 ] ]);

  TestEq(
      [ [ entity :=         testperson_3
        , rawdata :=        "hson:{\"f\":\"filename\",\"x\":\"R5aqYSwOjcstAcPij_Icf_o-yuZluOVLMhSd9vYvh9k\"}"
        , blobdata :=       testblob2
        ]
      ], (SELECT entity, rawdata, blobdata
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute = fileue_int_id
        ORDER BY entity));

/*  PRINT("Starting array test\n");

  PRINT("Current array contents\n" || AnyToString(
         (SELECT id, entity, attribute, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]), "boxed"));
*/
  testperson_3_obj->UpdateEntity([ UE_ARRAY := [ [ UE_INT := 1 ] ] ]);
  INTEGER basesetting_1 :=
      SELECT AS INTEGER id
        FROM wrd.entity_settings
       WHERE attribute = arrayue_int_id
         AND entity = testperson_3_obj->id;
/*
  PRINT("Current array contents\n" || AnyToString(
         (SELECT id, entity, attribute, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]), "boxed"));
*/
  TestEq(
      [ [ entity :=         testperson_3
        , rawdata :=        ""
        , parentsetting :=  0
        , ordering :=       1
        ]
      , [ entity :=         testperson_3
        , rawdata :=        "1"
        , parentsetting :=  basesetting_1
        , ordering :=       0
        ]
      ], (SELECT entity, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]
        ORDER BY entity, attribute != arrayue_int_id));

  testperson_3_obj->UpdateEntity([ UE_ARRAY := [ [ UE_INT := 2 ], [ UE_INT := 3 ] ] ]);
/*
  PRINT("Current array contents\n" || AnyToString(
         (SELECT id, entity, attribute, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]), "boxed"));
*/
  INTEGER basesetting_2_1 :=
      SELECT AS INTEGER id
        FROM wrd.entity_settings
       WHERE attribute = arrayue_int_id
         AND entity = testperson_3_obj->id
         AND ordering = 1;
  INTEGER basesetting_2_2 :=
      SELECT AS INTEGER id
        FROM wrd.entity_settings
       WHERE attribute = arrayue_int_id
         AND entity = testperson_3_obj->id
         AND ordering = 2;
/*
  PRINT("Current array contents\n" || AnyToString(
         (SELECT id, entity, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]
        ORDER BY entity, parentsetting != 0, ordering, parentsetting != basesetting_2_1), "boxed"));
*/
  TestEq(
      [ [ entity :=         testperson_3
        , rawdata :=        ""
        , parentsetting :=  0
        , ordering :=       1
        ]
      , [ entity :=         testperson_3
        , rawdata :=        ""
        , parentsetting :=  0
        , ordering :=       2
        ]
      , [ entity :=         testperson_3
        , rawdata :=        "2"
        , parentsetting :=  basesetting_2_1
        , ordering :=       0
        ]
      , [ entity :=         testperson_3
        , rawdata :=        "3"
        , parentsetting :=  basesetting_2_2
        , ordering :=       0
        ]
      ], (SELECT entity, rawdata, parentsetting, ordering
            FROM wrd.entity_settings
           WHERE entity IN [ testperson_3 ] AND attribute IN [ INTEGER(arrayue_int_id), arraysubue_int_id ]
        ORDER BY entity, parentsetting != 0, ordering, parentsetting != basesetting_2_1));

  //Test array attribute
  TestThrowsLike("*'invalid'*", PTR testperson_3_obj->UpdateEntity([ test_array := [[ test_email := "invalid" ]]]));

  testfw->CommitWork();
}

MACRO TestUpdateFiltering()
{
  OBJECT myrichdoc := NEW RichDocument;
  myrichdoc->ImportFromMHTML(testfw->GetModuleTestBlob("webhare_testsuite","system/testdata/b-lex.mht"));
  RECORD myrichexp := myrichdoc->ExportAsRecord();

  BLOB testimage_blob := GetWebhareResource("mod::system/web/tests/goudvis.png");
  RECORD testimage := WrapBlob(testimage_blob,"goudvis.png", [ extractdominantcolor := TRUE ]);

  OBJECT schemaobj := testfw->GetWRDSchema();

  testfw->BeginWork();

  OBJECT rel_obj := schemaobj->CreateType("TEST_UPDATES");
  OBJECT dom_obj := schemaobj->CreateDomain("TEST_UPDATES_DOMAIN");

  rel_obj->CreateAttribute("TEST_SINGLE_DOMAIN",               "DOMAIN",            [ domain := dom_obj->id ]);
  rel_obj->CreateAttribute("TEST_MULTIPLE_DOMAIN",             "DOMAINARRAY",       [ domain := dom_obj->id ]);
  rel_obj->CreateAttribute("WRD_CONTACT_PHONE",                "TELEPHONE",         [ title := "Testphone" ]);
  rel_obj->CreateAttribute("TESTINSTANCE",                     "WHFSINSTANCE",      [ title := "Testinstance" ]);
  rel_obj->CreateAttribute("TESTINTEXTLINK",                   "WHFSINTEXTLINK",    [ title := "Testintextlink" ]);
  rel_obj->CreateAttribute("TEST_RICHDOCUMENT",                "RICHDOCUMENT",      [ title := "Rich document" ]);
  rel_obj->CreateAttribute("TEST_IMAGE",                       "IMAGE",             [ title := "Image attribute" ]);
  rel_obj->CreateAttribute("TEST_FILE",                        "FILE",              [ title := "File attribute" ]);
  rel_obj->CreateAttribute("TEST_MONEY",                       "MONEY",             [ title := "Money attribute" ]);
  rel_obj->CreateAttribute("TEST_INTEGER",                     "INTEGER",           [ title := "Integer attribute" ]);
  rel_obj->CreateAttribute("TEST_BOOLEAN",                     "BOOLEAN",           [ title := "Boolean attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY",                       "ARRAY",             [ title := "Array attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_INT",              "INTEGER",           [ title := "Array integer attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_FREE",             "FREE",              [ title := "Array free attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_ARRAY2",           "ARRAY",             [ title := "Array array attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_ARRAY2.TEST_INT2", "INTEGER",           [ title := "Array array integer attribute" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_RICHDOCUMENT",     "RICHDOCUMENT",      [ title := "Rich document" ]);
  rel_obj->CreateAttribute("TEST_ARRAY.TEST_IMAGE",            "IMAGE",             [ title := "Image attribute" ]);

  //some simple array tests thrown in
  TestThrowsLike('The parent*', PTR rel_obj->CreateAttribute("NOSUCHARRAY.TEST_F", "FILE"));
  TestThrowsLike('*must be of type ARRAY*', PTR rel_obj->CreateAttribute("TEST_FILE.TEST_F", "FILE"));

  rel_obj->CreateAttribute("TEST_ARRAY.TEST_F",                "FILE",              [ title := "File attribute" ]);
  rel_obj->UpdateAttribute("TEST_ARRAY.TEST_F", [tag := "TEST_FILE"]);
  TestEQ("TEST_FILE", rel_obj->GetAttribute("TEST_ARRAY.TEST_FILE").localtag);

  INTEGER dom_d1 := dom_obj->CreateEntity([ wrd_tag := "D1" ])->id;
  INTEGER dom_d2 := dom_obj->CreateEntity([ wrd_tag := "D2" ])->id;
  INTEGER dom_d3 := dom_obj->CreateEntity([ wrd_tag := "D3" ])->id;


  RECORD upd :=
      [ test_single_domain :=   dom_d1
      , test_multiple_domain := [ dom_d3, dom_d2, dom_d2 ]
      , testinstance :=         [ whfstype := "http://www.webhare.net/xmlns/beta/embedblock1"
                                , id := "TestInstance-1"
                                , styletitle := ""
                                ]
      , test_richdocument :=    myrichexp
      , test_file :=            testimage
      , test_image :=           testimage
      , test_money :=           2.4
      , test_integer :=         3
      , test_boolean :=         TRUE
      , test_array :=           [ [ test_int :=   5
                                  , test_free :=  "7"
                                  , test_array2 :=
                                          [ [ test_int2 := 44
                                            ]
                                          ]
                                  , test_richdocument :=  myrichexp
                                  , test_image :=         testimage
                                  , test_file :=          testimage
                                  ]
                                , [ test_int :=           0
                                  , test_free :=          ""
                                  , test_array2 :=        DEFAULT RECORD ARRAY
                                  , test_richdocument :=  DEFAULT RECORD
                                  , test_image :=         DEFAULT RECORD
                                  , test_file :=          DEFAULT RECORD
                                  ]
                                ]
      ];

  // Updates with inner default value fields omitted
  RECORD eq_upd := upd;
  eq_upd.test_array[1] := DEFAULT RECORD;
  DELETE CELL styletitle FROM eq_upd.testinstance;

  RECORD defaults;
  FOREVERY (RECORD rec FROM UnpackRecord(upd))
    defaults := CellInsert(defaults, rec.name, GetTypeDefaultValue(TypeID(rec.value)));

  OBJECT e1 := rel_obj->CreateEntity(DEFAULT RECORD);

  // From empty: everything changed
  TestEQ(upd, e1->FilterFieldUpdates(upd));
  TestEQ(eq_upd, e1->FilterFieldUpdates(eq_upd));
  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(defaults));

  // set to value: no changes anymore
  e1->UpdateEntity(upd);
  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(upd));
  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(eq_upd));
  TestEQ(defaults, e1->FilterFieldUpdates(defaults));

  // Test per single field
  FOREVERY (RECORD field FROM UnpackRecord(upd))
  {
    RECORD test := CellInsert(DEFAULT RECORD, field.name, field.value);
    RECORD total := CellUpdate(defaults, field.name, field.value);
    RECORD total_eq := CellUpdate(defaults, field.name, GetCell(eq_upd, field.name));
    RECORD default_test := CellInsert(DEFAULT RECORD, field.name, GetCell(defaults, field.name));

    e1->UpdateEntity(defaults);
    TestEQ(test, e1->FilterFieldUpdates(test));
    TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(defaults));

    e1->UpdateEntity(test);
    TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(test));
    TestEQ(default_test, e1->FilterFieldUpdates(defaults));
    TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(total));
    TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(total_eq));
  }

  // Test source_fsobject in RTD embedded data, images and files

  OBJECT destlink := OpenTestsuitesite()->OpenByPath("tmp")->EnsureFile([name := "destlink"]);
  OBJECT destlink2 := OpenTestsuitesite()->OpenByPath("tmp")->EnsureFile([name := "destlink2"]);

  RECORD ref_testimage := testimage;
  RECORD ref_myrichexp := myrichexp;

  ref_testimage.source_fsobject := destlink->id;
  ref_myrichexp.embedded[0].source_fsobject := destlink->id;

  RECORD link_org :=
      [ test_richdocument :=    upd.test_richdocument
      , test_file :=            upd.test_file
      , test_image :=           upd.test_image
      ];

  RECORD link_upd :=
      [ test_richdocument :=    ref_myrichexp
      , test_file :=            ref_testimage
      , test_image :=           ref_testimage
      ];

  e1->UpdateEntity(link_upd);

  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(link_upd));
  TestEQ(link_org, e1->FilterFieldUpdates(link_org));

  ref_testimage.source_fsobject := destlink2->id;
  ref_myrichexp.embedded[0].source_fsobject := destlink2->id;

  RECORD link2_upd :=
      [ test_richdocument :=    ref_myrichexp
      , test_file :=            ref_testimage
      , test_image :=           ref_testimage
      ];

  e1->UpdateEntity(link2_upd);

  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates(link2_upd));
  TestEQ(link_upd, e1->FilterFieldUpdates(link_upd));
  TestEQ(link_org, e1->FilterFieldUpdates(link_org));

  // Test update rtd embedded record without blobsource and settingid
  RECORD cur_rtd := e1->GetField("test_richdocument");
  DELETE CELL __blobsource, wrd_settingid FROM cur_rtd.embedded[0];
  TestEQ(DEFAULT RECORD, e1->FilterFieldUpdates([ test_richdocument := cur_rtd ]));

  testfw->RollbackWork();
}

MACRO TestStoredQuery()
{
  testfw->BeginWork();

  OBJECT schemaobj := testfw->GetWRDSchema();
  OBJECT wrdperson := schemaobj->^wrd_person;

  wrdperson->DeleteAllEntities();

  // Maak een stored query aan voor personen
  RECORD querydata := [ sources := [ [ type := schemaobj->^wrd_person
                                     , outputcolumns := [ fullname := "WRD_FULLNAME"
                                                        , email := "WRD_CONTACT_EMAIL"
                                                        ]
                                     ]
                                   ]
                      ];
  OBJECT query := schemaobj->CreateStoredQuery(0, "QUERY_PERSON", "Personenquery", "", querydata);

  // Does the query work?
  TestEQ(DEFAULT RECORD ARRAY, query->Execute());

  // Does the query remember its cached time? (initially, it did)
  Sleep(1);
  wrdperson->CreateEntity(
      [ wrd_firstname := "First"
      , wrd_lastname := "Last"
      , wrd_contact_email := "a@a.com"
      ]);
  Sleep(1);
  TestEQ(
      [ [ fullname :=   "First Last"
        , email :=      "a@a.com"
        ]
      ], query->Execute());

  testfw->RollbackWork();
}

MACRO TestDeletion()
{
  testfw->BeginWork();
  INTEGER saveid := testfw->GetWRDSchema()->id;
  testfw->GetWRDSchema()->DeleteSelf();
  TestEq(DEFAULT OBJECT, OpenWRDSchemaById(saveid));
  testfw->RollbackWork();

  TestEq(DEFAULT OBJECT, OpenWRDSchema(""));
}

MACRO TestWHFSMapper()
{
  testfw->BeginWork();

  OBJECT destlink := OpenTestsuitesite()->OpenByPath("/testpages/imgeditfile.jpeg");

  OBJECT myrichdoc := NEW RichDocument;
  myrichdoc->ImportFromMHTML(testfw->GetModuleTestBlob("webhare_testsuite","system/testdata/b-lex.mht"));

  RECORD myrichexp := myrichdoc->ExportAsRecord();
  myrichexp.embedded[0].source_fsobject := destlink->id;

  RECORD myimage := myrichexp.embedded[0];

  OBJECT whfsmapper := NEW WHFSResourceNameMapper;

  OBJECT entity_person := testfw->GetWRDSchema()->^wrd_person->CreateEntity(
      [ testintextlink :=
            [ internallink :=   destlink->id
            , externallink :=   ""
            , append :=         ""
            ]
      , richie :=           myrichexp
      , test_image :=       myimage
      , test_file :=        myimage
      , testinstance := [ whfstype := "http://www.webhare.net/xmlns/beta/embedblock1"
                        , id := "TestInstance-1"
                        , fsref := destlink->id
                        ]
      ]);

  RECORD rec := testfw->GetWRDSchema()->^wrd_person->RunQuery(CELL
      [ outputcolumns := [ "testintextlink", "richie", "test_image", "test_file", "testinstance" ]
      , filters := [ [ field := "wrd_id", value := entity_person->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec.test_file.source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec.test_image.source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec.testintextlink.internallink);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec.richie.embedded[0].source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec.testinstance.fsref);

  entity_person->UpdateEntity(rec, CELL[ whfsmapper ]);

  RECORD rec2 := testfw->GetWRDSchema()->^wrd_person->RunQuery(CELL
      [ outputcolumns := [ "testintextlink", "richie", "test_image", "test_file", "testinstance" ]
      , filters := [ [ field := "wrd_id", value := entity_person->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2.test_file.source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2.test_image.source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2.testintextlink.internallink);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2.richie.embedded[0].source_fsobject);
  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2.testinstance.fsref);

  // Test unmapping images with incomplete info
  rec.test_image := CellDelete(rec.test_image, "hash");
  entity_person->UpdateEntity(rec, CELL[ whfsmapper ]);

  RECORD rec2_1 := testfw->GetWRDSchema()->^wrd_person->RunQuery(CELL
      [ outputcolumns := [ "testintextlink", "richie", "test_image", "test_file", "testinstance" ]
      , filters := [ [ field := "wrd_id", value := entity_person->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec2_1.test_image.source_fsobject);

  myrichexp.instances :=
      [ [ instanceid := "instanceid-01234"
        , data :=
            [ whfstype := "http://www.webhare.net/xmlns/beta/embedblock1"
            , id := "TestInstance-1"
            , fsref := destlink->id
            ]
        ]
      ];

  // test richdocument stored in whfs too
  entity_person->UpdateEntity([ richie := myrichexp ]);
  RECORD rec3 := entity_person->GetFields([ "richie" ]);
  TestEQ(destlink->id, rec3.richie.instances[0].data.fsref);

  rec3 := testfw->GetWRDSchema()->^wrd_person->RunQuery(CELL
      [ outputcolumns := [ "richie" ]
      , filters := [ [ field := "wrd_id", value := entity_person->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ('site::WebHare testsuite site/testpages/imgeditfile.jpeg', rec3.richie.instances[0].data.fsref);
  entity_person->UpdateEntity(rec3, CELL[ whfsmapper := whfsmapper ]);
  rec3 := entity_person->GetFields([ "richie" ]);
  TestEQ(destlink->id, rec3.richie.instances[0].data.fsref);

  // test payment method
  RECORD keypair := testfw->GenerateKeyPair("payments");
  OBJECT entity_paymentmethod := testfw->wrdschema->^payprov->CreateEntity(
    [ wrd_title := "TestMethod"
    , method := MakePaymentProviderValue("wrd:test", [ keypair := keypair.id, requirekeypair := TRUE ])
    ]);

  RECORD pmrec := testfw->GetWRDSchema()->^payprov->RunQuery(CELL
      [ outputcolumns := [ "method" ]
      , filters := [ [ field := "wrd_id", value := entity_paymentmethod->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ("whfs::" || OpenWHFSObject(keypair.id)->whfspath, pmrec.method.__paymentprovider.meta.keypair);

  entity_paymentmethod->UpdateEntity(pmrec, CELL[ whfsmapper ]);

  RECORD pmrec2 := testfw->GetWRDSchema()->^payprov->RunQuery(CELL
      [ outputcolumns := [ "method" ]
      , filters := [ [ field := "wrd_id", value := entity_paymentmethod->id ]
                   ]
      , whfsmapper
      ]);

  TestEQ("whfs::" || OpenWHFSObject(keypair.id)->whfspath, pmrec2.method.__paymentprovider.meta.keypair);

  // Store a richdoc with instances. This directly triggers RTD overflow to WHFS
  RECORD basertd := GetTestRTD();
  entity_person->UpdateEntity([ richie := basertd ], CELL[ whfsmapper ] );
  basertd.instances[0].data.html := "UPDATED HTML";
  entity_person->UpdateEntity([ richie := basertd ], CELL[ whfsmapper ] );
  TestEq("UPDATED HTML", entity_person->GetField("RICHIE").instances[0].data.html);

  testfw->RollbackWork();
}

BOOLEAN FUNCTION IsEventDataEqual(RECORD a, RECORD b)
{
  RETURN EncodeHSON(a) = EncodeHSON(b);
}

ASYNC MACRO TestEvents()
{
  OBJECT entity;

  {
    OBJECT eventwaiter := testfw->GetAsyncEventWaiter();

    testfw->BeginWork();
    entity := testfw->GetWRDSchema()->^wrd_person->CreateEntity(CELL[]);
    testfw->CommitWork();

    eventwaiter->AddEvent(
        [ mask :=     `wrd:type.${testfw->GetWRDSchema()->^wrd_person->id}.change`
        , datatest := PTR IsEventDataEqual(#1,
                          [ allinvalidated :=   FALSE
                          , created :=          INTEGER[ entity->id ]
                          , deleted :=          INTEGER[]
                          , updated :=          INTEGER[]
                          ])
        ]);

    AWAIT eventwaiter->CheckNow();
  }

  {
    OBJECT eventwaiter := testfw->GetAsyncEventWaiter();

    testfw->BeginWork();
    entity->UpdateEntity(CELL[ wrd_firstname := "john" ]);
    testfw->CommitWork();

    eventwaiter->AddEvent(
        [ mask :=     `wrd:type.${testfw->GetWRDSchema()->^wrd_person->id}.change`
        , datatest := PTR IsEventDataEqual(#1,
                          [ allinvalidated :=   FALSE
                          , created :=          INTEGER[]
                          , deleted :=          INTEGER[]
                          , updated :=          INTEGER[ entity->id ]
                          ])
        ]);

    AWAIT eventwaiter->CheckNow();
  }

  {
    // entity delete
    OBJECT eventwaiter := testfw->GetAsyncEventWaiter();

    testfw->BeginWork();
    entity->DeleteEntity();
    testfw->CommitWork();

    eventwaiter->AddEvent(
        [ mask :=     `wrd:type.${testfw->GetWRDSchema()->^wrd_person->id}.change`
        , datatest := PTR IsEventDataEqual(#1,
                          [ allinvalidated :=   FALSE
                          , created :=          INTEGER[]
                          , deleted :=          INTEGER[ entity->id ]
                          , updated :=          INTEGER[]
                          ])
        ]);

    AWAIT eventwaiter->CheckNow();
  }

  {
    // entity delete via type
    OBJECT eventwaiter := testfw->GetAsyncEventWaiter();

    testfw->BeginWork();
    entity := testfw->GetWRDSchema()->^wrd_person->CreateEntity(CELL[]);
    testfw->GetWRDSchema()->^wrd_person->DeleteEntity(entity->id);
    testfw->CommitWork();

    eventwaiter->AddEvent(
        [ mask :=     `wrd:type.${testfw->GetWRDSchema()->^wrd_person->id}.change`
        , datatest := PTR IsEventDataEqual(#1,
                          [ allinvalidated :=   FALSE
                          , created :=          INTEGER[ entity->id ]
                          , deleted :=          INTEGER[ entity->id ]
                          , updated :=          INTEGER[]
                          ])
        ]);

    AWAIT eventwaiter->CheckNow();
  }
}

MACRO TestTemporary() //one of the last tests so as much tests as possible are exposed to temporary
{
  RECORD ARRAY queryresult;
  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;

  //Verify the temporary
  RECORD rawtemporary := SELECT * FROM wrd.entities WHERE type = persontype->id AND creationdate = MAX_DATETIME;
  TestEq(MAX_DATETIME, persontype->GetEntityField(rawtemporary.id, "WRD_CREATIONDATE"));

  //A query for 'all' should not find the temporary
  queryresult := persontype->RunQuery([outputcolumns := CELL["WRD_CONTACT_EMAIL"], historymode := "now" ]);
  TestEq(FALSE, RecordExists(SELECT FROM queryresult WHERE wrd_contact_email = "temp@beta.webhare.net")); //temporary should be invisible to queries

  queryresult := persontype->RunQuery([outputcolumns := CELL["WRD_CONTACT_EMAIL"], historymode := "range", when_start := DEFAULT DATETIME, when_limit := MAX_DATETIME ]);
  TestEq(FALSE, RecordExists(SELECT FROM queryresult WHERE wrd_contact_email = "temp@beta.webhare.net")); //temporary should be invisible to queries

  queryresult := persontype->RunQuery([outputcolumns := CELL["WRD_CONTACT_EMAIL"], historymode := "at", when := MAX_DATETIME ]);
  TestEq(FALSE, RecordExists(SELECT FROM queryresult WHERE wrd_contact_email = "temp@beta.webhare.net")); //temporary should be invisible to queries

  queryresult := persontype->RunQuery([outputcolumns := CELL["WRD_CONTACT_EMAIL"], historymode := "all" ]);
  TestEq(FALSE, RecordExists(SELECT FROM queryresult WHERE wrd_contact_email = "temp@beta.webhare.net")); //temporary should be invisible to queries

  testfw->BeginWork();

  CleanupAllWRDTemporaries();
  TestEq(TRUE, RecordExists(SELECT FROM wrd.entities WHERE id=rawtemporary.id));

  UPDATE wrd.entities SET limitdate := AddTimeToDate(-1,GetCurrentDatetime()) WHERE id = rawtemporary.id; //set its expirationdate to now
  CleanupAllWRDTemporaries();

  TestEq(FALSE, RecordExists(SELECT FROM wrd.entities WHERE id=rawtemporary.id));
  testfw->CommitWork();

  // Test the full temporary API
  testfw->BeginWork();

  persontype->CreateAttribute("REQUIRED_ATTR", "FREE", [ isrequired := TRUE ]);

  //not setting required_attr should be fine as long as we're a temporary
  OBJECT tempentity := persontype->CreateEntity(CELL[], [ temp := TRUE ]);
  tempentity->UpdateEntity( [ wrd_contact_email := "temp2@beta.webhare.net" ]);

  // Enrich should not work onl temporaries with default historymode
  TestEQ(DEFAULT RECORD ARRAY, persontype->Enrich([ [ wrd_id := tempentity->id ] ], "wrd_id", CELL[ "wrd_contact_email" ]));
  TestEQ([ [ wrd_id := tempentity->id, wrd_contact_email := "temp2@beta.webhare.net" ] ], persontype->Enrich([ [ wrd_id := tempentity->id ] ], "wrd_id", CELL[ "wrd_contact_email" ], [ historymode := "__getfields" ]));

  //but as we try to make it non-temp, it should fail!
  TestThrowsLike("*REQUIRED_ATTR*required*", PTR tempentity->UpdateEntity([ wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ]));

  //make it non temp while fixing the required field
  tempentity->UpdateEntity([ required_attr := "NowFilled", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ]);
  TestEq( [ wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ], tempentity->Getfields(["WRD_CREATIONDATE","WRD_LIMITDATE"]));

  queryresult := persontype->RunQuery([outputcolumns := CELL["WRD_CONTACT_EMAIL"] ]);
  TestEq(TRUE, RecordExists(SELECT FROM queryresult WHERE wrd_contact_email = "temp2@beta.webhare.net")); //temporary should be invisible to queries
  INTEGER personid := tempentity->id;

  //test with links
  OBJECT personorglink := testfw->GetWRDSchema()->^personorglink;
  INTEGER testorg := testfw->GetWRDSchema()->^wrd_organization->Search("WRD_ORGNAME", "The Org");
  tempentity := personorglink->CreateEntity(CELL[], [ temp := TRUE ]);

  //should be safe to update without setting required links field
  tempentity->UpdateEntity([text := "Still a temp"]);

  //bring the links to live
  TestThrowsLike("*WRD_LEFTENTITY*required", PTR tempentity->UpdateEntity([ wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ]));
  tempentity->UpdateEntity(CELL[ wrd_leftentity := personid, wrd_rightentity := testorg, wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MAX_DATETIME ]);
  TestEq(testorg, personorglink->GetEntityField(tempentity->id,"WRD_RIGHTENTITY"));

  persontype->DeleteAttribute("REQUIRED_ATTR");

  testfw->CommitWork();
}

MACRO TestQueryParameters()
{
  OBJECT wrdschema := testfw->GetWRDSchema();

  testfw->BeginWork();
  OBJECT testdomval := wrdschema->^test_domain_1->CreateEntity([ wrd_tag := "PARAMETERTEST_2" ]);
  OBJECT testdomval2 := wrdschema->^test_domain_1->CreateEntity([ wrd_tag := "PARAMETERTEST_3", wrd_leftentity := "PARAMETERTEST_2" ]);
  OBJECT testperson := wrdschema->^wrd_person->CreateEntity([ wrd_contact_email := "paramtest@example.com", wrd_tag := "PARAMETERTEST_1", test_single_domain := testdomval->id ]);

  // Test normal parameter
  OBJECT query := MakeWRDQuery(
      [ sources :=    [ [ type := wrdschema->^wrd_person
                        , outputcolumns := CELL[ "wrd_contact_email" ]
                        , filters := [ [ field := "wrd_tag", value_p := "param1" ] ]
                        ]
                      ]
      ]);
  TestEQ([ [ wrd_contact_email := "paramtest@example.com" ] ], query->Execute([ param1 := "PARAMETERTEST_1" ]));

  // Test domain value parameter
  query := MakeWRDQuery(
      [ sources :=    [ [ type := wrdschema->^wrd_person
                        , outputcolumns := CELL[ "wrd_contact_email" ]
                        , filters := [ [ field := "test_single_domain", value_p := "param1" ] ]
                        ]
                      ]
      ]);
  TestEQ([ [ wrd_contact_email := "paramtest@example.com" ] ], query->Execute([ param1 := "PARAMETERTEST_2" ]));

  // Test domain value parameter
  query := MakeWRDQuery(
      [ sources :=    [ [ type := wrdschema->^test_domain_1
                        , outputcolumns := CELL[ "wrd_tag" ]
                        , filters := [ [ field := "wrd_leftentity", value_p := "param1" ] ]
                        ]
                      ]
      ]);
  TestEQ([ [ wrd_tag := "PARAMETERTEST_3" ] ], query->Execute([ param1 := "PARAMETERTEST_2" ]));

  testfw->RollbackWork();
}


RunTestframework([ PTR CreateWRDTestSchema
                 , PTR TestSchema
                 , PTR TestAuthenticationAttrs

                 , PTR TestTitleAttr
                 , PTR TestHSONAttr
                 , PTR TestEnumAttr
                 , PTR TestStatusRecordAttr
                 , PTR TestGenderDomain
                 , PTR TestDomains
                 , PTR TestGUID
                 , PTR ImageCache
                 , PTR RichDoc
                 , PTR RichDocEmbed
                 , PTR TestAttributes("WRD_PERSON")
                 , PTR TestAttributes("WRD_ORGANIZATION")
                 , PTR TestAttributes("TEST_DOMAIN_1")
                 , PTR TestDomainTagTranslation
                 , PTR TestHistoryMode

                 , PTR TestEnrichBulk
                 , PTR TestWRDQuery
                 , PTR TestWRDQuery_AfterFilters
                 , PTR TestWRDQuery_Password
                 , PTR TestWRDQuery_ContainsAndMDEqual
                 , PTR TestWRDQuery_Mentions_Single
                 , PTR TestWRDQuery_DeepOutputColumns
                 , PTR TestMerge
                 , PTR TestWRDQuery_ExpImp
                 , PTR TestRegressions
                 , PTR TestUpdateEntityFields
                 , PTR TestUpdateFiltering
                 , PTR TestDeletion
                 , PTR TestWHFSMapper
                 , PTR TestEvents
                 , PTR TestTemporary
                 , PTR TestQueryParameters
                 //, PTR TestStoredQuery  - not sure if we're bringing back storedqueries
                 ], [ wrdauth := FALSE ]);
