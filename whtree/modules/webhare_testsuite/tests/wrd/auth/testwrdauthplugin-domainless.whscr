<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::publisher/lib/testframework.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::tollium/lib/testframework.whlib";
LOADLIB "mod::wrd/lib/auth.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/dialogs.whlib";

LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";

LOADLIB "mod::webhare_testsuite/lib/system/webserver.whlib";
LOADLIB "mod::webhare_testsuite/lib/internal/testsite.whlib";


/*******************************************************************************
 *
 * Test WRD authentication using the webdesign plugin API
 */
//ADDME: Using the plugin seems to always make the login persistent

STRING baseurl;
RECORD thirdpartytest;
STRING thirdpartybaseurl;
STRING thirdpartyurl;
STRING testportalurl;
INTEGER entityid;

RECORD FUNCTION DoReq(RECORD vars, BOOLEAN thirdparty DEFAULTSTO FALSE)
{
  STRING url := UpdateURLVariables(thirdparty ? thirdpartyurl : baseurl, vars);
  IF(NOT testfw->browser->GotoWebPage(url) OR testfw->browser->contenttype!="application/json")
  {
    SendBlobTo(0,testfw->browser->content);
    Abort("get failure on " || testfw->browser->url);
  }
  RETURN DecodeJSONBlob(testfw->browser->content);
}

MACRO InvalidateWebhareLoginSession()
{
  //Invalidate the sessionid stored in the webhare login cookie. invalidating sessions may be tricky, but just randomizing the sessionid will have the same effect
  TestEq(TRUE, testfw->browser->GetCookie("webharelogin-wrd-testschema") != "");
  testfw->browser->SetSessionCookie("webharelogin-wrd-testschema", GenerateUFS128BitId() || " " || Tokenize(testfw->browser->GetCookie("webharelogin-wrd-testschema"),' ')[1]);
}

MACRO InvalidateExternalLoginSessions()
{
  //Find the _e cookie
  STRING e_cookiename := SELECT AS STRING name FROM testfw->browser->GetAllCookies() WHERE name LIKE 'webharelogin*_e';
  //change the sessionid, simulating a lost _e session
  TestEq(TRUE, e_cookiename != "", "Cannot locate the webhare external access cookie");
  testfw->browser->SetSessionCookie(e_cookiename, "V_DFv-saZMPa5TyZ7Wi2Gg " || Tokenize(testfw->browser->GetCookie(e_cookiename),' ')[1]);
}


MACRO PrepareServer() {
  RECORD testport := testfw->GetLocalhostWebinterface();
  thirdpartytest  := testfw->CreateWebserverPort([ virtualhosts := ["localhost.beta.webhare.net"]]); //note: localhost.webhare.com maps to 127.0.0.1

  testfw->BeginWork();

  baseurl := testport.baseurl || "wrd/authtest/webhare_testsuite.shtml?";
  testportalurl := UnpackURL(OpenTestsuiteSite()->webroot).origin || "/wrd/authtest/webhare_testsuite.shtml?";
  thirdpartybaseurl := thirdpartytest.webservers[0].url || "wrd/authtest/";
  thirdpartyurl := thirdpartybaseurl || "webhare_testsuite.shtml?";

  INSERT INTO system.access(webserver, path, matchtype, hostingsrc, hostingpath)
         VALUES(testport.webserverid, "/wrd/authtest/webhare_testsuite.shtml", 0/*exact*/, 3/*exact file*/, GetModuleInstallationRoot("webhare_testsuite") || "web/tests/wrd/authdebug.shtml");

  INSERT INTO system.access(webserver,path,matchtype,hostingsrc,hostingpath)
              VALUES(thirdpartytest.webservers[0].id,"/",1,6,"webhare_testsuite:securityheaders");
  INSERT INTO system.access(webserver,path,matchtype,hostingsrc,hostingpath)
              VALUES(thirdpartytest.webservers[0].id,"/",1,6,"webhare_testsuite:thirdpartytest");

  INTEGER extusersid := MakeAutonumber(system.access,"ID");
  INSERT INTO system.access(id,webserver,path,matchtype,authtype,authrequirement,authlist, hostingsrc, hostingpath)
              VALUES(extusersid,thirdpartytest.webservers[0].id,"/wrd/authtest/extusers/",1,1,TRUE,TRUE,3,GetModuleInstallationRoot("webhare_testsuite") || "web/tests/");
  INSERT INTO system.access_externalusers(accessid,username,userpassword)
              VALUES(extusersid,"testwrdauthplugin-username","testwrdauthplugin-password");

  testfw->CommitWork();

  testfw->RefreshWebserverConfig();
}

MACRO CreateMyTestSchema()
{
  RECORD result;

  testfw->BeginWork();

  OBJECT schemaobj := testfw->GetWRDSchema();
  TestEq(TRUE, ObjectExists(schemaobj));

  OBJECT persontype := testfw->GetWRDSchema()->^wrd_person;
  persontype->CreateAttribute("LASTLOGIN",  "DATETIME");
//  persontype->CreateAttribute("EMAIL", "Email address", "", "WRD_CONTACT_EMAIL", "");
//  persontype->CreateAttribute("PASSWORD", "Password", "", "PASSWORD", "");

//  OBJECT domain := CreateWRDAuthDomain(persontype, "TESTDOMAIN", "WRD_CONTACT_EMAIL", "PASSWORD");

  OBJECT entity := persontype->CreateEntity(
      [ wrd_contact_email := "testaccount@beta.webhare.net"
      , whuser_password := CreateAuthenticationSettingsFromPasswordHash("PLAIN:secret")
      , whuser_unit := testfw->testunit
      , wrdauth_account_status := [ status := "active" ]
      ]);

  entityid := entity->id;

  testfw->CommitWork();

  //ADDME some sort of automatic backing off/delays/even captcha? to prevent excessive login attempts ?
  DATETIME starttest := GetCurrentDatetime();
  result := DoReq( [ action := "login", username := "testaccount@test.invali", pwd := "wrongpassword", browsertriplet := "mac-chrome-01" ]);
  TestEq(FALSE, result.success);
  TestEq("INCORRECTPASSWORD", result.code); //we will no longer differentiate between UNKNOWNLOGIN and INCORRECTPASSWORD as the TS API can't currently do that
  TestAuditEvent(
      [ entity := 0
      , type := "platform:login-failed"
      , ip := "127.0.0.1"
      , login := "testaccount@test.invali"
      , impersonated := FALSE
      , impersonator_entity := 0
      , impersonator_login := "" //compared to HS we'll stop setting these to the entity if there was no impersonation at all
      , data := [ code := "unknown-account" ]
      , browsertriplet := "mac-chrome-01"
      ]);

  RECORD ARRAY events := ReadJSONLogLines("system:audit", starttest);
  TestEqMembers( [[ wrdschema := "wrd:testschema", type := "platform:login-failed" ]], events,"*");

  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "wrongpassword", browsertriplet := "mac-chrome-01"]);
  TestEq(FALSE, result.success);
  TestEq("INCORRECTPASSWORD", result.code);
  TestEq("", testfw->browser->GetCookie("webharelogin-wrd-testschema"));
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login-failed"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , data := [ code := "incorrect-email-password" ]
      , browsertriplet := "mac-chrome-01"
      ]);

  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  TestEq("PLAIN:secret", entity->GetField("whuser_password").passwords[0].passwordhash);
  TestEq(FALSE, IsWebHarePasswordHashStillSecure(entity->GetField("whuser_password").passwords[0].passwordhash));

  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-01"]);
  TestEq(TRUE, result.success);
  TestEq(TRUE, IsWebHarePasswordHashStillSecure(entity->GetField("whuser_password").passwords[0].passwordhash));
  TestEqLike("WHBF:*", entity->GetField("whuser_password").passwords[0].passwordhash);
  TestEq(1,length(entity->GetField("whuser_password").passwords));

  RECORD logincookie := SELECT * FROM testfw->browser->GetAllCookies() WHERE name LIKE "*webharelogin-wrd-testschema" AND data != "";
  TEstEq(TRUE, RecordExists(logincookie), "Verifies automatic cookiename ((Host-|Secure-|)webharelogin-<slug>)");

  RECORD loginevent := TestAuditEvent(
      [ entity := entityid
      , type := "platform:login"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , impersonated := FALSE
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);

  result := DoReq( [ action := "checkstatus" ]);
  TestEq(TRUE, result.isloggedin);
  TestEq("testaccount@beta.webhare.net", result.loginname);
  TestEq(entity->id, result.entityid);

  //regression test. issue #5989, early use of GetLoggedinEntity() or GetLoginName() causes a re-login
  result := DoReq( [ action := "logout-checkstatus" ]);
  TestEq(TRUE, result.oldstatus.isloggedin);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  TestAuditEvent(
      [ entity := entityid
      , type := "platform:logout"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , impersonated := FALSE
      , impersonator_entity := 0
      , impersonator_login := "" //compared to HS we'll stop setting these to the entity if there was no impersonation at all
      , data := loginevent.data
      , browsertriplet := "other-unknown-0"
      , byentity := 0
      , bylogin := "" //compared to HS we'll stop setting these to the entity if there was no external actor at all
      ]);

  DATETIME logginginat := GetCurrentDatetime();

  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "wrongpassword", browsertriplet := "mac-chrome-01"]);
  TestEq(FALSE, result.success);
  TestEq("INCORRECTPASSWORD", result.code);
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login-failed"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , data := [ code := "incorrect-email-password" ]
      , browsertriplet := "mac-chrome-01"
      ]);

  TestEq(TRUE, entity->GetField("LASTLOGIN") < logginginat, "Failed login shouldn't have updated LASTLOGIN");

  //neither should a 'master' (impersonated) login
  result := DoReq( [ action := "loginid", userid := ToString(entityid), impersonation := "1", browsertriplet := "mac-chrome-01" ]);
  TestEq(TRUE, result.success);
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:ok"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , data := DEFAULT RECORD
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "testaccount@beta.webhare.net"
      , impersonated := TRUE
      , impersonator_entity := entityid
      , impersonator_login := "testaccount@beta.webhare.net"
      ]);

  TestEq(TRUE, entity->GetField("LASTLOGIN") < logginginat, "Neither should an impersonated login update LASTLOGIN");

  result := DoReq( [ action := "logout-checkstatus" ]);
  TestEq(TRUE, result.oldstatus.isloggedin);
  TestEq(FALSE, result.isloggedin);
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:logout"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , impersonated := FALSE
      , __ignoredata := TRUE
      , browsertriplet := "other-unknown-0"
      , impersonator_entity := 0
      , impersonator_login := "" //compared to HS we'll stop setting these to the entity if there was no impersonation at all
      ]);

  logginginat := GetCurrentDatetime();
  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-01"]);
  TestEq(TRUE, result.success);

  TestEq(TRUE, entity->GetField("LASTLOGIN") >= logginginat, "succesful login, so update LASTLOGIN time");

  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , impersonated := FALSE
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);
}

MACRO TestWRDAuthPlugin()
{
  OBJECT plugin := GetWRDAuthPlugin(OpenTestsuiteSite()->OpenByPath("portal1-domainless")->url);
  TestEq(TRUE, IsAbsoluteURL(plugin->__GetLoginPageURL(),FALSE), "__GetLoginPageURL (or whatever function generates login urls in the future) should return absolute URL, it returned a relative path when used with currentsite:: earlier");
}

MACRO TestModuleDefIPRules()
{
  /* These tests no longer work with the new WRD Auth as the cookienames may differ
     Plus the webbrowser may have been incorrect to send cookies between different domains anyway
  TestEq(FALSE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop/"));
  TestEq(403, testfw->browser->GetHTTPStatusCode(),"should receive 403 as our current user is unprivileged");

  TestEq(FALSE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop-or-consilio/"));
  TestEq(403, testfw->browser->GetHTTPStatusCode());
  */

  OBJECT trustedbrowser := NEW WebBrowser;
  //trustedbrowser->debug := TRUE;
  trustedbrowser->autofollow := FALSE;
  trustedbrowser->SetupWebHareTrustedPort(GetWebhareConfiguration().trustedhost, GetWebhareConfiguration().trustedport, fetcher_trusted_ip);

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop/"));
  TestEq(303, trustedbrowser->GetHTTPStatusCode(), "should be redirect to login page as we have no session");

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop/test.txt?__whpub_clock_=1"));
  TestEq(303, trustedbrowser->GetHTTPStatusCode(), "should be redirect to login page as we have no session");

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop/test.txt?__whpub_clock_=1", [ headers := [[ field := "Accept-Encoding", value := "gzip" ]]]));
  TestEq(303, trustedbrowser->GetHTTPStatusCode(), "should be redirect to login page as we have no session");

  TestEq("", trustedbrowser->GetResponseHeader("Content-Encoding"), "Should not GZIP wrdauth pages!"); //OR ensure they're properly compressed. but we were sending uncompresed pages with a compressed header!

  TestEq(TRUE, trustedbrowser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop-or-consilio/"));
  TestEq(200, trustedbrowser->GetHTTPStatusCode());
}

MACRO TestPersistentLogin()
{
  OBJECT auditlogtype := testfw->GetWRDSchema()->GetType("WRD_AUDITLOG");

  RECORD result;
  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-01"]);
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);

  RECORD logincookie := SELECT * FROM testfw->browser->GetAllCookies() WHERE name LIKE "*webharelogin-wrd-testschema" AND data != "";
  TEstEq(TRUE, RecordExists(logincookie));
  TestEQ(DEFAULT DATETIME, logincookie.expires);

  //Completely clear the session
  testfw->browser->DeleteCookie(logincookie.name);

  //Should not recover
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);

  result := DoReq( [ action := "login", username := "testaccount@beta.webhare.net", pwd := "secret", persistent := "1", browsertriplet := "mac-chrome-01" ]);
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login"
      , ip := "127.0.0.1"
      , login := "testaccount@beta.webhare.net"
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);

  //Close the user
  testfw->BeginWork();
  testfw->GetWRDSchema()->^wrd_person->GetEntity(entityid)->CloseEntity();
  testfw->CommitWork();

  result := DoReq( [ action := "checkstatus-work" ]);
  TestEq(FALSE, result.isloggedin);

  //Clear the session again
  testfw->browser->DeleteCookie("webharelogin-wrd-testschema");

  //Close the user
  testfw->BeginWork();
  testfw->GetWRDSchema()->^wrd_person->GetEntity(entityid)->CloseEntity();
  testfw->CommitWork();

  result := DoReq( [ action := "checkstatus-work" ]);
  TestEq(FALSE, result.isloggedin);
}

VARIANT ARRAY FUNCTION MakeVA(VARIANT ARRAY args) __ATTRIBUTES__(VARARG)
{
  RETURN args;
}

MACRO TestRequireExternalLoggedinUser()
{
  OBJECT auditlogtype := testfw->GetWRDSchema()->GetType("WRD_AUDITLOG");
  testfw->browser->DeleteCookies("*webharelogin-*");

  STRING loginrequiringurl := thirdpartyurl || "action=requirelogin"; //uses WRD auth plugin dynamic auth

  TestEq(TRUE, testfw->browser->GotoWebPage(loginrequiringurl));
  TesteqLike("*wh-wrdauth-login__form*", testfw->browser->document->queryselector("form")->GetAttribute("class")); //ensure we're talking to some sort of tollium

  //We should be seeing the tollium page above. Do a WRD login
//  testfw->browser->debug:=TRUE;
  STRING logincontrol := GetVariableFromURL(testfw->browser->url, "wrdauth_logincontrol");
  STRING loginpage := testfw->browser->url;

  RECORD rec := testfw->browser->InvokeJSONRPC("/wh_services/wrd/auth", "Login",
                  VARIANT[testfw->browser->url, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"), FALSE, CELL[ browsertriplet := "mac-chrome-01", logincontrol ]]);

  TestEq(TRUE, rec.success);

  TestAuditEvent(
      [ entity := testfw->GetUserWRDId("sysop")
      , type := "platform:login"
      , login := "sysop@beta.webhare.net"
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);

  TestEq('redirect', rec.result.submitinstruction.type);

  TestEq(TRUE, testfw->browser->ExecuteSubmitInstruction(rec.result.submitinstruction), "Execute the submit instruction");
  TestEq(200, testfw->browser->GetHTTPStatusCode()); // another redirect to clean the location
  TestEq(loginrequiringurl, testfw->browser->url, "Should be redirected back to the original location, but now we should see things here");
  TestEq("sysop@beta.webhare.net", DecodeJSONBlob(testfw->browser->content).login);

  InvalidateExternalLoginSessions();

  TestEq(TRUE, testfw->browser->GotoWebPage(loginrequiringurl)); //should still work
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  TestEq(TRUE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop"));
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  TestEq(TRUE, testfw->browser->GotoWebPage( OpenTestsuiteSite()->webroot || "portal1-domainless/requiresysop-or-consilio"));
  TestEq(200, testfw->browser->GetHTTPStatusCode());

  // Log the user out on the main page (TODO can we invalidate the external thirdparty logins to?)
  TestAuditEvent(DEFAULT RECORD); //check log is still empty
  testEq(TRUE, testfw->browser->GotoWebPage(GetTestsuiteWRDauthPlugin()->GetLogoutLink()));
  TestAuditEvent(
      [ entity := testfw->GetUserWRDId("sysop")
      , type := "platform:logout"
      , login := "sysop@beta.webhare.net"
      , impersonated := FALSE
      , impersonator_entity := 0
      , impersonator_login := ""
      , __ignoredata := TRUE
      , browsertriplet := "other-unknown-0"
      ]);

  // FIXME: when the disk audit log is converted to JSON, test if the WRD schema is set in this log entry
}

MACRO TestCrossDomainLogin() {
  OBJECT auditlogtype := testfw->GetWRDSchema()->GetType("WRD_AUDITLOG");
  testfw->browser->DeleteCookies("*webharelogin-*");

  STRING loginrequiringurl := thirdpartyurl || "action=requirelogin"; //uses WRD auth plugin dynamic auth
  STRING accessrulelogin := thirdpartybaseurl || "accessruleaccounts/";

  TestEq(TRUE, testfw->browser->GotoWebPage(accessrulelogin));
  TestEqLike("*wh-wrdauth-login__form*", testfw->browser->document->queryselector("form")->GetAttribute("class")); //ensure we're talking to some sort of tollium

  STRING logincontrol := GetVariableFromURL(testfw->browser->url, "wrdauth_logincontrol");

  //We should be seeing the tollium page above. Do a WRD login
//  testfw->browser->debug:=TRUE;
  STRING loginpage := testfw->browser->url;
  RECORD rec := testfw->browser->InvokeJSONRPC("/wh_services/wrd/auth", "Login",
                  VARIANT[testfw->browser->url, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"), FALSE, CELL[ browsertriplet := "mac-chrome-01", logincontrol ]]);

  TestEq(TRUE, rec.success);
  TestEq("redirect", rec.result.submitinstruction.type);
  TestEq(TRUE, GetVariableFromURL(rec.result.submitinstruction.url, "wrdauth_proof") != "");
  TestEq(accessrulelogin, DeleteVariableFromUrl(rec.result.submitinstruction.url, "wrdauth_proof"));

  // Test if GetAfterLoginSubmitInstruction returns a similar submitinstruction
  RECORD rec2 := testfw->browser->InvokeJSONRPC("/wh_services/wrd/auth", "GetAfterLoginSubmitInstruction",
      VARIANT[ loginpage, logincontrol ]);

  TestEQ("redirect", rec2.result.submitinstruction.type);
  TestEq(TRUE, GetVariableFromURL(rec2.result.submitinstruction.url, "wrdauth_proof") != "");
  TestEQ(accessrulelogin, DeleteVariableFromUrl(rec2.result.submitinstruction.url, "wrdauth_proof"));

  //TestEq('reload', rec.result.submitinstruction.type);
  TestAuditEvent(
      [ entity := testfw->GetUserWRDId("sysop")
      , type := "platform:login"
      , login := "sysop@beta.webhare.net"
      , __ignoredata := TRUE
      , browsertriplet := "mac-chrome-01"
      ]);

  TestEq(TRUE, testfw->browser->ExecuteSubmitInstruction(rec.result.submitinstruction), "Execute the submitinstruction");
  TestEq(accessrulelogin, testfw->browser->url, "Should be redirected back to the original location, but now we should see things");
  TestEqLike("*WebHare testsuite /web/tests/ root*", BlobToString(testfw->browser->content));

  testfw->browser->DeleteCookies("*webharelogin-*"); //force logout otherwise can't access the reset

  // Go to accessrule which allows both webhare and ext users. It should send us to the webhare login page)
  STRING extuserslogin := thirdpartybaseurl || "extusers/";
  testfw->browser->autofollow := TRUE;
  TestEq(TRUE, testfw->browser->GotoWebPage(extuserslogin));
  TestEqLike(GetPrimaryWebhareInterfaceURL() || "*wrdauth_logincontrol=*", testfw->browser->url, "verify we were redirected to WebHare");
  logincontrol := GetVariableFromURL(testfw->browser->url, "wrdauth_logincontrol");
  rec := testfw->browser->InvokeJSONRPC("/wh_services/wrd/auth", "Login",
                  VARIANT[testfw->browser->url, "testwrdauthplugin-username", "testwrdauthplugin-password", FALSE, CELL[ browsertriplet := "mac-chrome-01", logincontrol ]]);

  TestEq(TRUE, rec.success);
  TestEq("redirect", rec.result.submitinstruction.type);
  TestEq(TRUE, GetVariableFromURL(rec.result.submitinstruction.url, "wrdauth_proof") != "");
  TestEq(extuserslogin, DeleteVariableFromUrl(rec.result.submitinstruction.url, "wrdauth_proof"));

  TestEq(TRUE, testfw->browser->ExecuteSubmitInstruction(rec.result.submitinstruction), "Execute the submitinstruction");
  TestEq(extuserslogin, testfw->browser->url, "Should be redirected back to the original location, but now we should see things");
  TestEqLike("*WebHare testsuite /web/tests/ root*", BlobToString(testfw->browser->content));
}

RECORD onshowdata;
MACRO RecordOnShowData(RECORD data)
{
  onshowdata := data;
}

OBJECT ASYNC FUNCTION TestAuditDialog()
{
  AWAIT ExpectScreenChange(+1, PTR RunWRDAuditLogDialog(GetTestController(),
    [ wrdschema := testfw->GetWRDSchema()
    , accountid := testfw->GetUserWRDId("sysop")
    , onshow := PTR RecordOnShowData
    ]));
  TestEq(3, Length(topscreen->events->rows));

  topscreen->events->selection := (SELECT * FROM topscreen->events->rows ORDER BY wrd_creationdate)[0];
  TestEq(FALSE, RecordExists(onshowdata));
  topscreen->events->openaction->TolliumClick();
  TestEq(TRUE, RecordExists(onshowdata));

  //dumpvalue(onshowdata);
  TestEq(testfw->GetUserWRDId("sysop"), onshowdata.entity);
  TestEq("platform:login", onshowdata.type);

  topscreen->events->selection := (SELECT * FROM topscreen->events->rows ORDER BY wrd_creationdate)[1];
  topscreen->events->openaction->TolliumClick();
  TestEq(TRUE, RecordExists(onshowdata));

  //dumpvalue(onshowdata);
  TestEq(testfw->GetUserWRDId("sysop"), onshowdata.entity);
  TestEq("platform:logout", onshowdata.type);

  AWAIT ExpectScreenChange(-1, PTR topscreen->TolliumExecuteCancel);
  RETURN TRUE;
}

MACRO TestLoginDenied()
{
  testfw->BeginWork();

  OBJECT schemaobj:=  testfw->GetWRDSchema();
  TestEq(TRUE, ObjectExists(schemaobj));

  OBJECT persontype := schemaobj->GetType("WRD_PERSON");
  OBJECT auditlogtype := schemaobj->GetType("WRD_AUDITLOG");

  OBJECT entity := persontype->CreateEntity(
      [ wrd_contact_email := "logindenied@beta.webhare.net"
      , whuser_password := CreateAuthenticationSettingsFromPasswordHash(testfw->hashedpasswords.secret)
      , whuser_unit := testfw->testunit
      , wrdauth_account_status := [ status := "active" ]
      ]);

  entityid := entity->id;

  testfw->CommitWork();

  // Make sure the current user is logged out
  RECORD result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  // Login is denied when logging in by username and password
  result := DoReq( [ action := "login", username := "logindenied@beta.webhare.net", pwd := "secret", browsertriplet := "mac-chrome-01"]);
  TestEq(FALSE, result.success);
  TestEq("NOACCESS", result.code);
  // TestEq(TRUE, CellExists(result, "USERINFO"));
  TestEq(FALSE, CellExists(result, "_INTERNAL"));
  TestAuditEvent(
      [ entity := entityid
      , type := "platform:login-failed"
      , ip := "127.0.0.1"
      , login := "logindenied@beta.webhare.net"
      , data := [ code := "account-disabled" ]
      , browsertriplet := "mac-chrome-01"
      ]);

  // User still not logged in
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  // Login is denied when logging in by id
  result := DoReq( [ action := "loginid", userid := ToString(entityid), browsertriplet := "mac-chrome-01" ]);
  TestEq(FALSE, result.success);
  TestEq("NOACCESS", result.code);
  TestEq(FALSE, CellExists(result, "_INTERNAL"));
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:failed"
      , ip := "127.0.0.1"
      , login := "logindenied@beta.webhare.net"
      , impersonated := FALSE
      , data := [ failurecode := "NOACCESS"
                ]
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "logindenied@beta.webhare.net"
      , impersonator_entity := entityid
      , impersonator_login := "logindenied@beta.webhare.net"
      ]);

  // User still not logged in
  result := DoReq( [ action := "checkstatus" ]);
  TestEq(FALSE, result.isloggedin);
  TestEq("", result.loginname);
  TestEq(0, result.entityid);

  // Login is not denied when impersonating login
  result := DoReq( [ action := "loginid", userid := ToString(entityid), impersonation := "1", browsertriplet := "mac-chrome-01" ]);
  TestEq(TRUE, result.success);
  TestEq(FALSE, RecordExists(result.submitinstruction));
  TestAuditEvent(
      [ entity := entityid
      , type := "wrd:loginbyid:ok"
      , login := "logindenied@beta.webhare.net"
      , impersonated := TRUE
      , data := DEFAULT RECORD
      , browsertriplet := "mac-chrome-01"
      , byentity := entityid
      , bylogin := "logindenied@beta.webhare.net"
      , impersonator_entity := entityid
      , impersonator_login := "logindenied@beta.webhare.net"
      ]);
}

Runtestframework( [ PTR PrepareServer
                  , PTR CreateMyTestSchema
                  , PTR TestWRDAuthPlugin
                  , PTR TestModuleDefIPRules
                  , PTR TestPersistentLogin
                  , PTR TestRequireExternalLoggedinUser
                  , PTR TestCrossDomainLogin
                  , PTR TestAuditDialog
                  , PTR TestLoginDenied
                  ], [ testusers := [[ login := "sysop", grantrights := ["system:sysop"] ]
                                    ]
                     ]);
