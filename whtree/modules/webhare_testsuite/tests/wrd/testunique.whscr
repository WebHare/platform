<?wh

LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/testframework.whlib";


MACRO ExpectCommitException(OBJECT e, STRING pattern)
{
  IF (GetPrimary()->IsWorkOpen())
    GetPrimary()->RollbackWork();

  IF (e EXTENDSFROM TestFailException)
    THROW e;
  TestEQLike(pattern, e->what);
}


MACRO TestUnique()
{
  OBJECT schemaobj := testfw->GetWRDSchema();

  testfw->BeginWork();

  OBJECT dom_obj := schemaobj->CreateDomain("TEST_UNIQUES");

  dom_obj->CreateAttribute("TEST_FREE",        "FREE",      [ isunique := TRUE, isrequired := FALSE, title := "Unique FREE" ]);
  dom_obj->CreateAttribute("TEST_EMAIL",       "EMAIL",     [ isunique := TRUE, isrequired := FALSE, title := "Unique EMAIL" ]);
  dom_obj->CreateAttribute("TEST_INTEGER",     "INTEGER",   [ isunique := TRUE, isrequired := FALSE, title := "Unique INTEGER" ]);
  dom_obj->CreateAttribute("TEST_INTEGER64",   "INTEGER64", [ isunique := TRUE, isrequired := FALSE, title := "Unique INTEGER64" ]);
  TestThrowsLike("*cannot*ARRAY*", PTR dom_obj->CreateAttribute("TEST_ARRAY",       "ARRAY",     [ isunique := TRUE, isrequired := FALSE, title := "Array with unique stuff" ]));
  dom_obj->CreateAttribute("TEST_ARRAY",       "ARRAY");
  dom_obj->CreateAttribute("TEST_ARRAY.EMAIL", "EMAIL",     [ isunique := TRUE, isrequired := FALSE, title := "Unique EMAIL" ]);
  dom_obj->CreateAttribute("TEST_NONUNIQUE",   "FREE",      [ isunique := FALSE, isrequired := FALSE, title := "Non-unique FREE" ]);

  testfw->CommitWork();

  testfw->BeginWork();

  INTEGER person1 := dom_obj->CreateEntity([ test_free := "1", test_email := "trans@beta.webhare.net", test_integer := 3, test_integer64 := 4, test_array := [[ email := "pietje@example.com" ]] ])->id;
  TestThrowsLike("*conflict*", PTR dom_obj->CreateEntity([ test_free := "1" ]));
  TestThrowsLike("*conflict*", PTR dom_obj->CreateEntity([ test_email := "trans@beta.webhare.net" ]));
  TestThrowsLike("*conflict*", PTR dom_obj->CreateEntity([ test_integer := 3 ]));
  TestThrowsLike("*conflict*", PTR dom_obj->CreateEntity([ test_integer64 := 4 ]));
  TestThrowsLike("*conflict*", PTR dom_obj->CreateEntity([ test_array := [[ email := "pietje@example.com" ]] ]));  //Issue #479

  testfw->CommitWork();


  testfw->BeginWork();

  OBJECT old_primary := GetPrimary();
  SetPrimaryWebhareTransaction(0);

  OBJECT sub_primary := OpenPrimary();
  sub_primary->BeginWork();
  dom_obj->CreateEntity([ test_free := "2xx6" ]);
  sub_primary->CommitWork();
  sub_primary->Close();

  SetPrimaryWebhareTransaction(old_primary->id);

  TRY
  {
    // Need to insert after the subtransaction, or the subtransaction commit will wait on the old primary to commit
    dom_obj->CreateEntity([ test_free := "2xx6" ]);

    RECORD ARRAY errors := testfw->CommitWorkReturnErrors();
    TestEQ(
        [ [ code :=       1
          , columnname := ""
          , message :=    "Value in WRD.ENTITY_SETTINGS:UNIQUE_RAWDATA is not unique"
          , tablename :=  "ENTITY_SETTINGS"
          ]
        ], errors);
  }
  CATCH (OBJECT e)
    ExpectCommitException(e, "Unique value conflict*");

  // Test if unique values are caught
  testfw->BeginWork();
  dom_obj->CreateEntity([ test_free := "UNIQUEFREE", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MakeDate(2018,1,1)]);
  dom_obj->CreateEntity([ test_free := "UNIQUEFREE", wrd_creationdate := MakeDate(2018,1,1)]);
  testfw->CommitWork();

  // Test database protection (importmode disabled the validation query)
  {
    testfw->BeginWork();
    dom_obj->CreateEntity([ test_free := "UNIQUEFREE2", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MakeDate(2050,1,1)]);
    TRY
    {
      dom_obj->CreateEntity([ test_free := "UNIQUEFREE2", wrd_creationdate := MakeDate(2050,1,1) ], [ importmode := TRUE ]);

      RECORD ARRAY errors := testfw->CommitWorkReturnErrors();
      TestEQ(
          [ [ code :=       1
            , columnname := ""
            , message :=    "Value in WRD.ENTITY_SETTINGS:UNIQUE_RAWDATA is not unique"
            , tablename :=  "ENTITY_SETTINGS"
            ]
          ], errors);
    }
    CATCH (OBJECT e)
      ExpectCommitException(e, "*duplicate key value violates unique constraint*"); // postgresql exception
  }

  // test database protection when updating limitdate to the future
  {
    testfw->BeginWork();
    OBJECT e1 := dom_obj->CreateEntity([ test_free := "UNIQUEFREE3", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MakeDate(2050,1,1) ]);
    e1->UpdateEntity([ wrd_limitdate := MakeDate(2050,1,2) ]);
    TRY
    {
      // Need to insert after the subtransaction, or the subtransaction commit will wait on the old primary to commit
      dom_obj->CreateEntity([ test_free := "UNIQUEFREE3", wrd_creationdate := MakeDate(2050,1,1) ], [importmode := TRUE ]);

      RECORD ARRAY errors := testfw->CommitWorkReturnErrors();
      TestEQ(
          [ [ code :=       1
            , columnname := ""
            , message :=    "Value in WRD.ENTITY_SETTINGS:UNIQUE_RAWDATA is not unique"
            , tablename :=  "ENTITY_SETTINGS"
            ]
          ], errors);
    }
    CATCH (OBJECT e)
      ExpectCommitException(e, "*duplicate key value violates unique constraint*"); // postgresql exception
  }

  // test database protection when updating limitdate to the past
  {
    testfw->BeginWork();
    OBJECT e1 := dom_obj->CreateEntity([ test_free := "UNIQUEFREE4", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MakeDate(2050,1,1) ]);
    e1->UpdateEntity([ wrd_limitdate := MakeDate(2018,1,2) ]);
    dom_obj->CreateEntity([ test_free := "UNIQUEFREE4", wrd_creationdate := MakeDate(2050,1,1) ], [ importmode := TRUE ]);
    testfw->CommitWork();
  }

  // test database protection when updating limitdate to the future
  {
    testfw->BeginWork();
    OBJECT e1 := dom_obj->CreateEntity([ test_free := "UNIQUEFREE5", test_nonunique := "nonunique", wrd_creationdate := MakeDate(2010,1,1), wrd_limitdate := MakeDate(2018,1,1)]);
    e1->UpdateEntity([ wrd_limitdate := MakeDate(2050,1,1) ]);

    // non-unique attributes should just work ok
    dom_obj->CreateEntity([ test_free := "UNIQUEFREE5-1", wrd_creationdate := MakeDate(2050,1,1), test_nonunique := "nonunique" ], [ importmode := TRUE ]);
    TRY
    {
      dom_obj->CreateEntity([ test_free := "UNIQUEFREE5", wrd_creationdate := MakeDate(2050,1,1) ], [ importmode := TRUE ]);

      RECORD ARRAY errors := testfw->CommitWorkReturnErrors();
      TestEQ(
          [ [ code :=       1
            , columnname := ""
            , message :=    "Value in WRD.ENTITY_SETTINGS:UNIQUE_RAWDATA is not unique"
            , tablename :=  "ENTITY_SETTINGS"
            ]
          ], errors);
    }
    CATCH (OBJECT e)
      ExpectCommitException(e, "*duplicate key value violates unique constraint*"); // postgresql exception
  }

  // test database protection when updating limitdate to the future with clashing old values (that are updated, so should not error out)
  {
    testfw->BeginWork();
    OBJECT deleted := dom_obj->CreateEntity([ test_free := "UNIQUEFREE6", wrd_limitdate := MakeDate(2020,1,1) ]);
    OBJECT active := dom_obj->CreateEntity([ test_free := "UNIQUEFREE6" ]);
    deleted->UpdateEntity([ test_free := "UNIQUEFREE7", wrd_limitdate := MAX_DATETIME ]);
    testfw->CommitWork();
  }

  //test email normalization
  testfw->BeginWork();
  TestEq(person1, dom_obj->Search("test_email", "trans@beta.webhare.net"));
  TestEq(person1, dom_obj->Search("test_email", "TRANS@beta.webhare.net"));
  TestThrowsLike("*is not a valid value*", PTR dom_obj->CreateEntity([ test_email := "trans@beta" ]));
  TestThrowsLike("*Unique value conflict*", PTR dom_obj->CreateEntity([ test_email := "TRANS@beta.webhare.net" ]));
  dom_obj->UpdateEntity(person1, [ test_email:= "TRANS@beta.webhare.net"]);
  TestEq(person1, dom_obj->Search("test_email", "trans@beta.webhare.net"));
  TestEq(person1, dom_obj->Search("test_email", "TRANS@beta.webhare.net"));
  TestEq([[ wrd_id := person1 ]], dom_obj->RunQuery([outputcolumns := ["wrd_id"], filters := [[ field := "test_email", value := "tRaNS@beTA.webhare.net" ]]]));
  TestEq([[ wrd_id := person1 ]], dom_obj->RunQuery([outputcolumns := ["wrd_id"], filters := [[ field := "test_email", matchtype := "LIKE", value := "tRaNS@beTA.*.net" ]]]));
  TestEq([[ wrd_id := person1 ]], dom_obj->RunQuery([outputcolumns := ["wrd_id"], filters := [[ field := "test_email", matchtype := "IN", value := ["tRaNS@beTA.WebHARE.net"] ]]]));
  TestEq([[ wrd_id := person1 ]], dom_obj->RunQuery([outputcolumns := ["wrd_id"], filters := [[ field := "test_array.email", matchtype := "MENTIONS", value := "PIETje@example.com" ]]]));
  testfw->CommitWork();
}

MACRO TestEnsureEntity()
{
  testfw->BeginWork();

  OBJECT whunit := testfw->GetWRDSchema()->GetType("WHUSER_UNIT");
  TestEq(0, Length(whunit->Runquery(DEFAULT RECORD)));

  TestThrowsLike("*wrd_tagxxx*", PTR whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tagxxx := "FIRSTUNIT" ], [ entitykey := ["wrd_leftentity","wrd_tagxxx"], ifnew := [ wrd_title := "Unit #1" ] ]));
  TestThrowsLike("*wrd_tag*", PTR whunit->EnsureEntity( [ wrd_leftentity := 0 ], [ entitykey := ["wrd_leftentity","wrd_tag" ], ifnew := [ wrd_title := "Unit #1"]]));


  OBJECT firstunit := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT" ], [ entitykey := ["wrd_leftentity","wrd_tag" ], ifnew := [ wrd_title := "Unit #1"]]);
  OBJECT secondunit := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "SECONDUNIT" ], [ entitykey := ["wrd_leftentity","wrd_tag" ], ifnew := [ wrd_title := "Unit #2"]]);
  TestEq(2, Length(whunit->Runquery(DEFAULT RECORD)));
  TestEq(TRUE, ObjectExists(firstunit));
  TestEq("Unit #1", firstunit->Getfield("WRD_TITLE"));

  firstunit := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT" ], [ entitykey := ["wrd_leftentity","wrd_tag" ], ifnew := [ wrd_title := "Unit #1b"]]);
  TestEq(2, Length(whunit->Runquery(DEFAULT RECORD)));
  TestEq("Unit #1", firstunit->GetField("WRD_TITLE")); //shouldn't have changed

  firstunit := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT", wrd_title := "Unit #1b" ], [ entitykey := ["wrd_leftentity","wrd_tag" ] ]);
  TestEq(2, Length(whunit->Runquery(DEFAULT RECORD)));
  TestEq("Unit #1b", firstunit->GetField("WRD_TITLE"));

  TestThrowsLike("*ENTITYKEY*", PTR whunit->EnsureEntity( [ wrd_leftentity := firstunit->id ]));
  TestThrowsLike("*ENTITYKEY*", PTR whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT"] , [ifnew := [ wrd_title := "Unit #1b" ]]), "Entitykey is required");

  whunit->CloseEntity(firstunit->id);

  TestThrowsLike("*WRD_LIMITDATE*without*historymode*all*", PTR whunit->EnsureEntity([ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT", wrd_title := "Unit #1b", wrd_limitdate := MAX_DATETIME ], [ entitykey := ["wrd_leftentity","wrd_tag" ] ]));

  OBJECT recreate := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT", wrd_title := "Unit #1b" ], [ entitykey := ["wrd_leftentity","wrd_tag" ] ]);
  TestAssert(recreate->id != firstunit->id);
  whunit->DeleteEntity(recreate->id);

  recreate := whunit->EnsureEntity( [ wrd_leftentity := 0, wrd_tag := "FIRSTUNIT", wrd_title := "Unit #1b" ], [ entitykey := ["wrd_leftentity","wrd_tag"], historymode := "all" ]);
  TestAssert(recreate->id = firstunit->id);

  testfw->CommitWork();
}


RunTestframework([ PTR TestUnique
                 , PTR TestEnsureEntity
                 ]);
