<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::internal/any.whlib";
LOADLIB "wh::internal/hsselftests.whlib";
LOADLIB "wh::internal/testfuncs.whlib";
LOADLIB "wh::internal/css/support.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::filetypes/css.whlib";
LOADLIB "wh::filetypes/html.whlib";
LOADLIB "wh::xml/dom.whlib";


MACRO TestDomStyleRewriter()
{
  OpenTest("TestDomStyleRewriter");

  BLOB htmlfile := OpenTestFile("corporate.html");
  OBJECT dom := MakeXMLDocumentFromHTML(htmlfile);
  BLOB css := StringToBlob(dom->GetElementsByTagName('style')->textcontent);
  OBJECT cssom := MakeCSSStyleSheet(css);

  dom := cssom->RewriteDomStyles(dom);

  // Serialize and retest:
  OBJECT rewriter := NEW HtmlRewriterContext;
  BLOB htmlblob := rewriter->GenerateHTML(dom);

  OBJECT newdom := MakeXMLDocumentFromHTML(htmlblob);
  css := StringToBlob(dom->GetElementsByTagName('style')->item(0)->ChildrenText);
  cssom := MakeCSSStyleSheet(css);
  newdom := cssom->RewriteDomStyles(newdom);
  newdom->GetElementsByTagName('style')->item(0)->NodeValue := BlobToString(cssom->GetDocumentBlob(TRUE));
  BLOB newhtmlblob := rewriter->GenerateHTML(newdom);
  dom->GetElementsByTagName('style')->item(0)->NodeValue := BlobToString(cssom->GetDocumentBlob(TRUE));
  htmlblob := rewriter->GenerateHTML(dom);

  TestEqTextBlob(htmlblob, newhtmlblob);
  OBJECT node := dom->QuerySelector("body.scheme1 .schemecolor");
  TestEQ("testlink", node->GetAttribute("id"));

  //DumpValue(nodelist, 'tree');
  //PRINT("\n" || nodelist->Length);
//  PRINT(nodelist->item(0)->getAttribute("style") || "\n");
  TestEq('text-decoration: underline; margin: 0; padding: 0; font-size: 15px; line-height: 22px; font-family: Arial, Helvetica, Sans-Serif; color: #c60c30 !important;', node->getAttribute("style"));


  CloseTest("TestDomStyleRewriter");
}

MACRO TestQuerySelector()
{
  OpenTest("TestQuerySelector");

  BLOB htmlfile := OpenTestFile("corporate.html");
  OBJECT dom := MakeXMLDocumentFromHTML(htmlfile);
  OBJECT node := dom->querySelector(".tdalign");

  TestEq("td", node->nodeName);
  OBJECT nodelist := dom->querySelectorAll(".tdalign");
  TestEq(4, nodeList->Length);
  nodelist := dom->querySelectorAll(".glark");
  TestEq(0, nodeList->length);

  OBJECT ARRAY bodychildren := dom->QuerySelectorAll("body > *")->GetCurrentElements();
  TestEq(Length(bodychildren), Length(dom->body->ListChildren("*","*")));

  TestThrowsLike("*empty selector*", PTR dom->querySelectorAll(""));

  CloseTest("TestQuerySelector");
}

MACRO TestRewriterPrecedence()
{
  OpenTest("TestRewriterPrecedence");

  BLOB newcss := StringToBlob("table { border-collapse: collapse; }\n"
                           || "table { border-spacing: 0; border-collapse: collapse; margin: 0 auto; border: 0; }\n"
                           || ".maintable { width: 620px; background-color: #3d92b6; }\n"
                           || ".maintable { background-color: pink !important; }\n"
                           || ".maintable { background-color: black; }\n"
                           || ".maintable { background-color: blue !important; }\n"
                           || ".scheme1 .maintable { background-color: red !important; }\n"
                           );
  BLOB html := StringToBlob('<html>\n\t<body class="scheme1">\n\t\t<table width="620" class="maintable">\n\t\t\t<!-- an empty table :-) -->\n\t\t</table>\n\t</body>\n</html>');
  OBJECT dom := MakeXMLDocumentFromHTML(html);
  OBJECT cssom := MakeCSSStyleSheet(newcss);
  OBJECT newdom := cssom->RewriteDomStyles(dom);

  TestEq("background-color: blue !important;", cssom->cssrules->item(5)->__DeclarationString);
  TestEq("background-color: red !important;", cssom->cssrules->item(6)->__DeclarationString);
  TestEq("border-spacing: 0; margin: 0 auto; border: 0; border-collapse: collapse; width: 620px; background-color: red !important;", newdom->GetElementsByTagName("table")->item(0)->getAttribute("style"));

  CloseTest("TestRewriterPrecedence");
}

MACRO TestComplexCSSRule()
{
  OpenTest("TestComplexCSSRule");

  BLOB cssfile := StringToBlob(
    "html, body { margin: 0; padding: 0; }\n"
    || ".logoarea:first-child { border: 1px solid #FF0000; }\n"
    || ".pathbar:nth-child(0)[border=0] { margin: 5px; }\n"
    || ".img:hover { border: 1px solid red; }\n"
    || "div > a.whatever { display: none; }\n"
    || ":scope > a.whatever { display: none; }\n"
    || "> a.whatever { display: none; }\n"
    || "#someid ul > li:nth-last-of-type(3) { text-decoration: none; }\n"
    || "span ~ img[src='image.jpg'] { background-color: #000; }\n"
    || "span + img:empty { border: 1px solid fuchsia; }\n"
    || "th ~ td > span.iconContainer:first-child:empty { display: none!important; }\n"
    || "div.window { background-image: url(path/to/image.png); }\n"
    || "*|div { border: none; }\n"
    || "body |div { border: none; }\n"
    || "body|div { border: none; }\n"
    || "*[src], *[href] { display: block; }\n"
    || ".type-cta > tr > td { color: ugly; }\n"
    || ".type-cta tr:first-child td:first-child { display: none; }\n"
    || "[data-whatever] { font-size: 1pt; }\n"
    || "html * { font-size: 2pt; }\n"
    );
  BLOB htmlfile := OpenTestFile("test.html");
  OBJECT cssom;
  cssom := MakeCSSStyleSheet(cssfile);
  OBJECT dom;
  dom := MakeXMLDocumentFromHTML(htmlfile);

  TestEq("margin: 0; padding: 0;", cssom->cssrules->item(0)->__DeclarationString);
  TestEq("border: 1px solid #FF0000;", cssom->cssrules->item(1)->__DeclarationString);
  TestEq("margin: 5px;", cssom->cssrules->item(2)->__DeclarationString);
  TestEq("border: 1px solid red;", cssom->cssrules->item(3)->__DeclarationString);
  TestEq("display: none;", cssom->cssrules->item(4)->__DeclarationString);
  TestEq("display: none;", cssom->cssrules->item(5)->__DeclarationString);
  TestEq("display: none;", cssom->cssrules->item(6)->__DeclarationString);
  TestEq("text-decoration: none;", cssom->cssrules->item(7)->__DeclarationString);
  TestEq("background-color: #000;", cssom->cssrules->item(8)->__DeclarationString);
  TestEq("border: 1px solid fuchsia;", cssom->cssrules->item(9)->__DeclarationString);
  TestEq("display: none !important;", cssom->cssrules->item(10)->__DeclarationString);
  TestEq("background-image: url(\"path/to/image.png\");", cssom->cssrules->item(11)->__DeclarationString);
  TestEq("border: none;", cssom->cssrules->item(12)->__DeclarationString);
  TestEq("border: none;", cssom->cssrules->item(13)->__DeclarationString);
  TestEq("border: none;", cssom->cssrules->item(14)->__DeclarationString);
  TestEq("display: block;", cssom->cssrules->item(15)->__DeclarationString);
  TestEq("color: ugly;", cssom->cssrules->item(16)->__DeclarationString);
  TestEq("display: none;", cssom->cssrules->item(17)->__DeclarationString);
  TestEq("font-size: 1pt;", cssom->cssrules->item(18)->__DeclarationString);
  TestEq("font-size: 2pt;", cssom->cssrules->item(19)->__DeclarationString);

  CloseTest("TestComplexCSSRule");
}

INTEGER FUNCTION GetFirstSelectorSpecificity(OBJECT rule)
{
  RETURN rule->__GetSelectors()[0].specificity;
}

MACRO TestCSSSpecificity()
{
  OpenTest("TestCSSSpecificity");

  BLOB css := StringToBlob("a { color: red; }\n"
                        || "body .schemecolor { color: green; }\n"
                        || "* { border: none; }\n"
                        || "LI { display: inline-block; }\n"
                        || "UL LI { display: block; }\n"
                        || "UL OL+LI { display: table-cell; }\n"
                        || "H1 + *[REL=up] { color: black; }\n"
                        || "UL OL LI.red { color: red; }\n"
                        || "LI.red.level { border: 1px solid magento; }\n"
                        || "#x34y { border: none; }\n"
                        || "#s12:not(FOO) { color: purple; }\n"
                          );

  BLOB html := StringToBlob("<html>\n"
                          || "\t<head>\n"
                          || "\t\t<title>whatever</title>\n"
                          || "\t</head>\n"
                          || "\t<body>\n"
                          || "\t\t<a class=\"schemecolor\" href=\"#\" style=\"color: #0094b3;\">bla</a>\n"
                          || "\t</body>\n"
                          || "</html>\n"
                           );

  OBJECT cssom := MakeCSSStyleSheet(css);
  OBJECT dom := MakeXMLDocumentFromHTML(html);
  OBJECT xpath := dom->CreateXPathQuery();

  dom := cssom->RewriteDomStyles(dom);
  OBJECT a := xpath->ExecuteQuery("//a")->item(0);
  TestEq("border: none; color: #0094b3;", a->getAttribute("style"));
  TestEq(0, GetFirstSelectorSpecificity(cssom->cssrules->item(2)));
//  TestEq([ a:= 0, b := 0, c:= 0 ], cssom->cssrules->item(2)->__Specificity);
  TestEq(1, GetFirstSelectorSpecificity(cssom->cssrules->item(3)));
//  TestEq([ a:= 0, b := 0, c:= 1 ], cssom->cssrules->item(3)->__Specificity);
  TestEq(2, GetFirstSelectorSpecificity(cssom->cssrules->item(4)));
//  TestEq([ a:= 0, b := 0, c:= 2 ], cssom->cssrules->item(4)->__Specificity);
  TestEq(3, GetFirstSelectorSpecificity(cssom->cssrules->item(5)));
//  TestEq([ a:= 0, b := 0, c:= 3 ], cssom->cssrules->item(5)->__Specificity);
  TestEq(11, GetFirstSelectorSpecificity(cssom->cssrules->item(6)));
//  TestEq([ a:= 0, b := 1, c:= 1 ], cssom->cssrules->item(6)->__Specificity);
  TestEq(13, GetFirstSelectorSpecificity(cssom->cssrules->item(7)));
//  TestEq([ a:= 0, b := 1, c:= 3 ], cssom->cssrules->item(7)->__Specificity);
  TestEq(21, GetFirstSelectorSpecificity(cssom->cssrules->item(8)));
//  TestEq([ a:= 0, b := 2, c:= 1 ], cssom->cssrules->item(8)->__Specificity);
  TestEq(100, GetFirstSelectorSpecificity(cssom->cssrules->item(9)));
//  TestEq([ a:= 1, b := 0, c:= 0 ], cssom->cssrules->item(9)->__Specificity);
  TestEq(101, GetFirstSelectorSpecificity(cssom->cssrules->item(10)));
//  TestEq([ a:= 1, b := 0, c:= 1 ], cssom->cssrules->item(10)->__Specificity);

  CloseTest("TestCSSSpecificity");
}

MACRO TestCSSRuleXPathNamespaced()
{
  OpenTest("TestCSSRuleXPathNamespaced");

  BLOB xml := StringToBlob('<?xml version="1.0" encoding="UTF-8" standalone="yes"?><sub:subjects xmlns:sub="http://www.utwente.nl/types/portal/subject/"><sub:subject><sub:subjectId>education</sub:subjectId><sub:isActive>true</sub:isActive><sub:dateCreated>2015-07-06T00:00:00+02:00</sub:dateCreated><sub:dateModified>2015-07-06T00:00:00+02:00</sub:dateModified><sub:title lang="EN">Education</sub:title><sub:title lang="NL">Onderwijs</sub:title></sub:subject><sub:subject><sub:subjectId>research</sub:subjectId><sub:isActive>true</sub:isActive><sub:dateCreated>2015-05-29T00:00:00+02:00</sub:dateCreated><sub:dateModified>2015-06-26T00:00:00+02:00</sub:dateModified><sub:title lang="NL">Onderzoek</sub:title><sub:title lang="EN">Research</sub:title></sub:subject></sub:subjects>');
  OBJECT dom := MakeXMLDocument(xml);

  TestEq(2, Length(dom->QuerySelectorAll("isActive")->GetCurrentElements()));
  TestEq(2, Length(dom->QuerySelectorAll("dateCreated")->GetCurrentElements()));
  TestEq(4, Length(dom->QuerySelectorAll("title")->GetCurrentElements()));

  CloseTest("TestCSSRuleXPathNamespaced");
}

MACRO TestRewriteDomStyles()
{
  BLOB input := OpenTestFile("css/rewritedomstyles.html");
  OBJECT dom := MakeXMLDocumentFromHTML(input);
  INTEGER numstyles := dom->GetElementsByTagName('style')->Length;
  INTEGER i;
  FOR(i := 0; i < numstyles; i := i + 1)
  {
    STRING style := dom->GetElementsByTagName('style')->item(i)->ChildrenText;
    OBJECT cssom := MakeCSSStyleSheet(StringToBlob(style));
    dom := cssom->RewriteDomStyles(dom);
    //dom->GetElementsByTagName('style')->item(i)->NodeValue := BlobToString(cssom->GetDocumentBlob(TRUE));
  }

  //BLOB output := NEW HtmlRewriterContext->GenerateHTML(dom);  SendBlobTo(0,output);
  OBJECT shouldhave560 := dom->GetElementById("shouldhave560");
  TestEq("width: 560px;", shouldhave560->GetAttribute("style"));

  OBJECT shouldhavepadding20 := dom->GetElementById("shouldhavepadding20");
  TestEq("padding-right: 20px;", shouldhavepadding20->GetAttribute("style"));

  OBJECT shouldbebold := dom->GetElementById("shouldbebold");
  //a merged style would be even better, but we mnust enusre that font: precedes font-weight
  TestEqLike("*font:*font-weight:*", shouldbebold->GetAttribute("style"));
}


STRING ARRAY FUNCTION GetNodeTexts(OBJECT ARRAY nodes)
{
  RETURN SELECT AS STRING ARRAY node->textcontent FROM ToRecordArray(nodes, "node");
}

RECORD ARRAY FUNCTION ParseTestXML(STRING resource)
{
  OBJECT testdoc := MakeXMLDocument(OpenTestFile(resource));
  IF (RecordExists(testdoc->GetParseErrors()))
    ABORT(testdoc->GetParseErrors());

  RECORD ARRAY data;
  FOREVERY (OBJECT test FROM testdoc->GetElements("test"))
  {
    RECORD rec :=
        [ title :=            test->GetElement("title")->textcontent
        , selectors :=        GetNodeTexts(test->GetElements("selectors > selector"))
        , invalidselectors := GetNodeTexts(test->GetElements("selectors > selector.invalid"))
        , content :=          test->GetElement("testcontent")->innerXML
        , mode :=             (ObjectExists(test->GetElement("mode")) ? test->GetElement("mode")->textcontent : "") ?? "qSA"
        ];

    INSERT rec INTO data AT END;
  }

  IF (LENGTH(data) = 0)
    THROW NEW Exception(`Could not parse css test xml`);

  RETURN data;
}

MACRO DumpXMLTree(OBJECT node, OBJECT ARRAY expect, OBJECT ARRAY got, INTEGER indent DEFAULTSTO 0)
{
  WHILE (ObjectExists(node))
  {
    BOOLEAN isexpected, isgotten;
    FOREVERY (OBJECT o FROM expect)
      IF (node->IsSameNode(o))
        isexpected := TRUE;
    FOREVERY (OBJECT o FROM got)
      IF (node->IsSameNode(o))
        isgotten := TRUE;

    PRINT(`${RepeatText("  ", indent)}<${node->nodename}${node->HasAttribute("class") ? ` class="${EncodeValue(node->GetAttribute("class"))}"` : ""}>${isexpected = isgotten ? "" : isgotten ? " <!-- returned unexpectedly -->" : " <!-- not returned while expected -->"}\n`);
    IF (ObjectExists(node->firstelementchild))
      DumpXMLTree(node->firstelementchild, expect, got, indent + 2);
    PRINT(`${RepeatText("  ", indent)}<${node->nodename}/>\n`);
    node := node->nextelementsibling;
  }
}

MACRO RunSelectorTests(RECORD ARRAY data)
{
  FOREVERY (RECORD rec FROM data)
  {
    OBJECT doc := MakeXMLDocument(StringToBlob(rec.content));
    IF (RecordExists(doc->GetParseErrors()))
    {
      DumpValue(doc->GetParseErrors());
      ABORT(`Parse errors for content of test ${rec.title}`);
    }
    IF (NOT ObjectExists(doc))
      ABORT(rec);

    // open HTML documents as HTML
    IF (doc->documentelement->nodename = "html")
    {
      OBJECT rewriter := NEW HtmlRewriterContext;
      BLOB htmlblob := rewriter->GenerateHTML(doc);
      doc := MakeXMLDocumentFromHTML(htmlblob);
    }

    IF (rec.title IN STRING
          [ ""
//          , ":empty pseudo-class and XML/SGML constructs"
          ])
    {
      CONTINUE;
    }

    FOREVERY (STRING sel FROM rec.selectors)
    {
      //PRINT(`Test selector: ${sel}\n`);
      IF (__MatchesAnyMask(sel,
          [ "*:link*"
          , "*:visited*"
          , "*:lang*"
          , "*:target*"
          , "*:enabled*"
          , "*:disabled*"
          , "*:checked*"
          , "*:first-line*"
          , "*:first-letter*"
          , "*:before*"
          , "*:after*"
          ]))
      {
        //PRINT(` ignoring unsupported selector: ${sel}\n`);
        CONTINUE;
      }

      OBJECT ARRAY expect := doc->GetElements(`[match-selector-${#sel}]`);
      OBJECT scope := doc->GetElement(`[selector-scope]`);

      OBJECT ARRAY got;
      BOOLEAN ismatch := TRUE;
      STRING err;
      TRY
         got := EvaluateSelectors(doc, scope, sel, rec.mode);
      CATCH (OBJECT e)
      {
        ismatch := FALSE;
        err := e->what;
      }
      ismatch := ismatch = (sel NOT IN rec.invalidselectors);

      ismatch := ismatch AND LENGTH(expect) = LENGTH(got);
      IF (ismatch)
      {
        FOREVERY (OBJECT o FROM expect)
          IF (NOT got[#o]->IsSameNode(o))
            ismatch := FALSE;
      }
      IF (NOT ismatch)
      {
        PRINT(`Failed selector: ${sel}\n`);

        IF (err != "")
          PRINT(`  Error: ${err}\n`);
        PRINT(`Selectors in test:\n`);
        DumpValue(rec.selectors);
        PRINT("Document:\n");
        SendBlobTo(0, doc->GetDocumentBlob(TRUE));
        PRINT("Selection tree:\n");
        DumpXMLTree(doc->documentelement, expect, got);
        ABORT("X");
      }
    }
  }
}

MACRO TestCSSSelectorEngine()
{
  RECORD ARRAY w3c_testsuite := ParseTestXML("css/css-selectors-w3ctestsuite.xml");
  RunSelectorTests(w3c_testsuite);

  RECORD ARRAY customtests := ParseTestXML("css/css-selector-customtests.xml");
  RunSelectorTests(customtests);
}

PRINT("\n === Running TestCSS_XPath\n");
TestCSSSelectorEngine();
TestComplexCSSRule();
TestCSSRuleXpathNamespaced();
TestQuerySelector();
TestDomStyleRewriter();
TestRewriterPrecedence();
TestCSSSpecificity();
TestRewriteDomStyles();
