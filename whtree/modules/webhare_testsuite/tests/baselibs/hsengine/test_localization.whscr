<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::internal/hsselftests.whlib";
LOADLIB "wh::util/localization.whlib";

// We're building using Ubuntu 18.04, which currently (as of 2018-03-22) has ICU4C 60.2:
// https://launchpad.net/ubuntu/bionic/+source/icu

// ICU version is <major>.<minor>[.<patch>[.<build>]]
STRING cur_icu_version := "60.2"; // CLDR 32
// TZ data version is <year><lowercase letter>
STRING cur_tzdata_version := "2017c";

/*
Print(MakeCompareFunction("en", "base", FALSE, FALSE)("a", "b") || "\n");
Print(MakeCompareFunction("en", "base", FALSE, FALSE)("a", "ä") || "\n");
Print(MakeCompareFunction("en", "base", FALSE, FALSE)("z", "ä") || "\n");
Print(MakeCompareFunction("sv", "base", FALSE, FALSE)("z", "ä") || "\n");
//*/
/*
STRING ARRAY FUNCTION __ICU_GetTimeZoneIDs() __ATTRIBUTES__(EXTERNAL "wh_icu");
STRING ARRAY zoneids := __ICU_GetTimeZoneIDs();
RECORD ARRAY zones := GetAvailableTimeZones("nl");
//abort((select * from torecordarray(zoneids, "tz") order by tz),"boxed");
abort((select code,tz,comments from zones order by code,tz),"boxed");
//*/
/*
STRING FUNCTION __ICU_GetTimeZoneDisplay(STRING timezone, BOOLEAN dst, INTEGER style, STRING locale) __ATTRIBUTES__(EXTERNAL "wh_icu");
string zone:="Europe/Amsterdam";
abort([icu_short:=__icu_gettimezonedisplay(zone,false,0,"nl")
      ,icu_long:=__icu_gettimezonedisplay(zone,false,1,"nl")
      ,icu_gmt:=__icu_gettimezonedisplay(zone,false,2,"nl")
      ,icu_short_dst:=__icu_gettimezonedisplay(zone,true,0,"nl")
      ,icu_long_dst:=__icu_gettimezonedisplay(zone,true,1,"nl")
      ,icu_gmt_dst:=__icu_gettimezonedisplay(zone,true,2,"nl")
      ]);
//*/
/*
datetime now := getcurrentdatetime();
datetime local := utctolocal(now,"Pacific/Bougainville");
datetime back := localtoutc(local,"Pacific/Bougainville");
//datetime local := utctolocal(now,"europe/amsterdam");
//datetime back := localtoutc(local,"europe/amsterdam");
abort([version:=__icu_gettzdataversion(),path:=__icu_getresourcespath(),now:=now,local:=local,back:=back]);
//*/
/*
STRING japanese := "キャンパス";
STRING greek := "Αλφαβητικός Κατάλογος";
STRING russian := "биологическом";
Print(japanese || " => " || TransliterateTextLocalized(japanese) || "\n");
Print(greek || " => " || TransliterateTextLocalized(greek) || "\n");
Print(russian || " => " || TransliterateTextLocalized(russian) || "\n");
Print(russian || " => " || TransliterateTextLocalized(russian) || "\n");
Print(LocalizedToUppercase("üßåñø"));
//*/

MACRO VersionTest()
{
  OpenTest("TestLocalization: VersionTest");

  // ICU version is <major>.<minor>[.<patch>[.<build>]]
  INTEGER ARRAY expected_version :=
      SELECT AS INTEGER ARRAY ToInteger(part, 0)
        FROM ToRecordArray(Tokenize(cur_icu_version, "."), "part");
  INTEGER ARRAY icu_version :=
      SELECT AS INTEGER ARRAY ToInteger(part, 0)
        FROM ToRecordArray(Tokenize(__ICU_GetICUVersion(), "."), "part");
  BOOLEAN newer;
  FOREVERY (INTEGER check FROM expected_version)
  {
    // If the current version doesn't have the part to check, it's out of date (e.g. "56.1" < "56.1.1")
    TestEq(TRUE, Length(icu_version) >= #check + 1, Length(icu_version) || " >= " || (#check + 1));
    // This part must be equal or higher
    TestEq(TRUE, icu_version[#check] >= check, icu_version[#check] || " >= " || check);
    // If the current version part is higher, we don't have to check further parts (e.g. "57.1" > "56.2.1")
    IF (icu_version[#check] > check)
    {
      newer := TRUE;
      BREAK;
    }
  }

  BOOLEAN anynewer;
  IF (newer OR Length(icu_version) > Length(expected_version))
  {
    Print("Installed ICU version is newer than expected: " || __ICU_GetICUVersion() || " > " || cur_icu_version || "\n");
    anynewer := TRUE;
  }

  // TZ data version is <year><lowercase letter>, which can be compared alphabetically
  TestEq(TRUE, __ICU_GetTZDataVersion() >= cur_tzdata_version);
  IF (__ICU_GetTZDataVersion() > cur_tzdata_version)
  {
    Print("Installed TZ data version is newer than expected: " || __ICU_GetTZDataVersion() || " > " || cur_tzdata_version || "\n");
    anynewer := TRUE;
  }

  IF(anynewer)
  {
    Print("Note: newer than expected is not necessarily a problem, but please report this if you see ICU-related issues\n");
  }


  CloseTest("TestLocalization: VersionTest");
}

MACRO LocalizeDateTimeTest()
{
  OpenTest("TestLocalization: LocalizeDateTimeTest");
  STRING format;
  DATETIME value := MakeDateTime(2010,10,2,13,24,35);

  // By default, show year, month and day numerical
  format := "dMy";
  TestEq("10/2/2010", LocalizeDateTime(format, value, "en"));
  TestEq("02/10/2010", LocalizeDateTime(format, value, "en-GB"));
  TestEq("2-10-2010", LocalizeDateTime(format, value, "nl"));
  TestEq("2.10.2010", LocalizeDateTime(format, value, "de"));

  // Show long formats were possible
  format := "EEEEGyMMMMdHms"; // H: 24-hour notation
  TestEq("Saturday, October 2, 2010 AD, 13:24:35", LocalizeDateTime(format, value, "en"));
  TestEq("Saturday, 2 October 2010 AD, 13:24:35", LocalizeDateTime(format, value, "en-GB"));
  TestEq("zaterdag 2 oktober 2010 n.Chr. 13:24:35", LocalizeDateTime(format, value, "nl"));
  TestEq("Samstag, 2. Oktober 2010 n. Chr., 13:24:35", LocalizeDateTime(format, value, "de"));
  format := "EEEEGyMMMMdhms"; // h: 12-hour notation (am/pm marker is added)
  TestEq("Saturday, October 2, 2010 AD, 1:24:35 PM", LocalizeDateTime(format, value, "en"));
  TestEq("Saturday, 2 October 2010 AD, 1:24:35 pm", LocalizeDateTime(format, value, "en-GB"));
  TestEq("zaterdag 2 oktober 2010 n.Chr. 1:24:35 p.m.", LocalizeDateTime(format, value, "nl"));
  // The German am/pm identifier has changed several times between "vorm."/"nachm." and "AM"/"PM". It's "vorm."/"nachm." in
  // ICU4C 60.2 (CLDR 32.0.1), which we're using for building WebHare, but changed back to "AM"/"PM" in ICU4C 62.1 (CLDR 33.1),
  // which is the current version on development systems. We'll do a like test for now.
  //TestEq("Samstag, 2. Oktober 2010 n. Chr., 1:24:35 PM", LocalizeDateTime(format, value, "de"));
  TestEqLike("Samstag, 2. Oktober 2010 n. Chr., 1:24:35 ?*", LocalizeDateTime(format, value, "de"));
  format := "EEEEGyMMMMdjms"; // j: locale-specific notation
  TestEq("Saturday, October 2, 2010 AD, 1:24:35 PM", LocalizeDateTime(format, value, "en"));
  TestEq("Saturday, 2 October 2010 AD, 13:24:35", LocalizeDateTime(format, value, "en-GB"));
  TestEq("zaterdag 2 oktober 2010 n.Chr. 13:24:35", LocalizeDateTime(format, value, "nl"));
  TestEq("Samstag, 2. Oktober 2010 n. Chr., 13:24:35", LocalizeDateTime(format, value, "de"));

  // Show 2-digit values
  format := "yyMMddHHmmss";
  TestEq("10/02/10, 13:24:35", LocalizeDateTime(format, value, "en"));
  TestEq("02/10/10, 13:24:35", LocalizeDateTime(format, value, "en-GB"));
  TestEq("02-10-10 13:24:35", LocalizeDateTime(format, value, "nl"));
  TestEq("02.10.10, 13:24:35", LocalizeDateTime(format, value, "de"));

  // Use and show specific timezone
  format := "yMMddjjmmssz";
  TestEq("10/02/2010, 03:24:35 PM GMT+2", LocalizeDateTime(format, value, "en", "Europe/Amsterdam")); // Specifying 'z' also results in 'a' being added
  TestEq("02/10/2010, 15:24:35 CEST", LocalizeDateTime(format, value, "en-GB", "Europe/Amsterdam"));
  TestEq("02-10-2010 15:24:35 CEST", LocalizeDateTime(format, value, "nl", "Europe/Amsterdam"));
  TestEq("02.10.2010, 15:24:35 MESZ", LocalizeDateTime(format, value, "de", "Europe/Amsterdam"));

  // FormatDateTime compatibility test
  format := "%Y-%m-%d %#H:%M:%S";
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("en")), LocalizeDateTime(GetLocalizeFormatString(format), value, "en", "", TRUE));
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("nl")), LocalizeDateTime(GetLocalizeFormatString(format), value, "nl", "", TRUE));
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("de")), LocalizeDateTime(GetLocalizeFormatString(format), value, "de", "", TRUE));
  format := "%A, %#d %b, %#I o'clock %p";
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("en")), LocalizeDateTime(GetLocalizeFormatString(format), value, "en", "", TRUE));
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("nl")), LocalizeDateTime(GetLocalizeFormatString(format), value, "nl", "", TRUE));
  TestEq(FormatDateTime(format, value, GetLocalizedDatetimeStrings("de")), LocalizeDateTime(GetLocalizeFormatString(format), value, "de", "", TRUE));

  CloseTest("TestLocalization: LocalizeDateTimeTest");
}

MACRO LocalizeNumberTest()
{
  OpenTest("TestLocalization: LocalizeNumberTest");
  INTEGER integer_value := 123456789;
  MONEY money_value := 12345.6789;
  FLOAT float_value := 1.2345678;
  MONEY negative_value := -1.25;

  TestEq("123456789", LocalizeNumber(integer_value, 0, FALSE, FALSE, "en"));
  TestEq("123,456,789", LocalizeNumber(integer_value, 0, TRUE, FALSE, "en"));
  TestEq("123456789", LocalizeNumber(integer_value, 0, FALSE, TRUE, "en"));
  TestEq("123,456,789", LocalizeNumber(integer_value, 0, TRUE, TRUE, "en"));
  TestEq("123456789.000", LocalizeNumber(integer_value, 3, FALSE, FALSE, "en"));
  TestEq("123,456,789.000", LocalizeNumber(integer_value, 3, TRUE, FALSE, "en"));
  TestEq("123456789", LocalizeNumber(integer_value, 3, FALSE, TRUE, "en"));
  TestEq("123,456,789", LocalizeNumber(integer_value, 3, TRUE, TRUE, "en"));

  TestEq("123456789", LocalizeNumber(integer_value, 0, FALSE, FALSE, "nl"));
  TestEq("123.456.789", LocalizeNumber(integer_value, 0, TRUE, FALSE, "nl"));
  TestEq("123456789", LocalizeNumber(integer_value, 0, FALSE, TRUE, "nl"));
  TestEq("123.456.789", LocalizeNumber(integer_value, 0, TRUE, TRUE, "nl"));
  TestEq("123456789,000", LocalizeNumber(integer_value, 3, FALSE, FALSE, "nl"));
  TestEq("123.456.789,000", LocalizeNumber(integer_value, 3, TRUE, FALSE, "nl"));
  TestEq("123456789", LocalizeNumber(integer_value, 3, FALSE, TRUE, "nl"));
  TestEq("123.456.789", LocalizeNumber(integer_value, 3, TRUE, TRUE, "nl"));

  TestEq("12345.6789", LocalizeNumber(money_value, 0, FALSE, FALSE, "en"));
  TestEq("12,345.6789", LocalizeNumber(money_value, 0, TRUE, FALSE, "en"));
  TestEq("12346", LocalizeNumber(money_value, 0, FALSE, TRUE, "en"));
  TestEq("12,346", LocalizeNumber(money_value, 0, TRUE, TRUE, "en"));
  TestEq("12345.6789", LocalizeNumber(money_value, 3, FALSE, FALSE, "en"));
  TestEq("12,345.6789", LocalizeNumber(money_value, 3, TRUE, FALSE, "en"));
  TestEq("12345.679", LocalizeNumber(money_value, 3, FALSE, TRUE, "en"));
  TestEq("12,345.679", LocalizeNumber(money_value, 3, TRUE, TRUE, "en"));

  TestEq("12345,6789", LocalizeNumber(money_value, 0, FALSE, FALSE, "nl"));
  TestEq("12.345,6789", LocalizeNumber(money_value, 0, TRUE, FALSE, "nl"));
  TestEq("12346", LocalizeNumber(money_value, 0, FALSE, TRUE, "nl"));
  TestEq("12.346", LocalizeNumber(money_value, 0, TRUE, TRUE, "nl"));
  TestEq("12345,6789", LocalizeNumber(money_value, 3, FALSE, FALSE, "nl"));
  TestEq("12.345,6789", LocalizeNumber(money_value, 3, TRUE, FALSE, "nl"));
  TestEq("12345,679", LocalizeNumber(money_value, 3, FALSE, TRUE, "nl"));
  TestEq("12.345,679", LocalizeNumber(money_value, 3, TRUE, TRUE, "nl"));

  TestEq("1.2345678", LocalizeNumber(float_value, 0, FALSE, FALSE, "en"));
  TestEq("1.2345678", LocalizeNumber(float_value, 0, TRUE, FALSE, "en"));
  TestEq("1", LocalizeNumber(float_value, 0, FALSE, TRUE, "en"));
  TestEq("1", LocalizeNumber(float_value, 0, TRUE, TRUE, "en"));
  TestEq("1.2345678", LocalizeNumber(float_value, 3, FALSE, FALSE, "en"));
  TestEq("1.2345678", LocalizeNumber(float_value, 3, TRUE, FALSE, "en"));
  TestEq("1.235", LocalizeNumber(float_value, 3, FALSE, TRUE, "en"));
  TestEq("1.235", LocalizeNumber(float_value, 3, TRUE, TRUE, "en"));

  TestEq("1,2345678", LocalizeNumber(float_value, 0, FALSE, FALSE, "nl"));
  TestEq("1,2345678", LocalizeNumber(float_value, 0, TRUE, FALSE, "nl"));
  TestEq("1", LocalizeNumber(float_value, 0, FALSE, TRUE, "nl"));
  TestEq("1", LocalizeNumber(float_value, 0, TRUE, TRUE, "nl"));
  TestEq("1,2345678", LocalizeNumber(float_value, 3, FALSE, FALSE, "nl"));
  TestEq("1,2345678", LocalizeNumber(float_value, 3, TRUE, FALSE, "nl"));
  TestEq("1,235", LocalizeNumber(float_value, 3, FALSE, TRUE, "nl"));
  TestEq("1,235", LocalizeNumber(float_value, 3, TRUE, TRUE, "nl"));

  TestEq("-1.25", LocalizeNumber(negative_value, 0, FALSE, FALSE, "en"));
  TestEq("-1", LocalizeNumber(negative_value, 0, FALSE, TRUE, "en"));

  TestEq("-1,25", LocalizeNumber(negative_value, 0, FALSE, FALSE, "nl"));
  TestEq("-1", LocalizeNumber(negative_value, 0, FALSE, TRUE, "nl"));

  CloseTest("TestLocalization: LocalizeNumberTest");
}

MACRO LocalizeCurrencyTest()
{
  OpenTest("TestLocalization: LocalizeCurrencyTest");
  MONEY money_value := 12345.6789;
  MONEY negative_value := -1.23;

  TestEq("€12345.68", LocalizeCurrency(money_value, -1, FALSE, "EUR", "en"));
  TestEq("€12,345.68", LocalizeCurrency(money_value, -1, TRUE, "EUR", "en"));
  TestEq("€12345.679", LocalizeCurrency(money_value, 3, FALSE, "EUR", "en"));
  TestEq("€12,345.679", LocalizeCurrency(money_value, 3, TRUE, "EUR", "en"));

  TestEq("€\u00A012345,68", LocalizeCurrency(money_value, -1, FALSE, "EUR", "nl"));
  TestEq("€\u00A012.345,68", LocalizeCurrency(money_value, -1, TRUE, "EUR", "nl"));
  TestEq("€\u00A012345,679", LocalizeCurrency(money_value, 3, FALSE, "EUR", "nl"));
  TestEq("€\u00A012.345,679", LocalizeCurrency(money_value, 3, TRUE, "EUR", "nl"));

  TestEq("-€1.23", LocalizeCurrency(negative_value, -1, FALSE, "EUR", "en"));
  TestEq("-€1", LocalizeCurrency(negative_value, 0, FALSE, "EUR", "en"));

  TestEq("€\u00A0-1,23", LocalizeCurrency(negative_value, -1, FALSE, "EUR", "nl"));
  TestEq("€\u00A0-1", LocalizeCurrency(negative_value, 0, FALSE, "EUR", "nl"));

  TestEq("$12345.68", LocalizeCurrency(money_value, -1, FALSE, "USD", "en"));
  TestEq("$12,345.68", LocalizeCurrency(money_value, -1, TRUE, "USD", "en"));
  TestEq("$12345.679", LocalizeCurrency(money_value, 3, FALSE, "USD", "en"));
  TestEq("$12,345.679", LocalizeCurrency(money_value, 3, TRUE, "USD", "en"));

  TestEq("US$\u00A012345,68", LocalizeCurrency(money_value, -1, FALSE, "USD", "nl"));
  TestEq("US$\u00A012.345,68", LocalizeCurrency(money_value, -1, TRUE, "USD", "nl"));
  TestEq("US$\u00A012345,679", LocalizeCurrency(money_value, 3, FALSE, "USD", "nl"));
  TestEq("US$\u00A012.345,679", LocalizeCurrency(money_value, 3, TRUE, "USD", "nl"));

  TestEq("-$1.23", LocalizeCurrency(negative_value, -1, FALSE, "USD", "en"));
  TestEq("-$1", LocalizeCurrency(negative_value, 0, FALSE, "USD", "en"));

  TestEq("US$\u00A0-1,23", LocalizeCurrency(negative_value, -1, FALSE, "USD", "nl"));
  TestEq("US$\u00A0-1", LocalizeCurrency(negative_value, 0, FALSE, "USD", "nl"));

  CloseTest("TestLocalization: LocalizeCurrencyTest");
}

MACRO LocalizePercentageTest()
{
  OpenTest("TestLocalization: LocalizePercentageTest");
  FLOAT float_value := .2468;
  FLOAT negative_value := -.2468;

  TestEq("25%", LocalizePercentage(float_value, 0, FALSE, "en"));
  TestEq("24.680%", LocalizePercentage(float_value, 3, FALSE, "en"));

  TestEq("25%", LocalizePercentage(float_value, 0, FALSE, "nl"));
  TestEq("24,680%", LocalizePercentage(float_value, 3, FALSE, "nl"));

  TestEq("-25%", LocalizePercentage(negative_value, 0, FALSE, "en"));
  TestEq("-24.680%", LocalizePercentage(negative_value, 3, FALSE, "en"));

  TestEq("-25%", LocalizePercentage(negative_value, 0, FALSE, "nl"));
  TestEq("-24,680%", LocalizePercentage(negative_value, 3, FALSE, "nl"));

  CloseTest("TestLocalization: LocalizePercentageTest");
}

MACRO LocalizeSpelloutTest()
{
  OpenTest("TestLocalization: LocalizeSpelloutTest");
  INTEGER value := 123456789;

  TestEq("one hundred twenty-three million four hundred fifty-six thousand seven hundred eighty-nine", LocalizeSpellout(value, "en"));
  TestEq("honderddrie\u00ADën\u00ADtwintig miljoen vier\u00ADhonderd\u00ADzes\u00ADen\u00ADvijftig\u00ADduizend\u00ADzeven\u00ADhonderd\u00ADnegen\u00ADen\u00ADtachtig", LocalizeSpellout(value, "nl"));

  CloseTest("TestLocalization: LocalizeSpelloutTest");
}

MACRO LocalizeOrdinalTest()
{
  OpenTest("TestLocalization: LocalizeOrdinalTest");
  INTEGER value := 12345;

  TestEq("12,345th", LocalizeOrdinal(value, "en"));
  TestEq("12.345e", LocalizeOrdinal(value, "nl"));
  TestEq("12.345.", LocalizeOrdinal(value, "de"));

  CloseTest("TestLocalization: LocalizeOrdinalTest");
}

MACRO WorldInfoTest()
{
  OpenTest("TestLocalization: WorldInfoTest");

  RECORD nl := SELECT * FROM GetCountryList("nl") WHERE code = "NL";
  TestEq(TRUE, RecordExists(nl));
  TestEq(TRUE, CellExists(nl, "NL"));
  TestEq("Nederland", nl.NL);
  TestEq(FALSE, CellExists(nl, "EN"));

  nl := SELECT * FROM GetCountryList([ "nl", "en" ]) WHERE code = "NL";
  TestEq(TRUE, RecordExists(nl));
  TestEq(TRUE, CellExists(nl, "NL"));
  TestEq("Nederland", nl.NL);
  TestEq(TRUE, CellExists(nl, "EN"));
  TestEq("Netherlands", nl.EN);

  // Check if Kosovo is returned (not a standard ISO country code)
  nl := SELECT * FROM GetCountryList([ "nl", "en" ]) WHERE code = "XK";
  TestEq(TRUE, RecordExists(nl));
  TestEq(TRUE, CellExists(nl, "NL"));
  TestEq("Kosovo", nl.NL);
  TestEq(TRUE, CellExists(nl, "EN"));
  TestEq("Kosovo", nl.EN);

  nl := SELECT * FROM GetLanguageList("nl") WHERE code = "nl";
  TestEq(TRUE, RecordExists(nl));
  TestEq(TRUE, CellExists(nl, "NL"));
  TestEq("Nederlands", nl.NL);
  TestEq(FALSE, CellExists(nl, "EN"));

  nl := SELECT * FROM GetLanguageList([ "nl", "en" ]) WHERE code = "nl";
  TestEq(TRUE, RecordExists(nl));
  TestEq(TRUE, CellExists(nl, "NL"));
  TestEq("Nederlands", nl.NL);
  TestEq(TRUE, CellExists(nl, "EN"));
  TestEq("Dutch", nl.EN);

  //Matchlanguage
  TestEq(TRUE, MatchLanguage("en","en"));
  TestEq(TRUE, MatchLanguage("en",["en","nl"]));
  TestEq(TRUE, MatchLanguage("EN",["en","nl"]));
  TestEq(TRUE, MatchLanguage("en",["EN","NL"]));
  TestEq(TRUE, MatchLanguage("nl",["EN","NL"]));
  TestEq(FALSE, MatchLanguage("en","en-US"));
  TestEq(TRUE, MatchLanguage("en-US","en-US"));
  TestEq(FALSE, MatchLanguage("en-GB","en-US"));
  TestEq(TRUE, MatchLanguage("en-US","en"));

  CloseTest("TestLocalization: WorldInfoTest");
}

MACRO TransformationTest()
{
  OpenTest("TestLocalization: TransformationTest");

  TestEq("üssåñø", LocalizedToLowercase("ÜSSÅÑØ"));
  TestEq("ÜSSÅÑØ", LocalizedToUppercase("üßåñø"));
  TestEq("≤...<<aeae€ussano", LocalizedNormalizeText("≤…«æÆ€ÜSSÅÑØ"));

  TestEq("Alphabētikós Katálogos", TransliterateTextLocalized("Αλφαβητικός Κατάλογος"));
  TestEq("biologičeskom", TransliterateTextLocalized("биологическом"));
  TestEq("gim, gugsam", TransliterateTextLocalized("김, 국삼"));
  TestEq("takeda, masayuki", TransliterateTextLocalized("たけだ, まさゆき"));

  CloseTest("TestLocalization: TransformationTest");
}

MACRO TestBothConversions(DATETIME localtime, DATETIME gmttime, STRING timezone)
{
  TestEq(gmttime, LocalTOUTC(localtime,timezone));
  TestEq(localtime, UTCToLocal(gmttime,timezone));
}

MACRO TimeZoneTests()
{
  OpenTest("TestLocalization: TimeZoneTests");

  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 18, 00, 00), "CET");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 18, 00, 00), "Cet");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 18, 00, 00), "cet");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 18, 00, 00), "Europe/Amsterdam");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 18, 00, 00), "europe/amsterdam");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 20, 00, 00), "UCT");
  TestBothConversions(MakeDateTime(2003, 04, 24, 20, 00, 00), MakeDateTime(2003, 04, 24, 20, 00, 00), "GMT");

  TestBothConversions(MakeDateTime(2003, 03, 30, 01, 59, 59), MakeDateTime(2003, 03, 30, 00, 59, 59), "CET");
  TestBothConversions(MakeDateTime(2003, 03, 30, 03, 00, 00), MakeDateTime(2003, 03, 30, 01, 00, 00), "CET");

  //02:00 CET is ambiguous, LocalToUTC should return interpret it as standard time
  TestBothConversions(MakeDateTime(2002, 10, 27, 02, 00, 00), MakeDateTime(2002, 10, 27, 01, 00, 00), "CET");
  //00:00 UTC should return 02:00 CET, it is interpreted as daylight saving time
  TestEq(MakeDateTime(2002, 10, 27, 02, 00, 00), UTCToLocal(MakeDateTime(2002, 10, 27, 00, 00, 00), "CET"));

  TestBothConversions(MakeDateTime(2002, 10, 27, 03, 00, 00), MakeDateTime(2002, 10, 27, 02, 00, 00), "CET");

  TestBothConversions(MakeDateTime(2003, 10, 22, 00, 00, 00), MakeDateTime(2003, 10, 21, 22, 00, 00), "CET");

  TestBothConversions(AddTimeToDate(-1, MakeDateTime(1890, 1, 1, 0, 0, 0)), AddTimeToDate(-1, MakeDateTime(1889, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(0, MakeDateTime(1890, 1, 1, 0, 0, 0)), AddTimeToDate(0, MakeDateTime(1889, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(1, MakeDateTime(1890, 1, 1, 0, 0, 0)), AddTimeToDate(1, MakeDateTime(1889, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(-1, MakeDateTime(1969, 1, 1, 0, 0, 0)), AddTimeToDate(-1, MakeDateTime(1968, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(0, MakeDateTime(1969, 1, 1, 0, 0, 0)), AddTimeToDate(0, MakeDateTime(1968, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(1, MakeDateTime(1969, 1, 1, 0, 0, 0)), AddTimeToDate(1, MakeDateTime(1968, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(-1, MakeDateTime(1970, 1, 1, 0, 0, 0)), AddTimeToDate(-1, MakeDateTime(1969, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(0, MakeDateTime(1970, 1, 1, 0, 0, 0)), AddTimeToDate(0, MakeDateTime(1969, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(1, MakeDateTime(1970, 1, 1, 0, 0, 0)), AddTimeToDate(1, MakeDateTime(1969, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(-1, MakeDateTime(1971, 1, 1, 0, 0, 0)), AddTimeToDate(-1, MakeDateTime(1970, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(0, MakeDateTime(1971, 1, 1, 0, 0, 0)), AddTimeToDate(0, MakeDateTime(1970, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(1, MakeDateTime(1971, 1, 1, 0, 0, 0)), AddTimeToDate(1, MakeDateTime(1970, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(-1, MakeDateTime(2040, 1, 1, 0, 0, 0)), AddTimeToDate(-1, MakeDateTime(2039, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(0, MakeDateTime(2040, 1, 1, 0, 0, 0)), AddTimeToDate(0, MakeDateTime(2039, 12, 31, 23, 0, 0)), "CET");
  TestBothConversions(AddTimeToDate(1, MakeDateTime(2040, 1, 1, 0, 0, 0)), AddTimeToDate(1, MakeDateTime(2039, 12, 31, 23, 0, 0)), "CET");

  TestBothConversions(MakeDateTime(1960, 04, 24, 20, 00, 00), MakeDateTime(1960, 04, 24, 19, 00, 00), "CET");
  TestBothConversions(MakeDateTime(1910, 04, 24, 20, 00, 00), MakeDateTime(1910, 04, 24, 19, 40, 28), "EUROPE/AMSTERDAM");

  TestEq(FALSE, IsLocalTimeDST(MakeDateTime(2002, 10, 27, 03, 00, 00), "CET"));
  TestEq(TRUE,  IsLocalTimeDST(MakeDateTime(2003, 03, 30, 03, 00, 00), "CET"));

  TestEq("+0000", GetTimeZoneDisplay("UTC",              FALSE, "offset", "en"));
  TestEq("+0000", GetTimeZoneDisplay("UTC",              TRUE,  "offset", "en"));
  TestEq("+0100", GetTimeZoneDisplay("Europe/Amsterdam", FALSE, "offset", "en"));
  TestEq("+0200", GetTimeZoneDisplay("Europe/Amsterdam", TRUE,  "offset", "nl"));
  TestEq(TRUE,    GetTimeZoneDisplay("UTC",              FALSE, "short",  "nl") IN ["UTC","GMT"]); //UTC = 59.1/2017b
  TestEq("GMT",   GetTimeZoneDisplay("UTC",              TRUE,  "short",  "en"));
  TestEq("GMT+1", GetTimeZoneDisplay("Europe/Amsterdam", FALSE, "short",  "en"));
  TestEq("CEST",  GetTimeZoneDisplay("Europe/Amsterdam", TRUE,  "short",  "nl"));
  TestEq(TRUE,    GetTimeZoneDisplay("UTC",              FALSE, "long",   "nl") IN ["GMT", "Geco\u00F6rdineerde wereldtijd"]); //Geco..tijd = 59.1/2017b
  TestEq("GMT",   GetTimeZoneDisplay("UTC",              TRUE,  "long",   "en"));
  TestEq("Central European Standard Time", GetTimeZoneDisplay("Europe/Amsterdam", FALSE, "long", "en"));
  TestEq("Midden-Europese zomertijd",      GetTimeZoneDisplay("Europe/Amsterdam", TRUE,  "long", "nl"));

  TestEq(1 * 60 * 60 * 1000, GetUTCOffset(MakeDateTime(2002, 10, 27, 03, 00, 00), "CET"));
  TestEq(2 * 60 * 60 * 1000, GetUTCOffset(MakeDateTime(2003, 03, 30, 03, 00, 00), "CET"));

  TestEq("NL", (SELECT AS STRING code FROM GetAvailableTimeZones() WHERE tz = "Europe/Amsterdam"));
  TestEq(TRUE, "Europe/Amsterdam" IN GetAvailableTimeZoneNames());

  // Asia/Kathmandu is known in ICU time zone data by its canonical id Asia/Katmandu
  TestEq("Asia/Katmandu", GetCanonicalTimeZoneID("Asia/Katmandu"));
  TestEq("Asia/Katmandu", GetCanonicalTimeZoneID("Asia/Kathmandu"));
  TestEq("", GetCanonicalTimeZoneID("nonexisting"));
  TestEq(TRUE, "Asia/Katmandu" IN GetAvailableTimeZoneNames());
  TestEq("NP", (SELECT AS STRING code FROM GetAvailableTimeZones() WHERE tz = "Asia/Katmandu"));
  TestEq(FALSE, "Asia/Kathmandu" IN GetAvailableTimeZoneNames());
  TestEq("", (SELECT AS STRING code FROM GetAvailableTimeZones() WHERE tz = "Asia/Kathmandu"));
  TestEq("NP", (SELECT AS STRING code FROM GetAvailableTimeZones() WHERE tz = GetCanonicalTimeZoneID("Asia/Kathmandu")));

  // In the Dutch locale, the weekend starts at Saturday 0:00 and ends at Monday 0:00
  TestEq(FALSE, IsWeekend(MakeDateTime(2015, 6, 19, 23, 59, 59), "nl"));
  TestEq(TRUE,  IsWeekend(MakeDate(2015, 6, 20), "nl"));
  TestEq(TRUE,  IsWeekend(MakeDateTime(2015, 6, 21, 23, 59, 59), "nl"));
  TestEq(FALSE, IsWeekend(MakeDate(2015, 6, 22), "nl"));

  // In the Arabian locale, the weekend starts at Friday 0:00 and ends at Sunday 0:00
  TestEq(FALSE, IsWeekend(MakeDateTime(2015, 6, 18, 23, 59, 59), "ar"));
  TestEq(TRUE,  IsWeekend(MakeDate(2015, 6, 19), "ar"));
  TestEq(TRUE,  IsWeekend(MakeDateTime(2015, 6, 20, 23, 59, 59), "ar"));
  TestEq(FALSE, IsWeekend(MakeDate(2015, 6, 21), "ar"));

  CloseTest("TestLocalization: TimeZoneTests");
}

MACRO ComparisonTest()
{
  OpenTest("TestLocalization: ComparisonTest");
  FUNCTION PTR compare;

  // By default in (American) English, the order is 'a', 'A', 'ä', 'b'; punctuation matters, and numbers are sorted alphabetically
  compare := MakeCompareFunction("en", "", FALSE, FALSE);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("b", "a") > 0);
  TestEq(TRUE, compare("a", "A") < 0);
  TestEq(TRUE, compare("A", "b") < 0);
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("A", "ä") < 0);
  TestEq(TRUE, compare("ä", "b") < 0);
  TestEq(TRUE, compare("a.", ".a") != 0);
  TestEq(TRUE, compare("1", "2") < 0);
  TestEq(TRUE, compare("10", "2") < 0);

  // Sensitivity base: case and accents are ignored when comparing
  compare := MakeCompareFunction("en", "base", FALSE, FALSE);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") = 0);
  TestEq(TRUE, compare("a", "ä") = 0);
  TestEq(TRUE, compare("A", "ä") = 0);

  // Sensitivity accent: case is ignored when comparing
  compare := MakeCompareFunction("en", "accent", FALSE, FALSE);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") = 0);
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("A", "ä") < 0);

  // Sensitivity case: accent is ignored when comparing (does not work correctly yet)
  compare := MakeCompareFunction("en", "case", FALSE, FALSE);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") < 0);
//ADDME:  TestEq(TRUE, compare("a", "ä") = 0);
  TestEq(TRUE, compare("A", "ä") < 0);

  // In Swedish, ä is sorted after z
  compare := MakeCompareFunction("sv", "", FALSE, FALSE);
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("ä", "b") > 0);

  // Punctuation can be ignored
  compare := MakeCompareFunction("en", "", TRUE, FALSE);
  TestEq(TRUE, compare("a.", ".a") = 0);

  // Sort number numerical instead of alphabetical
  compare := MakeCompareFunction("en", "", FALSE, TRUE);
  TestEq(TRUE, compare("1", "2") < 0);
  TestEq(TRUE, compare("10", "2") > 0);

  // Sort uppercase before lowercase
  compare := MakeCompareFunction("en", "", FALSE, FALSE, "upper");
  TestEq(TRUE, compare("a", "A") > 0);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("A", "b") < 0);

  // Sort lowercase before uppercase
  compare := MakeCompareFunction("en", "", FALSE, FALSE, "lower");
  TestEq(TRUE, compare("a", "A") < 0);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("A", "b") < 0);

  CloseTest("TestLocalization: ComparisonTest");
}

MACRO CollatorTest()
{
  OpenTest("TestLocalization: CollatorTest");
  FUNCTION PTR compare;

  // By default in (American) English, the order is 'a', 'A', 'ä', 'b'; punctuation matters, and numbers are sorted alphabetically
  compare := NEW Collator("en")->compare;
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("b", "a") > 0);
  TestEq(TRUE, compare("a", "A") < 0);
  TestEq(TRUE, compare("A", "b") < 0);
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("A", "ä") < 0);
  TestEq(TRUE, compare("ä", "b") < 0);
  TestEq(TRUE, compare("a.", ".a") != 0);
  TestEq(TRUE, compare("1", "2") < 0);
  TestEq(TRUE, compare("10", "2") < 0);

  // Sensitivity base: case and accents are ignored when comparing
  compare := NEW Collator("en", [ sensitivity := "base" ])->compare;
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") = 0);
  TestEq(TRUE, compare("a", "ä") = 0);
  TestEq(TRUE, compare("A", "ä") = 0);

  // Sensitivity accent: case is ignored when comparing
  compare := NEW Collator("en", [ sensitivity := "accent" ])->compare;
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") = 0);
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("A", "ä") < 0);

  // Sensitivity case: accent is ignored when comparing (does not work correctly yet)
  compare := NEW Collator("en", [ sensitivity := "case" ])->compare;
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("a", "A") < 0);
//ADDME:  TestEq(TRUE, compare("a", "ä") = 0);
  TestEq(TRUE, compare("A", "ä") < 0);

  // In Swedish, ä is sorted after z
  compare := NEW Collator("sv")->compare;
  TestEq(TRUE, compare("a", "ä") < 0);
  TestEq(TRUE, compare("ä", "b") > 0);

  // Punctuation can be ignored
  compare := NEW Collator("en", [ ignorepunctuation := TRUE ])->compare;
  TestEq(TRUE, compare("a.", ".a") = 0);

  // Sort number numerical instead of alphabetical
  compare := NEW Collator("en", [ numeric := TRUE ])->compare;
  TestEq(TRUE, compare("1", "2") < 0);
  TestEq(TRUE, compare("10", "2") > 0);

  // Sort uppercase before lowercase
  compare := NEW Collator("en", [ casefirst := "upper" ])->compare;
  TestEq(TRUE, compare("a", "A") > 0);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("A", "b") < 0);

  // Sort lowercase before uppercase
  compare := NEW Collator("en", [ casefirst := "lower" ])->compare;
  TestEq(TRUE, compare("a", "A") < 0);
  TestEq(TRUE, compare("a", "b") < 0);
  TestEq(TRUE, compare("A", "b") < 0);

  CloseTest("TestLocalization: CollatorTest");
}

MACRO DateTimeFormatTest()
{
  OpenTest("TestLocalization: DateTimeFormatTest");
  FUNCTION PTR format;
  DATETIME value := MakeDateTime(2010,10,2,13,24,35);
  RECORD options;

  // By default, show year, month and day numerical
  format := NEW DateTimeFormat("en", options)->format;
  TestEq("10/2/2010", format(value));
  format := NEW DateTimeFormat("en-GB", options)->format;
  TestEq("02/10/2010", format(value));
  format := NEW DateTimeFormat("nl", options)->format;
  TestEq("2-10-2010", format(value));
  format := NEW DateTimeFormat("de", options)->format;
  TestEq("2.10.2010", format(value));

  // Show long formats were possible
  options := [ weekday := "long", era := "short", year := "numeric", month := "long", day := "numeric", hour := "numeric", minute := "numeric", second := "numeric" ];
  format := NEW DateTimeFormat("en", options)->format;
  TestEq("Saturday, October 2, 2010 AD, 1:24:35 PM", format(value));
  format := NEW DateTimeFormat("en-GB", options)->format;
  TestEq("Saturday, 2 October 2010 AD, 13:24:35", format(value));
  format := NEW DateTimeFormat("nl", options)->format;
  TestEq("zaterdag 2 oktober 2010 n.Chr. 13:24:35", format(value));
  format := NEW DateTimeFormat("de", options)->format;
  TestEq("Samstag, 2. Oktober 2010 n. Chr., 13:24:35", format(value));

  // Show 2-digit values
  options := [ year := "2-digit", month := "2-digit", day := "2-digit", hour := "2-digit", minute := "2-digit", second := "2-digit" ];
  format := NEW DateTimeFormat("en", options)->format;
  TestEq("10/02/10, 01:24:35 PM", format(value));
  format := NEW DateTimeFormat("en-GB", options)->format;
  TestEq("02/10/10, 13:24:35", format(value));
  format := NEW DateTimeFormat("nl", options)->format;
  TestEq("02-10-10 13:24:35", format(value));
  format := NEW DateTimeFormat("de", options)->format;
  TestEq("02.10.10, 13:24:35", format(value));

  // Use and show specific timezone
  options := [ year := "numeric", month := "2-digit", day := "2-digit", hour := "2-digit", minute := "2-digit", second := "2-digit", timezone := "Europe/Amsterdam", timezonename := "short" ];
  format := NEW DateTimeFormat("en", options)->format;
  TestEq("10/02/2010, 03:24:35 PM GMT+2", format(value));
  format := NEW DateTimeFormat("en-GB", options)->format;
  TestEq("02/10/2010, 15:24:35 CEST", format(value));
  format := NEW DateTimeFormat("nl", options)->format;
  TestEq("02-10-2010 15:24:35 CEST", format(value));
  format := NEW DateTimeFormat("de", options)->format;
  TestEq("02.10.2010, 15:24:35 MESZ", format(value));

  CloseTest("TestLocalization: DateTimeFormatTest");
}

MACRO NumberFormatTest()
{
  OpenTest("TestLocalization: NumberFormatTest");
  FUNCTION PTR format;
  INTEGER integervalue := 123456789;
  MONEY moneyvalue := 12345.6789;
  FLOAT percentvalue := .2468;
  RECORD options;

  // Normally, show plain numbers, use grouping, max 3 fraction digits
  format := NEW NumberFormat("en", options)->format;
  TestEq("123,456,789", format(integervalue));
  TestEq("12,345.679", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("123.456.789", format(integervalue));
  TestEq("12.345,679", format(moneyvalue));

  // If currency style is requested, a currency must be specified
  STRING error;
  TRY
  {
    options := [ style := "currency" ];
    format := NEW NumberFormat("en", options)->format;
  }
  CATCH (OBJECT e)
  {
    error := e->what;
  }
  TestEq("No currency provided", error);

  // Currency formatting: show currency symbol, use grouping, max 2 fraction digits for Euro
  options := [ style := "currency", currency := "EUR" ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("€123,456,789.00", format(integervalue));
  TestEq("€12,345.68", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("€\u00A0123.456.789,00", format(integervalue));
  TestEq("€\u00A012.345,68", format(moneyvalue));

  // Currency formatting: show currency symbol followed by non-braking space, no grouping, max 3 fraction digits for Bahraini Dinar
  options := [ style := "currency", usegrouping := FALSE, currency := "BHD" ];
  format := NEW NumberFormat("en", options)->format;
  // ICU4C 62.1 introduced whitespace between currency symbol and number, but we still have to support ICU4C 60.2 (see top)
  //TestEq("BHD\u00A0123456789.000", format(integervalue));
  //TestEq("BHD\u00A012345.679", format(moneyvalue));
  TestEqLike("BHD*123456789.000", format(integervalue));
  TestEqLike("BHD*12345.679", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("BHD\u00A0123456789,000", format(integervalue));
  TestEq("BHD\u00A012345,679", format(moneyvalue));

  // Percentage formatting: show percent sign, use grouping, no fraction digits
  options := [ style := "percent" ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("25%", format(percentvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("25%", format(percentvalue));

  // No grouping
  options := [ usegrouping := FALSE ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("123456789", format(integervalue));
  TestEq("12345.679", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("123456789", format(integervalue));
  TestEq("12345,679", format(moneyvalue));

  // Minimum number of integer and fraction digits
  options := [ minimumintegerdigits := 6, minimumfractiondigits := 6 ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("123,456,789.000000", format(integervalue));
  TestEq("012,345.678900", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("123.456.789,000000", format(integervalue));
  TestEq("012.345,678900", format(moneyvalue));

  // Maximum fraction digits
  options := [ maximumfractiondigits := 1 ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("12,345.7", format(moneyvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("12.345,7", format(moneyvalue));

  // Percentage with minimum 2 fraction digits
  options := [ style := "percent", minimumfractiondigits := 2 ];
  format := NEW NumberFormat("en", options)->format;
  TestEq("24.68%", format(percentvalue));
  format := NEW NumberFormat("nl", options)->format;
  TestEq("24,68%", format(percentvalue));

  CloseTest("TestLocalization: NumberFormatTest");
}


Print("\n === Running TestLocalization\n");
VersionTest();
// Formatting functions
LocalizeDateTimeTest();
LocalizeNumberTest();
LocalizeCurrencyTest();
LocalizePercentageTest();
LocalizeSpelloutTest();
LocalizeOrdinalTest();
// World info
WorldInfoTest();
// Text transformations
TransformationTest();
// Time zone support
TimeZoneTests();
// Comparison
ComparisonTest();
// Intl, Collator, DateTimeFormat, NumberFormat
CollatorTest();
DateTimeFormatTest();
NumberFormatTest();
