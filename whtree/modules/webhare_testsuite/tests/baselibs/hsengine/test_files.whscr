<?wh
/// @short File library tests

LOADLIB "wh::os.whlib";
LOADLIB "wh::internal/filetypes.whlib";
LOADLIB "wh::internal/hsselftests.whlib";
LOADLIB "wh::internal/testfuncs.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/csv.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::javascript.whlib";


RECORD ARRAY errors;

MACRO CSVTest()
{
  OpenTest("CSVTest");

  //Simple test with newlines (to verify, save content below as 3.csv and open in excel)
  STRING input := '"A","B""X","C"\r\n"D","E\r\nF","G"\r\n\r\nH,"I\n",J\rK,"L\rM",N';

  TestEq( [ [ tokens := ['A','B"X','C'] ]
          , [ tokens := ['D','E\nF','G'] ]
          , [ tokens := ['H','I\n','J'] ]
          , [ tokens := ['K','L\nM','N'] ]
          ]
        , ParseCSVRows(StringToBlob(input), [ astokenarray := TRUE ]));

  //Test whether various quote behaviours match excel exactly (to verify, save content below as 1.csv and open in excel)
  STRING testdata:=`A;B;C
A";""B";C
A""B;C
A"B"C;D
A""B"";C
"A";B;C
 "A";B;C
"A"B;C
"A"B";C
""""A"";B
`;

  TestEq( [ [ tokens := [ 'A',      'B', 'C' ] ]
          , [ tokens := [ 'A"',     'B"','C' ] ]
          , [ tokens := [ 'A""B',   'C' ] ]
          , [ tokens := [ 'A"B"C',  'D' ] ]
          , [ tokens := [ 'A""B""', 'C' ] ]
          , [ tokens := [ 'A',      'B', 'C' ] ]
          , [ tokens := [ ' "A"',   'B', 'C' ] ]
          , [ tokens := [ 'AB',     'C' ] ]
          , [ tokens := [ 'AB"',    'C' ] ]
          , [ tokens := [ '"A""',   'B' ] ]
          ]
        , ParseCSVRows(StringToBlob(testdata), [ astokenarray := TRUE ]));

  //UTF-8 inside suspected ISO-8859-1 but adaptive UTF-8 enabled: should work
  TestEq( [ [ tokens := ["ABC\u20ACDEF"] ] ] , ParseCSVRows(StringToBlob("ABC\u20ACDEF"), [ encoding := "ISO-8859-1", acceptutf8 := TRUE, astokenarray := TRUE ]));
  //UTF-8 inside suspected ISO-8859-1 but adaptive UTF-8 disabld: individual UTF-8 bytes are translated, giving 2 chars + 1 gibberish
  TestEq( [ [ tokens := ["ABC\u00E2?\u00ACCDEF"] ] ] , ParseCSVRows(StringToBlob("ABC\u20ACCDEF"), [ encoding := "ISO-8859-1", acceptutf8 := FALSE, astokenarray := TRUE ]));
  //ISO-88591 inside suspected ISO-8859-1 and adaptive UTF-8 enabled: should work
  TestEq( [ [ tokens := ["ABC\u00F6DEF"] ] ] , ParseCSVRows(StringToBlob("ABC\xF6DEF"), [ encoding := "ISO-8859-1", acceptutf8 := TRUE, astokenarray := TRUE ]));
  //ISO-88591 inside suspected ISO-8859-1 and adaptive UTF-8 disabled: should work
  TestEq( [ [ tokens := ["ABC\u00F6DEF"] ] ] , ParseCSVRows(StringToBlob("ABC\xF6DEF"), [ encoding := "ISO-8859-1", acceptutf8 := FALSE, astokenarray := TRUE ]));

  STRING testdatawithheaders := `name;email
Pietje;pietje@example.com;really
Jan;jan@example.com
Klaas`;

  TestEq( [ [ tokens := [ 'name','email' ] ]
          , [ tokens := [ 'Pietje','pietje@example.com', 'really' ] ]
          , [ tokens := [ 'Jan','jan@example.com' ] ]
          , [ tokens := [ 'Klaas' ] ]
          ]
        , ParseCSVRows(StringToBlob(testdatawithheaders), [ astokenarray := TRUE ]));

  TestEq( [ [ name := "Pietje", email := "pietje@example.com", C := "really" ]
          , [ name := 'Jan', email := "jan@example.com", C := "" ]
          , [ name := 'Klaas', email := "", C := "" ]
          ]
        , ParseCSVRows(StringToBlob(testdatawithheaders)));

  TestEq( [ [ A := "name", B := "email", C := "" ]
          , [ A := "Pietje", B := "pietje@example.com", C := "really" ]
          , [ A := 'Jan', B := "jan@example.com", C := "" ]
          , [ A := 'Klaas', B := "", C := "" ]
          ]
        , ParseCSVRows(StringToBlob(testdatawithheaders), [ processheaders := FALSE ]));

  CloseTest("CSVTest");
}

MACRO CSVCreateTest()
{
  DATETIME now := makeDatetime(2011,12,8,7,58,12);
  DATETIME sometime := makeDatetime(2011,11,9,6,6,6);
  RECORD ARRAY rows :=
      [ [ title := "Title 1", bool := TRUE, date := now, int := 17,    time:=now, time2 := GetMsecondCount(now), moneyfield := 1.5 ]
      , [ title := "=file:///etc/passwd", bool := FALSE, date := sometime, int := 666, time:=sometime, time2 := MakeTime(6, 6, 6), moneyfield := 2.5 ]
      ];

  RECORD ARRAY columns :=
    [ [ name := "title", title := "Col 1:title", type := "text" ]
    , [ name := "bool",  title := "Col 2:bool",  type := "boolean" ]
    , [ name := "date",  title := "Col 3:date",  type := "date"    , storeutc := TRUE ]
    , [ name := "int",   title := "Col 4:int",   type := "integer" ]
    , [ name := "time",  title := "Col 5:time",  type := "time" , storeutc := TRUE ]
    , [ name := "time2",  title := "Col 6:time2",  type := "timestamp"  ]
    , [ name := "moneyfield",  title := "Col 7:moneyfield",  type := "money"  ]
    ];

  OBJECT csvout;

  csvout := NEW CSVColumnFileWriter;
  csvout->columns := columns;
  csvout->booleans_to_yesno := TRUE;
  csvout->timezone := "CET";
  csvout->languagecode := "NL";
  csvout->WriteRows(rows);

  TestEq('\"Col 1:title\";\"Col 2:bool\";\"Col 3:date\";\"Col 4:int\";\"Col 5:time\";\"Col 6:time2\";\"Col 7:moneyfield\"\r\n\"Title 1\";\"ja\";\"08-12-2011\";\"17\";\"8:58:12\";\"7:58:12\";\"1.5\"\r\n\"\'=file:///etc/passwd\";\"nee\";\"09-11-2011\";\"666\";\"7:06:06\";\"6:06:06\";\"2.5\"\r\n'
  , BlobToString(csvout->MakeOutputFile(),-1));

  //Also test the auto-detect
  csvout := NEW CSVColumnFileWriter;
  csvout->WriteRows(rows);
  TestEq('\"TITLE\";\"BOOL\";\"INT\";\"MONEYFIELD\";\"DATE\";\"TIME\";\"TIME2\"\r\n\"Title 1\";\"true\";\"17\";\"1.5\";\"08-12-2011 7:58:12\";\"08-12-2011 7:58:12\";\"28692000\"\r\n\"\'=file:///etc/passwd\";\"false\";\"666\";\"2.5\";\"09-11-2011 6:06:06\";\"09-11-2011 6:06:06\";\"21966000\"\r\n'
        , BlobToString(csvout->MakeOutputFile(),-1));

}

MACRO LoopbackReaders()
{
  OpenTest("TestFiles: LoopbackReaders");
  STRING testsrcdata := "Dit is een test\r\nDit is er nog een\nEn dit is de laatste";
  BLOB testdata := StringToBlob(testsrcdata);
  INTEGER testfile;

  testfile := OpenBlobAsFile(testdata);
  TestEq( "Dit is een test", ReadLineFrom(testfile,1024,TRUE));
  TestEq( "Dit is er nog een", ReadLineFrom(testfile,1024,TRUE));
  TestEq( "En dit is de laatste", ReadLineFrom(testfile,1024,TRUE));
  TestEq( "", ReadLineFrom(testfile,1024,TRUE));
  CloseBlobFile(testfile);

  testfile := OpenBlobAsFile(testdata);
  TestEq( "Dit is een test\r\n", ReadLineFrom(testfile,1024,FALSE));
  TestEq( "Dit is er nog een\n", ReadLineFrom(testfile,1024,FALSE));
  TestEq( "En dit is de laatste", ReadLineFrom(testfile,1024,FALSE));
  TestEq( "", ReadLineFrom(testfile,1024,FALSE));
  CloseBlobFile(testfile);

  testfile := OpenBlobAsFile(testdata);
  TestEq( "Dit is", ReadLineFrom(testfile,6,FALSE));
  TestEq( " een test\r", ReadLineFrom(testfile,10,FALSE));
  TestEq( "\n", ReadLineFrom(testfile,11,FALSE));
  TestEq( "Dit is er n", ReadLineFrom(testfile,11,FALSE));
  CloseBlobFile(testfile);

  testfile := OpenBlobAsFile(testdata);
  TestEq( "Dit is", ReadLineFrom(testfile,6,TRUE));
  TestEq( " een test", ReadLineFrom(testfile,10,TRUE));
  TestEq( "", ReadLineFrom(testfile,11,TRUE));
  TestEq( "Dit is er n", ReadLineFrom(testfile,11,TRUE));
  CloseBlobFile(testfile);

  testfile := OpenBlobAsFile(testdata);
  STRING data := ReadFromFile(testfile,GetFilelength(testfile));
  TestEq( testsrcdata, data);
  CloseBlobFile(testfile);

  /* Make sure the buffering works (read in chunks of out of the 32k buffer to check whether the chopping works properly) */
  testsrcdata := Left(testsrcdata,7);
  STRING totaldata;
  INTEGER passes := (4*32768)/Length(testsrcdata);
  FOR(INTEGER i:=0;i<passes;i:=i+1)
    totaldata := totaldata || testsrcdata;

  testdata := StringToBlob(totaldata);
  testfile := OpenBlobAsFile(testdata);
  FOR(INTEGER i:=0;i<passes;i:=i+1)
  {
    STRING input := ReadFrom(testfile, Length(testsrcdata));
    TestEq(Substring(totaldata,i*Length(testsrcdata),Length(testsrcdata)), input);
  }
  CloseBlobFile(testfile);

  testfile := OpenBlobAsFile(StringToBlob("regel met r\r erin"));
  TestEq( "regel met r\r erin", ReadLineFrom(testfile,128,TRUE));
  CloseBlobFile(testfile);

  CloseTest("TestFiles: LoopbackReaders");
}

MACRO BufferFilepointertest()
{
  OpenTest("TestFiles: BufferFilepointertest");
  STRING testsrcdata := "Dit is een test\r\nDit is er nog een\nEn dit is de laatste";
  BLOB testdata := StringToBlob(testsrcdata);
  INTEGER testfile;

  /* Test whether file pointer manipulation is not disturbed by buffering */
  testfile := OpenBlobAsFile(testdata);
  TestEq("Dit is een test", ReadLineFrom(testfile,1024,TRUE));
  TestEq(Length("Dit is een test\r\n"), INTEGER(GetFilePointer(testfile)));

  SetFilePointer(testfile, GetFilePointer(testfile)-4);
  TestEq("st", ReadLineFrom(testfile,1024,TRUE));
  CloseBlobFile(testfile);


  /* Now slice it! */
  testdata := MakeSlicedBlob(testdata, 1, Length(testdata)-2);
  testfile := OpenBlobAsFile(testdata);
  TestEq("it is een test", ReadLineFrom(testfile,1024,TRUE));
  TestEq( Length("it is een test\r\n"), INTEGER(GetFilePointer(testfile)));
  SetFilePointer(testfile, GetFilePointer(testfile)-4);
  TestEq("st", ReadLineFrom(testfile,1024,TRUE));
  TestEq("Dit is er nog een", ReadLineFrom(testfile,1024,TRUE));
  TestEq("En dit is de laatst", ReadLineFrom(testfile,1024,TRUE));
  CloseBlobFile(testfile);

  CloseTest("TestFiles: BufferFilepointertest");
}

MACRO BlobManipTest()
{
  OpenTest("TestFiles: BlobManip");

  //Test with empty blob first..
  BLOB simpleblob := DEFAULT BLOB;
  TestEq(0, LENGTH(simpleblob));

  //Test a simple 13-byte blob
  INTEGER newblobstream := CreateStream();
  TestEq(0i64, GetStreamLength(newblobstreaM));
  PrintTo(newblobstream, "Hello, World\n");
  TestEq(13i64, GetStreamLength(newblobstreaM));
  BLOB newblob := MakeBlobFromStream(newblobstream);

  //Test the length of this blob in various ways
  TestEq(13, LENGTH(newblob));
  INTEGER openblob := OpenBlobAsFile(newblob);
  TestEq(13i64, GetFileLength(openblob));
  TestEq(0i64, GetFilePointer(openblob));
  TestEq( "Hello, World\n", ReadFromFile(openblob,100));
  TestEq(13i64, GetFilePointer(openblob));

  //Test setting file pointers
  SetFilePointer(openblob,3);
  TestEq(3i64, GetFilePointer(openblob));
  TestEq( "lo, World\n", ReadFromFile(openblob,100));
  TestEq(TRUE/* no i/o errors */, CloseBlobFile(openblob));

  CloseTest("TestFiles: BlobManip");
}

MACRO ComposedBlobTest()
{
  OpenTest("TestFiles: ComposedBlobTest");

  BLOB ta := StringToBlob("12345");
  BLOB tb := StringToBlob("abcde");

  BLOB tc := MakeComposedBlob(
      [ [ data :=     ta
        , start :=    1i64
        , length :=   3i64
        ]
      , [ data :=     tb
        , start :=    1i64
        , length :=   3i64
        ]
      , [ data :=     ta
        , start :=    1
        ]
      , [ data :=     tb
        , start :=    1
        , length :=   4
        ]
      , [ data :=     ta
        ]
      ]);

  TestEQ("234bcd2345bcde12345", BlobToString(tc, -1));

  CloseTest("TestFiles: ComposedBlobTest");
}

MACRO MiscTest()
{
  OpenTest("TestFiles: MiscTest");

  //Collapse a path (no extensive tests are necessary- blextest alrady deals with that)
  TestEq("f", CollapsePath("b/../c/d/../../e/../../f"));
  TestEq("/f", CollapsePath("/b/../c/d/../../e/../../f"));
  TestEq("b/c/d", CollapsePath("A:/../b/c/d/"));

  TestEq("b-lex", GetBasenameFromPath("/my/dir/b-lex.html"));
  TestEq(".html", GetExtensionFromPath("/my/dir/b-lex.html"));
  TestEq(".htaccess", GetBasenameFromPath("/my/dir/.htaccess"));
  TestEq("", GetExtensionFromPath("/my/dir/.htaccess"));
  TestEq("..", GetBasenameFromPath("/my/dir/.."));
  TestEq("", GetExtensionFromPath("/my/dir/.."));
  TestEq(".htaccess", GetBasenameFromPath("/my/dir/.htaccess.txt"));
  TestEq(".txt", GetExtensionFromPath("/my/dir/.htaccess.txt"));
  TestEq("", GetExtensionFromPath(".txt"));

  //Test openining a nonexisting file
  STRING testfile := "/tmp/does-not-exist-" || GenerateUFS128BitId();
  BLOB testblob := MakeBlobFromDiskfile(testfile);
//  BLOB testblob := OpenTestFile("does-not-exist.txt");
  TestEq(0, Length(testblob));
  TestThrowsLike("No such*file*",PTR GetDiskResource(testfile));
  TestEq(DEFAULT BLOB, GetDiskResource(testfile,[allowmissing := TRUE]));

  TestEq(FALSE, GenerateTemporaryPathname() = GenerateTemporaryPathname());
  TestEq("uber-12-strassen-", GetSafeFileName(".Über '12' _Straßen_.?"));
  TestEq("unknown", GetSafeFileName("????? ??????? ?????????"));
  TestEq("index.html", GetSafeFileName("^index.html"));

  STRING testdir := GenerateTemporaryPathname();
  TestEq(TRUE, CreateDiskDirectory(testdir, TRUE));
  TestEq(TRUE, CreateDiskDirectory(testdir || "/dir1", TRUE));
  TestEq(TRUE, CreateSoftLink(testdir || "/dir2", "dir1"));
  TestEq("dir1", ReadSoftLink(testdir || "/dir2"));
  TestEQ(testdir || "/dir1", GetRealPath(testdir || "/dir2"));
  TestEQ("", GetRealPath(testdir || "/dir3"));
  TestEq(FALSE, DeleteDiskDirectory(testdir|| "/dir2"));
  TestEq(TRUE, DeleteDiskFile(testdir || "/dir2"));
  TestEq(TRUE, CreateSoftLink(testdir || "/dir2", "dir1"));
  TestEq(FALSE, DeleteDiskDirectory(testdir));
  TestEq(TRUE, DeleteDiskDirectoryRecursive(testdir));

  CloseTest("TestFiles: MiscTest");
}

MACRO ArchiveTest()
{
  OpenTest("TestFiles: ArchiveTest");

  {
    DATETIME start := GetCurrentDatetime();
    OBJECT newarchive := CreateNewArchive("zip");
    newarchive->AddFile("file1", StringToBlob("File nummer 1"), MakeDate(2002,1,1));
    newarchive->AddFolder("folder1", MakeDate(2003,4,5));
    newarchive->AddFile("folder1/file2", StringToBlob("File nummer 2"), DEFAULT DATETIME);
    newarchive->AddFolder("folder2", MakeDate(2004,5,6));
    newarchive->AddFolder("folder2/folder3", MakeDate(2005,6,7));

    TestThrowsLike("Invalid path name", PTR newarchive->AddFile(".", DEFAULT BLOB, MakeDate(2002,1,1)));
    TestThrowsLike("Invalid path name", PTR newarchive->AddFolder(".", MakeDate(2002,1,1)));

    BLOB archive := newarchive->MakeBlob();
    newarchive->Close();

    RECORD ARRAY results := UnpackArchive(archive);
    results := SELECT * FROM results ORDER BY path, name;

    TestEq(TRUE, results[2].modtime >= GetRoundedDatetime(start, 2000), "modtime should have been set to 'now' if unspecified");
    TestEq([ [ path := "", name := "file1", modtime := MakeDate(2002,1,1), data := StringToBlob("File nummer 1") ]
           , [ path := "folder1", name := "", modtime := MakeDate(2003,4,5), data := DEFAULT BLOB ]
           , [ path := "folder1", name := "file2", modtime := results[2].modtime, data := StringToBlob("File nummer 2") ]
           , [ path := "folder2", name := "", modtime := MakeDate(2004,5,6), data := DEFAULT BLOB ]
           , [ path := "folder2/folder3", name := "", modtime := MakeDate(2005,6,7), data := DEFAULT BLOB ]
           ], results);
  }


  // Test of rewrite of UnpackArchive via new Archive object
  BLOB ziparchiveblob := OpenTestFile("ziptest.zip");
  RECORD ARRAY results := SELECT * FROM UnpackArchive(ziparchiveblob) ORDER BY path, name;
  TestEqual(10,
      [ [ path := "",                   name := "file1.txt",modtime := MakeDateTime(2009, 3, 12, 14, 58, 26), data := StringToBlob("dit is file1") ]
      , [ path := "folder1",            name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 58, 42), data := DEFAULT BLOB ]
      , [ path := "folder1",            name := "file2.txt",modtime := MakeDateTime(2009, 3, 12, 14, 58, 40), data := StringToBlob("dit is file2") ]
      , [ path := "folder2",            name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 58, 30), data := DEFAULT BLOB ]
      , [ path := "folder2/folder3",    name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 58, 46), data := DEFAULT BLOB ]
      , [ path := "folder2/folder3",    name := "file3.txt",modtime := MakeDateTime(2009, 3, 12, 14, 58, 34), data := StringToBlob("dit is file3") ]
      ], results);

  BLOB targzarchiveblob := OpenTestFile("ziptest.tar.gz");
  results := SELECT * FROM UnpackArchive(targzarchiveblob) ORDER BY path, name;
  TestEqual(11,
      [ [ path := "",                   name := "file1.txt",modtime := MakeDateTime(2009, 3, 12, 13, 58, 26), data := StringToBlob("dit is file1") ]
      , [ path := "folder1",            name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 23, 21), data := DEFAULT BLOB ]
      , [ path := "folder1",            name := "file2.txt",modtime := MakeDateTime(2009, 3, 12, 13, 58, 40), data := StringToBlob("dit is file2") ]
      , [ path := "folder2",            name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 23, 21), data := DEFAULT BLOB ]
      , [ path := "folder2/folder3",    name := "",         modtime := MakeDateTime(2009, 3, 12, 14, 23, 21), data := DEFAULT BLOB ]
      , [ path := "folder2/folder3",    name := "file3.txt",modtime := MakeDateTime(2009, 3, 12, 13, 58, 34), data := StringToBlob("dit is file3") ]
      ], results);

  // New unpacking API

//  BLOB ziparchiveblob := OpenTestFile("ziptest.zip");
  {
    OBJECT ziparchive := OpenExistingArchive(ziparchiveblob);

    RECORD ARRAY zipentries :=
        SELECT *
             , data := type = 0 ? BlobToString(ziparchive->GetFile(fullpath), -1) : ""
          FROM ziparchive->entries
      ORDER BY fullpath;

    TestEqual(20,
        [ [ fullpath := "file1.txt",                  path := "",                   name := "file1.txt",    type := 0, modtime := MakeDateTime(2009, 3, 12, 14, 58, 26), size := 12, size64 := 12i64, data := "dit is file1" ]
        , [ fullpath := "folder1",                    path := "folder1",            name := "",             type := 1, modtime := MakeDateTime(2009, 3, 12, 14, 58, 42), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder1/file2.txt",          path := "folder1",            name := "file2.txt",    type := 0, modtime := MakeDateTime(2009, 3, 12, 14, 58, 40), size := 12, size64 := 12i64, data := "dit is file2" ]
        , [ fullpath := "folder2",                    path := "folder2",            name := "",             type := 1, modtime := MakeDateTime(2009, 3, 12, 14, 58, 30), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder2/folder3",            path := "folder2/folder3",    name := "",             type := 1, modtime := MakeDateTime(2009, 3, 12, 14, 58, 46), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder2/folder3/file3.txt",  path := "folder2/folder3",    name := "file3.txt",    type := 0, modtime := MakeDateTime(2009, 3, 12, 14, 58, 34), size := 12, size64 := 12i64, data := "dit is file3" ]
        ], zipentries);

    TestEq("", ziparchive->archivecomment);

    ziparchive->archivecomment := "testcommentaar";
    ziparchive->RemoveEntries("", "file1.txt");
    ziparchive->RemoveEntries("folder2", "*");
    ziparchive->RemoveEntries("folder1", "file2.txt");

    ziparchive->AddFile("folder1/file4.txt",         StringToBlob("dit is file4"), MakeDateTime(2009, 3, 1,  10,  0,  2));
    ziparchive->AddFolder("folder2/folder5",                                       MakeDateTime(2009, 3, 2,  10,  0,  4));
    ziparchive->AddFile("folder2/folder5/file6.txt", StringToBlob("dit is file6"), MakeDateTime(2009, 3, 3,  10,  0,  6));

    BLOB newarchive := ziparchive->MakeBlob();
    ziparchive->Close();

    ziparchive := OpenExistingArchive(newarchive);

    zipentries :=
        SELECT *
             , data := type = 0 ? BlobToString(ziparchive->GetFile(fullpath), -1) : ""
          FROM ziparchive->entries
      ORDER BY fullpath;

    TestEqual(22,
        [ [ fullpath := "folder1",                    path := "folder1",            name := "",             type := 1, modtime := MakeDateTime(2009, 3, 12, 14, 58, 42), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder1/file4.txt",          path := "folder1",            name := "file4.txt",    type := 0, modtime := MakeDateTime(2009, 3, 1,  10,  0,  2), size := 12, size64 := 12i64, data := "dit is file4" ]
        , [ fullpath := "folder2",                    path := "folder2",            name := "",             type := 1, modtime := MakeDateTime(2009, 3, 12, 14, 58, 30), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder2/folder5",            path := "folder2/folder5",    name := "",             type := 1, modtime := MakeDateTime(2009, 3, 2,  10,  0,  4), size := 0,  size64 := 0i64,  data := "" ]
        , [ fullpath := "folder2/folder5/file6.txt",  path := "folder2/folder5",    name := "file6.txt",    type := 0, modtime := MakeDateTime(2009, 3, 3,  10,  0,  6), size := 12, size64 := 12i64, data := "dit is file6" ]
        ], zipentries);

//    TestEq("testcommentaar", ziparchive->archivecomment);

    ziparchive->Close();
  }

  /* An archive consisting of
     lvl1.jpg
     map2/lvl2.jpg
     map2/map3/lvl3.jpg
     map2/map3/lvl3b.jpg
     and their respective forks
  */

  RECORD ARRAY macarchive :=
    [ [ path := "", name := "lvl1.jpg" ]
    , [ path := "__MACOSX", name := "" ]
    , [ path := "__MACOSX", name := "._lvl1.jpg" ]
    , [ path := "map2", name := "" ]
    , [ path := "map2", name := "lvl2.jpg" ]
    , [ path := "__MACOSX/map2", name := "" ]
    , [ path := "__MACOSX/map2", name := "._lvl2.jpg" ]
    , [ path := "map2/map3", name := "" ]
    , [ path := "map2/map3", name := "lvl3.jpg" ]
    , [ path := "__MACOSX/map2/map3", name := "" ]
    , [ path := "__MACOSX/map2/map3", name := "._lvl3.jpg" ]
    , [ path := "map2/map3", name := "lvl3b.jpg" ]
    , [ path := "__MACOSX/map2/map3", name := "._lvl3b.jpg" ]
    ];

  TestEqual(31,5,length(select from macarchive where name='')); //folders
  TestEqual(32,8,length(select from macarchive where name!='')); //files
  macarchive := FilterMacOSForksFromArchive(macarchive);
  TestEqual(33,4,length(select from macarchive where name!='')); //files
  TestEqual(34,2,length(select from macarchive where name='')); //folders

  /* A junky archive (someone moved files into the __macosx dir
     lvl1.jpg
     and its fork
     __macosx/map2/blabla
     __macosx/map3/.lvl3.jpg
  */

  macarchive :=
    [ [ path := "", name := "lvl1.jpg" ]
    , [ path := "__MACOSX", name := "" ]
    , [ path := "__MACOSX", name := "._lvl1.jpg" ]
    , [ path := "__MACOSX/map2", name := "" ]
    , [ path := "__MACOSX/map2", name := "blabla" ]
    , [ path := "__MACOSX/map3", name := "" ]
    , [ path := "__MACOSX/map3", name := "._lvl3.jpg" ]
    ];

  TestEqual(35,3,length(select from macarchive where name='')); //folders
  TestEqual(36,4,length(select from macarchive where name!='')); //files
  macarchive := FilterMacOSForksFromArchive(macarchive);
  TestEqual(37,2,length(select from macarchive where name!='')); //files
  TestEqual(38,2,length(select from macarchive where name='')); //folders

  BLOB originaldata := StringToBlob("0123456789");
  STRING output;
  IF (NOT IsWasm())
  {
    // create a zip by streaming (will have compressed size and crc in local file header set to 0)
    OBJECT proc := CreateProcess("zip", [ "-r", "-", "-" ], [ take_input := TRUE, take_output := TRUE, take_errors := TRUE ]);
    proc->Start();
    SendBlobTo(proc->input_handle, originaldata); // small enough for buffers
    proc->CloseInput();
    output := ReadFromFile(proc->output_handle, 1000000); // should fit
    proc->Close();
  }
  ELSE
    output := DecodeUFS("UEsDBC0ACAAIAMddKFcAAAAA__________8BABQALQEAEAAAAAAAAAAAAAAAAAAAAAAAMzA0MjYxNTO3sAQAUEsHCMbHhKYMAAAAAAAAAAoAAAAAAAAAUEsBAh4DLQAIAAgAx10oV8bHhKYMAAAACgAAAAEAAAAAAAAAAQAAALARAAAAAC1QSwUGAAAAAAEAAQAvAAAAVwAAAAAA");

  TestEQMembers(
      [ [ name := "-"
        , path := ""
        , data := originaldata
        ]
      ], UnpackArchive(StringToBlob(output)), "*");

  CloseTest("TestFiles: ArchiveTest");
}

MACRO ZlibTest()
{
  OpenTest("TestFiles: ArchiveEncodingTest");

  BLOB ziparchiveblob := OpenTestFile("encoded.zip");

  BLOB encoded_gzip := MakeZlibCompressedFile(ziparchiveblob,"GZIP",5);
  TestEq(ziparchiveblob, MakeZlibDecompressedFile(encoded_gzip,"GZIP"));

/*  BLOB encoded_zlib := MakeZlibCompressedFile(ziparchiveblob,"ZLIB",5);
  TestEq(ziparchiveblob, MakeZlibDecompressedFile(encoded_zlib,"ZLIB"));
*/
  BLOB encoded_zlibraw := MakeZlibCompressedFile(ziparchiveblob,"ZLIBRAW",5);
  BLOB encoded_zlibraw_withjunk := StringToBlob(BlobToString(encoded_zlibraw,-1) || "GARBAGE");
  TestEq(ziparchiveblob, MakeZlibDecompressedFile(encoded_zlibraw_withjunk,"ZLIBRAW:"||Length(encoded_zlibraw)));

  INTEGER out := CreateStream();
  INTEGER compressor := CreateZlibCompressor(out, "ZIP", 9);
  PrintTo(compressor, "abc");
  TestEQ("352441C2", EncodeBase16(CloseZlibCompressor(compressor).crc32));
  MakeBlobFromStream(out);

  CloseTest("TestFiles: ArchiveEncodingTest");
}

MACRO ArchiveEncodingTest()
{
  OpenTest("TestFiles: ArchiveEncodingTest");

  {
    BLOB ziparchiveblob := OpenTestFile("encoded.zip");
    RECORD ARRAY results := SELECT * FROM UnpackArchive(ziparchiveblob) ORDER BY path, name;
    TestEqual(1,
        [ [ path := "", name := "t\u20ACst.txt" ,modtime := MakeDateTime(2009, 5, 29, 16, 06, 48), data := StringToBlob("test") ]
        ], results);
  }

  {
    BLOB ziparchiveblob := OpenTestFile("encoded.zip");
    OBJECT archive := OpenExistingArchive(ziparchiveblob);
    archive->AddFile("newfile", StringToBlob(RepeatText("abcd", 1024*1024)), GetCurrentDateTime());
    BLOB newarchive := archive->MakeBlob();
    TestEQ(TRUE, LENGTH64(newarchive) < LENGTH(ziparchiveblob) + 100000, "Compression should be enabled when adding files to existing archives");
  }

  {
    OBJECT newarchive := CreateNewArchive("zip");
    newarchive->AddFile("t\u20ACst", StringToBlob("File nummer 1"), MakeDate(2002,1,1));

    BLOB archive := newarchive->MakeBlob();
    newarchive->Close();
    RECORD ARRAY results := UnpackArchive(archive);
    TestEq([ [ path := "", name := "t\u20ACst", modtime := MakeDate(2002,1,1), data := StringToBlob("File nummer 1") ] ]
              ,results);
  }

  CloseTest("TestFiles: ArchiveEncodingTest");
}


MACRO RedirectTest()
{
  OpenTest("TestFiles: RedirectTest");

  BOOLEAN saved_show_test_progress := show_test_progress;
  show_test_progress := FALSE;

  TestEq(0, RedirectOutputTo(0));

  INTEGER testblobstream := CreateStream();
  PrintTo(testblobstream,"1234567");
  BLOB testblob := MakeBlobFromStream(testblobstream);

  INTEGER newstr := CreateStream();
  PrintTo(newstr,"test");
  RedirectOutputTo(newstr);
  TestEq(newstr, RedirectOutputTo(newstr));
  Print("test2");
  SendBlobTo(0,testblob);

  ?>987654321<?wh //Prints 987654321 through harescript.

  BLOB finalblob := MakeBlobFromStream(newstr);

  RedirectOutputTo(0);
  TestEq(0, RedirectOutputTo(0));
  TestEq(4 + 5 + 7 + 9, Length(finalblob));

  show_test_progress := saved_show_test_progress;

  RECORD result;
  result := TestCompileAndRun('<?wh PrintTo(12345,"beeh"); ');
  MustContainError(999, result.errors, 185, "12345"); //invalid output id
  result := TestCompileAndRun('<?wh RedirectOutputTo(12345); Print("beeh"); ');
  MustContainError(999, result.errors, 206, "12345"); //invalid redirected output id

  CloseTest("TestFiles: RedirectTest");
}

STRING FUNCTION UncachedReadFile(STRING path)
{
  INTEGER fileid := OpenDiskFile(path, TRUE);
  STRING content := ReadFromFile(fileid, 16384);
  CloseDiskFile(fileid);
  RETURN content;
}

MACRO FSTest()
{
  OpenTest("TestFIles: FSTest");

  STRING temppath := GenerateTemporaryPathname();
  INTEGER outfile := CreateDiskFile(temppath, FALSE, TRUE);
  TestEq(TRUE, outfile>0);
  PrintTo(outfile,"abcdef");
  TestEq(6i64, GetFilelength(outfile));
  TestEq(TRUE, CloseDiskFile(outfile));

  BLOB outfileblob := MakeBLobFromDiskFile(temppath);
  TestEq(6, Length(outfileblob));
  TestEq(6, Length(BLobToString(outfileblob,7)));

  outfile := OpenDiskFile(temppath, TRUE);
  TestEq(TRUE, outfile>0);
  STRING outfilestring := ReadFromFile(outfile, 10);
  TestEq(6, Length(outfilestring));
  SetDiskFileLength(outfile, 0);
  PrintTo(outfile,"abcdef");
  TestEq(6i64, GetFilelength(outfile));
  TestEq(TRUE, CloseDiskFile(outfile));

  TestEq(TRUE, DeleteDiskFile(temppath));
  TestEq(6, Length(outfileblob));

  STRING tempdir := GenerateTemporaryPathname();
  CreateDiskDirectory(tempdir, TRUE);
  BLOB dirblob := MakeBlobFromDiskFile(tempdir);
  INTEGER dontcrash := OpenBlobAsFile(dirblob);
  TestEq(TRUE, dontcrash > 0); //ADDME are we sure it must always succeed to open a directory?
  STRING nodata := ReadFrom(dontcrash,24);
  TestEq("", nodata);
  TestEq(0i64, GetFileLength(dontcrash));
  CloseBlobFile(dontcrash);

  StoreDiskFile(MergePath(tempdir, "1.txt"), StringToBlob("test 1"), [ inplace := FALSE ]);
  TestEq("test 1", UncachedReadFile(MergePath(tempdir, "1.txt")));

  StoreDiskFile(MergePath(tempdir, "2.txt"), StringToBlob("test 2"), [ inplace := TRUE ]);
  TestEq("test 2", UncachedReadFile(MergePath(tempdir, "2.txt")));

  TestThrowsLike("*it already exists*", PTR StoreDiskFile(MergePath(tempdir, "2.txt"), StringToBlob("test 3"), [ inplace := FALSE ]));
  TestThrowsLike("*it already exists*", PTR StoreDiskFile(MergePath(tempdir, "2.txt"), StringToBlob("test 3"), [ inplace := TRUE ]));
  TestEq("test 2", UncachedReadFile(MergePath(tempdir, "2.txt")));

  StoreDiskFile(MergePath(tempdir, "1.txt"), StringToBlob("test 4"), [ overwrite := TRUE, inplace := FALSE ]);
  TestEq("test 4", UncachedReadFile(MergePath(tempdir, "1.txt")));

  StoreDiskFile(MergePath(tempdir, "1.txt"), StringToBlob("test 5"), [ overwrite := TRUE, inplace := TRUE ]);
  TestEq("test 5", UncachedReadFile(MergePath(tempdir, "1.txt")));

  StoreDiskFile(MergePath(tempdir, RepeatText("3",240)||".txt"), StringToBlob("test 6"), [ inplace := TRUE ]);
  TestEq("test 6", UncachedReadFile(MergePath(tempdir, RepeatText("3",240)||".txt")));

  StoreDiskFile(MergePath(tempdir, RepeatText("4",240)||".txt"), StringToBlob("test 7"), [ inplace := FALSE ]);
  TestEq("test 7", UncachedReadFile(MergePath(tempdir, RepeatText("4",240)||".txt")));

  //FIXME: Also think up a fix for DeleteDiskFile with an open file interaction

  CloseTest("TestFIles: FSTest");
}

MACRO ScanBlobTest()
{
  RECORD detect := ScanBlob(StringToBlob("GIF89a"),"xxx.gif"); //used to cause a record-does-not-exist
  TestEq("application/octet-stream", detect.mimetype);

  TestEq("application/octet-stream", ScanBlob(DEFAULT BLOB, "test.txt").mimetype);
  TestEq("text/html", ScanBlob(STringToBLob(' <!doctype html> ')).mimetype);
  TestEq("text/html", ScanBlob(STringToBLob('<!DOCTYPE html> <title>x</title>')).mimetype);
  TestEq("text/html", ScanBlob(DEFAULT BLOB, "test.txt", [ mimetype := "text/html" ]).mimetype);

  BLOB mkv := StringToBlob(DecodeBase64("GkXfo6NChoEBQveBAULygQRC84EIQoKIbWF0cm9za2FCh4EEQoWBAhhTgGcBAAAAAAY"));
  TestEq("video/x-matroska", ScanBlob(mkv,"").mimetype);

  BLOB dummygif := StringToBlob(DecodeBase16("47494638396101000100800000ffffffffffff21f90401000000002c00000000010001000002024401003b"));
  detect := WrapBlob(dummygif, "", [ extractdominantcolor := TRUE, generatehash := TRUE]);
  TestEq("image/gif", detect.mimetype);
  TestEq("noname.gif", detect.filename);
  TestEq("transparent", detect.dominantcolor);
  TestEq("hy_6nckd_mgbm-gsu0HLzcCYXnerJ-FYPjjYThVDy3Q", detect.hash);

  //test robustness against broken canvas
  detect := WrapBlob(MakeSlicedBlob(dummygif,0,20), "", [ extractdominantcolor := TRUE]);
  TestEq("", detect.dominantcolor);

  detect := WrapBlob(dummygif,"bladiebla.png");
  TestEq("image/gif", detect.mimetype);
  TestEq(".gif", detect.extension);
  TestEq("bladiebla.png", detect.filename);

  detect := ScanBlob(dummygif,"bladiebla.png");
  ValidateScannedData(detect); // Make sure it doesn't contain a 'mediaType' property from WASM's analyzeImage
  TestEq("image/gif", detect.mimetype);
  TestEq(".gif", detect.extension);

  detect := WrapBlob(dummygif,"bladiebla.*");
  ValidateWrappedData(detect);
  TestEq("image/gif", detect.mimetype);
  TestEq(".gif", detect.extension);
  TestEq("bladiebla.gif", detect.filename);

  //edge cases
  TestEq(".gif", WrapBlob(dummygif,".*").filename);
  TestEq("*.gif", WrapBlob(dummygif,"*.*").filename);

  //unknown extension
  TestEq("test", WrapBlob(StringToBlob("hoi!"),"test.*").filename);

  //short text files
  TestEq("text/plain", WrapBlob(StringToBlob("test"),"test.txt").mimetype);
  TestEq("application/octet-stream", WrapBlob(StringToBlob("test"),"").mimetype);

  RECORD imgl1 := ScanBlob(OpenTestFile("exif/landscape_1.jpg"),"");
  TestEq(600, imgl1.width);
  TestEq("image/jpeg", imgl1.mimetype);

  imgl1 := ScanBlob(OpenTestFile("exif/landscape_1.jpg"),"",[mimetype := "text/html"]);
  TestEq(0, imgl1.width);
  TestEq("text/html", imgl1.mimetype);

  // Test decoding a non-zip file with .zip extension
  TestEQMembers(
      [ mimetype := "application/octet-stream"
      ], ScanBlob(StringToBlob("PK\x03\x04" || RepeatText("\x00", 256)), "test.zip"),
      "*");
}

MACRO TestRelativePath()
{
  TestEq("c", ResolveToRelativePath("/a/b/", "/a/b/c"));
  TestEq("../c", ResolveToRelativePath("/a/b/", "/a/c"));
  TestEq("../../c", ResolveToRelativePath("/a/b/", "/c"));
  TestEq("../../c/d", ResolveToRelativePath("/a/b/", "/c/d"));
  TestEq("../d", ResolveToRelativePath("a/b/", "a/d"));
  TestEq("d", ResolveToRelativePath("a/b", "a/d"));
  TestEq("../d", ResolveToRelativePath("a/b/c", "a/d"));
}

MACRO TestModTimes()
{
  STRING tempdir := GenerateTemporaryPathname();
  CreateDiskDirectoryRecursive(tempdir, TRUE);

  STRING testfilepath := MergePath(tempdir, "file.dat");
  RECORD props;

  FOR (INTEGER i := 0; i < 10; i := i + 1)
  {
    DeleteDiskFile(testfilepath);
    StoreDiskFile(testfilepath, StringToBlob("file.dat"));
    props := GetDiskFileProperties(testfilepath);
    IF ((GetMSecondCount(props.modified) % 1000) > 5)
      BREAK;
  }

  IF((GetMsecondCount(props.modified) % 1000) != 0) //your filesystem supports sub-second precision
  {
    BLOB blobdata := GetDiskResource(testfilepath);
    DATETIME blobdatamodtime := GetBlobModTime(blobdata);
    TestEQ(props.modified, blobdatamodtime);

    RECORD scan := ReadDiskDirectory(tempdir, "file.dat");
    TestEQ("file.dat", scan.name);
    TestEQ(props.modified, scan.modified);

    // mseconds must be > 5, so subtracting 3 won't get to 0
    DATETIME newdate := AddTimeToDate(-3, props.modified);
    SetFileModificationDate(testfilepath, newdate);
    RECORD newprops := GetDiskFileProperties(testfilepath);
    TestEQ(newdate, newprops.modified);
  }

  DeleteDiskFile(testfilepath);
  DeleteDiskDirectory(tempdir);
}

MACRO TestBlobStream()
{
  INTEGER s := CreateStream();
  TestEQ(0i64, GetStreamLength(s));
  TestEQ(0i64, GetStreamPointer(s));
  PrintTo(s, "a");
  TestEQ(1i64, GetStreamLength(s));
  TestEQ(1i64, GetStreamPointer(s));
  PrintTo(s, "bcdef");
  TestEQ(6i64, GetStreamLength(s));
  TestEQ(6i64, GetStreamPointer(s));
  SetStreamPointer(s, 2i64);
  TestEQ(2i64, GetStreamPointer(s));
  PrintTo(s, "C");
  TestEQ(3i64, GetStreamPointer(s));
  SetStreamPointer(s, 7i64);
  PrintTo(s, "H");
  TestThrowsLike("*negative*", PTR SetStreamPointer(s, -1i64));
  TestEQ("abCdef\x00H", BlobToString(MakeBlobFromStream(s)));
}

LoopbackReaders();
CSVTest();
CSVCreateTest();
FSTest();
ArchiveTest();
BlobManipTest();
ComposedBlobTest();
MiscTest();
RedirectTest();
BufferFilepointertest();
ZlibTest();
ArchiveEncodingTest();
ScanBlobTest();
TestRelativePath();
TestModTimes();
TestBlobStream();
