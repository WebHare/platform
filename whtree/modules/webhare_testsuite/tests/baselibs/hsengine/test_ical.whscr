<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::filetypes/icalendar.whlib";
LOADLIB "wh::internal/hsselftests.whlib";


MACRO TestIcal_IcalEncoding()
{
  OpenTest("TestIcal_IcalEncoding");

  DATETIME date := MakeDate(2013,1,1);
  STRING locationevent := EncodeICalEvent([ dtstart := date, location:="xyz", description := RepeatText("\u20AC", 500) ]);
  /* RFC 5545 allows us to split UTF8 lines (and thus create invalid UTF-8)
     although it does refer to us as a 'simple implementation' if we do that.
     We can't have that, and Thunderbird crashes on it anyway, so lets ensure
     proper UTF8 after splitting */
  TestEq(TRUE, IsValidUTF8(locationevent)); //no truncated utf-8 sequences

  date := MakeDateTime(2000,1,1,12,34,56);
  // For EncodeICalEvent, the supplied tzid is used as supplied (it should match a VTIMEZONE within the calendar)
  STRING timezoneevent := EncodeICalEvent([ dtstart := date, timezone := "SomeID" ]);
  TestEq(`BEGIN:VEVENT\r
DTSTART;TZID=SomeID:20000101T123456\r
END:VEVENT\r
`, timezoneevent);
  // But UTC is handled separately (no TZID, 'Z' added to timestamp)
  timezoneevent := EncodeICalEvent([ dtstart := date, timezone := "UTC" ]);
  TestEq(`BEGIN:VEVENT\r
DTSTART:20000101T123456Z\r
END:VEVENT\r
`, timezoneevent);
  // An empty tzid means a floating timestamp (without any associated time zone)
  timezoneevent := EncodeICalEvent([ dtstart := date, timezone := "" ]);
  TestEq(`BEGIN:VEVENT\r
DTSTART:20000101T123456\r
END:VEVENT\r
`, timezoneevent);
  // tzid defaults to UTC
  timezoneevent := EncodeICalEvent([ dtstart := date ]);
  TestEq(`BEGIN:VEVENT\r
DTSTART:20000101T123456Z\r
END:VEVENT\r
`, timezoneevent);
  // An all-day event doesn't have a time zone
  timezoneevent := EncodeICalEvent([ dtstart := date, timezone := "CET", allday := TRUE ]);
  TestEq(`BEGIN:VEVENT\r
DTSTART;VALUE=DATE:20000101\r
END:VEVENT\r
`, timezoneevent);

  // If a time zone (other than UTC) is specified, the time zone information is added to the calendar
  STRING timezonecalendar := EncodeICalCalendar([ [ dtstart := date, timezone := "europe/amsterdam" ] ]);
  TestEq(`BEGIN:VCALENDAR\r
VERSION:2.0\r
PRODID:-//WebHare bv//NONSGML WebHare Calendar//EN\r
BEGIN:VTIMEZONE\r
TZID:Europe/Amsterdam\r
X-TZINFO:Europe/Amsterdam\r
BEGIN:DAYLIGHT\r
TZOFFSETTO:+020000\r
TZOFFSETFROM:+010000\r
TZNAME:(DST)\r
DTSTART:20000326T020000\r
RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r
END:DAYLIGHT\r
BEGIN:STANDARD\r
TZOFFSETTO:+010000\r
TZOFFSETFROM:+020000\r
TZNAME:(STD)\r
DTSTART:20001029T030000\r
RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r
END:STANDARD\r
END:VTIMEZONE\r
BEGIN:VEVENT\r
DTSTART;TZID=Europe/Amsterdam:20000101T123456\r
END:VEVENT\r
END:VCALENDAR\r
`, timezonecalendar);
  // If multiple events share the same time zone, the time zone information is added to the calendar only once (using the
  // earliest start date)
  timezonecalendar := EncodeICalCalendar(
      [ [ dtstart := AddDaysToDate(1, date), timezone := "europe/amsterdam" ]
      , [ dtstart := date, timezone := "Europe/Amsterdam" ]
      ]);
  TestEq(`BEGIN:VCALENDAR\r
VERSION:2.0\r
PRODID:-//WebHare bv//NONSGML WebHare Calendar//EN\r
BEGIN:VTIMEZONE\r
TZID:Europe/Amsterdam\r
X-TZINFO:Europe/Amsterdam\r
BEGIN:DAYLIGHT\r
TZOFFSETTO:+020000\r
TZOFFSETFROM:+010000\r
TZNAME:(DST)\r
DTSTART:20000326T020000\r
RRULE:FREQ=YEARLY;BYMONTH=3;BYDAY=-1SU\r
END:DAYLIGHT\r
BEGIN:STANDARD\r
TZOFFSETTO:+010000\r
TZOFFSETFROM:+020000\r
TZNAME:(STD)\r
DTSTART:20001029T030000\r
RRULE:FREQ=YEARLY;BYMONTH=10;BYDAY=-1SU\r
END:STANDARD\r
END:VTIMEZONE\r
BEGIN:VEVENT\r
DTSTART;TZID=Europe/Amsterdam:20000102T123456\r
END:VEVENT\r
BEGIN:VEVENT\r
DTSTART;TZID=Europe/Amsterdam:20000101T123456\r
END:VEVENT\r
END:VCALENDAR\r
`, timezonecalendar);
  // If no time zone is specified, UTC is assumed and to time zone information is added
  timezonecalendar := EncodeICalCalendar([ [ dtstart := date ] ]);
  TestEq(`BEGIN:VCALENDAR\r
VERSION:2.0\r
PRODID:-//WebHare bv//NONSGML WebHare Calendar//EN\r
BEGIN:VEVENT\r
DTSTART:20000101T123456Z\r
END:VEVENT\r
END:VCALENDAR\r
`, timezonecalendar);
  // If an empty time zone is specified, floating timestamps are used
  timezonecalendar := EncodeICalCalendar([ [ dtstart := date, timezone := "" ] ]);
  TestEq(`BEGIN:VCALENDAR\r
VERSION:2.0\r
PRODID:-//WebHare bv//NONSGML WebHare Calendar//EN\r
BEGIN:VEVENT\r
DTSTART:20000101T123456\r
END:VEVENT\r
END:VCALENDAR\r
`, timezonecalendar);
  // All-day events don't have time zones
  timezonecalendar := EncodeICalCalendar([ [ dtstart := date, timezone := "europe/amsterdam", allday := TRUE ] ]);
  TestEq(`BEGIN:VCALENDAR\r
VERSION:2.0\r
PRODID:-//WebHare bv//NONSGML WebHare Calendar//EN\r
BEGIN:VEVENT\r
DTSTART;VALUE=DATE:20000101\r
END:VEVENT\r
END:VCALENDAR\r
`, timezonecalendar);

  CloseTest("TestIcal_IcalEncoding");
}

TestIcal_IcalEncoding();
