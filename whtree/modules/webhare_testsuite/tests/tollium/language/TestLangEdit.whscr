<?wh
/* LangEdit.whscr is mixed case to allow us to test tid scanner on mixedcase files */

LOADLIB "wh::files.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::tollium/lib/internal/langedit/langeditor.whlib";

BLOB testdata1 := StringToBlob(
  '<language xml:lang="nl" xmlns="http://www.webhare.net/xmlns/tollium/screens" xmlns:html="http://www.w3.org/1999/xhtml" title="Hollands">'
||  '<textgroup gid="N1">'
||    '<textgroup gid="n4">'
||      '<text tid="aBc">ABC</text>'
||      '<text tid="richie">A<html:b>bold</html:b>C<html:u>underline</html:u> and a <html:a href="#test">link</html:a></text>'
||      '<text tid="xmly">a&lt;b&gt;c</text>'
||      '<text tid="ylinkparameter">A <html:a data-href-param="1">parametered</html:a> link</text>'
||    '</textgroup>'
||    '<textgroup gid="n2">'
||      '<textgroup gid="n3">'
||      '</textgroup>'
||      '<text tid="emptY"></text>'
||    '</textgroup>'
||  '</textgroup>'
||  '<textgroup gid="n5-x" keepemptyreason="daarom">'
||    '<textgroup gid="pruneme">'
||      '<text tid="empty"></text>'
||    '</textgroup>'
||    '<text tid="empty"></text>'
||  '</textgroup>'
||  '<textgroup gid="n6">'
||    '<text tid="a">org1</text>'
||    '<text tid="c">org1</text>'
||  '</textgroup>'
||  '<textgroup gid="n6">'
||    '<text tid="a">org2</text>'
||    '<text tid="b">org2</text>'
||  '</textgroup>'
||'</language>'
);

BLOB testdata2 := StringToBlob(
  '\xEF\xBB\xBF<?xml version="1.0" encoding="UTF-8" ?>\n<language xmlns="http://www.webhare.net/xmlns/tollium/screens" xml:lang="en" xmlns:html="http://www.w3.org/1999/xhtml">\n'
||'  <textgroup gid="n1">   <!-- n1 -->\n'
||'    <textgroup gid="n2">   <!-- n1.n2 -->\n'
||'      <text tid="abc4">A&amp;B&lt;C4 <ifparam p="2" value="2">test</ifparam></text>\n'
||'    </textgroup>\n'
||'    <textgroup gid="n4">   <!-- n1.n4 -->\n'
||'      <text tid="abc">ABC-<param p="1"/> <ifparam p="1" value="1"> minuut <else/> minuten </ifparam></text>\n'
||'      <text tid="def">DEF<br/>n4</text>\n'
||'      <text tid="uni">[faal\tDôF<br/>n4</text>\n'
||'    </textgroup>\n'
||'    <textgroup gid="p1_limited" limitlanguages="en">   <!-- n1.p1_limited -->\n'
||'      <text tid="enonly">EN Only</text>\n'
||'    </textgroup>\n'
||'    <textgroup gid="xcontainsnlonly">   <!-- n1.xcontainsnlonly -->\n' //and should be kept..
||'      <textgroup gid="nl_limited" limitlanguages="nl">   <!-- n1.xcontainsnlonly.nl_limited -->\n'
||'      </textgroup>\n'
||'    </textgroup>\n'
||'  </textgroup>\n'
||'</language>\n'
);

BLOB wittytest := StringToBLob(
'Test [gettid abc]\n'
|| '[gethtmltid def param1 param2]\n'
|| "<span data-texttid='gettid.datatid1'></span>\n"
|| '<span data-texttid="gettid.datatid2"></span>\n');

MACRO TestEarlyGettid()
{
  OBJECT witty := NEW WittyTemplate("HTML");
  witty->LoadCodeDirect(`[gettid "webhare_testsuite:gettid.datatid1"]`);
  TestEq("(cannot find text: webhare_testsuite:gettid.datatid1)",witty->RunToString());
}

MACRO TestEncodeText()
{
  TestEq("a",EncodeLanguageText("a"));
  TestEq('<param p="1"/>',EncodeLanguageText("%1"));
  /* langfiles are a bit odd. we expect < and > to be encoded so we can allow
     <b> and stuff in language files, but safely allow < to be &lt; makes
     & ambiguous

     so for now, we'll encode &amp; to just remain &amp;

     if the texteditor moves to rich text, we can probably avoid all this mess
     and just keep the backend storage in pure html */
  TestEq('a&lt;b',EncodeLanguageText("a<b"));
  TestEq('a&gt;b',EncodeLanguageText("a>b"));
  TestEq('a&amp;b',EncodeLanguageText("a&b"));
  TestEq('a&amp;b',EncodeLanguageText("a&amp;b"));

  TestEq('<html:a href="https://www.webhare.com/">Hare!</html:a>',EncodeLanguageText('<a href="https://www.webhare.com/">Hare!</a>'));
  TestEq('<html:a data-href-param="1">Hare!</html:a>',EncodeLanguageText('<a href="%1">Hare!</a>'));
}


MACRO ReaderTest()
{
  OBJECT langfile := OpenLanguageFile(MakeXMLDocument(testdata1));
  TestEq("nl", langfile->langcode);

  OBJECT basegroup := langfile->basegroup;
  TestEq(3, Length(basegroup->nodes));
  TestEq(TRUE, basegroup->nodes[0].isgroup);
  TestEq(FALSE, basegroup->keepifempty);
  TestEq("", basegroup->keepemptyreason);
  TestEq("n1", basegroup->nodes[0].name);

  TestEq(TRUE, basegroup->nodes[1].isgroup);
  TestEq("n5-x", basegroup->nodes[1].name);

  OBJECT group_n1 := basegroup->nodes[0].textgroup;
  TestEq(FALSE, group_n1->keepifempty);
  TestEq("", group_n1->keepemptyreason);
  TestEq(1, Length(group_n1->nodes));
  TestEq("n4", group_n1->nodes[0].name);
  TestEq(TRUE, group_n1->nodes[0].isgroup);

  OBJECT group_n1_n4 := group_n1->nodes[0].textgroup;
  TestEq(4, Length(group_n1_n4->nodes));
  TestEq("abc", group_n1_n4->nodes[0].name);
  TestEq("ABC", group_n1_n4->nodes[0].text);
  TestEq(FALSE, group_n1_n4->nodes[0].isgroup);
  TestEq("richie", group_n1_n4->nodes[1].name);
  TestEq("A<b>bold</b>C<u>underline</u> and a <a href=\"#test\">link</a>", group_n1_n4->nodes[1].text);
  TestEq('A <a href="%1">parametered</a> link', group_n1_n4->nodes[3].text);
  TestEq(FALSE, group_n1_n4->nodes[1].isgroup);
  TestEq("xmly", group_n1_n4->nodes[2].name);
  TestEq("a&lt;b&gt;c", group_n1_n4->nodes[2].text);
  TestEq(FALSE, group_n1_n4->nodes[2].isgroup);

  OBJECT group_n5 := basegroup->nodes[1].textgroup;
  TestEq(TRUE, group_n5->keepifempty);
  TestEq("daarom", group_n5->keepemptyreason);
  //The empty text should remain but the group should be gone (as keepifempty works only at group level)
  TestEq(1, Length(group_n5->nodes));
  TestEq(FALSE, group_n5->nodes[0].isgroup);
  TestEq("empty", group_n5->nodes[0].name);

  TestEq("n6", basegroup->nodes[2].name);
  OBJECT group_n6 := basegroup->nodes[2].textgroup;

  TestEq(3, Length(group_n6->nodes));
  TestEq("a", group_n6->nodes[0].name);
  TestEq("org2", group_n6->nodes[0].text);
  TestEq(FALSE, group_n6->nodes[0].isgroup);
  TestEq("b", group_n6->nodes[1].name);
  TestEq("org2", group_n6->nodes[1].text);
  TestEq(FALSE, group_n6->nodes[1].isgroup);
  TestEq("c", group_n6->nodes[2].name);
  TestEq("org1", group_n6->nodes[2].text);
  TestEq(FALSE, group_n6->nodes[2].isgroup);

  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata2));
  TestEq("en", langfile_en->langcode);

  OBJECT group_p1 := langfile_en->basegroup->nodes[0].textgroup->nodes[2].textgroup;
  TestEQ(["en"], group_p1->limitlanguages);
}

MACRO WriterTest1()
{
  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata1));
  BLOB langfile := langfile_en->MakeLanguageFile();
  langfile_en := OpenLanguageFile(MakeXMLDocument(langfile));

  OBJECT basegroup := langfile_en->basegroup;
  OBJECT group_n1 := basegroup->nodes[0].textgroup;
  OBJECT group_n1_n4 := group_n1->nodes[0].textgroup;
  TestEq("A<b>bold</b>C<u>underline</u> and a <a href=\"#test\">link</a>", group_n1_n4->nodes[1].text);
  TestEq("Hollands", langfile_en->title);
}

MACRO WriterTest2()
{
  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata2));
  BLOB langfile := langfile_en->MakeLanguageFile();

  IF(testfw->debug)
  {
    Print("Expect:\n");
    SendBlobTo(0,testdata2);
    Print("\nActual:\n");
    SendBlobto(0,langfile);
  }
  TestEq(testdata2, langfile);

  OBJECT comp := CombineLanguageFiles([langfile_en]);
  langfile := comp->MakeLanguageFile("en");
  //SendBlobto(0,langfile); print("\n\n"); SendBlobTo(0,testdata2);
  TestEq(testdata2, langfile);

  //add some empty stuff, shouldn't influence external file size
  comp->AddTids( ["blexis", "test.x.y.z", "commondialogs.dialogs.cannotdeletestage_invoiceables"] );

  langfile := comp->MakeLanguageFile("en");
  //SendBlobto(0,langfile); print("\n\n ^^ generated version, original vv \n"); SendBlobTo(0,testdata2);
  TestEq(testdata2, langfile);

  //add a new group, mark it as keep non empty, and ensure it was saved
  comp->AddTids( ["keepme.blabla", "keepme.chuchu.removethis" ]);
  comp->basegroup->GetTextGroup("keepme")->keepemptyreason := "hierom";
  comp->basegroup->GetTextGroup("keepme")->limitlanguages := ["nl"];

  langfile := comp->MakeLanguageFile("en");
  SendBlobto(0,langfile); print("\n\n"); SendBlobTo(0,testdata2);
  OBJECT langfile_readback := OpenLanguageFile(MakeXMLDocument(langfile));
  comp := CombineLanguageFiles([langfile_readback]);

  OBJECT keepmegroup := comp->basegroup->GetTextGroup("keepme");

  TestEq(TRUE, ObjectExists(keepmegroup));
  TestEq(TRUE, keepmegroup->keepifempty);
  TestEq("hierom", keepmegroup->keepemptyreason);
  TestEq(0, keepmegroup->GetTextPos("blabla"));
  TestEq(["nl"],keepmegroup->limitlanguages);
  keepmegroup->SetRawText("blabla", 0, "a&b"); //set a corrupted text

  TestEq(FALSE, ObjectExists(keepmegroup->GetTextGroup("chuchu")));

/* FIXME this needs fixing, but is pretty hard to do with the current language
   editor. we should probably just keep everything in XML, and manipulate that
   directly - probably makes it easier to implement rich editing too

  //verify the corrupted text didn't destroy the language file
  langfile := comp->MakeLanguageFile("en");
  langfile_readback := OpenLanguageFile(MakeXMLDocument(langfile));
  comp := CombineLanguageFiles([langfile_readback]);
  keepmegroup := comp->basegroup->GetTextGroup("keepme");
sendblobto(0,langfile);
  TestEq(TRUE, ObjectExists(keepmegroup));
  Testeq("ab", keepmegroup->GetRawText("blabla", 0));
  */
}

MACRO MergeTest()
{
  OBJECT langfile_nl := OpenLanguageFile(MakeXMLDocument(testdata1));
  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata2));

  OBJECT combined := CombineLanguageFiles([langfile_nl,langfile_en]);

  OBJECT basegroup := combined->basegroup;
  TestEq("", basegroup->GetFullGid());
  TestEq(3, Length(basegroup->nodes));
  TestEq(TRUE, basegroup->nodes[0].isgroup);
  TestEq("n1", basegroup->nodes[0].name);
  TestEq(FALSE, basegroup->keepifempty);

  OBJECT group_n1 := basegroup->nodes[0].textgroup;
  TestEq(FALSE, group_n1->keepifempty);
  TestEq("n1", group_n1->GetFullGid());
  TestEq(4, Length(group_n1->nodes));
  TestEq("n2", group_n1->nodes[0].name);
  TestEq(TRUE, group_n1->nodes[0].isgroup);
  TestEq("n4", group_n1->nodes[1].name);
  TestEq(TRUE, group_n1->nodes[1].isgroup);
  TestEq(["en"], group_n1->nodes[2].textgroup->limitlanguages);

  OBJECT group_n1_n2 := group_n1->nodes[0].textgroup;
  TestEq("n1.n2", group_n1_n2->GetFullGid());
  TestEq(1, Length(group_n1_n2->nodes));
  TestEq("abc4", group_n1_n2->nodes[0].name);
  TestEq(2, Length(group_n1_n2->nodes[0].texts));
  TestEq("", group_n1_n2->nodes[0].texts[0]);
  TestEq("A&amp;B&lt;C4 [IF %2=\"2\"]test[/IF]", group_n1_n2->nodes[0].texts[1]);
  TestEq(FALSE, group_n1_n2->nodes[0].isgroup);

  OBJECT group_n1_n4 := group_n1->nodes[1].textgroup;
  TestEq("n1.n4", group_n1_n4->GetFullGid());
  TestEq(6, Length(group_n1_n4->nodes));
  TestEq("abc", group_n1_n4->nodes[0].name);
  TestEq(["ABC","ABC-%1 [IF %1=\"1\"] minuut [ELSE] minuten [/IF]"], group_n1_n4->nodes[0].texts);
  TestEq(['A <a href="%1">parametered</a> link',''], group_n1_n4->nodes[5].texts);
  TestEq(FALSE, group_n1_n4->nodes[0].isgroup);
  TestEq("def", group_n1_n4->nodes[1].name);
  TestEq(["","DEF\nn4"], group_n1_n4->nodes[1].texts);
  TestEq("DEF\nn4", combined->GetRawText('en','n1.n4.def'));
  combined->SetRawText('en','n1.n4.def','abc\nn5');
  TestEq("abc\nn5", combined->GetRawText('en','n1.n4.def'));
  TestEq(["","abc\nn5"], group_n1_n4->nodes[1].texts);
  combined->SetRawText('en','n1.n4.def','DEF\nn4');
  TestEq(FALSE, group_n1_n4->nodes[1].isgroup);
  TestEq("uni", group_n1_n4->nodes[3].name);
  TestEq(["","[[faal\tDôF\nn4"], group_n1_n4->nodes[3].texts);
  TestEq(FALSE, group_n1_n4->nodes[3].isgroup);

  combined->AddTids( ["n1.n4.ABC.x", "n1.n4.CxtraText"] );
  TestEq(4, Length(group_n1->nodes));
  TestEq(8, Length(group_n1_n4->nodes));
  TestEq("cxtratext", group_n1_n4->nodes[1].name);
  TestEq("abc", group_n1_n4->nodes[7].name);

  OBJECT group_n1_n4_abc := group_n1_n4->nodes[7].textgroup;
  TestEq(1, Length(group_n1_n4_abc->nodes));
  TestEq("x", group_n1_n4_abc->nodes[0].name);

  combined->AddTids( ["blexis","commondialogs.dialogs.cannotdeletestage_invoiceables"] );
  TestEq(5, Length(basegroup->nodes));
  TestEq(FALSE, basegroup->nodes[0].isgroup);
  TestEq("blexis", basegroup->nodes[0].name);
  TestEq(TRUE, basegroup->nodes[1].isgroup);
  TestEq("commondialogs", basegroup->nodes[1].name);
  TestEq("dialogs", basegroup->nodes[1].textgroup->nodes[0].name);
  TestEq("cannotdeletestage_invoiceables", basegroup->nodes[1].textgroup->nodes[0].textgroup->nodes[0].name);
  TestEq(["",""],                          basegroup->nodes[1].textgroup->nodes[0].textgroup->nodes[0].texts);

  OBJECT group_n5 := basegroup->nodes[3].textgroup;
  TestEq("n5-x", basegroup->nodes[3].name);
  TestEq(TRUE, group_n5->keepifempty);

  TestEq("n6", basegroup->nodes[4].name);
  OBJECT group_n6 := basegroup->nodes[4].textgroup;
  TestEq(3, Length(group_n6->nodes));
  TestEq("a", group_n6->nodes[0].name);
  TestEq([ "org2", "" ], group_n6->nodes[0].texts);
  TestEq(FALSE, group_n6->nodes[0].isgroup);
  TestEq("b", group_n6->nodes[1].name);
  TestEq([ "org2", "" ], group_n6->nodes[1].texts);
  TestEq(FALSE, group_n6->nodes[1].isgroup);
  TestEq("c", group_n6->nodes[2].name);
  TestEq([ "org1", "" ], group_n6->nodes[2].texts);
  TestEq(FALSE, group_n6->nodes[2].isgroup);

  //Export nodes
  RECORD prepexport := combined->GenerateExport("n1.n4","webhare_testsuite","xx");
  TestEq(3, Length(prepexport.columns));

  BLOB importfile := GetWebhareResource("mod::webhare_testsuite/data/test/tollium/import-languagetexts.xlsx");
  TestEq("DEF\nn4", combined->GetRawText('en','n1.n4.def'));
  TestEq("", combined->GetRawText('nl','n1.n4.def'));
  combined->ImportLanguageFile(importfile);
  TestEq("a<br>b", combined->GetRawText('en','n1.n4.def'));
  TestEq("%%", combined->GetRawText('nl','n1.n4.def'));
  TestEq("schaap%1", combined->GetRawText('nl','n1.n4.uni'));
  TestEq("new_nl", combined->GetRawText('nl','n1.n9.nieuw'));

  //FIXME modify file and reimport

  /* ADDME cleaning up would be nice, but a bit too complex for now:
     - what about limitlang in limitlang
     - unmerged langfile support makes it harder (and not sure why we even have it)
     - fallbacklanguage requiring empty nodes to be kept in all languages makes it harder (and that's been on our fixlist for even longer)

  //add a group inside the ignored selection, it needs to go
  combined->AddTids( ["n1.xcontainsnlonly.nl_limited.subgroup.removeme"]);
  combined->SetRawText("nl", "n1.xcontainsnlonly.nl_limited.subgroup.removeme", "remove me in EN file");

  OBJECT nlresult := MakeXMLDocument(combined->MakeLanguageFile("nl"));
  TestEq(1, nlresult->QuerySelectorAll('text[tid="removeme"]')->length);

  OBJECT enresult := MakeXMLDocument(combined->MakeLanguageFile("en"));
  TestEq(0, nlresult->QuerySelectorAll('text[tid="removeme"]')->length);

  Print(enresult->outerxml);
  abort(1);
  */
}

BLOB testdata_xy := StringToBlob(
  '\xEF\xBB\xBF<?xml version="1.0" encoding="UTF-8" ?>\n<language xmlns="http://www.webhare.net/xmlns/tollium/screens" xml:lang="xy" xmlns:html="http://www.w3.org/1999/xhtml" fallbacklanguage="en">\n'
||'  <textgroup gid="n1">   <!-- n1 -->\n'
||'    <textgroup gid="n4">   <!-- n1.n4 -->\n'
||'      <text tid="def">DEF<br/>n4</text>\n'
||'    </textgroup>\n'
||'  </textgroup>\n'
||'</language>\n'
);

MACRO FallbackTest()
{
  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata2));
  OBJECT langfile_xy := OpenLanguageFile(MakeXMLDocument(testdata_xy));

  OBJECT combined := CombineLanguageFiles([langfile_en,langfile_xy]);
  TestEq("", combined->GetFallbackLanguage(0));
  TestEq("en", combined->GetFallbackLanguage(1));

  OBJECT basegroup_en := langfile_en->basegroup;
  OBJECT group_en_n1 := basegroup_en->nodes[0].textgroup;
  OBJECT group_en_n1_n4 := group_en_n1->nodes[1].textgroup;

  OBJECT basegroup_xy := langfile_xy->basegroup;
  OBJECT group_xy_n1 := basegroup_xy->nodes[0].textgroup;
  OBJECT group_xy_n1_n4 := group_xy_n1->nodes[0].textgroup;

//  combined->AddTids(["n1.n4.testadd"]);

  BLOB langfile_xy_out := combined->MakeLanguageFile("xy");
  IF(testfw->debug)
  {
    sendblobto(0,langfile_xy_out);
  }
  TestEq(langfile_xy_out, testdata_xy);
}

MACRO SyntaxTest()
{
  TestEq(TRUE, IsValidLangfileText(""));
  TestEq(FALSE, IsValidLangfileText("%"));
  TestEq(TRUE, IsValidLangfileText("%%"));
}

MACRO ManipulationTest()
{
  OBJECT langfile_nl := OpenLanguageFile(MakeXMLDocument(testdata1));
  OBJECT langfile_en := OpenLanguageFile(MakeXMLDocument(testdata2));

  OBJECT combined := CombineLanguageFiles([langfile_nl,langfile_en]);

  OBJECT basegroup := combined->basegroup;
  OBJECT group_nx := basegroup->GetTextGroup("nx");

  TestEq(FALSE, ObjectExists(group_nx));
  TestThrows(PTR basegroup->CreateTextGroup(""));
  TestThrows(PTR basegroup->CreateTextGroup("n.x"));
  TestThrows(PTR basegroup->CreateTextGroup(" nx"));
  TestThrows(PTR basegroup->CreateTextGroup("nx "));
  TestThrows(PTR basegroup->CreateTextGroup("n x"));

  group_nx := basegroup->CreateTextGroup("nx");
  TestEq(group_nx, basegroup->GetTextGroup("nx"));

  OBJECT deep_nx := group_nx->CreateTextGroup("deep");

  TestEq(-1, group_nx->GetTextPos("test"));
  TestThrows(PTR group_nx->CreateText(""));
  TestThrows(PTR group_nx->CreateText("n.x"));
  TestThrows(PTR group_nx->CreateText(" nx"));
  TestThrows(PTR group_nx->CreateText("nx "));
  TestThrows(PTR group_nx->CreateText("n x"));

  INTEGER testidx := group_nx->CreateText("test");
  TestEq(testidx, group_nx->GetTextPos("test"));
  TestEq(["",""], group_nx->nodes[testidx].texts);

  TestEq(FALSE, RecordExists(combined->LookupText("nx.")));

  RECORD textloc := combined->LookupText("nx.test");
  TestEq(TRUE, RecordExists(textloc));
  TestEq(group_nx, textloc.textgroup);
  TestEq(0, textloc.nodeindex);

  TestEq(DEFAULT OBJECT, combined->LookupTextGroup("nx."));
  TestEq(deep_nx, combined->LookupTextGroup("nx.deep"));
  TestEq(DEFAULT OBJECT, combined->LookupTextGroup("nx.deep.xyz"));
  TestEq(DEFAULT OBJECT, combined->LookupTextGroup(".nx.deep"));

  deep_nx->parent->DeleteTextGroup("deep");
  TestEq(DEFAULT OBJECT, combined->LookupTextGroup("nx.deep"));
  TestEq(DEFAULT OBJECT, deep_nx->parent);
  group_nx->DeleteText("test");
  TestEq(FALSE, RecordExists(combined->LookupText("nx.test")));
}

MACRO TestLangEditApi()
{
  //NOTE! this test should never actually save changes! Use the gettid.whscr test for desstructive (but slower) langeditapi testing

  OBJECT api := NEW LangEditAPI("consilio"); //pretty small and stable module. must faster than using webhare_testsuite
  TestEq(FALSE, api->IsOutOfDate());
  TestEq(FALSE, api->IsDirty());
  TestEq(["en","nl"], SELECT AS STRING ARRAY langcode FROM api->GetLanguages());

  api->LookupTextGroup("catalog.blacklist")->SetRawText("addpattern", 0, "NewAddPatternText");
  TestEq(FALSE, api->IsOutOfDate());
  TestEq(TRUE, api->IsDirty());
  TestEq(2, api->GetNumReferences("catalog.blacklist.addpattern"));
  TestEq("NewAddPatternText", api->LookupTextGroup("catalog.blacklist")->GetRawText("addpattern",0));
  TestEq("", api->LookupTextGroup("catalog.blacklistpattern")->GetRawText("addpattern",0), "addpatern shouldnt exist in our target group");

  api->LookupTextGroup("catalog.blacklistpattern")->CreateText("testje");
  api->LookupTextGroup("catalog.blacklistpattern")->CreateText("addpattern");
  TestEq(0, api->GetNumReferences("catalog.blacklist.testje"));

  api->LookupTextGroup("catalog.blacklist")->CreateText("testje");
  api->LookupTextGroup("catalog.blacklist")->SetRawText("testje", 0, "Testje Translated");
  api->LookupTextGroup("catalog.blacklist")->SetRawText("testje", 1, "Testje Vertaald");
  TestEq("Testje Translated", api->LookupTextGroup("catalog.blacklist")->GetRawText("testje", 0));

  TestEq(['catalog.blacklist'], api->GetSuggestedMissingFromSources(api->LookupTextGroup("catalog.blacklistpattern")));
  api->ImportMissingFrom(api->LookupTextGroup("catalog.blacklistpattern"),api->LookupTextGroup("catalog.blacklist"));

  TestEq("Testje Translated", api->LookupTextGroup("catalog.blacklistpattern")->GetRawText("testje", 0));
  TestEq("Testje Vertaald", api->LookupTextGroup("catalog.blacklistpattern")->GetRawText("testje", 1));
  TestEq("NewAddPatternText", api->LookupTextGroup("catalog.blacklistpattern")->GetRawText("addpattern", 0));

  TestEq("", api->LookupTextGroup("catalog.blacklist")->GetRawText("testje", 0));
  TestEq("", api->LookupTextGroup("catalog.blacklist")->GetRawText("testje", 1));
  TestEq("NewAddPatternText", api->LookupTextGroup("catalog.blacklist")->GetRawText("addpattern", 0));
}

RunTestFramework([ PTR TestEarlyGettid
                 , PTR TestEncodeText
                 , PTR ReaderTest
                 , PTR WriterTest1
                 , PTR WriterTest2
                 , PTR MergeTest
                 , PTR FallbackTest
                 , PTR SyntaxTest
                 , PTR ManipulationTest
                 , PTR TestLangEditApi
                 ]);
