<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::dbase/dynquery.whlib";
LOADLIB "wh::dbase/postgresql.whlib";
LOADLIB "wh::javascript.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbase/updatecommands.whlib";
LOADLIB "mod::system/lib/testframework.whlib";


MACRO TestReflectValue(VARIANT v, STRING encoding)
{
  IF (TypeID(v) = TypeID(BLOB) AND LENGTH(v) = 0)
    RETURN;

  TRY
  {
    VARIANT result := RECORD(GetPrimary()->__ExecSQL(`SELECT $1 AS value`, [ args := VARIANT[ v ], argencodings := [ encoding ] ])).value;
    TestEQ(v, result, AnyToString(v, "tree"));
  }
  CATCH (OBJECT e)
  {
    PRINT(`While reflecting\n` || AnyToString(v, "tree"));
    THROW;
  }
}

BOOLEAN FUNCTION ReturnTRUE() { RETURN TRUE; }


MACRO TestPrimitiveValues()
{
  OBJECT trans := GetPrimary();

  trans->BeginWork();

  // Cleanup
  IF (trans->SchemaExists("webhare_testsuite_testschema"))
    trans->DropSchema("webhare_testsuite_testschema", [ cascade := TRUE ]);
  trans->CreateSchema("webhare_testsuite_testschema", "", "");

  __LegacyCreateTable(trans, "webhare_testsuite_testschema", "refvalues",
      [ primarykey :=   "id"
      , cols :=         [ [ column_name := "id", data_type := "INTEGER", autonumber_start := 111 ]
                        ]
      ]);

  __LegacyCreateTable(trans, "webhare_testsuite_testschema", "primitives",
      [ primarykey :=   "id"
      , cols :=         [ [ column_name := "id", data_type := "INTEGER", autonumber_start := 111 ]
                        , [ column_name := "normalint", data_type := "INTEGER" ]
                        , [ column_name := "normalbool", data_type := "BOOLEAN" ]
                        , [ column_name := "normalvarchar", data_type := "VARCHAR", character_octet_length := 16 ]
                        , [ column_name := "normaldatetime", data_type := "DATETIME" ]
                        , [ column_name := "normalint64", data_type := "INTEGER64" ]
                        , [ column_name := "normalmoney", data_type := "MONEY" ]
                        , [ column_name := "normalfloat", data_type := "FLOAT" ]
                        , [ column_name := "normalblob", data_type := "BLOB" ]
                        , [ column_name := "binaryvarchar", data_type := "BYTEA" ]
                        , [ column_name := "nullint", data_type := "INTEGER", referenced_table_schema := "webhare_testsuite_testschema", referenced_table_name := "refvalues" ]
                        ]
      ]);

  trans->CommitWork();

  TABLE
  < INTEGER id
  > refvaluesable := BindTransactionToTable(trans->id, "webhare_testsuite_testschema.refvalues");

  TABLE
  < INTEGER id
  , INTEGER normalint
  , BOOLEAN normalbool
  , STRING normalvarchar
  , DATETIME normaldatetime
  , INTEGER64 normalint64
  , MONEY normalmoney
  , FLOAT normalfloat
  , BLOB normalblob
  , STRING binaryvarchar __ATTRIBUTES__(BINARY)
  , INTEGER nullint NULL := 0
  ; KEY id
  > testtable := BindTransactionToTable(trans->id, "webhare_testsuite_testschema.primitives");

  RECORD tests :=
      [ normalint :=          [ 0, -2147483648, 2147483647 ]
      , normalbool :=         [ FALSE, TRUE ]
      , normalvarchar :=      [ "", "1234567812345678" ]
      , normalint64 :=        [ 0i64, -1i64, 1i64, -2147483648i64, -2147483649i64, -2147483650i64, -9223372036854775807i64, -9223372036854775808i64, 9223372036854775807i64 ]
      , normaldatetime :=     [ DEFAULT DATETIME
                              , MakeDate(1,1,1)
                              , MakeDate(1916,1,1)
                              , MakeDateTime(1999,12,31,23,0,0)
                              , LocalToUTC(MakeDate(1916, 1, 1), "Europe/Amsterdam")
                              , MakeDate(2000, 1, 1)
                              , MakeDateTime(2000, 1, 2, 3, 4, 5, 6)
                              , MAX_DATETIME
                              ]
      , normalmoney :=        IsWASM() ? [ 0m, -900000000.99999, 900000000.99999 ] //TODO what range should JS aim for?
                                       : [ 0m, -92233720368547.75808, 92233720368547.75807 ]
      , normalfloat :=        [ 0f, -987654321.123456789, 1000 ]
      , normalblob :=         [ DEFAULT BLOB, StringToBlob("testblob") ]
      , binaryvarchar :=      [ "", DecodeBase16("D1BCA62CB288E511B156C2A9BE48DF44DB0A4104") ]
      , nullint :=            [ 0, -2147483648, 2147483647 ]
      ];

  trans->BeginWork();
  FOREVERY (INTEGER id FROM tests.nullint)
    IF (IsValueSet(id))
      INSERT INTO refvaluesable(id) VALUES (id);
  FOR (INTEGER id := 1; id <= 128; id := id + 1)
    IF (id NOT IN tests.nullint)
      INSERT INTO refvaluesable(id) VALUES (id);
  trans->CommitWork();

  RECORD defaultrec;
  FOREVERY (RECORD rec FROM UnpackRecord(tests))
    defaultrec := CellInsert(defaultrec, rec.name, rec.value[0]);

  FOREVERY (RECORD rec FROM UnpackRecord(tests))
  {
    // These types must be sent to postgresql as parameter, for IN optimization support
    IF (TypeID(rec.value) IN [ TYPEID(INTEGER ARRAY), TYPEID(INTEGER64 ARRAY), TYPEID(DATETIME ARRAY), TYPEID(STRING ARRAY) ])
      TestReflectValue(rec.value, rec.name NOT LIKE "BINARY*" ? "normal" : "binary");

    FOREVERY (VARIANT val FROM rec.value)
    {
      trans->BeginWork();

      TestReflectValue(val, rec.name NOT LIKE "BINARY*" ? "normal" : "binary");

      DELETE FROM testtable;

      INTEGER id := MakeAutoNumber(testtable, "id");
      RECORD toinsert := CellInsert(CELL[ id ], rec.name, val);
      INSERT toinsert INTO testtable;

      trans->CommitWork();

      //DumpValue(toinsert, [ name := "toinsert" ]);
      RECORD readvalue := SELECT * FROM testtable WHERE COLUMN id = toinsert.id;
      //DumpValue(readvalue, [ name := "readvalue" ]);

      // blob's aren't comparable
      IF (rec.name LIKE "*BLOB")
      {
        IF (LENGTH(val) != 0)
        {
          STRING insertid := __GetPostgreSQLBlobRegistrationId(trans->id, GetCell(toinsert, rec.name));
          STRING readid := __GetPostgreSQLBlobRegistrationId(trans->id, GetCell(readvalue, rec.name));
          TestEQ(FALSE, insertid = "", "Original blob should have a registration");
          TestEQ(insertid, readid);
        }
        CONTINUE;
      }

      TestEQ(CELL[ ...defaultrec, ...toinsert ], readvalue);

      // Test exact search
      INTEGER found :=
          SELECT AS INTEGER COLUMN id
            FROM testtable
           WHERE (CellExists(toinsert, "normalint") ? normalint = toinsert.normalint : TRUE)
             AND (CellExists(toinsert, "normalbool") ? normalbool = toinsert.normalbool : TRUE)
             AND (CellExists(toinsert, "normalvarchar") ? normalvarchar = toinsert.normalvarchar : TRUE)
             AND (CellExists(toinsert, "normaldatetime") ? normaldatetime = toinsert.normaldatetime : TRUE)
             AND (CellExists(toinsert, "normalint64") ? normalint64 = toinsert.normalint64 : TRUE)
             AND (CellExists(toinsert, "normalmoney") ? normalmoney = toinsert.normalmoney : TRUE)
             AND (CellExists(toinsert, "normalfloat") ? normalfloat = toinsert.normalfloat : TRUE)
             AND (CellExists(toinsert, "normalblob") ? normalblob = toinsert.normalblob : TRUE)
             AND (CellExists(toinsert, "binaryvarchar") ? binaryvarchar = toinsert.binaryvarchar : TRUE);

      TestEQ(id, found);

      // Test IN search
      found :=
          SELECT AS INTEGER COLUMN id
            FROM testtable
           WHERE (CellExists(toinsert, "normalint") ? normalint IN INTEGER[ toinsert.normalint ] : TRUE)
             AND (CellExists(toinsert, "normalbool") ? normalbool IN BOOLEAN[ toinsert.normalbool ] : TRUE)
             AND (CellExists(toinsert, "normalvarchar") ? normalvarchar IN STRING[ toinsert.normalvarchar ] : TRUE)
             AND (CellExists(toinsert, "normaldatetime") ? normaldatetime IN DATETIME[ toinsert.normaldatetime ] : TRUE)
             AND (CellExists(toinsert, "normalint64") ? normalint64 IN INTEGER64[ toinsert.normalint64 ] : TRUE)
             AND (CellExists(toinsert, "normalmoney") ? normalmoney IN MONEY[ toinsert.normalmoney ] : TRUE)
             AND (CellExists(toinsert, "normalfloat") ? normalfloat IN FLOAT[ toinsert.normalfloat ] : TRUE)
             AND (CellExists(toinsert, "normalblob") ? normalblob IN BLOB[ toinsert.normalblob ] : TRUE)
             AND (CellExists(toinsert, "binaryvarchar") ? binaryvarchar IN STRING[ toinsert.binaryvarchar ] : TRUE);

      TestEQ(id, found);

      // ADDME: test dynquery!
      OBJECT dynquery := NEW DynamicQuery;
      dynquery->AddTable("tab", GetPrimary()->id, "webhare_testsuite_testschema.primitives", SELECT AS STRING ARRAY ToLowercase(name) FROM UnpackRecord(readvalue));
      dynquery->AddConstraint("tab.id", "=", toinsert.id);
      readvalue := dynquery->Execute();
      TestEq(CELL[ ...defaultrec, ...toinsert ], readvalue.tab);
    }
  }

  // Test dummy update
  trans->BeginWork();
  DELETE FROM testtable;
  INSERT [ id := 1, normalvarchar := "Hi!" ] INTO testtable;
  UPDATE testtable SET RECORD DEFAULT RECORD WHERE id = 1;
  UPDATE testtable SET RECORD CELL[] WHERE id = 1;
  trans->RollbackWork();

  // Test no-column select
  TestEq(1, Length(SELECT FROM testtable));

  // Test touppercase on binary columns
  trans->BeginWork();
  DELETE FROM testtable;
  INSERT [ id := 1, binaryvarchar := DecodeBase16("D1BCA62CB288E511B156C2A9BE48DF44DB0A4104") ] INTO testtable;
  TestEQ(1, SELECT AS INTEGER id FROM testtable WHERE ToUppercase(binaryvarchar) = ToUppercase(DecodeBase16("D1BCA62CB288E511B156C2A9BE48DF44DB0A4104")));
  TestEQ(0, SELECT AS INTEGER id FROM testtable WHERE ToUppercase(binaryvarchar) IN STRING[]);
  trans->RollbackWork();

   //Test touppercase on string column
  trans->BeginWork();
  DELETE FROM testtable;
  INSERT [ id := 1, normalvarchar := "Een" ] INTO testtable;
  INSERT [ id := 2, normalvarchar := "TWEE" ] INTO testtable;
  TestEQ(1, SELECT AS INTEGER id FROM testtable WHERE ToUppercase(normalvarchar) = ToUppercase("EEN"));
  TestEQ(2, SELECT AS INTEGER id FROM testtable WHERE ToUppercase(normalvarchar) = ToUppercase("TWEE"));
  //test regression: this was sent as select â€¦ where ("T0"."nullint" IS NULL) OR ("T0"."nullint" = $1) and upper("T0"."normalvarchar") = upper($2) //missing parenthesis around the OR
  TestEQ(2, SELECT AS INTEGER id FROM testtable WHERE nullint = 0 AND ToUppercase(normalvarchar) = ToUppercase("TWEE"));
  TestEQ(0, SELECT AS INTEGER id FROM testtable WHERE nullint = 0 AND normalvarchar IN STRING[]);
  trans->RollbackWork();

  // Test limit handling when harescript does afterfiltering. Bit racy for detecting errors, depends on id=1 being found first by PostgreSQL
  trans->BeginWork();
  DELETE FROM testtable;
  INSERT [ id := 1, normalvarchar := "NO_MATCH" ] INTO testtable;
  INSERT [ id := 2, normalvarchar := "WRD" ] INTO testtable;
  TestEQ(2, SELECT AS INTEGER id FROM testtable WHERE ToLowercase(normalvarchar) = "wrd");
  TestEQ(2, SELECT AS INTEGER Any(id) FROM testtable GROUP BY normalvarchar HAVING ToLowercase(normalvarchar) = "wrd");
  trans->RollbackWork();

  trans->BeginWork();

  DELETE FROM testtable;

  INTEGER test_schema_oid := SELECT AS INTEGER oid FROM postgresql_pg_catalog.pg_namespace WHERE nspname = "webhare_testsuite_testschema";

  // Test encoding by PostgreSQLEscapeLiteral and PostgreSQLEscapeIdentifier
  STRING unicode_stuff;
  FOR (INTEGER i := 1; i < 512; i := i + 1)
  {
    unicode_stuff := UCToString(i);

    GetPrimary()->__ExecSQL(`INSERT INTO webhare_testsuite_testschema.primitives(id, normalvarchar) VALUES ($1, ${PostgreSQLEscapeLiteral(unicode_stuff)})`, [ args := VARIANT[ i ]]);
    TestEQ(unicode_stuff, SELECT AS STRING normalvarchar FROM testtable WHERE id = i);

    STRING funcname := "encoding_test_" || unicode_stuff;
    GetPrimary()->__ExecSQL(`CREATE FUNCTION webhare_testsuite_testschema.${PostgreSQLEscapeIdentifier(funcname)}() RETURNS text STRICT IMMUTABLE LANGUAGE plpgsql AS $$ BEGIN RETURN 'retval'; END; $$`);
    TestEQ(funcname, SELECT AS STRING proname FROM postgresql_pg_catalog.pg_proc WHERE proname LIKE 'encoding_test_*' AND pronamespace = test_schema_oid);
    GetPrimary()->__ExecSQL(`DROP FUNCTION webhare_testsuite_testschema.${PostgreSQLEscapeIdentifier(funcname)}()`);
  }

  // Test invalid UTF-8 encoding
  IF(NOT IsWasm()) //TODO do we care for this at the WASM level? it's about odd column names, not data (those we would safely pass through parameters). I doubt anyone actually relies on this, even in native
  {
    TestEQ(` E'\\xC0'`, PostgreSQLEscapeLiteral('\xC0'));
    TestEQ(` E'\\xC0a'`, PostgreSQLEscapeLiteral('\xC0a'));
    TestEQ(`U&"\xC0"`, PostgreSQLEscapeIdentifier('\xC0'));
    TestEQ(`U&"\xC0a"`, PostgreSQLEscapeIdentifier('\xC0a'));
  }

  trans->RollbackWork();

  // ADDME: spin off into its own test
  /* tests if fase2 updates of a table *with primary key* are properly processed
  */
  {
    trans->BeginWork();

    DELETE FROM testtable;

    FOR (INTEGER i := 1; i <= 128; i := i + 1)
      INSERT [ id := i, normalint := i, normalint64 := i % 4 ] INTO testtable;

    RECORD ARRAY local := SELECT * FROM testtable ORDER BY id;

    UPDATE testtable SET normalint := normalint + 1, nullint := nullint + 1;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1;

    UPDATE testtable SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 = 0;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 = 0;

    UPDATE testtable SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 + 1 = 2;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 + 1 = 2;

    UPDATE testtable SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0;

    UPDATE testtable SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0 AND ReturnTRUE();
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0 AND ReturnTRUE();

    TestEQ(local, SELECT * FROM testtable ORDER BY id);

    trans->RollbackWork();
  }

  /* same test, table without primary key (doesn't do fase2, everything locked and returned in fase1)
  */
  {
    TABLE
    < INTEGER id
    , INTEGER normalint
    , INTEGER64 normalint64
    , INTEGER nullint NULL := 0
    > testtable_nopk := BindTransactionToTable(trans->id, "webhare_testsuite_testschema.primitives");

    trans->BeginWork();

    DELETE FROM testtable_nopk;

    FOR (INTEGER i := 1; i <= 128; i := i + 1)
      INSERT [ id := i, normalint := i, normalint64 := i % 4 ] INTO testtable_nopk;

    RECORD ARRAY local := SELECT * FROM testtable_nopk ORDER BY id;

    UPDATE testtable_nopk SET normalint := normalint + 1, nullint := nullint + 1;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1;

    UPDATE testtable_nopk SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 = 0;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 = 0;

    UPDATE testtable_nopk SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 + 1 = 2;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint64 + 1 = 2;

    UPDATE testtable_nopk SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0;
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0;

    UPDATE testtable_nopk SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0 AND ReturnTRUE();
    UPDATE local SET normalint := normalint + 1, nullint := nullint + 1 WHERE normalint > 0 AND ReturnTRUE();

    TestEQ(local, SELECT * FROM testtable_nopk ORDER BY id);

    trans->RollbackWork();
  }
}

//We'll keep this outside of the Runtestframework as testfw relies on primitivevalues being workable
OpenPrimary();
TestPrimitiveValues();
