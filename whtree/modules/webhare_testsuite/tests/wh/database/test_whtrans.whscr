<?wh

LOADLIB "wh::dbase/dynquery.whlib";
LOADLIB "wh::javascript.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/dbase/updatecommands.whlib";


MACRO Cleanup()
{
  OpenPrimary();
  OBJECT trans := GetPrimaryWebhareTransactionObject();

  trans->BeginWork();
  IF (trans->SchemaExists("beta_dbtests"))
    trans->DropSchema("beta_dbtests", [ cascade := TRUE ]);
  trans->CommitWork();

  GetPrimary()->Close();
}

MACRO TestPrimary()
{
  OBJECT trans := OpenPrimary();

  // Work status
  TestEq(TRUE, trans->HasWorkSupport());
  TestEq(FALSE, trans->IsWorkOpen());

  // GetPrimary works?
  TestEq(trans->id, GetPrimary()->id);

  // No nested primary transactions
  TestThrowsLike('*already*opened*',PTR OpenPrimary);

  // Work (commit)
  trans->BeginWork();
  TestEq(trans->id, GetPrimaryWebhareTransaction());
  TestEq(TRUE, trans->IsWorkOpen());
  TestEq(DEFAULT RECORD ARRAY, trans->CommitWork());
  TestEq(FALSE, trans->IsWorkOpen());

  TestEq(trans->id, GetPrimaryWebhareTransaction());

  // Work (rollback)
  trans->BeginWork();
  TestEq(trans->id, GetPrimaryWebhareTransaction());
  TestEq(TRUE, trans->IsWorkOpen());
  trans->RollbackWork();
  TestEq(FALSE, trans->IsWorkOpen());

  TestEq(trans->id, GetPrimaryWebhareTransaction());
  TestEq(trans->id, GetPrimary()->id);

  // Close (must 0 primary transaction)
  trans->Close();
  TestEq(0, GetPrimaryWebhareTransaction());
  TestThrowsLike('No primary transaction*',PTR GetPrimary);
}

MACRO TestWorkLocks()
{
  OBJECT trans := OpenPrimary();
  trans->BeginLockedWork("webhare_testsuite:worklock");
  IF(IsWasm()) //WASM doesn't (yet?) support duplicate lock detection as TS doesn't (and it doesn't bind the mutexes to a codecontext - you still wouldn't want to auto-unlock but tracing issues is useful)
    TestEq(DEFAULT OBJECT, OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME));
  ELSE
    TestThrowsLike('*already*locked*', PTR OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME));
  TestEq(TRUE, trans->HasMutex("webhare_testsuite:worklock"));
  trans->RollbackWork();
  TestEq(FALSE, trans->HasMutex("webhare_testsuite:worklock"));

  OBJECT lock := OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME);
  TestEq(TRUE, ObjectExists(lock));
  lock->Close();

  iF(NOT IsWasm()) {
    trans->BeginLockedWork("webhare_testsuite:worklock");
    TestThrowsLike('*already*locked*', PTR OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME));
    trans->CommitWork();
  }

  lock := OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME);
  TestEq(TRUE, ObjectExists(lock));
  lock->Close();

  iF(NOT IsWasm()) {
    trans->BeginLockedWork("webhare_testsuite:worklock");
    TestThrowsLike('*already*locked*', PTR OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME));
  }
  trans->Close();

  lock := OpenLockManager()->TryLockMutex("webhare_testsuite:worklock", DEFAULT DATETIME);
  TestEq(TRUE, ObjectExists(lock));
  lock->Close();
}

MACRO TestCommitErrors()
{
  IF(IsWasm())
    RETURN; //unsupported, see also our comments at the end of test_work.whscr

  TABLE <INTEGER id, INTEGER int2> beta_tableA;

  OBJECT trans := OpenPrimary();

  // Prepare table for commit error
  trans->BeginWork();
  IF (GetPrimaryWebhareTransactionObject()->SchemaExists("beta_dbtests"))
    trans->DropSchema("beta_dbtests");
  trans->CreateSchema("beta_dbtests", "DEFINITION_SCHEMA", "_SYSTEM");

  __LegacyCreateTable(trans, "beta_dbtests", "tableA",
      [ cols := [ [ column_name :=      "id"
                  , data_type :=        "INTEGER"
                  //FIXME make all this optional for a nicer user api
                  , autonumber_start := 0
                  , nullable :=         TRUE
                  , isunique :=         TRUE // <-- used to generate error
                  , noupdate :=         FALSE
                  , referenced_table_name := ""
                  , referenced_table_schema := ""
                  , on_delete :=        "cascade"
                  ]
                , [ column_name :=      "int2"
                  , data_type :=        "INTEGER"
                  , autonumber_start := 0
                  , nullable :=         FALSE // can't be TRUE when isunique is also on
                  , isunique :=         TRUE // <-- used to generate error
                  , noupdate :=         FALSE
                  , referenced_table_name := ""
                  , referenced_table_schema := ""
                  , on_delete :=        "cascade"
                  ]
                ]
      , primarykey := "id"
      ]);

  trans->CommitWork();

  trans->BeginWork();
  beta_tableA := BindTransactionToTable(trans->id,"beta_dbtests.tableA");

  INSERT INTO beta_tableA(id, int2) VALUES (1, 2);
  INSERT INTO beta_tableA(id, int2) VALUES (1, 3);
  TestThrowsLike('*',PTR trans->CommitWork()); //* because exact exception depends a lot on the database
  TestEq(FALSE, trans->IsWorkOpen());

  trans->BeginWork();
  beta_tableA := BindTransactionToTable(trans->id,"beta_dbtests.tableA");
  INSERT INTO beta_tableA(id,int2) VALUES (1, 2);
  INSERT INTO beta_tableA(id,int2) VALUES (2, 3);

  TestEq( [[ id := 1, outint2 := 2, x := 42 ]]
        , EnrichWithTable([ [ id := 1, x := 42] ]
                         , "ID", beta_tableA, [ outint2 := "int2" ]));

  TestEq( [[id := 1, outint2 := 2, x := 42 ]]
        , EnrichWithTable([ [ id := 1, x := 42 ]
                          , [ id := 5, x := 47 ]
                          ]
                          , "ID", beta_tableA, [ outint2 := "int2" ]));

  TestEq([[ id := 1, outint2 := 2, x := 42 ]
         ,[ id := 5, outint2 := 0, x := 47 ]
         ]
        , EnrichWithTable([ [ id := 1, x := 42 ]
                          , [ id := 5, x := 47 ]
                          ]
                          , "ID", beta_tableA, [ outint2 := "int2" ], [ rightouterjoin := TRUE ]));

  trans->Close();
}

RunTestFramework([ PTR Cleanup
                 , PTR TestPrimary
                 , PTR TestWorkLocks
                 , PTR TestCommitErrors
                 ], [ usedatabase := FALSE ]);
