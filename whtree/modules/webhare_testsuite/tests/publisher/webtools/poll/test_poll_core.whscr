<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::publisher/lib/webtools/poll.whlib";


/* Verder TODO
  - using an optionguid from another question
  - using the same optionguid multiple times (can be abused to vote on a closed poll, cast multiple votes on a poll or to get % > 100 for a poll)
  - multiple choice polls

  - GetResultsForPolls() should never THROW on a non-existant (anymore) poll.
    (because when a poll is deleted and a page isn't republished,
    the other polls should keep on working instead of breaking down)

   - Testen van antifraude methodes

 ADDME When we get other WebTool types, ensure our poll id is not accepted by those others, even after modifying the 'poll:' prefix

   For future enhancements

   - When specifying from-to dates for voting, check whether those checks work
     (FIXME: how do we test this?)

   FIXME: testing the ordering could be done better?
*/



RECORD ARRAY myoptions :=
  [ [ title := "Optie 1", guid := GenerateUFS128BitId() ]
  , [ title := "Optie 2", guid := GenerateUFS128BitId() ]
  , [ title := "Optie 3", guid := GenerateUFS128BitId() ]
  , [ title := "Optie 4" ] // when no GUID is specified the polls API will generate it
  , [ title := "Optie 5", hide := TRUE ]
  ];
RECORD ARRAY myoptions_enriched;



PUBLIC MACRO Prepare()
{
  //Create a poll in the webtools site
  OBJECT webtoolsfolder := OpenTestsuiteSite()->OpenByPath("webtools");
  TestEq(TRUE, ObjectExists(webtoolsfolder), "webtools folder missing in testsite, run resettestsite.whscr?");

  testfw->BeginWork();

  //The poll webtool holds the actual poll results. Destroy it!
  OBJECT pollwebtoolfile := webtoolsfolder->OpenByName("pollwebtool");
  IF(ObjectExists(pollwebtoolfile))
    pollwebtoolfile->DeleteSelf();

  /* Set up the poll. As the publisher requires you to manually create the pollfile
     in the right spot, there's no real need to offer a special API for that here */
  OBJECT pollwebtooltype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/pollwebtool");
  OBJECT pollfile := webtoolsfolder->CreateFile( [ name := "pollwebtool", type := pollwebtooltype->id, publish := FALSE]);

  /* Open the poll by ID */
  OBJECT pollwebtool := OpenPoll(pollfile->id);
  TestEq(pollfile->id, pollwebtool->id);
  TestEqLike("poll:*", pollwebtool->toolid);

  OBJECT pollwebtoolbypollid := OpenPollByToolid(pollwebtool->toolid);
  TestEq(pollfile->id, pollwebtoolbypollid->id);

  TestEq(pollwebtoolbypollid->toolid, pollwebtool->toolid, "Toolid should always be the same to allow adhoc caching on toolid");

  // We get our options back, enriched with a GUID and hide field for options which didn't have them yet
  pollwebtool->SetOptions(myoptions);
  RECORD ARRAY options := pollwebtool->GetOptions();

  //ABORT(anytostring(options, "tree"));

  RECORD ARRAY options_missing_a_guid :=
        SELECT FROM options AS row
         WHERE NOT CellExists(row, "guid") OR row.guid = "";

  RECORD ARRAY options_missing_a_hide :=
        SELECT FROM options AS row
         WHERE NOT CellExists(row, "hide") OR row.guid = "";

  TestEq(Length(options_missing_a_guid), 0, "The returned options from poll->SetOptions must all have a \"guid\" field.");
  TestEq(Length(options_missing_a_hide), 0, "The returned options from poll->SetOptions must all have a \"hide\" field.");

  TestEq(Length(GenerateUFS128BitId()), Length(options[3].guid), "The guid should have been generated by GenerateUFS128BitId() so it should have the same length as one");

  // Now open a new poll object for the same poll
  // (they poll keeps it's polldata cached, so also make sure that storing/reading of data results in the same options)
  OBJECT pollwebtool2 := OpenPoll(pollfile->id);
  RECORD ARRAY options_fromnewinstance := pollwebtool2->GetOptions();
  //TestEq(Length(myoptions), Length(options_fromnewinstance));

  // we expect the return value of SetOptions and GetOptions to have the same fields and same ordering

  // - we want all set options to be there
  // - we don't want GetOptions() to filter on 'hide' (only GetResults() and GetWittyFields() should not return hidden options)
  // - we want to options to be there (correctly cached after SetOptions AND whether SetOptions saves it correctly and GetOptions returns it correctly)
  TestEq(Length(myoptions), Length(options), "Expected GetOptions to return all options we set, including hiddes ones");
  TestEq(options, options_fromnewinstance, "Expected the result of GetOptions to be the same as the enriched options returned by SetOptions");


  RECORD results := pollwebtool->GetResults(); //GetOptionsWithStatistics();

  // Since we just added the poll we expect all options to have zero votes.
  // So the return value of GetOptionsWithStatistics() should be the same as GetOptions(),
  // except with votes := 0 added to each RECORD in the array.
  TestEq(results.options, (SELECT *, votes := 0 FROM results.options), "Expected the result of GetResults().options to be the same as GetOptions() with a field votes added.");

  //DumpValue(statistics, "tree");

  // Commit. Otherwise the RPC's transaction will not be able to see our new poll.
  testfw->CommitWork();


  // attempting to vote for multiple options in a single choice poll
  RECORD vote_result;


  BOOLEAN fail;


  // Blank votes should THROW
  fail := FALSE;
  TRY
  {
    vote_result := testfw->browser->CallJSONRPC(
                    GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                  , pollwebtool->toolid
                  , DEFAULT STRING ARRAY
                  );
  }
  CATCH(OBJECT err)
  {
    fail := TRUE;
  }
  TestEq(fail, TRUE, "RPC CastVote should fail on blank votes.");


  // Using an unknown option GUID should THROW
  fail := FALSE;
  TRY
  {
    vote_result := testfw->browser->CallJSONRPC(
                    GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                  , pollwebtool->toolid
                  , ["IDONOTEXISTASOPTION"]
                  );
  }
  CATCH(OBJECT err)
  {
    fail := TRUE;
  }
  TestEq(fail, TRUE, "RPC CastVote should fail on a non-existant option GUID.");



  // Multiple selected options on singlechoice poll should THROW
  fail := FALSE;
  TRY
  {
    vote_result := testfw->browser->CallJSONRPC(
                    GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                  , pollwebtool->toolid
                  , [ STRING(options[1].guid), options[0].guid ]
                  );
  }
  CATCH(OBJECT err)
  {
    fail := TRUE;
  }
  TestEq(fail, TRUE, "RPC CastVote should fail when trying to vote for multiple options on a singleselect poll.");


  RECORD hidden_option := SELECT * FROM options WHERE hide;
  TestThrowsLike( "*not available*"
                , PTR testfw->browser->CallJSONRPC(
                      GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                    , pollwebtool->toolid
                    , [ STRING(hidden_option.guid) ] //STRING(options[1].guid) ]
                    ));


  // Use the first testoption with hide := TRUE to test
  vote_result := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                , pollwebtool->toolid
                , [ STRING(options[0].guid) ]
                );
  TestEq(CellExists(vote_result, "success") AND vote_result.success, TRUE, "Expected the CastVote RPC call returnvalue to have a field SUCCES with the value TRUE");
  UPDATE results.options SET votes := votes + 1 WHERE guid = VAR options[0].guid;



  vote_result := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                , pollwebtool->toolid
                , [ STRING(options[3].guid) ]
                );
  TestEq(CellExists(vote_result, "success") AND vote_result.success, TRUE, "Expected the CastVote RPC call returnvalue to have a field SUCCES with the value TRUE");
  UPDATE results.options SET votes := votes + 1 WHERE guid = VAR options[3].guid;



  vote_result := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                , pollwebtool->toolid
                , [ STRING(options[1].guid) ]
                );
  TestEq(CellExists(vote_result, "success") AND vote_result.success, TRUE, "Expected the CastVote RPC call returnvalue to have a field SUCCES with the value TRUE");
  UPDATE results.options SET votes := votes + 1 WHERE guid = VAR options[1].guid;


  vote_result := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "CastVote"
                , pollwebtool->toolid
                , [ STRING(options[1].guid) ]
                );
  TestEq(CellExists(vote_result, "success") AND vote_result.success, TRUE, "Expected the CastVote RPC call returnvalue to have a field SUCCES with the value TRUE");
  UPDATE results.options SET votes := votes + 1 WHERE guid = VAR options[1].guid;


  // update %
  results.options[0].votepercentage := 25;
  results.options[1].votepercentage := 50;
  results.options[3].votepercentage := 25;


  // when we request the statistics again we expect only one change:
  // the "votes" field for the second option must now be 1 instead of 0
  RECORD results2 := pollwebtool->GetResults();
  //DumpValue(results.options, "tree");
  //DumpValue(results2.options, "tree");
  TestEq(results.options, results2.options, "GetResults().options didn't return what we expected after having used the RPC CastVote.");


  RECORD single_poll_results := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "GetResultsForPoll"
                , pollwebtool->toolid
                );

  TestEq(results.options, single_poll_results.options, "Expected the results in options votes and votepercentages to match");
  TestEq(results2.amountofvoters, single_poll_results.amountofvoters);
  TestEq(results2.options[0].votes, single_poll_results.options[0].votes);

  RECORD ARRAY multiple_poll_results := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "GetResultsForPolls"
                , [ STRING(pollwebtool->toolid) ]
                );

  TestEq(single_poll_results, multiple_poll_results[0]);

/*
  testfw->BeginWork();
  pollwebtool->ResetVotes();
  testfw->CommitWork();


  RECORD ARRAY polls_results := testfw->browser->CallJSONRPC(
                  GetPrimaryWebhareInterfaceURL() || "wh_services/publisher/poll", "GetResultsForPolls"
                , [ STRING(pollwebtool->toolid) ]
                );
  TestEq(1, Length(polls_results));
  TestEq(0, polls_results[0].amountofvoters);
  TestEq(0, polls_results.options[0].votes);

  RECORD results3 := pollwebtool->GetResults();
  TestEq(0, results3.amountofvoters);
  TestEq(0, results3.options[0].votes);
*/
  //////////////////////////////////////////////////////////
  //
  // Multiple choice

  testfw->BeginWork();

  pollwebtool->UpdateSettings([ ismultiplechoice := TRUE ]);

  testfw->CommitWork();


}

RunTestframework([ PTR Prepare ]);

