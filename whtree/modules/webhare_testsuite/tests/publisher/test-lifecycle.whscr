<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internal/testfuncs.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/webserver/management.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/internal/tasks.whlib";

LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";


/** Wait for all publisher scheduled tasks triggered before a certain time
    to finish
    @param timeaftertrigger All scheduled tasks triggered before this time will be finished when this function returns
    @param deadline Error out when the wait hasn't completed after this time
*/
MACRO WaitForPublisherScheduledTasks(DATETIME timeaftertrigger, DATETIME deadline)
{
  WHILE (TRUE)
  {
    RECORD ARRAY tasks_to_execute :=
        SELECT * FROM publisher.schedule
         WHERE COLUMN when <= VAR timeaftertrigger;

    IF (NOT RecordExists(tasks_to_execute))
      BREAK;

    Sleep(10);
    IF(GetCurrentDatetime() >= deadline)
      ABORT("Task isn't completing");
  }

  // Wait for the postcommit effects of the scheduled tasks to finish too
  WHILE (TRUE)
  {
    RECORD executetaskstatus :=
         SELECT tag, currentstart, nexttime
           FROM system_internal.tasks
          WHERE tag = "publisher.scheduledtasks";

    IF (executetaskstatus.currentstart = DEFAULT DATETIME
        AND executetaskstatus.nexttime = DEFAULT DATETIME)
      BREAK;

    Sleep(10);
    IF(GetCurrentDatetime() >= deadline)
      ABORT("publisher.scheduledtasks isn't completing");
  }
}

/** Wait for all event completions to finish
    @param deadline Error out when the wait hasn't completed after this time
*/
MACRO WaitForEventCompletions(DATETIME deadline)
{
  OBJECT eventcompletionlink := ConnectToManagedPort("system:eventcompletion", "webserver");
  WHILE (TRUE)
  {
    /* A single request is usually enough for synchronization, because it handles all
       completions between requests
    */
    RECORD rec := eventcompletionlink->DoRequest( [ type := "havependingcompletions" ]);
    IF (NOT rec.msg.result)
      BREAK;

    Sleep(10);
    IF(GetCurrentDatetime() >= deadline)
      ABORT("publisher.scheduledtasks isn't completing");
  }
  eventcompletionlink->Close();
}

/** Wait for output analyser scans to finish
    @param folderids Ids of folders that must be completed
    @param deadline Error out when the wait hasn't completed after this time
*/
MACRO WaitForOutputAnalyzer(INTEGER ARRAY folderids, DATETIME deadline)
{
  OBJECT outputanalyzer := WaitForPromise(OpenWebHareService("publisher:outputanalyzer"));
  WHILE (TRUE)
  {
    RECORD state := WaitForPromise(outputanalyzer->GetState());
    INTEGER ARRAY scheduled := WaitForPromise(outputanalyzer->TestFoldersScheduled(folderids));
    //DumpValue(CELL[ state, scheduled ], "tree");
    IF (IsDefaultValue(scheduled))
      BREAK;

    Sleep(10);
    IF(GetCurrentDatetime() >= deadline)
      ABORT("outputanalyzer isn't completing");
  }
  outputanalyzer->CloseService();
}

MACRO EnsureTasksExecuted(DATETIME when)
{
  DATETIME deadline := AddTimeToDate(60000,GetCurrentDatetime());

  WaitForPublisherScheduledTasks(when, deadline);
  WaitForEventCompletions(deadline);
  WaitForOutputAnalyzer(INTEGER [ GetTestsuiteTempFolder()->id ], deadline);

  testfw->WaitForPublishCompletion(GetTestsuiteTempFolder()->id);
  //PRINT("Tasks & publisher finished\n");
}

/** Wait for a file to have been published. Use this if you know that a file should be republish within a few seconds */
BOOLEAN FUNCTION WaitForBeenPublished(INTEGER fileid, DATETIME sincewhen)
{
  /* We loop because even if we EnsureTasksExecuted, there's no way to ensure
     that the publisher:executetasks post-commit completions have been sent
     to the completion handler (we could  see that the completions queue is empty,
     but is that because it hasn't received anything yet of because it's done ?) */

  DATETIME deadline := AddTimeToDate(15000,GetCurrentDatetime());
  WHILE (GetCurrentDatetime() <= deadline)
  {
    IF(IsBeingPublishedSince(fileid, sincewhen))
      RETURN TRUE;
    Sleep(100);
  }
  RETURN FALSE;
}

MACRO TestLifeCycle()
{
  testfw->BeginWork();

  OBJECT autokill_now := GetTestsuiteTempFolder()->CreateFile([ name:= "autokill_now"]);
  OBJECT autokill_soon := GetTestsuiteTempFolder()->CreateFile([ name:= "autokill_soon"]);

  autokill_now->SetInstanceData("http://www.webhare.net/xmlns/publisher/lifecycle", [deletion := AddTimeToDate(-1,GetCurrentDatetime())]);
  autokill_soon->SetInstanceData("http://www.webhare.net/xmlns/publisher/lifecycle", [deletion := AddTimeToDate(60000,GetCurrentDatetime())]);

  ExecuteLifecycleCleanup();

  TestEq(TRUE,  ObjectExists(GetTestsuiteTempFolder()->OpenByName("autokill_soon")));
  TestEq(FALSE, ObjectExists(GetTestsuiteTempFolder()->OpenByName("autokill_now")));
  TestEq(FALSE, RecordExists(SELECT FROM system.fs_objects WHERE id = autokill_now->id)); //permanenetly gone!

  testfw->CommitWork();
}

MACRO PublicationMoveFile()
{
  testfw->BeginWork();

  OBJECT tomovefile := GetTestsuiteTempFolder()->CreateFile(
      [ name:=        "tomove.html"
      , type :=       24
      , publish :=    TRUE
      ]);
  OBJECT destfolder := GetTestsuiteTempFolder()->CreateFolder([name := "destfolder"]);
  OBJECT deletedfolder := GetTestsuiteTempFolder()->CreateFolder([name := "deletedfolder"]);

  DATETIME now := GetCurrentDateTime();
  AddFileTask(tomovefile->id, now, 3, destfolder->id); // move

  testfw->CommitWork();
  EnsureTasksExecuted(now);

  tomovefile := OpenWHFSObject(tomovefile->id);
  TestEq(destfolder->id, tomovefile->parent);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(tomovefile->id, now, 3, deletedfolder->id); //move file into a delted folder
  deletedfolder->RecycleSelf();
  testfw->CommitWork();
  EnsureTasksExecuted(now);

  tomovefile := OpenWHFSObject(tomovefile->id);
  TestEq(deletedfolder->id, tomovefile->parent);


}

MACRO PublicationDeleteFile()
{
  testfw->BeginWork();

  OBJECT tokillfile := GetTestsuiteTempFolder()->CreateFile(
      [ name:=        "todelete.html"
      , type :=       24
      , publish :=    TRUE
      ]);

  DATETIME now := GetCurrentDateTime();
  AddFileTask(tokillfile->id, now, 4, 0); // delete
  testfw->CommitWork();
  EnsureTasksExecuted(now);

  tokillfile := OpenWHFSObject(tokillfile->id);
  TestEq(FALSE, tokillfile->isactive);

}

MACRO PublicationDeleteFolder()
{
  testfw->BeginWork();

  OBJECT tokillfolder := GetTestsuiteTempFolder()->CreateFolder(
      [ name:=        "todelete"
      ]);
  OBJECT tokillfile := tokillfolder->CreateFile(
      [ name:=        "todelete.html"
      , type :=       24
      , publish :=    TRUE
      ]);

  DATETIME now := GetCurrentDateTime();
  AddFileTask(tokillfolder->id, now, 4, 0); // delete
  testfw->CommitWork();
  EnsureTasksExecuted(now);

  tokillfolder := OpenWHFSObject(tokillfolder->id);
  TestEq(FALSE, tokillfolder->isactive);

}

MACRO PublicationStartStopTest()
{
  testfw->BeginWork();

  OBJECT indexfile := GetTestsuiteTempFolder()->CreateFile(
      [ name:=        "index.html"
      , type :=       24
      , publish :=    TRUE
      ]);

  OBJECT testfile := GetTestsuiteTempFolder()->CreateFile(
      [ name:=        "test.html"
      , data :=       StringToBlob("Dit is tekst")
      , publish :=    FALSE
      ]);

  testfw->CommitWork();
  testfw->WaitForPublishCompletion(GetTestsuiteTempFolder()->id);

  testfw->BeginWork();
  DATETIME now := GetCurrentDateTime();
  AddFileTask(testfile->id, now, 1, 0); // Start publish NOW -> sets published to true, must republish all
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  //this tests that both testfile and indexfile have been (re)queued for republication since the last 'now'
  TestEQ(TRUE, IsBeingPublishedSince(testfile->id, now), `Testfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  TestEQ(TRUE, IsBeingPublishedSince(indexfile->id, now), `Indexfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->id, now, 1, 0); // Republish only testfile, now
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  //this tests that testfile has been (re)queued for republication since the last 'now', but not indexfile
  TestEQ(TRUE, IsBeingPublishedSince(testfile->id, now), `Testfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  TestEQ(FALSE, IsBeingPublishedSince(indexfile->id, now), `Indexfile ${indexfile->id} shouldn't have been republished since ${AnyToString(now, "tree")}`);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->id, now, 2, 0); // Unpublish file
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  TestEQ(TRUE, WaitForBeenPublished(indexfile->id, now), `Indexfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  testfile->Refresh();
  TestEQ(FALSE, testfile->publish);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->parent, now, 1, 0); // Publish folder
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  TestEQ(TRUE, IsBeingPublishedSince(testfile->id, now), `Testfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  TestEQ(TRUE, IsBeingPublishedSince(indexfile->id, now), `Indexfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->parent, now, 1, 0); // Republish folder
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  TestEQ(TRUE, IsBeingPublishedSince(testfile->id, now), `Testfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  TestEQ(TRUE, IsBeingPublishedSince(indexfile->id, now), `Indexfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);

  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->parent, now, 2, 0); // Unpublish folder
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  indexfile->Refresh();
  TestEQ(FALSE, indexfile->publish);
  testfile->Refresh();
  TestEQ(FALSE, testfile->publish);

  // Publish everything
  testfw->BeginWork();
  now := GetCurrentDateTime();
  AddFileTask(testfile->parent, now, 1, 0); // Publish folder
  testfw->CommitWork();

  EnsureTasksExecuted(now);
}

MACRO SetIndexDocTest()
{
  OBJECT indexfile := GetTestsuiteTempFolder()->OpenByPath("index.html");
  OBJECT testfile := GetTestsuiteTempFolder()->OpenByPath("test.html");

  testfw->BeginWork();
  indexfile->UpdateMetadata([ name := "test2.html" ]);
  testfw->CommitWork();

  TestEQ(indexfile->id, GetTestsuiteTempFolder()->indexdoc);

  // Make sure any republication is done
  EnsureTasksExecuted(GetCurrentDatetime());

  testfw->BeginWork();
  DATETIME now := GetCurrentDateTime();
  AddFileTask(testfile->id, now, 5, 0);
  testfw->CommitWork();

  EnsureTasksExecuted(now);

  GetTestsuiteTempFolder()->Refresh();
  TestEQ(testfile->id, GetTestsuiteTempFolder()->indexdoc);

  TestEQ(TRUE, IsBeingPublishedSince(testfile->id, now), `Testfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
  TestEQ(TRUE, IsBeingPublishedSince(indexfile->id, now), `Indexfile ${indexfile->id} should have been republished since ${AnyToString(now, "tree")}`);
}

RunTestFramework([ PTR TestLifecycle
                 , PTR PublicationDeleteFile
                 , PTR PublicationDeleteFolder
                 , PTR PublicationMoveFile
                 , PTR PublicationStartStopTest
                 , PTR SetIndexDocTest
                 ]);
