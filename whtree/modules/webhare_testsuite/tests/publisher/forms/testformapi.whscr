<?wh

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/validation.whlib";

LOADLIB "mod::publisher/lib/forms/api.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";

LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";
LOADLIB "mod::webhare_testsuite/lib/internal/testsite.whlib";

MACRO VerifyNot18Conditions(OBJECT formdefs, OBJECT formpage, OBJECT field, OBJECT field_toggleselectoptions)
{
  RECORD condition := formdefs->GetConditionAttribute(field, "enabledconditionid");
  OBJECT cbox := field->previouselementsibling;

  //not18 points to the cbox in conditions[0] and conditions[1], which is cloned. [2] points to toggleselectoptions
  TestEq(cbox->GetAttribute("guid"), condition.conditions[1].field);
  TestEq(field_toggleselectoptions->GetAttribute("guid"), condition.conditions[2].field);
}

OBJECT FUNCTION Get2ndGroup1stNot18(OBJECT dupedpage_obj)
{
  OBJECT ARRAY dupedpage_obj_groups := dupedpage_obj->ListChildren("*","group");
  TestEq(4,Length(dupedpage_obj_groups));

  //Let's get the 2nd group 1st not18 question
  OBJECT dupedpage_2ndgroup_1stnot18 := dupedpage_obj_groups[2]->ListChildren("*","*")[3];
  RETURN dupedpage_2ndgroup_1stnot18;
}

MACRO TestCoreFormAPI()
{
  OBJECT testfile := OpenTestsuiteSite()->OpenBypath("testpages/formtest");
  OBJECT webdesign := GetWebDesign(testfile->id);
  OBJECT coreform := webdesign->OpenForm("coretest", [ formref := "CORE-TEST-FORM"]);

  // this textedit has no value=""
  TestEq("", coreform->^number->emptyvalue);

  TestEq(0,coreform->^number->value);
  TestEq('',coreform->^number->textvalue);
  TestEq('', coreform->^number->__GetRenderData().value);
  TestEq(0, coreform->^number->GetRenderTree().value);
  TestEq('', coreform->^number->GetRenderTree().textvalue);

  // re-assigning the same value (0) will set it (we also considered it not having side-effects at all but we assume that explicitly setting 0 means you want it to be filled with that (eg a prefill?)
  coreform->^number->value := coreform->^number->value;
  TestEq('0',coreform->^number->textvalue);
  TestEq('0',coreform->^number->__GetRenderData().value);
  TestEq(0, coreform->^number->GetRenderTree().value);
  TestEq('0', coreform->^number->GetRenderTree().textvalue);

  // this textedit value="0" emptyvalue=0" explicitly sets a value
  TestEq("0", coreform->^numberemptyvalue->emptyvalue);
  TestEq('0',coreform->^numberemptyvalue->textvalue);
  //and SHOULD be fowarded for consistency (we didn't do this up to 4.35.1)
  TestEq('0',coreform->^numberemptyvalue->__GetRenderData().value);
  TestEq(0, coreform->^numberemptyvalue->GetRenderTree().value);
  TestEq('0', coreform->^numberemptyvalue->GetRenderTree().textvalue);

  // setting its value to the value referred by emptyvalue will clear the text value. so here self-set ... will do the reverse from above
  coreform->^numberemptyvalue->value := coreform->^numberemptyvalue->value;
  TestEq('',coreform->^numberemptyvalue->textvalue);
  TestEq('',coreform->^numberemptyvalue->__GetRenderData().value);
  TestEq(0, coreform->^numberemptyvalue->GetRenderTree().value);
  TestEq('', coreform->^numberemptyvalue->GetRenderTree().textvalue);

  coreform->^numberemptyvalue->emptyvalue := "-1";
  TestEq('',coreform->^numberemptyvalue->textvalue);
  TestEq('',coreform->^numberemptyvalue->__GetRenderData().value);
  TestEq(-1, coreform->^numberemptyvalue->GetRenderTree().value);
  TestEq('', coreform->^numberemptyvalue->GetRenderTree().textvalue);
}

MACRO FormApitest()
{
  RECORD res := BuildCustomWebtoolForm2( [ addgtmdatalayer := "muhdata", addtslinecomp := TRUE, addtslinecompascustom := TRUE, addcheckboxfield := TRUE, addaddressfield := TRUE,checkboxes := TRUE, checkboxfieldconditions := FALSE, setmailresultsfields := TRUE, checkboxsubs := TRUE, addconditions := TRUE]);

  OBJECT formdefs := OpenWHFSFormDefinitionsFile(res.formfile);
  OBJECT formdef := formdefs->OpenFormDefinition("webtoolform");
  OBJECT formpage := formdef->GetPage(0);

  TestEq(DEFAULT OBJECT, formpage->LookupComponent("doesnotexist"), "requesting nonexisting component should not crash");

  // Ensure duplicated questions are cleared from pins and name, and have a new guid
  OBJECT firstname := formpage->LookupComponent("firstname");
  TestEq(TRUE, ObjectExists(firstname));
  TestEq(TRUE, firstname->GetAttribute("tid") != "");

  OBJECT firstname2 := formpage->DuplicateComponent(firstname);
  TestEq(TRUE, ObjectExists(firstname2));
  TestEq(firstname->GetAttribute("tid"), firstname2->GetAttribute("tid"));
  TestEq(TRUE, firstname2->IsSameNode(firstname->nextelementsibling), "component should be inserted right next to its source");
  TestEq(firstname->GetAttribute("title"), firstname2->GetAttribute("title"), "title should be copied");
  TestEq(FALSE, firstname2->HasAttribute("pins"));
  TestEq(FALSE, firstname2->HasAttribute("name"));
  TestEq(TRUE, firstname->GetAttribute("guid") != firstname2->GetAttribute("guid"));

  // Ensure duplicated <option>s have their subquestions duplicated too, and properly reset
  OBJECT checkboxes := formpage->LookupComponent("checkboxes");
  OBJECT checkboxes_option0 := checkboxes->QuerySelector("option");
  TestEq(DEFAULT OBJECT, formpage->LookupComponent(checkboxes_option0->GetAttribute("guid")), "LookupComponent should not match options");
  TestEq(DEFAULT OBJECT, formpage->LookupComponent(checkboxes_option0->GetAttribute("rowkey")), "LookupComponent should not match options");

  OBJECT checkboxes_option1_textedit := checkboxes->QuerySelectorAll("option")->Item(2)->QuerySelector("textedit");

  OBJECT checkboxes2 := formpage->DuplicateComponent(checkboxes);
  OBJECT checkboxes2_option0 := checkboxes2->QuerySelector("option");
  TestEq(FALSE, checkboxes->GetAttribute("guid") = checkboxes2->GetAttribute("guid"));
  TestEq(checkboxes->QuerySelectorAll("option")->length, checkboxes2->QuerySelectorAll("option")->length);

  OBJECT checkboxes2_option1_textedit := checkboxes2->QuerySelectorAll("option")->Item(2)->QuerySelector("textedit");
  TestEq(TRUE, ObjectExists(checkboxes2_option1_textedit));
  TestEq(TRUE, checkboxes_option1_textedit->GetAttribute("guid") != checkboxes2_option1_textedit->GetAttribute("guid"));

  // Ensure conditions are duplicated (their GUID must be new)
  OBJECT checkboxes_option2 := checkboxes->QuerySelectorAll("option")->Item(2);
  OBJECT checkboxes2_option2 := checkboxes2->QuerySelectorAll("option")->Item(2);

  TestEq(TRUE, checkboxes_option2->GetAttribute("visibleconditionid") != checkboxes2_option2->GetAttribute("visibleconditionid"));
  TestEq(formdefs->GetConditionAttribute(checkboxes_option2, "visibleconditionid"), formdefs->GetConditionAttribute(checkboxes2_option2, "visibleconditionid") );

  // Duplicate the cbox, date & dependent email component in Groups & Stuff
  OBJECT groups_stuff := formpage->LookupComponent("group1");
  OBJECT group1_dummycbox := formpage->LookupComponent("dummycbox");
  OBJECT group1_date := formpage->LookupComponent("date");
  OBJECT group1_not18 := formpage->LookupComponent("not18");

  TestEq("mixedtypes", formdef->PrepareDuplicate(OBJECT[groups_stuff, group1_date]).error);
  TestEq("mixedtypes", formdef->PrepareDuplicate(OBJECT[formpage->node, group1_date]).error);
  TestEq("mixedtypes", formdef->PrepareDuplicate(OBJECT[formpage->node, group1_not18]).error);

  // Not putting the list in the right order, should still appear as group1_date, group1_dummycbox group1_not18
  OBJECT ARRAY duped := formdef->PrepareDuplicate([group1_not18, group1_date, group1_dummycbox]).duplicator->Run();
  OBJECT duped_date := duped[0];
  TestEq("date", duped_date->localname, "The duplicated date should be a date");
  OBJECT duped_dummycbox := duped[1];
  TestEq("checkbox", duped_dummycbox->localname, "The duplicated cbox should still be a checkbox");
  OBJECT duped_not18 := duped[2];
  TestEq("email", duped_not18->GetAttribute("validationchecks"), "The duplicated not18 should be an email field" );
  // Print(formdef->GetOutline()||'\n');
  TestAssert(duped[2]->previouselementsibling->IsSameNode(duped[1]), "The duped elements should be in original form order");
  TestAssert(duped[1]->previouselementsibling->IsSameNode(duped[0]), "The duped elements should be in original form order");
  TestAssert(duped[0]->previouselementsibling->IsSameNode(group1_not18), "The duped cbox should be after the original not18 question");
  TestAssert(group1_dummycbox->GetAttribute("guid") != duped_dummycbox->GetAttribute("guid"));

  OBJECT field_toggleselectoptions := formpage->LookupComponent("toggleselectoptions");
  VerifyNot18Conditions(formdefs, formpage, group1_not18, field_toggleselectoptions);
  VerifyNot18Conditions(formdefs, formpage, duped_not18, field_toggleselectoptions);

  OBJECT groups_contact := formpage->LookupComponent("groups_contact");
  //Duplicate groups&stuff and contact group
  OBJECT ARRAY duped_groups := formdef->PrepareDuplicate([groups_contact, groups_stuff]).duplicator->Run();
  TestEq(2, Length(duped_groups));

  TestAssert(duped_groups[1]->previouselementsibling->IsSameNode(duped_groups[0]), "The duped groups should be in original form order");
  TestAssert(duped_groups[0]->previouselementsibling->IsSameNode(groups_contact), "The duped gruop shoul be after groups_contact which is the last group");

  //Verify both group's lengths
  OBJECT dupedgroup_stuff := duped_groups[0];
  OBJECT dupedgroup_contact := duped_groups[1];
  TestEq(7, Length(dupedgroup_stuff->ListChildren("*","*")));
  TestEq(4, Length(dupedgroup_contact->ListChildren("*","*")));

  //Verify remapping
  VerifyNot18Conditions(formdefs, formpage, dupedgroup_stuff->ListChildren("*","*")[3], field_toggleselectoptions);
  VerifyNot18Conditions(formdefs, formpage, dupedgroup_stuff->ListChildren("*","*")[6], field_toggleselectoptions);

  //Duplicate the page
  OBJECT ARRAY dupedpages := formdef->PrepareDuplicate(OBJECT[formpage->node]).duplicator->Run();
  OBJECT dupedpage_obj := dupedpages[0];
  OBJECT dupedpage := formdef->GetPage(1);
  TestEq("", dupedpage->Role);
  TestEq(Length(dupedpage_obj->ListChildren("*","*")),Length(formpage->node->ListChildren("*","*")), "# of questions should be the same");

  //Find the dupedgroup_stuff in the duped page and get the 2nd group 1st not18 question
  OBJECT dupedpage_2ndgroup_1stnot18 := Get2ndGroup1stNot18(dupedpage_obj);

  //VerifyNot18Conditions will point to the cloned toggleselectoptions now
  OBJECT cloned_toggleselectoptions := dupedpage_obj->ListChildren("*","select")[0];
  VerifyNot18Conditions(formdefs, dupedpage, dupedpage_2ndgroup_1stnot18, cloned_toggleselectoptions);

  //Move the cloned_toggleselectoption to the first page
  formpage->node->AppendChild(cloned_toggleselectoptions);

  //Dupe page 1
  OBJECT ARRAY dupedpages2 := formdef->PrepareDuplicate(OBJECT[dupedpage_obj]).duplicator->Run();
  TestEq(1, Length(dupedpages2));
  OBJECT page2 := dupedpages2[0];
  // print(formdef->GetOutline()||'\n');

  // Page2 can't clone a toggleselectoptions so should still point to the cloned verison we moved from page1 to page0
  OBJECT page2_toggleselectoptions := page2->ListChildren("*","select")[0];
  VerifyNot18Conditions(formdefs, formdef->GetPage(2), Get2ndGroup1stNot18(page2), cloned_toggleselectoptions);

  RECORD validation := ValidateSingleFile("whfs::dummy.formdef.xml", [ overridedata := formdefs->ExportAsRecord().text]);
  TestEq(RECORD[], validation.messages);

  // Save what we have we can inspect it in the formedit app
  testfw->BeginWork();
  formdefs->SaveToWHFS(res.formfile);
  testfw->CommitWork();
  Print(`Edit url: ${GetPrimaryWebhareinterfaceURL()}?app=publisher(${res.formfile->id})\n`);
}

RunTestframework([ PTR TestCoreFormAPI
                 , PTR FormApitest
                 ]);
