<?wh
/* Test dealing with an assetpackmgr if compilation breaks */

LOADLIB "wh::files.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/testframework.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/compiler.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/modules/support.whlib";


RECORD extracted;
STRING mytempmodulename := GetRandomTestModuleName();

MACRO AddImportViaMod(INTEGER version)
{
  STRING moduleroot := GetModuleinstallationroot(mytempmodulename);
  CreateDiskDirectoryRecursive(moduleroot || "webdesigns/testdesign/resolvetest/", TRUE);

  IF (version = 1)
  {
    CreateDiskDirectoryRecursive(moduleroot || "webdesigns/testdesign/node_modules/@group/testpkg/", TRUE);
    DeleteDiskDirectoryRecursive(moduleroot || "webdesigns/testdesign/resolvetest/node_modules/");
  }
  ELSE
  {
    CreateDiskDirectoryRecursive(moduleroot || "webdesigns/testdesign/resolvetest/node_modules/@group/testpkg/", TRUE);
    DeleteDiskDirectoryRecursive(moduleroot || "webdesigns/testdesign/node_modules/");
  }

  StoreDiskFile(moduleroot || "webdesigns/testdesign/resolvetest/test.es", StringToBlob(`window.version = ${version};`), [ overwrite := TRUE ]);
  StoreDiskFile(moduleroot || "webdesigns/testdesign/resolvetest/sass.scss", StringToBlob(
`
@import '~@mod-${mytempmodulename}/webdesigns/testdesign/resolvetest/sass2';
@import '~@group/testpkg/sass3.scss';
`), [ overwrite := TRUE ]);
  StoreDiskFile(moduleroot || "webdesigns/testdesign/resolvetest/sass2.scss", StringToBlob(`div { background: ${version = 1 ? "red" : "green"} }`), [ overwrite := TRUE ]);
  StoreDiskFile(moduleroot || `webdesigns/testdesign/${version=2?"resolvetest/":""}node_modules/@group/testpkg/sass3.scss`, StringToBlob(`div { background: ${version = 1 ? "red" : "green"} }`), [ overwrite := TRUE ]);

  // Add imports to
  BLOB org_testdesign_es := GetDiskResource(moduleroot || "webdesigns/testdesign/testdesign.es");
  IF (BlobToString(org_testdesign_es) NOT LIKE "*resolvetest/test*")
  {
    StoreDiskFile(moduleroot || "webdesigns/testdesign/testdesign.es", StringToBlob(BlobToString(org_testdesign_es) ||
`
import "@mod-${mytempmodulename}/webdesigns/testdesign/resolvetest/test";
import "@mod-${mytempmodulename}/webdesigns/testdesign/resolvetest/sass.scss";
`), [ overwrite := TRUE ]);
  }

  PRINT(`module root for version ${version}: ${GetModuleinstallationroot(mytempmodulename)}\n`);
}

STRING FUNCTION GetFilePathFromDeps(RECORD status, STRING postfix)
{
  RETURN
    SELECT AS STRING path
      FROM ToRecordArray(status.dependencies.filedependencies, "PATH")
     WHERE path LIKE "*" || postfix;
}

MACRO CheckTestUsedFilePaths(RECORD status, INTEGER version)
{
  STRING testfile_path :=
    SELECT AS STRING path
      FROM ToRecordArray(status.dependencies.filedependencies, "PATH")
     WHERE path LIKE "*/webdesigns/testdesign/resolvetest/test.es";

  TestEq(`mod::${mytempmodulename}/webdesigns/testdesign/resolvetest/test.es`, GetFilePathFromDeps(status, "test.es"), "Path to test.es points to an old module (or no reference found to the file)");
  TestEq(`mod::${mytempmodulename}/webdesigns/testdesign/resolvetest/sass.scss`, GetFilePathFromDeps(status, "sass.scss"), "Path to sass.scss points to an old module (or no reference found to the file)");
  TestEq(`mod::${mytempmodulename}/webdesigns/testdesign/resolvetest/sass2.scss`, GetFilePathFromDeps(status, "sass2.scss"), "Path to sass2.scss points to an old module (or no reference found to the file)");
  TestEq(`mod::${mytempmodulename}/webdesigns/testdesign/${version=2?"resolvetest/":""}node_modules/@group/testpkg/sass3.scss`, GetFilePathFromDeps(status, "sass3.scss"), "Path to sass3.scss points to an old module (or no reference found to the file). Module._pathCache reset probably failed.");
}

ASYNC MACRO EnsureValidTestModuleWebDesignWebsiteBundle()
{
  /* Make sure the bundle compiled
     TODO: this validates the result of PrepareTestModuleWebDesignWebsite
           but isn't there a race here if the service hasn't even picked up a new module is there yet ? it's doing

  OBJECT FUNCTION DoWait(RECORD bundle, BOOLEAN acceptstale)
  {
    IF (bundle.lastcompile != DEFAULT DATETIME AND (acceptstale OR (NOT bundle.iscompiling AND NOT bundle.requirecompile)))
      RETURN CreateResolvedPromise(CELL[ bundle.haserrors, bundle.lastcompile, bundle.lastcompiletoken, bundle.outputtag ]);

          but if the assetpack is not *yet* compiling I can imagine getting an old  result here */

  OBJECT service := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  TRY
  {
    RECORD res := AWAIT service->WaitForCompile(`${mytempmodulename}:testdesign`, FALSE);
    TestEq(FALSE, res.haserrors, `compile of ${mytempmodulename}:testdesign should have succeeded`);
  }
  CATCH(OBJECT e)
  {
    //explain because we have no stacktrace!
    PrintTo(2, "EnsureValidTestModuleWebDesignWebsiteBundle failed: " || e->what || "\n");
    THROW;
  }
}

MACRO TestCrashJson()
{
  AddImportViaMod(1);
  PRINT(`1st module root: ${GetModuleinstallationroot(mytempmodulename)}\n`);

  testfw->BeginWork();
  OBJECT siteroot := testfw->GetTestSite()->rootobject;
  OBJECT dynfolder := siteroot->CreateFolder( [ name:="dynfolder"
                                              , typens := "http://www.webhare.net/xmlns/webhare_testsuite/webdesign-dynfolder"
                                              ]);
  dynfolder->CreateFile([name := "index.shtml", typens := "http://www.webhare.net/xmlns/publisher/dynamicfoldercontents", publish := TRUE ]);
  testfw->CommitWork();
  WaitForPublishCompletion(siteroot->id);

  testfw->FlushTasks([ "webhare_testsuite:aftercompile" ]);
  TestEq(TRUE, ReadRegistryKey("webhare_testsuite.tests.lastaftercompile") > testfw->starttime, "aftercompile task was NOT invoked");

  TestEq(TRUE, testfw->browser->GotoWebPage(siteroot->objecturl || "dynfolder/"), testfw->browser->href);

  OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  extracted := ExtractBundleOutputTag(testfw->browser->document);
  WaitForPromise(assetpackcontrol->WaitForCompile(extracted.outputtag, FALSE));
  RECORD status := WaitForPromise(assetpackcontrol->GetBundleStatus(extracted.outputtag));

// Module not found: Error: Cannot resolve 'file' or 'directory' /opt/whdata/installedmodules/webhare_testsuite_tests/${mytempmodulename}/webdesigns/testdesign/resolvetest/testdesign in /opt/whdata/tmp
  //print( GetModuleinstallationroot(mytempmodulename) || "webdesigns/testdesign\n" );
  //DumpValue(ReadDiskDirectory( GetModuleinstallationroot(mytempmodulename) || "webdesigns/testdesign", "*"),'boxed');
  //DumpValue(ReadDiskDirectory( GetModuleinstallationroot(mytempmodulename) || "webdesigns/testdesign/js", "*"),'boxed');
  TestEq(FALSE, status.haserrors, "Could not compile valid bundle " || extracted.outputtag || "\n" || status.stats);
  CheckTestUsedFilePaths(status, 1);

  //Now kill the package.json
  StoreDiskFile(GetModuleinstallationroot(mytempmodulename) || "webdesigns/testdesign/package.json", StringToBlob("This is not a JSON file"), [ overwrite := TRUE ]);
  WaitForPromise(assetpackcontrol->RecompileBundle(extracted.outputtag)); //don't want to wait for fswatch to pick it up
  WaitForPromise(assetpackcontrol->WaitForCompile(extracted.outputtag, FALSE));

  status := WaitForPromise(assetpackcontrol->GetBundleStatus(extracted.outputtag));
  TestEqLike("Package.json*not valid JSON", status.errors, "Wrong errors for bundle " || extracted.outputtag);
}

MACRO TestRecompileAfterModuleReplace()
{
  testfw->SetupTestModule(CELL[ timestampfolder := TRUE, replaceexistingmodule := TRUE, modulename := mytempmodulename ]);
  SetupWebDesign("publisher:blank", mytempmodulename, "TestDesign", [ aftercompiletask := "webhare_testsuite:aftercompile"] );
  AddImportViaMod(2);
  RecompileSiteProfiles(); //makes sure the XML/siteprl changes are picked up synchronously
  ApplyWebHareConfiguration([ subsystems := ["assetpacks"]]);

  OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  WaitForPromise(assetpackcontrol->RecompileBundle(extracted.outputtag)); //don't want to wait for fswatch to pick it up
  WaitForPromise(assetpackcontrol->WaitForCompile(extracted.outputtag, FALSE));
  RECORD status := WaitForPromise(assetpackcontrol->GetBundleStatus(extracted.outputtag));
  TestEq(FALSE, status.haserrors, "Could not compile valid bundle " || extracted.outputtag || "\n" || status.stats);

  CheckTestUsedFilePaths(status, 2);

  AddImportViaMod(1);
  RecompileSiteProfiles(); //makes sure the XML/siteprl changes are picked up synchronously

  WaitForPromise(assetpackcontrol->RecompileBundle(extracted.outputtag)); //don't want to wait for fswatch to pick it up
  WaitForPromise(assetpackcontrol->WaitForCompile(extracted.outputtag, FALSE));
  status := WaitForPromise(assetpackcontrol->GetBundleStatus(extracted.outputtag));
  TestEq(FALSE, status.haserrors, "Could not compile valid bundle " || extracted.outputtag || "\n" || status.stats || ", resetting Module._pathCache probably didn't reset the path cache correctly");

  CheckTestUsedFilePaths(status, 1);
}

RunTestframework([ PTR PrepareTestModuleWebDesignWebsite("publisher:blank", [istemplate := TRUE, withcontent := FALSE, timestampfolder := TRUE, modulename := mytempmodulename ])
                 , PTR EnsureValidTestModuleWebDesignWebsiteBundle
                 , PTR TestCrashJson
                 , PTR TestRecompileAfterModuleReplace()
                 ]);
