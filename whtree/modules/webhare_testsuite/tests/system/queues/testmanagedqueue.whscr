<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::system/lib/tasks.whlib";

RECORD val;

MACRO StoreValue(RECORD v)
{
  val := v;
}

ASYNC MACRO TestWaitableAction()
{
  INTEGER taskid;
  OBJECT ephtask;
  DATETIME teststart := GetCurrentDatetime();

  TestThrowsLike("No such managed task type *webhare_testsuite:nosuchtask*", PTR ScheduleManagedTask("webhare_testsuite:nosuchtask", DEFAULT RECORD));
  TestThrowsLike("No such ephemeral task type *webhare_testsuite:nosuchtask*", PTR ScheduleEphemeralTask("webhare_testsuite:nosuchtask", DEFAULT RECORD));

  TestEq(0, Length(LookupManagedTasks("webhare_testsuite:ping", [ createdafter := teststart ])));

  testfw->BeginWork();
  ephtask := ScheduleEphemeralTask("webhare_testsuite:ping", [ ping := 43 ]);
  testfw->RollbackWork();
  TestThrowsLike("*was queued did not commit*", PTR WaitForPromise(ephtask)); //this task can never run because the transaction rolled back

  testfw->BeginWork();
  taskid := ScheduleManagedTask("webhare_testsuite:ping", [ ping := 42 ]);
  ephtask := ScheduleEphemeralTask("webhare_testsuite:ping", [ ping := 43 ])->Then(PTR StoreValue);

  TestEq(1, Length(LookupManagedTasks("webhare_testsuite:ping", [ createdafter := teststart ])));
  TestEq(1, Length(LookupManagedTasks("webhare_testsuite:ping", [ createdafter := teststart, unfinished := TRUE ])));
  testfw->CommitWork();

  TestEq([pong := 42, managedtaskid := taskid ], RetrieveManagedTaskResult(taskid, MAX_DATETIME));
  RECORD taskinfo := DescribeManagedTask(taskid);
  TestEq(TRUE, taskinfo.finished <= GetCurrentDatetime(), 'task should be marked as finished');

  testfw->BeginWork();
  taskid := ScheduleManagedTask("webhare_testsuite:pingretry2", [ ping := "ABORT" ]);
  testfw->CommitWork();

  TestThrowsLike("*PING-TASK-Abort*", PTR RetrieveManagedTaskResult(taskid, MAX_DATETIME)); //crashes because we told it to
  TestEq(DEFAULT RECORD, RetrieveManagedTaskResult(taskid, DEFAULT DATETIME, [ accepttempfailure := TRUE, accepttimeout := TRUE ])); //if we probe for temporay failures we won't get a throw
  taskinfo := DescribeManagedTask(taskid);
  TestEq(1, taskinfo.failures);
  TestEq(DEFAULT DATETIME, taskinfo.finished, 'task should still be marked as unfinished');
  TestEq(TRUE, taskinfo.nextattempt > GetCurrentDatetime() AND taskinfo.nextattempt < AddDaySToDate(1,GetCurrentDatetime()),"Should still be queued");

  testfw->BeginWork();
  RetryPendingManagedTasksByIds([taskid]);
  testfw->CommitWork();

  TestThrowsLike("*PING-TASK-Abort*", PTR RetrieveManagedTaskResult(taskid, MAX_DATETIME, [accepttempfailure := TRUE]));
  taskinfo := DescribeManagedTask(taskid);
  TestEq(2, taskinfo.failures);
  TestEq(TRUE, taskinfo.finished < GetCurrentDatetime(), "task should now be ignored for further requeueing");

  TestEq(TRUE, ObjectExists(ephtask));
  TestEq(0, Length(LookupManagedTasks("webhare_testsuite:ping", [ createdafter := teststart, unfinished := TRUE ])));
  TestEq(1, Length(LookupManagedTasks("webhare_testsuite:ping", [ createdafter := teststart, unfinished := FALSE ])));
  WaitForPromise(ephtask);
  TestEq([ephpong := 43, managedtaskid := 0], val);

  testfw->BeginWork();
  taskid := ScheduleManagedTask("webhare_testsuite:ping", [ ping := 1 ], [ auxdata := [ ping := RepeatText("X",10000) ] ] );
  testfw->CommitWork();
  ephtask := ScheduleEphemeralTask("webhare_testsuite:ping", [ ping := 1 ], [ auxdata := [ ping := RepeatText("Y",10000) ] ] )->Then(PTR StoreValue);

  TestEq([pong := RepeatText("X",10000), managedtaskid := taskid ],RetrieveManagedTaskResult(taskid, MAX_DATETIME));
  WaitForPromise(ephtask);
  TestEq([ephpong := RepeatText("Y",10000), managedtaskid := 0 ],val);

  ephtask := ScheduleEphemeralTask("webhare_testsuite:ping", [ ping := "ABORT" ]);
  TestThrowsLike('*PING-TASK-Abort*', PTR WaitForPromise(ephtask));
  ephtask := ScheduleEphemeralTask("webhare_testsuite:ping", [ ping := "THROW" ]);
  TestThrowsLike('*PING-TASK-Throw*', PTR WaitForPromise(ephtask));

  testfw->BeginWork();
  WriteRegistryKey("webhare_testsuite.tests.taskthrownow", TRUE);
  taskid := ScheduleManagedTask("webhare_testsuite:ping", [ ping := "THROWNOW" ]);
  testfw->CommitWork();

  RECORD info;
  WHILE(TRUE)
  {
    info := DescribeManagedTask(taskid);
    IF(info.lasterrors != "")
      BREAK;

    AWAIT CreateSleepPromise(100);
  }
  TestEqLike("*Throw-Now*", info.lasterrors);
  TestEq(TRUE, GetDatetimeDifference(GetCurrentDatetime(), info.nextattempt).msecs < 5000, "Next attempt should be within 5 seconds");
  INTEGER ARRAY todelete := [ taskid ];

  testfw->BeginWork();
  WriteRegistryKey("webhare_testsuite.tests.taskthrownow", FALSE);
  testfw->CommitWork();

  ephtask := ScheduleEphemeralTask("webhare_testsuite:nodetask", [ nodeping := 42 ]);
  val := WaitForPromise(ephtask);
  TestEq([nodepong := 42],val);

  OBJECT port := CreateGlobalIPCPort("webhare_testsuite:cancellable_connectport");


  testfw->BeginWork();
  taskid := ScheduleManagedTask("webhare_testsuite:cancellable", DEFAULT RECORD);
  testfw->CommitWork();

  // cancellable will connect to our global port
  OBJECT link := port->Accept(AddTimeToDate(60 * 1000, GetCurrentDatetime()));
  IF (NOT ObjectExists(link))
    ABORT(`Expected managed task 'cancellable' to run within a minute`);

  testfw->BeginWork();
  OBJECT cancelpromise := CancelManagedTasks([ taskid ]);
  testfw->CommitWork();

  AWAIT cancelpromise;

  RECORD msg := AWAIT link->AsyncReceiveMessage(AddTimeToDate(30 * 1000, GetCurrentDatetime()));
  TestEQ("gone", msg.status, "Task should have been killed by the cancel");

  // test timeout handling
  testfw->BeginWork();
  taskid := ScheduleManagedTask("webhare_testsuite:cancellable", DEFAULT RECORD, [ timeout := 100 ]);
  INTEGER taskid3 := ScheduleManagedTask("webhare_testsuite:timelimitedtask", [ sleep := 200 ], [ timeout := 100 ]);
  INTEGER taskid4 := ScheduleManagedTask("webhare_testsuite:timelimitedtask", [ sleep := 400 ]);
  testfw->CommitWork();

  TestThrowsLike("Task * #* has failed: Task has timed out after 100ms", PTR RetrieveManagedTaskResult(taskid, MAX_DATETIME));
  TestThrowsLike("Task * #* has failed: Task has timed out after 100ms", PTR RetrieveManagedTaskResult(taskid3, MAX_DATETIME));
  TestThrowsLike("Task * #* has failed: Task has timed out after 300ms", PTR RetrieveManagedTaskResult(taskid4, MAX_DATETIME));

  WHILE(TRUE)
  {
    //it may take an extra attempt to get the sleep-200ms task to win from its timeout, as a sleep(200) isn't guaratneed to finish immediately after 200ms
    testfw->BeginWork();
    INTEGER taskid2 := ScheduleManagedTask("webhare_testsuite:timelimitedtask", [ sleep := 200 ]);
    testfw->CommitWork();

    TRY
    {
      RECORD res := RetrieveManagedTaskResult(taskid2, MAX_DATETIME);
      TestEq([sleep := 200], res);
      BREAK;
    }
    CATCH(OBJECT e)
    {
      IF(e->what like "*timed out*")
      {
        Print("Timedout exception, it happens... " || e->What || "\n");
        Sleep(100);
        CONTINUE; //just retry
      }
      THROW;
    }
  }

  testfw->BeginWork();
  OBJECT deletepromise := DeleteManagedTasks(INTEGER[ taskid, taskid3, taskid4, ...todelete ]);
  testfw->CommitWork();

  AWAIT deletepromise;
}

RECORD FUNCTION WaitForError(INTEGER taskid)
{
  RECORD descr;

  // Wait for first error to occur
  FOR (INTEGER i := 0; i < (60 * 1000) / 100; i := i + 1)
  {
    descr := DescribeManagedTask(taskid);
    IF (descr.lasterrors != "")
      BREAK;
    Sleep(100);
  }

  IF (descr.lasterrors = "")
    THROW NEW Exception(`Timeout waiting for task #${taskid} to run`);

  RETURN descr;
}

MACRO TestMarkAsTemporaryFailure()
{
  DATETIME taskstart, retryat;
  INTEGER taskid;
  RECORD descr;

  FOR (INTEGER itr := 0; itr <= 7; itr := itr + 1)
  {
    testfw->BeginWork();
    WriteRegistryKey("webhare_testsuite.tests.tempfailretryat", DEFAULT DATETIME);
    taskstart := GetCurrentDateTime();
    taskid := ScheduleManagedTask("webhare_testsuite:temporaryfailure", DEFAULT RECORD);

    IF (itr != 0)
    {
      UPDATE system.managedtasks
         SET iterations := itr
       WHERE id = taskid;
    }

    testfw->CommitWork();

    descr := WaitForError(taskid);

    // Test the exponential backoff
    INTEGER ARRAY exp_interval_mins := [ 15, 30, 60, 2 * 60, 4 * 60, 8 * 60, 24 * 60, 24 * 60 ];
    DATETIME expected := exp_interval_mins[itr] >= 24 * 60
        ? AddDaysToDate(exp_interval_mins[itr] / (24 * 60), taskstart)
        : AddTimeToDate(exp_interval_mins[itr], taskstart);

    TestEQ(TRUE, descr.nextattempt >= expected);

    testfw->BeginWork();
    CancelManagedTasks([ taskid ]);
    testfw->CommitWork();
  }

  {
    // Test honouring specifying retryat option
    testfw->BeginWork();
    retryat := AddTimeToDate(2 * 60 * 1000, GetCurrentDateTime());
    WriteRegistryKey("webhare_testsuite.tests.tempfailretryat", retryat);
    taskstart := GetCurrentDateTime();
    taskid := ScheduleManagedTask("webhare_testsuite:temporaryfailure", DEFAULT RECORD);
    testfw->CommitWork();

    descr := WaitForError(taskid);

    // Check if retryat is honoured
    TestEQ(retryat, descr.nextattempt);

    testfw->BeginWork();
    CancelManagedTasks([ taskid ]);
    testfw->CommitWork();
  }
}

ASYNC MACRO TestNotBeforeTasks()
{
  DATETIME now := GetCurrentDateTime();

  testfw->BeginWork();
  INTEGER taskid := ScheduleManagedTask("webhare_testsuite:ping", [ ping := 42 ], [ notbefore := AddTimeToDate(2000, now) ]);
  INTEGER taskid2 := ScheduleManagedTask("webhare_testsuite:ping", [ ping := 42 ], [ notbefore := AddTimeToDate(2000, now) ]);
  WriteRegistryKey("webhare_testsuite.tests.tempfailretryat", DEFAULT DATETIME);
  INTEGER taskid3 := ScheduleManagedTask("webhare_testsuite:temporaryfailure", DEFAULT RECORD, [ notbefore := AddTimeToDate(60000, now) ]);
  testfw->CommitWork();

  TestEQMembers([ notbefore := AddTimeToDate(2000, now), nextattempt := AddTimeToDate(2000, now) ], DescribeManagedTask(taskid), "*");

  testfw->BeginWork();
  RetryPendingManagedTasksByIds([ taskid2 ]);
  RetryPendingManagedTasks("webhare_testsuite:temporaryfailure");
  testfw->CommitWork();

  TestEQMembers([ notbefore := AddTimeToDate(2000, now), nextattempt := AddTimeToDate(2000, now) ], DescribeManagedTask(taskid2), "*");
  TestEQMembers([ notbefore := AddTimeToDate(60000, now), nextattempt := AddTimeToDate(60000, now) ], DescribeManagedTask(taskid3), "*");

  // should not resolve within the first 1.5 second
  TestEQ(DEFAULT RECORD, RetrieveManagedTaskResult(taskid, AddTimeToDate(1500, now), [ accepttimeout := TRUE ]));

  // but it should resolve when waiting for it (10 secs should be enough for CI, all other tasks are deleted)
  TestEQ([ managedtaskid := taskid, pong := 42 ], RetrieveManagedTaskResult(taskid, AddTimeToDate(10000, now)));

  testfw->BeginWork();
  OBJECT cancelpromise := CancelManagedTasks([ taskid, taskid2, taskid3 ]);
  testfw->CommitWork();

  AWAIT cancelpromise;
}

RunTestframework([ PTR TestWaitableAction
                 , PTR TestMarkAsTemporaryFailure
                 , PTR TestNotBeforeTasks
                 ]);
