<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";
LOADLIB "wh::internet/webdav.whlib";

LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/testframework.whlib";
LOADLIB "mod::webhare_testsuite/lib/system/tests.whlib";
LOADLIB "mod::system/lib/remoting/client.whlib";
LOADLIB "mod::system/lib/internal/editorsupport.whlib";


INTEGER FUNCTION SearchSourceElementLine(STRING resource, STRING ARRAY searchparts)
{
  STRING data := BlobToString(GetWebhareResource(resource));
  INTEGER pos := 0;
  FOREVERY (STRING part FROM searchparts)
  {
    pos := SearchSubString(data, part, pos);
    IF (pos = -1)
      THROW NEW Exception(`Could not find part '${part} in file ${resource}`);
    pos := pos + LENGTH(part);
  }
  RETURN LENGTH(Tokenize(Left(data, pos), "\n"));
}

RECORD port;
STRING baseurl;
STRING testfiledata;
STRING testfilerelpath;
RECORD connectinfo;

MACRO PrepareTests()
{
  port := testfw->GetLocalhostWebinterface();
  baseurl := port.baseurl;

  STRING connectinforoot := GetWebHareConfiguration().installationroot;
  STRING connectinfopath := MergePath(connectinforoot, ".wh.connectinfo");
  connectinfo := DecodeJSONBlob(GetDiskResource(connectinfopath));

  STRING testfilepath := GetWebHareResourceDiskPath("mod::system/moduledefinition.xml");
  testfiledata := BlobToString(GetDiskResource(testfilepath));
  testfilerelpath := ResolveToRelativePath(connectinforoot, testfilepath);
}

MACRO TestToddService()
{
  STRING portal := OpenTestsuiteSite()->webroot || 'portal1/';
  STRING toddrpc := ResolveToAbsoluteURL(portal, "/wh_services/tollium/todd");
  STRING wrdauthrpc := ResolveToAbsoluteURL(portal, "/wh_services/wrd/auth");

  //ABORT(testfw->browser->CallJSONRPC(`${baseurl}wh_services/wrd/auth`, "Login", toddrpc, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"), FALSE));
  //testfw->browser->Debug:=TRUE;
  TestEq(TRUE, testfw->browser->CallJSONRPC(wrdauthrpc, "Login", portal, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"), FALSE).success);

  RECORD searchres := InvokeRemoteFunctionWithBrowser(testfw->browser, `${toddrpc}/GetWebdavOpenInfo`, portal, 'wh::system.whlib', DEFAULT RECORD);
  //FIXME should be able to get 'local' paths
  TestEq("/system/modules/system/whlibs/system.whlib", searchres.item);
  TestEq(testfw->GetUserLogin("sysop"), searchres.login);
  TestEqLike("????-????-????-????", searchres.password);

  searchres := InvokeRemoteFunctionWithBrowser(testfw->browser, `${toddrpc}/GetWebdavOpenInfo`, portal, 'mod::system/screens/userrights/userrights.xml#main',
                                               [ componentpath := [ "todd0000000001:xxunknownelement", "todd0000000001:unitcontents!userandrolelist"] ]);
  //dumpvalue(searchres);
  TestEq('/system/modules/system/screens/userrights/parts/unitcontents.xml', searchres.item); // should give the <list>
  Testeq(SearchSourceElementLine("mod::system/screens/userrights/parts/unitcontents.xml", [ '<list name="userandrolelist"', '>']), searchres.data.line);

  searchres := InvokeRemoteFunctionWithBrowser(testfw->browser, `${toddrpc}/GetWebdavOpenInfo`, portal, 'mod::system/screens/userrights/userrights.xml#main',
                                               [ componentpath := [ "todd0000000001:xxunknownelement" ] ]);
  //dumpvalue(searchres);
  TestEq('/system/modules/system/screens/userrights/userrights.xml', searchres.item); //should give us the <screen>
  Testeq(SearchSourceElementLine("mod::system/screens/userrights/userrights.xml", [ '<screen name="main"', '>']), searchres.data.line);
}

MACRO TestWebdavVirtualInfo()
{
  OBJECT webdavserver := NEW WebdavConnection(baseurl || "webdav/");
  webdavserver->webbrowser->SetPassword(baseurl, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"));

  STRING webdavinfopath := "system/modules/system/.wh.webdavinfo-" || Random(1,65535);

  //OSX demands being able to propfind
  RECORD ARRAY dirinfo := webdavserver->ListDirectory(webdavinfopath);
  Testeq(0,Length(dirinfo));

  BLOB webdavinfoblob := webdavserver->Get(webdavinfopath);
  RECORD webdavinfo := DecodeJSONBlob(webdavinfoblob);

  OBJECT barebrowser := NEW WebBrowser; //build a new browser that doesn't share login cookies with testfw so we know we're permitted access
  barebrowser->SetAuthorization(webdavinfo.editorservice, "Bearer " || webdavinfo.accesstoken);

  RECORD res;
  STRING data := BlobToString(GetWebhareResource("mod::system/moduledefinition.xml"));
  res  := barebrowser->CallJSONRPC(
        webdavinfo.editorservice,
        "Validate",
        webdavinfo.translateinfo,
        "mod::system/moduledefinition.xml",
        data);


  TestEq(RECORD[], RECORD ARRAY(res.errors) CONCAT RECORD ARRAY(res.warnings), 'mod::system/moduledefinition.xml should have remotely validated');

  data := Substitute(data,'</module>','');
  res  := barebrowser->CallJSONRPC(webdavinfo.editorservice, "Validate", webdavinfo.translateinfo, "mod::system/moduledefinition.xml", data);
  TestEq(TRUE, Length(res.errors) > 0, 'There should be errors');
}

MACRO TestWebdavVirtualInfo_DavFS()
{
  //Linux insists on being able to PROPFIND the .wh.webdav-info file. PROPFIND should add it
  OBJECT webdavserver := NEW WebdavConnection(baseurl || "webdav/");
  webdavserver->webbrowser->SetPassword(baseurl, testfw->GetUserLogin("sysop"), testfw->GetUserPassword("sysop"));
  webdavserver->webbrowser->useragent := "davfs2/1.5.4 neon/0.30.1";

  RECORD ARRAY dirinfo := webdavserver->ListDirectory("system/modules/system");
  RECORD webdavinfofile := SELECT * FROM dirinfo WHERE name LIKE ".wh.webdavinfo-*";
  TestEq(TRUE,RecordExists(webdavinfofile),'Linux clients mounting webdav require .wh.webdavinfo- in their directory listing');
  TestEQ(TRUE, webdavinfofile.size > 0, "The size as reported by the propfind may not be zero (the file won't be retrieved if it is)");

  BLOB webdavinfoblob := webdavserver->Get(webdavinfofile.path);
  RECORD webdavinfo := DecodeJSONBlob(webdavinfoblob);
  TestEq(TRUE, CellExists(webdavinfo,'editorservice'));
}

MACRO TestEditSupport()
{
  RECORD retval;
  OBJECT browser := NEW WebBrowser;
  browser->SetAuthorization(connectinfo.editorservice, "bearer " || connectinfo.accesstoken);

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "validate",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , testfiledata
             ]);

  TestEQ(VARIANT[], retval.result.errors);

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "validate",
      VARIANT[ connectinfo.translateinfo
             , "mod::system/scripts/test.whscr"
             , `<?wh\n\nPRINT(ThisFunctionDoesNotExist());`
             ]);

  TestEQMembers(
      [ [ line :=     3
        , col :=      7
        , code :=     139 // Undefined function '%1'
        , msg1 :=     "THISFUNCTIONDOESNOTEXIST"
        ]
      ], retval.result.errors, "*");

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "validate",
      VARIANT[ connectinfo.translateinfo
             , "mod::system/lib/witty.witty"
             , `[embed nosuchcomponent]`
             ]);

  TestEQMembers(
      [ [ line :=     1
        , col :=      2
        , message := "No such component 'nosuchcomponent'"
        ]
      ], retval.result.errors, "*");

  // Test with corrupted moduledef
  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "validate",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , Substitute(testfiledata, "</module>", "</xmodule>")
             ]);

  TestEq("modules/system/moduledefinition.xml", retval.result.errors[0].editorpath);
  TestEq("mod::system/moduledefinition.xml", retval.result.errors[0].filename);
  TestEq("Opening and ending tag mismatch: module line 2 and xmodule", retval.result.errors[0].message);


  // Test inserting a loadlib
  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "addloadlibtosource",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , "<?wh\n\n\n\nPrint('yeey\\n');"
             , `mod::system/lib/configure.whlib`
             ]);

  TestEQ(5, retval.result.insertpos);
  TestEQ(`\nLOADLIB \"mod::system/lib/configure.whlib\";\n`, retval.result.data);

  FOR (INTEGER i := 0; i < 10; i := i + 1) // might be flaky due to other errors
  {
    TRY
      THROW NEW Exception("errortest132442");
    CATCH (OBJECT e)
      LogHareScriptException(e);

    retval := browser->InvokeJSONRPC(
        connectinfo.editorservice,
        "getremoteerrorlist",
        VARIANT[ connectinfo.translateinfo
               , testfilerelpath
               ]);

    // The errors should be somewhere in the last 8 errors, hopefully
    RECORD teststack :=
        SELECT *
          FROM retval.result.errors
         WHERE RecordExists(SELECT FROM stack WHERE CellExists(stack, "MESSAGE") ? message LIKE "*errortest132442*" : FALSE);

    IF (NOT RecordExists(teststack))
      CONTINUE;

    TestEQ(TRUE, teststack.stack[0].editorpath IN [ "modules/webhare_testsuite/tests/system/modules/testeditorsupport.whscr"
                                                  , "../../whdata/installedmodules/webhare_testsuite/tests/system/modules/testeditorsupport.whscr" //docker tests, TODO acceptable?
                                                  ]);
    BREAK;
  }

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "resolveuri",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , "mod::webhare_testsuite/tests/system/modules/testeditorsupport.whscr"
             ]);

  TestEQ(TRUE, retval.result.results[0].editorpath IN [ "modules/webhare_testsuite/tests/system/modules/testeditorsupport.whscr"
                                                      , "../../whdata/installedmodules/webhare_testsuite/tests/system/modules/testeditorsupport.whscr" //docker tests, TODO acceptable?
                                                      ]);

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "DocumentationSearch",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , "openprimary"
             ]);

  STRING refbaseurl := IsModuleInstalled("dev") ? ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(), "/reference/") : "https://www.webhare.dev/reference/";
  TestEQ(refbaseurl || "search/?fromeditor=1&query=openprimary", retval.result.url);
}

MACRO TestEditSupport_NoDev()
{
  IF(IsModuleInstalled("dev"))
  {
    Print("Skipping TestEditSupport_NoDev, dev module is installed\n");
    RETURN;
  }

  RECORD retval;
  OBJECT browser := NEW WebBrowser;
  browser->SetAuthorization(connectinfo.editorservice, "bearer " || connectinfo.accesstoken);

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "SymbolSearch",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , "openprimary"
             ]);

  TestEq(FALSE, retval.result.available);

  STRING whfilesrespath := ResolveToRelativePath(GetWebHareConfiguration().installationroot, GetWebHareResourceDiskPath("wh::files.whlib"));

  retval := browser->InvokeJSONRPC(
      connectinfo.editorservice,
      "GetLoadLibSuggestions",
      VARIANT[ connectinfo.translateinfo
             , testfilerelpath
             , "Tokenize"
             ]);
  TestEq(FALSE, retval.result.available);
}

MACRO TestUnprivileged()
{
  OBJECT webdavserver := NEW WebdavConnection(baseurl || "webdav/");
  webdavserver->webbrowser->SetPassword(baseurl, testfw->GetUserLogin("homer"), testfw->GetUserPassword("homer"));
  TestThrowsLike('Failed to get*', PTR webdavserver->Get("system/modules/system/.wh.webdavinfo-" || Random(1,65535)));
}

MACRO TestNoticeLog()
{
  DATETIME starttest := GetCurrentDatetime();
  TRY
  {
    THROW NEW Exception("test-notice-log");
  }
  CATCH(OBJECT e)
  {
    LogHareScriptException(e, [ info := [ context := "webhare_testsuite:testeditorsupport" ]]);
  }
  RECORD ARRAY errors := GetLastNoticeErrors();
  errors := SELECT * FROM errors WHERE channel='ERROR' AND when >= starttest;
  errors := SELECT * FROM errors WHERE CellExists(data,'info') AND data.info.context='webhare_testsuite:testeditorsupport';

  TestEq(1,Length(errors));
  TestEq("harescript-error", errors[0].message);
  TestEq("Exception: test-notice-log", errors[0].data.errors[0].message);
}

RunTestFramework([ PTR PrepareTests
                 , PTR TestToddService
                 , PTR TestWebdavVirtualInfo
                 , PTR TestWebdavVirtualInfo_DavFS
                 , PTR TestEditSupport
                 , PTR TestEditSupport_NoDev
                 , PTR TestUnprivileged
                 , PTR TestNoticeLog
                 ], [ testusers := [[ login := "sysop", grantrights := ["system:sysop"] ]
                                   ,[ login := "homer" ]
                                   ]
                    ]);
