<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::ooxml/spreadsheet.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/asynctools.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::publisher/lib/internal/webdesign/designfilesapi2.whlib";

LOADLIB "mod::system/lib/testfw/runtest.whlib";


PUBLIC BOOLEAN FUNCTION IsIn(STRING name, STRING ARRAY masks)
{
  FOREVERY(STRING mask FROM masks)
    IF(ToUPpercase(name) LIKE ToUppercase("*" || mask || "*"))
      RETURN TRUE;
  RETURN FALSE;
}

INTEGER watch_run_delay := 200;

// ---------------------------------------------------------------------------
//
// Class to schedule and serialize callbacks
//

OBJECTTYPE TimedSerializer
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  // timer
  OBJECT timer;

  // callback to serialize
  MACRO PTR callback;

  /// current trigger date
  DATETIME curtrigger;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(MACRO PTR callback)
  {
    this->callback := callback;
    this->curtrigger := MAX_DATETIME;
    this->timer := NEW WaitableTimer;

    this->DoTimerAction();
  }

  OBJECT ASYNC FUNCTION DoTimerAction()
  {
    AWAIT this->timer->WaitSignalled();
    this->timer->Reset();
    this->curtrigger := MAX_DATETIME;
    this->callback();
    this->DoTimerAction(); // do not await!
    RETURN DEFAULT RECORD;
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC MACRO Schedule(VARIANT time DEFAULTSTO DEFAULT DATETIME)
  {
    IF (time < this->curtrigger)
    {
      this->curtrigger := time;
      this->timer->Reset(time);
    }
  }
>;


PUBLIC OBJECTTYPE JSTests EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  // Assetpackcontrol service connection
  OBJECT assetpackcontrolservice;

  /// List of assetpack bundles
  RECORD ARRAY assetpack_bundles;

  /// JSTestservice connection
  OBJECT jstestservice;

  /** All test results
      @cell name
      @cell browser
      @cell assetpacks
  */
  RECORD ARRAY results;

  // List of supported browsers
  STRING ARRAY browsers;

  // Testframework, to get test list
  OBJECT runtestframework;

  // Full list of tests
  RECORD ARRAY alltests;

  // Selected list of tests (filtered from altests from masks & skips)
  RECORD ARRAY tests;

  // Name of tests that are watched
  STRING ARRAY watchedtests;

  // List of currently watched assetpacks
  STRING ARRAY watchedassetpacks;

  // serializer to run the ScheduleRunWatches function
  OBJECT checkrunwatches;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    IF (LENGTH(data.params) != 0)
      this->masks->value := data.params[0];

    this->runtestframework := NEW RunTests;
    this->browsers := [ "chrome", "firefox", "ie11", "edge", "safari" ];

    this->checkrunwatches := NEW TimedSerializer(PTR this->ScheduleRunWatches);

    this->watchbrowsers->rows :=
        SELECT *
             , rowkey :=    browser
             , watch :=     FALSE
          FROM ToRecordArray(this->browsers, "BROWSER");

    // Load the list of tests
    this->ReloadTestList();

    // Connect to services
    this->GotAssetpackControlStart(DEFAULT RECORD ARRAY);
    this->GotJSTestServiceStart(DEFAULT RECORD ARRAY);

    // recheck run watches
    this->checkrunwatches->Schedule(GetCurrentDateTime());
  }

  // ---------------------------------------------------------------------------
  //
  // Assetpack control service connection
  //

  MACRO CloseAssetpackServiceLink()
  {
    IF (ObjectExists(this->assetpackcontrolservice))
    {
      this->assetpackcontrolservice->CloseService();
      this->assetpackcontrolservice := DEFAULT OBJECT;
      this->watchedassetpacks := DEFAULT STRING ARRAY;
    }
  }

  // Called when the assetpackcontrol service has just started. Reconnect
  MACRO GotAssetpackControlStart(RECORD ARRAY events)
  {
    this->CloseAssetpackServiceLink();

    TRY
    {
      this->assetpackcontrolservice := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
      ScheduleCallbackOnServiceClose(this->assetpackcontrolservice, PTR this->GotAssetPackcontrolClose);
    }
    CATCH
    {
    }

    // Reload the assetpack status
    this->GotAssetpackChanges(DEFAULT RECORD ARRAY);

    // Watch assetpacks
    this->UpdateWachedAssetpacks();
  }

  // Called when our link to assetpackcontrol just closed
  MACRO GotAssetPackcontrolClose()
  {
    this->assetpackcontrolservice := DEFAULT OBJECT;
    this->watchedassetpacks := DEFAULT STRING ARRAY;

    // Reload the assetpack status
    this->GotAssetpackChanges(DEFAULT RECORD ARRAY);
  }

  MACRO GotAssetpackChanges(RECORD ARRAY events)
  {
    this->assetpack_bundles := DEFAULT RECORD ARRAY;
    IF (ObjectExists(this->assetpackcontrolservice))
    {
      TRY
      {
        this->assetpack_bundles :=
            SELECT *
              FROM WaitForPromise(this->assetpackcontrolservice->GetStatus()).bundles
          ORDER BY outputtag;
      }
      CATCH
      {
      }
    }

    this->ReloadList();
    this->checkrunwatches->Schedule(AddTimeToDate(watch_run_delay, GetCurrentDateTime()));
  }

  MACRO UpdateWachedAssetpacks()
  {
    STRING ARRAY assetpacks;
    FOREVERY (RECORD test FROM this->results)
    {
      IF (LowerBound(this->watchedtests, test.name).found)
        assetpacks := assetpacks CONCAT test.assetpacks;
    }

    assetpacks := GetSortedSet(assetpacks);

    STRING ARRAY to_add := ArrayDelete(assetpacks, this->watchedassetpacks);
    STRING ARRAY to_remove := ArrayDelete(this->watchedassetpacks, assetpacks);

    FOREVERY (STRING assetpack FROM to_add CONCAT to_remove)
    {
      IF (ObjectExists(this->assetpackcontrolservice))
      {
        TRY
        {
          // Update one by one, our connection could be lost half-way
          this->assetpackcontrolservice->SetWatched(assetpack, assetpack IN to_add);
          RECORD pos := LowerBound(this->watchedassetpacks, assetpack);
          IF (pos.found != (assetpack IN to_add))
          {
            IF (pos.found)
              DELETE FROM this->watchedassetpacks AT pos.position;
            ELSE
              INSERT assetpack INTO this->watchedassetpacks AT pos.position;
          }
        }
        CATCH
        {
        }
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // JSTest service connection
  //

  MACRO CloseJSTestServiceLink()
  {
    IF (ObjectExists(this->jstestservice))
    {
      this->jstestservice->CloseService();
      this->jstestservice := DEFAULT OBJECT;
    }
  }

  MACRO GotJSTestServiceStart(RECORD ARRAY events)
  {
    this->CloseJSTestServiceLink();

    TRY
    {
      this->jstestservice := WaitForPromise(OpenWebHareService("webhare_testsuite:jstestservice"));
      ScheduleCallbackOnServiceClose(this->jstestservice, PTR this->GotJSTestClose);
    }
    CATCH
    {
    }

    // Reload the assetpack status
    this->GotJSTestChangeAllEvent(DEFAULT RECORD ARRAY);
  }

  // Called when our link to assetpackcontrol just closed
  MACRO GotJSTestClose()
  {
    this->jstestservice := DEFAULT OBJECT;

    // Reload the assetpack status
    this->GotJSTestChangeAllEvent(DEFAULT RECORD ARRAY);
  }

  MACRO GotJSTestChangeAllEvent(RECORD ARRAY events)
  {
    this->UpdateTestResults("");
    this->ReloadList();
    this->GotRowSelect();

    this->UpdateWachedAssetpacks();
    this->checkrunwatches->Schedule(AddTimeToDate(watch_run_delay, GetCurrentDateTime()));
  }

  MACRO GotJSTestChangeEvent(RECORD ARRAY events)
  {
    STRING ARRAY tests :=
        SELECT AS STRING ARRAY DISTINCT data.testname
          FROM events;

    FOREVERY (STRING test FROM tests)
      this->UpdateTestResults("");

    BOOLEAN dorowselect, updatefooterrows;
    FOREVERY (STRING test FROM tests)
    {
      INTEGER pos := this->jstests->GetRowFlatPosition(test);
      IF (pos = -1)
        CONTINUE;

      // Single row update is quicker than refreshing whole list
      RECORD row := this->jstests->rows[pos];
      row := this->CalculateRow(row.test);
      this->jstests->UpdateSingleRow(row);
      updatefooterrows := TRUE;
      IF (row.rowkey IN this->jstests->value)
        dorowselect := TRUE;
    }

    IF (updatefooterrows)
    {
      RECORD ARRAY rows := SELECT * FROM this->jstests->rows WHERE istest;
      RECORD ARRAY footerrows := this->CalculateFooterRows(rows);
      FOREVERY (RECORD footerrow FROM footerrows)
        this->jstests->UpdateSingleRow(footerrow);
    }

    IF (dorowselect)
      this->GotRowSelect();

    this->UpdateWachedAssetpacks();
    this->checkrunwatches->Schedule(AddTimeToDate(watch_run_delay, GetCurrentDateTime()));
  }

  // Get updated test results
  MACRO UpdateTestResults(STRING test) // empty for all
  {
    RECORD ARRAY results;
    TRY
    {
      IF (ObjectExists(this->jstestservice))
        results := WaitForPromise(this->jstestservice->GetResults(test ?? "*"));
    }
    CATCH
    {
    }

    // Unmap assetpacks bundle outputtags from the test reports
    FOREVERY (RECORD result FROM results)
    {
      STRING ARRAY assetpacks;
      IF (RecordExists(result.report) AND RecordExists(RECORD ARRAY(result.report.tests)))
        FOREVERY (RECORD test FROM RECORD ARRAY(result.report.tests))
          FOREVERY (STRING assetpack FROM STRING ARRAY(test.assetpacks))
          {
            assetpack := UnmapBundleUuid(assetpack);
            INSERT assetpack INTO assetpacks AT END;
          }

      INSERT CELL assetpacks := GetSortedSet(assetpacks) INTO results[#result];
    }

    // Update the selected tests (or replace the whole list)
    IF (test = "")
      this->results := SELECT * FROM results ORDER BY name, browser;
    ELSE
    {
      FOREVERY (RECORD result FROM results)
      {
        RECORD pos := RecordLowerBound(this->results, result, [ "NAME", "BROWSER" ]);
        IF (pos.found)
          this->results[pos.position] := result;
        ELSE
          INSERT result INTO this->results AT pos.position;
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Test list getting
  //

  MACRO ReloadTestList()
  {
    this->alltests :=
        SELECT *
          FROM this->runtestframework->GatherAllTests(["*"], DEFAULT STRING ARRAY)
         WHERE type = "jstest";

    this->CalculateFilteredTests();
    this->ReloadList();
  }

  MACRO CalculateFilteredTests()
  {
    STRING ARRAY masks := this->masks->value = "" ? DEFAULT STRING ARRAY : Tokenize(NormalizeWhitespace(this->masks->value), " ");
    STRING ARRAY skips := this->skips->value = "" ? DEFAULT STRING ARRAY : Tokenize(NormalizeWhitespace(this->skips->value), " ");

    // Calc the tests to run by applying the masks and skips
    this->tests :=
        SELECT *
          FROM this->alltests
         WHERE (Length(masks)=0 OR IsIn(testname, masks))
           AND (LEngth(skips)=0 OR NOT IsIn(testname, skips));
  }

  // ---------------------------------------------------------------------------
  //
  // Presentation lists
  //

  RECORD FUNCTION CalculateRow(RECORD rec)
  {
    RECORD row :=
        [ rowkey :=     rec.testname
        , testname :=   rec.testname
        , test :=       rec
        , type :=       "single"
        , allicon :=    1
        , istest :=     TRUE
        , assetpacks := DEFAULT STRING ARRAY
        , lastcompile := DEFAULT DATETIME
        , bundlestatus := 1
        , canwatch :=   TRUE
        , watch :=      rec.testname IN this->watchedtests
        , style :=      rec.testname IN this->watchedtests ? "watched" : ""
        ];

    FOREVERY (STRING browser FROM this->browsers)
    {
      RECORD pos := RecordLowerBound(this->results, [ name := rec.testname, browser := browser ], [ "NAME", "BROWSER" ]);
      RECORD testresult := pos.found
          ? this->results[pos.position]
          : [ status :=     "unknown"
            , date :=       DEFAULT DATETIME
            , assetpacks := DEFAULT STRING ARRAY
            ];

      FOREVERY (STRING assetpack FROM testresult.assetpacks)
      {
        RECORD pos := RecordLowerBound(this->assetpack_bundles, [ outputtag := assetpack ], [ "OUTPUTTAG" ]);
        IF (pos.found)
        {
          RECORD bundle := this->assetpack_bundles[pos.position];
          IF (bundle.lastcompile > row.lastcompile)
            row.lastcompile := bundle.lastcompile;
          IF (bundle.iscompiling AND row.bundlestatus IN [ 1, 2, 3 ])
            row.bundlestatus := 4;
          ELSE IF (bundle.haserrors AND row.bundlestatus IN [ 1, 2 ])
            row.bundlestatus := 3;
          ELSE IF (bundle.hasstatus AND row.bundlestatus IN [ 1 ])
            row.bundlestatus := 2;
        }
      }

      INTEGER icon;

      SWITCH (testresult.status)
      {
        CASE "idle", "unknown", "cancelled"
        {
          icon := 1;
        }
        CASE "waiting", "started"
        {
          icon := 4;
        }
        CASE "pageloaded", "gotsession", "reporting"
        {
          icon := 6;
        }
        CASE "finished", "timeout", "exception"
        {
          BOOLEAN is_error := testresult.status != "finished";
          IF (RecordExists(testresult.report) AND LENGTH(testresult.report.tests) > 0)
            is_error := is_error OR LENGTH(testresult.report.tests[0].fails) > 0;

          IF (is_error)
          {
            icon := 3;
            row.allicon :=  3;
          }
          ELSE
          {
            icon := 2;
            IF (row.allicon = 0)
              row.allicon := 2;
          }
        }
        CASE "failed"
        {
          icon := 3;
          row.allicon :=  3;
        }
        CASE "scheduled"
        {
          icon := 5;
        }
        DEFAULT
        {
          LogDebug("jstests", "unknown status " || testresult.status);
        }
      }

      row := CellInsert(row, "icon_" || browser, icon);
      row := CellInsert(row, "result_" || browser, this->tolliumuser->FormatDateTime(testresult.date, "seconds", TRUE, TRUE));
    }

    RETURN row;
  }

  RECORD ARRAY FUNCTION CalculateFooterRows(RECORD ARRAY rows)
  {
    RECORD ARRAY footerrows :=
        [ [ testname :=   this->GetTid(".allfailed")
          , type :=       "failed"
          , rowkey :=     "*failed"
          , allicon :=    1
          , istest :=     FALSE
          , bundlestatus := 0
          , canwatch :=   FALSE
          , watch :=      FALSE
          ]
        , [ testname :=   this->GetTid(".all")
          , type :=       "all"
          , rowkey :=     "*all"
          , allicon :=    1
          , istest :=     FALSE
          , bundlestatus := 0
          , canwatch :=   FALSE
          , watch :=      FALSE
          ]
        , [ testname :=   this->GetTid(".allnotrun")
          , type :=       "allnotrun"
          , rowkey :=     "*notrun"
          , allicon :=    1
          , istest :=     FALSE
          , bundlestatus := 0
          , canwatch :=   FALSE
          , watch :=      FALSE
          ]
        ];

    FOREVERY (STRING browser FROM this->browsers)
    {
      RECORD stats :=
          SELECT failed := SUM(GetCell(rows, "icon_" || browser) = 3 ? 1:0)
               , success := SUM(GetCell(rows, "icon_" || browser) = 2 ? 1:0)
               , notrun := SUM(GetCell(rows, "icon_" || browser) = 1 ? 1:0)
               , total := Count(*)
            FROM rows; // skip current footer

      stats := stats ?? [ failed := 0, total := 0, success := 0, notrun := 0 ];

      footerrows[0] := CellInsert(footerrows[0], "icon_" || browser, stats.failed = 0 ? 1 : 3);
      footerrows[0] := CellInsert(footerrows[0], "result_" || browser, ToString(stats.failed));

      IF (stats.failed != 0)
        footerrows[0].allicon := 3;

      footerrows[1] := CellInsert(footerrows[1], "icon_" || browser, 1);
      footerrows[1] := CellInsert(footerrows[1], "result_" || browser, ToString(stats.total));

      footerrows[2] := CellInsert(footerrows[2], "icon_" || browser, 1);
      footerrows[2] := CellInsert(footerrows[2], "result_" || browser, ToString(stats.notrun));
    }
    RETURN footerrows;
  }

  MACRO ReloadList()
  {
    RECORD ARRAY rows;

    FOREVERY (RECORD rec FROM this->tests)
      INSERT this->CalculateRow(rec) INTO rows AT END;

    RECORD ARRAY footerrows := this->CalculateFooterRows(rows);

    this->jstests->rows := rows CONCAT footerrows; // HACK because footerrows don't work yet
//    this->jstests->footerrows := footerrows;

    this->GotRowSelect();
  }

  MACRO GotRowSelect()
  {
    IF (Length(this->jstests->selection)!=1 OR NOT this->jstests->selection.istest)
    {
      this->failures->rows := DEFAULT RECORD ARRAY;
      RETURN;
    }

    RECORD ARRAY rows;

    RECORD sel := this->jstests->selection;

    FOREVERY (STRING browser FROM this->browsers)
    {
      STRING failures := this->GetTid(".notrun");
      RECORD result;

      RECORD pos := RecordLowerBound(this->results, [ name := sel.testname, browser := browser ], [ "NAME", "BROWSER" ]);
      IF (pos.found)
      {
        result := this->results[pos.position];
        IF (result.status IN [ "finished", "timeout", "exception", "reporting" ])
        {
          RECORD testreport;
          IF (RecordExists(result.report) AND LENGTH(result.report.tests) = 1)
            testreport := result.report.tests[0];

          BOOLEAN is_ok := result.status = "finished";
          IF (is_ok AND RecordExists(testreport))
            is_ok := is_ok AND LENGTH(testreport.fails) = 0;

          failures := "";
          IF (RecordExists(testreport))
          {
            failures := Detokenize(
                (SELECT AS STRING ARRAY stepname = ""
                          ? "Step " || stepnr
                          : stepname || " (" || stepnr || ")"
                  FROM RECORD ARRAY(testreport.fails)), ", ");
          }

          IF (result.status = "exception")
            failures := failures || (failures = "" ? "" : ", ") || result.result.msg;
          ELSE IF (result.status = "timeout")
            failures := failures || (failures = "" ? "" : ", ") || "timeout";
          ELSE IF (failures = "")
            failures := this->GetTid(".noerrors");

          IF (result.status = "reporting")
            failures := failures || " ("|| this->GetTid(".stillrunning") || ")";
        }
        ELSE IF (result.status NOT IN [ "idle", "scheduled", "cancelled" ])
          failures := this->GetTid(".running");
      }

      INSERT
          [ rowkey :=   browser
          , browser :=  browser
          , failures := failures
          , test :=     sel.test
          , result :=   result
          , hasresult := RecordExists(result)
          ] INTO rows AT END;
    }

    this->failures->rows := rows;
  }

  // ---------------------------------------------------------------------------
  //
  // Misc. callbacks
  //

  MACRO GotIconClick(RECORD data, STRING value)
  {
    STRING ARRAY browsers;

    IF (value LIKE "icon_*")
      browsers := [ SubString(value, 5) ];
    ELSE IF (value = "allicon")
      browsers := this->browsers;
    ELSE
      RETURN;

    this->RunSelectedTests([ data ], browsers);
  }

  MACRO GotMasksChange()
  {
    this->CalculateFilteredTests();
    this->ReloadList();
  }

  MACRO GotWatchCheck(RECORD row, STRING col)
  {
    STRING ARRAY rowkeys := [ STRING(row.rowkey) ];
    IF (row.rowkey IN this->jstests->value)
      rowkeys := this->jstests->value;

    IF (row.watch) // just enabled
      this->watchedtests := GetSortedSet(this->watchedtests CONCAT rowkeys);
    ELSE
      this->watchedtests := ArrayDelete(this->watchedtests, rowkeys);

    this->ReloadList();
    this->UpdateWachedAssetpacks();

    this->checkrunwatches->Schedule(GetCurrentDateTime());
  }

  MACRO GotWatchBrowserCheck(RECORD row, STRING col)
  {
    this->checkrunwatches->Schedule(GetCurrentDateTime());
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  // serialized check to run watched tests
  MACRO ScheduleRunWatches()
  {
    DATETIME nextcheck := MAX_DATETIME;

    STRING ARRAY watched_browsers :=
        SELECT AS STRING ARRAY browser
          FROM this->watchbrowsers->rows
         WHERE watch;

    IF (LENGTH(watched_browsers) = 0)
      RETURN;

    RECORD ARRAY torun;
    DATETIME triggertime := AddTimeToDate(-watch_run_delay, GetCurrentDateTime());

    FOREVERY (RECORD test FROM this->alltests)
    {
      IF (NOT LowerBound(this->watchedtests, test.testname).found)
        CONTINUE;

      FOREVERY (STRING browser FROM watched_browsers)
      {
        BOOLEAN to_schedule;
        RECORD pos := RecordLowerBound(this->results, [ name := test.testname, browser := browser ], [ "NAME", "BROWSER" ]);
        IF (NOT pos.found) // not run yet
          to_schedule := TRUE;
        ELSE
        {
          RECORD result := this->results[pos.position];

          // test should not be running
          IF (result.status NOT IN [ "idle", "unknown", "cancelled", "finished", "timeout", "exception", "failed" ])
            CONTINUE;

          DATETIME last_assetpack_done;
          BOOLEAN all_assetpacks_done := TRUE;
          FOREVERY (STRING assetpack FROM result.assetpacks)
          {
            RECORD pos := RecordLowerBound(this->assetpack_bundles, [ outputtag := assetpack ], [ "OUTPUTTAG" ]);
            IF (pos.found)
            {
              RECORD bundle := this->assetpack_bundles[pos.position];
              IF (bundle.iscompiling OR bundle.haserrors)
                all_assetpacks_done := FALSE;
              ELSE IF (bundle.lastcompile > last_assetpack_done)
                last_assetpack_done := bundle.lastcompile;
            }
          }

          IF (NOT all_assetpacks_done OR last_assetpack_done < result.startdate)
            CONTINUE;

          IF (last_assetpack_done <= triggertime OR LENGTH(result.assetpacks) = 0)
            to_schedule := TRUE;
          ELSE
          {
            DATETIME check := AddTimeToDate(watch_run_delay, last_assetpack_done);
            IF (nextcheck > check)
              nextcheck := check;
          }
        }

        IF (to_schedule)
          INSERT [ test := test, browser := browser ] INTO torun AT END;
      }
    }

    IF (LENGTH(torun) = 0)
      RETURN;

    // Make sure the client is still active before rescheduling. Wait 30s for client reply
    IF (this->tolliumcontroller->GetClientState([ timeout := AddTimeToDate(30000, GetCurrentDateTime()) ]) != "ok")
    {
      // Check again in 30 seconds
      this->checkrunwatches->Schedule(AddTimeToDate(30000, GetCurrentDateTime()));
      RETURN;
    }

    RECORD ARRAY perbrowser :=
        SELECT browser
             , tests :=   GroupedValues(test)
          FROM torun
      GROUP BY browser;

    FOREVERY (RECORD rec FROM perbrowser)
      this->StartRunTests(rec.tests, rec.browser);

    IF (nextcheck != MAX_DATETIME)
      this->checkrunwatches->Schedule(nextcheck);
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO StartRunTests(RECORD ARRAY tests, STRING browser)
  {
    WaitForPromise(this->jstestservice->ScheduleTests(
          SELECT name :=    testname
               , browser := browser
               , data :=    tests
            FROM tests));
  }

  BOOLEAN FUNCTION AnyError(STRING ARRAY browsers, RECORD row)
  {
    FOREVERY(STRING browser FROM browsers)
      IF(GetCell(row, "icon_" || browser)=3)
        RETURN TRUE;
    RETURN FALSE;
  }

  BOOLEAN FUNCTION AnyNotRun(STRING ARRAY browsers, RECORD row)
  {
    FOREVERY(STRING browser FROM browsers)
      IF(GetCell(row, "icon_" || browser)=1)
        RETURN TRUE;
    RETURN FALSE;
  }

  MACRO RunSelectedTests(RECORD ARRAY rows, STRING ARRAY browsers)
  {
    // Expand 'failed' and 'all' rows
    FOREVERY (RECORD row FROM rows)
    {
      IF (row.type = "failed")
        rows := rows CONCAT SELECT * FROM this->jstests->rows WHERE istest AND type = "single" AND this->AnyError(browsers,rows);
      ELSE IF (row.type = "all")
        rows := rows CONCAT SELECT * FROM this->jstests->rows WHERE istest AND type = "single";
      ELSE IF (row.type = "allnotrun")
        rows := rows CONCAT SELECT * FROM this->jstests->rows WHERE istest AND type = "single" AND this->AnyNotRun(browsers,rows);
    }

    // Get the real selected rows
    STRING ARRAY rowkeys := SELECT AS STRING ARRAY rowkey FROM rows;
    rows := SELECT * FROM this->jstests->rows WHERE type = "single" AND rowkey IN rowkeys;

    FOREVERY (STRING browser FROM browsers)
    {
      RECORD ARRAY toadd;
      FOREVERY (RECORD row FROM rows)
      {
        RECORD pos := RecordLowerBound(this->results, [ name := row.testname, browser := browser ], [ "NAME", "BROWSER" ]);
        IF (pos.found AND this->results[pos.position].status NOT IN [ "finished", "exception", "timeout", "idle", "cancelled", "scheduled" ])
          CONTINUE;

        INSERT row.test INTO toadd AT END;
//        this->SetTestStatus(row.test, browser, "scheduled", [ test := row.test ], FALSE);
      }

      IF (LENGTH(toadd) != 0)
        this->StartRunTests(toadd, browser);
    }
    this->ReloadList();
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoRestartTestMgr()
  {
    IF (ObjectExists(this->jstestservice))
    {
      TRY
      {
        WaitForPromise(this->jstestservice->Restart());
      }
      CATCH; // might have been closed already
    }
  }

  MACRO DoApplyMasks()
  {
    this->CalculateFilteredTests();
    this->ReloadList();
  }

  MACRO DoRunChrome()
  {
    this->RunSelectedTests(this->jstests->selection, [ "chrome" ]);
  }

  MACRO DoRunFirefox()
  {
    this->RunSelectedTests(this->jstests->selection, [ "firefox" ]);
  }

  MACRO DoRunIE11()
  {
    this->RunSelectedTests(this->jstests->selection, [ "ie11" ]);
  }

  MACRO DoRunEdge()
  {
    this->RunSelectedTests(this->jstests->selection, [ "edge" ]);
  }

  MACRO DoRunSafari()
  {
    this->RunSelectedTests(this->jstests->selection, [ "safari" ]);
  }

  MACRO DoRunAll()
  {
    this->RunSelectedTests(this->jstests->selection, this->browsers);
  }

  MACRO DoOpenTestInBrowser(OBJECT handler)
  {
    RECORD test := this->jstests->selection.test;
    STRING testurl := AddVariableToURL(test.baseurl, "mask", test.testname);

    handler->SendURL(testurl);
  }

  MACRO DoOpenGridConsole(OBJECT handler)
  {
    handler->SendURL(ResolveToAbsoluteURL(GetSeleniumHubURL(), "/grid/console"));
  }

  MACRO DoOpenTestsPage(OBJECT handler)
  {
    handler->SendURL("/tests/");
  }

  MACRO DoOpenBrowserResult()
  {
    RECORD data := this->failures->selection.result;
    INSERT CELL jstestservice := this->jstestservice INTO data;
    this->LoadScreen(".testresults", data)->RunModal();
  }

  MACRO DoCancelTests()
  {
    RECORD ARRAY list;
    FOREVERY (STRING browser FROM this->browsers)
      list := list CONCAT (SELECT name, browser := browser FROM ToRecordArray(this->jstests->value, "NAME"));

    WaitForPromise(this->jstestservice->CancelTests(list));
  }

  MACRO DoExport(OBJECT handler)
  {
    OBJECT columnout := NEW XLSXColumnFileWriter;

    columnout->columns :=
        [ [ name := "testname",            title := "Test", type := "text", width := 50 ]
        ];

    FOREVERY (STRING browser FROM this->browsers)
      INSERT [ name := browser, title := browser, type := "text" ] INTO columnout->columns AT END;

    RECORD ARRAY rows;
    FOREVERY (RECORD rec FROM SELECT * FROM this->jstests->rows WHERE Left(rowkey, 1) != "*" ORDER BY testname)
    {
      RECORD row := [ testname := rec.testname ];
      FOREVERY (STRING browser FROM this->browsers)
      {
        INTEGER icon := GetCell(rec, "ICON_" || browser);
        STRING status;
        SWITCH (icon)
        {
          CASE 1    { status := ""; }
          CASE 2    { status := "ok"; }
          CASE 3    { status := "FAIL"; }
          DEFAULT   { status := "pending"; }
        }
        row := CellInsert(row, browser, status);
      }
      INSERT row INTO rows AT END;
    }

    columnout->WriteRows(rows);

    RECORD wrapped := WrapBlob(columnout->MakeOutputFile(), "jstests-" || FormatDateTime("%Y%m%d%H%M%S", UTCToLocal(GetCurrentDateTime(), "CET")) || ".xlsx");

    handler->SendFile(wrapped.data, wrapped.mimetype, wrapped.filename);
  }
>;

PUBLIC OBJECTTYPE TestResults EXTEND TolliumScreenBase
<
  RECORD data;
  STRING ARRAY assetpacks;

  MACRO Init(RECORD data)
  {
    this->data := data;
    this->listener->masks := [ "webhare_testsuite:jstestchange." || data.name ];
    this->Refresh();
  }

  MACRO OnChangeEvents(RECORD ARRAY events)
  {
    this->Refresh();
  }

  MACRO Refresh()
  {
    RECORD result :=
        SELECT *
          FROM WaitForPromise(this->data.jstestservice->GetResults(this->data.name))
         WHERE browser = this->data.browser;

    IF (NOT RecordExists(result))
    {
      this->tolliumresult := "cancel";
      RETURN;
    }

    this->frame->flags.canrestart := result.status IN
        [ "idle", "unknown", "cancelled", "finished", "timeout", "exception", "failed" ];

    this->teststatus->value := result.status;

    STRING testurl := AddVariableToURL(this->data.data.baseurl, "mask", this->data.name);
    testurl := AddVariableToURL(testurl, "autostart", "0");

    this->testurl->value := testurl;

    RECORD ARRAY failrows;
    STRING log;


    STRING ARRAY masks :=
        [ "webhare_testsuite:jstestchange." || this->data.name
        , "webhare_testsuite:jstestchangelog." || this->data.name
        ];

    STRING ARRAY assetpacks;
    STRING ARRAY assetpacktxt;

    IF (this->data.assetpack != "")
      INSERT this->data.assetpack || ".dev" INTO assetpacks AT END;

    IF (RecordExists(result.report))
    {
      FOREVERY (RECORD test FROM RECORD ARRAY(result.report.tests))
        failrows := failrows CONCAT RECORD ARRAY(test.fails);

      IF (RecordExists(result.report.logdata))
      {
        FOREVERY (RECORD line FROM RECORD ARRAY(result.report.logdata))
        {
          log := log || TrimWhitespace(FormatDateTime("%H:%M:%S.%Q", line.timestamp) || " " || ToLowercase(line.level) || " " || line.message) || "\n";
        }
      }

      FOREVERY (RECORD test FROM result.report.tests)
        FOREVERY (STRING assetpack FROM STRING ARRAY(test.assetpacks))
          INSERT UnmapBundleUuid(assetpack) INTO assetpacks AT END;
    }

    assetpacks := GetSortedSet(assetpacks);
    IF (LENGTH(assetpacks) != 0)
    {
      RECORD ARRAY assetpack_bundles;

      OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
      TRY
        assetpack_bundles := WaitForPromise(assetpackcontrol->GetStatus()).bundles;
      FINALLY
        assetpackcontrol->CloseService();

      FOREVERY (STRING assetpack FROM assetpacks)
      {
        RECORD rec := SELECT * FROM assetpack_bundles WHERE outputtag = assetpack;
        IF (NOT RecordExists(rec))
          INSERT assetpack || ": ???" INTO assetpacktxt AT END;
        ELSE IF (rec.iscompiling)
          INSERT assetpack || ": compiling" INTO assetpacktxt AT END;
        ELSE IF (rec.haserrors)
          INSERT assetpack || ": errors" INTO assetpacktxt AT END;
        ELSE
          INSERT assetpack || ": ok" INTO assetpacktxt AT END;
      }
    }

    this->assetpacks := assetpacks;
    this->assetpackstatus->value := Detokenize(assetpacktxt, ", ");
    masks := masks CONCAT
        SELECT AS STRING ARRAY "publisher:assetpackcontrol.change." || assetpack
          FROM ToRecordArray(this->assetpacks, "ASSETPACK");

    this->listener->masks := masks;
    this->failedsteps->rows := failrows;
    this->log->value := log;
  }

  MACRO DoRestart()
  {
    WaitForPromise(this->data.jstestservice->ScheduleTests(
          [ [ name :=    this->data.name
            , browser := this->data.browser
            , data :=    this->data.data
            ]
          ]));
  }

  MACRO DoRecompileAssetpacks()
  {
    OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
    TRY
      FOREVERY (STRING assetpack FROM this->assetpacks)
        assetpackcontrol->RecompileBundle(assetpack, FALSE);
    FINALLY
      assetpackcontrol->CloseService();
  }
>;
