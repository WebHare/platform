<?wh

LOADLIB "wh::files.whlib";

LOADLIB "mod::system/lib/database.whlib";

LOADLIB "mod::consilio/lib/contentproviders/customcontent.whlib";

LOADLIB "mod::webhare_testsuite/lib/database.whlib";

BOOLEAN showdebuglog;// := TRUE;

PUBLIC STATIC OBJECTTYPE DBContent EXTEND CustomContentBase
< // ---------------------------------------------------------------------------
  //
  // CustomContentBase API
  //
  MACRO NEW()
  {
    IF(this->contentsourcetag NOT LIKE "webhare_testsuite:*")
      ABORT(`Unexpected tag '${this->contentsourcetag}'`);
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION GetMapping()
  {
    RECORD ARRAY mapping :=
        [ [ name := "_body",                   tokenized := TRUE, suggested := TRUE ]
        , [ name := "date_adate",              value := DEFAULT DATETIME ]
        , [ name := "datafrom",                value := "", tokenized := FALSE ]
        , [ name := "indexed_by",              value := "", tokenized := FALSE ]
        , [ name := "mapping_string",          value := "", type := "keyword" ]
        , [ name := "mapping_integer",         value := 0 ]
        , [ name := "mapping_integer64",       value := 0i64 ]
        , [ name := "mapping_money",           value := 0m ]
        , [ name := "mapping_float",           value := 0f ]
        , [ name := "mapping_boolean",         value := FALSE ]
        , [ name := "mapping_datetime",        value := DEFAULT DATETIME ]
        , [ name := "mapping_string_array",    value := STRING[], type := "keyword" ]
        , [ name := "mapping_integer_array",   value := INTEGER[] ]
        , [ name := "mapping_integer64_array", value := INTEGER64[] ]
        , [ name := "mapping_money_array",     value := MONEY[] ]
        , [ name := "mapping_float_array",     value := FLOAT[] ]
        , [ name := "mapping_boolean_array",   value := BOOLEAN[] ]
        , [ name := "mapping_datetime_ARRAY",  value := DATETIME[] ]
        ];
    RETURN mapping;
  }

  UPDATE PUBLIC MACRO PrepareForIndexing()
  {
    OpenPrimary();
    IF (showdebuglog)
      LogDebug("DBContent", "PrepareForIndexing");
  }

  UPDATE PUBLIC RECORD FUNCTION ListGroups(DATETIME indexdate)
  {
    RECORD result :=
        [ status := "result"
        , groups :=
              SELECT DISTINCT id := groupid
                FROM webhare_testsuite.consilio_index
        ];
    IF (showdebuglog)
      LogDebug("DBContent", "ListGroups", indexdate, result);
    RETURN result;
  }

  UPDATE PUBLIC RECORD FUNCTION ListObjects(DATETIME indexdate, STRING groupid)
  {
    RECORD ARRAY objects :=
        SELECT *
          FROM webhare_testsuite.consilio_index
          WHERE COLUMN groupid = VAR groupid;

    RECORD result;
    IF (RecordExists(SELECT FROM objects WHERE spiderfrom != 0))
    {
      // Group with spidering: no requiredindexdates!
      result :=
          [ status := "result"
          , objects :=
                SELECT id :=                  objectid
                     , ...(objectid LIKE "*withdata*" ? [ data := this->GetObjectData(objects, "list") ] : CELL[])
                  FROM objects
                 WHERE spiderfrom = 0
          ];
    }
    ELSE
    {
      result :=
          [ status := "result"
          , objects :=
                SELECT id :=                  objectid
                     , requiredindexdate :=   grouprequiredindexdate
                     , ...(objectid LIKE "*withdata*" ? [ data := this->GetObjectData(objects, "list") ] : CELL[])
                  FROM objects
          ];
    }
    IF (showdebuglog)
      LogDebug("DBContent", "ListObjects", indexdate, groupid, result);
    RETURN result;
  }


  UPDATE PUBLIC RECORD FUNCTION FetchObject(DATETIME indexdate, STRING groupid, STRING objectid)
  {
    IF (objectid LIKE "*fromlist*")
    {
      RECORD retval := this->FetchObjectFromObjectList(indexdate, groupid, objectid);
      IF (CellExists(retval, "DOCUMENT_FIELDS"))
        retval.document_fields.datafrom := "fetchfromlist-" || retval.document_fields.datafrom;
      RETURN retval;
    }

    RECORD rec :=
        SELECT *
          FROM webhare_testsuite.consilio_index
         WHERE COLUMN groupid = VAR groupid
               AND COLUMN objectid = VAR objectid;

    IF(NOT RecordExists(rec))
    {
      RECORD result :=
          [ status := "notfound"
          , error := "beta object " || EncodeJava(groupid) || ":" || EncodeJava(objectid) || " not found"
          ];
      IF (showdebuglog)
        LogDebug("DBContent", "FetchObject", indexdate, groupid, objectid, result);
      RETURN result;
    }

    IF (rec.text = "THROW")
      THROW NEW Exception("THROWN");
    IF (rec.text = "CRASH")
      THROW NEW Exception("BETATEST-CRASH");
    IF (rec.text = "ABORT")
      ABORT("ABORT");
    IF (rec.text = "JUMBOTEXT")
    {
      // Create a text with a length larger than the default max length for summary generation/highlighting (which is 1000000
      // by default)
      INTEGER stream := CreateStream();
      PrintTo(stream, "aap ");
      FOR (INTEGER i := 0; i < 100000; i := i + 1)
        PrintTo(stream, "noot mies\n");
      rec.text := BlobToString(MakeBlobFromStream(stream));
    }

    RECORD result :=
        [ status :=              "result"
        , ...this->GetObjectData(rec, "fetch")
        ];

    IF (showdebuglog)
      LogDebug("DBContent", "FetchObject", indexdate, groupid, objectid, result);
    RETURN result;
  }

  RECORD FUNCTION GetObjectData(RECORD rec, STRING datafrom)
  {
    RECORD extradata := rec.extradata != "" ? DecodeHSON(rec.extradata) : DEFAULT RECORD;
    RETURN
        [ document_body :=       rec.text
        , document_fields := CELL
              [ date_adate :=    rec.adate
              , objecturl :=     "obj://" || rec.groupid || "/" || rec.objectid
              , indexed_by :=    ToString(this->contentsourceid)
              , datafrom :=      datafrom
              , ...extradata
              ]
        , indexdate :=           rec.indexdate
        , requiredindexdate :=   rec.objectrequiredindexdate
        , objects :=             (SELECT id := consilio_index.objectid
                                       , ...(objectid LIKE "*withdata*" ? [ data := this->GetObjectData(consilio_index, "fetch-list") ] : CELL[])
                                    FROM webhare_testsuite.consilio_index
                                   WHERE spiderfrom = rec.id)
        ];
  }
>;
