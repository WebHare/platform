<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::internet/tcpip.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";

LOADLIB "mod::system/lib/testfw/runtest.whlib";


OBJECTTYPE PromiseAllData
< RECORD ARRAY list;
  INTEGER pending;
  MACRO PTR finalresolve;

  MACRO NEW(INTEGER count, MACRO PTR resolve)
  {
    this->list := RepeatElement(DEFAULT RECORD, count);
    this->pending := count;
    this->finalresolve := resolve;
  }

  PUBLIC MACRO Resolve(INTEGER id, VARIANT value)
  {
    IF (RecordExists(this->list[id]))
      RETURN;

    this->list[id] := [ value := value ];
    this->pending := this->pending - 1;
    IF (this->pending = 0)
      this->finalresolve(SELECT AS VARIANT ARRAY COLUMN value FROM this->list);
  }
>;

OBJECT FUNCTION MyPromiseAll(OBJECT ARRAY promises)
{
  RECORD defer := CreateDeferredPromise();
  OBJECT data := NEW PromiseAllData(LENGTH(promises), defer.resolve);

  FOREVERY (OBJECT promise FROM promises)
    promise->Then(PTR data->Resolve(#promise, #1), defer.reject);

  RETURN defer.promise;
}


OBJECT trans;
RECORD params;
RECORD ARRAY results;

trans := OpenPrimary();

params := ParseArguments(GetConsoleArguments(),
    [ [ name := "browsers",       type := "stringopt" ]
    , [ name := "host",           type := "stringopt" ]
    , [ name := "port",           type := "stringopt" ]
    , [ name := "email",          type := "stringopt" ]
    , [ name := "emaillink",      type := "stringopt" ]
    , [ name := "skip",           type := "stringlist" ]
    , [ name := "v",              type := "switch" ]
    , [ name := "createsites",    type := "switch" ]
    , [ name := "overwrite",      type := "switch" ]
//    , [ name := "local",          type := "switch" ]
    , [ name := "noinit",         type := "switch" ]
    , [ name := "masks",          type := "paramlist" ]
    ]);

IF (NOT RecordExists(params))
{
  PRINT("Syntax: runscript runjstests.whscr [ -v ] [ --email email ] [ --host hostname ] [ --browsers ie,firefox,chrome ] --skip skip ] [ *mask* ]\n");
  RETURN;
}

IF (params.host = "")
  params.host := GetSystemHostName(TRUE) || ":" || (params.port ?? "8000");
ELSE IF (params.port != "")
  params.host := params.host || ":" || params.port;
//IF (params.mask = "")
//  params.mask := "*";

STRING ARRAY browsers := Tokenize(params.browsers, ",");

RECORD ARRAY targets :=
    [ [ id :=         "firefox-win"
      , keywords :=   [ "firefox", "firefox-win" ]
      , s_capa :=     "firefox"
      ]
    , [ id :=         "chrome-win"
      , keywords :=   [ "chrome", "chrome-win" ]
      , s_capa :=     "chrome"
      ]
    , [ id :=         "ie11-win"
      , keywords :=   [ "ie", "ie11", "ie11-win" ]
      , s_capa :=     "ie11"
      ]
    , [ id :=         "edge-win" // No nightly testmachine for this one yet
      , keywords :=   [ "edge", "edge-win" ]
      , s_capa :=     "edge"
      ]
    , [ id :=         "safari-mac"
      , keywords :=   [ "safari", "safari-mac" ]
      , s_capa :=     "safari"
      ]
    ];

STRING nowstr := FormatISO8601DateTime(GetCurrentDateTime(),"","","",FALSE);


IF (NOT params.noinit)
{
  {
    DATETIME wait_until := AddTimeToDate(60 * 1000, GetCurrentDateTime());
    OBJECT browser := NEW WebBrowser;
    BOOLEAN repeatedwait;
    WHILE (TRUE)
    {
      IF (browser->GotoWebPage("http://" || params.host || "/.webhare_testsuite/jstests/"))
        BREAK;

      IF (NOT repeatedwait)
        PRINT("Waiting for webbrowser to be available on '"||params.host||"'\n");
      repeatedwait := TRUE;

      IF (GetCurrentDateTime() > wait_until)
        ABORT("Test website did not become available in 1 minute");

      Sleep(1000);
    }
  }
}

OBJECT runtestframework := NEW RunTests;

STRING primurl := GetPrimaryWebhareInterfaceURL();
STRING FUNCTION OverrideHost(STRING url)
{
  IF (url NOT LIKE primurl || "*")
    RETURN url;
  RETURN "http://" || params.host || "/" || UnpackURL(url).urlpath;
}

RECORD ARRAY tests :=
    SELECT *
         , baseurl :=   OverrideHost(baseurl)
      FROM runtestframework->GatherAllTests(params.masks, params.skip)
     WHERE type = "jstest";


// Returns whether this data means that the test has succeeded
BOOLEAN FUNCTION ShowTestResult(RECORD resultrec, BOOLEAN showok)
{
  IF (resultrec.status IN [ "timeout", "finished", "exception", "cancelled", "idle" ])
  {
    RECORD ARRAY fails;
    IF (RecordExists(resultrec.report) AND LENGTH(resultrec.report.tests) > 0)
      fails := RECORD ARRAY(resultrec.report.tests[0].fails);

    STRING ARRAY failnames :=
        SELECT AS STRING ARRAY stepname = "" ? ToString(stepnr) : stepname || " (" || stepnr || ")"
          FROM fails;

    IF (NOT showok AND resultrec.status = "finished" AND LENGTH(failnames) = 0)
      RETURN TRUE;

    PRINT(AnsiCmd("bold,white") || resultrec.name || AnsiCmd("reset"));
    PRINT(" - ");
    PRINT(AnsiCmd("bold,cyan") || resultrec.browser || AnsiCmd("reset"));
    PRINT(": ");
    BOOLEAN have_item;
    BOOLEAN have_fail;
    FOREVERY (STRING failname FROM failnames)
    {
      have_fail := TRUE;
      IF (NOT have_item)
        have_item := TRUE;
      ELSE
        PRINT(", ");
      PRINT(AnsiCmd("bold,red") || failname || AnsiCmd("reset"));
    }

    IF (resultrec.status = "timeout")
    {
      have_fail := TRUE;
      IF (NOT have_item)
        have_item := TRUE;
      ELSE
        PRINT(", ");
      PRINT(AnsiCmd("bold,blue") || "timeout" || AnsiCmd("reset"));
    }
    ELSE IF (resultrec.status = "exception")
    {
      have_fail := TRUE;
      IF (NOT have_item)
        have_item := TRUE;
      ELSE
        PRINT(", ");
      PRINT(AnsiCmd("bold,blue") || "exception: " || resultrec.result.msg || AnsiCmd("reset"));
    }
    ELSE IF (resultrec.status IN [ "cancelled", "idle" ])
    {
      IF (NOT have_item)
        have_item := TRUE;
      ELSE
        PRINT(", ");
      PRINT(AnsiCmd("bold,blue") || "cancelled" || AnsiCmd("reset"));
    }
    IF (resultrec.status = "finished" AND LENGTH(failnames) = 0)
      PRINT(AnsiCmd("bold,green") || "ok" || AnsiCmd("reset"));

    PRINT("\n");

    IF (NOT showok)
    {
      IF (RecordExists(resultrec.report))
      {
        FOREVERY (RECORD test FROM resultrec.report.tests)
        {
          FOREVERY (RECORD fail FROM test.fails)
          {
            PRINT("Step " || (fail.stepname = "" ? ToString(fail.stepnr) : fail.stepname || " (" || fail.stepnr || ")") || ":\n");
            IF (CellExists(fail, "E"))
              PRINT(TrimWhitespace("> " || Substitute(Substitute(fail.e, "\n", "\n> "), " \n", "\n")) || "\n\n");
          }
        }
      }
    }
    RETURN NOT have_fail;
  }
  RETURN FALSE;
}


MACRO GotTestStatusChange(RECORD resultrec)
{
  RECORD pos := RecordLowerBound(results, resultrec, [ "BROWSER", "TESTNAME" ]);
  IF (pos.found)
    results[pos.position] := resultrec;
  ELSE
    INSERT resultrec INTO results AT pos.position;

  ShowTestResult(resultrec, TRUE);
}


OBJECT jstestrunner := WaitForPromise(OpenWebHareService("webhare_testsuite:jstestservice"));

RECORD ARRAY toschedule;

FOREVERY (RECORD target FROM targets)
{
  STRING reportid := target.id || "-" || nowstr;

  BOOLEAN match;
  FOREVERY (STRING browser FROM browsers)
    IF (browser = "" OR browser IN target.keywords)
      match := TRUE;
  IF (NOT match)
    CONTINUE;

  FOREVERY (RECORD test FROM tests)
    INSERT
        [ name :=       test.testname
        , browser :=    target.s_capa
        , data :=       test
        , succeeded :=  FALSE
        ] INTO toschedule AT END;
}

PRINT(`Hub url: ${GetSeleniumHubURL()}\n`);

RegisterMultiEventCallback("webhare_testsuite:jstestchange.*", PTR OnChangeEvent);
RegisterMultiEventCallback("system:webhareservice.webhare_testsuite:jstestservice.start", PTR OnRestartEvent);
WaitForPromise(jstestrunner->ScheduleTests(toschedule));

RECORD defer := CreateDeferredPromise();

toschedule :=
    SELECT *
         , done :=    FALSE
      FROM toschedule
  ORDER BY COLUMN name, COLUMN browser;

INTEGER todocount := LENGTH(toschedule);
IF (todocount = 0)
{
  PRINT("No matching tests!\n");
  SetConsoleExitCode(1);
  TerminateScript();
}

RECORD ARRAY queue;
BOOLEAN processing;

MACRO OnChangeEvent(STRING event, RECORD ARRAY eventdata)
{
  FOREVERY (RECORD data FROM eventdata)
  {
    RECORD pos := RecordLowerBound(queue, data, [ "TESTNAME", "BROWSER" ]);
    IF (NOT pos.found)
      INSERT data INTO queue AT pos.position;
  }

  IF (NOT processing)
    ProcessQueue();
}

MACRO ProcessQueue()
{
  processing := TRUE;
  WHILE (LENGTH(queue) != 0)
  {
    RECORD data := queue[0];
    DELETE FROM queue AT 0;

    RECORD pos := RecordLowerBound(toschedule, [ name := data.testname, browser := data.browser ], [ "NAME", "BROWSER" ]);
    IF (NOT pos.found)
      CONTINUE;

    RECORD rec := toschedule[pos.position];
    IF (rec.done)
      CONTINUE;

    RECORD result :=
        SELECT *
          FROM WaitForPromise(jstestrunner->GetResults(rec.name))
         WHERE browser = rec.browser;

    IF (RecordExists(result))
    {
      IF (result.status NOT IN [ "finished", "timeout", "exception", "cancelled", "idle" ])
        CONTINUE;

      IF (ShowTestResult(result, TRUE))
        toschedule[pos.position].succeeded := TRUE;
    }
    toschedule[pos.position].done := TRUE;
    todocount := todocount - 1;
    IF (todocount = 0)
      defer.resolve(TRUE);
  }

  processing := FALSE;
}

MACRO OnRestartEvent(STRING event, RECORD ARRAY eventdata)
{
  PRINT("Test service has restarted, state has been lost\n");
  TerminateScript();
}

WaitForPromise(defer.promise);

STRING ARRAY failed_tests := SELECT AS STRING ARRAY DISTINCT name FROM toschedule WHERE NOT succeeded;
IF (LENGTH(failed_tests) != 0)
{
  SetConsoleExitCode(1);
  PRINT(`\nThe following tests have failed: ${Detokenize(failed_tests, ", ")}\n`);
}
