<?wh

/** @short WRD authentication
    @topic wrdauth/api
*/

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/webbrowser.whlib";
LOADLIB "wh::util/stringparser.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";


OBJECT pwnedbrowser;

/** Queries the haveibeenpwned (HIBP) service for the breach count of a password
    @param pwd Password to query
    @return Cachable record
    @cell return.value Breach count
    @cell return.ttl Cache ttl
*/
RECORD FUNCTION GetCacheablePwnCount(STRING pwd)
{
  IF(NOT Objectexists(pwnedbrowser))
  {
    pwnedbrowser := NEW WebBrowser;
    pwnedbrowser->timeout := 3000; //3 secs is more than enough
  }

  STRING pwdhash := ToUppercase(EncodeBase16(GetSHA1Hash(pwd)));

  INTEGER numbreaches := -1;
  IF(pwnedbrowser->GotoWebPage(`https://api.pwnedpasswords.com/range/${Left(pwdhash,5)}`))
  {
    STRING data := BlobToString(pwnedbrowser->content);
    INTEGER hashpos := SearchSubstring(data, Substring(pwdhash,5));
    IF(hashpos = -1)
    {
      numbreaches := 0;
    }
    ELSE
    {
      INTEGER countstart := hashpos + 36; //35 remaining chars plus :
      INTEGER countend := SearchSubstring(data, '\n', countstart);
      numbreaches := ToInteger(Substring(data, countstart, countend - countstart - 1), -1);
    }
  }
  RETURN [ value := numbreaches
         , ttl := 30*60*1000
         ];
}

/** Queries the haveibeenpwned (HIBP) service for the breach count of a password
    @param pwd Password to query
    @return Breach count (cached for up to 30 minutes)
*/
PUBLIC INTEGER FUNCTION GetPasswordBreachCount(STRING pwd)
{
  RETURN GetAdhocCached(CELL[pwd], PTR GetCacheablePwnCount(pwd));
}

INTEGER FUNCTION GetCountOfSet(STRING text, STRING chars)
{
  OBJECT p := NEW StringParser(text);
  STRING matches;
  WHILE (NOT p->eof)
  {
    matches := matches || p->ParseWhileInSet(chars);
    p->ParseWhileNotInSet(chars);
  }
  RETURN LENGTH(matches);
}

/** @param checks Password validation checks. Space-separated list of checks. Possible checks:
    - hibp Check that the password isn't present in the "Have I Been Pwned" database
    - minlength:(amount) Make sure that password has at least (amount) characters
    - lowercase:(amount) Make sure that password has at least (amount) lowercase characters
    - uppercase:(amount) Make sure that password has at least (amount) uppercase characters
    - digits:(amount) Make sure that password has at least (amount) digits
    - symbols:(amount) Make sure that password has at least (amount) symbols
    @return Parsed list of checks
    @cell(string) return.check Token of the check ("hibp", "minlength", "lowercase", "uppercase", "digits", "symbols")
    @cell(integer) return.value Amount (for checks that have an amount).
*/
PUBLIC RECORD ARRAY FUNCTION ParsePasswordChecks(STRING checks)
{
  RECORD ARRAY retval;

  FOREVERY (STRING token FROM Tokenize(checks, " "))
  {
    STRING ARRAY parts := Tokenize(token, ":");
    IF (LENGTH(parts) != (parts[0] IN [ "", "hibp" ] ? 1 : 2))
      THROW NEW Exception(`Password check '${token}' has a syntax error`);

    INTEGER value := LENGTH(parts) = 2 ? ToInteger(parts[1], -1) : 0;
    IF (value < 0)
      THROW NEW Exception(`Password check '${token}' has an invalid count`);

    SWITCH (parts[0])
    {
      CASE ""       { CONTINUE; }
      CASE "hibp", "minlength", "lowercase", "uppercase", "digits", "symbols"
      {
        INSERT CELL[ check := parts[0], value ] INTO retval AT END;
      }
      DEFAULT
      {
        THROW NEW Exception(`No such password check '${parts[0]}'`);
      }
    }
  }

  // Return in fixed order
  RETURN
      SELECT *
        FROM retval
    ORDER BY SearchElement([ "hibp", "minlength", "lowercase", "uppercase", "digits", "symbols" ], check);
}

STRING FUNCTION GetRequirementTid(RECORD check)
{
  SWITCH (check.check)
  {
    CASE "hibp"       { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.hibp"); }
    CASE "minlength"  { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.minlength", ToString(check.value)); }
    CASE "lowercase"  { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.lowercase", ToString(check.value)); }
    CASE "uppercase"  { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.uppercase", ToString(check.value)); }
    CASE "digits"     { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.digits", ToString(check.value)); }
    CASE "symbols"    { RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements.symbols", ToString(check.value)); }
  }
  THROW NEW Exception(`No tids for check ${check.check}`);
}

PUBLIC STRING FUNCTION DescribePasswordChecks(STRING checks)
{
  RECORD ARRAY parsedchecks := ParsePasswordChecks(checks);
  IF (IsDefaultValue(parsedchecks))
    RETURN "";

  STRING ARRAY lines;
  FOREVERY (RECORD check FROM parsedchecks)
    INSERT `- ${GetRequirementTid(check)}` INTO lines AT END;

  RETURN GetTid("wrd:site.forms.authpages.passwordcheck.requirements", Detokenize(lines, "\n"));
}

PUBLIC RECORD FUNCTION CheckPassword(STRING checks, STRING newpassword)
{
  RECORD ARRAY failed;

  FOREVERY (RECORD check FROM ParsePasswordChecks(checks))
  {
    SWITCH (check.check)
    {
      CASE "hibp"
      {
        INTEGER breachcount := GetPasswordBreachCount(newpassword);
        IF (breachcount != 0)
          INSERT check INTO failed AT END;
      }
      CASE "minlength"
      {
        IF (UCLength(newpassword) < check.value)
          INSERT check INTO failed AT END;
      }
      CASE "lowercase"
      {
        IF (GetCountOfSet(newpassword, "abcdefghijklmnopqrstuvwxyz") < check.value)
          INSERT check INTO failed AT END;
      }
      CASE "uppercase"
      {
        IF (GetCountOfSet(newpassword, "ABCDEFGHIJKLMNOPQRSTUVWXYZ") < check.value)
          INSERT check INTO failed AT END;
      }
      CASE "digits"
      {
        IF (GetCountOfSet(newpassword, "0123456789") < check.value)
          INSERT check INTO failed AT END;
      }
      CASE "symbols"
      {
        IF (UCLength(newpassword) - GetCountOfSet(newpassword, "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") < check.value)
          INSERT check INTO failed AT END;
      }
      DEFAULT
      {
        THROW NEW Exception(`No such password check '${check.check}'`);
      }
    }
  }

  IF (RecordExists(failed))
  {
    STRING ARRAY lines;
    FOREVERY (RECORD check FROM failed)
      INSERT `- ${GetRequirementTid(check)}` INTO lines AT END;

    RETURN
        [ success :=    FALSE
        , message :=    GetTid("wrd:site.forms.authpages.passwordcheck.failure", Detokenize(lines, "\n"))
        ];
  }

  RETURN
      [ success :=    TRUE
      , message :=    ""
      ];
}

/** Returns the default WRD schema password policy
    @param(object %WRDSchema2017) wrdschema WRD schema
    @return Password policy
    @cell(string) return.passwordvalidationchecks Password validation checks
*/
PUBLIC RECORD FUNCTION GetDefaultWRDSchemaPasswordPolicy(OBJECT wrdschema)
{
  RECORD retval :=
      [ passwordvalidationchecks := ""
      ];

  IF (ObjectExists(wrdschema))
    retval.passwordvalidationchecks := wrdschema->GetSchemaSetting("wrd:auth.passwordpolicy.validationchecks", [ fallback := "" ]);

  RETURN retval;
}
