<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";

LOADLIB "mod::wrd/lib/internal/payments/endpoints.whlib";
LOADLIB "mod::wrd/lib/internal/psp/base.whlib";


/* General API description: https://dev.buckaroo.nl/Apis
   Actual APIs: https://testcheckout.buckaroo.nl/json/Docs

*/

PUBLIC CONSTANT RECORD ARRAY buckaroo_paymentmethods :=
  [[ rowkey := "ideal"   //should match Services.ServiceList
   , title := "iDEAL"
   , issuers := wrd_payments_idealbanks
  ]];

CONSTANT STRING apiroot_prod := "https://checkout.buckaroo.nl/json/";
CONSTANT STRING apiroot_test := "https://testcheckout.buckaroo.nl/json/";

OBJECT buckaroobrowser;
OBJECT FUNCTION GetBrowser()
{
  IF(ObjectExists(buckaroobrowser))
    RETURN buckaroobrowser;

  buckaroobrowser := NEW WebBrowser;
  LogRPCForWebbrowser("wrd:payments.buckaroo", "", buckaroobrowser);

  RETURN buckaroobrowser;
}

STRING FUNCTION EncodeURLBuckaroo(STRING indata) //Buckaroo doesn't specify the expected URI encoder so we'll guess... this one!
{
  indata := EncodeURL(indata);
  indata := Substitute(indata,'/',"%2f");
  indata := Substitute(indata,'!',"%21");
  indata := Substitute(indata,'$',"%24");
  indata := Substitute(indata,'(',"%28");
  indata := Substitute(indata,')',"%29");
  indata := Substitute(indata,'%7E','~');
  //it wants all escapes to be lowercase
  indata := Substitute(indata,'%3D',"%3d");
  indata := Substitute(indata,'%3F',"%3f");
  RETURN indata;
}


RECORD FUNCTION DoBuckarooRequest(RECORD settings, STRING suburl, RECORD body, STRING culture, STRING channel)
{
  STRING method := RecordExists(body) ? "POST" : "GET";
  STRING finalurl := ResolveToAbsoluteURL(settings.testmode ? apiroot_test : apiroot_prod, suburl);
  INTEGER requesttimestamp := GetUnixTimestamp(GetCurrentDatetime());
  STRING nonce := GenerateUFS128BitId();
  STRING bodytext := EncodeJSON(body);

  // Signature algorithms: https://dev.buckaroo.nl/Apis/Description/json#authentication
  //                       read the C# example code! the spec is ambiguous (eg requestContentBase64String should be empty if no body, secretkey should not be concatenated, Channel is not optional)
  //                       also it doesn't specify the URL Encoding algorithm
  // Debugger: https://dev.buckaroo.nl/Apis/AuthenticationDebugger
  STRING hashbase := settings.websiteid
                     || method
                     || EncodeURLBuckaroo(ToLowercase(Substring(finalurl, 8))) //strip "https://" prefix
                     || requesttimestamp
                     || nonce
                     || (RecordExists(body) ? EncodeBase64(GetMD5Hash(bodytext)) : "");
  STRING auth := `${settings.websiteid}:${EncodeBase64(GetHashForString(hashbase,"HMAC:SHA-256", settings.secretid))}:${nonce}:${requesttimestamp}`;

  GetBrowser()->SendRawRequest(method, finalurl,
     [[ field := "Culture", value := culture ]
     ,[ field := "Channel", value := channel ]
     ,[ field := "Software", value := `{"PlatformName":"WebHare","PlatformVersion":"${EncodeJava(GetWebhareVersionInfo().version)}","ModuleSupplier":"WebHare","ModuleName":"WRD BuckarooPaymentProvider","ModuleVersion":"1.0"}`]
     ,[ field := "Content-Type", value := "application/json" ]
     ,[ field := "Authorization", value := `hmac ${auth}` ]
     ], RecordExists(body) ? StringToBlob(bodytext) : DEFAULT BLOB);

  RETURN CELL[ status := GetBrowser()->GetHTTPStatusCode()
             , response := DecodeJSONBlob(GetBrowser()->content)
             ];
}

PUBLIC STATIC OBJECTTYPE BuckarooPaymentProvider EXTEND WRDPaymentProviderBase_V2
<
  MACRO NEW(RECORD settings)
  : WRDPaymentProviderBase_V2("wrd:buckaroo", "redirect", settings, [ responsekey := "", transactionkey := "" ])
  {
    this->needspaymentref := TRUE;
  }

  UPDATE PUBLIC RECORD FUNCTION GetPSPStatus()
  {
    TRY
    {
      IF(NOT CheckBuckarooMerchant(this->settings))
        RETURN [ success := FALSE, unknown := FALSE, message := "Credentials appear to be invalid" ];

      RETURN [ success := TRUE, unknown := FALSE, message := "" ];
    }
    CATCH(OBJECT e)
    {
      RETURN [ success := FALSE, unknown := FALSE, message := e->what ];
    }
  }

  UPDATE RECORD ARRAY FUNCTION __DoGetPaymentOptions(RECORD options)
  {
    RECORD ARRAY methods;

    FOREVERY(RECORD method FROM buckaroo_paymentmethods)
    {
      IF(method.rowkey NOT IN this->settings.methods)
        CONTINUE;

      INSERT [[ paymentoptiontag := method.rowkey
              , title := method.title
              , issuers := options.getissuers ? method.issuers : RECORD[]
             ]] INTO methods AT END;
    }
    RETURN methods;
  }

  UPDATE PUBLIC MACRO __SetupNewTransaction(MONEY amount_payable, RECORD paymentmethod)
  {
    WRDPaymentProviderBase::__SetupNewTransaction(amount_payable, paymentmethod);

    RECORD customerinfo := this->GetCustomerInfo(paymentmethod);
    this->paymentdata := CELL[ customerinfo.ipaddress
                             , culture := ToUppercase(paymentmethod.language) = "DE" ? "de-DE"
                                         : ToUppercase(paymentmethod.language) = "NL" ? "nl-NL"
                                         : "en-US"
                             ];
  }

  UPDATE PUBLIC RECORD FUNCTION RunPaymentRequest(STRING paymenttok)
  {
    RECORD result := [ submitinstruction := DEFAULT RECORD
                     , complete := FALSE
                     , errors := RECORD[]
                     , processnow := FALSE
                     ];

    /* Payment fields are listed here! https://dev.buckaroo.nl/Apis
       And JSON structure is here - https://testcheckout.buckaroo.nl/json/Docs/Api/POST-json-Transaction
       Note: docs says 'Order' number is ignored so we need to transmit payment ref in the Invoice field
       Limitations of invoice field are unclear. "This can be a combination of numbers and letters" but
       then their example says "testinvoice 123"
    */
    RECORD ARRAY parameters;
    IF(this->issuer != "")
      parameters := [[ name := "issuer", value := this->issuer ]];

    RECORD paymentrequest :=
      CELL[ currency := "EUR"
          , amountdebit := this->amountpayable //Yes, transmitted as float :=(
          , invoice := this->paymentref
          , description := this->orderid
          , returnurl := GetInternalReturnURL(paymenttok)
          , services := [ servicelist := [[ name := this->paymentoptiontag
                                          , action := "Pay"
                                          , parameters := parameters
                                         ]]
                        ]
          , pushurl := GetInternalReturnURL(paymenttok, [ isnotification := TRUE ])
          ];

    IF(this->paymentdata.ipaddress != "")
    {
      INSERT CELL clientip := [ type := this->paymentdata.ipaddress LIKE "*:*" ? 1 : 0 //1=ipv6, 0=ipv4
                              , address := this->paymentdata.ipaddress
                              ] INTO paymentrequest;
    }

    RECORD callresult := DoBuckarooRequest(this->settings, "Transaction", paymentrequest, this->paymentdata.culture, "Web");

    IF(callresult.status != 200)
      THROW NEW Exception(`Unexpected status: ${callresult.status}`);

    GetPrimary()->BeginWork();
    UpdatePaymentMetadata(paymenttok, [ transactionkey := callresult.response."key"
                                      , paymentkey := callresult.response.paymentkey
                                      ]);
    GetPrimary()->CommitWork();

    result.submitinstruction := [ type := "redirect", url := callresult.response.requiredaction.redirecturl ];
    RETURN result;
  }

  UPDATE MACRO PollStatus()
  {
    IF(this->paymentdata.transactionkey = "")
      RETURN; //have nothing to poll

    RECORD callresult := DoBuckarooRequest(this->settings, `Transaction/Status/${EncodeURL(this->paymentdata.transactionkey)}`, DEFAULT RECORD, this->paymentdata.culture, "Web");

    IF(callresult.status != 200)
      THROW NEW Exception(`Unexpected status: ${callresult.status}`);

    //statuscodes are documented at https://dev.buckaroo.nl/PaymentMethods
    IF(callresult.response.status.code.code = 190)
      this->pvt_status := "approved";
    ELSE IF(callresult.status IN [490,491,492,890,891,690])
      this->pvt_status := "failed";
    ELSE
      this->pvt_status := "pending";
  }
>;

PUBLIC BOOLEAN FUNCTION CheckBuckarooMerchant(RECORD methodsettings)
{
  IF(methodsettings.websiteid = "" OR methodsettings.secretid = "")
    RETURN FALSE;

  RECORD result := DoBuckarooRequest(methodsettings, "/json/Transaction/Specification/ideal?serviceVersion=1.0", DEFAULT RECORD, "nl-NL","Web");
  RETURN result.status = 200 AND result.response.name = "ideal";
}
