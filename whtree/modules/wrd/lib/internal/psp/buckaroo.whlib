<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::system/lib/cache.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";

LOADLIB "mod::wrd/lib/internal/payments/endpoints.whlib";
LOADLIB "mod::wrd/lib/internal/psp/base.whlib";


/* General API description: https://dev.buckaroo.nl/Apis
   Actual APIs: https://testcheckout.buckaroo.nl/json/Docs

*/

PUBLIC CONSTANT RECORD ARRAY buckaroo_paymentmethods :=
  [[ rowkey := "ideal"
   , title := "iDEAL"
   , type := "payment"
   , hasissuers := TRUE
   ]
  ,[ rowkey := "emandate"
   , title := "E-mandate"
   , type := "mandate"
   , hasissuers := TRUE
  ]];

CONSTANT STRING apiroot_prod := "https://checkout.buckaroo.nl/json/";
CONSTANT STRING apiroot_test := "https://testcheckout.buckaroo.nl/json/";

OBJECT buckaroobrowser;
OBJECT FUNCTION GetBrowser()
{
  IF(ObjectExists(buckaroobrowser))
    RETURN buckaroobrowser;

  buckaroobrowser := NEW WebBrowser;
  LogRPCForWebbrowser("wrd:payments.buckaroo", "", buckaroobrowser);

  RETURN buckaroobrowser;
}

STRING FUNCTION EncodeURLBuckaroo(STRING indata) //Buckaroo doesn't specify the expected URI encoder so we'll guess... this one!
{
  indata := EncodeURL(indata);
  indata := Substitute(indata,'/',"%2f");
  indata := Substitute(indata,'!',"%21");
  indata := Substitute(indata,'$',"%24");
  indata := Substitute(indata,'(',"%28");
  indata := Substitute(indata,')',"%29");
  indata := Substitute(indata,'%7E','~');
  //it wants all escapes to be lowercase
  indata := Substitute(indata,'%3D',"%3d");
  indata := Substitute(indata,'%3F',"%3f");
  RETURN indata;
}


RECORD FUNCTION DoBuckarooRequest(RECORD settings, STRING suburl, RECORD body, STRING culture, STRING channel)
{
  STRING method := RecordExists(body) ? "POST" : "GET";
  STRING finalurl := ResolveToAbsoluteURL(settings.testmode ? apiroot_test : apiroot_prod, suburl);
  INTEGER requesttimestamp := GetUnixTimestamp(GetCurrentDatetime());
  STRING nonce := GenerateUFS128BitId();
  STRING bodytext := EncodeJSON(body, CELL["AmountDebit","Currency","Description","PushURL","ReturnURL","Services","StartRecurrent","ServiceList","Parameters","Name","Action","Value"]);

  // Signature algorithms: https://dev.buckaroo.nl/Apis/Description/json#authentication
  //                       read the C# example code! the spec is ambiguous (eg requestContentBase64String should be empty if no body, secretkey should not be concatenated, Channel is not optional)
  //                       also it doesn't specify the URL Encoding algorithm
  // Debugger: https://dev.buckaroo.nl/Apis/AuthenticationDebugger
  STRING hashbase := settings.websiteid
                     || method
                     || EncodeURLBuckaroo(ToLowercase(Substring(finalurl, 8))) //strip "https://" prefix
                     || requesttimestamp
                     || nonce
                     || (RecordExists(body) ? EncodeBase64(GetMD5Hash(bodytext)) : "");
  STRING auth := `${settings.websiteid}:${EncodeBase64(GetHashForString(hashbase,"HMAC:SHA-256", settings.secretid))}:${nonce}:${requesttimestamp}`;

  GetBrowser()->SendRawRequest(method, finalurl,
     [[ field := "Culture", value := culture ]
     ,[ field := "Channel", value := channel ]
     ,[ field := "Software", value := `{"PlatformName":"WebHare","PlatformVersion":"${EncodeJava(GetWebhareVersionInfo().version)}","ModuleSupplier":"WebHare","ModuleName":"WRD BuckarooPaymentProvider","ModuleVersion":"1.0"}`]
     ,[ field := "Content-Type", value := "application/json" ]
     ,[ field := "Authorization", value := `hmac ${auth}` ]
     ], RecordExists(body) ? StringToBlob(bodytext) : DEFAULT BLOB);

  RECORD jsonresponse := DecodeJSONBlob(GetBrowser()->content);
  RETURN CELL[ status := GetBrowser()->GetHTTPStatusCode()
             , response := jsonresponse
             ];
}

PUBLIC STATIC OBJECTTYPE BuckarooPaymentProvider EXTEND WRDPaymentProviderBase_V2
<
  MACRO NEW(RECORD settings)
  : WRDPaymentProviderBase_V2("wrd:buckaroo", "redirect", settings, [ transactionkey := "", validationreference := "", isrecurring := FALSE, paymentkey := "" ])
  {
    this->needspaymentref := TRUE;
  }

  UPDATE PUBLIC RECORD FUNCTION GetPSPStatus()
  {
    TRY
    {
      IF(NOT CheckBuckarooMerchant(this->settings))
        RETURN [ success := FALSE, unknown := FALSE, message := "Credentials appear to be invalid" ];

      RETURN [ success := TRUE, unknown := FALSE, message := "" ];
    }
    CATCH(OBJECT e)
    {
      RETURN [ success := FALSE, unknown := FALSE, message := e->what ];
    }
  }

  UPDATE RECORD ARRAY FUNCTION __DoGetPaymentOptions(RECORD options)
  {
    RECORD connectinfo := CELL[ this->settings.testmode, this->settings.websiteid, this->settings.secretid ];
    RECORD ARRAY methods;

    FOREVERY(RECORD method FROM buckaroo_paymentmethods)
    {
      IF(method.rowkey NOT IN this->settings.methods)
        CONTINUE;

      RECORD ARRAY issuers;
      IF(options.getissuers AND method.hasissuers)
      {
        TRY
        {
          RECORD cachekey := CELL[...connectinfo, which := method.rowkey];
          issuers := WaitForPromise(GetPrecalculatedData(cachekey, Resolve("#GetCacheableIssuers"))).issuers;
        }
        CATCH(OBJECT e)
        {
          LogHarescriptException(e);
        }
      }

      INSERT [CELL[ paymentoptiontag := method.rowkey
                  , method.title
                  , method.type
                  , issuers
                  , islive := NOT this->settings.testmode
                 ]] INTO methods AT END;
    }
    RETURN methods;
  }

  UPDATE PUBLIC MACRO __SetupNewTransaction(MONEY amount_payable, RECORD paymentmethod)
  {
    WRDPaymentProviderBase::__SetupNewTransaction(amount_payable, paymentmethod);

    STRING ARRAY requirements;
    STRING mandateid;
    IF(paymentmethod.paymentoptiontag = "emandate")
    {
      INSERT "customerid" INTO requirements AT END;

      IF(RecordExists(paymentmethod.capturefrom))
      {
        IF(paymentmethod.capturedate = DEFAULT DATETIME)
          THROW NEW Exception(`Missing capturedate`);

        RECORD origmetadata := paymentmethod.capturefrom.__bestpayment.__paymentdata.m;
        mandateid := origmetadata.mandateid;
        IF(paymentmethod.customerid = "")
          paymentmethod.customerid := origmetadata.customerid;

        paymentmethod.isrecurring := origmetadata.isrecurring;
      }
    }

    RECORD customerinfo := this->GetCustomerInfo(paymentmethod, CELL [ requirements ]);
    IF(Length(customerinfo.customerid) > 35)
      THROW NEW Exception(`Customer id '${customerinfo.customerid}' too long, may be up to 35 characters`);

    this->paymentdata := CELL[ ...this->paymentdatastructure
                             , customerinfo.ipaddress
                             , customerinfo.customerid
                             , culture := ToUppercase(paymentmethod.language) = "DE" ? "de-DE"
                                         : ToUppercase(paymentmethod.language) = "NL" ? "nl-NL"
                                         : "en-US"
                             , paymentmethod.isrecurring
                             , usemandateid := mandateid
                             , capturedate := paymentmethod.capturedate
                             ];
  }

  UPDATE PUBLIC RECORD FUNCTION RunPaymentRequest(STRING paymenttok)
  {
    RECORD result := [ submitinstruction := DEFAULT RECORD
                     , complete := FALSE
                     , errors := RECORD[]
                     , processnow := FALSE
                     ];

    /* Payment fields are listed here! https://dev.buckaroo.nl/Apis
       And JSON structure is here - https://testcheckout.buckaroo.nl/json/Docs/Api/POST-json-Transaction
       Note: docs says 'Order' number is ignored so we need to transmit payment ref in the Invoice field
       Limitations of invoice field are unclear. "This can be a combination of numbers and letters" but
       then their example says "testinvoice 123"
    */
    RECORD paymentrequest :=
      CELL[ currency := "EUR"
          , description := this->orderid
          , returnurl := GetInternalReturnURL(paymenttok)
          , services := [ servicelist := [[ name := this->paymentoptiontag
                                          , action := "Pay"
                                          , parameters := RECORD[]
                                         ]]
                        ]
          , pushurl := GetInternalReturnURL(paymenttok, [ isnotification := TRUE ])
          ];

    STRING actiontype := "Transaction";
    IF(this->paymentoptiontag = "emandate" AND this->paymentdata.usemandateid = "") //not using an existing mandate
    {
      paymentrequest.services.servicelist[0].parameters := paymentrequest.services.servicelist[0].parameters CONCAT
              [[ name := "debtorbankid", value := this->issuer ]
              ,[ name := "debtorreference", value := this->paymentdata.customerid ]
              // Indicates type of eMandate: one-off or recurring direct debit. 0 = recurring, 1 = one off.
              ,[ name := "sequencetype", value := this->paymentdata.isrecurring ? "0" : "1" ]
              ,[ name := "purchaseid", value := this->paymentref ]
              ,[ name := "language", value := ToLowercase(tokenize(this->paymentdata.culture,'-')[0]) ]
              ,[ name := "emandatereason", value := this->orderid ]
              ];

      paymentrequest.services.servicelist[0].action := "CreateMandate";
      actiontype := "DataRequest";
    }
    ELSE
    {
      IF(this->paymentoptiontag = "emandate" AND this->paymentdata.usemandateid != "")
      {
        //https://docs.buckaroo.io/docs/sepadirectdebit-requests#paywithemandate
        paymentrequest.services.servicelist[0].name := "SepaDirectDebit";
        paymentrequest.services.servicelist[0].action := "PayWithEmandate";
        paymentrequest.services.servicelist[0].parameters := paymentrequest.services.servicelist[0].parameters CONCAT
              [[ name := "MandateReference", value := this->paymentdata.usemandateid ]
              ,[ name := "CollectDate", value := FormatDatetime("%Y-%m-%d", this->paymentdata.capturedate) ]
              ];

        INSERT CELL Startrecurrent := this->paymentdata.isrecurring INTO paymentrequest;

        DELETE CELL returnurl FROM paymentrequest; //doesn't make sense
      }
      ELSE
      {
        IF(this->issuer != "")
          INSERT [[ name := "issuer", value := this->issuer ]] INTO paymentrequest.services.servicelist[0].parameters AT END;
      }

      INSERT CELL amountdebit := this->amountpayable //Yes, transmitted as float :=(
                , invoice := this->paymentref
             INTO paymentrequest;

    }

    IF(this->paymentdata.ipaddress != "")
    {
      INSERT CELL clientip := [ type := this->paymentdata.ipaddress LIKE "*:*" ? 1 : 0 //1=ipv6, 0=ipv4
                              , address := this->paymentdata.ipaddress
                              ] INTO paymentrequest;
    }

    RECORD callresult := DoBuckarooRequest(this->settings, actiontype, paymentrequest, this->paymentdata.culture, "Web");
    dumpvalue(callresult,'tree');

    IF(callresult.status != 200)
      THROW NEW Exception(`Unexpected status: ${callresult.status}`);

    callresult.response := EnforceStructure( [ paymentkey := ""
                                             , services := RECORD[] ], callresult.response);
    UpdatePaymentMetadata(paymenttok, [ transactionkey := callresult.response."key"
                                      , paymentkey := callresult.response.paymentkey
                                      , mandateid := Length(callresult.response.services) > 0 ? (SELECT AS STRING value FROM callresult.response.services[0].parameters WHERE ToUppercase(name) = "MANDATEID") : ""
                                      ]);

    IF(RecordExists(callresult.response.requiredaction))
      result.submitinstruction := [ type := "redirect", url := callresult.response.requiredaction.redirecturl ];
    ELSE
      result.complete := TRUE;

    RETURN result;
  }

  UPDATE MACRO PollStatus()
  {
    IF(this->paymentdata.transactionkey = "")
      RETURN; //have nothing to poll

    RECORD callresult;
    IF(this->paymentoptiontag = "emandate" AND this->paymentdata.usemandateid = "")
    {
      RECORD inforequest :=
        CELL[ currency := "EUR"
            , description := this->orderid
            , services := [ servicelist := [[ name := "emandate"
                                            , action := "GetStatus"
                                            , parameters := RECORD[[ name := "mandateid", value := this->paymentdata.mandateid ]]
                                           ]]
                          ]
            ];

      callresult := DoBuckarooRequest(this->settings, "DataRequest", inforequest, this->paymentdata.culture, "Web");

      STRING validationreference := SELECT AS STRING value FROM callresult.response.services[0].parameters WHERE ToUppercase(name) = "VALIDATIONREFERENCE";
      IF(validationreference != "") //buckaroo recommends saving this, so i guess we will.
        this->paymentdata.validationreference := validationreference;
    }
    ELSE
    {
      callresult := DoBuckarooRequest(this->settings, `Transaction/Status/${EncodeURL(this->paymentdata.transactionkey)}`, DEFAULT RECORD, this->paymentdata.culture, "Web");
    }
    IF(callresult.status != 200)
      THROW NEW Exception(`Unexpected status: ${callresult.status}`);

    //statuscodes are documented at https://dev.buckaroo.nl/PaymentMethods
    IF(callresult.response.status.code.code = 190)
      this->pvt_status := "approved";
    ELSE IF(callresult.status IN [490,491,492,890,891,690])
      this->pvt_status := "failed";
    ELSE
      this->pvt_status := "pending";
  }
>;

PUBLIC BOOLEAN FUNCTION CheckBuckarooMerchant(RECORD methodsettings)
{
  IF(methodsettings.websiteid = "" OR methodsettings.secretid = "")
    RETURN FALSE;

  RECORD result := DoBuckarooRequest(methodsettings, "/json/Transaction/Specification/ideal?serviceVersion=1.0", DEFAULT RECORD, "nl-NL","Web");
  RETURN result.status = 200 AND result.response.name = "ideal";
}

PUBLIC RECORD FUNCTION GetCacheableIssuers(RECORD cachekey)
{
  RECORD ARRAY issuers;
  IF(cachekey.which = "ideal")
  {
    /*
  {
    "Actions": [
      {
        "Name": "Pay",
        "Type": 0,
        "Default": true,
        "Description": "Pay",
        "RequestParameters": [
          {
            "ListItemDescriptions": [
              {
                "Value": "ABNANL2A",
                "Description": "ABN AMRO",
                "GroupName": "Nederland"
              },
            "Name": "issuer"
  */
    RECORD result := DoBuckarooRequest(cachekey, `/json/Transaction/Specification/${cachekey.which}?serviceVersion=1.0`, DEFAULT RECORD, "nl-NL","Web");
    //dumpvalue(result,'tree');
    RECORD payaction := SELECT * FROM result.response.Actions WHERE Name = "Pay";
    RECORD issuerparameter := SELECT * FROM payaction.RequestParameters  WHERE Name = "issuer";
    issuers := SELECT rowkey := Value, title := description FROM issuerparameter.ListItemDescriptions;
  }
  ELSE IF(cachekey.which = "emandate")
  {
    RECORD paymentrequest :=
      CELL[ currency := "EUR"
          , services := [ servicelist := [[ name := "emandate"
                                          , action := "GetIssuerList"
                                         ]]
                        ]
          ];

    RECORD callresult := DoBuckarooRequest(cachekey, "DataRequest", paymentrequest, "nl-NL", "Web");
    /*
 +STATUS: 200
 +RESPONSE: RECORD
  +ISTEST: TRUE
  +KEY: '214FB3542F2E433A8D7657E8CF1919DC'
  +SERVICECODE: 'emandate'
  +ADDITIONALPARAMETERS: DEFAULT RECORD
  +CONSUMERMESSAGE: DEFAULT RECORD
  +CUSTOMPARAMETERS: DEFAULT RECORD
  +REQUESTERRORS: DEFAULT RECORD
  +REQUIREDACTION: DEFAULT RECORD
  +SERVICES: RECORD ARRAY
   +RECORD
    +NAME: 'emandate'
    +ACTION: DEFAULT RECORD
    +PARAMETERS: RECORD ARRAY
     +RECORD
      +NAME: 'issuer1_DebtorBankId'
      +VALUE: 'ABNANL2A'
     +RECORD
      +NAME: 'issuer1_DebtorBankName'
      +VALUE: 'ABN AMRO'
     +RECORD
      +NAME: 'issuer1_DebtorBankCountry'
      +VALUE: 'Nederland'
     +RECORD
      +NAME: 'issuer2_DebtorBankId'
      +VALUE: 'ASNBNL21'
     +RECORD
      +NAME: 'issuer2_DebtorBankName'
      +VALUE: 'ASN Bank'
     +RECORD
      +NAME: 'issuer2_DebtorBankCountry'
      +VALUE: 'Nederland'
     +RECORD


    */
    RECORD emandateservice := SELECT * FROM callresult.response.services WHERE name = "emandate";
    IF(RecordExists(emandateservice))
    {
      STRING ARRAY unique_issuer_prefixes := SELECT AS STRING ARRAY DISTINCT Tokenize(name,'_')[0] FROM emandateservice.parameters WHERE ToUppercase(name) LIKE "ISSUER*_*";
      FOREVERY(STRING prefix FROM unique_issuer_prefixes)
      {
        STRING bankid := SELECT AS STRING value FROM emandateservice.parameters WHERE ToUppercase(name) = ToUppercase(prefix || "_DebtorBankId");
        STRING bankname := SELECT AS STRING value FROM emandateservice.parameters WHERE ToUppercase(name) = ToUppercase(prefix || "_DebtorBankName");
        IF(bankid != '' AND bankname != '')
          INSERT CELl[ rowkey := bankid, title :=bankname ] INTO issuers AT END;
      }
    }
  }
  ELSE
  {
    THROW NEW Exception(`Unknown type '${cachekey.which}'`);
  }

  IF(Length(issuers) = 0)
    THROW NEW Exception(`Failed to retrieve issuers fort type '${cachekey.which}'`);

  RETURN CELL[ value := CELL[ issuers ] ];
}
