<?wh
LOADLIB "wh::javascript.whlib";

LOADLIB "mod::wrd/lib/internal/payments/endpoints.whlib";
LOADLIB "mod::wrd/lib/internal/psp/base.whlib";
LOADLIB "mod::system/lib/internal/modules/bridgesupport.whlib";

STRING FUNCTION MapField(STRING infield)
{
  SWITCH(infield)
  {
    CASE "wrdContactEmail"
    {
      RETURN "WRD_CONTACT_EMAIL";
    }
    DEFAULT
    {
      THROW NEW Exception(`Field '${infield}' not supported`);
    }
  }
}

RECORD ARRAY FUNCTION MapErrors(RECORD ARRAY inerrors)
{
  RETURN SELECT field := CellExists(inerrors,'field') ? MapField(inerrors.field) : "", error, description := comment FROM inerrors;
}

STRING FUNCTION MapRequirement(STRING inrequirement) {
  SWITCH(inrequirement) {
    CASE "wrdGender" {
      RETURN "wrd_gender";
    }
    CASE "wrdFirstName" {
      RETURN "wrd_firstname";
    }
    CASE "wrdLastName" {
      RETURN "wrd_lastname";
    }
    CASE "wrdContactPhone" {
      RETURN "wrd_contact_phone";
    }
    CASE "wrdContactEmail" {
      RETURN "wrd_contact_email";
    }
    CASE "wrdDateOfBirth" {
      RETURN "wrd_dateofbirth";
    }
    CASE "billingAddress" {
      RETURN "billingaddress";
    }
    CASE "shippingAddress" {
      RETURN "shippingaddress";
    }
    CASE "ipAddress" {
      RETURN "ipaddress";
    }
    CASE "orderLines" {
      RETURN "orderlines";
    }
    DEFAULT {
      THROW NEW Exception(`Unsupported requirement '${inrequirement}'`);
    }
  }
}

STRING ARRAY FUNCTION MapRequirements(STRING ARRAY inrequirements) {
  RETURN SELECT AS STRING ARRAY MapRequirement(req) FROM ToRecordArray(inrequirements,'req');
}

PUBLIC STATIC OBJECTTYPE JSPaymentProvider EXTEND WRDPaymentProviderBase <
  RECORD methodsettings;
  RECORD newtransdata; //data captured by __setupnewtransaction, most of it to be discarded
  PUBLIC STRING paymeta;
  STRING rejectreasonhtml;

  //driver with '#' is a raw path, since 5.9.2 we'll support module-based names too
  MACRO NEW(RECORD settings) : WRDPaymentProviderBase("wrd:js", "redirect", settings) {
    IF(CellExists(settings,'pspoptions')) { //are we invoked for an explicit JS PSP, and not just 'wrd:js' with raw metadata?
      this->pvt_psptype := settings.type;
      settings := settings.pspoptions;
    }
    this->methodsettings := settings;
    this->needspaymentref := TRUE;
  }

  RECORD FUNCTION BuildTransData(MONEY amount_payable, RECORD paymentmethod)
  {
    RECORD selectedmethod := SELECT * FROM this->methodsettings.methods WHERE methods.rowkey = paymentmethod.paymentoptiontag;
    IF(NOT RecordExists(selectedmethod))
      THROW NEW Exception(`Method '${paymentmethod.paymentoptiontag}' not found`);

    RECORD customerinfo := this->GetCustomerInfo(paymentmethod, [ requirements := selectedmethod.requirements ]);

    RETURN CELL[ ...paymentmethod
               , ...customerinfo
               , wrdpersonentity := ObjectExists(paymentmethod.wrdpersonentity) ? paymentmethod.wrdpersonentity->id : 0
               , cart := paymentmethod.orderlines
               , amount_payable
               , DELETE wrdpersonfields //they're merged into customerinfo
               ];
  }

  UPDATE PUBLIC RECORD FUNCTION __GetPaymentData()
  {
    RECORD retval;
    IF(this->rejectreasonhtml != "")
      retval := CELL[...retval, this->rejectreasonhtml];
    IF(this->cardissuer != "")
      retval := CELL[...retval, this->cardissuer];
    IF(this->cardnumber != "")
      retval := CELL[...retval, this->cardnumber];
    RETURN retval;
  }

  UPDATE PUBLIC MACRO __SetupNewTransaction(MONEY amount_payable, RECORD paymentmethod)
  {
    WRDPaymentProviderBase::__SetupNewTransaction(amount_payable, paymentmethod);
    this->newtransdata := this->BuildTransData(amount_payable, paymentmethod);
  }

  UPDATE PUBLIC MACRO __SetupExistingTransaction(RECORD payment)
  {
    WRDPaymentProviderBase::__SetupExistingTransaction(payment);
    RECORD opts := EnforceStructure([ rejectreasonhtml := "", cardissuer := "", cardnumber := "" ], payment.__paymentdata.m);
    this->paymeta := CellExists(payment.__paymentdata.m,'paymeta') ? payment.__paymentdata.m.paymeta : "";
    this->rejectreasonhtml := opts.rejectreasonhtml;
    this->cardissuer := opts.cardissuer;
    this->cardnumber := opts.cardnumber;
  }

  UPDATE RECORD ARRAY FUNCTION __DoGetPaymentOptions(RECORD options)
  {
    IF(NOT RecordExists(this->methodsettings))
      RETURN RECORD[];

    RETURN SELECT paymentoptiontag := rowkey
                , title
                , issuers := RECORD[]
                , islive := this->methodsettings.islive
                , requirements := MapRequirements(requirements)
                , minamount := CellExists(methods,'minamount') ? MONEY(methods.minamount) : 0m
                , maxamount := CellExists(methods,'maxamount') ? MONEY(methods.maxamount) : 0m
                , images := CellExists(methods,'images') ? (SELECT link, mime_type := mimetype FROM methods.images) : RECORD[]
             FROM this->methodsettings.methods;
  }

  UPDATE PUBLIC RECORD FUNCTION CheckPaymentRequest(MONEY amount_payable, RECORD paymentmethod)
  {
    RECORD transdata := this->BuildTransData(amount_payable, paymentmethod);
    RECORD result := CallJS("@mod-wrd/js/internal/paymentbridge.ts#precheckPaymentRequest",
        this->methodsettings.driver,
        this->methodsettings.configuration,
        transdata);
    result.errors := MapErrors(result.errors);
    RETURN result;
  }

  UPDATE PUBLIC RECORD FUNCTION RunPaymentRequest(STRING paymenttok)
  {
    RECORD result := [ submitinstruction := DEFAULT RECORD
                     , complete := FALSE
                     , errors := RECORD[]
                     , processnow := FALSE
                     ];

    STRING returnurl := GetInternalReturnURL(paymenttok);
    STRING pushurl := GetInternalReturnURL(paymenttok, [ isnotification := TRUE ]);
    RECORD transdata :=
        CELL[ ...this->newtransdata
            , paymentuuid := paymenttok
            , returnurl
            , pushurl
            ];
    IF(transdata.orderid = "")
      THROW NEW Exception(`Transactions must have an orderid`); //we should have always required this, using the switch to JS PSPs to enforce it

    RECORD paymentresult:= CallJS("@mod-wrd/js/internal/paymentbridge.ts#runPaymentRequest",
        this->methodsettings.driver,
        this->methodsettings.configuration,
        transdata);

    IF(paymentresult.paymentmetadata != "")
    {
      this->paymeta := paymentresult.paymentmetadata;
      UpdatePaymentMetadata(paymenttok, [ paymeta := paymentresult.paymentmetadata
                                        ]);
    }

    result.submitinstruction := paymentresult.navigateto;
    result.errors := MapErrors(paymentresult.errors);
    this->ProcessPaymentResult(paymentresult);

    RETURN result;
  }

  MACRO ProcessPaymentResult(RECORD paymentresult)
  {
    IF(CellExists(paymentresult,'setstatus'))
      this->pvt_status := paymentresult.setstatus;
    IF(CellExists(paymentresult,'rejectreasonhtml'))
      this->rejectreasonhtml := paymentresult.rejectreasonhtml;
    IF(CellExists(paymentresult,'cardnumber'))
      this->cardnumber := paymentresult.cardnumber;
    IF(CellExists(paymentresult,'cardissuer'))
      this->cardissuer := paymentresult.cardissuer;
  }

  UPDATE PUBLIC RECORD FUNCTION ProcessNotification()
  {
    RECORD returnreq := EncodeWebRequestForJS();
    RECORD pushresult := CallJS("@mod-wrd/js/internal/paymentbridge.ts#processPush",
        this->methodsettings.driver,
        this->methodsettings.configuration,
        this->paymeta,
        returnreq);

    IF(NOT RecordExists(pushresult))
      RETURN DEFAULT RECORD;

    this->ProcessPaymentResult(pushresult);
    RETURN pushresult.response;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION ProcessReturnURL(STRING returnurl)
  {
    IF(this->pvt_status != "pending") //We've already got a response for this payment. No need to recheck (all drivers should probably do this)
      RETURN TRUE;

    RECORD returnreq := EncodeWebRequestForJS();
    RECORD paymentresult := CallJS("@mod-wrd/js/internal/paymentbridge.ts#processReturnURL",
        this->methodsettings.driver,
        this->methodsettings.configuration,
        this->paymeta,
        returnreq);

    this->ProcessPaymentResult(paymentresult);
    RETURN TRUE;
  }

  UPDATE PUBLIC MACRO RecheckPayment()
  {
    RECORD paymentresult := CallJS("@mod-wrd/js/internal/paymentbridge.ts#checkStatus",
        this->methodsettings.driver,
        this->methodsettings.configuration,
        this->paymeta);
    this->ProcessPaymentResult(paymentresult);
  }

  UPDATE PUBLIC STRING FUNCTION GetHTMLStatusForUser()
  {
    RETURN this->rejectreasonhtml;
  }

  UPDATE PUBLIC RECORD FUNCTION GetPSPStatus()
  {
    RECORD result := CallJS("@mod-wrd/js/internal/paymentbridge.ts#connectPSP",
        this->methodsettings.driver,
        this->methodsettings.configuration);

    IF(result.error !=  "")
      RETURN [ success := FALSE, unknown := FALSE, message := result.error ];
    IF(Length(result.methods) = 0) //TODO but perhaps we should actually be comparing our expected list with the received list? or at least update it?
      RETURN [ success := FALSE, unknown := FALSE, message := "No methods available" ];

    RETURN [ success := TRUE, unknown := FALSE, message := "Available methods: " || Detokenize((SELECT AS STRING ARRAY title FROM result.methods),", ") ];
  }
>;
