<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/localization.whlib";
LOADLIB "wh::witty.whlib";

LOADLIB "mod::wrd/lib/worldinfo/countries.whlib";

PUBLIC CONSTANT STRING ARRAY stored_address_fields := ["country","street","nr_detail","zip","state","city"];

/** @short Parse a rawdata address
    @long The address is stored in java-encoded, linefeed separated, value=data pairs */
RECORD FUNCTION ParseAddressRawdata(STRING data)
{
  STRING ARRAY curaddresstoks:=Tokenize(data,'\n');
  RECORD retdata := CELL[];
  FOREVERY(STRING tok FROM curaddresstoks)
  {
    INTEGER equals := SearchSubstring(tok,'=');
    IF(equals<1)
      CONTINUE;

    STRING fieldname := Left(tok,equals);
    STRING fielddata := Substring(tok,equals+1,Length(tok));
    IF (NOT CellExists(retdata, fieldname))
      retdata := CellInsert(retdata,DecodeJava(fieldname),DecodeJava(fielddata));
  }
  RETURN retdata;
}

PUBLIC STRING FUNCTION EncodeWRDAddress(RECORD indata)
{
  IF(NOT RecordExists(indata))
    RETURN "";
  IF(NOT CellExists(indata,'country') OR Length(indata.country) != 2)
  {
    dumpvalue(indata);
    THROW NEW Exception(`The field 'country' is required in an address and must be a 2 digit code`);
  }

  indata := PickCells(indata, stored_address_fields);
  indata.country := ToUppercase(indata.country);
  FOREVERY(STRING field FROM stored_address_fields)
    IF(CellExists(indata, field) AND GetCell(indata, field) = "")
      indata := CellDelete(indata, field);

  RETURN EncodeJSON(indata);
}

PUBLIC STRING FUNCTION GetDisplayValueForParsedAddress(RECORD rawaddress, STRING language, BOOLEAN showcountry)
{
  STRING countrycode := CellExists(rawaddress,"country") ? rawaddress.country : "";
  /* Look up address information for this country */
  RECORD info := __GetWRDAddressInfo(countrycode,language);
  RECORD ARRAY fields := info.fields;

  STRING displayvalue;
  IF(info.addressformat != "")
  {
     //TODO Cache the witty!
    OBJECT addresswitty := NEW WittyTemplate("TEXT");
    addresswitty->LoadCodeDirect(DecodeJava(info.addressformat));
    displayvalue := addresswitty->RunToString(rawaddress);
  }
  ELSE
  {
    FOREVERY(RECORD subfield FROM fields)
    {
      STRING cellvalue;
      IF(CellExists(rawaddress,subfield.tag))
        cellvalue:=GetCell(rawaddress,subfield.tag);

      INSERT CELL value := cellvalue INTO fields[#subfield];

      displayvalue := displayvalue || cellvalue;

      //Append a break if requested, but only if this is not the first line and the preceding line was not empty.
      IF (displayvalue != "" AND Right(displayvalue,1)!="\n")
        displayvalue := displayvalue || (subfield.break_after ? '\n' : ' ');
    }
  }

  // Add the country
  IF(showcountry)
  {
    // Add an break (if needed)
    IF (displayvalue!="" AND Right(displayvalue,1)!="\n")
      displayvalue := displayvalue || '\n';

    displayvalue := displayvalue ||
        (SELECT AS STRING title
           FROM GetWRDCountryList(language, countrycode)
          WHERE code = ToUppercase(countrycode));
  }
  RETURN TrimWhitespace(displayvalue);
}

RECORD FUNCTION GetCacheableCountryNameList(STRING language)
{
  RETURN
      [ value :=      (SELECT code, title := GetCell(row, language) FROM GetCountryList(language) AS row ORDER BY code)
      , ttl :=        60 * 60 * 1000
      ];
}

PUBLIC RECORD FUNCTION GenerateAddress(STRING rawvalue, STRING currentlanguage, INTEGER wrd_schema, BOOLEAN with_country_full)
{
  //The WH5.4 format
  RECORD finaladdress :=
    CELL[ country :=        ""
        , street :=         ""
        , locationdetail := ""   //we'll never set locationdetail anymore but we'll keep it for backwards compatibility
        , nr_detail :=      ""
        , zip :=            ""
        , city :=           ""
        , state :=          ""
        ];

  IF(rawvalue LIKE '{*') //It's JSON!
  {
    finaladdress := CELL[ ...finaladdress, ...PickCells(DecodeJSON(rawvalue),stored_address_fields) ];
  }
  ELSE //Convert pre WH5.4 address
  {
    RECORD originaladdress := ParseAddressRawdata(rawvalue);

    RECORD address := originaladdress;
    FOREVERY(RECORD field FROM UnpackRecord(address))
      IF(TrimWhitespace(field.value) IN ["","-"]) //invalid or dummy values
        address := CellDelete(address,field.name);

    FOREVERY(STRING straightcopy FROM ["country","street","nr_detail","zip","city"])
      IF(CellExists(address,straightcopy))
        finaladdress := CellUpdate(finaladdress, straightcopy, GetCell(address, straightcopy));

    IF(Length(address.country) != 2)
      RETURN DEFAULT RECORD; //broken value

    IF(CellExists(address, "province"))
    {
      IF(finaladdress.state = "")
        finaladdress.state := address.province;
    }

    IF(CellExists(address, "district"))
    {
      IF(finaladdress.city = "")
        finaladdress.city := address.district;
      ELSE
        finaladdress.city := finaladdress.city || ", " || address.district;
    }

    DELETE CELL country,street,nr_detail,zip,city,country_full,province,state,district FROM address;

    FOREVERY(STRING prefix_to_street FROM ["colony","locationdetail2","locationdetail"])
      IF(CellExists(address,prefix_to_street))
      {
        finaladdress.street := TrimWhitespace(GetCell(address,prefix_to_street) || "\n" || finaladdress.street);
        address := CellDelete(address, prefix_to_street);
      }

    FOREVERY(RECORD remainingfield FROM UnpackRecord(address))
      {
        finaladdress.street := TrimWhitespace(remainingfield.value || "\n" || finaladdress.street);
        address := CellDelete(address, remainingfield.name);
      }
  }

  finaladdress.country := ToUppercase(finaladdress.country);

  IF (with_country_full)
  {
    STRING country_full;
    IF(finaladdress.country != "")
    {
      RECORD ARRAY countries := GetAdhocCached([ lang := currentlanguage ], PTR GetCacheableCountryNameList(currentlanguage));
      RECORD pos := RecordLowerBound(countries, [ code := finaladdress.country ], [ "CODE" ]);
      IF (pos.found)
        country_full := countries[pos.position].title;
    }
    finaladdress := CELL[...finaladdress, country_full ];
  }

  RETURN finaladdress;
}
