<?wh
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";


CONSTANT RECORD attributedefaults :=
    CELL[ __reftype := DEFAULT OBJECT
        , allowedvalues := STRING[]
        , base := FALSE
        , cellname := ""
        , cellnames := STRING[]
        , checklinks := FALSE
        , description := ""
        , domain := 0
        , generatetag := ""
        , isgenerated := FALSE
        , ishiddenbyparent := FALSE  //marks attributes that are invisible because a parent type defined them
        , isinherited := FALSE       //marks attributes that are define in a parent
        , isordered := FALSE
        , isreadonly := FALSE
        , isrequired := FALSE
        , isunique := FALSE
        , isunsafetocopy := FALSE
        , maxlength := 0
        , multiline := FALSE
        , parent := 0
        ];

CONSTANT RECORD baseattributedefaults :=
    CELL[ ...attributedefaults
        , id   := 0
        , base := TRUE
        ];


PUBLIC RECORD FUNCTION BaseAttributeValidation(RECORD metadata)
{
  IF(CellExists(metadata,'tag'))
  {
    IF(metadata.tag="")
      THROW NEW Exception("Attribute tags cannot be made empty");
    IF(metadata.tag!=TrimWhitespace(metadata.tag))
      THROW NEW Exception("Attribute tags cannot start or end with whitespace");

    metadata.tag := ToUppercase(metadata.tag);
  }
  RETURN metadata;
}

RECORD ARRAY FUNCTION GetSubAttrs(INTEGER whichtype)
{
  // Retrieve all attributes
  RECORD ARRAY attrs :=
         SELECT TEMPORARY uppercasetag := ToUppercase(tag)
              , ...attributedefaults
              , id
              , attributetype
              , title
              , localtag := uppercasetag
              , description
              , domain       := IsDomainAttributeType(attributetype) ? domain : 0 // Only return domain for domain attrs
              , isrequired := required
              , isordered := ordered
              , isunique
              , isunsafetocopy
              , parent
              , maxlength := (attributetype IN // (string type fields)
                                [ wrd_attributetype_free
                                , wrd_attributetype_address
                                , wrd_attributetype_email
                                , wrd_attributetype_telephone
                                , wrd_attributetype_password
                                , wrd_attributetype_url
                                ]) ? 4096 : 0
              , checklinks
              , multiline
              , allowedvalues := allowedvalues != "" ? Tokenize(allowedvalues,'\t') : DEFAULT STRING ARRAY
          FROM wrd.attrs AS mainattrs
         WHERE type = whichtype;

  RECORD ARRAY conflictingattrs := SELECT localtag, parent
                                     FROM attrs
                                 GROUP BY localtag, parent
                                  HAVING COUNT(*)>1;

  IF(Length(conflictingattrs) > 0)
    THROW NEW Exception(`Cannot load WRD type #${whichtype} due to duplicate attr/tag '${conflictingattrs[0].localtag}' with parent #${conflictingattrs[0].parent}`);

 attrs :=
     SELECT *
          , __parentpos :=
                     (SELECT AS INTEGER #parents + 1
                        FROM attrs AS parents
                       WHERE parents.id = list.parent) - 1
          , __selectattributeids := [ INTEGER(list.id) ]
       FROM attrs AS list;

  FOREVERY (RECORD rec FROM attrs)
  {
    INTEGER id := rec.id;
    INTEGER pos := rec.__parentpos;

    WHILE (pos != -1)
    {
      INSERT id INTO attrs[pos].__selectattributeids AT END;
      pos := attrs[pos].__parentpos;
    }
  }

  // Don't leave mess hanging around
  attrs := SELECT *, DELETE __parentpos FROM attrs;
  RETURN attrs;
}

STRING FUNCTION CompletePath(RECORD ARRAY attrlist, STRING tag, INTEGER myparent)
{
  WHILE(myparent!=0)
  {
    RECORD parentrec := SELECT * FROM attrlist WHERE attrlist.id = myparent;
    IF(NOT RecordExists(parentrec))
      THROW NEW Exception("Cannot resolve parent for WRD attribute #" || myparent);
    myparent := parentrec.parent;
    tag := parentrec.localtag || "." || tag;
  }
  RETURN tag;
}

RECORD ARRAY FUNCTION FixupChildren(RECORD ARRAY attrlist)
{
  RETURN SELECT *, tag := CompletePath(attrlist, thisattr.localtag, thisattr.parent) FROM attrlist AS thisattr;
}

PUBLIC RECORD ARRAY FUNCTION __SelectAttributes(RECORD typerec, STRING langcode)
{
  RECORD ARRAY attrs := FixupChildren(GetSubAttrs(typerec.id)) CONCAT GetMetaTypeAttributes(typerec, langcode);
  attrs := SELECT *
                , attributetypename := GetAttributeTypeNameByTypeId(attributetype)
             FROM attrs;

  IF(typerec.parenttype != 0)
  {
    /* In WRD inheritance of conflicting attributes is inverted from what's expected in OOP: non-base attributes from the parents override
       those in the children (so that children cannot write inconsistent data that break constraints in their parent, eg unique).

       There is one exception: WRD_TITLE on WRD_PERSON/WRD_ORGANIZATION has to replace the one from WRD_RELATION, as person has different rules for WRD_TITLE
    */
    RECORD ARRAY parentattributes := __SelectAttributes( (SELECT * FROM wrd.types WHERE id = typerec.parenttype ), langcode);

    //delete redefined base fields - on those the lowest level is always right (consider WRD_RELATION.WRD_TITLE)
    STRING ARRAY currentbaseattributes := SELECT AS STRING ARRAY tag FROM attrs WHERE base ORDER BY ToUppercase(tag);
    DELETE FROM parentattributes WHERE BinaryFind(currentbaseattributes, tag) != -1;

    STRING ARRAY parenttags := SELECT AS STRING ARRAY tag FROM parentattributes ORDER BY tag;

    //add non-redefined attributes from our parents
    UPDATE attrs SET ishiddenbyparent := TRUE WHERE BinaryFind(parenttags, tag) != -1;
    attrs := (SELECT *, isinherited := TRUE FROM parentattributes) CONCAT attrs;
  }

  RETURN attrs;
}

//Get the attributes that apply to every entity with this metatype
RECORD ARRAY FUNCTION GetMetaTypeAttributes(RECORD typerec, STRING langcode)
{
  RECORD lang := GetLangTexts(langcode);
  RECORD ARRAY builtin_attrs :=
    [ CELL[ ...baseattributedefaults
          , tag := "WRD_GUID"
          , localtag := "WRD_GUID"
          , attributetype := wrd_attributetype_free
          , cellname := "guid"
          , title := lang.attrlabels.wrd_guid
          , cellnames := [ "guid" ]
          , isgenerated := TRUE
          , isunique := TRUE
          , generatetag := "WRD_GUID"
          , maxlength := 36
          ]
    , CELL[ ...baseattributedefaults
          , tag := "WRD_ID"
          , localtag := "WRD_ID"
          , attributetype := wrd_attributetype_integer
          , cellname := "id"
          , title := lang.attrlabels.wrd_id
          , isreadonly := TRUE
          , isunique := TRUE
          ]
     , CELL[ ...baseattributedefaults
          , tag := "WRD_TYPE"
          , localtag := "WRD_TYPE"
          , attributetype := wrd_attributetype_integer
          , cellname := "type"
          , title := lang.attrlabels.wrd_type||" (id)"
          , isreadonly := TRUE
          ]
    , CELL[ ...baseattributedefaults
          , tag := "WRD_TAG"
          , localtag := "WRD_TAG"
          , attributetype := wrd_attributetype_free
          , cellname := "tag"
          , title := lang.attrlabels.wrd_tag
          , isunique := TRUE
          , maxlength := 256
          ]
    , CELL[ ...baseattributedefaults
          , tag := "WRD_CREATIONDATE"
          , localtag := "WRD_CREATIONDATE"
          , attributetype := wrd_attributetype_datetime
          , cellname := "creationdate"
          , title := lang.attrlabels.wrd_creationdate
          ]
    , CELL[ ...baseattributedefaults
          , tag := "WRD_LIMITDATE"
          , localtag := "WRD_LIMITDATE"
          , attributetype := wrd_attributetype_datetime
          , cellname := "limitdate"
          , title := lang.attrlabels.wrd_limitdate
          , isordered := FALSE
          ]
    , CELL[ ...baseattributedefaults
          , tag := "WRD_MODIFICATIONDATE"
          , localtag := "WRD_MODIFICATIONDATE"
          , attributetype := wrd_attributetype_datetime
          , cellname := "modificationdate"
          , title := lang.attrlabels.wrd_modificationdate
          , isordered := FALSE
          ]
        ];

  IF(typerec.metatype = wrd_metatype_domain) //Domain
  {
    INSERT CELL[ ...baseattributedefaults
               , tag           := "WRD_ORDERING"
               , localtag      := "WRD_ORDERING"
               , attributetype := wrd_attributetype_integer
               , cellname      := "ordering"
               , title         := lang.attrlabels.wrd_ordering
               ] INTO builtin_attrs AT END;
  }

  IF((typerec.metatype IN [ wrd_metatype_attachment, wrd_metatype_link ] AND typerec.requiretype_left != 0) OR (typerec.metatype = wrd_metatype_domain))
  {
    INSERT CELL[ ...baseattributedefaults
               , tag           := "WRD_LEFTENTITY"
               , localtag      := "WRD_LEFTENTITY"
               , base          := TRUE
               , attributetype := wrd_attributetype_domain
               , cellname      := "leftentity"
               , title         := lang.attrlabels.wrd_linkof
               , domain        := typerec.metatype = wrd_metatype_domain ? typerec.id : typerec.requiretype_left
               , isrequired    := typerec.metatype IN [3,2]
               ] INTO builtin_attrs AT END;
  }
  IF(typerec.metatype = wrd_metatype_link AND typerec.requiretype_right != 0)
  {
    INSERT CELL[ ...baseattributedefaults
               , tag           := "WRD_RIGHTENTITY"
               , localtag      := "WRD_RIGHTENTITY"
               , attributetype := wrd_attributetype_domain
               , cellname      := "rightentity"
               , title         := lang.attrlabels.wrd_linkto
               , domain        := typerec.requiretype_right
               , isrequired    := TRUE
               ] INTO builtin_attrs AT END;
  }

  IF(typerec.tag = "WRD_PERSON")
  {
    RECORD ARRAY all_person_tags :=
      [ [ tag := "WRD_GENDER",          attributetype := wrd_attributetype_domain, cellname := "gender",        title := lang.attrlabels.wrd_gender ]
      , [ tag := "WRD_SALUTE_FORMAL",   attributetype := wrd_attributetype_free,   isgenerated := TRUE,         title := lang.attrlabels.wrd_salute_formal,  isreadonly := TRUE, cellnames := [ "gender", "infix", "lastname", "titles" ] ]
      , [ tag := "WRD_ADDRESS_FORMAL",  attributetype := wrd_attributetype_free,   isgenerated := TRUE,         title := lang.attrlabels.wrd_address_formal, isreadonly := TRUE, cellnames := [ "gender", "initials", "infix", "lastname", "titles" ] ]
      , [ tag := "WRD_FULLNAME",        attributetype := wrd_attributetype_free,   isgenerated := TRUE,         title := lang.attrlabels.wrd_fullname,       isreadonly := TRUE, cellnames := [ "firstname", "firstnames", "infix", "initials", "lastname" ] ]
      , [ tag := "WRD_TITLES",          attributetype := wrd_attributetype_free,   cellname := "titles",        title := lang.attrlabels.wrd_titles,         maxlength := 256 ]
      , [ tag := "WRD_INITIALS",        attributetype := wrd_attributetype_free,   cellname := "initials",      title := lang.attrlabels.wrd_initials,       maxlength := 256 ]
      , [ tag := "WRD_FIRSTNAME",       attributetype := wrd_attributetype_free,   cellname := "firstname",     title := lang.attrlabels.wrd_firstname,      maxlength := 256 ]
      , [ tag := "WRD_FIRSTNAMES",      attributetype := wrd_attributetype_free,   cellname := "firstnames",    title := lang.attrlabels.wrd_firstnames,     maxlength := 256 ]
      , [ tag := "WRD_INFIX",           attributetype := wrd_attributetype_free,   cellname := "infix",         title := lang.attrlabels.wrd_infix,          maxlength := 256 ]
      , [ tag := "WRD_LASTNAME",        attributetype := wrd_attributetype_free,   cellname := "lastname",      title := lang.attrlabels.wrd_lastname,       maxlength := 256 ]
      , [ tag := "WRD_TITLES_SUFFIX",   attributetype := wrd_attributetype_free,   cellname := "titles_suffix", title := lang.attrlabels.wrd_titles_suffix,  maxlength := 256 ]
      , [ tag := "WRD_DATEOFBIRTH",     attributetype := wrd_attributetype_date,   cellname := "dateofbirth",   title := lang.attrlabels.wrd_dateofbirth ]
      , [ tag := "WRD_DATEOFDEATH",     attributetype := wrd_attributetype_date,   cellname := "dateofdeath",   title := lang.attrlabels.wrd_dateofdeath ]
      ];

    builtin_attrs := builtin_attrs CONCAT
                   SELECT ...baseattributedefaults
                        , *
                        , generatetag := CellExists(tags,'isreadonly') AND tags.isreadonly ? tag : ""
                     FROM all_person_tags AS tags;
  }

  IF(typerec.tag IN ["WRD_RELATION", "WRD_PERSON", "WRD_ORGANIZATION"])
  {
    STRING ARRAY cellnames;
    IF(typerec.tag != "WRD_ORGANIZATION")
      cellnames := [ "firstname", "firstnames", "infix", "initials", "lastname", "type" ];

    INSERT CELL[ ...baseattributedefaults
               , tag := "WRD_TITLE"
               , attributetype := 2
               , title := lang.attrlabels.wrd_title
               , isgenerated := TRUE
               , isreadonly := TRUE
               , cellnames := cellnames
               , maxlength := 256
                /* The generator doesn't really support WRD_ORGNAME but we need to fake it because elswhere ParseFilters redirects ORGNAME searches. Thats
                   a hack to fix for another day... but the one that blocks us from just dropping WRD_ORGNAME here */
               , generatetag := typerec.tag = "WRD_RELATION" ? "WRD_RELATION_TITLE" : typerec.tag = "WRD_PERSON" ? "WRD_FULLNAME" : "WRD_ORGNAME"
               ] INTO builtin_attrs AT END;
  }

  builtin_attrs := SELECT *
                        , localtag := tag
                     FROM builtin_attrs;
  RETURN builtin_attrs;
}
