<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::money.whlib";
LOADLIB "wh::dbase/dynquery.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/comparisons.whlib";

LOADLIB "mod::system/lib/cache.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/internal/support2.whlib";
LOADLIB "mod::wrd/lib/internal/addressfields.whlib";
LOADLIB "mod::wrd/lib/internal/whfs-service.whlib";
LOADLIB "mod::wrd/lib/internal/auth/support.whlib";
LOADLIB "mod::wrd/lib/internal/payments/support.whlib";


// ----------------------------------------------------------------------------
//
//   Helper variables
//

// Default entity record (all cells filled in on their default, for outer joins)
RECORD default_entity :=
  [ id := 0
  , wrd_schema := 0
  , guid := ""
  , tag := ""
  , creationdate := DEFAULT DATETIME
  , modificationdate := DEFAULT DATETIME
  , limitdate := DEFAULT DATETIME
  , type := 0
  , leftentity := 0
  , rightentity := 0
  , required := FALSE
  , isunique := FALSE
  , title := ""
  , initials := ""
  , firstname := ""
  , firstnames := ""
  , infix := ""
  , lastname := ""
  , titles := ""
  , gender := 0
  , dateofbirth := DEFAULT DATETIME
  , dateofdeath := DEFAULT DATETIME
  , ordering := 0
  , titles_suffix := ""
  ];

BOOLEAN FUNCTION IsWrapper(VARIANT val)
{
  RETURN TypeID(val)=TypeID(RECORD) AND CellExists(val,"__QUERYFIELD") AND TYPEID(val.__queryfield)=TYPEID(STRING) AND val.__queryfield = "";

}

PUBLIC RECORD FUNCTION GenerateBaseFields(RECORD ARRAY base_fields, RECORD inrow)
{
  RECORD addfields;
  FOREVERY (RECORD field FROM base_fields)
  {
    STRING rename := field.rename;
    VARIANT mycell;
    IF(field.isgenerated)
      mycell := field.generator(inrow);
    ELSE
      mycell := GetCell(inrow, field.cellname);

    FOREVERY(STRING sub FROM field.subselect)
      IF(CellExists(mycell,sub))
        mycell := GetCell(mycell, sub);
      ELSE
        mycell := "";

    addfields := CellInsert(addfields, rename, mycell);
  }
  RETURN addfields;
}

/** This is the base object for a WRD condition. It is used in this
    form by the simple conditions like free text conditions (FREE) and datetime
    conditions (DATETIME).
    Its members are not accessible; they are set through by adding them to
    a WRDMultiCondition object.

    Allowed types are: AND, OR, NOT, FREE, DOMAIN
    Domain is the same as free, but has an additional domain_tag set. The search value is
    the id of that domain, match_type must be '=' (ADDME: also allow 'IN').
*/
STATIC OBJECTTYPE WRDCondition
  < /// Type of this condition
    PUBLIC STRING type;

    /// Match type of this condition ( '=', '!=', '<', '>', '<=', '>=', "IN", "LIKE" )
    PUBLIC STRING match_type;

    /// Attribute for this condition
    PUBLIC RECORD attr;

    /// Value that must be matched (in cell 'data'); for FREE and DOMAIN conditions only
    PUBLIC RECORD value_holder;

    /// Is the condition case-sensitive? For FREE conditions only.
    PUBLIC BOOLEAN match_case;

    /// Ignore invalid allowedvalues?
    PUBLIC BOOLEAN ignoreallowedvalues;

    /// Domain tag (for serialization purposes only, not used further)
    PUBLIC STRING domain_tag;

    /// If not "", the value should be gotten from a parameter (name in this var)
    PUBLIC STRING from_parameter;

    /// Suffix for complex parameter types
    PUBLIC STRING from_suffix;

    /// Constructor, must be passed the type of this condition.
    PUBLIC MACRO NEW(STRING type)
    {
      this->type := type;
    }

    PUBLIC MACRO SerializeToXML(OBJECT wrdtype, OBJECT rootnode, BOOLEAN parent_is_root)
    {
      OBJECT node := rootnode->ownerdocument->CreateElementNS(query_ns, "filter");
      rootnode->AppendChild(node);

      node->SetAttribute("field", this->attr.tag);

      IF (this->match_type != "=")
        node->SetAttribute("match_type", ToUppercase(this->match_type));

      IF (IsCaseRelevant(this->attr) AND this->match_case != FALSE)
        node->SetAttribute("match_case", (this->match_case?'true':'false'));

      IF (this->from_parameter != "")
      {
        node->SetAttribute("parameter", this->from_parameter);
        IF (this->from_suffix != "")
          node->SetAttribute("parameter_suffix", this->from_suffix);
        node->SetAttribute("type", this->type);
      }
      ELSE
      {
        IF (this->type = 'FREE')
        {
          VARIANT value := this->value_holder.data;

          // Translate all WRD_ID's to the WRD_GUID of the entity
          IF ((this->attr.attributetype IN [ 1/*domain*/, 8/*domain-multi*/ ] OR
                this->attr.tag IN [ "WRD_ID", "WRD_LEFTENTITY","WRD_RIGHTENTITY"])
              AND this->attr.tag NOT IN [ "WRD_GENDER" ])
          {
            node->SetAttribute("translateids", "true");

            // Get the type of the referenced entity
            OBJECT type := this->attr.domain = 0 ? wrdtype : wrdtype->wrdschema->GetTypeById(this->attr.domain);

            IF (TypeID(value) = TypeID(INTEGER))
            {
              // Single WRD_ID: translate to guid
              OBJECT entity := type->GetEntity(value);
              IF (ObjectExists(entity))
                node->__SetHSValue(entity->GetField("WRD_GUID"));
              ELSE
                node->__SetHSValue("");
            }
            ELSE IF (TypeID(value) = TypeID(INTEGER ARRAY))
            {
              STRING ARRAY data;

              FOREVERY (INTEGER id FROM INTEGER ARRAY(value))
              {
                // Multiple WRD_IDs: translate to guids
                OBJECT entity := type->GetEntity(id);
                IF (ObjectExists(entity))
                  INSERT entity->GetField("WRD_GUID") INTO data AT END;
              }
              node->__SetHSValue(data);
            }
            ELSE
              THROW NEW Exception("Encountered incompatible value type:\n"||AnyToString(value, "tree"));

          }
          ELSE
            node->__SetHSValue(value);
        }
        ELSE IF (this->type = 'DOMAIN')
          node->SetAttribute("domainvaluetag", this->domain_tag);
        ELSE
          THROW NEW Exception("Not a free or domain condition");
      }
    }
  >;


/** A WRDMultiCondition contains a more complex condition. Multiple conditions can be
    added to this object. Allowed types for this condition are AND, NOT and OR.
    The interpretation of the children of this node varies on the type; for AND they must
    all evaluate to true for this condition to evaluate to TRUE, for OR there need only
    be one child that evaluates to TRUE for this to happen.
    For a NOT-condition, there may only be one child; this condition then evaluates to
    the opposite value its child evaluates to.
*/
STATIC OBJECTTYPE WRDMultiCondition EXTEND WRDCondition
  < /// List of children conditions of this condition
    PUBLIC OBJECT ARRAY children;

    /// List of children conditions of this condition after database optimalization
    PUBLIC OBJECT ARRAY opt_children;

    // Constructor (not to be used from the outside)
    PUBLIC MACRO NEW(STRING wrd_type)  // Create a new WRDQuerySource
    : WRDCondition(wrd_type)
    {
    }

    PUBLIC UPDATE MACRO SerializeToXML(OBJECT wrdtype, OBJECT rootnode, BOOLEAN parent_is_root)
    {
      IF (NOT parent_is_root OR this->type != "AND")
      {
        OBJECT node := rootnode->ownerdocument->CreateElementNS(query_ns, "filter");
        rootnode->AppendChild(node);

        node->SetAttribute("type", ToLowercase(this->type));

        FOREVERY(OBJECT child FROM this->children)
          child->SerializeToXML(wrdtype, node, FALSE);
      }
      ELSE
      {
        FOREVERY(OBJECT child FROM this->children)
          child->SerializeToXML(wrdtype, rootnode, FALSE);
      }
    }
  >;


/** A WRDQuerySource selects results from a single WRD entity type, on which
    conditions can be set.
    This object functions as a AND-condition (is a WRDMultiCondition), which can
    be used to add conditions.
*/
STATIC OBJECTTYPE WRDQuerySource EXTEND WRDMultiCondition
< /// Type of the entities selected by this query
  PUBLIC OBJECT wrd_type;

  /// Limit requested types.
  PUBLIC INTEGER ARRAY typefilter;

  /// Name of this source
  PUBLIC STRING name;

  /// Partition of this source
  PUBLIC OBJECT partition;

  /** History mode (if "all", return ALL results else use [ when_start, when_limit > range)
      Valid values: "all", "now", "at", "range"
  */
  PUBLIC STRING history_mode;

  /// Return only entities that were valid at or after 'when_start' (ignored when history_mode = "all")
  PUBLIC DATETIME when_start;

  /// Return only entities that were valid before 'when_limit' (ignored when all_history_mode = "all")
  PUBLIC DATETIME when_limit;

  /** List of attributes that must be returned
      @cell name Name of the field to return the attribute in
      @cell attr The attribute that must be returned
      @cell subselect Cell to retrieve from within the value (only valid for types ADDRESS, FILE, BLOB) (optional)
  */
  PUBLIC RECORD ARRAY selected_attributes;

  /** Map of the attributes to return
      @cell name Name of the field to return the attribute in
      @cell attr The attribute that must be returned. Empty for submaps
      @cell submap Subreturn map for returnable records
  */
  PUBLIC RECORD ARRAY return_map;

  /** The number of submaps */
  PUBLIC INTEGER __submaps;

  OBJECT pvt_whfsmapper;

  /** Constructor for a WRDQuerySource object; pass the type of entity to select.
      @param wrd_type WRD type object
      @param whfsmapper WHFS mapper
  */
  PUBLIC MACRO NEW(OBJECT wrd_type, OBJECT whfsmapper)
  : WRDMulticondition("AND")
  {
    this->wrd_type := wrd_type;
    this->pvt_whfsmapper := whfsmapper;
  }

  RECORD FUNCTION ExpandWildcards(STRING ARRAY masks)
  {
    RECORD outputcolumns;
    FOREVERY (STRING mask FROM masks)
    {
      IF (mask LIKE "*.*" OR mask LIKE "*#*")
        THROW NEW Exception("Columns with . or # are not allowed in a simple outputcolumns string array");

      IF(SearchSubstring(mask,'*') != -1 OR SearchSubstring(mask,'?') != -1) //wildcard
      {
        BOOLEAN match;
        FOREVERY(RECORD attr FROM this->wrd_type->ListAttributes(0))
          IF(ToUppercase(attr.tag) LIKE ToUppercase(mask))
          {
            outputcolumns := CellInsert(outputcolumns, attr.tag, attr.tag);
            match := TRUE;
          }

        IF(NOT match)
          THROW NEW Exception("The column '" || mask || "' did not match any attribute");
      }
      ELSE
      {
        outputcolumns := CellInsert(outputcolumns, mask, mask);
      }
    }
    RETURN outputcolumns;
  }

  //Split selected attributes into fields and basefields and setup accessors for non basefields
  PUBLIC RECORD FUNCTION CreateAccessors()
  {
    IF (LENGTH(this->selected_attributes) = 0)
      RETURN DEFAULT RECORD;

    RETURN GetAccessors(this->wrd_type, this->selected_attributes, DEFAULT OBJECT, this->pvt_whfsmapper);
  }

  PUBLIC RECORD ARRAY FUNCTION RecurseGetOutputColumns(VARIANT in_outputcolumns)
  {
    RECORD ARRAY myreturnmap;
    STRING nameprefix := this->__submaps = 0 ? "" : this->__submaps || "#";

    // if outputcolumns is a string array, rewrite to a proper record
    RECORD outputcolumns;
    IF (TypeID(in_outputcolumns) = TypeID(STRING ARRAY))
      outputcolumns := this->ExpandWildcards(in_outputcolumns);
    ELSE IF (TypeID(in_outputcolumns) = TypeID(RECORD))
      outputcolumns := in_outputcolumns;
    ELSE
      THROW NEW Exception("Unexpected type '" || GetTypeName(TypeID(in_outputcolumns)) || "' for outputcolumns");

    FOREVERY (RECORD outputcolumn FROM UnpackRecord(outputcolumns))
    {
      RECORD wrapper;
      STRING selected_attribute;
      IF(IsWrapper(outputcolumn.value))
      {
        wrapper := outputcolumn.value;
        selected_attribute := wrapper.fieldname;
      }
      ELSE IF(TypeID(outputcolumn.value)=TypeID(RECORD) OR TypeID(outputcolumn.value)=TypeID(STRING ARRAY) )
      {
        this->__submaps := this->__submaps + 1;
        INSERT [ name := outputcolumn.name
               , attr := ""
               , submap := this->RecurseGetOutputColumns(outputcolumn.value)
               ]
               INTO myreturnmap AT END;
        CONTINUE;
      }
      ELSE
      {
        selected_attribute := outputcolumn.value;
      }

      STRING ARRAY subselect;
      STRING attrtag;
      STRING metaselect;

      FOREVERY(STRING tok FROM Tokenize(selected_attribute, "."))
      {
        IF(#tok=0)
          attrtag := tok;
        ELSE
          INSERT tok INTO subselect AT END;
      }

      INTEGER hashpos := Searchsubstring(selected_attribute, "#");
      IF (hashpos != -1)
      {
        IF (Length(subselect)>0)
          THROW NEW Exception("Cannot use the '#' metadata selector together with a subselection");

        attrtag := LEFT(selected_attribute, hashpos);
        metaselect := ToUppercase(SubString(selected_attribute, hashpos + 1));

        IF (metaselect NOT IN [ "ORDERING" ])
          THROW NEW Exception("Field '"||SubString(selected_attribute, hashpos + 1)||"' is not a valid attribute metadata field");
      }

      // Retrieve the attribute
      RECORD attr := SELECT * FROM this->wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase(attrtag);
      IF (NOT RecordExists(attr))
      {
        STRING bestmatch := GetBestMatch(attrtag, SELECT AS STRING ARRAY tag FROM this->wrd_type->__final_attrs);
        THROW NEW Exception(`Cannot find attribute '${attrtag}' in wrd type '${this->wrd_type->tag}'${bestmatch = "" ? "" : `, did you mean '${bestmatch}'`}`);
      }

      IF (Length(subselect)>0 AND attr.attributetype NOT IN [ 3/*address*/, 9/*image*/, 10/*file*/, 13/*array*/ ])
        THROW NEW Exception("Subselection is only possible on attributes of type address, image, file and array"); //FIXME with deeper subselections, also validate the subfields

      IF (hashpos != -1 AND attr.base)
        THROW NEW Exception("Cannot use the '#' metadata selector on base attributes");

      //IF (CellExists(outputcols, outputcolumn.name))
      //  THROW NEW Exception("A column with the name '" || outputcolumn.name || "' has been selected twice");

      //outputcols := CellInsert(outputcols, outputcolumn.name, obj->name);

      // Insert __metadatafield into attr when needed, so we can see when we need the metadata attr
      IF (hashpos != -1)
        INSERT CELL __metadatafield := metaselect INTO attr;

      INSERT [ name := nameprefix || outputcolumn.name
             , attr := attr
             , subselect := subselect
             , metaselect := metaselect
             , sourcename := this->name
             , wrapper := wrapper
             ] INTO this->selected_attributes AT END;

      INSERT [ name := outputcolumn.name
             , attr := nameprefix || outputcolumn.name
             , submap := DEFAULT RECORD ARRAY
             ]
             INTO myreturnmap AT END;
    }
    RETURN myreturnmap;
  }
>;

/** A partition is a group of sources that have links of type 'default' or 'cross' between them.
*/
 PUBLIC STATIC OBJECTTYPE Partition
  < /// Group id, for partitioning
    PUBLIC INTEGER partition_id;

    /// Ordering id, for ordering the partitions
    PUBLIC INTEGER ordering;

    /// List of sources in this partition, type: WRDQuerySource
    PUBLIC OBJECT ARRAY sources;

    /// List of links between the sources in this partition
    PUBLIC RECORD ARRAY internal_links;

    /// List all links that will be evaluated after this partition is retrieved.
    PUBLIC RECORD ARRAY passive_external_links;

    /// List links that must be evaluated when this partition is retrieved
    PUBLIC RECORD ARRAY active_external_links;

    /// List of partitions this partition is dependent on, type: Partition
    PUBLIC OBJECT ARRAY dependencies;

    /// Dynamic query for this partition
    PUBLIC OBJECT dbquery;

    /// Retrieval mode (can be "" (iff ordering == 1), "missing", "optional"
    PUBLIC STRING mode;

    /// Whether distincting entities is necessary (due to a MENTIONS filter)
    PUBLIC BOOLEAN require_distincting;
  >;


/** A WRDQuery selects results from multiple single queries together, based
    on links and attribute constraints.
*/
PUBLIC STATIC OBJECTTYPE WRDQuery
  < /// Schema for this query
    PUBLIC OBJECT wrd_schema;

    /// List of single queries (type: WRDQuerySource)
    PUBLIC OBJECT ARRAY singles;

    /// List of single queries (type: Partition)
    PUBLIC OBJECT ARRAY partitions;

    /** List of links ( left, right, attr_tag, type )
        @cell jointype
        @cell link_left

    */
    PUBLIC RECORD ARRAY links;

    /// Time at which the query is executed
    PUBLIC DATETIME current_time;

    /// Maximum number of results that may be returned, -1 for no limit.
    PUBLIC INTEGER resultlimit;

    /// The list of parameters to this query
    PUBLIC RECORD parameters;

    OBJECT pvt_whfsmapper;

    // Initialize the multiquery with a single query
    // ----------------------------------------------------------------------------
    //
    //   WRDQuery
    //

    /** @param wrd_schema WRD schema
        @param whfsmapper WHFS mapper
    */
    PUBLIC MACRO NEW(OBJECT wrd_schema, OBJECT whfsmapper)
    {
      this->wrd_schema := wrd_schema;
      this->pvt_whfsmapper := whfsmapper;
      this->resultlimit := -1;
    }

    /** Initializes the query with the execution time (for historymode 'now')
    */
    PUBLIC MACRO InitializeExecution(DATETIME execution_time)
    {
      this->current_time := execution_time;

      FOREVERY (OBJECT single FROM this->singles)
      {
        IF (single->history_mode = "now")
        {
          // See the comment in MakeWRDQuery for the rationale for choosing this range
          single->when_start := execution_time;
          single->when_limit := AddTimeToDate(1, execution_time);
        }
      }
    }

/*  FIXME: PropagateParameters doesn't exist; what was this function supposed to do?
           Should it be SetConditionsOptChildrenAndParams?

    PUBLIC MACRO SetParameters(RECORD params)
    {
      IF (NOT RecordExists(this->parameters))
        RETURN;
      FOREVERY (RECORD p FROM UnpackRecord(this->parameters))
        IF (NOT CellExists(params, p.name))
          THROW NEW Exception("No value has been specified for parameter '" || p.name || "'");

      FOREVERY (OBJECT single FROM this->singles)
        this->PropagateParameters(single, params);
    }
*/

    /** Calculates the partitions of single queries that are strongly linked together
        (via 'normal' links or 'cross' links)
    */
    PUBLIC MACRO PartitionQueries()
    {
      // Make partitions for every source
      FOREVERY (OBJECT single FROM this->singles)
      {
        single->partition := NEW Partition;
        single->partition->partition_id := #single + 1;
      }

      // Merge partitions base on 'link' and 'cross' links. ADDME: this can probably be done faster/more efficient
      WHILE (TRUE)
      {
        BOOLEAN any_change := FALSE;
        FOREVERY (RECORD link FROM this->links)
        {
          IF (link.jointype IN [ "cross", "default" ])
          {
            INTEGER left_partition := link.link_left->partition->partition_id;
            INTEGER right_partition := link.link_right->partition->partition_id;
            IF (left_partition < right_partition)
            {
              any_change := TRUE;
              link.link_right->partition := link.link_left->partition;
            }
            ELSE IF (left_partition > right_partition)
            {
              any_change := TRUE;
              link.link_left->partition := link.link_right->partition;
            }
          }
        }
        IF (NOT any_change)
          BREAK;
      }

      // Gather all partitions and set their sources
      OBJECT ARRAY partitions;
      FOREVERY (OBJECT single FROM this->singles)
      {
        INSERT single INTO single->partition->sources AT END;
        IF (single->partition NOT IN partitions)
          INSERT single->partition INTO partitions AT END;
      }
      this->partitions := partitions;
    }

    /** Distributes all links into the differnt link lists (internal, passive_external,
        active_external). Also sets dependencies for partitions (a partition that has
        a missing or optional link pointing towards it is dependent on the other
        partition in the link.
    */
    PUBLIC MACRO DistributeLinksAndSetDependencies()
    {
      // Set partition dependencies and distribute the links
      FOREVERY (RECORD link FROM this->links)
      {
        // A default or cross link links two tables to the same partition, and is added to that partitions' internal links
        // A xxx-missing or xxx-optional query is added to both sides.
        // For right-optional for example, the link is added to the left side in passive_external_links and
        // to the right side in active_external_links.

        SWITCH (link.jointype)
        {
          CASE "left-missing", "left-optional"
            {
              IF (link.link_right->partition = link.link_left->partition)
                THROW NEW Exception("It is not allowed to have a xxx-missing or xxx-optional link between sources that are already linked by normal or cross links");
              INSERT link.link_right->partition INTO link.link_left->partition->dependencies AT END;

              INSERT link INTO link.link_left->partition->active_external_links AT END;
              INSERT link INTO link.link_right->partition->passive_external_links AT END;

              STRING mode := link.jointype = "left-optional" ? "optional" : "missing";
              IF (link.link_left->partition->mode != "" AND link.link_left->partition->mode != mode)
                THROW NEW Exception("Cannot mix optional and missing link modes on the same set of normally linked tables");
              link.link_left->partition->mode := mode;
            }
          CASE "right-missing", "right-optional"
            {
              IF (link.link_right->partition = link.link_left->partition)
                THROW NEW Exception("It is not allowed to have a xxx-missing or xxx-optional link between sources that are already linked by normal or cross links");
              INSERT link.link_left->partition INTO link.link_right->partition->dependencies AT END;

              INSERT link INTO link.link_right->partition->active_external_links AT END;
              INSERT link INTO link.link_left->partition->passive_external_links AT END;

              STRING mode := link.jointype = "right-optional" ? "optional" : "missing";
              IF (link.link_right->partition->mode != "" AND link.link_right->partition->mode != mode)
                THROW NEW Exception("Cannot mix optional and missing link modes on the same set of normally linked tables");
              link.link_right->partition->mode := mode;
            }
          DEFAULT
            {
              IF (link.link_right->partition != link.link_left->partition)
                ABORT("Internal error: found a join of type '" || link.jointype || "' that links to two different partitions");

              INSERT link INTO link.link_right->partition->internal_links AT END;
            }
        }
      }
    }

    /** Calculates the orderi in which the partitions must be evaluated, based on the
        dependencies set by @a DistributeLinksAndSetDependencies
    */
    PUBLIC MACRO OrderPartitions()
    {
      OBJECT ARRAY ordered_objs;

      // Get all partitions with no dependencies. We want it to be only one.
      FOREVERY (OBJECT partition FROM this->partitions)
        IF (LENGTH(partition->dependencies) = 0)
          INSERT partition INTO ordered_objs AT END;

      IF (LENGTH(ordered_objs) = 0)
        THROW NEW Exception("Found incompatible join types: two left-XXX and right-XXX join types are forming a full outer join");
      IF (LENGTH(ordered_objs) > 1)
        THROW NEW Exception("Found two tables '" || ordered_objs[0]->sources[0]->name || "' and '" || ordered_objs[1]->sources[0]->name || "' that have no (indirect) relation. Use a cross join to explicitly add a relation.");

      // Now keep adding all partition whose dependencies are already in ordered_objs, until we got them all.
      ordered_objs[0]->ordering := 1;
      INTEGER partition_count := LENGTH(this->partitions);
      WHILE (TRUE)
      {
        BOOLEAN any_change := FALSE;

        FOREVERY (OBJECT partition FROM this->partitions)
          IF (partition->ordering = 0) // Only unprocessed partitions!
          {
            // Check if all dependencies have already been resolved
            BOOLEAN all_resolved := TRUE;
            FOREVERY (OBJECT dependency FROM partition->dependencies)
              IF (dependency NOT IN ordered_objs)
              {
                all_resolved := FALSE;
                BREAK;
              }
            // Al resolved: this may be the next partition
            IF (all_resolved)
            {
              INSERT partition INTO ordered_objs AT END;
              partition->ordering := LENGTH(ordered_objs);
              any_change := TRUE;
            }
          }

        IF (LENGTH(ordered_objs) = partition_count)
          BREAK;
        ELSE IF (NOT any_change)
          THROW NEW Exception("Found incompatible join types: two left-XXX and right-XXX join types are forming a full outer join");
      }

      // Put back the partitions, now ordered
      this->partitions := ordered_objs;
    }

    /** Generates names for link columns needed when adding a new partition (calculated
        from the active_external links)
    */
    PUBLIC STRING ARRAY FUNCTION GenerateLinkNames(OBJECT new_partition)
    {
      STRING ARRAY results;
      FOREVERY (RECORD link FROM new_partition->active_external_links)
      {
        STRING name := "LINK";
        IF (#link != 0)
          name := name || #link;
        INSERT name INTO results AT END;
      }
      RETURN results;
    }

    /** Sets the link columns that are needed to link a new partition to the current
        retrieved partitions
    */
    PUBLIC RECORD ARRAY FUNCTION SetLinksInCurrentRows(RECORD ARRAY current_rows, OBJECT new_partition, STRING ARRAY link_names)
    {
    //  Print ("Setting links in current rows for join of partition " || new_partition->partition_id || "\n");
    //  PrintRecordArrayTo(0, current_rows, "boxed");

      IF (LENGTH(new_partition->active_external_links) = 0)
        RETURN current_rows;

      IF (link_names[0] != "LINK" OR LENGTH(link_names) != LENGTH(new_partition->active_external_links))
        ABORT("Internal error: link_names is not compatible (at original rows)");

      FOREVERY (RECORD link FROM new_partition->active_external_links)
      {
        STRING link_name := link_names[#link];
        STRING left_name := link.link_left->name;
        STRING right_name := link.link_right->name;
        RECORD attr := link.attr;

    /*    PRINT("Processing link: " || link_name || ", left: " || left_name || ", right: " || right_name);
        PRINT(", mode: " || link.jointype || ", attr: " || attr.tag || "\n");
        PRINT("Left partition: " || link.link_left->partition->partition_id || "\n");
        PRINT("Right partition: " || link.link_right->partition->partition_id || "\n");
        PRINT("Partition that is to be added: " || new_partition->partition_id || "\n");*/

        IF (link.link_right->partition = new_partition)
        {
          // Left has already been retrieved

          // Both queries are non-optional
          IF (attr.base) // Base field
          {
            FOREVERY (RECORD row FROM current_rows)
              current_rows[#row] := CellInsert(row, link_name, GetCell(GetCell(row, left_name), attr.cellname));
          }
          ELSE
          {
            FOREVERY (RECORD row FROM current_rows)
              current_rows[#row] := CellInsert(row, link_name, GetCell(row, left_name).id);
          }
        }
        ELSE
        {
          FOREVERY (RECORD row FROM current_rows)
            current_rows[#row] := CellInsert(row, link_name, GetCell(row, right_name).id);
        }
      }
      RETURN SELECT * FROM current_rows ORDER BY link;
    }

    /** Builds the DB query for a specific partition.
        @param current_rows Current results (of all previous ordered partitions,
            with links columns set by @a SetLinksInCurrentRows
        @param params Passed parameters
    */
    PUBLIC MACRO ConstructDBQuery(OBJECT partition, RECORD ARRAY current_rows, RECORD params)
    {
      INTEGER transaction := GetBindingFromTable(wrd.types).transaction;

      OBJECT query := NEW DynamicQuery;
      partition->dbquery := query;

      BOOLEAN all_handled := TRUE;
      FOREVERY (OBJECT single FROM partition->sources)
      {
        // Add the base table for the query
        query->AddDeclaredTable(single->name, wrd.entities, ["id"]);
        query->AddConstraint(single->name || ".type", "IN", single->typefilter);

        IF (single->history_mode = "all")
        {
          query->AddConstraint(single->name || ".creationdate", "<", MAX_DATETIME); //filter out temporaries
        }
        ELSE IF (single->history_mode != "__getfields") //__getfields is used by getentityfield(s) to be able to select temporaries too
        {
          query->AddConstraint(single->name || ".creationdate", "<", single->when_limit);
          query->AddConstraint(single->name || ".limitdate", ">", single->when_start);
        }

        RECORD ARRAY sel_attrs;
        FOREVERY (RECORD selattr FROM single->selected_attributes)
        {
          IF (selattr.attr.base)
          {
            IF (selattr.attr.cellname != "")
              query->RequestAdditionalColumns(single->name, [ STRING(selattr.attr.cellname) ]);
            ELSE IF (selattr.attr.isgenerated)
              query->RequestAdditionalColumns(single->name, selattr.attr.cellnames);
          }
        }
    //    PRINT("Adding filters for " || single->name || ": " || length(single->children) || "\n");

        this->SetConditionsOptChildrenAndParams(single->wrd_type, single, params);
        BOOLEAN this_handled := this->TryAddAllConditionsToQuery(partition, query, single->name, single, single->wrd_type);
        all_handled := all_handled AND this_handled;
      }

      // If this is the only partition and every condition is being sent to the DB, the DB may also handle the limit.
      IF (this->resultlimit >= 0 AND all_handled AND LENGTH(this->partitions) = 1)
        query->SetLimit(this->resultlimit);

      // Add every internal link (links between sources within this partition)
      FOREVERY (RECORD link FROM partition->internal_links)
      {
        IF (link.jointype = "cross") // Ignore cross links
          CONTINUE;

        // Both queries are non-optional
        IF (link.attr.base) // Base field
        {
          query->AddJoin(link.link_left->name || "." || link.attr.cellname, "=", link.link_right->name || ".id");
        }
        ELSE
        {
          STRING setting_table := "LINK_SETTING_INT_" || partition->partition_id || "_" || #link;

          query->AddDeclaredTable(setting_table, wrd.entity_settings, DEFAULT STRING ARRAY);
          query->AddJoin(link.link_left->name || ".id", "=", setting_table || ".entity");
          query->AddJoin(setting_table || ".setting", "=", link.link_right->name || ".id");
          query->AddConstraint(setting_table || ".attribute", "=", link.attr.id);
        }
      }

      // Add fields that are needed for partitions that are added later (with joins of other partitions)
      FOREVERY (RECORD link FROM partition->passive_external_links)
      {
        // Only needed to retrieve a column for a link when it links a base field from this partition to another partition
        IF (link.link_left->partition = partition AND link.attr.base)
          query->RequestAdditionalColumns(link.link_left->name, [ STRING(link.attr.cellname) ]);
        // All other links link to an entity.id, which is auto-retrieved.
      }

      STRING ARRAY link_names;

    //  PrintRecordArrayto(0, partition->active_external_links, "boxed");

      // Add fields that are needed for outer joins we are going to perform when this partition is joined to existing results
      FOREVERY (RECORD link FROM partition->active_external_links)
      {
        STRING link_name := "LINK";
        IF (#link != 0)
          link_name := link_name || #link;
        INSERT link_name INTO link_names AT END;

        STRING left_name := link.link_left->name;
        STRING right_name := link.link_right->name;
        RECORD attr := link.attr;

        STRING setting_table := "LINK_SETTING_EXT_" || partition->partition_id || "_" || #link;

        INTEGER ARRAY links := SELECT AS INTEGER ARRAY DISTINCT GetCell(rows, link_name) FROM current_rows AS rows ORDER BY GetCell(rows, link_name);

        IF (link.link_right->partition = partition)
        {
          // Left has already been retrieved

          IF (attr.base) // Base field
          {
            query->AddConstraint(right_name || ".id", "IN", links);
          }
          ELSE
          {
            query->AddDeclaredTable(setting_table, wrd.entity_settings, DEFAULT STRING ARRAY);
            query->AddConstraint(setting_table || ".entity", "IN", links);
            query->AddJoin(setting_table || ".setting", "=", right_name || ".id");
            query->AddConstraint(setting_table || ".attribute", "=", attr.id);
          }
        }
        ELSE
        {
          // Right has already been retrieved

          IF (attr.base) // Base field
          {
            query->AddConstraint(left_name || "." || attr.cellname, "IN", links);
          }
          ELSE
          {
            query->AddDeclaredTable(setting_table, wrd.entity_settings, DEFAULT STRING ARRAY);
            query->AddJoin(setting_table || ".entity", "=", left_name || ".id");
            query->AddConstraint(setting_table || ".setting", "IN", links);
            query->AddConstraint(setting_table || ".attribute", "=", attr.id);
          }
        }
      }

    //  PRINT("Constructed query for partition " || partition->partition_id || ", ordering: " || partition->ordering || ":\n");
    //  PRINT(query->Dump());
    }

    /** Sets all opt_children members of all used conditions to the contents of the chilren
        members. Also set all parameter values
    */
    PRIVATE MACRO SetConditionsOptChildrenAndParams(OBJECT wrdtype, OBJECT condition, RECORD params)
    {
    //  PRINTRECORDTO(0, params, "boxed");
      IF (condition->type IN [ "OR", "AND", "NOT" ])
      {
        condition->opt_children := condition->children;
        FOREVERY (OBJECT cond FROM condition->opt_children)
          this->SetConditionsOptChildrenAndParams(wrdtype, cond, params);
      }
      ELSE
      {
        STRING name := condition->from_parameter;
        IF (name != "")
        {
          IF (NOT CellExists(params, name))
            THROW NEW Exception("Parameter '" || name || "' has not been specified.");
          RECORD data := [ data := GetCell(params, name) ];
          IF (condition->from_suffix != "")
            data := [ data := GetCell(data.data, condition->from_suffix) ];

          condition->value_holder := data;
          ConvertDomainValuesInFilter(condition, wrdtype);
        }
      }
    }

    /** Optimize conditions when the values are known
    */
    OBJECT ARRAY FUNCTION OptimizeConditions(OBJECT ARRAY conditions)
    {
      RETURN this->OptimizeDatetimeRangeConditions(conditions);
    }

    /** Optimize datetime conditions forming a range into a range query
    */
    OBJECT ARRAY FUNCTION OptimizeDatetimeRangeConditions(OBJECT ARRAY conditions)
    {
      OBJECT ARRAY result;

      OBJECT last_lowerbound;
      FOREVERY (OBJECT condition FROM conditions)
      {
        IF (NOT RecordExists(condition->attr) OR condition->attr.attributetype NOT IN [ 6, 12 ]) // date, datetime
        {
          INSERT condition INTO result AT END;
          CONTINUE;
        }

        IF (condition->match_type IN [ ">=", ">" ])
          last_lowerbound := condition;
        ELSE IF (condition->match_type IN [ "<=", "<" ] AND ObjectExists(last_lowerbound))
        {
          IF (condition->attr.tag = last_lowerbound->attr.tag)
          {
            // Adjust boundaries by 1 ms when condition is "<" or ">", but only if it is safe to do so
            BOOLEAN replace_lowerbound := last_lowerbound->match_type = ">=" OR last_lowerbound->value_holder.data != MAX_DATETIME;
            DATETIME lowerbound := last_lowerbound->match_type = ">=" OR last_lowerbound->value_holder.data = MAX_DATETIME
                ? last_lowerbound->value_holder.data
                : AddTimeToDate(1, last_lowerbound->value_holder.data);

            BOOLEAN replace_upperbound := condition->match_type = "<=" OR condition->value_holder.data != DEFAULT DATETIME;
            DATETIME upperbound := condition->match_type = "<=" OR condition->value_holder.data = DEFAULT DATETIME
                ? condition->value_holder.data
                : AddTimeToDate(-1, condition->value_holder.data);

            // If the resulting lowerbound is largen than the upperbound, set them equal and let the upperbound condition weed them out
            IF (lowerbound > upperbound)
            {
              upperbound := lowerbound;
              replace_upperbound := FALSE;
            }

            OBJECT opt := NEW WRDCondition("FREE");
            opt->match_case := TRUE;
            opt->match_type := "__INRANGE";
            opt->attr := condition->attr;
            opt->value_holder := [ data := DATETIME[ lowerbound, upperbound ] ];

            // If replacing the lowerbound, remove it from the list of conditions
            IF (replace_lowerbound)
              DELETE FROM result AT SearchElement(result, last_lowerbound);
            IF (NOT replace_upperbound)
              INSERT condition INTO result AT END;
            INSERT opt INTO result AT END;

            // Only try to replace a lowerbound once
            last_lowerbound := DEFAULT OBJECT;
            CONTINUE;
          }
        }

        INSERT condition INTO result AT END;
      }
      RETURN result;
    }

    /** Tries to add all conditions to the DB query
        @return Whether the condition was 100% added (and can be eliminated)
    */
    PRIVATE BOOLEAN FUNCTION TryAddAllConditionsToQuery(OBJECT partition, OBJECT dbquery, STRING query_name, OBJECT condition, OBJECT wrd_type)
    {
      SWITCH (condition->type)
      {
      CASE "OR"     { condition->opt_children := condition->children; RETURN FALSE; }
      CASE "NOT"    { condition->opt_children := condition->children; RETURN FALSE; } // FIXME: Implement.
      CASE "AND"
        {
          OBJECT ARRAY unhandled;

          // Optimize date range queries
          OBJECT ARRAY conditions := this->OptimizeConditions(condition->children);

          FOREVERY (OBJECT cond FROM conditions)
          {
            IF (NOT this->TryAddAllConditionsToQuery(partition, dbquery, query_name, cond, wrd_type))
              INSERT cond INTO unhandled AT END;
          }

          condition->opt_children := unhandled;
          RETURN LENGTH(unhandled) = 0;
        }
      CASE "FREE", "DOMAIN"
        {
          BOOLEAN success := this->TryAddFreeConditionToQuery(partition, dbquery, query_name, condition, wrd_type);
          RETURN success;
        }
      }
      RETURN FALSE;
    }

    /** Tries to add a free (or domain) condition to the DB query
        @return Whether the condition was 100% added (and can be eliminated)
    */
    PRIVATE BOOLEAN FUNCTION TryAddFreeConditionToQuery(OBJECT partition, OBJECT dbquery, STRING query_name, OBJECT condition, OBJECT wrd_type)
    {
      IF (condition->attr.base) // Base field
      {
        // Can't directly search generated fields, also
        IF (condition->attr.isgenerated)
        {
          IF (NOT CellExists(condition->attr, "DECODER") OR condition->attr.decoder = DEFAULT MACRO PTR)
            RETURN FALSE;

          STRING ARRAY user_values;
          IF (condition->match_type = "IN")
            user_values := STRING ARRAY(condition->value_holder.data);
          ELSE
            user_values := [ STRING(condition->value_holder.data) ];

          // Special case for empty IN: add an constraint that's impossible to satify (but quick to verify with DB indices)
          IF (LENGTH(user_values) = 0)
          {
            dbquery->AddConstraint(query_name || ".id", "=", -1);
            dbquery->RequestAdditionalColumns(query_name, condition->attr.cellnames);
            RETURN FALSE; // After-filter just in case
          }

          STRING ARRAY search_values; // For now, only GUID is handled here, that is a string. DB code doesn't like VARIANT ARRAYs
          BOOLEAN match_case;
          BOOLEAN need_afterfiltering;
          STRING cellname;

          // Decode all individual values
          FOREVERY (VARIANT val FROM user_values)
          {
            RECORD decoded := condition->attr.decoder(val, condition->match_case);
            IF (NOT decoded.valid)
              RETURN FALSE;

            // Process search atributes
            need_afterfiltering := need_afterfiltering OR decoded.need_afterfiltering;
            IF (#val = 0)
            {
              match_case := decoded.match_case;
              cellname := decoded.cellname;
            }
            ELSE IF (match_case != decoded.match_case OR cellname != decoded.cellname)
            {
              // Safe exit if something differs per decoded value
              RETURN FALSE;
            }

            INSERT decoded.value INTO search_values AT END;
          }

          VARIANT search_value := search_values;
          IF (condition->match_type != "IN")
            search_value := search_value[0];
          ELSE IF (NOT match_case) // No IN for case insensitive queries
            RETURN FALSE;

          IF (match_case)
            dbquery->AddConstraint(query_name || "." || cellname, condition->match_type, search_value);
          ELSE
            dbquery->AddUppercaseConstraint(query_name || "." || cellname, condition->match_type, search_value);

          IF (need_afterfiltering)
          {
            dbquery->RequestAdditionalColumns(query_name, [ cellname ]);
            RETURN FALSE;
          }

          RETURN TRUE;
        }

        // can't handle IN for case insensitive constraints
        IF (NOT condition->match_case AND condition->match_type = "IN")
          RETURN FALSE;

        IF (TypeId(condition->value_holder.data) = TypeId(STRING) AND LENGTH(condition->value_holder.data) >= 4096) // DB can't handle 4096 or more chars in a query
          RETURN FALSE;

        // Base fields are always present, direct condition can be added
        IF (condition->match_type = "__INRANGE")
        {
          dbquery->AddConstraint(query_name || "." || condition->attr.cellname, ">=", condition->value_holder.data[0]);
          dbquery->AddConstraint(query_name || "." || condition->attr.cellname, "<=", condition->value_holder.data[1]);
        }
        ELSE IF (condition->match_case)
          dbquery->AddConstraint(query_name || "." || condition->attr.cellname, condition->match_type, condition->value_holder.data);
        ELSE
          dbquery->AddUppercaseConstraint(query_name || "." || condition->attr.cellname, condition->match_type, condition->value_holder.data);
      }
      ELSE
      {
        OBJECT accessor := GetAccessorForAttributeType(condition->attr, wrd_type, CELL[ linkgetter := DEFAULT OBJECT
                                                                                      , whfsmapper := this->pvt_whfsmapper
                                                                                      , wrapper := DEFAULT RECORD
                                                                                      ]);
        IF (NOT accessor->CheckUserInput(condition->value_holder.data, condition))
          THROW NEW Exception("This is not a valid value for this attribute '"||condition->attr.tag||"' of type " || GetAttributeTypeNameByTypeId(condition->attr.attributetype) || ": (match type '"||condition->match_type||"', data type: " || GetTypeName(TypeID(condition->value_holder.data)) || ")\n" || AnyToString(condition->value_holder.data, "boxed"));

        // If default is also a match we can't handle this; would need an outer join for that (a missing settings-record is also a match)
        IF (accessor->MatchesDefault(condition->value_holder.data, condition))
          RETURN FALSE;

        // FIXME: multiple returns on multiple occurrances in settings table!

        INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
        STRING setting_table := "CONDITION_SETTING_" || dbquery->GetSourcesLength() || "_" || query_name;

        IF (accessor->attr.parent != 0 AND condition->match_type NOT IN [ "MENTIONS", "MENTIONSANY" ])
          THROW NEW Exception("Matchtype '" || condition->match_type || "' not supported for array attributes (tried to apply to '" || accessor->attr.tag || "')");

        // Try to add the query. If failed, missed optimization opportunity.
        RECORD addresult := accessor->TryAddToDBQuery(dbquery, setting_table, condition->value_holder.data, condition, FALSE);
        IF (NOT addresult.canhandle AND NOT addresult.canhandlepartially)
          RETURN FALSE;

        // Add the rest of the constraints. The setting must be valid NOW (no history mumbo jumbo).
        dbquery->AddJoin(query_name || ".id", "=", setting_table || ".entity");
        dbquery->AddConstraint(setting_table || ".attribute", "=", condition->attr.id);

        // Multiple mentions in one entity cause a row to be returned multiple times: distinct phase is required
        IF (condition->match_type IN ["MENTIONS","MENTIONSANY"])
          partition->require_distincting := TRUE;

        IF (addresult.canhandlepartially)
          RETURN FALSE;
      }
      RETURN TRUE;
    }

    /** Executes the DB query of a specific partition
    */
    PUBLIC RECORD ARRAY FUNCTION ExecutePartitionQuery(OBJECT partition)
    {
      RECORD ARRAY rows := partition->dbquery->Execute();

      IF (partition->require_distincting)
        rows := this->DeduplicatePartitionQueryRows(partition, rows);

      // After-filter all retrieved rows
      rows := this->AfterFilterResults(rows, partition);

      RETURN rows;
    }

    /** Eliminates duplicate rows from the result of a partition query
    */
    RECORD ARRAY FUNCTION DeduplicatePartitionQueryRows(OBJECT partition, RECORD ARRAY rows)
    {
      // Eliminate duplicate rows
      RECORD ARRAY filtered;

      STRING ARRAY sourcenames;
      FOREVERY (OBJECT single FROM partition->sources)
        INSERT ToUppercase(single->name) INTO sourcenames AT END;

      RECORD ARRAY list;
      FOREVERY (RECORD row FROM rows)
      {
        RECORD ids;
        FOREVERY (STRING name FROM sourcenames)
          ids := CellInsert(ids, name, GetCell(row, name).id);

        RECORD lookup := RecordLowerBound(list, ids, sourcenames);
        IF (NOT lookup.found)
        {
          INSERT row INTO filtered AT END;
          INSERT ids INTO list AT lookup.position;
        }
      }

      RETURN filtered;
    }

    /** Sets the link columns in the results of the dbquery of the partition that is to be added
    */
    PUBLIC RECORD ARRAY FUNCTION SetLinksInNewRows(RECORD ARRAY results, OBJECT new_partition, STRING ARRAY link_names)
    {
      IF (link_names[0] != "LINK" OR LENGTH(link_names) != LENGTH(new_partition->active_external_links))
        ABORT("Internal error: link_names is not compatible (at new rows)");

      FOREVERY (RECORD curr_link FROM new_partition->active_external_links)
      {
        STRING left_name := curr_link.link_left->name;
        STRING right_name := curr_link.link_right->name;
        RECORD attr := curr_link.attr;
        STRING link_name := link_names[#curr_link];
        STRING setting_table := "LINK_SETTING_EXT_" || new_partition->partition_id || "_" || #curr_link;

        IF (curr_link.link_left->partition != new_partition)
        {
          IF (attr.base) // Base field FIXME: handle by forevery
            results := SELECT AS RECORD ARRAY CellInsert(results, link_name, GetCell(results, right_name).id) FROM results;
          ELSE
            results := SELECT AS RECORD ARRAY CellInsert(results, link_name, GetCell(results, setting_table).entity) FROM results;
        }
        ELSE
        {
          IF (attr.base) // Base field
            results := SELECT AS RECORD ARRAY CellInsert(results, link_name, GetCell(GetCell(results, left_name), attr.cellname)) FROM results;
          ELSE
            results := SELECT AS RECORD ARRAY CellInsert(results, link_name, GetCell(results, setting_table).setting) FROM results;
        }
      }

      results := SELECT * FROM results ORDER BY link;
      RETURN results;
    }

    /** After filters the results (on the conditions that couldn't be immediately
        solved in the db query
    */
    PRIVATE RECORD ARRAY FUNCTION AfterFilterResults(RECORD ARRAY current_results, OBJECT partition)
    {
      // We can't work out the optimal way to execute this. Let's hope the db has done most stuff.
      FOREVERY (OBJECT single FROM partition->sources)
      {
        // Only filter when needed
        IF (LENGTH(single->opt_children) = 0)
          CONTINUE;

        // Get all the entity records for the current single.
        STRING name := ToUppercase(single->name);

        // entities := SELECT CellInsert(GetCell(row, name), "__ROW", row) FROM current_results AS row
        RECORD ARRAY entities := current_results;
        FOREVERY (RECORD row FROM current_results)
        {
          RECORD entity := GetCell(row, name);
          INSERT CELL __row := row INTO entity;

          entities[#row] := entity;
        }
        entities := SELECT * FROM entities ORDER BY id;

        // entity_ids := SELECT DISTINCT id FROM entities ORDER BY id
        INTEGER ARRAY entity_ids;
        INTEGER last := -1;
        FOREVERY (RECORD r FROM entities)
        {
          INTEGER curr := r.id;
          IF (curr != last)
          {
            INSERT r.id INTO entity_ids AT END;
            last := curr;
          }
        }

        // Delete 0 id (for default record, no need to filter on it)
        IF (LENGTH(entity_ids) > 0 AND entity_ids[0] = 0)
          DELETE FROM entity_ids AT 0;

        entity_ids := this->FilterEntities(single, single, entity_ids);

        // Add 0 id (for default record)
        INSERT 0 INTO entity_ids AT 0;

        current_results := FilterListAndReturnRows(entities, entity_ids);
      }
      RETURN current_results;
    }

    /** Returns the list of entity'ids for which the condition tree in @cond is satisfied
        @param entity_ids List of current ids of entities
    */
    PRIVATE INTEGER ARRAY FUNCTION FilterEntities(OBJECT single, OBJECT cond, INTEGER ARRAY entity_ids)
    {
      INTEGER ARRAY results;
      SWITCH (cond->type)
      {
        CASE "AND"
            {
              results := entity_ids;
              FOREVERY (OBJECT child FROM cond->opt_children)
                results := this->FilterEntities(single, child, results);
              RETURN results;
            }
        CASE "OR"
            {
              results := entity_ids;
              FOREVERY (OBJECT child FROM cond->opt_children)
              {
                INTEGER ARRAY fresults := this->FilterEntities(single, child, entity_ids);
                IF (#child = 0)
                  results := fresults;
                ELSE
                  results := UnionIntegerArrays(results, fresults);
              }
              RETURN results;
            }
        CASE "NOT"
            {
              results := DEFAULT INTEGER ARRAY;
              FOREVERY (OBJECT child FROM cond->opt_children)
                results := this->FilterEntities(single, child, entity_ids);
              results := NegateIntegerArray(entity_ids, results);
              RETURN results;
            }
        CASE "FREE", "DOMAIN"
            {
              // Do the free query.
              RECORD attrinfo := cond->attr;

              OBJECT query := NEW DynamicQuery;
              INTEGER transaction := GetBindingFromTable(wrd.types).transaction;

              INTEGER ARRAY matches;
              VARIANT match_value := cond->value_holder.data;
              IF (NOT cond->match_case)
              {
                IF (cond->match_type != "IN")
                  match_value := ToUppercase(match_value);
                ELSE
                  FOREVERY (STRING val FROM match_value)
                    match_value[#val] := ToUppercase(val);
              }

              IF (attrinfo.base)
              {
                // No need to do funny about historical data; entity_ids should be valid already
                query->AddDeclaredTable("ENTITIES", wrd.entities, [ "id" ]);
                query->AddConstraint("ENTITIES.id", "IN", entity_ids);

                // Non-generated attrinfo's are easy
                IF (NOT attrinfo.isgenerated)
                {
                  BOOLEAN done := FALSE;
                  query->RequestAdditionalColumns("ENTITIES", [ STRING(attrinfo.cellname) ]);
                  BOOLEAN db_can_handle := TypeId(match_value) != TypeId(STRING) OR LENGTH(match_value) < 4096;
                  IF (db_can_handle AND cond->match_case)
                    query->AddConstraint("ENTITIES." || attrinfo.cellname, cond->match_type, match_value);
                  ELSE IF (db_can_handle AND cond->match_type != "IN")
                    query->AddUppercaseConstraint("ENTITIES." || attrinfo.cellname, cond->match_type, match_value);
                  ELSE
                  {
    //                query->RequestAdditionalColumns("ENTITIES", [ STRING(attrinfo.cellname) ]);
    //                PRINT("IN!\n" ||anytostring(match_value, "tree") || "\n");
                    matches := SELECT AS INTEGER ARRAY entities.id
                                 FROM query->Execute() AS row
                                WHERE EvaluateConstraint(ToUppercase(GetCell(row.entities, attrinfo.cellname)), cond->match_type, match_value)
                             ORDER BY entities.id;
                    done := TRUE;
                  }
                  IF (NOT done)
                    matches := SELECT AS INTEGER ARRAY entities.id
                               FROM query->Execute()
                           ORDER BY entities.id;
                }
                ELSE
                {
                  // Generated stuffs are somewhat more difficult
                  query->RequestAdditionalColumns("ENTITIES", attrinfo.cellnames);
                  matches := SELECT AS INTEGER ARRAY entities.id
                               FROM query->Execute() AS row
                              WHERE cond->match_case ? EvaluateConstraint(attrinfo.generator(row.entities), cond->match_type, match_value)
                                                     : EvaluateConstraint(ToUppercase(attrinfo.generator(row.entities)), cond->match_type, match_value)
                           ORDER BY entities.id;
                }
                RETURN matches;
              }

              OBJECT accessor := GetAccessorForAttributeType(attrinfo, single->wrd_type, CELL[ linkgetter := DEFAULT OBJECT
                                                                                             , whfsmapper := this->pvt_whfsmapper
                                                                                             , wrapper := DEFAULT RECORD
                                                                                             ]);
              IF (NOT accessor->CheckUserInput(cond->value_holder.data, cond))
                THROW NEW Exception("The specified value to match against is not a valid value or valuetype for attribute "||attrinfo.localtag||" in combination with matchtype "||cond->match_type||" (got valuetype "||GetTypeName(TypeID(cond->value_holder.data))||")");

              //PRINT("Trying to add " ||  cond->attr.tag || "\n");

              IF(accessor->attr.parent != 0 AND cond->match_type NOT IN ["MENTIONS","MENTIONSANY"])
                THROW NEW Exception("Matchtype '" || cond->match_type || "' not supported for array attributes (tried to apply to '" || accessor->attr.tag || "')");

              RECORD addresult := accessor->TryAddToDBQuery(query, "SETTINGS", cond->value_holder.data, cond, TRUE);
              IF (NOT addresult.canhandle)
              {
                //PRINT("Doing ourselves " || attrinfo.tag || "\n");
                IF (NOT addresult.canhandlepartially)
                  query->AddDeclaredTable("SETTINGS", wrd.entity_settings, [ "entity" ] );
                query->AddConstraint("SETTINGS.entity", "IN", entity_ids);
                query->AddConstraint("SETTINGS.attribute", "=", attrinfo.id);

                // The DB cannot handle it, we must execute it ourself. Make sure the needed cells are retrieved and GO!
                accessor->RequestNeededColumns(query, "SETTINGS");
                STRING match_type:= cond->match_type;
                BOOLEAN match_case := cond->match_case;

                RECORD ARRAY settings :=
                    SELECT vals     := GroupedValues(row.settings)
                         , entity   := Any(row.settings.entity)
                      FROM query->Execute() AS row
                  GROUP BY row.settings.entity;

                matches :=
                    SELECT AS INTEGER ARRAY entity
                      FROM settings
                     WHERE accessor->MatchFromRecord(vals, 0, LENGTH(vals), match_type, match_value, match_case)

                  ORDER BY entity;

              }
              ELSE IF (NOT addresult.noresults)
              {
                //PRINT("DB can handle " || attrinfo.tag || "\n");
                query->AddConstraint("SETTINGS.entity", "IN", entity_ids);
                query->AddConstraint("SETTINGS.attribute", "=", attrinfo.id);

                matches :=
                    SELECT AS INTEGER ARRAY DISTINCT settings.entity
                      FROM query->Execute()
                  ORDER BY settings.entity;
              }
              ELSE
                matches := DEFAULT INTEGER ARRAY;

              BOOLEAN default_matches := accessor->MatchesDefault(cond->value_holder.data, cond);

              IF (default_matches)
              {
                // Default also matches. Get all settings, and negate that, to get setting-less entities.
                OBJECT dynquery := NEW DynamicQuery;
                dynquery->AddDeclaredTable("SETTINGS", wrd.entity_settings, [ "entity" ] );
                dynquery->AddConstraint("SETTINGS.entity", "IN", entity_ids);
                dynquery->AddConstraint("SETTINGS.attribute", "=", attrinfo.id);

                INTEGER ARRAY existing_entities :=
                     SELECT AS INTEGER ARRAY settings.entity
                       FROM dynquery->Execute()
                   ORDER BY settings.entity;

                INTEGER ARRAY defaults := NegateIntegerArray(entity_ids, existing_entities);
                matches := UnionIntegerArrays(matches, defaults);
              }
              RETURN matches;
            }
      }
      THROW NEW Exception("Illegal entity type " || cond->type);
    }

    /** Returns the default entity records for a specific partition
    */
    PUBLIC RECORD FUNCTION ReturnDefaultForPartition(OBJECT partition)
    {
      RECORD rec;
      FOREVERY (OBJECT source FROM partition->sources)
        rec := CellInsert(rec, source->name, default_entity);
      RETURN rec;
    }

    /** Enriches all entities in finalresults with selected needed attributes
    */
    PUBLIC RECORD ARRAY FUNCTION EnrichAllEntities(RECORD ARRAY finalresults)
    {
      RECORD emptyrecord := CELL[];
      finalresults :=
          SELECT *
               , result :=    emptyrecord
               , __entity :=  0
               , data :=      DEFAULT RECORD
            FROM finalresults;

      FOREVERY (OBJECT single FROM this->singles)
      {
        RECORD accessors := single->CreateAccessors();
        IF(NOT RecordExists(accessors))
          CONTINUE;

        RECORD ARRAY fields, base_fields;
        fields := accessors.fields;
        base_fields := accessors.base_fields;

        FOREVERY (RECORD row FROM finalresults)
          finalresults[#row].data := DEFAULT RECORD;

        STRING name := single->name;
        IF (LENGTH(fields) > 0)
        {
          RECORD ARRAY enrich_results;

          FOREVERY (RECORD row FROM finalresults)
            finalresults[#row].__entity := GetCell(row, name).id;

          finalresults := this->EnrichEntities(finalresults, fields);
        }

        // Enrich base fields (needed entity record data is present in GetCell(row, name))
        FOREVERY (RECORD row FROM finalresults)
        {
          finalresults[#row].data := MakeMergedRecord(finalresults[#row].data, GenerateBaseFields(base_fields, GetCell(row, single->name)));
        }

        // Merge the data for this source into the final result
        IF(single->__submaps>0)
        {
          FOREVERY(RECORD res FROM finalresults)
            finalresults[#res].result := MakeMergedRecord(res.result, ApplyReturnMap(single->return_map, res.data));
        }
        ELSE
        {
          FOREVERY(RECORD res FROM finalresults)
            finalresults[#res].result := MakeMergedRecord(res.result, res.data);
        }
      }

      // Return only the result rows
      RETURN
          SELECT AS RECORD ARRAY result
            FROM finalresults;
    }

    /** Enriches all entities of a specific source
        @param records Records that need to be enriched
        @cell records.__entity Id of entity for this source
        @cell records.__row Row data as returned by merges of @a ExecutePartitionQuery for all partitions
        @cell records.data Final enriched data
        @param fields List of fields to enrich with. Is the attribute-record to enrich with, with extra cells.
        @cell fields.__attributeid Id of the attribute
        @cell fields.accessor Accessor for the attribute type (only needed for non-base fields)
        @cell fields.rename Name that must be used for this field when inserting it into __data
        @cell fields.subselect Subselect for the attribute (RECORD attributes only)
    */
    PUBLIC RECORD ARRAY FUNCTION EnrichEntities(RECORD ARRAY records, RECORD ARRAY fields)
    {
      // Get all attributes (ignore contacts), and their distinct ids
      RECORD ARRAY attributes :=
            SELECT rename
                 , attribute := id
                 , accessor
                 , subselect
                 , allattributeids
              FROM fields
          ORDER BY id;

      // Any enrichment to do at all?
      IF (LENGTH(attributes) = 0)
        RETURN records;

      //PRINTRECORDARRAYTO(0, fields, "tree");

      INTEGER transaction := GetBindingFromTable(wrd.types).transaction;

      // We have work to do. Sort the records on entity, we need that.
      records := SELECT * FROM records ORDER BY __entity;

      INTEGER ARRAY wanted_attr_ids;
      FOREVERY (RECORD rec FROM attributes)
        wanted_attr_ids := wanted_attr_ids CONCAT rec.allattributeids;
      wanted_attr_ids := SELECT AS INTEGER ARRAY DISTINCT id FROM ToRecordArray(wanted_attr_ids, "ID") ORDER BY id;

      // Get all entities in chunks of 1024
      RECORD ARRAY result;
      RECORD ARRAY chunks;

      INTEGER chunk_count := (LENGTH(records) + 1023) / 1024;
      FOR (INTEGER chunk_nr := 0; chunk_nr < chunk_count; chunk_nr := chunk_nr + 1)
      {
        INTEGER chunk_begin := chunk_nr * 1024;
        INTEGER chunk_limit := chunk_nr * 1024 + 1024;
        IF (chunk_limit > LENGTH(records))
          chunk_limit := LENGTH(records);

        INTEGER ARRAY list;
        RECORD ARRAY recs;

        FOR (INTEGER idx := chunk_begin; idx < chunk_limit; idx := idx + 1)
        {
          INSERT records[idx].__entity INTO list AT END;
          INSERT records[idx] INTO recs AT END;
        }

        INSERT [ list := list
               , recs := recs
               ] INTO chunks AT END;
      }

      RECORD ARRAY all_attr_settings;
      FOREVERY (RECORD chunk FROM chunks)
      {
        OBJECT query := NEW DynamicQuery;
        query->AddDeclaredTable("SETTINGS", wrd.entity_settings, [ "attribute", "entity", "rawdata", "ordering", "parentsetting" ]);
        query->AddConstraint("SETTINGS.attribute", "IN", wanted_attr_ids);
        query->AddConstraint("SETTINGS.entity", "IN", chunk.list);

        FOREVERY (RECORD field FROM attributes)
          field.accessor->RequestNeededColumns(query, "settings");

//        PRINT("Executing DB query<BR>:\n"||EncodeHTML(query->Dump()));

        RECORD ARRAY attr_settings :=
              SELECT AS RECORD ARRAY r.settings
                FROM query->Execute() AS r
            ORDER BY settings.parentsetting, settings.entity, settings.attribute, settings.ordering;

        result := result CONCAT EnrichRows(chunk.recs, attributes, attr_settings, [ parentsetting := 0 ], [ "PARENTSETTING"]);
      }
      RETURN result;
    }

    /** Executes the query
    */
    PUBLIC RECORD ARRAY FUNCTION Execute(RECORD params)
    {
      this->InitializeExecution(this->current_time ?? GetCurrentDateTime());
      this->PartitionQueries();
      this->DistributeLinksAndSetDependencies();
      this->OrderPartitions();

      RECORD ARRAY current;
      FOREVERY (OBJECT partition FROM this->partitions)
      {
        IF (#partition = 0)
        {
          this->ConstructDBQuery(partition, current, params);
          current := this->ExecutePartitionQuery(partition);
        }
        ELSE
        {
          STRING ARRAY link_names := this->GenerateLinkNames(partition);
          current := this->SetLinksInCurrentRows(current, partition, link_names);

          this->ConstructDBQuery(partition, current, params);
          RECORD ARRAY rawdata := this->ExecutePartitionQuery(partition);

          rawdata := this->SetLinksInNewRows(rawdata, partition, link_names);

          STRING ARRAY additional_links := link_names;
          DELETE FROM additional_links AT 0;

          IF (partition->mode = "optional")
            current := RightOuterJoinOnLink(current, rawdata, this->ReturnDefaultForPartition(partition), additional_links);
          ELSE
            current := RightMissingJoinOnLink(current, rawdata, this->ReturnDefaultForPartition(partition), additional_links);
        }
      }

      // Limit the number of returned rows.
      IF (this->resultlimit >= 0)
        current := ArraySlice(current, 0, this->resultlimit);

      RECORD ARRAY results := this->EnrichAllEntities(current);
      this->Cleanup();
      RETURN results;
    }

    /** Returns a string roughly explaining how this query will be solved
    */
    PUBLIC STRING FUNCTION Explain(RECORD params)
    {
      this->PartitionQueries();
      this->DistributeLinksAndSetDependencies();
      this->OrderPartitions();

      RECORD ARRAY ps;
      STRING s;

      FOREVERY (OBJECT partition FROM this->partitions)
        INSERT [ o := partition->ordering, p := partition ] INTO ps AT END;

      FOREVERY (RECORD r FROM SELECT * FROM ps ORDER BY o)
      {
        OBJECT partition := r.p;

        s := s || "Partition " || partition->partition_id || ", ordering: " || r.o || "\n";
        s := s || " Sources:\n";
        FOREVERY (OBJECT single FROM partition->sources)
          s := s || "  " || single->name || ", type: " || single->wrd_type->tag || "\n";
      }
      s := s || "\n";

      RECORD ARRAY rs;
      FOREVERY (RECORD r FROM SELECT * FROM ps ORDER BY o)
      {
        OBJECT partition := r.p;
        this->ConstructDBQuery(partition, rs, params);
        s := s || "Partition " || partition->partition_id || "\n";
        s := s || " Database query:\n" || partition->dbquery->Dump();
        s := s || " After filters:\n";
        FOREVERY (OBJECT single FROM partition->sources)
          IF (LENGTH(single->opt_children) > 0)
          {
            s := s || "Single " || single->name || ":\n";
            s := s || ExplainAfterFilters(single, "  ");
          }
      }
      this->Cleanup();
      RETURN s;
    }

    /** Returns the list of output columns
        @return The list
        @cell return.name Name of the output column
        @cell return.attr Attribute that is selected for this output column
    */
    PUBLIC RECORD ARRAY FUNCTION GetOutputColumns()
    {
      RECORD ARRAY results;
      FOREVERY (OBJECT single FROM this->singles)
        results := results CONCAT single->selected_attributes;
      RETURN results;
    }

    /** Returns the list of parameters
        @return The list
        @cell return.name Name of the parameter
        @cell return.type Attribute type
        @cell return.subtype Attribute subtype
        @cell return.valuestart If present, minimal value of the parameter
        @cell return.valuelimit If present, limit value of the parameter
    */
    PUBLIC RECORD ARRAY FUNCTION GetParameters()
    {
      RETURN SELECT AS RECORD ARRAY value FROM UnpackRecord(this->parameters);
    }

    /** Does some cleanup so that all objects will be refcount deleted once this query
        is discarded.
    */
    PUBLIC MACRO Cleanup()
    {
      FOREVERY (OBJECT single FROM this->singles)
        single->partition := DEFAULT OBJECT;
    }

    PUBLIC OBJECT FUNCTION SerializeToXML(OBJECT rootnode)
    {
      OBJECT doc := rootnode->ownerdocument;

      OBJECT xml_sources := doc->CreateElementNS(query_ns, "sources");
      rootnode->AppendChild(xml_sources);

      // Add the harescript namespace for convenience
      xml_sources->SetAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns:hs", "http://www.webhare.net/xmlns/hs/xmlrecord");

      FOREVERY(OBJECT single FROM this->singles)
      {
        OBJECT xml_source := doc->CreateElementNS(query_ns, "source");
        xml_sources->AppendChild(xml_source);

        xml_source->SetAttribute("type", single->wrd_type->tag);
        xml_source->SetAttribute("name", single->name);

        IF (RecordExists(single->selected_attributes))
        {
          OBJECT xml_outputcols := doc->CreateElementNS(query_ns, "outputcolumns");
          xml_source->AppendChild(xml_outputcols);

          FOREVERY (RECORD selattr FROM single->selected_attributes)
          {
            OBJECT xml_outputcol := doc->CreateElementNS(query_ns, "outputcolumn");
            xml_outputcols->AppendChild(xml_outputcol);

            xml_outputcol->SetAttribute("name", selattr.name);
            xml_outputcol->SetAttribute("attribute", selattr.attr.tag);
            IF (Length(selattr.subselect) > 0)
              xml_outputcol->SetAttribute("subselect", Detokenize(selattr.subselect, "."));
          }
        }

        IF (single->history_mode != "now")
          xml_source->SetAttribute("historymode", single->history_mode);

        IF (single->history_mode = "at")
        {
          xml_source->SetAttribute("when", FormatDateTime("%Y-%m-%dT%H:%M:%S.%QZ", single->when_start));
        }
        ELSE IF (single->history_mode = "range")
        {
          xml_source->SetAttribute("whenstart", FormatDateTime("%Y-%m-%dT%H:%M:%S.%QZ", single->when_start));
          xml_source->SetAttribute("whenlimit", FormatDateTime("%Y-%m-%dT%H:%M:%S.%QZ", single->when_limit));
        }

        IF (LENGTH(single->children) != 0)
        {
          OBJECT xml_filters := doc->CreateElementNS(query_ns, "filters");
          xml_source->AppendChild(xml_filters);

          single->SerializeToXML(single->wrd_type, xml_filters, TRUE);
        }
      }

      IF (LENGTH(this->links) != 0)
      {
        OBJECT xml_links := doc->CreateElementNS(query_ns, "links");
        rootnode->AppendChild(xml_links);

        FOREVERY (RECORD link FROM this->links)
        {
          OBJECT xml_link := doc->CreateElementNS(query_ns, "link");
          xml_links->AppendChild(xml_link);

          IF (NOT link.attr_specified AND ToUppercase(link.attr.tag) = "WRD_LEFTENTITY")
          {
            // Left and right have been switched: unswitch
            xml_link->SetAttribute("left", link.link_right->name);
            xml_link->SetAttribute("right", link.link_left->name);
          }
          ELSE
          {
            xml_link->SetAttribute("left", link.link_left->name);
            xml_link->SetAttribute("right", link.link_right->name);
          }
          IF (link.jointype != "default")
            xml_link->SetAttribute("jointype", link.jointype);
          IF (link.attr_specified)
            xml_link->SetAttribute("field", link.attr.tag);
        }
      }

      IF (this->resultlimit != -1)
      {
        OBJECT xml_resultlimit := doc->CreateElementNS(query_ns, "resultlimit");
        rootnode->AppendChild(xml_resultlimit);

        rootnode->SetAttribute("value", this->resultlimit);
      }

      IF (RecordExists(this->parameters))
      {
        OBJECT xml_parameters := doc->CreateElementNS(query_ns, "parameters");
        rootnode->AppendChild(xml_parameters);

        FOREVERY (RECORD parameter FROM UnpackRecord(this->parameters))
        {
          OBJECT xml_parameter := doc->CreateElementNS(query_ns, "parameter");
          xml_parameters->AppendChild(xml_parameter);

          RECORD paramdata := parameter.value;

          xml_parameter->SetAttribute("name", parameter.name);
          IF (paramdata.title != parameter.name)
            xml_parameter->SetAttribute("title", paramdata.title);

          xml_parameter->SetAttribute("type", GetAttributeTypeNameByTypeId(paramdata.type));
          IF (paramdata.subtype != "")
            xml_parameter->SetAttribute("subtype", paramdata.subtype);

          SWITCH (parameter.type)
          {
          CASE 1 /*domain*/
            {
              xml_parameter->SetAttribute("domaintype", parameter.domaintype->tag);

              // ADDME: domainfilters?
            }

          CASE 6, 12 /*date, datetime*/
            {
              THROW NEW Exception("Serialization for parameters of type date/datetime not implemented yet");
            }

          CASE 15 /*integer*/
            {
              IF (CellExists(paramdata, "VALUESTART"))
                xml_parameter->SetAttribute("valuestart", ToString(paramdata.valuestart));
              IF (CellExists(paramdata, "VALUELIMIT"))
                xml_parameter->SetAttribute("valuelimit", ToString(paramdata.valuelimit));
              IF (CellExists(paramdata, "VALUEDEFAULT"))
                xml_parameter->SetAttribute("valuedefault", ToString(paramdata.valuedefault));
            }

          CASE 16 /*money*/
            {
              IF (CellExists(paramdata, "VALUESTART"))
                xml_parameter->SetAttribute("valuestart", FormatMoneyXSD(paramdata.valuestart));
              IF (CellExists(paramdata, "VALUELIMIT"))
                xml_parameter->SetAttribute("valuelimit", FormatMoneyXSD(paramdata.valuelimit));
              IF (CellExists(paramdata, "VALUEDEFAULT"))
                xml_parameter->SetAttribute("valuedefault", FormatMoneyXSD(paramdata.valuedefault));
            }
          }
        }
      }
      RETURN rootnode;
    }

  >;

/** This is the interface to WRD queries; this object is returned
    when MakeWRDQuery is called, and is used by the user to execute
    or analyze a query.
*/
PUBLIC STATIC OBJECTTYPE WRDQueryInterface
  </// Returns all matches for this query
    PUBLIC RECORD ARRAY FUNCTION Execute(RECORD params DEFAULTSTO DEFAULT RECORD)
    {
      RETURN DEFAULT RECORD ARRAY;
    }

    /// Explains how the query will be solved
    PUBLIC STRING FUNCTION Explain(RECORD params DEFAULTSTO DEFAULT RECORD)
    {
      RETURN "";
    }

    /// Exports this query to XML
    PUBLIC OBJECT FUNCTION SerializeToXML(OBJECT docnode)
    {
      RETURN DEFAULT OBJECT;
    }

    /// Exports this query to XML
//  , OBJECT FUNCTION SerializeToXML2(OBJECT docnode)
    PUBLIC RECORD ARRAY FUNCTION GetOutputColumns()
    {
      RETURN DEFAULT RECORD ARRAY;
    }

    PUBLIC RECORD ARRAY FUNCTION GetParameters()
    {
      RETURN DEFAULT RECORD ARRAY;
    }

    /** Processes a list of parameters in the form of parameters in a query definition
        to the format that GetParameters needs to return */
    PUBLIC RECORD ARRAY FUNCTION ProcessParameters(RECORD ARRAY parameters, BOOLEAN strict)
    {
      RETURN ProcessParameters(parameters, strict);
    }

    UPDATE PUBLIC MACRO ResetCurrentTime(DATETIME current_time DEFAULTSTO DEFAULT DATETIME)
    {
    }
  >;

/** This is the interface to WRD queries; this object is returned
    when MakeWRDQuery is called, and is used by the user to execute
    or analyze a query.
*/
STATIC OBJECTTYPE WRDQueryInterfaceNormalQuery EXTEND WRDQueryInterface
  < PRIVATE OBJECT query;

    PUBLIC PROPERTY current_time(query->current_time, query->current_time);

    /// Returns all matches for this query
    PUBLIC UPDATE RECORD ARRAY FUNCTION Execute(RECORD params DEFAULTSTO DEFAULT RECORD)
    {
      RETURN this->query->Execute(params);
    }

    /// Explains how the query will be solved
    PUBLIC UPDATE STRING FUNCTION Explain(RECORD params DEFAULTSTO DEFAULT RECORD)
    {
      RETURN this->query->Explain(params);
    }

    /// Exports this query to XML
    PUBLIC UPDATE OBJECT FUNCTION SerializeToXML(OBJECT docnode)
    {
      RETURN this->query->SerializeToXML(docnode);
    }

    PUBLIC UPDATE RECORD ARRAY FUNCTION GetParameters()
    {
      RETURN this->query->GetParameters();
    }

    PUBLIC MACRO NEW(OBJECT query)
    {
      this->query := query;
    }

    UPDATE PUBLIC RECORD ARRAY FUNCTION GetOutputColumns()
    {
      RETURN this->query->GetOutputColumns();
    }

    PUBLIC INTEGER FUNCTION GetTypeForOutputcolumn(STRING colname)
    {
      //NOTE this only supports single source scenario
      RETURN TypeID(GetCell(GetDefaultRecordForSource(this->query->singles[0]), colname));
    }
    UPDATE PUBLIC MACRO ResetCurrentTime(DATETIME current_time DEFAULTSTO DEFAULT DATETIME)
    {
      this->query->InitializeExecution(current_time ?? GetCurrentDateTime());
    }

  >;


/** This object type is used to convert between db storage format and the way we want to see the data
    stored in the database
    This base object is for strings, stored in the 'rawdata' cell.
*/
STATIC OBJECTTYPE WRDDBValue
< /// Attribute this accessor has been instantiated for
  PUBLIC RECORD attr;

  /// WRD type of the attribute
  OBJECT wrdtype;

  MACRO NEW(OBJECT wrdtype, RECORD attr)
  {
    this->wrdtype := wrdtype;
    this->attr := attr;
  }

  /** Make sure all parent setting records are also added to the query, to make sure their creation/limitdata is honored
      @param dbquery Dynamic database query
      @param curtable Name of current table
      @param parent Parent attribute id (of selected attribute, so it points to the deepest array)
      @return Names of added tables (in the dynamic query)
  */
  STRING ARRAY FUNCTION AddArrayParents(OBJECT dbquery, STRING curtable, INTEGER parent)
  {
    STRING ARRAY tables;

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    WHILE (parent != 0)
    {
      RECORD attr := this->wrdtype->GetAttributeById(parent);

      STRING setting_table := "PARENTSETTING_" || dbquery->GetSourcesLength();
      dbquery->AddDeclaredTable(setting_table, wrd.entity_settings, DEFAULT STRING ARRAY);
      dbquery->AddJoin(curtable || ".parentsetting", "=", setting_table || ".id");

      INSERT setting_table INTO tables AT END;
      curtable := setting_table;
      parent := attr.parent;
    }
    RETURN tables;
  }

  /** Returns whether a parsed value matches a constraint
      @param dbval Parsed attribute value
      @param match_type Matchtype
      @param match_value Value to match against. If comparing case sensitive, must be uppercased!
      @param match_case Whether to match case
      @return Whether the value matches the constraint
  */
  PUBLIC BOOLEAN FUNCTION Match(VARIANT dbval, STRING match_type, VARIANT match_value, BOOLEAN match_case)
  {
    RETURN EvaluateConstraintWithSpecCase(dbval, match_type, match_value, match_case);
  }

  /** Returns whether a parsed value matches a constraint by directly passing the needed records
      @see Match, GetFromRecord */
  PUBLIC BOOLEAN FUNCTION MatchFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit, STRING match_type, VARIANT match_value, BOOLEAN match_case)
  {
    RETURN this->Match(this->GetFromRecord(entity_settings, settings_start, settings_limit), match_type, match_value, match_case);
  }

  /** Validate user input for validity
      @param match_type Matching type
      @param user_input User provided input
      @param match_case Whether case-matching was requested
      @return Whether the value is valid for this type.
  */
  PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type = "IN")
    {
      IF (NOT IsTypeIDArray(TypeID(user_input)))
        RETURN FALSE;
      IF (LENGTH(user_input) = 0)
        RETURN TRUE;
      ELSE
        user_input := user_input[0];
    }

    IF (match_type IN [ "CONTAINS", "MENTIONS", "MENTIONSANY", "__INRANGE" ])
      THROW NEW Exception(`The match type '${match_type}' is not allowed for attribute '${this->attr.tag}'`);

    INTEGER user_type := TypeID(user_input);
    IF (NOT condition->match_case AND user_type != TypeId(STRING))
      RETURN FALSE;

    RETURN user_type = TypeID(this->GetDefaultValue());
  }

  PUBLIC VARIANT FUNCTION GetValue(RECORD ARRAY attrdata, INTEGER attrdata_start, INTEGER attrdata_limit, RECORD row)
  {
    IF(attrdata_limit <= attrdata_start)
      RETURN this->GetDefaultValue();
    ELSE
      RETURN this->GetFromRecord(attrdata, attrdata_start, attrdata_limit);
  }

  /** Returns the default value for this attribute type
  */
  PUBLIC VARIANT FUNCTION GetDefaultValue()
  {
    THROW NEW Exception("GetDefaultValue() for " || this->wrdtype->tag || ":" || this->attr.tag || " must be overriden");
  }

  /** Decodes the attribute value from one or more entity settings
  */
  PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    // Example: RETURN entity_settings[settings_start].rawdata;
    THROW NEW Exception("GetFromRecord() for " || this->wrdtype->tag || ":" || this->attr.tag || " must be overriden");
  }

  /** @short Does the comparetype/value also match defaults - not database stored values (eg 0, "", no file)
      @return True if this comparison would also match unstored values
  */
  PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    IF (NOT this->CheckUserInput(value, condition))
      THROW NEW Exception("Specified value is of the wrong type for this type of attribute");
    RETURN EvaluateConstraintWithSpecCase(this->GetDefaultValue(), condition->match_type, value, condition->match_case);
  }

  /** Returns whether a constraint value only contains default values for this attribute type
  */
  PUBLIC BOOLEAN FUNCTION ContainsOnlyDefaultValues(VARIANT value)
  {
    VARIANT defaultvalue := this->GetDefaultValue();
    IF (IsTypeidArray(TypeID(value)))
    {
      FOREVERY (VARIANT v FROM value)
        IF (v != defaultvalue)
          RETURN FALSE;
      RETURN TRUE;
    }
    RETURN value = defaultvalue;
  }

  /** Try to add this cotnraint to the database query, so the query will (as much as possible) return results that
      match this contraint.
      Caveats: default values are usually not stored into entity_settings rows - make sure you don't filter out default values.
      @param query
      @param settings_source Name that must be used when adding a table to the dynamic query to select entity settings
      @param value Value to search for
      @param comparetype Comparison operator
      @param match_case Whether to match case insensitive
      @param ignore_default_also_match If TRUE, you can safely filter out default values, and add the query anyway.
      @return
      @cell return.canhandle Whether the query has been amended to filter for this constraint.
      @cell return.noresults If the query can't be added, whether there would be any matches of non-default attributes possible.
      @cell return.tables Additional tables added for array parent settings (must be checked for creationdate/limitdate by caller - TODO still needed?)
  */
  PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype = "=" AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }
    IF (comparetype = "IN") // The db can't handle IN for strings
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
    IF (LENGTH(STRING(value)) >= 4096) // The db can't handle 4096 bytes or longer strings anyway.
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (match_case)
      query->AddConstraint(settings_source || ".rawdata", comparetype, value);
    ELSE // dynamic query doesn't support IN for uppercase queries
      query->AddUppercaseConstraint(settings_source || ".rawdata", comparetype, value);
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "rawdata" ]);
  }

  PUBLIC INTEGER ARRAY FUNCTION GetAllAttributeIds()
  {
    RETURN [ INTEGER(this->attr.id) ];
  }
>;

BOOLEAN FUNCTION CheckEnumUserInput(RECORD attr, VARIANT user_input, OBJECT condition)
{
  STRING match_type := condition->match_type;
  IF (match_type = "IN")
  {
    IF(TypeID(user_input) != TypeID(STRING ARRAY))
      THROW NEW Exception(`Matchtype 'IN' requires a string array value for enumeration attribute '${attr.tag}'`);
    IF(NOT condition->ignoreallowedvalues)
      FOREVERY(STRING val FROM user_input)
        IF(val !="" AND NOT IsAllowedEnumValue(val, attr.allowedvalues))
          THROW NEW Exception(`Value '${val}' is not an acceptable value for enumeration attribute '${attr.tag}'`);
    RETURN TRUE;
  }
  ELSE IF(match_type IN ['=','!='])
  {
    IF(TypeID(user_input) != TypeID(STRING))
      THROW NEW Exception(`Matchtype '${match_type}' requires a string value for enumeration attribute '${attr.tag}'`);
    IF(NOT condition->ignoreallowedvalues)
      IF(user_input != "" AND NOT IsAllowedEnumValue(user_input, attr.allowedvalues))
        THROW NEW Exception(`Value '${user_input}' is not an acceptable value for enumeration attribute '${attr.tag}'`);
    RETURN TRUE;
  }
  ELSE IF(match_type = "LIKE")
  {
    IF(TypeID(user_input) != TypeID(STRING))
      THROW NEW Exception(`Matchtype '${match_type}' requires a string value for enumeration attribute '${attr.tag}'`);
    // ADDME: check if at least one allowed value matches? could be expensive check.
    RETURN TRUE;
  }
  ELSE
    THROW NEW Exception(`The match type '${match_type}' is not allowed for attribute '${attr.tag}'`);
}

STATIC OBJECTTYPE WRDDBEnumSingleValue EXTEND WRDDBValue
<
  UPDATE PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN entity_settings[settings_start].rawdata;
  }
  UPDATE PUBLIC VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT STRING;
  }
  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    RETURN CheckEnumUserInput(this->attr, user_input, condition);
  }
>;
STATIC OBJECTTYPE WRDDBEnumMultipleValue EXTEND WRDDBValue
<
  UPDATE PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN Tokenize(entity_settings[settings_start].rawdata,'\t');
  }
  UPDATE PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    IF(condition->match_type = "=" AND Length(value)=0)
      RETURN TRUE;

    RETURN FALSE;
  }
  UPDATE PUBLIC VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT STRING ARRAY;
  }
  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];//FIXME
  }
  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type IN ["INTERSECTS", '=', '!='])
    {
      IF(TypeID(user_input) != TypeID(STRING ARRAY))
        THROW NEW Exception(`Matchtype 'IN' requires a string array value for enumeration attribute '${this->attr.tag}'`);
      IF(NOT condition->ignoreallowedvalues)
        FOREVERY(STRING val FROM user_input)
          IF(val !="" AND NOT IsAllowedEnumValue(val, this->attr.allowedvalues))
            THROW NEW Exception(`Value '${val}' is not an acceptable value for enumeration attribute '${this->attr.tag}'`);
      RETURN TRUE;
    }
    ELSE IF(match_type = "CONTAINS")
    {
      IF(TypeID(user_input) != TypeID(STRING))
        THROW NEW Exception(`Matchtype '${match_type}' requires a string value for enumeration attribute '${this->attr.tag}'`);
      IF(NOT condition->ignoreallowedvalues)
        IF(user_input != "" AND NOT IsAllowedEnumValue(user_input, this->attr.allowedvalues))
          THROW NEW Exception(`Value '${user_input}' is not an acceptable value for enumeration attribute '${this->attr.tag}'`);
      RETURN TRUE;
    }
    ELSE
      THROW NEW Exception(`The match type '${match_type}' is not allowed for attribute '${this->attr.tag}'`);
  }
>;

/// Object accessor for strings
STATIC OBJECTTYPE WRDDBStringValue EXTEND WRDDBValue
<
  /** Validate user input for validity
      @param match_type Matching type
      @param user_input User provided input
      @param match_case Whether case-matching was requested
      @return Whether the value is valid for this type.
  */
  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type = "IN")
    {
      IF (NOT IsTypeIDArray(TypeID(user_input)))
        RETURN FALSE;
      IF (LENGTH(user_input) = 0)
        RETURN TRUE;
      ELSE
        user_input := user_input[0];
    }

    IF (TypeID(user_input) != TypeID(STRING))
      RETURN FALSE;

    IF (match_type IN [ "CONTAINS", "MENTIONSANY", "__INRANGE" ])
      THROW NEW Exception(`The match type '${match_type}' is not allowed for attribute '${this->attr.tag}'`);

    // Default value is always illegal for mentions
    IF (match_type = "MENTIONS" AND user_input = "")
      RETURN FALSE;

    RETURN TRUE;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    IF (condition->match_type = "MENTIONS")
      RETURN FALSE; // Already checked by GetUserInput

    IF (NOT this->CheckUserInput(value, condition))
      THROW NEW Exception("Specified value is of the wrong type for this type of attribute");
    RETURN EvaluateConstraintWithSpecCase(this->GetDefaultValue(), condition->match_type, value, condition->match_case);
  }

  /** Returns the default value for this attribute type
  */
  UPDATE PUBLIC VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT STRING;
  }

  /** Decodes the attribute value from one or more entity settings
  */
  UPDATE PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN entity_settings[settings_start].rawdata;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype = "=" AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }
    IF (comparetype = "IN" OR comparetype = "MENTIONSANY") // The db can't handle IN for strings
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
    IF (LENGTH(STRING(value)) >= 4096) // The db can't handle 4096 bytes or longer strings anyway.
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    STRING dbcomparetype := comparetype;
    IF (comparetype = "MENTIONS")
      dbcomparetype := "=";

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);

    IF (match_case)
      query->AddConstraint(settings_source || ".rawdata", dbcomparetype, value);
    ELSE // dynamic query doesn't support IN for uppercase queries
      query->AddUppercaseConstraint(settings_source || ".rawdata", dbcomparetype, value);

    IF (comparetype = "MENTIONS")
    {
      RETURN
          [ canhandle :=  TRUE
          , canhandlepartially := FALSE
          , noresults :=  FALSE
          , tables :=     this->AddArrayParents(query, settings_source, this->attr.parent)
          ];
    }

    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

>;

STATIC OBJECTTYPE WRDDBRTValue EXTEND WRDDBValue //RelationTitle value
< INTEGER ARRAY orgtypeids;
  STRING sourcename;

  MACRO NEW(OBJECT type, RECORD attr, STRING sourcename)
  : WRDDBValue(type, attr)
  {
    this->orgtypeids := type->__GetOrgTypeIds();
    this->sourcename := sourcename;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle search within the queries, fallback to raw scan
    RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  UPDATE PUBLIC VARIANT FUNCTION GetValue(RECORD ARRAY attrdata, INTEGER attrdata_start, INTEGER attrdata_limit, RECORD row)
  {
    RECORD baserow := GetCell(row, this->sourcename);
    //FIXME it's probably not always __source0!
    IF(baserow.type IN this->orgtypeids)
      RETURN WRDDBValue::GetValue(attrdata, attrdata_start, attrdata_limit, row);
    ELSE
      RETURN this->attr.generator(baserow);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN "";
  }

  /** Decodes the attribute value from one or more entity settings
  */
  UPDATE PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN entity_settings[settings_start].rawdata;
  }
>;

/// Object accessor for booleans
STATIC OBJECTTYPE WRDDBBooleanValue EXTEND WRDDBValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT BOOLEAN;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN DecodeWRDAttribute(entity_settings[settings_start].rawdata, 16);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".rawdata", comparetype, EncodeWRDAttribute(BOOLEAN(value)).rawdata);
    ELSE
    {
      STRING ARRAY enc_values;
      FOREVERY (BOOLEAN v FROM value)
        INSERT EncodeWRDAttribute(v).rawdata INTO enc_values AT END;
      query->AddConstraint(settings_source || ".rawdata", "IN", enc_values);
    }
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := comparetype = "=" AND value = FALSE ];
  }
>;

/// Object accessor for integers
STATIC OBJECTTYPE WRDDBIntegerValue EXTEND WRDDBValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT INTEGER;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN DecodeWRDAttribute(entity_settings[settings_start].rawdata, 15);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    // Cannot do ordering on tostring-stored integers.
    IF (comparetype NOT IN [ "=", "!=", "IN" ])
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".rawdata", comparetype, EncodeWRDAttribute(INTEGER(value)).rawdata);
    ELSE
    {
      STRING ARRAY enc_values;
      FOREVERY (INTEGER v FROM value)
        INSERT EncodeWRDAttribute(v).rawdata INTO enc_values AT END;
      query->AddConstraint(settings_source || ".rawdata", "IN", enc_values);
    }
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }
>;

/// Object accessor for integer64's
STATIC OBJECTTYPE WRDDBInteger64Value EXTEND WRDDBValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT INTEGER64;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN DecodeWRDAttribute(entity_settings[settings_start].rawdata, 18);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    // Cannot do ordering on tostring-stored integers.
    IF (comparetype NOT IN [ "=", "!=", "IN" ])
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".rawdata", comparetype, EncodeWRDAttribute(INTEGER64(value)).rawdata);
    ELSE
    {
      STRING ARRAY enc_values;
      FOREVERY (INTEGER64 v FROM value)
        INSERT EncodeWRDAttribute(v).rawdata INTO enc_values AT END;
      query->AddConstraint(settings_source || ".rawdata", "IN", enc_values);
    }
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }
>;

STRING FUNCTION GetSharedIntegerPrefix(STRING range_from, STRING range_to)
{
  IF (LENGTH(range_from) != LENGTH(range_to)) // Not the same order of size (eg. 1 vs 10)?
    RETURN "";

  FOR (INTEGER i := LENGTH(range_from); i > 0; i := i - 1)
    IF (Left(range_from, i) = Left(range_to, i))
      RETURN Left(range_from, i);

  RETURN "";
}

STRING FUNCTION GetDateTimeSharedPrefix(STRING range_from, STRING range_to)
{
  STRING date_from := Tokenize(range_from, ",")[0];
  STRING date_to := Tokenize(range_to, ",")[0];

  STRING prefix := GetSharedIntegerPrefix(date_from, date_to);
  IF (prefix = date_from)
    prefix := GetSharedIntegerPrefix(range_from, range_to) ?? prefix || ",";

  RETURN prefix;
}

/// Object accessor for datetimes
STATIC OBJECTTYPE WRDDBDateTimeValue EXTEND WRDDBValue
< BOOLEAN isdatetime;

  MACRO NEW(OBJECT wrdtype, RECORD attr, BOOLEAN isdatetime) : WRDDBValue(wrdtype, attr)
  {
    this->isdatetime := isdatetime;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT DATETIME;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    IF (condition->match_type = "__INRANGE")
      RETURN TypeID(user_input) = TypeID(DATETIME ARRAY) AND LENGTH(user_input) = 2;

    RETURN WRDDBValue::CheckUserInput(user_input, condition);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    STRING rawdata := entity_settings[settings_start].rawdata;
    IF(this->isdatetime)
    {
      INTEGER colpos := SearchSubstring(rawdata,',');
      RETURN MakeDateFromParts(ToInteger(Left(rawdata, colpos), -1), ToInteger(Substring(rawdata, colpos+1), -1));
    }
    ELSE
    {
      RETURN MakeDateFromParts(ToInteger(Tokenize(rawdata,',')[0], -1), 0);
    }
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    // Cannot do ordering on tostring-stored integers.
    IF (comparetype NOT IN [ "=", "!=", "IN", "__INRANGE" ])
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    IF (comparetype = "__INRANGE")
    {
      STRING range_from := EncodeWRDAttribute(DATETIME(value[0])).rawdata;
      STRING range_to := EncodeWRDAttribute(DATETIME(value[1])).rawdata;

      // Can't compare, but a shared prefix will remove a lot of candidates
      STRING prefix;
      IF (value[0] <= value[1]) // valid range?
        prefix := GetDateTimeSharedPrefix(range_from, range_to);
      ELSE
        prefix := "NOMATCH"; // won't match any dates

      IF (prefix = "")
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

      query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
      query->AddConstraint(settings_source || ".rawdata", "LIKE", prefix || "*");
      RETURN [ canhandle := FALSE, canhandlepartially := TRUE, noresults := FALSE ];
    }

    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".rawdata", comparetype, EncodeWRDAttribute(DATETIME(value)).rawdata);
    ELSE
    {
      STRING ARRAY enc_values;
      FOREVERY (DATETIME v FROM value)
        INSERT EncodeWRDAttribute(v).rawdata INTO enc_values AT END;
      query->AddConstraint(settings_source || ".rawdata", "IN", enc_values);
    }
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }
>;

/// Object accessor for monies
STATIC OBJECTTYPE WRDDBMoneyValue EXTEND WRDDBValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT MONEY;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN DecodeWRDAttribute(entity_settings[settings_start].rawdata, 14);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    // Cannot do ordering on tostring-stored monies.
    IF (comparetype NOT IN [ "=", "!=", "IN" ])
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".rawdata", comparetype, EncodeWRDAttribute(MONEY(value)).rawdata);
    ELSE
    {
      STRING ARRAY enc_values;
      FOREVERY (DATETIME v FROM value)
        INSERT EncodeWRDAttribute(v).rawdata INTO enc_values AT END;
      query->AddConstraint(settings_source || ".rawdata", "IN", enc_values);
    }
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }
>;

/// Object accessor for images and files - TODO there's probably room for a RecordBasedValue so we can also test other recordbased types for existence
STATIC OBJECTTYPE WRDDBWrappedBlobValue EXTEND WRDDBValue
<
  OBJECT linkgetter;
  OBJECT whfsmapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBValue(type, attr)
  {
    this->linkgetter := options.linkgetter;
    this->whfsmapper := options.whfsmapper;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    IF(condition->match_type NOT IN [ '=', '!=' ])
      THROW NEW Exception(`Blob records only support '=' and '!=' tests`);
    IF(TYPEID(user_input) != TYPEID(RECORD))
      RETURN FALSE;
    IF(RecordExists(user_input))
      THROW NEW Exception(`Blob records can only be compared against DEFAULT RECORD`);
    RETURN TRUE;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    RETURN (condition->match_type = "=" AND NOT RecordExists(value))
           OR (condition->match_type = "!=" AND RecordExists(value));
  }

  PUBLIC UPDATE BOOLEAN FUNCTION ContainsOnlyDefaultValues(VARIANT value)
  {
    FOREVERY(VARIANT val FROM value)
      IF(RecordExists(val))
        RETURN FALSE;

    RETURN TRUE;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ]; // Can't do anything with images.
  }

  UPDATE PUBLIC BOOLEAN FUNCTION MatchFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit, STRING matchtype, VARIANT match_value, BOOLEAN match_case)
  {
    BOOLEAN hasvalue := settings_start != settings_limit;
    BOOLEAN wantvalue := RecordExists(match_value);

    IF(matchtype = "=")
      RETURN hasvalue = wantvalue;
    ELSE IF(matchtype = "!=")
      RETURN hasvalue != wantvalue;
    ELSE
      THROW NEW Exception(`Unexpected match type '${matchtype}'`);
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "rawdata", "blobdata", "id" ]);
  }
>;

/// Object accessor for images
STATIC OBJECTTYPE WRDDBImageValue EXTEND WRDDBWrappedBlobValue
<
  RECORD wrapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBWrappedBlobValue(type, attr, options)
  {
    this->wrapper := options.wrapper;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RECORD image := GetWrappedObjectFromWRDSetting(entity_settings[settings_start], FALSE, this->linkgetter, this->whfsmapper);
    IF(RecordExists(this->wrapper))
      image := WrapCachedImage(image, this->wrapper.resizemethod);
    RETURN image;
  }
>;

/// Object accessor for files
STATIC OBJECTTYPE WRDDBFileValue EXTEND WRDDBWrappedBlobValue
<
  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN GetWrappedObjectFromWRDSetting(entity_settings[settings_start], TRUE, this->linkgetter, this->whfsmapper);
  }
>;

STATIC OBJECTTYPE WRDDBLinkValueBase EXTEND WRDDBValue
<
>;

/// Object accessor for single links
STATIC OBJECTTYPE WRDDBLinkValue EXTEND WRDDBLinkValueBase
< UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type = "IN")
    {
      IF (LENGTH(user_input) = 0 AND IsTypeidArray(TypeID(user_input)))
        RETURN TRUE;
      ELSE
        user_input := user_input[0];
    }

    IF (match_type = "MENTIONS" AND user_input = 0)
      THROW NEW Exception("The value '0' is not allowed for matchtype 'MENTIONS'");

    IF (match_type = "MENTIONSANY")
    {
      IF(TypeID(user_input)!=TypeID(INTEGER ARRAY))
        RETURN FALSE;
      IF(0 IN user_input)
        THROW NEW Exception("The value '0' is not allowed for matchtype 'MENTIONSANY'");
      RETURN TRUE;
    }

    IF (match_type IN [ "__INRANGE" ])
      THROW NEW Exception(`The match type '${match_type}' is not allowed for attribute '${this->attr.tag}'`);

    INTEGER user_type := TypeID(user_input);
    RETURN user_type = TypeID(this->GetDefaultValue());
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT INTEGER;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    //print(comparetype||'\n');
    IF(condition->match_type="MENTIONS" OR condition->match_type="MENTIONSANY")
      RETURN FALSE;
    RETURN WRDDBValue::MatchesDefault(value, condition);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN entity_settings[settings_start].setting;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition))
    {
      IF (NOT ignore_default_also_match)
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
      IF (comparetype IN [ "MENTIONS", "MENTIONSANY", "=", "IN" ] AND this->ContainsOnlyDefaultValues(value))
        RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := TRUE ];
    }

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF(comparetype = "MENTIONS")
      query->AddConstraint(settings_source || ".setting", "=", INTEGER(value));
    ELSE IF(comparetype = "MENTIONSANY")
      query->AddConstraint(settings_source || ".setting", "IN", INTEGER ARRAY(value));
    ELSE IF (comparetype != "IN")
      query->AddConstraint(settings_source || ".setting", comparetype, INTEGER(value));
    ELSE
      query->AddConstraint(settings_source || ".setting", "IN", INTEGER ARRAY(value));

    IF (comparetype IN [ "MENTIONS", "MENTIONSANY" ])
    {
      RETURN
          [ canhandle :=  TRUE
          , canhandlepartially := FALSE
          , noresults :=  FALSE
          , tables :=     this->AddArrayParents(query, settings_source, this->attr.parent)
          ];
    }

    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "setting" ]);
  }
>;

/// Object accessor for multiple links
STATIC OBJECTTYPE WRDDBLinksValue EXTEND WRDDBLinkValueBase
< PUBLIC UPDATE BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type = "CONTAINS")
    {
      IF(TypeId(user_input) != TypeID(INTEGER))
        RETURN FALSE;
      RETURN TRUE;
    }
    IF (match_type = "INTERSECTS")
    {
      IF(TypeId(user_input) != TypeID(INTEGER ARRAY))
        RETURN FALSE;
      IF(0 IN user_input)
        THROW NEW Exception("INTERSECTS cannot be used to look for '0' in a multiple link field");
      RETURN TRUE;
    }

    IF (match_type = "MENTIONS")
    {
      IF (user_input = 0)
        THROW NEW Exception("The value '0' is not allowed for matchtype 'MENTIONS'");
      RETURN TRUE;
    }

    IF (match_type = "MENTIONSANY")
    {
      IF(TypeID(user_input)!=TypeID(INTEGER ARRAY))
        RETURN FALSE;
      IF(0 IN user_input)
        THROW NEW Exception("The value '0' is not allowed for matchtype 'MENTIONSANY'");
      RETURN TRUE;
    }

    IF (match_type NOT IN [ "=", "!=" ])
      THROW NEW Exception("Multiple domain links can't use any compare type other than '=', '!=', 'INTERSECTS', 'CONTAINS', 'MENTIONS' and 'MENTIONSANY'");

    RETURN TypeID(user_input)=TypeID(INTEGER ARRAY);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT INTEGER ARRAY;
  }

  UPDATE PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    //print(comparetype||'\n');
    IF(condition->match_type ="MENTIONS" OR condition->match_type ="MENTIONSANY")
      RETURN FALSE;
    RETURN WRDDBValue::MatchesDefault(value, condition);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    INTEGER ARRAY settings;
    FOR (INTEGER i := settings_start; i < settings_limit; i := i + 1)
      INSERT entity_settings[i].setting INTO settings AT END;
    RETURN settings;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    IF (comparetype NOT IN [ "CONTAINS", "MENTIONS", "MENTIONSANY" ])
    {
      // Can't express a multiple link match in SQL (at least, not in this framework)
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
    }

    // Assume that all values are unique
    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF(comparetype = "MENTIONS")
      query->AddConstraint(settings_source || ".setting", "=", INTEGER(value));
    ELSE IF(comparetype = "MENTIONSANY")
      query->AddConstraint(settings_source || ".setting", "IN", INTEGER ARRAY(value));
    ELSE // CONTAINS
      query->AddConstraint(settings_source || ".setting", "=", INTEGER(value));

    IF (comparetype IN [ "MENTIONS", "MENTIONSANY" ])
    {
      RETURN
          [ canhandle :=  TRUE
          , canhandlepartially := FALSE
          , noresults :=  FALSE
          , tables :=     this->AddArrayParents(query, settings_source, this->attr.parent)
          ];
    }

    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "setting" ]);
  }
>;

STATIC OBJECTTYPE WRDDBPasswordValue EXTEND WRDDBValue
< PUBLIC UPDATE BOOLEAN FUNCTION Match(VARIANT dbval, STRING match_type, VARIANT match_value, BOOLEAN match_case)
  {
    IF(match_value = "")
      RETURN (dbval = "") = (match_type = "="); //
    ELSE
      RETURN VerifyWebHarePasswordHash(match_value, dbval) = (match_type = "=");
  }

  PUBLIC UPDATE BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type NOT IN ["!=","="])
      RETURN FALSE;
    IF(TypeID(user_input) != TypeId(STRING))
      RETURN FALSE;

    RETURN TRUE;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN "";
  }

  /** Decodes the attribute value from one or more entity settings
  */
  UPDATE PUBLIC VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF (IsValueSet(entity_settings[settings_start].blobdata) OR entity_settings[settings_start].rawdata LIKE "hson:*")
    {
      // authentication settings, get current password (last one)
      RECORD settings := IsValueSet(entity_settings[settings_start].rawdata)
          ? DecodeHSON(entity_settings[settings_start].rawdata)
          : DecodeHSONBlob(entity_settings[settings_start].blobdata);

      RETURN IsValueSet(settings.passwords) ? settings.passwords[END-1].passwordhash : "";
    }

    RETURN entity_settings[settings_start].rawdata;
  }

  PUBLIC UPDATE BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    //only ="" will match against the default, the default being 'no password'
    RETURN value = "" AND condition->match_type = "=";
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    // Since backconversion from authentication settings, we need to parse the db value to get the password
    RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT dynquery, STRING settings_source)
  {
    dynquery->RequestAdditionalColumns(settings_source, [ "rawdata", "blobdata" ]);
  }
>;

STATIC OBJECTTYPE WRDDBAddressValue EXTEND WRDDBValue
< STRING language;
  OBJECT wrd_schema;

  MACRO NEW(OBJECT wrd_type, RECORD attr)
  : WRDDBValue(wrd_type, attr)
  {
    this->wrd_schema := wrd_type->wrdschema;
    this->language := this->wrd_schema->__GetCurrentLanguageCode();
  }

  PUBLIC UPDATE BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    STRING match_type := condition->match_type;
    IF (match_type != "LIKE")
      RETURN FALSE;
    IF(TypeID(user_input) != TypeId(STRING))
      RETURN FALSE;

    RETURN TRUE;
  }

  PUBLIC UPDATE BOOLEAN FUNCTION ContainsOnlyDefaultValues(VARIANT value)
  {
    RETURN FALSE;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN GenerateAddress(entity_settings[settings_start].rawdata, this->language, this->wrd_schema->id, NOT this->wrd_schema->__iswrdapi2017);
//      RETURN ParseAddressRawdata(entity_settings[settings_start].rawdata);
  }

  PUBLIC UPDATE BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    RETURN EvaluateConstraintWithSpecCase("", condition->match_type, value, condition->match_case);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value, condition) AND NOT ignore_default_also_match)
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    IF (LENGTH(STRING(value)) >= 4096)
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    IF (match_case)
      query->AddConstraint(settings_source || ".rawdata", comparetype, value);
    ELSE // dynamic query doesn't support IN for uppercase queries
      query->AddUppercaseConstraint(settings_source || ".rawdata", comparetype, value);
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT dynquery, STRING settings_source)
  {
    dynquery->RequestAdditionalColumns(settings_source, [ "rawdata" ]);
  }
>;

/// Object accessor for arrays
STATIC OBJECTTYPE WRDDBArrayValue EXTEND WRDDBValue
< RECORD ARRAY fields;
  INTEGER ARRAY attrids;

  MACRO NEW(OBJECT wrd_type, RECORD attr, RECORD options)
  : WRDDBValue(wrd_type, attr)
  {
    RECORD ARRAY subattrs := SELECT * FROM wrd_type->__final_attrs WHERE __final_attrs.parent = attr.id;
    FOREVERY (RECORD subattr FROM subattrs)
    {
      INSERT
          [ rename :=     subattr.localtag
          , attribute :=  subattr.id
          , accessor :=   GetAccessorForAttributeType(subattr, wrd_type, options)
          , subselect :=  DEFAULT STRING ARRAY
          ] INTO this->fields AT END;
      INSERT subattr.id INTO this->attrids AT END;
    }
    this->fields := SELECT * FROM this->fields ORDER BY attribute;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD ARRAY;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    DATETIME now := GetCurrentDateTime();

    INTEGER ARRAY parent_settings;
    RECORD ARRAY rows;
    FOR (INTEGER i := settings_start; i <settings_limit; i := i + 1)
    {
      INTEGER settingid := entity_settings[i].id;
      INSERT settingid INTO parent_settings AT END;

      RECORD ARRAY enrichrow :=
          [ [ __entity := entity_settings[i].entity
            , data := [ wrd_settingid := settingid ]
            , __order :=  i
            ]
          ];

      enrichrow := EnrichRows(
            enrichrow,
            this->fields,
            entity_settings,
            [ parentsetting := settingid
            , entity := entity_settings[i].entity
            ],
            [ "PARENTSETTING", "ENTITY" ]);

      INSERT enrichrow[0].data INTO rows AT END;
    }

    RETURN rows;
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    THROW NEW Exception("Cannot compare arrays");
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "ordering" ]);
    FOREVERY (RECORD field FROM this->fields)
      field.accessor->RequestNeededColumns(query, settings_source);
  }

  UPDATE PUBLIC INTEGER ARRAY FUNCTION GetAllAttributeIds()
  {
    INTEGER ARRAY result := [ INTEGER(this->attr.id) ];
    FOREVERY (RECORD field FROM this->fields)
      result := result CONCAT field.accessor->GetAllAttributeIds();
    RETURN result;
  }
>;

STATIC OBJECTTYPE WRDDBIncomparableValue EXTEND WRDDBValue
<
  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    THROW NEW Exception(`Comparison of values of type ${GetAttributeTypeNameByTypeId(this->attr.attributetype)} has not been implemented yet`);
  }
  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    THROW NEW Exception(`Comparison of values of type ${GetAttributeTypeNameByTypeId(this->attr.attributetype)} has not been implemented yet`);
  }
>;

/// Object accessor for rich documents
STATIC OBJECTTYPE WRDDBRichDocumentValue EXTEND WRDDBIncomparableValue
<
  OBJECT linkgetter;
  OBJECT whfsmapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBIncomparableValue(type, attr)
  {
    this->linkgetter := options.linkgetter;
    this->whfsmapper := options.whfsmapper;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    INTEGER ARRAY parent_settings;
    RECORD ARRAY rows;
    FOR (INTEGER i := settings_start; i < settings_limit; i := i + 1)
    {
      INSERT entity_settings[i] INTO rows AT END;
    }

    RETURN ReadWRDRichDocument(rows, this->linkgetter, this->whfsmapper);
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "ordering", "rawdata", "blobdata" ]);
  }
>;

STATIC OBJECTTYPE WRDDBRecordValue EXTEND WRDDBIncomparableValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF(settings_start = settings_limit)
      RETURN DEFAULT RECORD;

    VARIANT data := entity_settings[settings_start].rawdata != "" ? DecodeHSON(entity_settings[settings_start].rawdata) : DecodeHSONBlob(entity_settings[settings_start].blobdata);
    IF(TypeID(data) != TypeID(RECORD))
      THROW NEW Exception(`Entity setting #${entity_settings[settings_start].id} incorrectly contains a non-record value`);
    RETURN data;
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata", "blobdata" ]);
  }
>;

STATIC OBJECTTYPE WRDDBStatusRecordValue EXTEND WRDDBValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE BOOLEAN FUNCTION MatchFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit, STRING match_type, VARIANT match_value, BOOLEAN match_case)
  {
    //We shortcircuit the match implementation so we don't unnecessarily try to decode a blob value
    STRING dbval;
    IF(settings_start != settings_limit)
    {
      STRING rawdata := entity_settings[settings_start].rawdata;
      dbval := Left(rawdata, Searchsubstring(rawdata,'\t'));
    }
    RETURN EvaluateConstraintWithSpecCase(dbval, match_type, match_value, match_case);
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF(settings_start = settings_limit)
      RETURN DEFAULT RECORD;

    STRING rawdata := entity_settings[settings_start].rawdata;
    INTEGER tab := Searchsubstring(rawdata,'\t');
    IF(tab < 0)
      RETURN DEFAULT RECORD;

    STRING status := Left(rawdata,tab);
    VARIANT data := Length(rawdata) > tab + 1 ? DecodeHSON(Substring(rawdata,tab+1)) : DecodeHSONBlob(entity_settings[settings_start].blobdata);
    IF(TypeID(data) != TypeID(RECORD))
      THROW NEW Exception(`Entity setting #${entity_settings[settings_start].id} incorrectly contains a non-record value`);

    RETURN CELL[...data, status];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata", "blobdata" ]);
  }

  UPDATE PUBLIC BOOLEAN FUNCTION CheckUserInput(VARIANT user_input, OBJECT condition)
  {
    RETURN CheckEnumUserInput(this->attr, user_input, condition);
  }
  UPDATE PUBLIC BOOLEAN FUNCTION MatchesDefault(VARIANT value, OBJECT condition)
  {
    RETURN EvaluateConstraintWithSpecCase("", condition->match_type, value, condition->match_case);
  }
  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];//FIXME
  }
  //TODO TryAddToDBQuery - mostly whatever EnumSIngle will do
>;

STATIC OBJECTTYPE WRDDBInstanceValue EXTEND WRDDBIncomparableValue
<
  OBJECT linkgetter;
  OBJECT whfsmapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBIncomparableValue(type, attr)
  {
    this->linkgetter := options.linkgetter;
    this->whfsmapper := options.whfsmapper;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF(settings_start = settings_limit)
      RETURN DEFAULT RECORD;

    IF (ObjectExists(this->linkgetter))
      RETURN this->linkgetter->GetInstance(entity_settings[settings_start].id, this->whfsmapper);

    RETURN ReadWRDWHFSInstance(entity_settings[settings_start], this->whfsmapper);
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata" ]);
  }
>;

STATIC OBJECTTYPE WRDDBPaymentProviderValue EXTEND WRDDBRecordValue
<
  OBJECT linkgetter;
  OBJECT whfsmapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBRecordValue(type, attr)
  {
    this->linkgetter := options.linkgetter;
    this->whfsmapper := options.whfsmapper;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RECORD val := WRDDBRecordValue::GetFromRecord(entity_settings, settings_start, settings_limit);
    IF(RecordExists(val))
    {
      VARIANT keypair := ObjectExists(this->linkgetter)
          ? this->linkgetter->GetLink(entity_settings[settings_start].id)
          : SELECT AS INTEGER fsobject FROM wrd.entity_settings_whfslink WHERE id = entity_settings[settings_start].id;
      IF (NOT IsDefaultValue(this->whfsmapper))
        keypair := this->whfsmapper->MapWHFSRef(keypair);
      val.meta := CELL[...val.meta, keypair ];
      RETURN [ __paymentprovider := val ];
    }
    RETURN val;
  }
>;

STATIC OBJECTTYPE WRDDBPaymentValue EXTEND WRDDBIncomparableValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN CreatePaymentRecord(RECORD[]);
  }
  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RECORD ARRAY recs;
    FOR(INTEGER setting := settings_start; setting < settings_limit; setting := setting + 1)
    {
      VARIANT data := entity_settings[setting].rawdata != "" ? DecodeHSON(entity_settings[setting].rawdata) : DecodeHSONBlob(entity_settings[setting].blobdata);
      IF(TypeID(data) != TypeID(RECORD))
        THROW NEW Exception(`Entity setting #${entity_settings[setting].id} incorrectly contains a non-record value`);

      INSERT CELL[ ...data, provider := entity_settings[setting].setting, __ordering := entity_settings[setting].ordering ] INTO recs AT END;
    }
    recs := SELECT *, DELETE __ordering FROM recs ORDER BY __ordering;
    RETURN CreatePaymentRecord(recs);
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata", "blobdata", "setting" ]);
  }
>;
STATIC OBJECTTYPE WRDDBIntExtLinkValue EXTEND WRDDBIncomparableValue
<
  OBJECT linkgetter;
  OBJECT whfsmapper;

  MACRO NEW(OBJECT type, RECORD attr, RECORD options)
  : WRDDBIncomparableValue(type, attr)
  {
    this->linkgetter := options.linkgetter;
    this->whfsmapper := options.whfsmapper;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF(settings_start = settings_limit)
      RETURN DEFAULT RECORD;

    RETURN ReadWRDWHFSIntExtLink(entity_settings[settings_start], this->linkgetter, this->whfsmapper);
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata" ]);
  }
>;

STATIC OBJECTTYPE WRDDBAuthenticationSettingsValue EXTEND WRDDBIncomparableValue
< PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    RETURN DEFAULT RECORD;
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    IF(settings_start = settings_limit)
      RETURN DEFAULT RECORD;

    // If the data doesn't start with `hson:` we'll assume it is a converted password
    VARIANT data;
    IF (entity_settings[settings_start].rawdata != "")
    {
      IF (entity_settings[settings_start].rawdata NOT LIKE "hson:*")
        RETURN CreateAuthenticationSettingsFromPasswordHash(entity_settings[settings_start].rawdata, [ validfrom := DEFAULT DATETIME ]);
      data := DecodeHSON(entity_settings[settings_start].rawdata);
    }
    ELSE
    {
      IF (BlobToString(entity_settings[settings_start].blobdata, 5) != "hson:")
        RETURN CreateAuthenticationSettingsFromPasswordHash(BlobToString(entity_settings[settings_start].blobdata), [ validfrom := DEFAULT DATETIME ]);
      data := DecodeHSONBlob(entity_settings[settings_start].blobdata);
    }
    IF(TypeID(data) != TypeID(RECORD))
      THROW NEW Exception(`Entity setting #${entity_settings[settings_start].id} incorrectly contains a non-record value`);
    RETURN data;
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ "id", "rawdata", "blobdata" ]);
  }
>;

/// Object accessor for attribute metadata (#ordering)
STATIC OBJECTTYPE WRDDBAttributeMetadataValue EXTEND WRDDBVALUE
< // --------------------------------------------------------------------------
  //
  // Variables
  //

  /// Name of the field (in uppercase)
  STRING field;

  // --------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT type, STRING field, RECORD attr)
  : WRDDBValue(type, attr)
  {
    this->field := field;
  }

  // --------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC UPDATE VARIANT FUNCTION GetDefaultValue()
  {
    SWITCH (this->field)
    {
    CASE "ORDERING"     { RETURN 0; }
    DEFAULT             { THROW NEW Exception(`Illegal attribute metadata fieldname '${this->field}`); }
    }
  }

  PUBLIC UPDATE VARIANT FUNCTION GetFromRecord(RECORD ARRAY entity_settings, INTEGER settings_start, INTEGER settings_limit)
  {
    RETURN GetCell(entity_settings[settings_start], this->field);
  }

  UPDATE PUBLIC RECORD FUNCTION TryAddToDBQuery(OBJECT query, STRING settings_source, VARIANT value, OBJECT condition, BOOLEAN ignore_default_also_match)
  {
    STRING comparetype := condition->match_type;
    BOOLEAN match_case := condition->match_case;
    BOOLEAN ignoreallowedvalues := condition->ignoreallowedvalues;

    // Can't handle when default also matches
    IF (this->MatchesDefault(value,condition) AND NOT ignore_default_also_match)
      RETURN [ canhandle := FALSE, canhandlepartially := FALSE, noresults := FALSE ];

    INTEGER transaction := GetBindingFromTable(wrd.types).transaction;
    query->AddDeclaredTable(settings_source, wrd.entity_settings, DEFAULT STRING ARRAY);
    query->AddConstraint(settings_source || "." || this->field, comparetype, value);
    RETURN [ canhandle := TRUE, canhandlepartially := FALSE, noresults := FALSE ];
  }

  PUBLIC UPDATE MACRO RequestNeededColumns(OBJECT query, STRING settings_source)
  {
    query->RequestAdditionalColumns(settings_source, [ ToLowercase(this->field) ]);
  }
>;

// ----------------------------------------------------------------------------
//
//   Helper functions
//

RECORD FUNCTION ApplyReturnMap(RECORD ARRAY return_map, RECORD __data)
{
  RECORD retval := CELL[];
  FOREVERY(RECORD rec FROM return_map)
  {
    VARIANT thisval;
    IF(rec.attr = "")
      thisval := ApplyReturnMap(rec.submap, __data);
    ELSE
      thisval := GetCell(__data, rec.attr);
    retval := CellInsert(retval, rec.name, thisval);
  }
  RETURN retval;
}

BOOLEAN FUNCTION IsCaseRelevant(RECORD attr)
{
  RETURN attr.attributetype IN [ 0, 2, 3/*address*/, 4, 5 ];
}

BOOLEAN FUNCTION EvaluateConstraint(VARIANT left, STRING condition_type, VARIANT right)
{
  IF (TypeId(left) = TypeId(INTEGER ARRAY) AND condition_type IN ["=","!="])
  {
    left := SortArray(left);
    right := SortArray(right);
    BOOLEAN is_equal := LENGTH(left) = LENGTH(right);
    IF (is_equal)
    {
      FOREVERY (INTEGER i FROM left)
        IF (i != right[#i])
        {
          is_equal := FALSE;
          BREAK;
        }
    }
    RETURN condition_type != "=" XOR is_equal;
  }

  SWITCH (condition_type)
  {
    CASE "="    { RETURN left = right; }
    CASE "!="   { RETURN left != right; }
    CASE "<"    { RETURN left < right; }
    CASE ">"    { RETURN left > right; }
    CASE "<="   { RETURN left <= right; }
    CASE ">="   { RETURN left >= right; }
    CASE "IN"   { RETURN left IN right; }
    CASE "LIKE" { RETURN left LIKE right; }
    CASE "CONTAINS" { RETURN right IN left; }
    CASE "INTERSECTS" { FOREVERY(VARIANT leftval FROM left) IF (leftval IN right) RETURN TRUE; RETURN FALSE; }
    CASE "__INRANGE" { RETURN left >= right[0] AND left <= right[1]; }
  }
  THROW NEW Exception("Illegal condition type '" || condition_type || "'");
}

// Right MUST be uppercased for case-insensitive queries!
BOOLEAN FUNCTION EvaluateConstraintWithSpecCase(VARIANT left, STRING condition_type, VARIANT right, BOOLEAN match_case)
{
  IF (NOT match_case)
    left := ToUppercase(left);

  RETURN EvaluateConstraint(left, condition_type, right);
}

PUBLIC OBJECT FUNCTION GetAccessorForAttributeType(RECORD attrinfo, OBJECT wrd_type, RECORD options)
{
  IF (CellExists(attrinfo, "__METADATAFIELD"))
    RETURN NEW WRDDBAttributeMetadataValue(wrd_type, attrinfo.__metadatafield, attrinfo);

  INTEGER attributetype := attrinfo.attributetype;

  SWITCH (attributetype)
  {
  CASE 1 /* single select*/
    { RETURN NEW WRDDBLinkValue(wrd_type, attrinfo); }

  CASE 8 /* multiple select */
    { RETURN NEW WRDDBLinksValue(wrd_type, attrinfo); }

  CASE 2 /* free text */
     , 4 /* Email */
     , 5 /* Telephone  */
     , 21 /* URL */
    { RETURN NEW WRDDBStringValue(wrd_type, attrinfo); }

  CASE 7 /* Password */
    { RETURN NEW WRDDBPasswordValue(wrd_type, attrinfo); }

  CASE 3 /* Address */
    { RETURN NEW WRDDBAddressValue(wrd_type, attrinfo); }

  CASE 6 /* Date and/or time types */
     , 12 /* datetime */
    { RETURN NEW WRDDBDateTimeValue(wrd_type, attrinfo, attributetype = 12); }

  CASE 9 /* Image */
    { RETURN NEW WRDDBImageValue(wrd_type, attrinfo, options); }

  CASE 10 /* File */
    { RETURN NEW WRDDBFileValue(wrd_type, attrinfo, options); }

  CASE 11 /* Date and/or time types */
     , 15 /* Integer */
    { RETURN NEW WRDDBIntegerValue(wrd_type, attrinfo); }

  CASE 13 /* Array */
    { RETURN NEW WRDDBArrayValue(wrd_type, attrinfo, options); }

  CASE 14 /* Money */
    { RETURN NEW WRDDBMoneyValue(wrd_type, attrinfo); }

  CASE 16 /* Boolean */
    { RETURN NEW WRDDBBooleanValue(wrd_type, attrinfo); }

  CASE 17
    { RETURN NEW WRDDBRichDocumentValue(wrd_type, attrinfo, options); }

  CASE 18 /* Integer64 */
    { RETURN NEW WRDDBInteger64Value(wrd_type, attrinfo); }

  CASE 19 /* Instance */
    { RETURN NEW WRDDBInstanceValue(wrd_type, attrinfo, options); }

  CASE 20 /* IntExtLink */
    { RETURN NEW WRDDBIntExtLinkValue(wrd_type, attrinfo, options); }

  CASE 22 /* RECORD */
    { RETURN NEW WRDDBRecordValue(wrd_type, attrinfo); }

  CASE 23 //ENUM
    { RETURN NEW WRDDBEnumSingleValue(wrd_type, attrinfo); }
  CASE 24 //ENUMARRAY
    { RETURN NEW WRDDBEnumMultipleValue(wrd_type, attrinfo); }

  CASE 25 /* PAYMENTMETHOD */
    { RETURN NEW WRDDBPaymentProviderValue(wrd_type, attrinfo, options); }
  CASE 26 /* PAYMENT */
    { RETURN NEW WRDDBPaymentValue(wrd_type, attrinfo); }
  CASE 27 /* STATUSRECORD */
    { RETURN NEW WRDDBStatusRecordValue(wrd_type, attrinfo); }
  CASE 28 /* AUTHENTICATIONSETTINGS */
    { RETURN NEW WRDDBAuthenticationSettingsValue(wrd_type, attrinfo); }

  DEFAULT
    { THROW NEW Exception(`Type ${GetAttributeTypeNameByTypeId(attributetype)} has not been implemented in the query interface yet`); }
  }
}


// ----------------------------------------------------------------------------
//
//   Query parser
//

RECORD ARRAY FUNCTION ProcessParameters(RECORD ARRAY parameters, BOOLEAN strict)
{
  RECORD ARRAY processed_parameters;

  // Parameters
  RECORD parsed_parameters;
  FOREVERY (RECORD param FROM parameters)
  {
    STRING name := param.name;
    STRING title := CellExists(param, "TITLE") ? param.title : param.name;
    STRING subtype := CellExists(param, "SUBTYPE") ? param.subtype : "";
    INTEGER type := GetAttributeTypeIdByTypeName(param.type, strict);
    RECORD p :=
        [ name := name
        , type := type
        , subtype := subtype
        , ordering := #param + 1
        , title := title
        , presentation_function := DEFAULT FUNCTION PTR
        ];

    SWITCH (type)
    {
    CASE 11, 14, 15, 18 // integer(64) + money
      {
        IF (CellExists(param, "VALUESTART"))
          INSERT CELL valuestart := param.valuestart INTO p;
        IF (CellExists(param, "VALUELIMIT"))
          INSERT CELL valuelimit := param.valuelimit INTO p;
        IF (CellExists(param, "VALUEDEFAULT"))
          INSERT CELL valuedefault := param.valuedefault INTO p;
        IF (subtype != "")
          THROW NEW Exception("No subtype allowed for attribute type " || param.type);
      }
    CASE 2,4,5 //string, email, phone
      {
        IF (subtype != "")
          THROW NEW Exception("No subtype allowed for attribute type " || param.type);
        IF (CellExists(param, "VALUEDEFAULT"))
          INSERT CELL valuedefault := STRING(param.valuedefault) INTO p;
      }
    CASE 16 //boolean
      {
        IF (subtype != "")
          THROW NEW Exception("No subtype allowed for attribute type " || param.type);
        IF (CellExists(param, "VALUEDEFAULT"))
          INSERT CELL valuedefault := BOOLEAN(param.valuedefault) INTO p;
      }
    CASE 1 // domain
      {
        INSERT CELL domaintype := param.domaintype INTO p;
        IF (subtype != "")
          THROW NEW Exception("No subtype allowed for attribute type " || param.type);
        RECORD ARRAY filters;
        IF (CellExists(param, "FILTERS"))
          filters := param.filters;
        INSERT CELL filters := filters INTO p;
        FUNCTION PTR presentation_function;
        IF (CellExists(param, "PRESENTATION_FUNCTION"))
          p.presentation_function := param.presentation_function;
      }
    CASE 6, 12
      {
        IF (subtype = "list")
        {
          RECORD ARRAY valuelist := param.valuelist;
          IF (RecordExists(valuelist) AND NOT CellExists(valuelist, "ROWKEY"))
          {
            FOREVERY (RECORD rec FROM valuelist)
              INSERT CELL rowkey := #rec + 1 INTO valuelist[#rec];
          }
          FOREVERY (RECORD value FROM valuelist)
          {
            IF (NOT CellExists(value, "valuestart"))
            {
              INSERT CELL valuestart := value.value INTO valuelist[#value];
              INSERT CELL valuelimit := AddTimeToDate(1, value.value) INTO valuelist[#value];
            }
          }

          IF (CellExists(param, "VALUEDEFAULT"))
          {
            IF (NOT RecordExists(SELECT FROM valuelist WHERE rowkey = param.valuedefault))
              THROW NEW Exception("The default of parameter "||param.name||" does not exist");
          }

          INSERT CELL valuelist := valuelist INTO p;
          INSERT CELL valuedefault := param.valuedefault INTO p;
        }
        ELSE
        {
          IF (subtype = "year")
          {
            INTEGER startmonth := CellExists(param, "STARTMONTH") ? param.startmonth : 1;
            INTEGER startday := CellExists(param, "STARTDAY") ? param.startday : 1;

            INSERT CELL startmonth := startmonth INTO p;
            INSERT CELL startday := startday INTO p;
          }
          ELSE IF (subtype != "")
            THROW NEW Exception("Illegal subtype '" || subtype ||  "' for attribute type " || param.type);

          IF (CellExists(param, "VALUESTART"))
            INSERT CELL valuestart := param.valuestart INTO p;
          IF (CellExists(param, "VALUELIMIT"))
            INSERT CELL valuelimit := param.valuelimit INTO p;
          IF (CellExists(param, "VALUEDEFAULT"))
            INSERT CELL valuedefault := param.valuedefault INTO p;
        }
      }
    DEFAULT
      {
        THROW NEW Exception("Unsupported parameter type: " || param.type);
      }
    }
    INSERT p INTO processed_parameters AT END;
  }
  RETURN processed_parameters;
}

RECORD FUNCTION GetDefaultRecordForSource(OBJECT querysource)
{
  RECORD accessors := querysource->CreateAccessors();

  RECORD data := GenerateBaseFields(accessors.base_fields, default_entity);
  FOREVERY (RECORD field FROM accessors.fields)
  {
    VARIANT val := field.accessor->GetDefaultValue();
    val := ApplySubSelect(val, field);
    data := CellInsert(data, field.rename, val);
  }

  RETURN ApplyReturnMap(querysource->return_map, data);
}

PUBLIC RECORD FUNCTION GetDefaultJoinRecord(OBJECT wrdtype, RECORD outputcolumns, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ whfsmapper :=   DEFAULT OBJECT
      ], options);

  OBJECT obj := NEW WRDQuerySource(wrdtype, options.whfsmapper);
  obj->return_map := obj->RecurseGetoutputColumns(outputcolumns);
  RETURN GetDefaultRecordForSource(obj);
}

/** Constructs a WRD query
    @param querydata Query specification
    @cell querydata.sources Query sources
    @cell(string) querydata.sources.name Name for referring to this source
    @cell(object %WRDType2017) querydata.sources.type Type (can be a STRING with a tag when a wrdschema has been specified)
    @cell(integer array) querydata.sources.typefilter If specified, return only entities that have one of these types
    @cell querydata.sources.outputcolumns Columns to output. Can be a STRING ARRAY with the tags of the attributes to select, or a RECORD (of the form `[ outputname := "ATTRIBUTENAME", outputsubrecord := [ subattr := "ATTRIBUTENAME" ] ]`). Mutually exclusive with 'outputcolumn'
    @cell(record array) querydata.sources.filters Query filters to apply to the query
    @cell(string) querydata.sources.filters.type Type of the filter. Allowed: 'AND', 'OR', 'NOT', FREE', 'DOMAIN'. Defaults to 'VALUE'.
    @cell(record array) querydata.sources.filters.filters Subfilters (only for type 'AND', 'OR')
    @cell(record) querydata.sources.filters.filter Filter to negate (only for type 'NOT')
    @cell(string) querydata.sources.filters.field Tag of the attribute to filter on
    @cell(string) querydata.sources.filters.matchtype Type of matching to do. Allowed: '=', '!=', '>=', '>', '<=', '<', 'IN', 'LIKE', 'CONTAINS', 'MENTIONS', 'MENTIONSANY', '__INRANGE'. Defaults to '=' or 'IN', depending on whether the value is an array.
    @cell(record array) querydata.sources.filters.value Value to match on.
    @cell(string) querydata.sources.filters.value_p If specified, get the value from a query parameter with the specified name
    @cell(boolean) querydata.sources.filters.matchcase Whether to match case. Defaults to FALSE when case is relevant for this field.
    @cell(boolean) querydata.sources.filters.ignoreallowedvalues If TRUE, do not check the value against the list of allowed values for enumerations
    @cell(string) querydata.sources.historymode History mode, one of
                  - 'now': Return all entities that are valid now
                  - 'at': Return all entities that were valid at 'when'
                  - 'range': Return all entities that were valid in the range [ 'when_start', 'when_limit' ]
                  - 'all': Return all entities (excluding temporaries)
                  - '__getfields': Return all entities (including temporaries)
    @cell(datetime) querydata.sources.when For history mode 'at', date when entities must be valid to be returned
    @cell(datetime) querydata.sources.when_start For history mode 'range', start of the range where entities must have been valid in to be returned
    @cell(datetime) querydata.sources.when_limit For history mode 'range', limit of the range where entities must have been valid in to be returned
    @cell(record array) querydata.links Links between the sources
    @cell(string) querydata.links.left Name of the left source
    @cell(string) querydata.links.right Name of the right source
    @cell(string) querydata.links.field Field in the left sources that refers to the right source. Can be omitted to use the relation between the left and right source.
    @cell(string) querydata.links.jointype Method of joining the sources, one of "cross", "default", "left-optional", "left-missing", "right-optional", "right-missing".
    @cell(record array) querydata.params Parameters
    @cell(integer) querydata.resultlimit Maximum number of results to return. Omit or set negative to return all results.
    @cell(object %WRDSchema2017) querydata.wrdschema WRD schema to use. If set, tags can be used to select a type in the sources list.
    @cell(object %WHFSResourceNameMapper) querydata.whfsmapper WHFS mapper to use to convert WHFS ids
    @return(object #WRDQueryInterfaceNormalQuery) Query interface
*/
PUBLIC OBJECT FUNCTION MakeWRDQuery(RECORD querydata)
{
  IF(CellExists(querydata, 'OUTPUTCOLUMNS') OR CellExists(querydata, 'FILTER')) //This is obviosuly a forgotten type...
    THROW NEW Exception(`Trying to execute a query on a WRD schema without specifying the type (use wrdschema->^type->RunQuery)`);

  FOREVERY(RECORD cellrec FROM UnpackRecord(querydata))
    IF(cellrec.name NOT IN ["SOURCES","LINKS","PARAMS","RESULTLIMIT","WRDSCHEMA", "WHFSMAPPER"])
      THROW NEW Exception(`Unsupported query parameter '${cellrec.name}'`);

  RECORD ARRAY sources := querydata.sources;
  RECORD ARRAY links := CellExists(querydata, "LINKS") ? querydata.links : DEFAULT RECORD ARRAY;
  RECORD ARRAY parameters := CellExists(querydata, "PARAMS") ? querydata.params : DEFAULT RECORD ARRAY;

  // Parsed links and sources (objects)
  OBJECT ARRAY parsed_sources;
  RECORD ARRAY parsed_links;

  // Map from source name to source object
  RECORD sourcemap;
  RECORD outputcols;

//  DATETIME now := GetCurrentDateTime();

  OBJECT whfsmapper := CellExists(querydata, "WHFSMAPPER") ? querydata.whfsmapper : DEFAULT OBJECT;

  OBJECT wrdschema := CellExists(querydata, "WRDSCHEMA") AND ObjectExists(querydata.wrdschema)
      ? querydata.wrdschema
      : Length(sources) > 0 AND ObjectExists(sources[0].type)
            ? sources[0].type->wrdschema
            : DEFAULT OBJECT;

  // Parameters
  BOOLEAN strict := ObjectExists(wrdschema) AND wrdschema->__iswrdapi2017;
  RECORD ARRAY processed_parameters := ProcessParameters(parameters, strict);
  RECORD parsed_parameters;

  FOREVERY (RECORD param FROM processed_parameters)
    parsed_parameters := CellInsert(parsed_parameters, param.name, param);

  // Parse all sources
  FOREVERY (RECORD source FROM sources)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(source))
      IF(cellrec.name NOT IN ["NAME","TYPE","TYPEFILTER","OUTPUTCOLUMNS","FILTERS","HISTORYMODE","WHEN","WHEN_START","WHEN_LIMIT"])
        THROW NEW Exception("Unsupported query parameter '" || cellrec.name || "'");

    OBJECT type;
    IF (TypeID(source.type) = TypeID(STRING) AND strict)
    {
      type := wrdschema->__GetTypeByTag(source.type);
      IF (NOT ObjectExists(type))
        THROW NEW Exception(`Type '${source.type}' for source ${CellExists(source, "NAME") ? "'" || source.name || "'" : "#" || #source} does not exist`);
    }
    ELSE
    {
      IF (NOT ObjectExists(source.type))
        THROW NEW Exception("The type object for source " || (CellExists(source, "NAME") ? "'" || source.name || "'" : "#" || #source) || " does not exist");

      IF (NOT Objectexists(wrdschema))
        wrdschema := type->wrdschema;
      ELSE IF (source.type->wrdschema != wrdschema)
        THROW NEW Exception("Mixing types from different WRDSchema objects");

      type := source.type;
    }

    // Get the type from the source record
    IF (NOT ObjectExists(type))
      THROW NEW Exception("The type object for source " || (CellExists(source, "NAME") ? "'" || source.name || "'" : "#" || #source) || " does not exist");

    // Build a new source object
    OBJECT obj := NEW WRDQuerySource(type, whfsmapper);

    // Get the name (defaults to the a reserved name)
    obj->name := CellExists(source, "NAME") AND source.name != "" ? source.name : "__source" || #source;

    IF (CellExists(sourcemap, obj->name))
      THROW NEW Exception("The source with name '" || obj->name || "' already exists within this query, please choose another name");

    INTEGER ARRAY allowedtypes := INTEGER[ obj->wrd_type->id, ...obj->wrd_type->__childtypeids ];
    IF (CellExists(source, "TYPEFILTER"))
    {
      VARIANT typefilter := source.typefilter;
      IF (TypeID(typefilter) = TypeID(STRING ARRAY))
      {
        INTEGER ARRAY typefilterids;
        FOREVERY (STRING typefiltertype FROM typefilter)
        {
          OBJECT wrdtype := wrdschema->__GetTypeByTag(typefiltertype);
          IF (NOT ObjectExists(wrdtype))
            THROW NEW Exception(`No such type ${EncodeHSON(typefiltertype)} found (specified in typefilter)`);
          INSERT wrdtype->id INTO typefilterids AT END;
        }
        typefilter := typefilterids;
      }

      IF (IsValueSet(ArrayDelete(INTEGER ARRAY(typefilter), allowedtypes)))
        THROW NEW Exception(`The typefilter contains WRD type ids that are not valid for WRD type '${obj->wrd_type->tag}'`);
      obj->typefilter := typefilter;
    }
    ELSE
      obj->typefilter := allowedtypes;

    // Get the output columns
    IF(CellExists(source,"OUTPUTCOLUMNS"))
      obj->return_map := obj->RecurseGetoutputColumns(source.outputcolumns);

    // Get the historymode
    STRING historymode := CellExists(source, "HISTORYMODE") ? source.historymode : "now";
    IF (historymode = "default")
      historymode := "now";

    SWITCH (historymode)
    {
      /* selecting a point in time (default,now,at) requires us to define a range of at least
         one millisecond, because data created within our current time tick will otherwise have a
         creationdate equal to the limitdate of the search, and be skipped
         (this wouldn't be needed if GetCurrentDatetime() was guaranteed to be increasing on every
          call, _AND_ we could store this precision into the database)

         eg, assume storable time granularity of 1. if an entity is created @0.4, it will be stored
             as 'creationdate 0, limitdate max'. a search for 'when_start=0.5, when_end=0.5' will
             be rounded down to 'when_start=0, when_end=0' and miss the new entity
          */
      CASE "now"
        { // historymode "now" will be filled in at query execution start, instead of query construction
        }
      CASE "all","__getfields" { }
      CASE "at"         { obj->when_start := source.when; obj->when_limit := source.when = MAX_DATETIME ? MAX_DATETIME : AddTimeToDate(1, source.when); }
      CASE "range"      { obj->when_start := source.when_start; obj->when_limit := source.when_limit; }
      DEFAULT           { THROW NEW Exception(`Illegal historymode '${historymode}', acceptable modes are 'now', 'all', 'at', 'range'`); }
    }
    obj->history_mode := historymode;

    // Get the filters
    RECORD ARRAY filters;
    IF (CellExists(source, "FILTERS"))
    {
      IF (TYPEID(source.filters) != TYPEID(RECORD ARRAY))
        THROW NEW Exception("The cell 'filters' must be of type record array");

      filters := source.filters;
    }
    RECORD custom_params := ParseFilters(obj, type, filters, parsed_parameters, DEFAULT RECORD);
    IF (NOT RecordExists(parsed_parameters))
      parsed_parameters := custom_params;

    // Source is complete now
    INSERT obj INTO parsed_sources AT END;
    sourcemap := CellInsert(sourcemap, obj->name, obj);
  }

  IF (LENGTH(sources) = 0)
    THROW NEW Exception("No sources have been specified, please specify one");

  FOREVERY (RECORD link FROM links)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(link))
      IF(cellrec.name NOT IN ["LEFT","RIGHT","FIELD","JOINTYPE"])
        THROW NEW Exception("Unsupported query parameter '" || cellrec.name || "'");

    IF (NOT CellExists(sourcemap, link.left))
      THROW NEW Exception("Cannot find the source with name '" || link.left || "'");
    IF (NOT CellExists(sourcemap, link.right))
      THROW NEW Exception("Cannot find the source with name '" || link.right || "'");

    STRING jointype := CellExists(link, "JOINTYPE") ? link.jointype : "default";

    OBJECT link_left := GetCell(sourcemap, link.left);
    OBJECT link_right := GetCell(sourcemap, link.right);

    RECORD parsed_link :=
        [ link_left := link_left
        , link_right := link_right
        , jointype := jointype
        , attr := DEFAULT RECORD
        , attr_specified := FALSE
        ];

    IF (jointype NOT IN [ "cross", "default", "left-optional", "left-missing", "right-optional", "right-missing" ])
      THROW NEW Exception("Illegal join type '" || jointype || "'");

    IF (jointype != "cross")
    {
      IF (CellExists(link, "FIELD"))
      {
        parsed_link.attr := SELECT * FROM link_left->wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase(link.field);
        parsed_link.attr_specified := TRUE;
        IF (NOT RecordExists(parsed_link.attr))
        {
          IF(RecordExists(SELECT FROM link_right->wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase(link.field)))
            THROW NEW Exception(`Cannot find attribute '${link.field}' in wrd type '${link_left->wrd_type->tag}' (try swapping left and right)`);

          STRING bestmatch := GetBestMatch(link.field, SELECT AS STRING ARRAY tag FROM link_left->wrd_type->__final_attrs);
          THROW NEW Exception(`Cannot find attribute '${link.field}' in wrd type '${link_left->wrd_type->tag}'${bestmatch = "" ? "" : `, did you mean '${bestmatch}'`}`);
        }
        IF (parsed_link.attr.domain != link_right->wrd_type->id)
          THROW NEW Exception(`Attribute '${link.field}' in wrd type '${link_left->wrd_type->tag}' does not link to type '${link_right->wrd_type->tag}'`);
      }
      ELSE
      {
        // Normal link, find out which type links to the other
        IF (link_left->wrd_type->linkto = link_right->wrd_type->id)
          parsed_link.attr := SELECT * FROM link_left->wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase("WRD_RIGHTENTITY");
        ELSE IF (link_right->wrd_type->linkfrom = link_left->wrd_type->id)
        {
          // Make sure the attribute always works on the LEFT link.
          parsed_link.link_left := link_right;
          parsed_link.link_right := link_left;
          SWITCH (jointype)
          {
            CASE "left-optional"        { jointype := "right-optional"; }
            CASE "left-missing"         { jointype := "right-missing"; }
            CASE "right-optional"       { jointype := "left-optional"; }
            CASE "right-missing"        { jointype := "left-missing"; }
          }
          parsed_link.jointype := jointype;
          parsed_link.attr := SELECT * FROM link_right->wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase("WRD_LEFTENTITY");
        }
        ELSE
          THROW NEW Exception(`WRD types '${link_left->wrd_type->tag}' and '${link_right->wrd_type->tag}' cannot be linked to each other in this order`);
        IF (NOT RecordExists(parsed_link.attr))
          THROW NEW Exception("Internal error: could not resolve standard attribute wrd_xxxentity, while a link possibility was indicated");
      }
    }
    INSERT parsed_link INTO parsed_links AT END;
  }

  // Get resultlimit
  INTEGER resultlimit := CellExists(querydata, "RESULTLIMIT") ? querydata.resultlimit : -1;

  // Get a schema
  OBJECT wrd_schema := parsed_sources[0]->wrd_type->wrdschema;

  // Build a new query object
  OBJECT query := NEW WRDQuery(wrd_schema, whfsmapper);
  query->singles := parsed_sources;
  query->links := parsed_links;
  query->parameters := parsed_parameters;
  query->resultlimit := resultlimit;

  RETURN NEW WRDQueryInterfaceNormalQuery(query);
}

RECORD FUNCTION ParseParameter(STRING name)
{
  INTEGER dotpos := SearchSubstring(name, '.');
  IF (dotpos = -1)
    RETURN [ name := name, suffix := "" ];
  IF (dotpos = LENGTH(name) - 1)
    THROW NEW Exception("Illegal parameter format (expected a longer suffix after the '.').");

  RETURN [ name := Left(name, dotpos), suffix := SubString(name, dotpos + 1, LENGTH(name)) ];
}

MACRO CheckAttributeCompatibleWithParameter(OBJECT wrdtype, RECORD attr, RECORD param, STRING param_name)
{
  IF (      (param.type != attr.attributetype)          // Types may not differ
        AND (param.type != 1 OR attr.tag != "WRD_ID")   // Domain parameter may be matched with a wrd_id
        AND ((param.type NOT IN [6, 12]) OR (attr.attributetype NOT IN [6, 12])) // date/datetime may be freely intermixed
     )
    THROW NEW Exception("Parameter '" || param_name || "' is not compatible with earlier uses (different attribute types, " || param.type || " vs. " || attr.attributetype || ").");
  IF ((attr.attributetype = 1 AND param.domaintype->id != attr.domain)
   OR (attr.tag = "WRD_ID" AND wrdtype->id != param.domaintype->id))
    THROW NEW Exception("Parameter '" || param_name || "' is not compatible with earlier uses (different domain types, " || param.domaintype->tag || " vs. " || wrdtype->wrdschema->GetTypeById(attr.domain)->tag || ").");
}

RECORD FUNCTION RetrieveArgument(OBJECT wrdtype, RECORD attr, STRING param_name, STRING param_suffix, RECORD parameters, RECORD custom_params)
{
  RECORD res := [ param := DEFAULT RECORD
                , custom_params := custom_params ];

  IF (RecordExists(parameters))
  {
    IF (NOT CellExists(parameters, param_name))
      THROW NEW Exception("Parameter '" || param_name || "' has not been specified, while others have been specified. Specify all or none.");
    res.param := GetCell(parameters, param_name);
    IF (param_suffix NOT IN [ "", "year_start", "year_limit", "valuestart", "valuelimit" ]) // FIXME: generalize
      THROW NEW Exception("Illegal sub-selection '" || param_suffix || "' for parameter '" || param_name || "'.");
  }
  ELSE IF (CellExists(custom_params, param_name))
  {
    res.param := GetCell(custom_params, param_name);
  }
  ELSE
  {
    IF (param_suffix != "" AND NOT RecordExists(parameters))
      THROW NEW Exception("Complex parameters (which can be used with dots) need to be declared");

    res.param := [ type := attr.attributetype
                 , subtype := ""
                 , ordering := LENGTH(UnpackRecord(res.custom_params)) + 1
                 ];
    IF (attr.attributetype = 1) /* domain */
      INSERT CELL domaintype := wrdtype->wrdschema->GetTypeById(attr.domain) INTO res.param;

    res.custom_params := CellInsert(res.custom_params, param_name, res.param);

    // No checking needed.
    RETURN res;
  }
  CheckAttributeCompatibleWithParameter(wrdtype, attr, res.param, param_name);
//  IF (res.param.type != attr.attributetype AND (res.param.type != 1 OR attr.tag != "WRD_ID"))
//    ABORT("Parameter '" || param_name || "' is not compatible with earlier uses (different attribute types, " || res.param.type || " vs. " || attr.attributetype || ").");
//  IF (attr.attributetype = 1 AND res.param.domaintype->id != attr.domain)
//    ABORT("Parameter '" || param_name || "' is not compatible with earlier uses (different domain types, " || res.param.domaintype->tag || " vs. " || wrdtype->wrdschema->GetTypeById(attr.domain)->tag || ").");
  IF (param_suffix != "" AND res.param.subtype = "")
    THROW NEW Exception("Complex parameter accesses (with a '.') are not allowed for simple attributes (only allowed when a subtype is indicated).");
  IF (param_suffix = "" AND res.param.subtype != "")
    THROW NEW Exception("Complex parameter accesses (with a '.') is required when a subtype is indicated.");

  RETURN res;
}

MACRO ConvertDomainValuesInFilter(OBJECT filter, OBJECT wrdtype)
{
  BOOLEAN isarray := IsTypeidArray(TypeID(filter->value_holder.data));

  // Convert tags to ids
  IF ((filter->attr.attributetype IN [ 1/*domain*/, 8/*domain-multi*/ ]/* OR
        filter->attr.tag IN [ "WRD_LEFTENTITY","WRD_RIGHTENTITY"]*/)
      AND filter->attr.tag NOT IN [ "WRD_GENDER" ]
      AND TypeID(filter->value_holder.data) = (isarray ? TypeID(STRING ARRAY) : TypeID(STRING)))
  {
    // Is a domain
    INTEGER ARRAY vals;
    FOREVERY (STRING tag FROM isarray ? filter->value_holder.data : [ STRING(filter->value_holder.data) ])
    {
      INTEGER domainentity := wrdtype->GetDomVal(filter->attr.tag, tag);
      IF (domainentity = 0)
        THROW NEW Exception(`Could not find domain value with tag '${tag}' for attribute '${filter->attr.tag}' in wrd type ${wrdtype->tag}`);
      INSERT domainentity INTO vals AT END;
    }

    IF (isarray)
      filter->value_holder := [ data := vals ];
    ELSE
      filter->value_holder := [ data := vals[0] ];
  }
}

RECORD FUNCTION ParseFilters(OBJECT obj, OBJECT wrdtype, RECORD ARRAY filters, RECORD parameters, RECORD custom_params)
{
  FOREVERY (RECORD filter FROM filters)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(filter))
      IF(cellrec.name NOT IN ["TYPE","FIELD","MATCH_TYPE","MATCHTYPE","MATCHCASE","MATCH_CASE","VALUE","VALUE_P","DOMAINVALUETAG","DOMAINVALUETAG_P","FILTERS","FILTER","ISFIXED","IGNOREALLOWEDVALUES"])
        THROW NEW Exception("Unsupported query parameter '" || cellrec.name || "'");

    STRING type := CellExists(filter, "TYPE") ? ToUppercase(filter.type) : "";
    IF (type = "")
    {
      IF (CellExists(filter, "domainvaluetag") OR CellExists(filter, "domainvaluetag_p"))
        type := "DOMAIN";
      ELSE IF (CellExists(filter, "value") OR CellExists(filter, "value_p"))
        type := "FREE";
      ELSE THROW NEW Exception("Missing value or domainvaluetag for filter on wrd type " || wrdtype->tag);
    }
    OBJECT child;
    SWITCH (type)
    {
      CASE "AND"
        {
          child := NEW WRDMultiCondition("AND");
          custom_params := ParseFilters(child, wrdtype, filter.filters, parameters, custom_params);
        }
      CASE "OR"
        {
          child := NEW WRDMultiCondition("OR");
          custom_params := ParseFilters(child, wrdtype, filter.filters, parameters, custom_params);
        }
      CASE "NOT"
        {
          child := NEW WRDMultiCondition("NOT");
          custom_params := ParseFilters(child, wrdtype, [ RECORD(filter.filter) ], parameters, custom_params);
        }
      CASE "FREE"
        {
          child := NEW WRDCondition("FREE");

          child->attr := SELECT * FROM wrdtype->__final_attrs WHERE ToUppercase(tag)=ToUppercase(filter.field);
          IF (NOT RecordExists(child->attr))
          {
            STRING bestmatch := GetBestMatch(filter.field, SELECT AS STRING ARRAY tag FROM wrdtype->__final_attrs);
            THROW NEW Exception(`Cannot find attribute '${filter.field}' in wrd type '${wrdtype->tag}'${bestmatch = "" ? "" : `, did you mean '${bestmatch}'`}`);
          }
          IF(child->attr.generatetag = "WRD_RELATION_TITLE")
            THROW NEW Exception("The WRD_TITLE field of a RELATION is not searchable"); //for now. perhaps we can lift it but it'll be a challenge...
          IF(child->attr.generatetag = "WRD_ORGNAME") //redirect to the proper field
            child->attr := SELECT * FROM wrdtype->__final_attrs WHERE ToUppercase(tag)=ToUppercase("WRD_ORGNAME");

          BOOLEAN match_case; // Ignore match_case when case is not relevant
          IF (CellExists(filter, "MATCHCASE"))
            match_case := filter.matchcase;
          ELSE IF (CellExists(filter, "MATCH_CASE"))
            match_case := filter.match_case;
          child->match_case := IsCaseRelevant(child->attr) ? match_case : TRUE;
          child->ignoreallowedvalues := CellExists(filter,'ignoreallowedvalues') AND filter.ignoreallowedvalues;

          BOOLEAN isarray;
          IF (CellExists(filter, "VALUE_P"))
          {
            RECORD pdata := ParseParameter(filter.value_p);
            child->from_parameter := pdata.name;
            child->from_suffix := pdata.suffix;
            RECORD res := RetrieveArgument(wrdtype, child->attr, pdata.name, pdata.suffix, parameters, custom_params);
            custom_params := res.custom_params;
          }
          ELSE
          {
            child->value_holder := [ data := filter.value ];
            ConvertDomainValuesInFilter(child, wrdtype);

            isarray := IsTypeidArray(TypeID(filter.value));
          }

          IF (CellExists(filter, "MATCHTYPE"))
            child->match_type := filter.matchtype;
          ELSE IF (CellExists(filter, "MATCH_TYPE"))
            child->match_type := filter.match_type;
          ELSE IF(child->attr.attributetype = 8) //multi domain
            child->match_type := isarray ? "=" : "CONTAINS";
          ELSE
            child->match_type := isarray ? "IN" : "=";

          IF(child->match_type NOT IN ["=","!=","<",">","<=",">=","IN","LIKE","CONTAINS","INTERSECTS","MENTIONSANY","MENTIONS","__INRANGE"])
            THROW NEW Exception("Unknown match type '" || child->match_type || "'");
          IF (child->attr.attributetype = 7 AND child->match_type NOT IN ["=","!="])
            THROW NEW Exception("Match type '" || child->match_type || "' is not allowed for password attribute '" || filter.field || "' in wrd type '" || wrdtype->tag || "'");

        }
      CASE "DOMAIN"
        {
          child := NEW WRDCondition("DOMAIN");
          child->attr := SELECT * FROM wrdtype->__final_attrs WHERE ToUppercase(tag)=ToUppercase(filter.field);
          IF (NOT RecordExists(child->attr))
          {
            STRING bestmatch := GetBestMatch(filter.field, SELECT AS STRING ARRAY tag FROM wrdtype->__final_attrs);
            THROW NEW Exception(`Cannot find attribute '${filter.field}' in wrd type '${wrdtype->tag}'${bestmatch = "" ? "" : `, did you mean '${bestmatch}'`}`);
          }
          IF (CellExists(filter, "DOMAINVALUETAG_P"))
          {
            RECORD pdata := ParseParameter(filter.domainvaluetag_p);
            child->from_parameter := pdata.name;
            child->from_suffix := pdata.suffix;
            RECORD res := RetrieveArgument(wrdtype, child->attr, pdata.name, pdata.suffix, parameters, custom_params);
            custom_params := res.custom_params;
          }
          ELSE
          {
            child->domain_tag := filter.domainvaluetag;
            INTEGER domainentity := wrdtype->GetDomVal(filter.field, filter.domainvaluetag);
            IF (domainentity = 0)
              THROW NEW Exception("Cannot find domain value with tag '" || filter.domainvaluetag || "' for attribute '" || filter.field || "' in wrd type '" || wrdtype->tag || "'");
            child->value_holder := [ data := domainentity ];
          }
          child->match_case := TRUE;
          IF (CellExists(filter, "MATCHTYPE"))
            child->match_type := filter.matchtype;
          ELSE IF (CellExists(filter, "MATCH_TYPE"))
            child->match_type := filter.match_type;
          ELSE
            child->match_type := "=";
          IF (child->match_type = "IN")
            THROW NEW Exception("IN is not allowed as match type for domain conditions");
        }
     }
     INSERT child INTO obj->children AT END;
   }
   RETURN custom_params;
}

/** @param querydata @includecelldef #MakeWRDQuery.querydata
    @return Query results
*/
PUBLIC RECORD ARRAY FUNCTION RunWRDQuery(RECORD querydata)
{
  OBJECT wrd_query := MakeWRDQuery(querydata);
  RETURN wrd_query->Execute(DEFAULT RECORD);
}

PUBLIC RECORD ARRAY FUNCTION RightOuterJoinOnLink(RECORD ARRAY left, RECORD ARRAY right, RECORD right_default, STRING ARRAY additional_links)
{
  INTEGER rightpos := 0
        , previouspos := 0
        , rightlen := LENGTH(right)
        , lastlink := -1;

  INTEGER additional_links_len := LENGTH(additional_links);
  BOOLEAN check_additionals := additional_links_len > 0;

  RECORD ARRAY results;
  FOREVERY (RECORD rec FROM left)
  {
    IF (rec.link = lastlink)
      rightpos := previouspos;
    ELSE
    {
      lastlink := rec.link;
      WHILE (rightpos < rightlen AND right[rightpos].link < lastlink)
        rightpos := rightpos + 1;
      previouspos := rightpos;
    }

//    PRINT("Left: " || rec.link || " (" || #rec || "), right #" || rightpos || "/" || rightlen || "\n");
    BOOLEAN found := FALSE;
    WHILE (rightpos < rightlen AND right[rightpos].link = lastlink)
    {
      IF (check_additionals)
      {
        BOOLEAN isok := true;
        RECORD rightrec := right[rightpos];
        FOR (INTEGER idx := 0; idx < additional_links_len; idx := idx + 1)
        {
          IF (GetCell(rec, additional_links[idx]) != GetCell(rightrec, additional_links[idx]))
          {
            isok := FALSE;
            BREAK;
          }
        }
        IF (NOT isok) // fail?
        {
          rightpos := rightpos + 1;
          CONTINUE;
        }
      }

//      PRINT(" with right " || right[rightpos].link || " #" || rightpos || "/" || rightlen || "\n");
      RECORD addrec := right[rightpos];
      found := TRUE;
      RECORD newrec := __HS_SQL_OverwriteRecord(rec, addrec);
      DELETE CELL link FROM newrec;
      IF (check_additionals)
        FOR (INTEGER idx := 0; idx < additional_links_len; idx := idx + 1)
          newrec := CellDelete(newrec, additional_links[idx]);
      INSERT newrec INTO results AT END;
      rightpos := rightpos + 1;
    }
    IF (NOT found)
    {
      RECORD newrec := MakeMergedRecord(rec, right_default);
      DELETE CELL link FROM newrec;
      IF (check_additionals)
        FOR (INTEGER idx := 0; idx < additional_links_len; idx := idx + 1)
          newrec := CellDelete(newrec, additional_links[idx]);
      INSERT newrec INTO results AT END;
    }
  }
//  PrintRecordArrayTo(0, results, "boxed");
  RETURN results;
}

PUBLIC RECORD ARRAY FUNCTION RightMissingJoinOnLink(RECORD ARRAY left, RECORD ARRAY right, RECORD right_default, STRING ARRAY additional_links)
{
  INTEGER rightpos := 0
        , previouspos := 0
        , rightlen := LENGTH(right)
        , lastlink := -1;

  INTEGER additional_links_len := LENGTH(additional_links);
  BOOLEAN check_additionals := additional_links_len > 0;

  RECORD ARRAY results;
  FOREVERY (RECORD rec FROM left)
  {
    IF (rec.link = lastlink)
      rightpos := previouspos;
    ELSE
    {
      lastlink := rec.link;
      WHILE (rightpos < rightlen AND right[rightpos].link < lastlink)
        rightpos := rightpos + 1;
      previouspos := rightpos;
    }

//    PRINT("Left: " || rec.link || " (" || #rec || "), right #" || rightpos || "/" || rightlen || "\n");
    BOOLEAN found := FALSE;
    WHILE (rightpos < rightlen AND right[rightpos].link = lastlink)
    {
      IF (check_additionals)
      {
        BOOLEAN isok := true;
        RECORD rightrec := right[rightpos];
        FOR (INTEGER idx := 0; idx < additional_links_len; idx := idx + 1)
        {
          IF (GetCell(rec, additional_links[idx]) != GetCell(rightrec, additional_links[idx]))
          {
            isok := FALSE;
            BREAK;
          }
        }
        IF (NOT isok) // fail?
        {
          rightpos := rightpos + 1;
          CONTINUE;
        }
      }
      found := TRUE;
      rightpos := rightpos + 1;
    }
    IF (NOT found)
    {
      RECORD newrec := MakeMergedRecord(rec, right_default);
      DELETE CELL link FROM newrec;
      IF (check_additionals)
        FOR (INTEGER idx := 0; idx < additional_links_len; idx := idx + 1)
          newrec := CellDelete(newrec, additional_links[idx]);
      INSERT newrec INTO results AT END;
    }
  }
//  PrintRecordArrayTo(0, results, "boxed");
  RETURN results;
}

VARIANT FUNCTION ApplySubSelect(VARIANT value, RECORD field)
{
  IF(TYPEID(value) = TYPEID(RECORD ARRAY))
  {
    //FIXME support all types, not just imageid and strings
    VARIANT retval;

    FOREVERY(STRING sub FROM field.subselect)
    {
      IF(#sub=0 AND field.accessor EXTENDSFROM WRDDBARRAYVALUE)
        retval := DEFAULT RECORD ARRAY;
      ELSE IF(ToUppercase(sub)="IMAGEID")
        retval := DEFAULT INTEGER ARRAY;
      ELSE
        retval := DEFAULT STRING ARRAY;

      FOREVERY(RECORD row FROM value)
      {
        VARIANT subval;

        IF(CellExists(row, sub))
          subval := GetCell(row, sub);
        ELSE IF(ToUppercase(sub)="IMAGEID" AND NOT RecordExists(row)) //FIXME should only work on actual images
          subval:= 0;
        ELSE
          subval := "";

        INSERT subval INTO retval AT END;
      }
      value := retval;
    }
  }
  ELSE
  {
    FOREVERY(STRING sub FROM field.subselect)
      IF(CellExists(value, sub))
        value := GetCell(value, sub);
      ELSE IF(ToUppercase(sub)="IMAGEID" AND NOT RecordExists(value)) //FIXME should only work on actual images
        value := 0;
      ELSE
        value := "";
  }
  RETURN value;
}

/** @param rows Rows that need to be enriched
    @cell rows.__entity Entity nr for this row
    @cell rows.data Current data for this row
    @param fields Description of fields to enrich them with, must be sorted on cell @a fields.fieldid
    @cell fields.rename
    @cell fields.fieldid Attribute id
    @cell fields.accessor
    @cell fields.subselect
    @param attrdata List of every entity relevant entity setting (pertains to any of the rows AND any of the fields)
    @cell attrdata.entity
    @cell attrdata.fieldid
    @return Rows, with data record enriched
    @cell return.__entity
    @cell return.data
*/
RECORD ARRAY FUNCTION EnrichRows(RECORD ARRAY rows, RECORD ARRAY fields, RECORD ARRAY attrdata, RECORD context, STRING ARRAY contextcells)
{
  // Inv: forevery(data from attrdata) data.entity in select __entity from rows
  // Inv: forevery(data from attrdata) data.attribute in select attribute from fields
  // Inv: rows sorted on __entity
  // Inv: fields sorted on attribute
  // Inv: attrdata sorted on entity, attribute,

  INTEGER attrdata_pos := RecordLowerBound(attrdata, context, contextcells).position;
  INTEGER attrdata_len := RecordUpperBound(attrdata, context, contextcells);
  INTEGER prev_row_attrdata_start := 0;
  INTEGER last_entity := -1;
  FOREVERY (RECORD row FROM rows)
  {

    // Set starting point right (we may have cached it from the previous row).
    INTEGER current_entity := row.__entity;
    IF (current_entity = last_entity)
      attrdata_pos := prev_row_attrdata_start;
    ELSE
    {
      // Find current entity
      WHILE (attrdata_pos < attrdata_len AND attrdata[attrdata_pos].entity < current_entity)
        attrdata_pos := attrdata_pos + 1;
      prev_row_attrdata_start := attrdata_pos;
      last_entity := current_entity;
    }

    FOREVERY (RECORD field FROM fields)
    {
      INTEGER current_attribute := field.attribute;
      INTEGER attrdata_start;
      INTEGER attrdata_limit;
      WHILE (attrdata_pos < attrdata_len AND attrdata[attrdata_pos].entity = current_entity)
      {
        INTEGER attr_id := attrdata[attrdata_pos].attribute;
        IF (attr_id < current_attribute)
        {
          attrdata_pos := attrdata_pos + 1;
          CONTINUE;
        }
        IF (attr_id = current_attribute)
        {
          attrdata_start := attrdata_pos;
          attrdata_limit := attrdata_start + 1;
          WHILE (attrdata_limit < attrdata_len AND attrdata[attrdata_limit].entity = current_entity AND attrdata[attrdata_limit].attribute = current_attribute)
            attrdata_limit := attrdata_limit + 1;
        }
        BREAK;
      }

      //ADDME In the case of getting images, we could be optimized to not even retrieve the 'data' member from the database
      VARIANT value := field.accessor->GetValue(attrdata, attrdata_start, attrdata_limit, row);

      IF (Length(field.subselect) > 0)
        value := ApplySubSelect(value, field);

      row.data := CellInsert(row.data, field.rename, value);
    }
    rows[#row] := row;
  }
  RETURN rows;
}

/** Filters a list of records based on id. Returns the __row cell of record that have an id
    present in the @a filter list
    @param rows Rows to filter. Must be sorted on id.
    @cell rows.id Id to filter on
    @cell rows.__row Record that is returned if the id is present in filter
    @param filter List of ids that are acceptable. Must be ordered ascending, no duplicates!!!
    @return Returns all the __row cells of rows whose id was in the filter list
*/
RECORD ARRAY FUNCTION FilterListAndReturnRows(RECORD ARRAY rows, INTEGER ARRAY filter)
{
  INTEGER filter_pos := 0
        , filter_len := LENGTH(filter);

  // INV: rows.id sorted, filter sorted
  RECORD ARRAY results;
  FOREVERY (RECORD r FROM rows)
  {
    INTEGER id := r.id;
    IF (filter_pos < filter_len AND filter[filter_pos] < id)
      filter_pos := filter_pos + 1;

    IF (filter_pos < filter_len AND id = filter[filter_pos])
      INSERT r.__row INTO results AT END;
  }
  RETURN results;
}

/** Returns the sorted union of two sorted integer arrays
    @param ar first integer array
    @param br second integer array
    @return Sorted list of all integers that are either in @a ar or @a br
*/
INTEGER ARRAY FUNCTION UnionIntegerArrays(INTEGER ARRAY ar, INTEGER ARRAY br)
{
  INTEGER bpos := 0, blen := LENGTH(br);
  INTEGER ARRAY rr;
  FOREVERY (INTEGER a FROM ar)
  {
    FOR (; bpos < blen AND br[bpos] <= a; bpos := bpos + 1)
      IF (a != br[bpos])
        INSERT br[bpos] INTO rr AT END;
    INSERT a INTO rr AT END;
  }
  FOR (; bpos < blen; bpos := bpos + 1)
    INSERT br[bpos] INTO rr AT END;
  RETURN rr;
}

/** Returns all integers that are in one array, but not in another
    @param bases base integer array, sorted.
    @param ar list of integers that must NOT be returned, sorted.
    @return List of integers that are in @a bases but not in @a ar
*/
INTEGER ARRAY FUNCTION NegateIntegerArray(INTEGER ARRAY bases, INTEGER ARRAY ar)
{
  INTEGER apos := 0, alen := LENGTH(ar);
  INTEGER ARRAY rr;
  FOREVERY (INTEGER base FROM bases)
  {
    BOOLEAN found := FALSE;
    FOR (; apos < alen AND ar[apos] <= base; apos := apos + 1)
      IF (base = ar[apos])
        found := TRUE;
    IF (NOT found)
      INSERT base INTO rr AT END;
  }
  RETURN rr;
}


STRING FUNCTION ExplainAfterFilters(OBJECT cond, STRING indent)
{
  STRING res;
  SWITCH (cond->type)
  {
    CASE "AND", "OR", "NOT"
        {
          res := indent || cond->type || "\n";
          FOREVERY (OBJECT o FROM cond->opt_children)
            res := res || ExplainAfterFilters(o, indent || " ");
        }
    CASE "FREE"
        {
          STRING value := AnyToString(cond->value_holder.data, "tree");
          IF (value LIKE "*\n")
            value := Left(value, LENGTH(value) - 1);
          res := indent || cond->type || "." || cond->attr.tag || " " || cond->match_type || " " || value || " ";
          res := res || (cond->match_case ? "" : " (case insensitive)") || "\n";
        }
    CASE "DOMAIN"
        {
          res := indent || cond->type || "." || cond->attr.tag || " " || cond->match_type || " " || cond->domainvaluetag || " ";
          res := res || (cond->match_case ? "" : " (case insensitive)") || "\n";
        }
  }
  RETURN res;
}

STRING FUNCTION FormatMoneyXSD(MONEY value)
{
  STRING str := FormatMoney(value, 5, ".", "", FALSE);
  INTEGER len := LENGTH(str);
  INTEGER i := 1;
  FOR (; i <= 6; i := i + 1)
  {
    STRING char := SubString(str, len - i, 1);
    IF (char != "0" AND char != ".")
      BREAK;
  }
  RETURN LEFT(str, len - i + 1);
}

RECORD FUNCTION ParseXMLFilter(OBJECT wrd_type, OBJECT xml_filter)
{
  STRING type := xml_filter->GetAttribute("type");
  SWITCH (type)
  {
  CASE "and", "or"
    {
      RECORD ARRAY filters;
      OBJECT ARRAY xml_filters := xml_filter->childnodes->GetCurrentElements();

      FOREVERY (OBJECT xml_subfilter FROM xml_filters)
        INSERT ParseXMLFilter(wrd_type, xml_subfilter) INTO filters AT END;

      RETURN
          [ type :=       ToUppercase(type)
          , filters :=    filters
          ];
    }
  CASE "not"
    {
      RECORD ARRAY filters;
      OBJECT ARRAY xml_filters := xml_filter->childnodes->GetCurrentElements();
      IF(Length(xml_filters) != 1)
        THROW NEW Exception("Expected exactly one subfilter");

      RETURN
          [ type :=      ToUppercase(type)
          , filter :=    ParseXMLFilter(wrd_type, xml_filters[0])
          ];
    }
  CASE "free", "domain", ""
    {
      RECORD filter :=
          [ field :=      xml_filter->GetAttribute("field")
          ];

      STRING xml_match_case := xml_filter->GetAttribute("match_case");
      IF (xml_match_case != "")
        INSERT CELL match_case := xml_match_case IN [ "1", "true" ] INTO filter;

      STRING xml_parameter := xml_filter->GetAttribute("parameter");
      IF (xml_parameter != "")
      {
        STRING xml_parameter_suffix := xml_filter->GetAttribute("parameter_suffix");
        IF (xml_parameter_suffix != "")
          xml_parameter := xml_parameter || "." || xml_parameter_suffix;

        IF (type = "")
          THROW NEW Exception("Missing filter attribute 'type' for filter on field '"||filter.field||"'");

        IF (type = "free")
          INSERT CELL value_p := xml_parameter INTO filter;
        ELSE
          INSERT CELL domainvaluetag_p := xml_parameter INTO filter;

        INSERT CELL type := ToUppercase(type) INTO filter;
      }
      ELSE
      {
        STRING xml_domainvaluetag := xml_filter->GetAttribute("domainvaluetag");
        IF (type != "" AND (xml_domainvaluetag = "") != (type = "free"))
          THROW NEW Exception("Error while parsing query filter for attribute '"||filter.field||"', type='"||type||"' doesn't agree with the existance of attribute 'domainvaluetag' or the presence of an harescript value");
        ELSE IF (type = "")
          type := xml_domainvaluetag = "" ? "free" : "domain";

        STRING xml_match_type := xml_filter->GetAttribute("match_type");
        IF (xml_match_type != "" AND xml_match_type != "=")
          INSERT CELL match_type := ToUppercase(xml_match_type) INTO filter;

        IF (type = "domain")
          INSERT CELL domainvaluetag := xml_domainvaluetag INTO filter;
        ELSE
        {
          RECORD attr := SELECT * FROM wrd_type->__final_attrs WHERE ToUppercase(tag)=ToUppercase(filter.field);
          IF(NOT RecordExists(attr))
            THROW NEW Exception("Error while parsing query forfilter for attribute '"||filter.field||"', type='"||type||"' has no such attribute.");
          OBJECT ref_type := attr.domain = 0 ? wrd_type : wrd_type->wrdschema->GetTypeById(attr.domain);

          VARIANT value := xml_filter->__INTERNAL_GetHSValue();
          IF (xml_filter->GetAttribute("translateids") IN [ "0", "true"])
          {
            IF (TypeID(value) = TypeID(STRING))
            {
              IF (value != "")
              {
                OBJECT entity := ref_type->OpenWRDEntityByGuid(value);
                value := ObjectExists(entity) ? entity->id : 0;
              }
              ELSE
                value := 0;
            }
            ELSE IF (TypeID(value) = TypeID(STRING ARRAY))
            {
              INTEGER ARRAY data;
              FOREVERY (STRING guid FROM STRING ARRAY(value))
              {
                OBJECT entity := ref_type->OpenWRDEntityByGuid(guid);
                IF (ObjectExists(entity))
                  INSERT entity->id INTO data AT END;
              }
              value := data;
            }
          }
          INSERT CELL value := value INTO filter;
        }
      }

      RETURN filter;
    }
  }
  THROW NEW Exception("Encountered unknown filter type '"||type||"' while parsing a WRD query");
}

RECORD FUNCTION ParseXMLSource(OBJECT wrd_schema, OBJECT xml_source, OBJECT xpathquery)
{
  RECORD source :=
    [ name := xml_source->GetAttribute("name")
    , type := wrd_schema->__GetTypeByTag(xml_source->GetAttribute("type"))
    ];

  IF(NOT Objectexists(source.type))
  {
    THROW NEW Exception("No such type '" || xml_source->GetAttribute("type") || "'");
  }

  RECORD outputcolumns;

  OBJECT ARRAY xml_outputcolumns := xpathquery->ExecuteQuery(".//ns:outputcolumns/ns:outputcolumn", xml_source)->GetCurrentElements();

  FOREVERY (OBJECT xml_outputcolumn FROM xml_outputcolumns)
  {
    STRING name := xml_outputcolumn->GetAttribute("name");
    STRING field := xml_outputcolumn->GetAttribute("attribute");
    STRING subselect := xml_outputcolumn->GetAttribute("subselect");
    IF (subselect != "")
      field := field || "." || subselect;

    IF (CellExists(outputcolumns, name))
      THROW NEW Exception("An output column with the name '"||name||"' is already specified in source '"||source.name||"'");

    outputcolumns := CellInsert(outputcolumns, xml_outputcolumn->GetAttribute("name"), field);
  }
  IF (RecordExists(outputcolumns))
    INSERT CELL outputcolumns := outputcolumns INTO source;

  STRING historymode := xml_source->GetAttribute("historymode");
  IF (historymode != "now" AND historymode != "")
    INSERT CELL historymode := historymode INTO source;

  IF (historymode = "at")
  {
    DATETIME when := MakeDateFromText(xml_source->GetAttribute("when"));
    IF (when = DEFAULT DATETIME)
      THROW NEW Exception("Missing or illegal value for attribute 'when' in source '"||source.name||"', needed because historymode='at', while importing a WRD query");

    INSERT CELL when := when INTO source;
  }
  ELSE IF (historymode = "range")
  {
    DATETIME when_start := MakeDateFromText(xml_source->GetAttribute("when_start"));
    DATETIME when_limit := MakeDateFromText(xml_source->GetAttribute("when_limit"));

    IF (when_start = DEFAULT DATETIME)
      THROW NEW Exception("Missing or illegal value for attribute 'when_start' in source '"||source.name||"', needed because historymode='range', while importing a WRD query");
    IF (when_limit = DEFAULT DATETIME)
      THROW NEW Exception("Missing or illegal value for attribute 'when_limit' in source '"||source.name||"', needed because historymode='range', while importing a WRD query");

    INSERT CELL when_start := when_start INTO source;
    INSERT CELL when_limit := when_limit INTO source;
  }

  OBJECT ARRAY xml_filters := xpathquery->ExecuteQuery(".//ns:filters/ns:filter", xml_source)->GetCurrentElements();
  RECORD ARRAY filters;
  FOREVERY (OBJECT xml_filter FROM xml_filters)
    INSERT ParseXMLFilter(source.type, xml_filter) INTO filters AT END;

  IF (RecordExists(filters))
    INSERT CELL filters := filters INTO source;

  RETURN source;
}

RECORD FUNCTION ParseXMLLink(OBJECT xml_link)
{
  RECORD link :=
      [ left :=   xml_link->GetAttribute("left")
      , right :=  xml_link->GetAttribute("right")
      ];

  STRING field := xml_link->GetAttribute("field");
  IF (field != "")
    INSERT CELL field := field INTO link;

  STRING jointype := xml_link->GetAttribute("jointype");
  IF (jointype != "")
    INSERT CELL jointype := jointype INTO link;

  RETURN link;
}

RECORD FUNCTION ParseXMLParameter(OBJECT xml_parameter)
{
  RECORD parameter :=
      [ name := xml_parameter->GetAttribute("name")
      , type := xml_parameter->GetAttribute("type")
      ];

  IF (ObjectExists(xml_parameter->GetAttributeNode("title")))
    INSERT CELL title := xml_parameter->GetAttribute("title") INTO parameter;

  STRING subtype := xml_parameter->GetAttributeNode("subtype");
  IF (subtype != "")
    INSERT CELL subtype := subtype INTO parameter;

  STRING xml_type := xml_parameter->GetAttributeNode("type");
  INTEGER type := GetAttributeTypeIdByTypeName(xml_type, FALSE);
  IF (type = 0)
    THROW NEW Exception("Encountered unknown attribute type '"||xml_type||"' in parameter '"||parameter.name||"'");

  SWITCH (type)
  {
  CASE 1 /*domain*/
    {
      INSERT CELL domaintype := xml_parameter->GetAttribute("domaintype") INTO parameter;
    }
  CASE 6, 12
    {
      THROW NEW Exception("Deserialization for parameters of type date/datetime not implemented yet");
    }
  CASE 15 /*integer*/
    {
      THROW NEW Exception("Deserialization for parameters of type integer not implemented yet");
    }

  CASE 16 /*money*/
    {
      THROW NEW Exception("Deserialization for parameters of type money not implemented yet");
    }
  }

  RETURN parameter;
}

/** Reads an XML serialized query, returns a query record with the spec
    @param wrd_schema WRD schema
    @param query_node Node with an encoded query
    @return @includecelldef #MakeWRDQuery.querydata
*/
PUBLIC RECORD FUNCTION ImportQueryFromXML(OBJECT wrd_schema, OBJECT query_node)
{
  OBJECT query := query_node->ownerdocument->CreateXPathQuery();
  query->RegisterNamespace("ns", query_ns);

  OBJECT ARRAY xml_sources := query->ExecuteQuery(".//ns:sources/ns:source", query_node)->GetCurrentElements();

  RECORD ARRAY sources;
  FOREVERY (OBJECT xml_source FROM xml_sources)
    INSERT ParseXMLSource(wrd_schema, xml_source, query) INTO sources AT END;

  OBJECT ARRAY xml_links := query->ExecuteQuery(".//ns:links/ns:link", query_node)->GetCurrentElements();

  RECORD ARRAY links;
  FOREVERY (OBJECT xml_link FROM xml_links)
    INSERT ParseXMLLink(xml_link) INTO links AT END;

  OBJECT ARRAY xml_parameters := query->ExecuteQuery(".//ns:parameters/ns:parameter", query_node)->GetCurrentElements();

  RECORD ARRAY parameters;
  FOREVERY (OBJECT xml_parameter FROM xml_parameters)
    INSERT ParseXMLParameter(xml_parameter) INTO parameters AT END;

  INTEGER resultlimit := -1;
  OBJECT ARRAY xml_resultlimits := query->ExecuteQuery(".//ns:resultlimit", query_node)->GetCurrentElements();
  IF (LENGTH(xml_resultlimits) != 0)
  {
    STRING value := xml_resultlimits[0]->GetAttribute("value");

    resultlimit := ToInteger(value, -1);
    IF (resultlimit < 0)
      THROW NEW Exception("Resultlimit does not contain a valid non-negative integer");
  }

  RECORD data :=
    [ sources := sources
    ];

  IF (RecordExists(links))
    INSERT CELL links := links INTO data;
  IF (RecordExists(parameters))
    INSERT CELL parameters := parameters INTO data;
  IF (resultlimit != -1)
    INSERT CELL resultlimit := resultlimit INTO data;

  RETURN data;
}

/** Split the accessors for attributes into 'base' fields and 'settings' fields
    @param wrd_type WRD type
    @param selectfields List of fields to select
    @cell(record) selectfields.sourcename Name of the source
    @cell(record) selectfields.attr Attribute record
    @cell(string) selectfields.name Name of the field to select
    @cell(string array) selectfields.subselect Subselection
    @param linkgetter Link getter
    @param whfsmapper WHFS mapper
    @return List of accessors
    @cell return.base_fields List of fields with base attributes
    @cell return.fields List of fields with normal attributes
*/
PUBLIC RECORD FUNCTION GetAccessors(OBJECT wrd_type, RECORD ARRAY selectfields, OBJECT linkgetter, OBJECT whfsmapper)
{
  RECORD options := CELL
      [ linkgetter
      , whfsmapper
      ];

  RECORD ARRAY fields, base_fields;
  FOREVERY (RECORD field FROM selectfields)
  {
    RECORD attr := field.attr;
    IF (attr.generatetag = "WRD_ORGNAME") //workaround for organization fields
    {
      OBJECT orgtype := wrd_type->wrdschema->GetType("WRD_ORGANIZATION");
      attr := orgtype->GetAttribute("WRD_ORGNAME");

      INSERT CELL accessor := GetAccessorForAttributeType(attr, wrd_type, options) INTO attr;
      INSERT CELL rename := field.name INTO attr;
      INSERT CELL subselect := field.subselect INTO attr;
      INSERT CELL allattributeids := [ INTEGER(attr.id) ] INTO attr;
      INSERT attr INTO fields AT END;
    }
    ELSE IF(attr.generatetag = "WRD_RELATION_TITLE") //workaround for organization fields
    {
      OBJECT orgtype := wrd_type->wrdschema->GetType("WRD_ORGANIZATION");
      attr.id := orgtype->GetAttribute("WRD_ORGNAME").id; //make sure orgname gets picked up

      INSERT CELL accessor := NEW WRDDBRTValue(wrd_type,attr, field.sourcename) INTO attr;
      INSERT CELL rename := field.name INTO attr;
      INSERT CELL subselect := field.subselect INTO attr;
      INSERT CELL allattributeids := attr.accessor->GetAllAttributeIds() INTO attr;
      INSERT attr INTO fields AT END;
    }
    ELSE IF (attr.base)
    {
      INSERT CELL rename := field.name INTO attr;
      INSERT CELL subselect := field.subselect INTO attr;
      INSERT attr INTO base_fields AT END;
    }
    ELSE
    {
      INSERT CELL accessor := GetAccessorForAttributeType(attr, wrd_type, CELL[...options, wrapper := field.wrapper]) INTO attr;
      INSERT CELL rename := field.name INTO attr;
      INSERT CELL subselect := field.subselect INTO attr;
      INSERT CELL allattributeids := attr.accessor->GetAllAttributeIds() INTO attr;
      INSERT attr INTO fields AT END;
    }
  }

  RETURN [ fields := fields
         , base_fields := base_fields
         ];
}




/* ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - */
/* ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - */
/* ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - ** - */

// FIXME: Implement regrouping!
// (multiple entity-settings for filtered entities might duplicate the results)

/*
  BOOLEAN need_grouping := query->GetSourcesLength() != LENGTH(this->singles);
*/
/*
  IF (NOT need_grouping)
    RETURN rows;

  // Make sure that of every combination of singles only one is given back
  RECORD ARRAY groups;
  RECORD ARRAY results;
  STRING ARRAY source_names;
  FOREVERY (OBJECT single FROM this->singles)
    INSERT ToUppercase(single->name) INTO source_names AT END;

  FOREVERY (RECORD row FROM rows)
  {
    RECORD groupdata;
    FOREVERY (STRING name FROM source_names)
      groupdata := CellInsert(groupdata, ToString(#name), GetCell(row, name).id);
    INTEGER grouppos := __HS_SQL_GetGroupPosition(groups, groupdata);
    IF (grouppos < 0)
    {
      INSERT row INTO results AT END;
      INSERT groupdata INTO groups AT (-grouppos) - 1;
    }
  }
*/
