<?wh
LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/payments.whlib";
LOADLIB "mod::wrd/lib/internal/payments/support.whlib";

STRING FUNCTION DescribePayment(RECORD paymentrecord, RECORD paymentattr, OBJECT wrdschema)
{
  RETURN `Payment #${paymentrecord.id} for ${ToLowercase(wrdschema->tag || "." || paymentattr.wrdtypetag)} entity #${paymentrecord.paymententity} (${paymentrecord.paymentdata.paymentref})`;
}

PUBLIC RECORD ARRAY FUNCTION PollPaymentStatuses(BOOLEAN for_test, DATETIME delete_threshold, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
    [ recheckinterval := 5*60*1000
    , id := 0
    , debug := FALSE
    ], options);

  RECORD ARRAY issues;
  STRING ARRAY block_payments := SELECT AS STRING ARRAY uuid FROM wrd.pendingpayments GROUP BY uuid HAVING COUNT(*)>1;
  IF(Length(block_payments)>0)
    INSERT [ message := `There are ${Length(block_payments)} duplicate payments - they cannot be polled for status. Maybe you need to remove a .bak schema?` ] INTO issues AT END;

  RECORD ARRAY paymentgroups := SELECT payments := GroupedValues(pendingpayments)
                                     , providerattr
                                     , paymentattr
                                  FROM wrd.pendingpayments
                                 WHERE (options.id = 0 ? nextcheck < GetCurrentDatetime() : TRUE)
                                       AND (options.id = 0 ? TRUE : pendingpayments.id = options.id)
                                       AND uuid NOT IN block_payments
                              GROUP BY providerattr, paymentattr
                              ORDER BY Random(1,65535);

  INTEGER ARRAY relevant_attrs;

  //ADDME limit the amount of work per run
  FOREVERY(RECORD paymentgroup FROM paymentgroups)
  {
    RECORD providerattr := DescribeWRDAttribute(paymentgroup.providerattr);
    RECORD paymentattr := DescribeWRDAttribute(paymentgroup.paymentattr);
    OBJECT wrdschema := OpenWRDSchemaById(providerattr.wrdschema);
    IF(NOT ObjectExists(wrdschema))
      CONTINUE; //this schema has been deleted

    IF(options.id = 0 AND (wrdschema->tag = whconstant_wrd_testschema) != for_test)
      CONTINUE;

    INSERT paymentgroup.paymentattr INTO relevant_attrs AT END;

    OBJECT api := GetPaymentAPI(wrdschema, [ providertypeid := providerattr.wrdtype
                                           , providerfield := providerattr.attributetag
                                           , paymenttypeid := paymentattr.wrdtype
                                           , paymentfield := paymentattr.attributetag
                                           ]);

    OBJECT paymenttype := wrdschema->GetTypeById(paymentattr.wrdtype);
    RECORD ARRAY paymentgrouppayments := paymenttype->Enrich(paymentgroup.payments, "PAYMENTENTITY", CELL[ "WRD_ID", paymentdata := paymentattr.attributetag ]);

    RECORD ARRAY providergroups := SELECT payments := GroupedValues(paymentgrouppayments)
                                        , provider := ANY(paymentdata.paymentprovider)
                                     FROM paymentgrouppayments
                                 GROUP BY paymentdata.paymentprovider
                              ORDER BY Random(1,65535);

    FOREVERY(RECORD providergroup FROM providergroups)
    {
      //ADDME open the provider instead of individual payments, group requests to the provider where possible
      FOREVERY(RECORD paymentrecord FROM providergroup.payments)
      {
        STRING seterror;
        IF(options.debug)
          Print(`Rechecking ${DescribePayment(paymentrecord, paymentattr, wrdschema)}\n`);
        OBJECT paymentobject := api->__OpenPSP(paymentrecord.paymentdata, paymentrecord.creationdate, paymentrecord.uuid);
        TRY
        {
          paymentobject->RecheckPayment();
        }
        CATCH(OBJECT e)
        {
          LogHarescriptException(e);
          seterror := `${DescribePayment(paymentrecord, paymentattr, wrdschema)} triggered an exception during check: ${e->what}`;
        }

        IF(seterror = "")
        {
          IF(paymentobject->status != "pending") //we now know the reality of this payment
          {
            GetPrimary()->BeginLockedWork("wrd:payments.payment:" || paymentrecord.paymententity);
            ProcessUpdatedPayment(paymentobject->paymenthandler, paymentattr.attributetag, paymentobject, paymenttype->GetEntity(paymentrecord.paymententity), FALSE);
            UPDATE wrd.pendingpayments SET nextcheck := MAX_DATETIME, error := "" WHERE id = paymentrecord.id;
            GetPrimary()->CommitWork();
            CONTINUE;
          }

          IF(paymentrecord.creationdate <= AddDaysToDate(-paymentobject->expiredays, GetCurrentDatetime()))
          {
            //cancel payment after two weeks
            TRY
            {
              api->CancelPendingPayment(paymentrecord.paymententity, [ paymentuuid := paymentrecord.uuid ]);
              CONTINUE;
            }
            CATCH(OBJECT e)
            {
              LogHarescriptException(e);
              seterror := `${DescribePayment(paymentrecord, paymentattr, wrdschema)} triggered an exception during check: ${e->what}`;
            }
          }
        }

        DATETIME setnextcheck;
        RECORD diff := GetDatetimeDifference(paymentrecord.creationdate, GetCurrentDatetime());
        IF(diff.days > 0) //check payments older than a day once every 6 hours
          setnextcheck := AddTimeToDate(6*60*60*1000, GetCurrentDatetime());
        ELSE IF(diff.msecs >= 2*60*60*1000) //after 2 hours, checking every 30 minutes is enough
          setnextcheck := AddTimeToDate(30*60*1000, GetCurrentDatetime());
        ELSE //check every 5 minutes (TODO reschedule pollpaymentstatus ourselves instead of having to actually wait for the next tick)
          setnextcheck := AddTimeToDate(options.recheckinterval, GetCurrentDatetime());

        GetPrimary()->BeginWork();
        UPDATE wrd.pendingpayments SET nextcheck := setnextcheck, error := seterror WHERE id = paymentrecord.id;
        GetPrimary()->CommitWork();
      }
    }
  }

  FOREVERY(RECORD failpay FROM SELECT error FROM wrd.pendingpayments WHERE paymentattr IN relevant_attrs AND error != "" AND (options.id = 0 ? TRUE : id = options.id))
    INSERT [ message := failpay.error ] INTO issues AT END;

  IF(delete_threshold < MAX_DATETIME)
  {
    GetPrimary()->BeginWork();
    DELETE FROM wrd.pendingpayments WHERE creationdate < delete_threshold AND nextcheck = MAX_DATETIME AND (options.id = 0 ? TRUE : id = options.id);
    GetPrimary()->CommitWork();
  }

  RETURN issues;
}
