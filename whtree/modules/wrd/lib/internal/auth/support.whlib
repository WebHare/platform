<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/otp.whlib";
LOADLIB "wh::util/stringparser.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/internal/wrdsettings.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/rightsinfo.whlib";
LOADLIB "mod::system/lib/internal/cluster/logging.whlib";


/** Default WRD auth configuration
    @cell(integer64) expire_login Expire normal login after this time (milliseconds)
    @cell(integer64) expire_persistent_login Expire persistent login after this time (milliseconds)
    @cell(integer64) expire_third_party_login Expire third party login after this time (milliseconds)
    @cell(integer) round_long_logins_to Round long logins to this time of the day (milliseconds)
    @cell(string) round_long_logins_t_z Round long logins in this timezone
    @cell(integer64) round_min_duration Minimum duration of sessions when rounding (milliseconds)
*/
PUBLIC CONSTANT RECORD wrdauth_defaultconfiguration :=
  [ expire_login :=             86400 * 1000i64 // 1 day
  , expire_persistent_login :=  30 * 86400 * 1000i64 //30 days
  , expire_third_party_login := 86400 * 1000i64 // 1 day
  , round_long_logins_to :=     4 * 3600 * 1000    // 4 am (set to -1 to disable rounding)
  , round_long_logins_t_z :=    "Europe/Amsterdam" // default timezone for rounding
  , round_min_duration :=       3 * 3600 * 1000i64 // sessions last at least 3 hours
  ];

/** @param entityid Id entity to get the authobject from
    @return @includecelldef #LookupAuthobjectByGuid.return
*/
PUBLIC RECORD FUNCTION LookupAuthobjectByEntityid(INTEGER entityid)
{
  STRING rawguid := SELECT AS STRING guid FROM wrd.entities WHERE id = entityid;
  IF(rawguid="")
    RETURN DEFAULT RECORD;

  RETURN LookupAuthobjectByGuid(EncodeWRDGUID(rawguid));
}

/** Returns authentication settings with the specified password hash as current password.
    @long This should be used when creating new entities, but not to update password as using the returned value won't retain any password history and will reset 2FA settings
    @param passwordhash Current password hash
    @cell options.validfrom Date when the password was set, defaults to current time
    @return Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION CreateAuthenticationSettingsFromPasswordHash(STRING passwordhash, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ validfrom :=    GetCurrentDateTime()
      ], options);

  RECORD value := GetDefaultAuthenticationSettings();
  IF (passwordhash != "")
    INSERT CELL[ passwordhash, options.validfrom ] INTO value.passwords AT END;
  RETURN ValidateAuthenticationSettingValue(value); //validates the password hash
}

/** Returns whether the specified authentication settings are the default value (no passwords set, no second factor set)
    @param value Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @return TRUE if the settings are default
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC BOOLEAN FUNCTION IsDefaultAuthenticationSettings(RECORD value)
{
  IF (NOT RecordExists(value))
    RETURN TRUE;
  BOOLEAN allempty := TRUE;
  FOREVERY (RECORD rec FROM UnpackRecord(value))
    IF (rec.name != "VERSION" AND IsValueSet(rec.value))
      RETURN FALSE;
  RETURN TRUE;
}

/** Returns a record with default authentication settings
    @return Default authentication settings record @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION GetDefaultAuthenticationSettings()
{
  RETURN
      [ version :=      1
      , passwords :=    RECORD[]
      , totp :=         DEFAULT RECORD
      ];
}

/** @param val Authantication settings to validate
    @return Validated authentication settings
    @cell(integer) return.version Settings version, should be 1.
    @cell(record array) return.passwords List of passwords, last one is current valid password.
    @cell(string) return.passwords.passwordhash Password hash.
    @cell(datetime) return.passwords.validfrom Date from when this password hash. Must be increasing and smaller than GetCurrentDateTime().
    @cell(record) return.totp TOTP second factor settings
    @cell(string) return.totp.url TOTP configuration url, see %GetTOTPUrl
    @cell(datetime) return.totp.locked Datime when normal code entry was locked due to too many failures
    @cell(record array) return.totp.backupcodes List of backup codes
    @cell(string) return.totp.backupcodes.code Backup code
    @cell(datetime) return.totp.used Date when backup code was used
*/
PUBLIC RECORD FUNCTION ValidateAuthenticationSettingValue(RECORD val)
{
  val := ValidateOptions(
      [ version :=    -1
      , passwords :=  DEFAULT RECORD ARRAY
      , totp :=       DEFAULT RECORD
      ], val,
      [ required :=   [ "version" ]
      , title :=      `data`
      ]);

  IF (val.version != 1)
    THROW NEW Exception(`Expected version 1`);

  FOREVERY (RECORD password FROM val.passwords)
  {
    val.passwords[#password] := ValidateOptions(
        [ passwordhash :=   ""
        , validfrom :=  DEFAULT DATETIME
        ], password,
        [ required :=     [ "passwordhash" ]
        , title := `data.passwords[${#password}]` ]);

    IF(password.passwordhash NOT LIKE "MD5:????????????????"
        AND password.passwordhash NOT LIKE "SSHA1:????????????????????????????"
        AND password.passwordhash NOT LIKE "XSHA1:????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "WHBF:????????????????????????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "NETASP-SHA1:????????????????????*"
        AND password.passwordhash NOT LIKE "LCR:???*"
        AND password.passwordhash NOT LIKE "PLAIN:?*"
        AND password.passwordhash != ""
        AND password.passwordhash != "*")
      THROW NEW Exception(`Password in authenticationsettings.passwords[${#password}].passwordhash is receiving an unhashed password value - CreateWebharePasswordHash should have been invoked on the value`);

    IF (#password > 0 AND val.passwords[#password].validfrom <= val.passwords[#password-1].validfrom)
      THROW NEW Exception(`Passwords in authenticationsettings.passwords[${#password}] isn't properly sorted on validfrom`);

  }

  IF (IsValueSet(val.passwords) AND val.passwords[END-1].validfrom > GetCurrentDateTime())
    THROW NEW Exception(`Passwords in authenticationsettings.passwords[${LENGTH(val.passwords)-1}] activates in the future`);

  IF (RecordExists(val.totp))
  {
    val.totp := ValidateOptions(
        [ url :=          ""
        , backupcodes :=  RECORD[]
        , locked :=       DEFAULT DATETIME
        ], val.totp,
        [ required :=     [ "url" ]
        , title := `data.totp` ]);

    RECORD parsed := UnpackOTPUrl(val.totp.url);
    IF (parsed.type != "totp")
      THROW NEW Exception(`data.totp.url is not a valid TOTP url`);

    FOREVERY (RECORD code FROM val.totp.backupcodes)
    {
      val.totp.backupcodes[#code] := ValidateOptions(
          [ code :=       ""
          , used :=       DEFAULT DATETIME
          ], code,
          [ required :=     [ "code" ]
          , title := `data.totp.backupcodes[${#code}]`
          ]);
    }
  }
  RETURN val;
}

PUBLIC RECORD FUNCTION UpdateAuthenticationSettings(RECORD curvalue, RECORD newvalue)
{
  curvalue := curvalue ?? GetDefaultAuthenticationSettings();
  newvalue := ValidateAuthenticationSettingValue(newvalue ?? GetDefaultAuthenticationSettings());

  // used dates of TOTP backup codes must stay intact
  IF (RecordExists(curvalue.totp) AND RecordExists(newvalue.totp))
  {
    // don't allow value setting to overwrite set used dates of TOTP backup codes
    UPDATE newvalue.totp.backupcodes AS newcodes
       SET used := (SELECT AS DATETIME used FROM curvalue.totp.backupcodes WHERE code = newcodes.code) ?? used;
  }

  RETURN IsDefaultAuthenticationSettings(newvalue) ? DEFAULT RECORD : newvalue;
}

/** Writes a audit event to the logs in a separate transction
    @param(object %WRDType2017) wrdtype Relevant wrd type
    @param type Audit event type
    @cell options.account WRD ID of account that is being modified (required)
    @cell options.login Login name of account that is being modified
    @cell options.isimpersonation Whether this is an impersonation
    @cell(record) options.message Additional data
*/
PUBLIC MACRO WriteWRDAuditEvent(OBJECT wrdtype, STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ account :=    0
      , login :=      ""
      , message :=    DEFAULT RECORD
      , wrdschema := ""
      , isimpersonation := FALSE
      ], options,
      [ required := [ "account" ]
      ]);

  RunInSeparatePrimary(PTR DoWriteAuditEvent(wrdtype, type, options.account, options.login, options.isimpersonation, options.message, options.wrdschema));
}

// Writes an audit log event to the database in separated transactions
MACRO DoWriteAuditEvent(OBJECT accounttype, STRING type, INTEGER affecteduser_entityid, STRING affecteduser_login, BOOLEAN isimpersonation, RECORD message, STRING wrdschema)
{
  type := ToLowercase(type);
  IF(type NOT LIKE "?*:?*")
    THROW NEW Exception(`Invalid audit event type '${type}'`);

  // The log determines its own datetime, make sure the database logdate is just before or at that date
  DATETIME creationdate := GetCurrentDatetime();
  RECORD auditcontext := CELL[ affecteduser_login
                             , affecteduser_entityid
                             , type
                             ];
  IF(wrdschema != "")
    INSERT CELL wrdschema := wrdschema INTO auditcontext;
  ELSE IF (NOT ObjectExists(GetEffectiveUser()) OR NOT ObjectExists(GetEffectiveUser()->wrdschema))
    INSERT CELL wrdschema := accounttype->wrdschema->tag INTO auditcontext;

  RECORD logged := LogAuditEventBy("wrd:auth", auditcontext, message);

  RECORD toinsert := CELL
      [ creationdate
      , wrdschema :=            accounttype->wrdschema->id
      , ip :=                   logged.auditcontext.remoteip
      , logged.auditcontext.country
      , logged.auditcontext.browsertriplet
      , type
      , impersonated :=         logged.auditcontext.impersonator_entityid != logged.auditcontext.user_entityid OR isimpersonation
      , impersonator_entity :=  logged.auditcontext.impersonator_entityid < 0 ? 0 : logged.auditcontext.impersonator_entityid
      , impersonator_login :=   logged.auditcontext.impersonator_login ?? accounttype->GetEntityField(logged.auditcontext.impersonator_entityid, accounttype->wrdschema->accountlogintag)
      , byentity :=             logged.auditcontext.user_entityid < 0 ? 0 : logged.auditcontext.user_entityid
      , bylogin :=              logged.auditcontext.user_login ?? accounttype->GetEntityField(logged.auditcontext.user_entityid, accounttype->wrdschema->accountlogintag)
      , entity :=               logged.auditcontext.affecteduser_entityid
      , login :=                logged.auditcontext.affecteduser_login ?? accounttype->GetEntityField(logged.auditcontext.affecteduser_entityid, accounttype->wrdschema->accountlogintag)
      , data :=                 RecordExists(message) ? EncodeHSON(message) : ""
      ];

  GetPrimary()->BeginWork();
  INSERT toinsert INTO wrd.auditevents;

  TRY
  {
    GetPrimary()->CommitWork();
    BroadcastEvent(`wrd:auditlog.${accounttype->wrdschema->id}.${logged.auditcontext.affecteduser_entityid}`, DEFAULT RECORD);
    RETURN;
  }
  CATCH(OBJECT e)
  {
    //if commit fails, we might be racing against deletion of the entity (especially when logging out of a cleaned up wrd schema). are we ?
    IF(NOT RecordExists(SELECT FROM wrd.entities WHERE entities.id = affecteduser_entityid))
      RETURN; //okay, we can live with this

    //retry once more, but if this fails, too bad
    GetPrimary()->BeginWork();
    INSERT toinsert INTO wrd.auditevents;
    GetPrimary()->CommitWork();
    BroadcastEvent(`wrd:auditlog.${accounttype->wrdschema->id}.${logged.auditcontext.affecteduser_entityid}`, DEFAULT RECORD);
  }
}

/** Parses a subset an ISO8061 duration.
    Limitations:
    - fractions are only allowed with seconds, not with smallest item
    -
    @param duration Duration to parse
    @return Duration parts
    @cell(integer) return.years Number of years
    @cell(integer) return.months Number of months
    @cell(integer) return.weeks Number of weeks
    @cell(integer) return.days Number of days
    @cell(integer) return.hours Number of hours
    @cell(integer) return.minutes Number of minutes
    @cell(integer) return.seconds Number of seconds
    @cell(integer) return.milliseconds Number of milliseconds
*/
PUBLIC RECORD FUNCTION ParseDuration(STRING duration) {
  RETURN duration = "" ? DEFAULT RECORD : ParseISO8601Duration(duration);
}

DATETIME FUNCTION AddUnpackedDurationToDateInternal(RECORD duration, DATETIME date, INTEGER factor)
{
  FOREVERY (RECORD part FROM UnpackRecord(duration))
  {
    IF (part.value = 0)
      CONTINUE;
    SWITCH (part.name)
    {
      CASE "YEARS"          { date := AddYearsToDate(factor * part.value, date); }
      CASE "MONTHS"         { date := AddMonthsToDate(factor * part.value, date); }
      CASE "WEEKS"          { date := AddDaysToDate(factor * 7*part.value, date); }
      CASE "DAYS"           { date := AddDaysToDate(factor * part.value, date); }
      CASE "HOURS"          { date := AddTimeToDate(factor * 60*60*1000*part.value, date); }
      CASE "MINUTES"        { date := AddTimeToDate(factor * 60*1000*part.value, date); }
      CASE "SECONDS"        { date := AddTimeToDate(factor * 1000*part.value, date); }
      CASE "MILLISECONDS"   { date := AddTimeToDate(factor * part.value, date); }
    }
  }

  RETURN date;
}

PUBLIC DATETIME FUNCTION AddUnpackedDurationToDate(RECORD duration, DATETIME date)
{
  RETURN AddUnpackedDurationToDateInternal(duration, date, 1);
}

PUBLIC DATETIME FUNCTION SubtractUnpackedDurationToDate(RECORD duration, DATETIME date)
{
  RETURN AddUnpackedDurationToDateInternal(duration, date, -1);
}

/** Get a text describing a duration.
    @param duration ISO 8601 duration
    @return Duration string
*/
PUBLIC STRING FUNCTION GetDurationTitle(STRING duration)
{
  STRING ARRAY parts;
  FOREVERY (RECORD part FROM UnpackRecord(ParseDuration(duration)))
  {
    IF (part.value = 0)
      CONTINUE;
    SWITCH (part.name)
    {
      CASE "YEARS"   { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.years", ToString(part.value)) INTO parts AT END; }
      CASE "MONTHS"  { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.months", ToString(part.value)) INTO parts AT END; }
      CASE "WEEKS"   { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.weeks", ToString(part.value)) INTO parts AT END; }
      CASE "DAYS"    { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.days", ToString(part.value)) INTO parts AT END; }
      CASE "HOURS", "MINUTES", "SECONDS", "MILLISECONDS" { } // ignore for now.
    }
  }

  STRING retval;
  SWITCH (LENGTH(parts))
  {
    CASE 1 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts1", parts[0]); }
    CASE 2 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts2", parts[0], parts[1]); }
    CASE 3 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts3", parts[0], parts[1], parts[2]); }
    CASE 4 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts4", parts[0], parts[1], parts[2], parts[3]); }
  }
  RETURN retval;
}

PUBLIC RECORD FUNCTION GetSchemaUnitPolicy(OBJECT wrdschema, INTEGER unit) {
  //Get base settings
  BOOLEAN have_passwordchecks, have_expiration;
  RECORD base_expiration;
  STRING base_passwordchecks;

  FOR (INTEGER maxiter := 0; unit != 0 AND maxiter < 16; maxiter := maxiter + 1) {
    RECORD unitdata := wrdschema->^whuser_unit->GetEntityFields(unit, [ "wrd_leftentity", "override_passwordchecks", "passwordchecks", "override_expiration", "expiration" ]);
    IF(have_passwordchecks = FALSE AND unitdata.override_passwordchecks) {
      have_passwordchecks := TRUE;
      base_passwordchecks := unitdata.passwordchecks;
    }
    IF(have_expiration = FALSE AND unitdata.override_expiration) {
      have_expiration := TRUE;
      base_expiration := unitdata.expiration;
    }
    unit := unitdata.wrd_leftentity;
  }

  RETURN CELL[
    passwordchecks := have_passwordchecks ? base_passwordchecks : GetWRDSetting(wrdschema, "password_validation_checks"),
    expiration := base_expiration
  ];
}

PUBLIC RECORD FUNCTION GetUserUnitPolicy(OBJECT wrdschema, INTEGER user) {
  INTEGER unit;
  IF(ObjectExists(wrdschema->accounttype) AND RecordExists(wrdschema->accounttype->GetAttribute("WHUSER_UNIT")))
    unit := wrdschema->accounttype->GetEntityField(user, "WHUSER_UNIT");

  RETURN GetSchemaUnitPolicy(wrdschema, unit);
}
