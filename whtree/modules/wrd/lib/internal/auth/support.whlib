<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/otp.whlib";
LOADLIB "wh::util/stringparser.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/internal/rightsinfo.whlib";
LOADLIB "mod::system/lib/internal/cluster/logging.whlib";


/** Default WRD auth configuration
    @cell(integer64) expire_login Expire normal login after this time (milliseconds)
    @cell(integer64) expire_persistentlogin Expire persistent login after this time (milliseconds)
    @cell(integer64) expire_thirdpartylogin Expire third party login after this time (milliseconds)
    @cell(integer) round_longlogins_to Round long logins to this time of the day (milliseconds)
    @cell(string) round_longlogins_tz Round long logins in this timezone
    @cell(integer64) round_minduration Minimum duration of sessions when rounding (milliseconds)
*/
PUBLIC CONSTANT RECORD wrdauth_defaultconfiguration :=
  [ expire_login :=                 86400 * 1000i64 // 1 day
  , expire_persistentlogin :=  30 * 86400 * 1000i64 //30 days
  , expire_thirdpartylogin :=       86400 * 1000i64 // 1 day
  , round_longlogins_to :=       4 * 3600 * 1000    // 4 am (set to -1 to disable rounding)
  , round_longlogins_tz :=       "Europe/Amsterdam" // default timezone for rounding
  , round_minduration :=         3 * 3600 * 1000i64 // sessions last at least 3 hours
  ];

PUBLIC MACRO SetCurrentStateCookie(OBJECT wrdauth, OBJECT plugin)
{
  IF(NOT IsRequest())
    RETURN;

  RECORD opts := [ domain := wrdauth->cookiedomain
                 , httponly := FALSE
                 , secure := wrdauth->securecookie
                 , lifetime := -1
                 , encrypt := FALSE
                 , samesite := wrdauth->samesitecookie
                 ];

  RECORD userinfo;
  STRING value;

  IF(wrdauth->IsLoggedIn())
  {
    userinfo := plugin->GetUserInfo();
    value := "." || (RecordExists(userinfo) ? EncodeJSON(userinfo) : "");

    STRING persisthash := EncodeUFS(GetMD5Hash(GetWebCookie(wrdauth->cookiename)));
    UpdateWebCookie(wrdauth->cookiename || "_c", value != "" ? persisthash || value : "", opts);

    opts.lifetime := wrdauth->GetPersistentCookieLifetime(); //FIXME we shouldn't be recalculating/redoing this? wrdauthplugin knows the proper lifetimes and we should be reusing the code there.
    UpdateWebCookie(wrdauth->cookiename || "_j", value != "" ? persisthash || "." : "", opts);
  }
  ELSE
  {
    UpdateWebCookie(wrdauth->cookiename, "");
    UpdateWebCookie(wrdauth->cookiename || "_j", "", opts);
    UpdateWebCookie(wrdauth->cookiename || "_c", "", opts);
  }
}

/** @param entityid Id entity to get the authobject from
    @return @includecelldef #LookupAuthobjectByGuid.return
*/
PUBLIC RECORD FUNCTION LookupAuthobjectByEntityid(INTEGER entityid)
{
  STRING rawguid := SELECT AS STRING guid FROM wrd.entities WHERE id = entityid;
  IF(rawguid="")
    RETURN DEFAULT RECORD;

  RETURN LookupAuthobjectByGuid(EncodeWRDGUID(rawguid));
}

/** Returns authentication settings with the specified password hash as current password.
    @long This should be used when creating new entities, but not to update password as using the returned value won't retain any password history and will reset 2FA settings
    @param passwordhash Current password hash
    @cell options.validfrom Date when the password was set, defaults to current time
    @return Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION CreateAuthenticationSettingsFromPasswordHash(STRING passwordhash, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ validfrom :=    GetCurrentDateTime()
      ], options);

  RECORD value := GetDefaultAuthenticationSettings();
  IF (passwordhash != "")
    INSERT CELL[ passwordhash, options.validfrom ] INTO value.passwords AT END;
  RETURN ValidateAuthenticationSettingValue(value); //validates the password hash
}

/** Returns whether the specified authentication settings are the default value (no passwords set, no second factor set)
    @param value Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @return TRUE if the settings are default
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC BOOLEAN FUNCTION IsDefaultAuthenticationSettings(RECORD value)
{
  IF (NOT RecordExists(value))
    RETURN TRUE;
  BOOLEAN allempty := TRUE;
  FOREVERY (RECORD rec FROM UnpackRecord(value))
    IF (rec.name != "VERSION" AND IsValueSet(rec.value))
      RETURN FALSE;
  RETURN TRUE;
}

/** Returns a record with default authentication settings
    @return Default authentication settings record @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION GetDefaultAuthenticationSettings()
{
  RETURN
      [ version :=      1
      , passwords :=    RECORD[]
      , totp :=         DEFAULT RECORD
      ];
}

/** @param val Authantication settings to validate
    @return Validated authentication settings
    @cell(integer) return.version Settings version, should be 1.
    @cell(record array) return.passwords List of passwords, last one is current valid password.
    @cell(string) return.passwords.passwordhash Password hash.
    @cell(datetime) return.passwords.validfrom Date from when this password hash. Must be increasing and smaller than GetCurrentDateTime().
    @cell(record) return.totp TOTP second factor settings
    @cell(string) return.totp.url TOTP configuration url, see %GetTOTPUrl
    @cell(datetime) return.totp.locked Datime when normal code entry was locked due to too many failures
    @cell(record array) return.totp.backupcodes List of backup codes
    @cell(string) return.totp.backupcodes.code Backup code
    @cell(datetime) return.totp.used Date when backup code was used
*/
PUBLIC RECORD FUNCTION ValidateAuthenticationSettingValue(RECORD val)
{
  val := ValidateOptions(
      [ version :=    -1
      , passwords :=  DEFAULT RECORD ARRAY
      , totp :=       DEFAULT RECORD
      ], val,
      [ required :=   [ "version" ]
      , title :=      `data`
      ]);

  IF (val.version != 1)
    THROW NEW Exception(`Expected version 1`);

  FOREVERY (RECORD password FROM val.passwords)
  {
    val.passwords[#password] := ValidateOptions(
        [ passwordhash :=   ""
        , validfrom :=  DEFAULT DATETIME
        ], password,
        [ required :=     [ "passwordhash" ]
        , title := `data.passwords[${#password}]` ]);

    IF(password.passwordhash NOT LIKE "MD5:????????????????"
        AND password.passwordhash NOT LIKE "SSHA1:????????????????????????????"
        AND password.passwordhash NOT LIKE "XSHA1:????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "WHBF:????????????????????????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "NETASP-SHA1:????????????????????*"
        AND password.passwordhash NOT LIKE "LCR:???*"
        AND password.passwordhash NOT LIKE "PLAIN:?*"
        AND password.passwordhash != ""
        AND password.passwordhash != "*")
      THROW NEW Exception(`Password in authenticationsettings.passwords[${#password}].passwordhash is receiving an unhashed password value - CreateWebharePasswordHash should have been invoked on the value`);

    IF (#password > 0 AND val.passwords[#password].validfrom <= val.passwords[#password-1].validfrom)
      THROW NEW Exception(`Passwords in authenticationsettings.passwords[${#password}] isn't properly sorted on validfrom`);

  }

  IF (IsValueSet(val.passwords) AND val.passwords[END-1].validfrom > GetCurrentDateTime())
    THROW NEW Exception(`Passwords in authenticationsettings.passwords[${LENGTH(val.passwords)-1}] activates in the future`);

  IF (RecordExists(val.totp))
  {
    val.totp := ValidateOptions(
        [ url :=          ""
        , backupcodes :=  RECORD[]
        , locked :=       DEFAULT DATETIME
        ], val.totp,
        [ required :=     [ "url" ]
        , title := `data.totp` ]);

    RECORD parsed := UnpackOTPUrl(val.totp.url);
    IF (parsed.type != "totp")
      THROW NEW Exception(`data.totp.url is not a valid TOTP url`);

    FOREVERY (RECORD code FROM val.totp.backupcodes)
    {
      val.totp.backupcodes[#code] := ValidateOptions(
          [ code :=       ""
          , used :=       DEFAULT DATETIME
          ], code,
          [ required :=     [ "code" ]
          , title := `data.totp.backupcodes[${#code}]`
          ]);
    }
  }
  RETURN val;
}

PUBLIC RECORD FUNCTION UpdateAuthenticationSettings(RECORD curvalue, RECORD newvalue)
{
  curvalue := curvalue ?? GetDefaultAuthenticationSettings();
  newvalue := ValidateAuthenticationSettingValue(newvalue ?? GetDefaultAuthenticationSettings());

  // used dates of TOTP backup codes must stay intact
  IF (RecordExists(curvalue.totp) AND RecordExists(newvalue.totp))
  {
    // don't allow value setting to overwrite set used dates of TOTP backup codes
    UPDATE newvalue.totp.backupcodes AS newcodes
       SET used := (SELECT AS DATETIME used FROM curvalue.totp.backupcodes WHERE code = newcodes.code) ?? used;
  }

  RETURN IsDefaultAuthenticationSettings(newvalue) ? DEFAULT RECORD : newvalue;
}

/** Writes a audit event to the logs in a separate transction
    @param(object %WRDType2017) wrdtype Relevant wrd type
    @param type Audit event type
    @cell options.account WRD ID of account that is being modified (required)
    @cell options.login Login name of account that is being modified
    @cell options.isimpersonation Whether this is an impersonation
    @cell(record) options.message Additional data
*/
PUBLIC MACRO WriteWRDAuditEvent(OBJECT wrdtype, STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ account :=    0
      , login :=      ""
      , message :=    DEFAULT RECORD
      , isimpersonation := FALSE
      ], options,
      [ required := [ "account" ]
      ]);

  RunInSeparatePrimary(PTR DoWriteAuditEvent(wrdtype, type, options.account, options.login, options.isimpersonation, options.message));
}

// Writes an audit log event to the database in separated transactions
MACRO DoWriteAuditEvent(OBJECT accounttype, STRING type, INTEGER affecteduser_entityid, STRING affecteduser_login, BOOLEAN isimpersonation, RECORD message)
{
  type := ToLowercase(type);
  IF(type NOT LIKE "?*:?*")
    THROW NEW Exception(`Invalid audit event type '${type}'`);

  // The log determines its own datetime, make sure the database logdate is just before or at that date
  DATETIME creationdate := GetCurrentDatetime();
  RECORD logged := LogAuditEventBy("wrd:auth", CELL
      [ affecteduser_login
      , affecteduser_entityid
      , type
      ], message);

  RECORD toinsert := CELL
      [ creationdate
      , wrdschema :=            accounttype->wrdschema->id
      , ip :=                   logged.auditcontext.remoteip
      , logged.auditcontext.country
      , logged.auditcontext.browsertriplet
      , type
      , impersonated :=         logged.auditcontext.impersonator_entityid != logged.auditcontext.user_entityid OR isimpersonation
      , impersonator_entity :=  logged.auditcontext.impersonator_entityid < 0 ? 0 : logged.auditcontext.impersonator_entityid
      , impersonator_login :=   logged.auditcontext.impersonator_login
      , byentity :=             logged.auditcontext.user_entityid < 0 ? 0 : logged.auditcontext.user_entityid
      , bylogin :=              logged.auditcontext.user_login
      , entity :=               logged.auditcontext.affecteduser_entityid
      , login :=                logged.auditcontext.affecteduser_login
      , data :=                 RecordExists(message) ? EncodeHSON(message) : ""
      ];

  GetPrimary()->BeginWork();
  INSERT toinsert INTO wrd.auditevents;

  TRY
  {
    GetPrimary()->CommitWork();
    BroadcastEvent(`wrd:auditlog.${accounttype->wrdschema->id}.${logged.auditcontext.affecteduser_entityid}`, DEFAULT RECORD);
    RETURN;
  }
  CATCH(OBJECT e)
  {
    //if commit fails, we might be racing against deletion of the entity (especially when logging out of a cleaned up wrd schema). are we ?
    IF(NOT RecordExists(SELECT FROM wrd.entities WHERE entities.id = affecteduser_entityid))
      RETURN; //okay, we can live with this

    //retry once more, but if this fails, too bad
    GetPrimary()->BeginWork();
    INSERT toinsert INTO wrd.auditevents;
    GetPrimary()->CommitWork();
    BroadcastEvent(`wrd:auditlog.${accounttype->wrdschema->id}.${logged.auditcontext.affecteduser_entityid}`, DEFAULT RECORD);
  }
}

/** Parses a subset an ISO8061 duration.
    Limitations:
    - fractions are only allowed with seconds, not with smallest item
    -
    @param duration Duration to parse
    @return Duration parts
    @cell(integer) return.years Number of years
    @cell(integer) return.months Number of months
    @cell(integer) return.weeks Number of weeks
    @cell(integer) return.days Number of days
    @cell(integer) return.hours Number of hours
    @cell(integer) return.minutes Number of minutes
    @cell(integer) return.seconds Number of seconds
    @cell(integer) return.milliseconds Number of milliseconds
*/
PUBLIC RECORD FUNCTION ParseDuration(STRING duration)
{
  IF (duration = "")
    RETURN DEFAULT RECORD;

  RECORD retval :=
      [ years :=          0
      , months :=         0
      , weeks :=          0
      , days :=           0
      , hours :=          0
      , minutes :=        0
      , seconds :=        0
      , milliseconds :=   0
      ];

  OBJECT parser := NEW StringParser(duration);

  IF (NOT parser->TryParse("P"))
    THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}`);

  BOOLEAN havet;
  STRING letters := "YMDHMSYMDHMS";
  STRING ARRAY long := [ "years", "months", "days", "hours", "minutes", "seconds" ];

  INTEGER lpos := 0;
  BOOLEAN haveitem;
  WHILE (NOT parser->eof)
  {
    IF (parser->TryParse("T"))
    {
      IF (havet)
        THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Multiple "T" letters found`);
      lpos := 3;
      havet := TRUE;
      CONTINUE;
    }

    INTEGER amount := ToInteger(parser->ParseWhileInSet(parser->set_digit), -1);
    BOOLEAN gotdot := parser->TryParse(".") OR parser->TryParse(",");
    IF (gotdot)
      retval.milliseconds := ToInteger(Left(parser->ParseWhileInSet(parser->set_digit) ||  "000", 3), -1);
    STRING type := parser->ParseN(1);

    IF (type = "")
      THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Missing type letter`);

    IF (type != "S" AND gotdot)
      THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Partial amounts only allowed for the seconds part`);
    IF (amount = -1)
      THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Coult not parse amount`);

    IF (type = "W")
    {
      IF (havet OR haveitem)
        THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Weeks only allowed as used as the only element in the duration`);
      retval.weeks := amount;
      haveitem := TRUE;
      BREAK;
    }

    INTEGER pos := SearchSubstring(letters, type, lpos);
    IF (pos = -1)
      THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Unknown type letter ${EncodeJSON(type)}`);
    IF (havet ? pos >= 6 : pos >= 3)
      THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: Letter ${EncodeJSON(type)} not allowed at this position`);

    retval := CellUpdate(retval, long[pos], amount);
    lpos := pos + 1;
    haveitem := TRUE;
  }

  IF (NOT parser->eof OR NOT haveitem)
    THROW NEW Exception(`Illegal duration specification ${EncodeJSON(duration)}: extra data ${EncodeJSON(parser->remaining_data)}`);

  RETURN retval;
}

DATETIME FUNCTION AddUnpackedDurationToDateInternal(RECORD duration, DATETIME date, INTEGER factor)
{
  FOREVERY (RECORD part FROM UnpackRecord(duration))
  {
    IF (part.value = 0)
      CONTINUE;
    SWITCH (part.name)
    {
      CASE "YEARS"          { date := AddYearsToDate(factor * part.value, date); }
      CASE "MONTHS"         { date := AddMonthsToDate(factor * part.value, date); }
      CASE "WEEKS"          { date := AddDaysToDate(factor * 7*part.value, date); }
      CASE "DAYS"           { date := AddDaysToDate(factor * part.value, date); }
      CASE "HOURS"          { date := AddTimeToDate(factor * 60*60*1000*part.value, date); }
      CASE "MINUTES"        { date := AddTimeToDate(factor * 60*1000*part.value, date); }
      CASE "SECONDS"        { date := AddTimeToDate(factor * 1000*part.value, date); }
      CASE "MILLISECONDS"   { date := AddTimeToDate(factor * part.value, date); }
    }
  }

  RETURN date;
}

PUBLIC DATETIME FUNCTION AddUnpackedDurationToDate(RECORD duration, DATETIME date)
{
  RETURN AddUnpackedDurationToDateInternal(duration, date, 1);
}

PUBLIC DATETIME FUNCTION SubtractUnpackedDurationToDate(RECORD duration, DATETIME date)
{
  RETURN AddUnpackedDurationToDateInternal(duration, date, -1);
}

/** Get a text describing a duration.
    @param duration ISO 8601 duration
    @return Duration string
*/
PUBLIC STRING FUNCTION GetDurationTitle(STRING duration)
{
  STRING ARRAY parts;
  FOREVERY (RECORD part FROM UnpackRecord(ParseDuration(duration)))
  {
    IF (part.value = 0)
      CONTINUE;
    SWITCH (part.name)
    {
      CASE "YEARS"   { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.years", ToString(part.value)) INTO parts AT END; }
      CASE "MONTHS"  { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.months", ToString(part.value)) INTO parts AT END; }
      CASE "WEEKS"   { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.weeks", ToString(part.value)) INTO parts AT END; }
      CASE "DAYS"    { INSERT GetTid("wrd:site.forms.authpages.passwordcheck.duration.days", ToString(part.value)) INTO parts AT END; }
      CASE "HOURS", "MINUTES", "SECONDS", "MILLISECONDS" { } // ignore for now.
    }
  }

  STRING retval;
  SWITCH (LENGTH(parts))
  {
    CASE 1 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts1", parts[0]); }
    CASE 2 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts2", parts[0], parts[1]); }
    CASE 3 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts3", parts[0], parts[1], parts[2]); }
    CASE 4 { retval := GetTid("wrd:site.forms.authpages.passwordcheck.duration.parts4", parts[0], parts[1], parts[2], parts[3]); }
  }
  RETURN retval;
}
