<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/otp.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";

LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/internal/rightsinfo.whlib";


PUBLIC MACRO SetCurrentStateCookie(OBJECT wrdauth, OBJECT plugin)
{
  IF(NOT IsRequest())
    RETURN;

  RECORD opts := [ domain := wrdauth->cookiedomain
                 , httponly := FALSE
                 , secure := wrdauth->securecookie
                 , lifetime := -1
                 , encrypt := FALSE
                 , samesite := wrdauth->samesitecookie
                 ];

  RECORD userinfo;
  STRING value;

  IF(wrdauth->IsLoggedIn())
  {
    userinfo := plugin->GetUserInfo();
    value := "." || (RecordExists(userinfo) ? EncodeJSON(userinfo) : "");

    STRING persisthash := EncodeUFS(GetMD5Hash(GetWebCookie(wrdauth->cookiename || "_p")));
    UpdateWebCookie(wrdauth->cookiename || "_c", value != "" ? persisthash || value : "", opts);

    opts.lifetime := wrdauth->GetPersistentCookieLifetime();
    UpdateWebCookie(wrdauth->cookiename || "_j", value != "" ? persisthash || "." : "", opts);
  }
  ELSE
  {
    UpdateWebCookie(wrdauth->cookiename, "");
    UpdateWebCookie(wrdauth->cookiename || "_j", "", opts);
    UpdateWebCookie(wrdauth->cookiename || "_c", "", opts);
    UpdateWebCookie(wrdauth->cookiename || "_p", "");
  }
}

/** @return
    @cell return.id
    @cell return.name
*/
PUBLIC RECORD FUNCTION LookupAuthobjectByEntityid(INTEGER entityid)
{
  STRING rawguid := SELECT AS STRING guid FROM wrd.entities WHERE id = entityid;
  IF(rawguid="")
    RETURN DEFAULT RECORD;

  RETURN LookupAuthobjectByGuid(EncodeWRDGUID(rawguid));
}

/** Returns authentication settings with the specified password hash as current password
    @param passwordhash Current password hash
    @return Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION CreateAuthenticationSettingsFromPasswordHash(STRING passwordhash)
{
  RECORD value := GetDefaultAuthenticationSettings();
  IF (passwordhash != "")
    INSERT CELL[ passwordhash, validfrom := DEFAULT DATETIME ] INTO value.passwords AT END;
  RETURN value;
}

/** Returns whether the specified authentication settings are the default value (no passwords set, no second factor set)
    @param value Authentication settings @includecelldef #ValidateAuthenticationSettingValue.return
    @return TRUE if the settings are default
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC BOOLEAN FUNCTION IsDefaultAuthenticationSettings(RECORD value)
{
  IF (NOT RecordExists(value))
    RETURN TRUE;
  BOOLEAN allempty := TRUE;
  FOREVERY (RECORD rec FROM UnpackRecord(value))
    IF (rec.name != "VERSION" AND IsValueSet(rec.value))
      RETURN FALSE;
  RETURN TRUE;
}

/** Returns a record with default authentication settings
    @return Default authentication settings record @includecelldef #ValidateAuthenticationSettingValue.return
    @public
    @topic wrdauth/api
    @loadlib mod::wrd/lib/auth.whlib
*/
PUBLIC RECORD FUNCTION GetDefaultAuthenticationSettings()
{
  RETURN
      [ version :=      1
      , passwords :=    RECORD[]
      , totp :=         DEFAULT RECORD
      ];
}

/** @param val Authantication settings to validate
    @return Validated authentication settings
    @cell(integer) return.version Settings version, should be 1.
    @cell(record array) return.passwords List of passwords, last one is current valid password.
    @cell(string) return.passwords.passwordhash Password hash.
    @cell(datetime) return.passwords.validfrom Date from when this password hash. Must be increasing and smaller than GetCurrentDateTime().
    @cell(record) return.totp TOTP second factor settings
    @cell(string) return.totp.url TOTP configuration url, see %GetTOTPUrl
    @cell(datetime) return.totp.locked Datime when normal code entry was locked due to too many failures
    @cell(record array) return.totp.backupcodes List of backup codes
    @cell(string) return.totp.backupcodes.code Backup code
    @cell(datetime) return.totp.used Date when backup code was used
*/
PUBLIC RECORD FUNCTION ValidateAuthenticationSettingValue(RECORD val)
{
  val := ValidateOptions(
      [ version :=    -1
      , passwords :=  DEFAULT RECORD ARRAY
      , totp :=       DEFAULT RECORD
      ], val,
      [ required :=   [ "version" ]
      , title :=      `data`
      ]);

  IF (val.version != 1)
    THROW NEW Exception(`Expected version 1`);

  FOREVERY (RECORD password FROM val.passwords)
  {
    val.passwords[#password] := ValidateOptions(
        [ passwordhash :=   ""
        , validfrom :=  DEFAULT DATETIME
        ], password,
        [ required :=     [ "passwordhash" ]
        , title := `data.passwords[${#password}]` ]);

    IF(password.passwordhash NOT LIKE "MD5:????????????????"
        AND password.passwordhash NOT LIKE "SSHA1:????????????????????????????"
        AND password.passwordhash NOT LIKE "XSHA1:????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "WHBF:????????????????????????????????????????????????????????????"
        AND password.passwordhash NOT LIKE "NETASP-SHA1:????????????????????*"
        AND password.passwordhash NOT LIKE "LCR:???*"
        AND password.passwordhash NOT LIKE "PLAIN:?*"
        AND password.passwordhash != ""
        AND password.passwordhash != "*")
      THROW NEW Exception(`Password in authenticationsettings.passwords[${#password}].passwordhash is receiving an unhashed password value - CreateWebharePasswordHash should have been invoked on the value`);

    IF (#password > 0 AND val.passwords[#password].validfrom <= val.passwords[#password-1].validfrom)
      THROW NEW Exception(`Passwords in authenticationsettings.passwords[${#password}] isn't properly sorted on validfrom`);

  }

  IF (IsValueSet(val.passwords) AND val.passwords[END-1].validfrom > GetCurrentDateTime())
    THROW NEW Exception(`Passwords in authenticationsettings.passwords[${LENGTH(val.passwords)-1}] activates in the future`);

  IF (RecordExists(val.totp))
  {
    val.totp := ValidateOptions(
        [ url :=          ""
        , backupcodes :=  RECORD[]
        , locked :=       DEFAULT DATETIME
        ], val.totp,
        [ required :=     [ "url" ]
        , title := `data.totp` ]);

    RECORD parsed := UnpackOTPUrl(val.totp.url);
    IF (parsed.type != "totp")
      THROW NEW Exception(`data.totp.url is not a valid TOTP url`);

    FOREVERY (RECORD code FROM val.totp.backupcodes)
    {
      val.totp.backupcodes[#code] := ValidateOptions(
          [ code :=       ""
          , used :=       DEFAULT DATETIME
          ], code,
          [ required :=     [ "code" ]
          , title := `data.totp.backupcodes[${#code}]`
          ]);
    }
  }
  RETURN val;
}

PUBLIC RECORD FUNCTION UpdateAuthenticationSettings(RECORD curvalue, RECORD newvalue)
{
  curvalue := curvalue ?? GetDefaultAuthenticationSettings();
  newvalue := ValidateAuthenticationSettingValue(newvalue ?? GetDefaultAuthenticationSettings());

  // used dates of TOTP backup codes must stay intact
  IF (RecordExists(curvalue.totp) AND RecordExists(newvalue.totp))
  {
    // don't allow value setting to overwrite set used dates of TOTP backup codes
    UPDATE newvalue.totp.backupcodes AS newcodes
       SET used := (SELECT AS DATETIME used FROM curvalue.totp.backupcodes WHERE code = newcodes.code) ?? used;
  }

  RETURN IsDefaultAuthenticationSettings(newvalue) ? DEFAULT RECORD : newvalue;
}
