<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/internal/auth/support.whlib";


RECORD FUNCTION GetCacheableWRDAuthConfig(STRING wrdschemaname)
{
  OBJECT wrdschema := OpenWRDSchema(wrdschemaname);
  IF(NOT ObjectExists(wrdschema))
  {
    RETURN [ value := CELL[ fatalerror := `No such schema '${wrdschemaname}'` ]
           , ttl := 15 * 60 * 1000
           , eventmasks := [ "wrd:schema.list" ]
           ];
  }

  IF(NOT ObjectExists(wrdschema->accounttype))
  {
    RETURN [ value := CELL[ fatalerror := `No accounttype defined for schema '${wrdschemaname}'` ]
           , ttl := 15 * 60 * 1000
           , eventmasks := wrdschema->GetEventMasks()
           ];
  }

  STRING ARRAY acceptable_configcells := SELECT AS STRING ARRAY name FROM UnpackRecord(wrdauth_defaultconfiguration);
  RECORD wrdauthconfig :=
      CELL[ ...wrdauth_defaultconfiguration
          , ...PickCells(wrdschema->GetSchemaSetting("wrd:auth.localsettings", [ fallback := DEFAULT RECORD ]), acceptable_configcells)
          , schemaid := wrdschema->id
          , loginemail := wrdschema->accountemailtag = wrdschema->accountlogintag
          , domainsecret := wrdschema->GetSchemaSetting("wrd:auth.domainsecret", [ fallback := "" ])
          , wrdschema->accountpasswordtag
          , wrdschema->accountpasswordisauthsettings
          , fallback_lastloginfield := ""
          ];

  IF(wrdauthconfig.domainsecret = "") // all should have a domainsecret now, otherwise you're using wrdauth without applying its schemadef?
    THROW NEW Exception(`wrd:auth.domainsecret has not been set on schema '${wrdschema->tag}'`);

  STRING ARRAY eventmasks := wrdschema->GetEventMasks() CONCAT wrdschema->GetSettingsEventMasks();

  // temporary fallback so users can migrate to lastloginfield= setting
  OBJECT authdomaintype := wrdschema->GetType("WRD_AUTHDOMAIN");
  IF(ObjectExists(authdomaintype) AND RecordExists(authdomaintype->GetAttribute("WRDAUTH_LASTLOGINFIELD")))
  {
    eventmasks := eventmasks CONCAT authdomaintype->GetEventMasks();
    FOREVERY(RECORD domain FROM  authdomaintype->RunQuery(
        [ outputcolumns := CELL[ "WRDAUTH_LASTLOGINFIELD" ]
        ]))
    {
      IF(domain.WRDAUTH_LASTLOGINFIELD != "" AND RecordExists(wrdschema->accounttype->GetAttribute(domain.WRDAUTH_LASTLOGINFIELD)))
        wrdauthconfig.fallback_lastloginfield := domain.WRDAUTH_LASTLOGINFIELD;
    }
  }

  RETURN [ value := wrdauthconfig
         , ttl := 15 * 60 * 1000
         , eventmasks := eventmasks
         ];
    }

//Get everything you need to know about WRDAuth's configuration, cacheable
PUBLIC RECORD FUNCTION GetWRDAuthConfig(STRING wrdschema)
{
  RETURN GetAdhocCached(CELL[ wrdschema ], PTR GetCacheableWRDAuthConfig(wrdschema));
}


/** Encrypts and signes data with the domain secret
    @param indata Data to encrypt
    @param type Type of data (also needed for decryption)
    @return Encoded and encrypted data
*/
PUBLIC STRING FUNCTION EncryptWRDAuthData(RECORD wrdauthconfig, RECORD indata, STRING type)
{
  IF(NOT RecordExists(indata))
    THROW NEW Exception("Trying to encrypt a default record");

  STRING encrypteddata := EncryptAndSignData(EncodeHSON(indata), "SHA-1,BLOWFISH+CBC,8", wrdauthconfig.domainsecret || type);
  RETURN encrypteddata;
}

/** Decodes previously encrypted data
    @param encrypteddata Encrypted data
    @param type Type of data (must match type used in EncryptData)
    @return Decrypted data (DEFAULT RECORD if decryption or validation failed)
*/
PUBLIC RECORD FUNCTION DecryptWRDAuthData(RECORD wrdauthconfig, STRING encrypteddata, STRING type)
{
  STRING data := DecryptSignedData(encrypteddata, "SHA-1,BLOWFISH+CBC,8", wrdauthconfig.domainsecret || type);
  RETURN data != "" ? DecodeHSON(data) : DEFAULT RECORD;
}

PUBLIC DATETIME FUNCTION CalculateWRDSessionExpiry(RECORD wrdauthconfig, DATETIME now, INTEGER64 expirytime)
{
  IF(expirytime <= 0)
    THROW NEW Exception(`Invalid expiry time configured`);

  DATETIME expiry := AddTimeToDate(expirytime, now);

  IF(wrdauthconfig.round_longlogins_to >= 0) //rounding is enabled (this is the default)
  {
    expiry := AddTimeToDate(wrdauthconfig.round_minduration, expiry);
    DATETIME localexpiry := UTCToLocal(expiry, wrdauthconfig.round_longlogins_tz);
    BOOLEAN wasnextday := GetMsecondCount(localexpiry) < wrdauthconfig.round_longlogins_to;

    //then we round it down
    localexpiry := MakeDateFromParts(GetDaycount(localexpiry) - (wasnextday ? 1 : 0), wrdauthconfig.round_longlogins_to);
    expiry := LocalToUTC(localexpiry, wrdauthconfig.round_longlogins_tz);
  }

  RETURN expiry;
}

PUBLIC STRING FUNCTION ExpandContextVariables(OBJECT webcontext, STRING indata)
{
  IF(indata NOT LIKE "*[*")
    RETURN indata;

  //TODO share with webserver config.whlib ?
  STRING sitename := webcontext->targetsite->name;
  RECORD vars := CELL[ sitename
                     , siteslug := Tolowercase(Substitute(sitename, " ", "-"))
                     ];

  FOREVERY (RECORD rec FROM UnpackRecord(vars))
    indata := Substitute(indata, `[${ToLowercase(rec.name)}]`, rec.value);

  //TODO fail if unexpected name
  indata := Substitute(indata,'[[','['); //support simple escaping

  RETURN indata;
}
