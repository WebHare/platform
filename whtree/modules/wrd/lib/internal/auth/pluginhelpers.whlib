<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/internal/auth/support.whlib";


RECORD FUNCTION GetCacheableWRDAuthConfig(STRING wrdschemaname, STRING sitetag)
{
  OBJECT wrdschema := OpenWRDSchema(wrdschemaname);
  IF(NOT ObjectExists(wrdschema))
  {
    RETURN [ value := CELL[ fatalerror := `No such schema '${wrdschemaname}'` ]
           , ttl := 15 * 60 * 1000
           , eventmasks := [ "wrd:schema.list" ]
           ];
  }

  IF(NOT ObjectExists(wrdschema->accounttype))
  {
    RETURN [ value := CELL[ fatalerror := `No accounttype defined for schema '${wrdschemaname}'` ]
           , ttl := 15 * 60 * 1000
           , eventmasks := wrdschema->GetEventMasks()
           ];
  }

  INTEGER authdomainid;
  IF(sitetag != "") //did you have too.... ?
  {
    OBJECT authdomaintype := wrdschema->GetType("WRD_AUTHDOMAIN");
    IF(NOT ObjectExists(authdomaintype))
      THROW NEW Exception(`The WRD schema '${wrdschema->tag}' does not have a type WRD_AUTHDOMAIN, needed to resolve sitetag '${sitetag}'`);

    authdomainid := authdomaintype->Search("WRD_TAG", sitetag, [matchcase := FALSE]);
    IF(authdomainid = 0)
    {
      RETURN [ value := CELL[ fatalerror := `No such auth site '${sitetag}' in schema '${wrdschemaname}'` ]
             , ttl := 15 * 60 * 1000
             , eventmasks := wrdschema->GetEventMasks()
             ];
    }
  }

  STRING ARRAY acceptable_configcells := SELECT AS STRING ARRAY name FROM UnpackRecord(wrdauth_defaultconfiguration);
  RECORD wrdauthconfig :=
      CELL[ ...wrdauth_defaultconfiguration
          , ...PickCells(wrdschema->GetSchemaSetting("wrd:auth.localsettings", [ fallback := DEFAULT RECORD ]), acceptable_configcells)
          , schemaid := wrdschema->id
          , loginemail := wrdschema->accountemailtag = wrdschema->accountlogintag
          //TODO various extra sanity checks on authdomainid are useless with domainless. do we need those checks back? feels like they should just entity GUIDs instead because some also use direct entityids
          , authdomainid
          , domainsecret := wrdschema->GetSchemaSetting("wrd:auth.domainsecret", [ fallback := "" ])
          , wrdschema->accountpasswordtag
          , wrdschema->accountpasswordisauthsettings
          ];

  IF(wrdauthconfig.domainsecret = "") // all should have a domainsecret now, otherwise you're using wrdauth without applying its schemadef?
    THROW NEW Exception(`wrd:auth.domainsecret has not been set on schema '${wrdschema->tag}'`);

  RETURN [ value := wrdauthconfig
         , ttl := 15 * 60 * 1000
         , eventmasks := wrdschema->GetEventMasks() CONCAT wrdschema->GetSettingsEventMasks()
         ];
    }

//Get everything you need to know about WRDAuth's configuration, cacheable
PUBLIC RECORD FUNCTION GetWRDAuthConfig(STRING wrdschema, STRING sitetag)
{
  RETURN GetAdhocCached(CELL[ wrdschema, sitetag ], PTR GetCacheableWRDAuthConfig(wrdschema, sitetag));
}


/** Encrypts and signes data with the domain secret
    @param indata Data to encrypt
    @param type Type of data (also needed for decryption)
    @return Encoded and encrypted data
*/
PUBLIC STRING FUNCTION EncryptWRDAuthData(RECORD wrdauthconfig, RECORD indata, STRING type)
{
  IF(NOT RecordExists(indata))
    THROW NEW Exception("Trying to encrypt a default record");

  STRING encrypteddata := EncryptAndSignData(EncodeHSON(indata), "SHA-1,BLOWFISH+CBC,8", wrdauthconfig.domainsecret || type);
  RETURN encrypteddata;
}

/** Decodes previously encrypted data
    @param encrypteddata Encrypted data
    @param type Type of data (must match type used in EncryptData)
    @return Decrypted data (DEFAULT RECORD if decryption or validation failed)
*/
PUBLIC RECORD FUNCTION DecryptWRDAuthData(RECORD wrdauthconfig, STRING encrypteddata, STRING type)
{
  STRING data := DecryptSignedData(encrypteddata, "SHA-1,BLOWFISH+CBC,8", wrdauthconfig.domainsecret || type);
  RETURN data != "" ? DecodeHSON(data) : DEFAULT RECORD;
}

PUBLIC DATETIME FUNCTION CalculateWRDSessionExpiry(RECORD wrdauthconfig, DATETIME now, INTEGER64 expirytime)
{
  IF(expirytime <= 0)
    THROW NEW Exception(`Invalid expiry time configured`);

  DATETIME expiry := AddTimeToDate(expirytime, now);

  IF(wrdauthconfig.roundup_longlogins_to >= 0) //rounding is enabled (this is the defualt)
  {
    /* TODO short login periods (less than a day) probably shouldn't be extended to the 'rounding' time. but where should the (default) cutoff be ?
            for now just recommend against logindurations < 1 day */
    DATETIME localexpiry := UTCToLocal(expiry, wrdauthconfig.roundup_longlogins_tz);
    BOOLEAN addday := GetMsecondCount(localexpiry) <= wrdauthconfig.roundup_longlogins_to;

    //then we round it down
    localexpiry := MakeDateFromParts(GetDaycount(localexpiry), wrdauthconfig.roundup_longlogins_to);
    expiry := LocalToUTC(localexpiry, wrdauthconfig.roundup_longlogins_tz);
  }

  RETURN expiry;
}
