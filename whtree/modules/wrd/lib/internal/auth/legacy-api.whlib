<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::util/otp.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/auth/support.whlib";
LOADLIB "mod::wrd/lib/internal/auth/pluginhelpers.whlib";
LOADLIB "mod::wrd/lib/internal/wrdsettings.whlib";

CONSTANT INTEGER cookie_version := 2;
CONSTANT INTEGER max_totp_attempts := 6;

PUBLIC RECORD FUNCTION ParseIDCookie(STRING idcookie) {
  IF(idcookie NOT LIKE "* accessToken:*")
    RETURN DEFAULT RECORD;

  STRING sessionid := Left(idcookie, SearchSubstring(idcookie, ' '));
  STRING idtoken := Substring(idcookie, SearchSubstring(idcookie,':')+1); //grab the token
  STRING ARRAY toks := Tokenize(idtoken,'.');
  IF(Length(toks) != 3)
    RETURN DEFAULT RECORD;

  RECORD claims := DecodeJSON(DecodeUFS(toks[1]));
  IF(NOT RecordExists(claims))
    RETURN DEFAULT RECORD;

  STRING tokenhash := GetHashForString(idtoken, "SHA-256");
  //this isn't 2038 safe, let's hope HS wrdauth is cancelled before that
  DATETIME expires := CellExists(claims,'exp') AND TypeID(claims.exp) = TYPEID(INTEGER) ? MakeDatetimeFromUnixTimestamp(claims.exp) : DEFAULT DATETIME;

  RETURN CELL[ idtoken, claims, tokenhash, expires, sessionid ];
}

/** Returns second factor state
    @param(object %WRDEntity2017) entity Entity to login for
    @return Second factor login state
    @cell return.curinit Currently active second factor login entry
    @cell return.totpfailures Number of TOTP failures since last succesfull login
    @cell return.totpattemptsleft Number of TOTP normal code login attempts left
    @cell return.totpblockedcodes Valid codes used for succesfull login in current code window (not allowed to login with those, wait until next code)
*/
PUBLIC RECORD FUNCTION GetSecondFactorState(OBJECT wrdschema, INTEGER entityid)
{
  /* Only look a the login events from a day back. Allow a fixed number of tries per day
      Only need audit events with logged data

      Needed events:
      - wrd:login:secondfactor:*
      - wrd:authsettings.setuptotp
  */
  RECORD ARRAY auditevents :=
      SELECT creationdate
            , COLUMN type
            , data := DecodeJSON(COLUMN data)
        FROM wrd.auditevents
        WHERE COLUMN entity = VAR entityid
          AND creationdate >= AddDaysToDate(-1, GetCurrentDateTime())
          AND type LIKE "platform:secondfactor.*"
     ORDER BY creationdate DESC;

  // current open second factor login
  RECORD curinit;

  // secondfactorlogin init for this validation
  STRING ARRAY used_challenges;
  FOREVERY (RECORD rec FROM auditevents) {
    IF(rec.type = "platform:secondfactor.failed")
      INSERT rec.data.challenge INTO used_challenges AT END;
    ELSE IF(rec.type = "platform:secondfactor.challenge") {
      IF(rec.data.challenge NOT IN used_challenges)
        curinit := rec;
      BREAK;
    }
  }


  STRING ARRAY totpblockedcodes;

  // https://tools.ietf.org/html/rfc6238#section-5: The verifier MUST NOT accept
  // the second attempt of the OTP after the successful validation has
  // been issued for the first OTP, which ensures one-time only use of an
  // OTP.
  DATETIME reusecode_cutoff := AddTimeToDate(-90 * 1000, GetRoundedDateTime(GetCurrentDatetime(), 30 * 1000));
  FOREVERY (RECORD rec FROM auditevents)
  {
    IF (rec.creationdate < reusecode_cutoff)
      BREAK;

    IF (rec.type = "platform:secondfactor.ok")
      INSERT rec.data.code INTO totpblockedcodes AT END;
  }

  // count totp failures since last login
  INTEGER totpfailures;
  FOREVERY (RECORD rec FROM auditevents)
  {
    // A totpreusedcode isn't counted toward the totpfailures
    IF (rec.type = "platform:secondfactor.failed")
    {
      IF (rec.data.failurecode = "TOTPINVALIDCODE" OR rec.data.failurecode = "TOTPLOCKED")
        totpfailures := totpfailures + 1;
    }
    IF (rec.type = "platform:secondfactor.ok" OR rec.type = "platform:secondfactor.setuptotp")
      BREAK;
  }

  INTEGER totpattemptsleft := max_totp_attempts - totpfailures;
  IF (totpattemptsleft < 0)
    totpattemptsleft := 0;

  RETURN CELL
      [ curinit
      , totpfailures
      , totpattemptsleft
      , totpblockedcodes
      ];
}

/** @param(object %WRDEntity2017) entity Entity to verify second factor for
    @param type Type of 2fa verification (allowed: 'totp')
    @param data Verification data
    @cell(string) data.code TOTP code
    @param logindata Login data for logging
    @cell(string) logindata.challenge Base64 encoded login challenge
    @cell(boolean) logindata.isimpersonation
    @cell(string) logindata.ip
    @cell(string) logindata.login
    @return Verification result
    @cell(boolean) return.success TRUE if validation went ok
    @cell(string) return.code
              - OK: verification success
              - INVALIDDATA: verification failed, please login with password again
              - TOTPLOCKED: too many failed attempts, please use backup codes (totp only)
              - TOTPINVALIDCODE: invalid attempt (totp only)
              - TOTPREUSEDCODE: reused a code already accepted in a previous login attempt (totp only)
    @cell(string) return.nonce Updated nonce for next attempt (only for codes TOTPINVALIDCODE and TOTPREUSEDCODE)
    @cell(object %WRDEntity2017) return.entity User entity (only for code OK)
*/
PUBLIC RECORD FUNCTION ValidateSecondFactor(OBJECT wrdschema, INTEGER entityid, STRING type, RECORD data, RECORD logindata)
{
  OBJECT lock := OpenLocalLockManager()->LockLocalMutex(`wrd:auth.2fa.${entityid}`);

  TRY
  {
    STRING returncode := "";
    RECORD response;
    DATETIME now := GetCurrentDatetime();

    IF (NOT wrdschema->accountpasswordisauthsettings)
      RETURN [ success := FALSE, code := "INVALIDDATA" ];

    RECORD settings := wrdschema->accounttype->GetEntityField(entityid, wrdschema->accountpasswordtag);
    IF (NOT RecordExists(settings))
      RETURN [ success := FALSE, code := "INVALIDDATA" ];
    IF (NOT RecordExists(settings.totp))
      RETURN [ success := FALSE, code := "INVALIDDATA" ];

    RECORD state := GetSecondFactorState(wrdschema, entityid);

    IF (NOT RecordExists(state.curinit))
      RETURN [ success := FALSE, code := "SESSIONEXPIRED" ];

    BOOLEAN updatesettings; // should settings be written back?
    RECORD logmessagedata;
    INTEGER totpattemptsleft := state.totpattemptsleft;

    SWITCH (type)
    {
      CASE "totp"
      {
        RECORD parsed := UnpackOTPUrl(settings.totp.url);

        logmessagedata := CELL[ data.code ];

        IF (LENGTH(data.code) = parsed.options.digits)
        {
          IF (IsValueSet(settings.totp.locked))
            returncode := "TOTPLOCKED";
          ELSE
          {
            BOOLEAN ismatch := TestTOTPCode(parsed.secret, data.code, parsed.options).success;

            IF (ismatch)
            {
              // https://tools.ietf.org/html/rfc6238#section-5: The verifier MUST NOT accept
              // the second attempt of the OTP after the successful validation has
              // been issued for the first OTP, which ensures one-time only use of an
              // OTP.
              IF (data.code IN state.totpblockedcodes)
                returncode := "TOTPREUSEDCODE";
            }

            // count failures since last login
            totpattemptsleft := state.totpattemptsleft - (ismatch ? 0 : 1);
            IF (totpattemptsleft <= 0)
            {
              totpattemptsleft := 0;
              settings.totp.locked := GetCurrentDatetime();
              updatesettings := TRUE;
              returncode := "TOTPLOCKED";
            }
            ELSE IF (NOT ismatch)
              returncode := "TOTPINVALIDCODE";
            ELSE IF (returncode = "")
              returncode := "OK";
          }
        }
        ELSE // might be backup code
        {
          RECORD backupcode := SELECT * FROM settings.totp.backupcodes WHERE code = data.code;
          IF (NOT RecordExists(backupcode))
            returncode := "TOTPINVALIDCODE";
          ELSE IF (backupcode.used != DEFAULT DATETIME)
            returncode := "TOTPREUSEDCODE";
          ELSE
          {
            UPDATE settings.totp.backupcodes
                SET used := now
              WHERE code = data.code;
            updatesettings := TRUE;
            returncode := "OK";
          }
        }

        IF (updatesettings)
        {
          GetPrimary()->BeginWork();
          wrdschema->accounttype->UpdateEntity(entityid, CellInsert(CELL[], wrdschema->accountpasswordtag, settings));
          GetPrimary()->CommitWork();
        }
      }
      DEFAULT
      {
        THROW NEW Exception(`Second factor login type ${EncodeJSON(type)} not supported`);
      }
    }

    RETURN returncode = "OK"
        ? CELL[ success := TRUE, code := "OK", entity := entityid, totpattemptsleft ]
        : CELL[ success := FALSE, code := returncode, totpattemptsleft ];
  }
  FINALLY
  {
    lock->Close();
  }
}

PUBLIC STATIC OBJECTTYPE WRDAuth <
  //
  // Variables
  //

  OBJECT wrdschema;
  RECORD wrdauthconfig;
  RECORD __WRDAuthPluginSettings_HS;

  BOOLEAN did_wrdauthjs_check;

  // Cookie containing idtoken
  STRING idcookie;

  // Parsed id cookie
  RECORD wrdauthjs;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT wrdschema, RECORD wrdauthconfig, RECORD __WRDAuthPluginSettings_HS) {
    this->__WRDAuthPluginSettings_HS := __WRDAuthPluginSettings_HS;
    this->wrdschema := wrdschema;
    this->wrdauthconfig := wrdauthconfig;

    this->loggedinentity := -1;
    this->loggedinexpires := DEFAULT DATETIME;
    this->authenticatewebsession := TRUE;

    this->cookiename := "webharelogin"; //ADDME Make webhare webserver optimize access checking for other cookie names
    this->samesitecookie := "lax";
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //


  /** Lookup a user based on field and contents of that field
      @param field to search. If field isn't WRD_GUID and you haven't switched to authentication settings yet, the password field must be filled for the lookup to succeed (this behaviour is now deprecated!)
      @param value Contents of field to match
      @return Id of user iff exactly one user matched.
  */
  INTEGER FUNCTION DoLookup(STRING field, STRING value)
  {
    RECORD ARRAY filters := [ [ field := field, value := TrimWhitespace(value), matchcase := FALSE ] ];

    RECORD outputcolumns := [ id := "WRD_ID" ];
    IF (field != "WRD_GUID" AND NOT this->wrdschema->accountpasswordisauthsettings)
      INSERT CELL auth := this->wrdschema->accountpasswordtag INTO outputcolumns;

    RECORD ARRAY q := this->wrdschema->accounttype->RunQuery( CELL
        [ outputcolumns
        , filters
        ]);

    IF (field != "WRD_GUID" AND NOT this->wrdschema->accountpasswordisauthsettings)
      DELETE FROM q WHERE auth = "";

    RETURN Length(q)=1 ? q[0].id : 0;
  }

  // ---------------------------------------------------------------------------
  //
  // Semi-public API
  //

  /** Creates login cookies
      @param userid
      @param cookietype cookietype_session, cookietype_persistent, cookietype_external
      @param options
      @cell options.path Path to encode in external cookie (optional)
      @cell(datetime) options.setcreationdate Enforce this cookie creation date
      @return Encoded cookies, or default record if cookie is already expired
      @cell return.session Session cookie
      @cell return.persistent Persistent cookie
      @cell return.external External cookie
  */
  PUBLIC RECORD FUNCTION __CreateLoginCookies(INTEGER userid, INTEGER cookietype, BOOLEAN impersonation, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ path := ""
                               , setcreationdate := DEFAULT DATETIME
                               ], options);

    IF (cookietype != cookietype_external) {
      //Delegating this to JS now
      //FIXME how to get the proper target url when eg being invoked by a RPC service ?
      this->loggedinentity := userid; //shortcircuit attempts to parse the internal cookies immediately after login
      RETURN CallJS("@mod-platform/js/auth/harescript.ts#prepareLoginCookies", this->__WRDAuthPluginSettings_HS, userid, impersonation, cookietype = cookietype_persistent, cookietype = cookietype_thirdparty, options.setcreationdate ?? GetCurrentDatetime());
    }

    //TODO _e / external cookies still need quite some revision, ideally a self-contained JWT

    RECORD cookies :=
        [ logincookie := ""
        , logincookielifetime := 0i64
        , external :=   ""
        , expires :=    DEFAULT DATETIME
        ];

    DATETIME now := GetCurrentDatetime();
    DATETIME creationdate := options.setcreationdate ?? now;
    INTEGER64 expirytime := cookietype = cookietype_thirdparty ? INTEGER64(this->wrdauthconfig.expire_thirdpartylogin)
                            : cookietype = cookietype_persistent ? INTEGER64(this->wrdauthconfig.expire_persistentlogin)
                            : INTEGER64(this->wrdauthconfig.expire_login);
    IF(expirytime <= 0)
      THROW NEW Exception(`Invalid expiry time configured`);

    cookies.expires := CalculateWRDSessionExpiry(this->wrdauthconfig, creationdate, expirytime);
    IF(options.setcreationdate != DEFAULT DATETIME AND now >= cookies.expires) //if the expiry time isn't ridiculously short (because that's probably someone testing) then do not create cookies that expire immediately
      RETURN DEFAULT RECORD; //the cookie has already expired

    STRING ARRAY fieldnames := ["WRD_GUID", this->wrdschema->accountpasswordtag ];
    RECORD fields := this->wrdschema->accounttype->GetEntityFields(userid, fieldnames, [ historymode := "now" ]);
    IF(NOT RecordExists(fields))
      THROW NEW Exception("Invalid account #" || userid);

    RECORD cookiedata := [ v := cookie_version
                         , user := userid
                         , cs := creationdate
                         , exp := cookies.expires
                         , wg := fields.wrd_guid
                         ];
    IF(cookietype != 0)
      INSERT CELL t := cookietype INTO cookiedata;

    IF (cookietype = cookietype_persistent)
    {
      VARIANT authdata := GetCell(fields, this->wrdschema->accountpasswordtag);
      STRING passwordhash := NOT this->wrdschema->accountpasswordisauthsettings
          ? STRING(authdata)
          : RecordExists(authdata) AND RecordExists(authdata.passwords)
              ? authdata.passwords[END-1].passwordhash
              : "";

      //FIXME shouldn't we still hash the password someway, even though encrypted? .. and FIXME shouldn't any password change invalidate your cookies (but how to safely deal with changes during a session?)
      INSERT CELL p := passwordhash INTO cookiedata;
    }

    IF (cookietype = cookietype_external)
    {
      RECORD copy := cookiedata;
      IF (options.path != "")
        INSERT CELL pa := options.path INTO copy;
      cookies.external := this->EncryptData(copy, "external");
    }
    ELSE
    {
      cookies.logincookie := this->EncryptData(cookiedata, "session");
      cookies.logincookielifetime := cookietype = cookietype_persistent ? (expirytime + 999) / 1000 : 0i64;
    }

    RETURN cookies;
  }

  /** Decodes and validates cookie data
      @param cookie
      @param type Type of cookie, one of "session", "external", "persistent"
      @return User data (DEFAULT RECORD if decoding/validating failed)
      @cell return.userid User (existence has been checked)
      @cell return.creationdate
      @cell return.path Path (only available for some external cookies)
  */
  PUBLIC RECORD FUNCTION __ParseCookie(STRING cookie, STRING type)
  {
    IF (type NOT IN [ "session", "persistent", "external" ])
      THROW NEW Exception("Illegal cookie type '" || type || "'");

    RECORD data := this->DecryptData(cookie, type);
    IF(NOT Recordexists(data) OR data.v != 2)
      RETURN DEFAULT RECORD;

    STRING ARRAY fieldnames := ["WRD_GUID", this->wrdschema->accountpasswordtag ];
    RECORD fields := this->wrdschema->accounttype->GetEntityFields(data.user, fieldnames, [ historymode := "now" ]);
    IF(NOT RecordExists(fields))
      RETURN DEFAULT RECORD;

    IF(fields.wrd_guid != data.wg)
      RETURN DEFAULT RECORD;
    IF(type = "persistent")
    {
      VARIANT authdata := GetCell(fields, this->wrdschema->accountpasswordtag);
      STRING passwordhash := NOT this->wrdschema->accountpasswordisauthsettings
          ? STRING(authdata)
          : RecordExists(authdata) AND RecordExists(authdata.passwords)
              ? authdata.passwords[END-1].passwordhash
              : "";
      IF (data.p != passwordhash)
        RETURN DEFAULT RECORD;
    }

    RECORD cookiedata := [ userid := data.user
                         , creationdate := data.cs
                         , expires := CellExists(data,'exp') ? data.exp : DEFAULT DATETIME
                         , cookietype := CellExists(data,'t') ? data.t : 0
                         ];

    IF (CellExists(data, "PA"))
      INSERT CELL path := data.pa INTO cookiedata;
    RETURN cookiedata;
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //


  /** Encrypts and signes data with the domain secret
      @param indata Data to encrypt
      @param type Type of data (also needed for decryption)
      @return Encoded and encrypted data
  */
  STRING FUNCTION EncryptData(RECORD indata, STRING type DEFAULTSTO "")
  {
    IF(NOT RecordExists(indata))
      THROW NEW Exception("Trying to encrypt a default record");

    STRING ds := GetWRDSetting(this->wrdschema, "domain_secret");
    IF(ds = "") // all should have a domainsecret now, otherwise you're using wrdauth without applying its schemadef
      THROW NEW Exception(`wrd:auth.domainsecret has not been set`);

    STRING encrypteddata := EncryptAndSignData(EncodeHSON(indata), "SHA-1,BLOWFISH+CBC,8", ds || type);
    RETURN encrypteddata;
  }

  /** Decodes previously encrypted data
      @param encrypteddata Encrypted data
      @param type Type of data (must match type used in EncryptData)
      @return Decrypted data (DEFAULT RECORD if decryption or validation failed)
  */
  RECORD FUNCTION DecryptData(STRING encrypteddata, STRING type DEFAULTSTO "")
  {
    STRING data;
    STRING ds := GetWRDSetting(this->wrdschema, "domain_secret");
    IF(ds = "") // all should have a domainsecret now, otherwise you're using wrdauth without applying its schemadef
      THROW NEW Exception(`wrd:auth.domainsecret has not been set`);

    data  := DecryptSignedData(encrypteddata, "SHA-1,BLOWFISH+CBC,8", ds || type);
    RETURN data != "" ? DecodeHSON(data) : DEFAULT RECORD;
  }

  /** Looks up a user based on the login name. The user must have a non-default password.
      @param login Login name
      @return User id
  */
  PUBLIC INTEGER FUNCTION LookupLogin(STRING login)
  {
    RETURN this->DoLookup(this->wrdschema->accountlogintag, login);
  }

  RECORD FUNCTION serviceLoginById(INTEGER entityid, BOOLEAN impersonate, INTEGER cookietype, RECORD options)
  {
    OBJECT the_entity := this->wrdschema->accounttype->GetEntity(entityid);
    IF(NOT ObjectExists(the_entity))
      RETURN [ success := FALSE, code := "UNKNOWNLOGIN" ];

    RETURN this->FinalizeLogin(the_entity, impersonate, cookietype, "", "", TRUE, options);
  }

  STRING FUNCTION GenerateSecondFactorLoginChallenge()
  {
    // WebAuthn 13.4.3. Cryptographic Challenges: challenges should be at least 16 bytes long.
    RETURN EncodeBase64(GenerateRandomBinaryValue(16));
  }

  /** @param loginproof Login proof generated by #Login
      @param type Type of 2fa verification (allowed: 'totp')
      @param data Verification data
      @cell(string) data.code TOTP code
      @param ip Remote ip address
      @param options @includecelldef #FinalizeLogin.options
      @return @includecelldef #FinalizeLogin.return
      @cell return.code Result code if verification failed:
                - INVALIDDATA: Login proof expired/decryption failed, please login with password again
                - TOTPLOCKED: too many failed attempts, please use backup codes (totp only)
                - TOTPINVALIDCODE: invalid attempt (totp only)
                - TOTPREUSEDCODE: reused a code already accepted in a previous login attempt (totp only)
      @cell return.totpattemptsleft Updated login proof for next attempt (only for codes TOTPINVALIDCODE and TOTPREUSEDCODE)
      @cell return.entityid User entityid
      @cell return.login User login
  */
  RECORD FUNCTION serviceLoginSecondFactor(STRING loginproof, STRING type, RECORD data, STRING ip, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    DATETIME now := GetCurrentDatetime();

    RECORD logindata := this->DecryptData(loginproof, "wrd:2faloginproof");
    IF (NOT RecordExists(logindata))
      RETURN [ success := FALSE, code := "INVALIDDATA", entityid := 0, login := "" ];
    IF (logindata.validuntil < now)
      RETURN [ success := FALSE, code := "INVALIDDATA", entityid := 0, login := "" ];

    OBJECT the_entity := this->wrdschema->accounttype->GetEntity(logindata.entityid);
    IF (NOT ObjectExists(the_entity))
      RETURN [ success := FALSE, code := "INVALIDDATA", entityid := 0, login := "" ];

    UpdateAuditContext([ user_entityid := logindata.entityid, user_login := logindata.login ]);

    RECORD response := ValidateSecondFactor(this->wrdschema, logindata.entityid, type, data, logindata);

    RECORD logdata;
    RECORD secondfactordata;

    SWITCH (response.code)
    {
      CASE "OK"
      {
        TRY
        {
          GetPrimary()->BeginWork();
          response := this->FinalizeLogin(this->wrdschema->accounttype->GetEntity(response.entity), logindata.isimpersonation, logindata.cookietype, logindata.login, ip, TRUE, PickCells(options, [ "firstloginfield", "lastloginfield" ]));

          RETURN CELL
              [ ...response
              , secondfactordata :=         DEFAULT RECORD
              , logdata := CELL
                    [ data.code
                    , usedchallenge :=      logindata.challenge
                    , decodedlogindata :=   logindata
                    ]
              ];
        }
        FINALLY (OBJECT e)
        {
          IF (ObjectExists(e))
            GetPrimary()->RollbackWork();
          ELSE
            GetPrimary()->CommitWork();
        }
      }
      CASE "TOTPINVALIDCODE", "TOTPREUSEDCODE", "TOTPLOCKED"
      {
        // generate a new challenge
        STRING challenge := this->GenerateSecondFactorLoginChallenge();
        loginproof := this->EncryptData(CELL
              [ ...logindata
              , challenge
              ], "wrd:2faloginproof");

        secondfactordata := CELL
            [ challenge
            , response.totpattemptsleft
            , totp :=       TRUE
            , firstfactorproof :=   loginproof
            ];
      }
      CASE "SESSIONEXPIRED"
      {
        // no updating of login proof or second factor data, just login again
      }
      DEFAULT
      {
        THROW NEW Exception(`Unknown result code ${EncodeJSON(response.code)}`);
      }
    }

    RETURN CELL
        [ success :=            response.code = "OK"
        , response.code
        , logdata :=            CELL[ decodedlogindata := logindata
                                    , usedchallenge :=    logindata.challenge
                                    ]
        , secondfactordata
        , logindata.entityid
        , logindata.login
        ];
  }

  /** @param the_entity WRD entity of the user to log in
      @param isimpersonation Whether this is an impersonation
      @param cookietype The type of cookie: cookietype_session, cookietype_thirdparty, cookietype_persistent or cookietype_external
      @param login Unused
      @param ip Remote IP of the request
      @param updatelogindata Whether to update the first/last login date
      @cell options.firstloginfield @includecelldef #UpdateLastLoginAndIp.options.firstloginfield
      @cell options.lastloginfield @includecelldef #UpdateLastLoginAndIp.options.lastloginfield
      @cell(datetime) options.setcreationdate Override the creationdate of the cookie
      @return Result
      @cell(boolean) return.success Always TRUE
      @cell(string) return.code Always ""
      @cell(integer) return.entityid Id of the logged in entity
      @cell(string) return.entityguid GUID of the logged in entity
      @cell(integer) return.domain Authentication domain id
      @cell(string) return.login Login name of the logged in entity
      @cell(string) return.domaintitle Title of the authentication domain
      @cell(string) return.logincookie Login cookie
      @cell(string) return.persistentcookie Persistent cookie
      @cell(boolean) return.isimpersonation Whether this is an impersonation
      @cell(boolean) return.persistent Whether persistent login was requested
      @cell(datetime) return.expires When the current session expires
  */
  RECORD FUNCTION FinalizeLogin(OBJECT the_entity, BOOLEAN isimpersonation, INTEGER cookietype, STRING login, STRING ip, BOOLEAN updatelogindata, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD cookies := this->__CreateLoginCookies(the_entity->id, cookietype, isimpersonation, PickCells(options, ["SETCREATIONDATE"]));
    IF(NOT RecordExists(cookies))
      RETURN DEFAULT RECORD;

    RETURN CELL
           [ code := ""
           , ...cookies
           , success := TRUE
           , entityid := the_entity->id
           , entityguid :=  the_entity->guid
           , login := the_entity->GetField(this->wrdschema->accountlogintag)
           , isimpersonation := isimpersonation
           //, persistent := persistent
           ];
  }

  STRING sessionid;
  RECORD sessiondata;
  INTEGER loggedinentity;
  DATETIME loggedinexpires;

  /// Cache current cookie values. Used specially to implement logout-relogin properly
  RECORD cookiecache;

  /// Cookie in which to store the session id. If changed, change it to the form webharelogin-123-456-789 (appending -s and numbers will allow optimization, multiple sets of numbers are unlikely to collide with webhare generated 'webharelogin's)
  PUBLIC STRING cookiename;

  /// Disable httponly flag on sensitive cookies
  PUBLIC BOOLEAN nohttponlycookies;
  /// Cookie domain. Leave empty to make the cookie apply only to the current domain
  PUBLIC STRING cookiedomain;
  /// Set the time in minutes the loginstate cookie should last (keeping a user logged in). Defaults to 0 (no limit, and 365 days for a permanent cookie)
  PUBLIC INTEGER logintime;
  /// Set to make the cookies secure (only transferrable over https)
  PUBLIC BOOLEAN securecookie;
  /// Set the samesite value of the cookie
  PUBLIC STRING samesitecookie;
  /// Automatically authenticate the web session for the access rule ? (defaults to TRUE)
  PUBLIC BOOLEAN authenticatewebsession;

  BOOLEAN FUNCTION IsValidAccountEntity(INTEGER entityid) {
    //TODO deal with parent/child types? not sure if they're ever relevant though
    RETURN RecordExists(SELECT FROM wrd.entities WHERE id = VAR entityid AND limitdate > GetCurrentDatetime() AND type = this->wrdschema->accounttype->id);
  }

  /** @short Check for active login session */
  MACRO CheckForSession() {
    IF(NOT this->did_wrdauthjs_check) {
      this->did_wrdauthjs_check := TRUE;
      this->loggedinentity := 0;

      //Do we happen to see an ID Token in the login cookie?
      IF(IsRequest()) {
        STRING prefix := GetRequestURL() LIKE "https:*" ? this->cookiedomain != "" ? "__Secure-" : "__Host-" : ""; //see TS getIdCookieName
        this->idcookie := GetWebCookie(prefix || this->cookiename);
        RECORD parsed := ParseIDCookie(this->idcookie);

        IF(RecordExists(parsed)) {
          RECORD match := SELECT entity, id, expirationdate FROM wrd.tokens WHERE hash = parsed.tokenhash AND client = 0 AND type = "id" AND expirationdate > GetCurrentDateTime(); //find a session attached to us
          IF(RecordExists(match) AND this->IsValidAccountEntity(match.entity)) { //It's s a hit!
            this->wrdauthjs := [
              ...parsed,
              token := match.id,
              entity := match.entity
            ];

            this->loggedinentity := match.entity;
            this->loggedinexpires := match.expirationdate;

            this->sessiondata :=
              CELL[ this->wrdauthjs.expires
                  , entityid := this->wrdauthjs.entity
                  ];

            this->sessionid := Tokenize(this->idcookie,' ')[0];
            UpdateAuditContext(CELL[ user_entityid := this->wrdauthjs.entity ]);
            RETURN;
          }
        }
      }
    }
  }

  PUBLIC INTEGER FUNCTION GetLoggedinEntity() {
    IF(this->loggedinentity = -1)
      this->CheckForSession();
    RETURN this->loggedinentity;
  }

  PUBLIC MACRO SetLoggedinEntity(INTEGER entityid) {
    this->loggedinentity := entityid;
  }

  PUBLIC DATETIME FUNCTION GetLoggedinExpires() {
    this->CheckForSession();
    RETURN this->loggedinexpires;
  }

  PUBLIC STRING FUNCTION GetLoggedinEntityLogin()
  {
    this->CheckForSession();
    RETURN this->loggedinentity > 0 ? this->wrdschema->accounttype->GetEntityField(this->loggedinentity, this->wrdschema->accountlogintag) : "";
  }

  PUBLIC STRING FUNCTION GetIDToken() {
    this->CheckForSession();
    RETURN RecordExists(this->wrdauthjs) ? this->wrdauthjs.idtoken : "";
  }

  PUBLIC RECORD FUNCTION GetClaims() {
    this->CheckForSession();
    RETURN RecordExists(this->wrdauthjs) ? this->wrdauthjs.claims : DEFAULT RECORD;
  }

  /** @short Are we currently logged in ? */
  PUBLIC BOOLEAN FUNCTION IsLoggedIn() {
    RETURN this->GetLoggedinEntity() > 0;
  }

  /** @short Login as a specific user
      @param userid WRD Entity id to login
      @param is_impersonation If true, consider this an impersonation login - don't update lastlogin etc
      @return Login result
      @cell return.success TRUE if login was successfull
      @cell return.code Error code
  */
  PUBLIC RECORD FUNCTION LoginById(INTEGER userid, BOOLEAN is_impersonation, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    STRING remoteip := CellExists(options,"REMOTEIP") AND options.remoteip != "" ? options.remoteip : IsRequest() ? GetClientRemoteIp() : "";
    BOOLEAN persistent := CellExists(options, 'persistent') AND options.persistent;
    BOOLEAN thirdparty := CellExists(options, 'thirdparty') AND options.thirdparty;
    INTEGER cookietype := thirdparty ? cookietype_thirdparty : persistent ? cookietype_persistent : cookietype_session;

    this->loggedinentity := -1;
    RECORD trylogin := GetPrimary()->ExecuteInWork(PTR this->serviceLoginById(userid, is_impersonation, cookietype, options));
    IF(NOT trylogin.success)
    {
      //this->WriteAuditEvent("WRD:" || trylogin.code,
      //    [ account := userid
      //    , remoteip := remoteip
      //    , isimpersonation := is_impersonation
      //    ]);
      RETURN trylogin;
    }

    RECORD res := this->CompleteLogin(trylogin, TRUE, "", options);
    //IF (res.success)
    //  this->WriteAuditEvent("WRD:LOGINID",
    //      [ account := trylogin.entityid
    //      , remoteip := remoteip
    //      , isimpersonation := trylogin.isimpersonation
    //      ]);
    RETURN res;
  }

  PUBLIC RECORD FUNCTION LoginSecondFactor(STRING loginproof, STRING type, RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ firstloginfield :=    ""
        , lastloginfield :=     ""
        , remoteip :=           ""
        ], options,
        [ optional := [ "firstloginfield", "lastloginfield" ]
        ]);

    STRING loginname;

    STRING remoteip := options.remoteip ?? (IsRequest() ? GetClientRemoteIp() : "");

    this->loggedinentity := -1;
    RECORD trylogin := this->serviceLoginSecondFactor(loginproof, type, data, remoteip, CELL
          [ ...options
          ]);

    IF(NOT trylogin.success)
      RETURN trylogin;

    RECORD res := this->CompleteLogin(trylogin, TRUE, "", options);

    res := CELL
        [ ...res
        , ...PickCells(trylogin, [ "logdata", "secondfactordata", "entityid", "login" ])
        ];
    RETURN res;
  }

  RECORD FUNCTION GetCookieOpts()
  {
    RETURN [ domain := this->cookiedomain
           , httponly := NOT this->nohttponlycookies
           , secure := this->securecookie
           , lifetime := -1
           , samesite := this->samesitecookie
           ];
  }

  /** @param trylogin
      @param setlogincookie
  */
  RECORD FUNCTION CompleteLogin(RECORD trylogin, BOOLEAN setlogincookie, STRING sessionid, RECORD options)
  {
    UpdateAuditContext([ user_entityid := trylogin.entityid, user_login := trylogin.login ]);

    IF(CellExists(trylogin, "headers")) { //New wrdauth headers received.
      FOREVERY(RECORD toset FROM trylogin.headers)
        AddHTTPHeader(toset.field, toset.value, toset.always_add);
      RETURN [ success := TRUE, code := "" ];
    }

    IF(CellExists(trylogin, "error")) { //login denied
      RETURN [ success := FALSE, code := "NOACCESS" ];
    }

    RETURN [ success := TRUE, code := "" ];
  }

  PUBLIC MACRO Logout(RECORD options DEFAULTSTO DEFAULT RECORD) {
    this->CheckForSession(); //ensures this->wrdauthjs is set

    //Delete session in database, Cleanup idtoken. TODO use doLogout to improve code sharing?
    IF(RecordExists(this->wrdauthjs)) {
      CallJS("@mod-platform/js/auth/harescript.ts#closeFrontendLogin", this->wrdschema->tag, this->wrdauthjs.idtoken, GetClientRemoteIP(), GetWebHeader("User-Agent"));
      __WHS_CloseWebSession(this->wrdauthjs.sessionid, "wrd:authlogin");
    }

    //Clear the cookies
    RECORD opts := CELL[...this->GetCookieOpts(), lifetime := 0
                       ];
    UpdateWebCookie(this->cookiename, "", opts);
    UpdateWebCookie("__Host-" || this->cookiename, "", opts);
    UpdateWebCookie("__Secure-" || this->cookiename, "", opts);
    UpdateWebCookie(this->cookiename || "_publicauthdata", "", CELL[...opts, httponly := FALSE]);

    //Reset the plugin state
    this->loggedinentity := 0;
    this->loggedinexpires := DEFAULT DATETIME;
    this->sessionid := "";
    this->sessiondata := DEFAULT RECORD;
    this->cookiecache := [ sessionid := "", enclogindata := ""]; //prevent GetWebCookie from seeing the (now stale) cookies
    this->wrdauthjs := DEFAULT RECORD;
    this->idcookie := "";

    UpdateAuditContext([ user_entityid := 0, user_login := "" ]);
  }

  /** Writes a audit event to the logs in a separate transction
      @param type Audit event type
      @param options @includecelldef #WriteWRDAuditEvent.options
  */
  PUBLIC MACRO WriteAuditEvent(STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF (CellExists(options, "ACCOUNT") AND options.account != 0 AND (NOT CELLExists(options, "login") OR options.login = ""))
    {
      options := CELL
          [ ...options
          , login := this->wrdschema->accounttype->GetEntityField(options.account, this->wrdschema->accountlogintag)
          ];
    }

    WriteWRDAuditEvent(this->wrdschema->accounttype, type, options);
  }
>;
