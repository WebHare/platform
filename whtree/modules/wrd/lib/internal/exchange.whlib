<?wh

LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/imexport.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";

LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/internal/whfs-service.whlib";

//FIXME Convert all to a nice im/export api. DO NOT CALL THIS FUNCTION FROM EXTERNAL MODULES NOT SHIPPED WITH WEBHARE - THE API _WILL_ CHANGE

PUBLIC OBJECTTYPE OverwritingProtectedWRDSchemaException EXTEND Exception
<
  MACRO NEW() : Exception("Trying to overwrite a protected schema")
  {

  }
>;

PUBLIC STATIC OBJECTTYPE WRDImExport EXTEND DatabaseImExport <
  OBJECT export_wrdschema;
  OBJECT import_wrdschema;
  OBJECT rtdtype;
  OBJECT instancetype;
  RECORD options;
  OBJECT importmapper;
  OBJECT exportmapper;
  INTEGER newschemaid;
  DATETIME now;

  PUBLIC STRING oldschemarenamedto;
  PUBLIC STRING newschemaname;
  PUBLIC MACRO PTR onoverwritingschema;
  PUBLIC MACRO PTR onimportedreference;
  PUBLIC BOOLEAN ignoremissingreferences;
  PUBLIC BOOLEAN ignorepayments;
  INTEGER ARRAY skipattrids;
  INTEGER ARRAY skiptypeids;

  MACRO NEW(OBJECT wrdschema, RECORD options) : DatabaseImExport("wrd", "v1.3")
  {
    this->now := GetCurrentDatetime();
    this->options := ValidateOptions([ renameto := ""
                                     , onoverwritingschema := DEFAULT MACRO PTR
                                     ], options);
    this->onoverwritingschema := this->options.onoverwritingschema;
    this->rtdtype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/richdocumentfile");
    this->instancetype := OpenWHFSType("http://www.webhare.net/xmlns/wrd/instancefile");

    this->export_wrdschema := wrdschema;
    this->SetupByModule("wrd", ["wrd.schemas"]);
    this->AddImportRowFilter("wrd.schemas", PTR this->SchemasFilter);
    this->AddExportRowFilter("wrd.schemas", PTR this->ExportSchemasFilter);
    this->AddImportRowFilter("wrd.types", PTR this->typesfilter);
    this->AddImportRowFilter("wrd.entity_settings", PTR this->EntitySettingsFilter);

    this->AddImportRowFilter("wrd.attrs", PTR this->attrsfilter);
    this->AddImportRowFilter("wrd.keyvaluestore", PTR this->StoredKeyValueFilter);
    this->AddImportRowFilter("wrd.entity_settings_whfslink", PTR this->ImportWHFSLink);
    this->AddExportRowFilter("wrd.entity_settings_whfslink", PTR this->ExportwHFSLink);
    this->IgnoreImportTable("wrd.events");
    this->IgnoreImportTable("wrd.eventsubtags");
    this->IgnoreImportTable("wrd.translate_types");
    this->IgnoreImportTable("wrd.translate_entities");
    this->IgnoreImportTable("wrd.registrynodes");
    this->IgnoreImportTable("wrd.registrykeys");
    this->IgnoreImportTable("wrd.storedqueries");

    //Do not im/export things we wouldn't add to a sync either, especially as WRD ex/import needs to move to a more 'logical' approach (storing actual entities as typed-json, not raw db records) anyway
    this->RemoveTableCascade("wrd.tokens");
    this->RemoveTableCascade("wrd.auditevents");
    this->RemoveTableCascade("wrd.changesets");

    //the above completely forgets about the table, now mark an explicit ignore because existing wrdschemas might still have data for the tables
    this->IgnoreImportTable("wrd.auditevents");
    this->IgnoreImportTable("wrd.changesets");
    this->IgnoreImportTable("wrd.changes");
    this->IgnoreImportTable("wrd.change_attachments");

    IF(ObjectExists(wrdschema)) //is export
    {
      this->AddExportConstraint("wrd.schemas", "id", "=", wrdschema->id);
      this->exportmapper := NEW WHFSBulkSender(0, "");
    }
    ELSE
    {
      this->importmapper := OpenWHFSRootObject()->MakeBulkReceiver();
    }
  }

  /** Skip types by mask.
      @param mask A mask for <TYPE TAG>
      @return Full tags of actual types skipped */
  PUBLIC STRING ARRAY FUNCTION SkipTypesByMask(STRING mask)
  {
    RECORD ARRAY toskip := SELECT *
                             FROM this->export_wrdschema->ListTypes()
                            WHERE ToUppercase(tag) LIKE ToUppercase(mask);

    this->SkipTypes(SELECT AS INTEGER ARRAY id FROM toskip);
    RETURN SELECT AS STRING ARRAY tag FROM toskip;
  }

  PUBLIC MACRO SkipAttributes(INTEGER ARRAY toskip)
  {
    IF(Length(toskip)=0)
      RETURN;

    FOREVERY(INTEGER id FROM toskip)
      IF(id NOT IN this->skipattrids)
        INSERT id INTO this->skipattrids AT END;
  }

  /** Skip attributes by mask.
      @param mask A mask for <TYPE TAG>[.<PARENT TAGS>...].<ATTRIBUTE TAG>
      @return Full tags of actual attributes skipped */
  PUBLIC STRING ARRAY FUNCTION SkipAttributesByMask(STRING mask)
  {
    INTEGER ARRAY skipids;
    STRING ARRAY skipped;
    FOREVERY(RECORD type FROM this->export_wrdschema->ListTypes())
    {
      RECORD ARRAY toskip := SELECT id, tag
                               FROM this->export_wrdschema->GetTypeById(type.id)->__pvt_GetAllAttrs()
                              WHERE (ToUppercase(type.tag || "." || tag) LIKE ToUppercase(VAR mask))
                                    OR (ToUppercase(type.tag || "." || tag) LIKE ToUppercase(VAR mask || ".*"));

      FOREVERY(RECORD skip FROM toskip)
      {
        INSERT skip.id INTO skipids AT END;
        INSERT ToUppercase(type.tag || "." || skip.tag) INTO skipped AT END;
      }
    }

    this->SkipAttributes(skipids);
    RETURN skipped;
  }

  PUBLIC MACRO SkipTypes(INTEGER ARRAY toskip)
  {
    IF(Length(toskip)=0)
      RETURN;

    FOREVERY(INTEGER skipid FROM toskip)
      IF(skipid NOT IN this->skiptypeids)
      {
        //also remove all attributes referred by the type
        OBJECT typeobj := this->export_wrdschema->GetTypeById(skipid);
        IF(NOT ObjectExists(typeobj))
          CONTINUE; //gone?

        this->SkipAttributes(SELECT AS INTEGER ARRAY id FROM typeobj->__pvt_GetAllAttrs());
        INSERT skipid INTO this->skiptypeids AT END;

        //skip child types too
        this->SkipTypes(typeobj->__childtypeids);

        //skip referring types too
        this->SkipTypes(SELECT AS INTEGER ARRAY id FROM this->export_wrdschema->ListTypes() WHERE linkfrom = skipid OR linkto = skipid);
      }
  }

  RECORD FUNCTION ExportWHFSLink(RECORD inrow)
  {
    IF(inrow.linktype=0)
    {
      INSERT CELL data := EncodeHSON(this->rtdtype->__ExportInstanceData(inrow.fsobject, this->exportmapper, FALSE).data) INTO inrow;
      DELETE CELL fsobject FROM inrow;
      RETURN inrow;
    }
    IF(inrow.linktype=1)
    {
      INSERT CELL data := EncodeHSON(this->instancetype->__ExportInstanceData(inrow.fsobject, this->exportmapper, FALSE).instance) INTO inrow;
      DELETE CELL fsobject FROM inrow;
      RETURN inrow;
    }
    IF(inrow.linktype=2)
    {
      INSERT CELL data := MapExternalWHFSRef(inrow.fsobject) INTO inrow;
      DELETE CELL fsobject FROM inrow;
      RETURN inrow;
    }
    THROW NEW Exception("Unable to export schema - unrecognized linktype #" || inrow.linktype);
  }
  RECORD FUNCTION ImportWHFSLink(RECORD inrow)
  {
    IF(inrow.linktype = 0) //RTD
    {
      RECORD data := DecodeHSON(inrow.data);
      DELETE CELL data FROM inrow;
      INSERT CELL fsobject := StoreRTDInWHFS(this->GetImportedSchemaID(), data, this->importmapper) INTO inrow;
      RETURN inrow;
    }
    IF(inrow.linktype = 1) //Instance
    {
      RECORD data := DecodeHSON(inrow.data);
      DELETE CELL data FROM inrow;
      INSERT CELL fsobject := StoreInstanceInWHFS(this->GetImportedSchemaID(), data, this->importmapper) INTO inrow;
      RETURN inrow;
    }
    IF(inrow.linktype = 2) //FSObject
    {
      IF(inrow.data = "") //nothing set in this reference
        RETURN DEFAULT RECORD;

      OBJECT dest := OpenWHFSObjectByPath(inrow.data);
      IF(this->onimportedreference != DEFAULT MACRO PTR)
        this->onimportedreference(inrow.data, ObjectExists(dest) ? dest->id : 0);

      IF(NOT ObjectExists(dest) OR dest->id = 0)
      {
        IF (this->ignoremissingreferences)
          RETURN DEFAULT RECORD;
        THROW NEW Exception("Unable to import schema - unable to restore reference to '" || inrow.data || "'");
      }

      DELETE CELL data FROM inrow;
      INSERT CELL fsobject := dest->id INTO inrow;
      RETURN inrow;
    }
    THROW NEW Exception("Unable to import schema - unrecognized linktype #" || inrow.linktype);
  }

  RECORD FUNCTION SchemasFilter(RECORD inrec)
  {
    IF(this->newschemaname != "")
      THROW NEW Exception("The WRD import contains multiple schema records");

    inrec := CELL[...inrec
                 , DELETE authkey
                 , DELETE protected
                 , DELETE worldinfo
                 , DELETE languages
                 , DELETE schemadata_xml
                 , DELETE required_fields
                 , DELETE unique_fields
                 , DELETE creationsource
                 , creationdate := GetCurrentDateTime()
                 , id := this->newschemaid
                 ];

    STRING usename := this->options.renameto ?? inrec.name;

    // See if the original schema name already exists. If so, rename the old schema to .bak (x)
    RECORD currschema :=
         SELECT id, name, protected
           FROM wrd.schemas
          WHERE ToUppercase(name) = ToUppercase(usename);

    IF (RecordExists(currschema))
    {
      IF(this->onoverwritingschema != DEFAULT MACRO PTR)
        this->onoverwritingschema(currschema.id);

      IF (currschema.protected)
        THROW NEW OverwritingProtectedWRDSchemaException;

      //Make sure the schema name is unique
      FOR(INTEGER trycount:=0;TRUE;trycount:=trycount+1)
      {
        STRING tryname := currschema.name || ".bak" || (trycount=0?"":" ("||trycount||")");
        IF (NOT RecordExists( SELECT FROM wrd.schemas WHERE ToUppercase(name) = ToUppercase(tryname) ))
        {
          UPDATE wrd.schemas
             SET name := tryname
           WHERE id = currschema.id;

          this->oldschemarenamedto := tryname;
          BREAK;
        }
      }

      // Renamed the schema, clear caches for it
      GetWRDCommitHandler()->SchemaNameChanged(currschema.id);
    }
    GetWRDCommitHandler()->SchemaCreated();

    inrec.name := usename;
    this->newschemaname := usename;

    RETURN inrec;
  }

  RECORD FUNCTION ExportSchemasFilter(RECORD inrec)
  {
    inrec.creationdate := GetCurrentDatetime();
    RETURN inrec;
  }

  RECORD FUNCTION TypesFilter(RECORD inrec)
  {
    DELETE CELL wrd_schema, list_attributes, required_fields, unique_fields FROM inrec;
    INSERT CELL wrd_schema := this->newschemaid INTO inrec;
    RETURN inrec;
  }
  RECORD FUNCTION ChangeSetFilter(RECORD inrec)
  {
    DELETE CELL wrdschema, entity FROM inrec; //remote entityid is generally meaningless, so drop it
    INSERT CELL wrdschema := this->newschemaid INTO inrec;
    RETURN inrec;
  }
  RECORD FUNCTION AuditEventsFilter(RECORD inrec)
  {
    inrec := CELL[...inrec, wrdschema := this->newschemaid ];
    RETURN inrec;
  }
  RECORD FUNCTION EntitySettingsFilter(RECORD inrec)
  {
    IF(CellExists(inrec,'creationdate'))
    {
      IF(inrec.limitdate < this->now OR inrec.creationdate >= this->now)
        RETURN DEFAULT RECORD;
      inrec := CELL[...inrec, DELETE creationdate, DELETE limitdate ];
    }
    RETURN inrec;
  }
  RECORD FUNCTION StoredKeyValueFilter(RECORD inrec)
  {
    DELETE CELL wrd_schema FROM inrec;
    INSERT CELL wrd_schema := this->newschemaid INTO inrec;
    RETURN inrec;
  }
  RECORD FUNCTION AttrsFilter(RECORD inrec)
  {
    DELETE CELL creationdate, limitdate, confidential, keephistory, ordering, maxlength, maxwidth, required_fields, unique_fields FROM inrec;
    RETURN inrec;
  }

  PUBLIC INTEGER FUNCTION GetImportedSchemaID()
  {
    RETURN this->newschemaid;
  }

  RECORD FUNCTION FilterWHFSLinks(INTEGER64 ARRAY killthis, RECORD inrec)
  {
    IF(inrec.id IN killthis)
      RETURN DEFAULT RECORD;
    RETURN inrec;
  }

  UPDATE PUBLIC BLOB FUNCTION RunExport()
  {
    IF(Length(this->skiptypeids)>0)
    {
      INTEGER ARRAY typeids := SELECT AS INTEGER ARRAY id FROM wrd.types WHERE wrd_schema = this->export_wrdschema->id AND id NOT IN this->skiptypeids;
      this->AddExportConstraint("wrd.entities", "type", "IN", typeids);
    }
    IF(Length(this->skipattrids)>0)
    {
      //Make sure we don't export noninteresting settings
      INTEGER ARRAY keepattrs := SELECT AS INTEGER ARRAY attrs.id
                                   FROM wrd.attrs, wrd.types
                                  WHERE types.wrd_schema = this->export_wrdschema->id
                                        AND attrs.type = types.id
                                        AND attrs.id NOT IN this->skipattrids;

      this->AddExportConstraint("wrd.entity_settings", "attribute", "IN", keepattrs);

      //Are any of these attributes of types that may contain WHFSLINKS ?
      INTEGER ARRAY whfslinkattrs := SELECT AS INTEGER ARRAY id
                                       FROM wrd.attrs
                                      WHERE attrs.id IN this->skipattrids
                                            AND attrs.attributetype IN [17,19,20];

      IF(Length(whfslinkattrs) > 0 )
      {
        INTEGER64 ARRAY skipwhfslinks := SELECT AS INTEGER64 ARRAY entity_settings_whfslink.id
                                           FROM wrd.entity_settings_whfslink, wrd.entity_settings
                                          WHERE entity_settings.attribute IN whfslinkattrs
                                                AND entity_settings_whfslink.id = entity_settings.id;

        IF(Length(skipwhfslinks) > 0)
          this->AddExportRowFilter("wrd.entity_settings_whfslink", PTR this->FilterWHFSLinks(skipwhfslinks, #1));
      }
    }
    RETURN DatabaseImExport::RunExport();
  }

  /** @short Export archive to WHFS
      @param numdaystokeep Number of days to keep this archive. If 0, infinite (but are you sure you want to have potential personal data linger around infinitely?) */
  PUBLIC MACRO ExportToWHFS(INTEGER destfolder, INTEGER numdaystokeep)
  {
    IF(numdaystokeep < 0)
      THROW NEW Exception(`Invalid number of days to keep: ${numdaystokeep}`);

    BLOB result := this->RunExport();
    STRING filename := Substitute(this->export_wrdschema->tag,":","--") || "-" || FormatDatetime("%Y%m%d-%H%M%S", GetCurrentDatetime()) || ".wrdschema";
    OBJECT backupfile := OpenWHFSObject(destfolder)->CreateFile([ name := filename
                                                                , data := result
                                                                , typens := "http://www.webhare.net/xmlns/wrd/schemaarchive"
                                                                , publish := FALSE
                                                                ]);
    IF(numdaystokeep > 0)
      backupfile->SetInstanceData("http://www.webhare.net/xmlns/publisher/lifecycle", [ deletion := AddDaystoDate(numdaystokeep, GetCurrentDatetime()) ]);
  }

  UPDATE PUBLIC MACRO RunImport(BLOB data) {
    this->newschemaid := MakeAutonumber(wrd.schemas,"id");
    IF(this->ignorepayments) {
      this->RemoveTableCascade("wrd.pendingpayments");
      this->IgnoreImportTable("wrd.pendingpayments");
    }
    DatabaseImExport::RunImport(data);
    RescanWRDConsilioLinks(this->newschemaid);
  }

  UPDATE PUBLIC MACRO RunCopy()
  {
    this->newschemaid := MakeAutonumber(wrd.schemas,"id");
    this->importmapper := OpenWHFSRootObject()->MakeBulkReceiver();
    DatabaseImExport::RunCopy();
    RescanWRDConsilioLinks(this->newschemaid);
  }
>;
