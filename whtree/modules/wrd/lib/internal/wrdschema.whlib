<?wh
LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/comparisons.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/tasks.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::wrd/lib/internal/cache.whlib";
LOADLIB "mod::wrd/lib/internal/metadata/moduledefs.whlib";
LOADLIB "mod::wrd/lib/internal/metadata/schemaparser.whlib";
LOADLIB "mod::wrd/lib/internal/metadata/updateschema.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/queries.whlib" ;
LOADLIB "mod::wrd/lib/internal/wrdtype.whlib";
LOADLIB "mod::wrd/lib/internal/exchange.whlib";
LOADLIB "mod::wrd/lib/internal/wrdsettings.whlib";

INTEGER FUNCTION GetAccountAttrId(OBJECT intype, STRING tag)
{
  IF(tag="")
    RETURN 0;
  IF(NOT ObjectExists(intype))
    THROW NEW Exception("Cannot specify account field '" ||tag || "' if no accounttype is set");

  RECORD field := intype->GetAttribute(tag);
  IF(NOT RecordExists(field))
    THROW NEW Exception("No such field '" ||tag || "' in type '" || intype->tag || "'");

  RETURN field.id;
}

RECORD FUNCTION GetCacheableTypeRecById(INTEGER schemaid, INTEGER type_id)
{
  RETURN
      [ ttl := ttl_wrdschemacache
      , eventmasks := [ "wrd:schema." || schemaid || ".change" ]
      , value :=    SELECT *
                      FROM wrd.types
                     WHERE id = type_id
                       AND wrd_schema = schemaid
      ];
}

STRING FUNCTION FixupKeyName(STRING keyname)
{
  IF(keyname NOT LIKE "?*:?*" OR keyname LIKE "* *" OR keyname LIKE "*."
     OR keyname LIKE ".*" OR keyname LIKE "*..*" OR keyname LIKE "*:*:*"
     OR keyname LIKE "*:.*" OR keyname LIKE "*.*:*")
    THROW NEW Exception(`Illegal key name '${keyname}'`);
  RETURN ToUppercase(keyname);
}

STATIC OBJECTTYPE BulkCreator
<
  OBJECT wrdschema;
  RECORD result;
  RECORD existing;
  RECORD idmap;

  MACRO NEW(OBJECT wrdschema, RECORD existing)
  {
    this->wrdschema := wrdschema;
    this->existing := existing;
  }

  INTEGER FUNCTION MapValue(OBJECT type, STRING attr, STRING val)
  {
    IF(val LIKE ":*")
    {
      STRING entityname := Substring(val,1);
      IF(CellExists(this->result, entityname)) //already created!
        RETURN GetCell(this->result, entityname)->id;
      IF(CellExists(this->idmap, entityname)) //it's in the plan!
        RETURN GetCell(this->idmap, entityname);

      THROW NEW Exception(`No entity named '${entityname}' inserted`);
    }
    RETURN type->GetDomVal(attr,val);
  }

  RECORD FUNCTION ParseCreateAction(RECORD act)
  {
    act := ValidateOptions([ create := ""
                           , entities := RECORD[]
                           , defaults := CELL[]
                           ], act, [ title := "creations" ]);

    OBJECT type := this->wrdschema->GetType(act.create);
    IF(NOT ObjectExists(type))
      THROW NEW Exception(`No such type '${act.create}'`);

    RECORD ARRAY items;
    FOREVERY(RECORD item FROM act.entities)
    {
      item := CELL[ ...act.defaults, ...item ];

      STRING outputname;
      IF(CellExists(item,'_name'))
      {
        outputname := item._name;
        DELETE CELL _name FROM item;
      }

      INSERT CELL[ outputname, data := item ] INTO items AT END;
    }
    RETURN CELL[ type, items ];
  }

  RECORD FUNCTION ParseModifyAction(RECORD act)
  {
    act := ValidateOptions([ modify := ""
                           , entities := RECORD[]
                           , defaults := CELL[]
                           ], act, [ title := "modifications" ]);

    OBJECT type := this->wrdschema->GetType(act.modify);
    IF(NOT ObjectExists(type))
      THROW NEW Exception(`No such type '${act.modify}'`);

    RECORD ARRAY items;
    FOREVERY(RECORD item FROM act.entities)
    {
      item := CELL[ ...act.defaults, ...item ];

      STRING outputname;
      IF (NOT CellExists(item,'_name'))
        THROW NEW Exception(`Modify item found without '_name' cell`);

      outputname := item._name;
      DELETE CELL _name FROM item;

      INSERT CELL[ outputname, data := item] INTO items AT END;
    }
    RETURN CELL[ type, items ];
  }


  PUBLIC RECORD FUNCTION Run(RECORD ARRAY actions)
  {
    BOOLEAN save_integritycheck;
    TRY
    {
      save_integritycheck := this->wrdschema->__disableintegritychecks;
      this->wrdschema->__disableintegritychecks := TRUE;

      this->result := this->existing;

      //Generate IDs first
      FOREVERY(RECORD act FROM actions)
        IF(CellExists(act,'create'))
        {
          RECORD parsed := this->ParseCreateAction(act);
          FOREVERY(RECORD item FROM parsed.items)
          {
            IF(item.outputname != "")
              this->idmap := CellInsert(this->idmap, item.outputname, parsed.type->GetNewEntityId());
          }
        }


      FOREVERY(RECORD act FROM actions)
      {
        IF(CellExists(act,'create'))
        {
          RECORD parsed := this->ParseCreateAction(act);
          OBJECT type := parsed.type;

          FUNCTION PTR onmapdomvalue := PTR this->MapValue(type, #1, #2);

          FOREVERY(RECORD item FROM parsed.items)
          {
            STRING outputname := item.outputname;
            TRY
            {
              IF(outputname != "")
                INSERT CELL wrd_id := GetCell(this->idmap, outputname) INTO item.data;

              OBJECT entity := type->CreateEntity(item.data, [ onmapdomvalue := onmapdomvalue ]);
              IF(outputname != "")
                this->result := CellInsert(this->result, outputname, entity);
            }
            CATCH(OBJECT e)
            {
              IF(outputname != "")
                e->what := e->what || ` (creating entity '${outputname})'`;
              ELSE
                e->what := e->what || ` (creating entity #${#item} of action block #${#act} (CREATE ${ToUppercase(act.create)}))`;
              THROW;
            }
          }
        }
      }

      FOREVERY(RECORD act FROM actions)
      {
        IF(CellExists(act,'modify'))
        {
          RECORD parsed := this->ParseModifyAction(act);
          OBJECT type := parsed.type;

          FUNCTION PTR onmapdomvalue := PTR this->MapValue(type, #1, #2);

          FOREVERY(RECORD item FROM parsed.items)
          {
            STRING outputname := item.outputname;
            IF (NOT CellExists(this->result, item.outputname))
              THROW NEW Exception(`No such item '${item.outputname}' found in type '${act.modify}'`);

            TRY
            {
              GetCell(this->result, item.outputname)->UpdateEntity(item.data, [ onmapdomvalue := onmapdomvalue ]);
            }
            CATCH(OBJECT e)
            {
              e->what := e->what || ` (modifying ${ToUppercase(act.modify)} '${outputname}')'`;
              THROW;
            }
          }
        }
      }

      RETURN this->result;
    }
    FINALLY
    {
      this->wrdschema->__disableintegritychecks := save_integritycheck;
    }
  }
>;

/** @topic wrd/api
    @public
    @loadlib mod::wrd/lib/api.whlib
    @short Read a WRD schema setting
    @param wrdschemaid Id of the WRD schema
    @param keyname Name of the setting to retrieve
    @param options Options
    @cell options.fallback Fallback value
    @return Returns key value, throws if the key does not exist and no fallback was supplied
*/
PUBLIC VARIANT FUNCTION GetWRDSchemaSetting(INTEGER wrdschemaid, STRING keyname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ fallback := "" ], options, [ optional := ["fallback"], notypecheck := ["fallback" ]]);
  keyname := FixupKeyName(keyname);

  RECORD storevalue :=
      SELECT *
        FROM wrd.keyvaluestore
       WHERE wrd_schema = wrdschemaid
             AND name = keyname;

  IF (NOT RecordExists(storevalue))
    IF(CellExists(options,'fallback'))
      RETURN options.fallback;
    ELSE
      THROW NEW Exception(`Cannot find key ${keyname} and no fallback value set`);

  RETURN ReadAnyFromDatabase(storevalue.data, storevalue.blobdata);
}

/** @topic wrd/api
    @public
    @loadlib mod::wrd/lib/api.whlib
    @short Sets a WRD schema setting
    @param wrdschemaid Id of the WRD schema
    @param keyname Name of the setting to retrieve
    @param value Value to store
*/
PUBLIC MACRO SetWRDSchemaSetting(INTEGER wrdschemaid, STRING keyname, VARIANT value)
{
  keyname := FixupKeyName(keyname);

  RECORD parts := PrepareAnyForDatabase(value);
  INTEGER storeid :=
      SELECT AS INTEGER id
        FROM wrd.keyvaluestore
       WHERE wrd_schema = wrdschemaid
             AND name = keyname;

  IF (storeid > 0)
  {
    UPDATE wrd.keyvaluestore
       SET data := parts.stringpart
         , blobdata := parts.blobpart
     WHERE id = storeid;
  }
  ELSE
  {
    INSERT INTO wrd.keyvaluestore(wrd_schema, name, data, blobdata)
         VALUES(wrdschemaid, keyname, parts.stringpart, parts.blobpart);
  }

  // ADDME: specialized metadata event?
  GetWRDCommitHandler()->SettingsChanged(wrdschemaid);
}

/** @topic wrd/api
    @public
    @loadlib mod::wrd/lib/api.whlib
    @short Removes a WRD schema setting
    @param wrdschemaid Id of the WRD schema
    @param keyname Name of the setting to remove
*/
PUBLIC MACRO RemoveWRDSchemaSetting(INTEGER wrdschemaid, STRING keyname)
{
  keyname := FixupKeyName(keyname);
  DELETE FROM wrd.keyvaluestore
   WHERE wrd_schema = wrdschemaid
         AND name = keyname;

  GetWRDCommitHandler()->SettingsChanged(wrdschemaid);
}

PUBLIC STATIC OBJECTTYPE WRDSchemaBase
<
  RECORD schemarec;
  RECORD ARRAY typecache;
  OBJECT pvt_types;
  ///currently registered hat properties
  STRING ARRAY currenthats;

  //true if we're in the new api. will disppear if migration is ever complete, and gives an easily greppable identifier
  PUBLIC BOOLEAN __iswrdapi2017;

  /// dynamic hat property resolver, for types
  PUBLIC PROPERTY ^(GetTypeByHatProperty, -);

  /// @type(integer) Id of this schema
  PUBLIC PROPERTY id(this->schemarec.id, -);

  /// @type(string) Tag of this schema
  PUBLIC PROPERTY tag(this->schemarec.name, -);

  /// @type(string) Title of this schema
  PUBLIC PROPERTY title(this->schemarec.title, -);

  /// @type(string) Description of this schema
  PUBLIC PROPERTY description(this->schemarec.description, -);

  /// @type(datetime) Creation date, if known
  PUBLIC PROPERTY creationdate(this->schemarec.creationdate, -);

  /// @type(boolean) Whether this schema is protected against deleting and overwriting
  PUBLIC PROPERTY protected(this->schemarec.protected, -);

  /// @type(boolean) Whether this schema is a source for usermgmt
  PUBLIC PROPERTY usermgmt(this->schemarec.usermgmt, -);

  /// Set to true to disable integrity checks during insertions that require additional database queries (ie, performance before correctness). This option may be removed in the future
  PUBLIC BOOLEAN __disableintegritychecks;

  /// @type(object #WRDType2017) Get the type used for accounts
  PUBLIC PROPERTY accounttype(GetAccountType, -);
  /// @type(string) Get the tag of the login attribute
  PUBLIC PROPERTY accountlogintag(GetAccountLoginTag, -);
  /// @type(string) Get the tag of the email attribute
  PUBLIC PROPERTY accountemailtag(GetAccountemailTag, -);
  /// @type(string) Get the tag of the password attribute
  PUBLIC PROPERTY accountpasswordtag(GetAccountpasswordTag, -);
  /// @type(boolean) Whether the password field is of authenticationsettings type
  PUBLIC PROPERTY accountpasswordisauthsettings(GetAccountPasswordIsAuthSettings, -);

  /** @private Should not be constructed directly
      @param schemarec Contents of database schema record
  */
  PUBLIC MACRO NEW(RECORD schemarec)
  {
    this->schemarec := schemarec;
  }



  //////////////////////////////////////////
  //
  // Schema metadata
  //
  PUBLIC RECORD FUNCTION __ExplainMyselfToJavascript()
  {
    RETURN CELL[ this->tag
               , types := (SELECT tag := ToLowercase(tag)
                             FROM this->ListTypes())
              , this->id
               ];
  }

  PUBLIC MACRO __SignalMetadataChanged()
  {
    GetWRDCommitHandler()->MetadataChanged(this->schemarec.id);
    this->pvt_types := DEFAULT OBJECT;
  }

  PUBLIC MACRO __RefreshFromDB()
  {
    this->schemarec := SELECT * FROM wrd.schemas WHERE id = this->schemarec.id;

    IF(Length(this->typecache) > 0)
    {
      INTEGER ARRAY existingtypeids := SELECT AS INTEGER ARRAY id FROM wrd.types WHERE types.wrd_schema = this->schemarec.id;
      DELETE FROM this->typecache WHERE id NOT IN existingtypeids;
    }

    //remove obsolete saved hatted properties
    FOREVERY(STRING hat FROM this->currenthats)
      IF(NOT RecordExists(SELECT FROM this->typecache WHERE ToUppercase(tag) = ToUppercase(hat))) //type deleted
      {
        MemberDelete(this, "^" || hat);
        DELETE FROM this->currenthats AT SearchElement(this->currenthats, hat);
      }
  }

  PUBLIC STRING FUNCTION __GetCurrentLanguageCode()
  {
    THROW NEW Exception("__GetCurrentLanguageCode() not implemented");
  }

  PUBLIC STRING ARRAY FUNCTION GetEventMasks()
  {
    RETURN [ "wrd:schema." || this->schemarec.id || ".change" ];
  }

  PUBLIC STRING ARRAY FUNCTION GetSettingsEventMasks()
  {
    RETURN [ "wrd:schema." || this->schemarec.id || ".settingschange" ];
  }

  /** @short Delete this schema */
  PUBLIC MACRO DeleteSelf()
  {
    IF(this->protected)
      THROW NEW Exception("The schema is currently protected and cannot be deleted");

    UPDATE wrd.schemas SET name := "$wrd$deleted$" || id
                       WHERE id = this->schemarec.id;

    ScheduleManagedTask("wrd:deletetask", [ id := this->schemarec.id ]);
    ScheduleTimedTask("wrd:scanforissues"); //clear out any associated errors
    this->__SignalMetadataChanged();
    GetWRDCommitHandler()->SchemaNameChanged(this->schemarec.id);
    RETURN;
  }

  PUBLIC MACRO UpdateMetadata(RECORD newsettings)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(newsettings))
      IF (cellrec.name NOT IN
            [ "LANGUAGES", "DESCRIPTION", "NAME", "TAG", "PROTECTED", "USERMGMT"
            , "ACCOUNTTYPE", "ACCOUNTLOGIN", "ACCOUNTPASSWORD", "ACCOUNTEMAIL", "ACCOUNTLOGINTAG"
            , "ACCOUNTPASSWORDTAG", "ACCOUNTEMAILTAG", "TITLE", "CREATIONDATE"
            ])
      {
        THROW NEW Exception("Updating '" || cellrec.name || "' using UpdateMetadata not supported");
      }

    RECORD toset;
    IF(CellExists(newsettings,'tag'))
      INSERT CELL name := newsettings.tag INTO toset;
    ELSE IF(CellExists(newsettings,'name'))
      INSERT CELL name := newsettings.name INTO toset;
    IF(CellExists(newsettings,'title'))
      INSERT CELL title := newsettings.title INTO toset;
    IF(CellExists(newsettings,'languages'))
      THROW NEW Exception("The cell 'languages' is no longer supported");
    IF(CellExists(newsettings,'description'))
      INSERT CELL description := newsettings.description INTO toset;
    IF(CellExists(newsettings,'protected'))
      INSERT CELL protected := newsettings.protected INTO toset;

    IF(CellExists(newsettings,'accounttype'))
      INSERT CELL accounttype := newsettings.accounttype INTO toset;

    IF(CellExists(newsettings,'accountlogintag') OR CellExists(newsettings,'accountpasswordtag') OR CellExists(newsettings,'accountemailtag'))
    {
      OBJECT accounttype := CellExists(toset,"accounttype") ? this->GetTypeById(toset.accounttype) : this->accounttype;
      IF(CellExists(newsettings,'accountlogintag'))
        INSERT CELL accountlogin := GetAccountAttrId(accounttype, newsettings.accountlogintag) INTO toset;
      IF(CellExists(newsettings,'accountpasswordtag'))
        INSERT CELL accountpassword := GetAccountAttrId(accounttype, newsettings.accountpasswordtag) INTO toset;
      IF(CellExists(newsettings,'accountemailtag'))
        INSERT CELL accountemail := GetAccountAttrId(accounttype, newsettings.accountemailtag) INTO toset;
    }

    IF(CellExists(newsettings,'accountlogin'))
      INSERT CELL accountlogin := newsettings.accountlogin INTO toset;

    IF(CellExists(newsettings,'accountpassword'))
      INSERT CELL accountpassword := newsettings.accountpassword INTO toset;
    IF(CellExists(newsettings,'accountemail'))
      INSERT CELL accountemail := newsettings.accountemail INTO toset;
    IF(CellExists(newsettings,'usermgmt') AND newsettings.usermgmt != this->usermgmt)
    {
      //ADDME Schedule fixusers?
      INSERT CELL usermgmt := newsettings.usermgmt INTO toset;
    }
    IF(CellExists(newsettings,'creationdate'))
      INSERT CELL creationdate := newsettings.creationdate INTO toset;

    UPDATE wrd.schemas SET RECORD toset WHERE id = this->id;
    this->__RefreshFromDB();
    this->__SignalMetadataChanged();

    IF (CellExists(toset, "name"))
    {
      GetWRDCommitHandler()->SchemaNameChanged(this->id);
      ScheduleTimedTask("wrd:scanforissues", [ allowmissing := TRUE ]); //clear out any associated errors (eg if you rename .bak back to normal name)
    }

    //ADDME schedule a fixusers
  }

  //////////////////////////////////////////
  //
  // Opening/listing types
  //

  /** Dynamic property resolving for wrdschema->^typetag
      @param propname Property name (`^` + WRD type name)
      @return(object #WRDType2017) WRD type object
  */
  OBJECT FUNCTION GetTypeByHatProperty(STRING propname) __ATTRIBUTES__(SKIPTRACE)
  {
    STRING tag := SubString(propname, 1);
    OBJECT wrdtype := this->__GetTypeByTag(tag, TRUE); //'->^typetag' is ALWAYS a 2017 definition
    IF (NOT ObjectExists(wrdtype))
    {
      STRING bestmatch := GetBestMatch(tag, SELECT AS STRING ARRAY COLUMN tag FROM this->ListTypes());
      THROW NEW Exception(`No such type ${EncodeJSON(tag)} exists in schema ${this->tag}${bestmatch=""?"":`, did you mean ${EncodeJSON(bestmatch)}?`}`);
    }

    // Save for quick re-access
    INSERT ToUppercase(wrdtype->tag) INTO this->currenthats AT END;
    MemberInsert(this, propname, FALSE, wrdtype);
    RETURN wrdtype;
  }

  /** Load a type, but only if it's in the cache
      @param typeids List of types to get
      @return Type objects that are in the type cache
  */
  PUBLIC OBJECT ARRAY FUNCTION __GetTypeIfcached(INTEGER ARRAY typeids)
  {
    RETURN SELECT AS OBJECT ARRAY obj FROM this->typecache WHERE id IN typeids;
  }

  /** Returns list of all types
      @return Record array with description of all types
      @cell return.id Id of this type
      @cell return.tag Tag of this type
      @cell return.metatype Metatype of this type (1=object, 2=link, 3=attachment, 4=domain)
      @cell return.title Translated title of this type
      @cell return.original_title Original (untranslated) title of this type
      @cell return.description Description of this type
      @cell return.is_entity Whether this type is an entity
      @cell return.is_link Whether this type is a link
      @cell return.is_attachment Whether this type is a attachment
      @cell return.is_domain Whether this type is a domain
      @cell return.requiretype_left Tag of type that must be in wrd_leftentity for this type
      @cell return.requiretype_right Tag of type that must be in wrd_rightentity for this type
      @cell return.parenttype ID of the parent type
      @cell return.deleteclosedafter Nr of days after which to permanently delete closed entities
      @cell return.keephistorydays Nr of days to keep history
      @cell return.haspersonaldata If this type may contain sensitive personal data
  */
  PUBLIC RECORD ARRAY FUNCTION ListTypes()
  {
    RETURN SELECT id
                , tag := ToUppercase(tag)
                , metatype
                , title
                , description
                , isobject := metatype = wrd_metatype_object
                , islink := metatype = wrd_metatype_link
                , isattachment := metatype = wrd_metatype_attachment
                , isdomain := metatype = wrd_metatype_domain
                , linkfrom := requiretype_left
                , linkto := requiretype_right
                , parenttype
                , deleteclosedafter
                , keephistorydays
                , haspersonaldata
             FROM wrd.types
            WHERE wrd_schema = this->schemarec.id;
  }

  PUBLIC OBJECT FUNCTION GetTypeById(INTEGER type_id)
  {
    BOOLEAN useapi2017 := this->__iswrdapi2017;
    OBJECT savedtype := SELECT AS OBJECT obj FROM this->typecache WHERE id=type_id AND api2017 = useapi2017;
    IF(ObjectExists(savedtype))
      RETURN savedtype;

    FUNCTION PTR cachecall := PTR GetCacheableTypeRecById(this->id, type_id);
    RECORD typerec := IsWRDMetadataCacheDisabled() ? GetAdhocCached([ type := "typerecbyid", wrdschema := this->id, id := type_id ], cachecall) : cachecall().value;
    IF(NOT RecordExists(typerec))
      RETURN DEFAULT OBJECT;

    OBJECT thetype := this->__CreateTypeObject(typerec);
    INSERT INTO this->typecache(id, obj, tag, api2017) VALUES(type_id, thetype, typerec.tag, useapi2017) AT END;
    RETURN thetype;
  }

  /** Get a type
      @param findtag Tag of the type
      @param forceapi2017 If TRUE, always get a [WRDType2017](%WRDType2017) type object
      @return(object %WRDType2017) WRD type object
  */
  PUBLIC OBJECT FUNCTION __GetTypeByTag(STRING findtag, BOOLEAN forceapi2017 DEFAULTSTO FALSE)
  {
    BOOLEAN useapi2017 := forceapi2017 OR this->__iswrdapi2017;
    OBJECT savedtype := SELECT AS OBJECT obj FROM this->typecache WHERE ToUppercase(tag)=ToUppercase(findtag) AND api2017 = useapi2017;
    IF(ObjectExists(savedtype))
      RETURN savedtype;

    RECORD typerec;
    IF(IsWRDMetadataCacheDisabled())
      typerec := this->GetCacheableTypeRecByName(findtag).value;
    ELSE
      typerec := GetAdhocCached([ type := "typerecbyname", wrdschema := this->id, tag := findtag ], PTR this->GetCacheableTypeRecByName(findtag));

    IF(NOT RecordExists(typerec))
      RETURN DEFAULT OBJECT;

    OBJECT thetype := forceapi2017 ? NEW WRDType2017(this,typerec) : this->__CreateTypeObject(typerec);
    INSERT INTO this->typecache(id, obj, tag, api2017) VALUES(typerec.id, thetype, typerec.tag, useapi2017) AT END;
    RETURN thetype;
  }



  //////////////////////////////////////////
  //
  // Managing types
  //
  OBJECT FUNCTION __CreateTypeObject(RECORD typerec)
  {
    THROW NEW Exception("__CreateTypeObject not implemented");
  }
  RECORD FUNCTION GetCacheableTypeRecByName(STRING findtag)
  {
    RETURN
        [ ttl :=        ttl_wrdschemacache
        , eventmasks := [ "wrd:schema." || this->schemarec.id || ".change" ]
        , value :=      SELECT *
                          FROM wrd.types
                         WHERE wrd_schema = this->schemarec.id
                           AND ToUppercase(tag) = ToUppercase(findtag)
        ];
  }

  // This function handles the 4 Create<type>Type functions below. Public for JS
  PUBLIC OBJECT FUNCTION __DoCreateType(RECORD typerecord)
  {
    typerecord := ValidateOptions([ title := "", description := "", tag := ""
                                    , requiretype_left := 0, requiretype_right := 0, metatype := wrd_metatype_object
                                    , parenttype := 0, abstract := FALSE, deleteclosedafter := 0, keephistorydays := 0
                                    , haspersonaldata := FALSE
                                    ], typerecord);
    typerecord.tag := ToUppercase(typerecord.tag);

    IF (typerecord.tag = "")
      THROW NEW Exception("The tag was not filled in");

    // Check whether the title & tag are unique
    RECORD ARRAY alltypes := SELECT COLUMN tag
                               FROM this->ListTypes();

    IF (RecordExists(SELECT FROM alltypes WHERE ToUpperCase(tag) = ToUpperCase(typerecord.tag)))
      THROW NEW Exception("The tag of this type is not unique for its WRD schema");

    INTEGER parent := typerecord.parenttype;
    //FIXME we're not verifying parent has same metatype as child?

    INTEGER newtypeid := MakeAutonumber(wrd.types,"id");
    INSERT INTO wrd.types (id, wrd_schema, title, description, tag, metatype
                         , requiretype_left, requiretype_right, abstract, parenttype, deleteclosedafter, keephistorydays
                         , haspersonaldata)
                   VALUES (newtypeid, this->id, typerecord.title, typerecord.description, typerecord.tag, typerecord.metatype
                         , typerecord.requiretype_left, typerecord.requiretype_right, typerecord.abstract, parent
                         , typerecord.deleteclosedafter, typerecord.keephistorydays, typerecord.haspersonaldata);

    this->__SignalMetadataChanged();

    OBJECT thetype := this->GetTypeById(newtypeid);
    IF(NOT ObjectExists(thetype))
      THROW NEW Exception("Internal error, creation of type #" || newtypeid || " (" || typerecord.tag || ") failed");

    IF(typerecord.metatype = wrd_metatype_domain AND parent = 0)
      thetype->__DoCreateAttribute("FREE", "Title", "", "WRD_TITLE", 0);

    IF(parent != 0 AND parent != wrd_metatype_domain)
      this->GetTypeById(parent)->__ReloadTypeAndChildren();

    RETURN thetype;
  }

  /** Create a complete copy of a schema
      @param targetname Target schema name
  */
  PUBLIC MACRO CopySchemaTo(STRING targetname)
  {
    IF(RecordExists(SELECT FROM wrd.schemas WHERE ToUpperCase(schemas.name) = ToUppercase(targetname)))
      THROW NEW Exception(`Schema '${targetname}' already exists!`);

    OBJECT importer := NEW WRDImExport(this, [ renameto := targetname ]);
    importer->RunCopy();
  }

  /** Create a new type
      @param tag Tag for the new type
      @cell options.title Title for the new type
      @cell options.description Description for the new type
      @cell options.linkfrom Type this type links from
      @cell options.linkto Type the new type links to (if set, 'linkfrom' is required)
      @return New type
  */
  PUBLIC OBJECT FUNCTION CreateType (STRING tag, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ title := "", description := "", linkfrom := 0, linkto := 0, deleteclosedafter := 0, keephistorydays := 0, haspersonaldata := FALSE, abstract := FALSE ], options);
    IF(options.linkfrom = 0 AND options.linkto != 0)
      THROW NEW Exception("Cannot set 'linkto' without setting 'linkfrom'");
    IF (options.deleteclosedafter < 0)
      THROW NEW Exception(`Cannot delete closed entities after a negative time period`);
    IF (options.keephistorydays < 0)
      THROW NEW Exception(`Cannot keep changes for a negative time period`);

    options := CELL[ ...options
                   , tag
                   , metatype := options.linkto != 0 ? 2 : options.linkfrom != 0 ? 3 : 1
                   , requiretype_left := options.linkfrom
                   , requiretype_right := options.linkto
                   , DELETE linkfrom
                   , DELETE linkto
                  ];

    RETURN this->__DoCreateType(options);
  }

  /** Create a new domain type
      @param tag Tag for the new type
      @cell options.title Title for the new type
      @cell options.description Description for the new type
      @return New type
  */
  PUBLIC OBJECT FUNCTION CreateDomain (STRING tag, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ title := "", description := "", deleteclosedafter := 0, keephistorydays := 0, haspersonaldata := FALSE ], options);
    IF (options.deleteclosedafter < 0)
      THROW NEW Exception(`Cannot delete closed entities after a negative time period`);
    IF (options.keephistorydays < 0)
      THROW NEW Exception(`Cannot keep changes for a negative time period`);

    INSERT CELL tag := tag
              , metatype := wrd_metatype_domain
           INTO options;
    RETURN this->__DoCreateType(options);
  }

  //////////////////////////////////////////
  //
  // Queries
  //

  PUBLIC RECORD ARRAY FUNCTION RunQuery(RECORD querydata)
  {
    RETURN MakeWRDQuery(CELL[...querydata, wrdschema := this ])->Execute(DEFAULT RECORD);
  }

  //////////////////////////////////////////
  //
  // Schema setting
  //

  /** Read a WRD schema setting
      @param keyname Key of value to returned
      @param options Options
      @cell options.fallback Fallback value (used if key does not exist)
      @return Returns key value, throws if the key does not exist and no fallback was supplied
  */
  PUBLIC VARIANT FUNCTION GetSchemaSetting(STRING keyname, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RETURN GetWRDSchemaSetting(this->schemarec.id, keyname, options);
  }

  /** Set a WRD schema setting
      @param keyname Key to set
      @param value Valute to store with the key
  */
  PUBLIC MACRO SetSchemaSetting(STRING keyname, VARIANT value)
  {
    SetWRDSchemaSetting(this->schemarec.id, keyname, value);
  }

  /** Removes a WRD schema setting
      @param keyname Key to delete
  */
  PUBLIC MACRO RemoveSchemaSetting(STRING keyname)
  {
    RemoveWRDSchemaSetting(this->schemarec.id, keyname);
  }

  /** Returns the list of schema settings
      @return @includecelldef #ListWRDSchemaSettings.return
  */
  PUBLIC RECORD ARRAY FUNCTION ListSchemaSettings()
  {
    RETURN ListWRDSchemaSettings(this->schemarec.id);
  }

  /** Get the status of a recent migration script
      @param migrationtag Tag of the migration
      @return A record describing the migration if it executed, a DEFAULT RECORD if it didn't
      @cell(datetime) return.finished When the migration completed
      @cell(record) return.result Result returned by the migration script
  */
  PUBLIC RECORD FUNCTION GetMigrationStatus(STRING migrationtag)
  {
    IF(NOT ObjectExists(this->__GetTypeByTag("wrd_settings", TRUE))) //migrations not even set up yet..
      RETURN DEFAULT RECORD;

    INTEGER mysettings := this->^wrd_settings->Search("wrd_guid", wrd_settings_guid);
    RECORD ARRAY completedmigrations := this->^wrd_settings->GetEntityField(mysettings, "migrations");
    RETURN SELECT result, finished, revision FROM completedmigrations WHERE tag = migrationtag;
  }

  //////////////////////////////////////////
  //
  // Authentication support
  //

  OBJECT FUNCTION GetAccountType()
  {
    RETURN this->schemarec.accounttype != 0 ? this->GetTypeById(this->schemarec.accounttype) : DEFAULT OBJECT;
  }

  STRING FUNCTION GetAccountField(INTEGER fieldid)
  {
    IF(this->schemarec.accountlogin = 0)
      RETURN "";

    OBJECT acctype := this->accounttype;
    IF(NOT ObjectExists(acctype))
      RETURN "";

    RECORD attr := acctype->GetAttributeById(fieldid);
    IF(NOT RecordExists(attr))
      RETURN "";

    RETURN attr.tag;
  }

  STRING FUNCTION GetAccountLoginTag()
  {
    RETURN this->GetAccountField(this->schemarec.accountlogin);
  }

  STRING FUNCTION GetAccountEmailTag()
  {
    RETURN this->GetAccountField(this->schemarec.accountemail);
  }

  STRING FUNCTION GetAccountPasswordTag()
  {
    RETURN this->GetAccountField(this->schemarec.accountpassword);
  }

  BOOLEAN FUNCTION GetAccountPasswordIsAuthSettings()
  {
    IF(this->schemarec.accountlogin = 0)
      RETURN FALSE;

    OBJECT acctype := this->accounttype;
    IF(NOT ObjectExists(acctype))
      RETURN FALSE;

    RECORD attr := acctype->GetAttributeById(this->schemarec.accountpassword);
    IF(NOT RecordExists(attr))
      RETURN FALSE;

    RETURN attr.attributetype = wrd_attributetype_authenticationsettings;
  }

  PUBLIC INTEGER FUNCTION CreateChangeSet()
  {
    OBJECT user := GetEffectiveUser();
    INTEGER id := MakeAutonumber(wrd.changesets, "id");
    INSERT CELL
        [ id
        , creationdate :=   GetCurrentDatetime()
        , wrdschema :=      this->id
        , entity :=         ObjectExists(user) ? user->entityid : 0
        , userdata :=       ObjectExists(user) ? EncodeHSON(user->GetUserDataForLogging()) : ""
        ] INTO wrd.changesets;
    RETURN id;
  }
>;

/** WRD schema object
    @topic wrd/api
    @public
*/
PUBLIC STATIC OBJECTTYPE WRDSchema2017 EXTEND WRDSchemaBase
<
  /** @private
      @param schemarec Database schema record
  */
  MACRO NEW(RECORD schemarec)
  : WRDSchemaBase(schemarec)
  {
    this->__iswrdapi2017 := TRUE;
  }

  STRING FUNCTION TestSchemaResourcesChanged(STRING schemaresource)
  {
    RECORD orgupdate := this->GetSchemaSetting("wrd:schemaresources", [ fallback := DEFAULT RECORD ]);
    IF (NOT RecordExists(orgupdate))
      RETURN `no schema definition resource set`;

    orgupdate :=
        [ schemaresource :=   ""
        , resources :=        RECORD[]
        , version := 0
        , ...orgupdate
        ];

    IF (orgupdate.version != current_schema_version)
      RETURN `schema version mismatch, expected version ${current_schema_version} but got version ${orgupdate.version}`;

    IF (orgupdate.schemaresource != schemaresource)
      RETURN `schemadefinition changed, was ${orgupdate.schemaresource ?? '<not set>'} and is now: ${schemaresource}`;

    FOREVERY (RECORD rec FROM orgupdate.resources) {
      rec := CELL[ resourcename := "", modified := DEFAULT DATETIME, ...rec ];
      IF (rec.resourcename = "" OR rec.modified = DEFAULT DATETIME)
        RETURN `dependencies were invalid`;

      RECORD resource := RetrieveWebhareResource(rec.resourcename, [ allowmissing := TRUE ]);
      IF(NOT RecordExists(resource))
        RETURN `dependency is now missing: ${rec.resourcename}`;

      INTEGER64 age := GetDatetimeDifference(resource.modified, rec.modified).totalmsecs;
      IF(ABS(age)>1)
          RETURN `a dependency was modified: ${rec.resourcename}`;
    }

    RETURN "";
  }

  UPDATE PUBLIC STRING FUNCTION __GetCurrentLanguageCode()
  {
    RETURN GetTidLanguage() ?? "en";
  }
  UPDATE OBJECT FUNCTION __CreateTypeObject(RECORD typerec)
  {
    RETURN NEW WRDType2017(this, typerec);
  }

  /** Get the WRD type oobject for a type
      @param tag Tag of the type to return
      @return(object %WRDType2017) WRD type
  */
  PUBLIC OBJECT FUNCTION GetType(STRING tag)
  {
    RETURN this->__GetTypeByTag(tag);
  }

  /** Update this WRD schema's metadata
      @cell(string) options.schemaresource Schema resource to use (if not set, we'll use the moduldedefinition's specified schema)
      @cell(boolean) options.force Always update, even if the schema resources haven't changed
      @cell(boolean) options.reportupdates Log updated schemas to stderr
      @cell(boolean) options.reportskips Log skipped schemas to stderr
      @cell(boolean) options.fromexternal Set to true if the source is an external server
      @cell(boolean) options.applysettings Apply schema settings (defaults to TRUE)
      @cell(boolean) options.skipmigrations Skip any migrations (note that we never run migrations if fromexternal is set)
      @cell(boolean) options.isprimaryschema Set if this is the moduledef-defined schema and not just a (temorary, adhoc?) extension, and should be recorded as such
  */
  PUBLIC MACRO ApplySchemaDefinition(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ schemaresource := ""
                               , force := FALSE
                               , reportupdates := FALSE
                               , reportskips := FALSE
                               , skipmigrations := FALSE
                               , fromexternal := FALSE
                               , isprimaryschema := FALSE
                               , __schemadefinition := DEFAULT BLOB
                               ], options);

    RECORD schemadef;
    IF(Length(options.__schemadefinition) > 0)//backdoor used by WRD sync. could switch to inline? and/or merge with 'fromexternal' option?
      schemadef := OpenWRDSchemaDefFile("mod::wrd/dummyresource.xml", [ overridedata := options.__schemadefinition, addbaseschema := NOT options.fromexternal ]);  //TODO apparently we parse twice..once for validate and once for ourselves

    IF(NOT RecordExists(schemadef))
    {
      STRING schemaresource := options.schemaresource;
      IF(schemaresource = "")
      {
        schemadef := GetModuleWRDSchemaDefinition(this->tag);
        IF(RecordExists(schemadef))
        {
          schemaresource := schemadef.definitionfile ?? wrd_baseschemaresource;
          IF(schemadef.title != "" AND this->title != schemadef.title)
            this->UpdateMetadata([ title := schemadef.title ]);
        }
        ELSE
        {
          schemaresource := wrd_baseschemaresource;
        }
      }

      IF(schemaresource = "")
        RETURN; //nothing else to update

      STRING changereason;
      IF (options.schemaresource = "" //not an explicitly specified resource
          AND NOT options.force)
      {
        changereason := this->TestSchemaResourcesChanged(schemaresource);
        IF(changereason = "")
        {
          IF(options.reportskips)
            Print(`Not updating '${this->tag}': schema definition not changed\n`);
          RETURN;
        }
      }

      IF(options.reportupdates)
        Print(`Updating schema '${this->tag}'${changereason != "" ? ` because ${changereason}` : ""}\n`);

      schemadef := OpenWRDSchemaDefFile(schemaresource);
    }

    UpdateSchema(this, schemadef, CELL[ options.fromexternal, options.skipmigrations, options.isprimaryschema, iscreate := FALSE ]);
  }

  /** Setup entities in the schema,
      @param commands A list Entity creation commands
      @cell(string) commands.create Tag of the wrdtype to create
      @cell(record) commands.defaults Default values for unspecified entity cells
      @cell(record array) commands.entities A list of CreateEntity records. Will be merged with 'defaults' and any referencing field containing `:<name>`` as a value will be looked up internally
      @cell(string) commands.entities._name Name for the entity, used for references and in the return record
      @cell(record) options.continuesetup An earlier SetupEntities result which we will be allowed to reference and will be merged into our result
      @return A record containing the created entities by their _name */
  PUBLIC RECORD FUNCTION SetupEntities(RECORD ARRAY commands, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ continuesetup := DEFAULT RECORD ], options);
    RETURN NEW BulkCreator(this, options.continuesetup)->Run(commands);
  }
>;

PUBLIC RECORD FUNCTION GetCacheableSchemaRecByName(STRING findname)
{
  RECORD schemarec :=
      SELECT *
        FROM wrd.schemas
        WHERE ToUppercase(name) = ToUppercase(findname);

  RETURN
      [ ttl :=        ttl_wrdschemacache
      , eventmasks := RecordExists(schemarec)
                            ? [ "wrd:schema." || schemarec.id || ".change" ]
                            : [ "wrd:schema.list" ]
      , value := schemarec
      ];
}
PUBLIC RECORD FUNCTION GetCacheableSchemaRec(INTEGER findid)
{
  RECORD schemarec :=
      SELECT *
        FROM wrd.schemas
        WHERE id = findid;

  RETURN
      [ ttl :=        ttl_wrdschemacache
      , eventmasks := RecordExists(schemarec)
                            ? [ "wrd:schema." || schemarec.id || ".change" ]
                            : [ "wrd:schema.list" ]
      , value := schemarec
      ];
}

RECORD ARRAY wrdschemacache;

PUBLIC OBJECT FUNCTION OpenWRDSchema2017(RECORD schemarec)
{
  OBJECT wrdschema := SELECT AS OBJECT(OBJECT(schemaobj)) FROM wrdschemacache WHERE id = schemarec.id;
  IF(ObjectExists(wrdschema))
    RETURN wrdschema;

  DELETE FROM wrdschemacache WHERE id = schemarec.id;
  wrdschema := NEW WRDSchema2017(schemarec);
  INSERT CELL[ id := schemarec.id, schemaobj := WEAKOBJECT(wrdschema) ] INTO wrdschemacache AT END;
  RETURN wrdschema;
}
