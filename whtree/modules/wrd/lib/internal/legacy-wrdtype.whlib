<?wh
LOADLIB "wh::datetime.whlib";


LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::wrd/lib/database.whlib";
LOADLIB "mod::wrd/lib/internal/queries.whlib";
LOADLIB "mod::wrd/lib/internal/support.whlib";
LOADLIB "mod::wrd/lib/internal/setentity.whlib";
LOADLIB "mod::wrd/lib/internal/wrdtype.whlib";
LOADLIB "mod::wrd/lib/internal/legacy-wrdentity.whlib";

PUBLIC OBJECTTYPE LegacyWRDType EXTEND WRDTypeBase
<
  PUBLIC PROPERTY description (GetDescription, -);
  PUBLIC PROPERTY languagecode(currentlanguage, -);
  PUBLIC PROPERTY childtypeids(__childtypeids, -);
  PUBLIC PROPERTY abstract(isabstract, -);

  PUBLIC PROPERTY wrd_requiretype_left(linkfrom, -);
  PUBLIC PROPERTY wrd_requiretype_right(linkto, -);

  PRIVATE STRING currentlanguage;


  ////////////////////////////////////////////////////////////////////
  //
  // NEW and database loading

  PUBLIC MACRO NEW(OBJECT wrdschema, RECORD typerec, STRING currentlanguage)
  : WRDTypeBase(wrdschema, typerec)
  //ADDME: Allow instantiating type at different time
  {
    this->currentlanguage := currentlanguage;
  }

  UPDATE OBJECT FUNCTION __CreateEntityObject(RECORD entityrec)
  {
    RETURN NEW LegacyWRDEntity(this, entityrec);
  }

  PUBLIC MACRO ReloadType()
  {
    THROW NEW Exception(`Legacy WRDType attribute manipulation is no longer supported. You need to use the WRD2017 APIs from mod::wrd/lib/api.whlib`);
  }



  ////////////////////////////////////////////////////////////////////
  //
  // Other stuff

  PUBLIC STRING FUNCTION GenerateGUID()
  {
    RETURN this->GetNewEntityGUID();
  }

  UPDATE PUBLIC MACRO UpdateTypeMetadata(RECORD newmetadata)
  {
    THROW NEW Exception(`Legacy WRDType attribute manipulation is no longer supported. Use UpdateMetadata instead`);
  }

  /** @return Result
      @cell entityid Id of newly created entity (only if no errors occurred)
      @cell errors List of errors
      @cell errors.tag Tag of attribute with the error
      @cell errors.code Error code ("REQUIRED", "TOOLARGE", etc.) ADDME: document all
      @cell errors.attr_title Title of attribute
      @cell settingids Ids of all newly created settings
  */
  PUBLIC RECORD FUNCTION CreateEntity(RECORD entitydata)
  {
    RECORD res := LegacyUpdateEntity(this, entitydata, 0);
    this->domainvalues_cached := FALSE;
    RETURN res;
  }

  /** @return Result
      @cell entityid The newly created entity */
  PUBLIC OBJECT FUNCTION CreateEntity2(RECORD entitydata)
  {
    RETURN this->__DoCreateEntity(entitydata);
  }

  PUBLIC RECORD FUNCTION CreateDomVal(INTEGER parent, STRING title, RECORD entitydata)
  {
    // Update the record for the create entity function
    INSERT CELL wrd_title := title INTO entitydata;
    INSERT CELL wrd_leftentity := parent INTO entitydata;
    this->domainvalues_cached := FALSE;
    RECORD res:= LegacyUpdateEntity(this, entitydata, 0);
    this->domainvalues_cached := FALSE;
    RETURN res;
  }

  PUBLIC STRING FUNCTION GetNewAttributeTag(INTEGER parentattribute, STRING inputtag)
  {
    THROW NEW Exception(`Legacy WRDType attribute manipulation is no longer supported. GetNewAttributeTag is no longer available`);
  }

  PUBLIC RECORD FUNCTION CreateAttribute (STRING attributetype, STRING attributetitle, STRING description, STRING attributetag, STRING domaintag)
  {
    THROW NEW Exception(`Legacy WRDType attribute manipulation is no longer supported. You need to use the WRD2017 APIs from mod::wrd/lib/api.whlib`);
  }

  PUBLIC MACRO UpdateAttributeMetadata(STRING tag, RECORD newsettings)
  {
    THROW NEW Exception(`Legacy WRDType attribute manipulation is no longer supported. You need to use UpdateAttribute`);
  }

  PUBLIC INTEGER FUNCTION LookupEntity(STRING tagname, VARIANT tagval, BOOLEAN match_case DEFAULTSTO TRUE)
  {
    IF(NOT IsDtapLive())
      THROW NEW Exception(`This LookupEntity call should be replaced with ->Search(tagname, tagval${match_case ? "" : ', [ matchcase := FALSE ]'})`);
    RETURN this->Search(tagname, tagval, [matchcase:=match_case]);
  }

  PUBLIC INTEGER FUNCTION LookupWRDEntityByAttribute(STRING tagname, VARIANT tagval, BOOLEAN match_case DEFAULTSTO TRUE)
  {
    IF(NOT IsDtapLive())
      THROW NEW Exception(`This LookupEntity call should be replaced with ->Search(tagname, tagval${match_case ? "" : ', [ matchcase := FALSE ]'})`);
    RETURN this->Search(tagname, tagval, [matchcase:=match_case]);
  }

  /** Returns description of all attributes in this type
      @return Record per attribute (not all described)
      @cell return.allowedvalues Acceptable values for an enum/status field
      @cell return.attributeid Id of attribute (0 for base attributes)
      @cell return.attributetype Type of this attribute
      @cell return.base Whether this is a base attribute
      @cell return.description (not available for internal attributes)
      @cell return.domain If this a domain attribute, id of the domain this attribute refers to
      @cell return.isgenerated Whether this attribute is
      @cell return.isordered Whether the contents of this attribute persist their ordering
      @cell return.isreadonly Whether this is a read-only attribute
      @cell return.isrequired Whether this a required attribute
      @cell return.isunique Whether values in this attribute must be unique (when present)
      @cell return.isinherited
      @cell return.keephistory
      @cell return.localtag
      @cell return.maxlength
      @cell return.checklinks
      @cell return.multiline
      @cell return.parent Parent attribute
      @cell return.tag Tag
      @cell return.title Translated title of this attribute
  */
  PUBLIC RECORD ARRAY FUNCTION GetAttributes(INTEGER fromparent)
  {
    RETURN SELECT *, attributeid := id
             FROM this->ListAttributes(fromparent);
  }

  PUBLIC RECORD FUNCTION GetAttributeInfo(INTEGER attrid)
  {
    RECORD basedata := this->GetAttributeById(attrid);
    IF(RecordExists(basedata))
      INSERT CELL attributeid := attrid INTO basedata;
    RETURN basedata;
  }

  PUBLIC RECORD FUNCTION GetAttributeInfoByTag(STRING find_tag)
  {
    RECORD basedata := this->GetAttribute(find_tag);
    IF(RecordExists(basedata))
      INSERT CELL attributeid := basedata.id INTO basedata;
    RETURN basedata;
  }

  PUBLIC RECORD ARRAY FUNCTION GetDomVals(STRING findtag)
  {
    IF(NOT IsDtapLive())
      THROW NEW Exception(`LegacyWRDType::GetDomVals conflicts with WRDType2017::GetDomVals and is deprecated. If you can't switch to the WRD2017 API yet, at least replace GetDomVals with ListDomVals`);

    RECORD res := this->GetAllDomvals(findtag);
    IF(NOT res.isdom)
    {
      RETURN SELECT *
                  , ordering := 0
               FROM res.type->RunQuery( [ outputcolumns := [ id := "WRD_ID"
                                                    , title := "WRD_TITLE"
                                                    , tag := "WRD_TAG"
                                                    , guid := "WRD_GUID"
                                                    ]
                                 ]);
    }
    DATETIME when := GetCurrentDatetime();
    RETURN SELECT * FROM res.vals WHERE creationdate <= when AND when < limitdate;
  }

  PUBLIC BOOLEAN FUNCTION Exists(INTEGER verifyid)
  {
    INTEGER ARRAY validtypeids := [INTEGER(this->typerec.id)] CONCAT this->__childtypeids;
    RETURN RecordExists(SELECT FROM wrd.entities WHERE id = verifyid AND type IN validtypeids);
  }

  /** @short Get an entity by its tag
    @long Get an entity of this type, looking it up by its tag
    @param tag Tag to look up (case insensitive), or the WRD global unique id if tag starts with 'WRD:'
    @return The entity object, or a default object if no entity was found */
  PUBLIC OBJECT FUNCTION GetEntityByTag(STRING tag)
  {
    INTEGER entity := this->LookupEntity("WRD_TAG", tag, FALSE);
    IF(entity = 0)
      RETURN DEFAULT OBJECT;
    ELSE
      RETURN this->GetEntity(entity);
  }

  PRIVATE STRING FUNCTION GetDescription()
  {
    RETURN this->typerec.description;
  }

  PUBLIC BOOLEAN FUNCTION IsDomainType()
  {
    RETURN this->typerec.metatype=4;
  }

  PUBLIC OBJECT FUNCTION OpenWRDEntityByGuid (STRING http_guid)
  {
    http_guid := ToUpperCase(http_guid);

    IF (LEFT(http_guid, 4) != "WRD:")
      THROW NEW Exception("Global unique ids must start with 'wrd:'");

    // Find the entity, to know the WRD type id
    RECORD entityrec := SELECT entity_id := entities.id
                          FROM wrd.entities
                         WHERE entities.type = this->id
                               AND guid = DecodeWRDGUID(http_guid);
    IF (NOT RecordExists(entityrec))
      RETURN DEFAULT OBJECT;

    // Find the type, open it and return the entity
    RETURN this->GetEntity(entityrec.entity_id);
  }

  PUBLIC OBJECT FUNCTION MakeQuery(RECORD querydata)
  {
    INTEGER resultlimit := -1;
    IF (CellExists(querydata, "resultlimit"))
    {
      resultlimit := querydata.resultlimit;
      DELETE CELL resultlimit FROM querydata;
    }

    RECORD wrdquery := [sources := [ MakeMergedRecord([type := this],querydata)]];
    IF (resultlimit >= 0)
      INSERT CELL resultlimit := resultlimit INTO wrdquery;

    RETURN MakeWRDQuery(wrdquery);
  }
>;
