<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/semver.whlib";
LOADLIB "wh::xml/dom.whlib";
LOADLIB "wh::internal/any.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/typecoder.whlib";
LOADLIB "mod::system/lib/internal/whfs/objects.whlib";

LOADLIB "mod::wrd/lib/api.whlib";
LOADLIB "mod::wrd/lib/internal/metadata/schemaparser.whlib";
LOADLIB "mod::wrd/lib/internal/metadata/updateschema.whlib";
LOADLIB "mod::wrd/lib/internal/sync/service.whlib";
LOADLIB "mod::wrd/lib/internal/sync/support.whlib";


/// Settings that will be ignored
CONSTANT STRING ARRAY ignore_schemasettings :=
    [ "wrd:syncpoints"
    , "wrd:schemaresources"
    , "wrd:sync.history" //removed in 5.3 but we'll keep it on the ignorelist for when we communicate with older servers
    ];

RECORD ARRAY FUNCTION GetExisting(RECORD ARRAY newcurrentcontents, INTEGER id)
{
  RECORD ARRAY existing;
  INTEGER cnt;
  FOREVERY (RECORD rec FROM newcurrentcontents)
  {
    IF (id IN rec.parents)
    {
      existing := existing CONCAT rec.existing;
      cnt := cnt + 1;
    }
  }
  IF (cnt > 1)
    existing := SELECT * FROM existing ORDER BY wrd_guid;
  RETURN existing;
}

STRING FUNCTION GetTypeTagById(RECORD ARRAY newcurrentcontents, INTEGER id)
{
  RETURN (SELECT AS STRING tag FROM newcurrentcontents WHERE COLUMN id = VAR id) ?? "#" || ToString(id);
}

PUBLIC RECORD ARRAY FUNCTION EnrichLocalLinksAttrEntities(RECORD ARRAY newcurrentcontents, RECORD ARRAY attrs)
{
  FOREVERY (RECORD attr FROM attrs)
  {
    IF (attr.attributetypename IN [ "IMAGE", "FILE" ])
      CONTINUE;

    IF (attr.attributetypename = "ARRAY")
      attrs[#attr].fields := EnrichLocalLinksAttrEntities(newcurrentcontents, attr.fields);
    ELSE
      INSERT CELL __map := GetExisting(newcurrentcontents, attr.domain) INTO attrs[#attr];
  }
  RETURN attrs;
}

PUBLIC RECORD ARRAY FUNCTION GetKnownBlobs(RECORD ARRAY attrs, RECORD ARRAY data)
{
  RECORD ARRAY result;
  FOREVERY (RECORD attr FROM attrs)
  {
    IF (attr.attributetypename IN [ "IMAGE", "FILE" ])
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD filerec := GetCell(rec, attr.localtag);
        IF (RecordExists(filerec))
          INSERT CELL[ filerec.hash, filerec.data ] INTO result AT END;
      }
    }
    ELSE IF (attr.attributetypename = "RICHDOCUMENT")
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD docrec := GetCell(rec, attr.localtag);
        IF (RecordExists(docrec))
          FOREVERY (RECORD embed FROM docrec.embedded)
            INSERT CELL[ embed.hash, embed.data ] INTO result AT END;
      }
    }
    ELSE IF (attr.attributetypename = "ARRAY")
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD ARRAY elts := GetCell(rec, attr.localtag);
        result := result CONCAT GetKnownBlobs(attr.fields, elts);
      }
    }
  }
  RETURN result;
}

VARIANT FUNCTION ConvertIdGuidLinks(VARIANT links)
{
  IF (TypeID(links) = TypeID(RECORD))
    RETURN RecordExists(links) ? links.wrd_guid : "";
  IF (TypeID(links) = TypeID(RECORD ARRAY))
    RETURN SELECT AS STRING ARRAY wrd_guid FROM links;
  RETURN links;
}

PUBLIC RECORD ARRAY FUNCTION RestoreLocalLinks(RECORD ARRAY newcurrentcontents, RECORD ARRAY attrs, RECORD ARRAY data, RECORD ARRAY sortedblobs, STRING fortype)
{
  IF (LENGTH(data) = 0)
    RETURN data;

  FOREVERY (RECORD attr FROM attrs)
  {
    // Skip attributes that don't exist locally
    IF (NOT CellExists(data[0], attr.localtag))
      CONTINUE;

    IF (attr.attributetypename IN [ "IMAGE", "FILE" ])
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD filerec := GetCell(rec, attr.localtag);
        IF (RecordExists(filerec) AND NOT CellExists(filerec, "DATA"))
        {
          RECORD pos := RecordLowerBound(sortedblobs, filerec, [ "HASH" ]);
          IF (NOT pos.found)
            THROW NEW exception(`Could not find blob with hash '${filerec.hash}'`);

          __sync_reusedblobs := __sync_reusedblobs + 1;
          INSERT CELL data := sortedblobs[pos.position].data INTO filerec;
          data[#rec] := CellUpdate(rec, attr.localtag, filerec);
        }
      }

      CONTINUE;
    }

    IF (attr.attributetypename = "RICHDOCUMENT")
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD docrec := GetCell(rec, attr.localtag);
        IF (RecordExists(docrec))
        {
          FOREVERY (RECORD embed FROM docrec.embedded)
            IF (NOT CellExists(embed, "DATA"))
            {
              RECORD pos := RecordLowerBound(sortedblobs, embed, [ "HASH" ]);
              IF (NOT pos.found)
                THROW NEW exception(`Could not find blob with hash '${embed.hash}'`);

              __sync_reusedblobs := __sync_reusedblobs + 1;
              INSERT CELL data := sortedblobs[pos.position].data INTO docrec.embedded[#embed];
            }
          data[#rec] := CellUpdate(rec, attr.localtag, docrec);
        }
      }

      CONTINUE;
    }

    IF (attr.attributetypename = "ARRAY")
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD ARRAY elts := GetCell(rec, attr.localtag);
        FOR (INTEGER i := 0, e := LENGTH(elts); i < e; i := i + 1)
          DELETE CELL wrd_settingid FROM elts[i];
        data[#rec] := DEFAULT RECORD;
        data[#rec] := CellUpdate(rec, attr.localtag, RestoreLocalLinks(newcurrentcontents, attr.fields, elts, sortedblobs, fortype));
      }
      CONTINUE;
    }

    // domain or domain array
    RECORD ARRAY map := attr.__map;

    INTEGER ARRAY alllinks;
    IF (attr.attributetypename = "DOMAIN")
    {
      FOREVERY (RECORD rec FROM data)
      {
        STRING link := ConvertIdGuidLinks(GetCell(rec, attr.localtag));
        data[#rec] := DEFAULT RECORD;
        rec := CellDelete(rec, attr.localtag);
        INTEGER rewrite;
        IF (link != "")
        {
          RECORD pos := RecordLowerBound(map, [ wrd_guid := link ], [ "WRD_GUID" ]);
          IF (NOT pos.found)
            THROW NEW Exception(`Could not find entity with guid '${link}' of type '${GetTypeTagById(newcurrentcontents, attr.domain)}'`);
          rewrite := map[pos.position].wrd_id;
        }
        data[#rec] := CellInsert(rec, attr.localtag, rewrite);
      }
    }
    ELSE IF (attr.attributetypename = "DOMAINARRAY")
    {
      FOREVERY (RECORD rec FROM data)
      {
        data[#rec] := DEFAULT RECORD;
        STRING ARRAY links := ConvertIdGuidLinks(GetCell(rec, attr.localtag));
        INTEGER ARRAY rewrite;

        FOREVERY (STRING link FROM links)
        {
          RECORD pos := RecordLowerBound(map, [ wrd_guid := link ], [ "WRD_GUID" ]);
          IF (NOT pos.found)
            THROW NEW Exception(`Could not find entity of type '${GetTypeTagById(newcurrentcontents, attr.domain)}'`);
          INSERT map[[pos].position].wrd_id INTO rewrite AT END;
        }

        rec := CellDelete(rec, attr.localtag);
        data[#rec] := CellInsert(rec, attr.localtag, rewrite);
      }
    }
    ELSE IF (attr.attributetypename = "PAYMENT")
    {
      FOREVERY (RECORD rec FROM data)
      {
        RECORD payment := GetCell(rec, attr.localtag);
        data[#rec] := DEFAULT RECORD;
        INTEGER top_rewrite;
        IF (IsValueSet(payment.paymentprovider))
        {
          RECORD pos := RecordLowerBound(map, [ wrd_guid := ConvertIdGuidLinks(payment.paymentprovider) ], [ "WRD_GUID" ]);
          IF (NOT pos.found)
            THROW NEW Exception(`Could not find entity of type '${GetTypeTagById(newcurrentcontents, attr.domain)}'`);
          top_rewrite := map[pos.position].wrd_id;
        }
        payment := CELL[ ...payment, paymentprovider := top_rewrite ];
        FOREVERY (RECORD prec FROM payment.payments)
        {
          INTEGER arr_rewrite;
          IF (IsValueSet(prec.paymentprovider))
          {
            RECORD pos := RecordLowerBound(map, [ wrd_guid := ConvertIdGuidLinks(prec.paymentprovider) ], [ "WRD_GUID" ]);
            IF (NOT pos.found)
              THROW NEW Exception(`Could not find entity of type '${GetTypeTagById(newcurrentcontents, attr.domain)}'`);
            arr_rewrite := map[pos.position].wrd_id;
          }
          payment.payments[#prec] := CELL[ ...prec, paymentprovider := arr_rewrite ];
        }
        data[#rec] := CellUpdate(rec, attr.localtag, payment);
      }
    }

  }

  RETURN data;
}

/** Synchronize a local schema with the contents of an external schema
    @param wrdschema WRD schema to update
    @param remotepeer Peer where the source schema is located (DEFAULT OBJECT to use this WebHare installation)
    @param remoteschemaname Name of the source schema
    @param options @includecelldef #SyncFromExternalSchemaBatch.options
    @cell(boolean) options.syncmode Sync mode "batch", "incremental". Default is now 'incremental', support for syncmode batch may be dropped in the future
    @return Iterator which gives back progress
*/
PUBLIC OBJECT FUNCTION SyncFromExternalSchema(OBJECT wrdschema, OBJECT remotepeer, STRING remoteschemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ syncmode :=       "incremental"
      ],
      options,
      [ enums :=          [ syncmode := [ "batch", "incremental" ] ]
      , passthroughin :=  "syncoptions"
      ]);

  IF (options.syncmode = "batch")
    RETURN SyncFromExternalSchemaBatch(wrdschema, remotepeer, remoteschemaname, options.syncoptions);
  ELSE
    RETURN SyncFromExternalSchemaIncremental(wrdschema, remotepeer, remoteschemaname, options.syncoptions);
}


/** Synchronize a local schema with the contents of an external schema
    @param wrdschema WRD schema to update
    @param remotepeer Peer where the source schema is located (DEFAULT OBJECT to use this WebHare installation)
    @param remoteschemaname Name of the source schema
    @cell(string array)  options.excludetypes List of types that must not be updated
    @cell(string array)  options.includetypes If not empty, list of types that must be updated (excludedtypes takes priority over this list)
    @cell(string array) options.forcetypes List of mask for types for which all entities must be updated
    @cell(object %WebBrowser) options.browser Optional browser to use
    @cell(boolean) options.commitoften Whether to commit multiple times during the syncing process (instead of only once, after the sync)
    @cell(boolean) options.updateall Set to TRUE to update all entities with their source data
*/
PUBLIC OBJECT FUNCTION *SyncFromExternalSchemaBatch(OBJECT wrdschema, OBJECT remotepeer, STRING remoteschemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ excludetypes :=   STRING[]
      , includetypes :=   STRING[]
      , forcetypes :=     STRING[]
      , browser :=        DEFAULT OBJECT
      , commitoften :=    FALSE
      , updateall :=      FALSE
      ], options);

  // Is this a full synchronization?
  BOOLEAN isfullsync := LENGTH(options.excludetypes) = 0 AND (LENGTH(options.includetypes) = 0 OR "*" IN options.includetypes);

  FOREVERY (STRING s FROM options.excludetypes)
    options.excludetypes[#s] := ToUppercase(s);
  FOREVERY (STRING s FROM options.includetypes)
    options.includetypes[#s] := ToUppercase(s);

  RECORD ARRAY currentcontents;

  OBJECT whfsmapper := NEW WHFSResourceNameMapper;

  GetPrimary()->PushWork();
  GetPrimary()->DisableWorkTimeout(); //TODO restore the setting, but only if it wasn't already disabled

  RECORD ARRAY localtypes := SELECT * FROM wrdschema->ListTypes() ORDER BY tag;

  RECORD ARRAY knownblobs;
  FOREVERY (RECORD typerec FROM localtypes)
  {
    BOOLEAN isexcluded;
    FOREVERY(STRING exclude FROM options.excludetypes)
      IF(ToUppercase(typerec.tag) LIKE exclude)
        isexcluded := TRUE;

    IF (isexcluded)
      CONTINUE;
//    IF (LENGTH(options.includetypes) != 0 AND typerec.tag NOT IN options.includetypes)
//      CONTINUE;

    YIELD [ status := `Gather local entities for domain ${typerec.tag}`, progress := 20m * #typerec / LENGTH(localtypes) ];

    OBJECT type := wrdschema->GetType(typerec.tag);

    RECORD ARRAY attrs := GenerateProcessingInstructions(type, 0, [ "*" ]);
    DELETE FROM attrs WHERE NOT __haveblob;
    STRING ARRAY blobattrs := SELECT AS STRING ARRAY COLUMN localtag FROM attrs WHERE __haveblob;

    RECORD ARRAY currententities :=
        SELECT *
          FROM type->RunQuery(
                  [ outputcolumns :=  [ "wrd_id", "wrd_guid", "wrd_modificationdate", ...blobattrs ]
                  , filters :=        [ [ field := "WRD_TYPE", value := type->id ] ]
                  , historymode :=    "__getfields"
                  ])
      ORDER BY wrd_guid;

    IF (options.updateall OR __MatchesAnyMask(typerec.tag, options.forcetypes))
    {

      // Update modificationdate so sync will update all
      FOR (INTEGER i := 0, e := LENGTH(currententities); i < e; i := i + 1)
        currententities[i].wrd_modificationdate := DEFAULT DATETIME;
    }

    knownblobs := knownblobs CONCAT GetKnownBlobs(attrs, currententities);

    // Remove the blob attributes
    currententities := SELECT wrd_id, wrd_guid, wrd_modificationdate FROM currententities;

    INSERT [ type := typerec.tag, entities := currententities ] INTO currentcontents AT END;
  }

  knownblobs := SELECT * FROM knownblobs ORDER BY hash;

  RECORD res;
  RECORD syncinstructionoptions := CELL
      [ ...options
      , DELETE browser
      , DELETE commitoften
      , DELETE updateall
      , DELETE forcetypes
      , knownblobs :=     (SELECT AS STRING ARRAY DISTINCT hash FROM knownblobs)
      ];

  IF (ObjectExists(whfsmapper))
    INSERT CELL mapwhfslinks := TRUE INTO syncinstructionoptions;

  YIELD [ status := `Getting sync instructions`, progress := 20m, important := TRUE ];
  IF (NOT ObjectExists(remotepeer))
    res := GetSyncInstructions(OpenWRDSchema(remoteschemaname), currentcontents, syncinstructionoptions);
  ELSE
    res := remotepeer->InvokeWRDSyncService("GetSyncInstructions", remoteschemaname, currentcontents, syncinstructionoptions);

  wrdschema->ApplySchemaDefinition([ __schemadefinition := res.schemadefinition, fromexternal := TRUE, applysettings := FALSE ]);

  RECORD ARRAY types := SortWRDTypesOnDependencies(wrdschema->ListTypes(), [ forinsert := TRUE ]);
  RECORD ARRAY newcurrentcontents;

  INTEGER totalrecords, nowrecords;
  FOREVERY (RECORD typerec FROM res.types)
    totalrecords := totalrecords + 2 * LENGTH(typerec.updates) + 2 * LENGTH(typerec.deletes);

  DATETIME now := GetCurrentDateTime();
  DATETIME limitinpast := AddTimeToDate(-1, now);

  FOREVERY (RECORD typerec FROM types)
  {
    OBJECT type := wrdschema->GetType(typerec.tag);

    RECORD current := SELECT * FROM currentcontents WHERE COLUMN type = typerec.tag;
    RECORD ARRAY existing2 := RecordExists(current) ? current.entities : RECORD[];
    RECORD ARRAY existing := RecordExists(current) ? current.entities : RECORD[];

    RECORD updatetyperec := SELECT * FROM res.types WHERE COLUMN type = typerec.tag;
    RECORD ARRAY updates := RecordExists(updatetyperec) ? updatetyperec.updates : RECORD[];

    IF (typerec.isdomain)
    {
      //DumpValue(existing, [ name := "existing", format := "boxed" ]);

      FOREVERY (RECORD entity FROM updates)
      {
        YIELD [ status := `Create entities for domain ${typerec.tag}`, progress := 40m + 50m * nowrecords / totalrecords ];
        //PRINT(` import ${entity.wrd_guid} (parent: ${entity.wrd_leftentity})\n`);
        nowrecords := nowrecords + 1;

        INTEGER wrd_leftentity;
        IF (entity.wrd_leftentity != "")
        {
          RECORD lpos := RecordLowerBound(existing, [ wrd_guid := entity.wrd_leftentity ], [ "WRD_GUID" ]);
          IF (NOT lpos.found)
            ABORT("failed looking up parent of domain entity");
          wrd_leftentity := existing[lpos.position].wrd_id;
        }

        DATETIME new_modtime := AddTimeToDate(-1, entity.wrd_modificationdate);

        RECORD pos := RecordLowerBound(existing, entity, [ "WRD_GUID" ]);
        IF (NOT pos.found)
        {
          RECORD entityrec := CELL[ entity.wrd_guid, wrd_leftentity, wrd_modificationdate := new_modtime ];
          OBJECT obj := type->CreateEntity(entityrec, CELL[ importmode := TRUE, whfsmapper ]);
          INSERT CELL wrd_id := obj->id INTO entityrec;
          INSERT entityrec INTO existing AT pos.position;
        }
        ELSE
        {
          // Disable updated records, so we won't get unique conflicts
          type->UpdateEntity(existing[pos.position].wrd_id, CELL[ wrd_leftentity, wrd_modificationdate := new_modtime, wrd_limitdate := limitinpast ], CELL[ importmode := TRUE, whfsmapper ]);
        }
      }
    }
    ELSE
    {
//      DumpValue(existing, [ name := "existing", format := "boxed" ]);

      RECORD ARRAY lexisting := GetExisting(newcurrentcontents, typerec.linkfrom);
      RECORD ARRAY rexisting := GetExisting(newcurrentcontents, typerec.linkto);

      STRING ltypetag := SELECT AS STRING tag FROM types WHERE id = typerec.linkfrom;
      STRING rtypetag := SELECT AS STRING tag FROM types WHERE id = typerec.linkto;

      BOOLEAN linkfrom := typerec.linkfrom != 0;
      BOOLEAN linkto := typerec.linkto != 0;

/*
      IF (linkfrom)
        DumpValue(lexisting, [ name := "left existing " || ltypetag, format := "boxed" ]);
      IF (linkto)
        DumpValue(rexisting, [ name := "right existing" || rtypetag, format := "boxed" ]);
*/

      FOREVERY (RECORD entity FROM updates)
      {
//        RECORD dbg := [ wrd_leftentity := "n/a", wrd_rightentity := "n/a", ...entity ];
        YIELD [ status := `Create entities for non-domain ${typerec.tag}`, progress := 40m + 50m * nowrecords / totalrecords ];
        nowrecords := nowrecords + 1;

        RECORD entityrec := CELL[ entity.wrd_guid, wrd_modificationdate := AddTimeToDate(-1, entity.wrd_modificationdate) ];
        IF (linkfrom AND (entity.wrd_creationdate != MAX_DATETIME OR entity.wrd_leftentity != "")) //temp entities may ignore leftentity/rightentity requirements
        {
          RECORD xpos := RecordLowerBound(lexisting, [ wrd_guid := entity.wrd_leftentity ], [ "WRD_GUID" ]);
          IF (NOT xpos.found)
            THROW NEW Exception(`${typerec.tag} ${entity.wrd_guid}'s leftentity tries to refer to ${ltypetag} ${entity.wrd_leftentity ?? "<no wrd_guid>"} but it was not found`);

          INSERT CELL wrd_leftentity := lexisting[xpos.position].wrd_id INTO entityrec;
        }
        IF (linkto AND (entity.wrd_creationdate != MAX_DATETIME OR entity.wrd_rightentity != "")) //temp entities may ignore leftenity/rightentity requirements
        {
          RECORD xpos := RecordLowerBound(rexisting, [ wrd_guid := entity.wrd_rightentity ], [ "WRD_GUID" ]);
          IF (NOT xpos.found)
            THROW NEW Exception(`${typerec.tag} ${entity.wrd_guid}'s rightentity tries to refer to ${rtypetag} ${entity.wrd_rightentity ?? "<no wrd_guid>"} but it was not found`);

          INSERT CELL wrd_rightentity := rexisting[xpos.position].wrd_id INTO entityrec;
        }

        RECORD pos := RecordLowerBound(existing, entity, [ "WRD_GUID" ]);
        IF (NOT pos.found)
        {
          OBJECT obj := type->CreateEntity(entityrec, CELL[ importmode := TRUE, whfsmapper, temp := entity.wrd_creationdate = MAX_DATETIME ]);
          INSERT CELL wrd_id := obj->id INTO entityrec;
          INSERT entityrec INTO existing AT pos.position;
        }
        ELSE
        {
          // Disable updated records, so we won't get unique conflicts
          DELETE CELL wrd_guid FROM entityrec;
          type->UpdateEntity(existing[pos.position].wrd_id, CELL[ ...entityrec, wrd_limitdate := limitinpast ], CELL[ importmode := TRUE, whfsmapper ]);
        }
      }
    }

    INTEGER ARRAY children := INTEGER[ typerec.id, ...type->__childtypeids ];
    INSERT CELL
        [ ...typerec
        , existing
        , ids :=        INTEGER[ typerec.id, ...type->__childtypeids ]
        , parents :=    INTEGER[ typerec.id ]
        ] INTO newcurrentcontents AT END;

    UPDATE newcurrentcontents
      SET parents :=    INTEGER[ ...parents, typerec.id ]
    WHERE id IN type->__childtypeids;

    IF (options.commitoften)
    {
      GetPrimary()->PopWork();
      GetPrimary()->PushWork();
    }
  }

  RECORD ARRAY deferreddeletes;

  /* Close entities that will be deleted later, don't want them to interfere with unique constraints
     Can't delete them now, they might cascade entities away that will have their links updated.
  */
  FOREVERY (RECORD typerec FROM types)
  {
    OBJECT type := wrdschema->GetType(typerec.tag);

    RECORD ARRAY existing := (SELECT * FROM newcurrentcontents WHERE COLUMN tag = typerec.tag).existing;

    RECORD updatetyperec := SELECT * FROM res.types WHERE COLUMN type = typerec.tag;
    STRING ARRAY deletes := RecordExists(updatetyperec) ? updatetyperec.deletes : STRING[];

    INTEGER ARRAY ids;
    FOREVERY (STRING todelete FROM deletes)
    {
      YIELD [ status := `Close entities for type ${typerec.tag}`, progress := 40m + 50m * nowrecords / totalrecords ];
      nowrecords := nowrecords + 1;

      RECORD pos := RecordLowerBound(existing, [ wrd_guid := todelete ], [ "WRD_GUID" ]);
      IF (NOT pos.found)
        CONTINUE;

      INTEGER entityid := existing[pos.position].wrd_id;
      INSERT entityid INTO ids AT END;
      type->UpdateEntity(entityid, CELL[ wrd_limitdate := limitinpast ]);
    }

    INSERT CELL
        [ type
        , ids
        ] INTO deferreddeletes AT END;

    IF (options.commitoften)
    {
      GetPrimary()->PopWork();
      GetPrimary()->PushWork();
    }
  }

  FOREVERY (RECORD typerec FROM types)
  {
    OBJECT type := wrdschema->GetType(typerec.tag);

    RECORD ARRAY existing := (SELECT * FROM newcurrentcontents WHERE COLUMN tag = typerec.tag).existing;

    RECORD updatetyperec := SELECT * FROM res.types WHERE COLUMN type = typerec.tag;
    RECORD ARRAY updates := RecordExists(updatetyperec) ? updatetyperec.updates : RECORD[];

    RECORD ARRAY attrs := GenerateProcessingInstructions(type, 0, [ "*" ]);
    attrs := EnrichLocalLinksAttrEntities(newcurrentcontents, attrs);

    updates := RestoreLocalLinks(newcurrentcontents, attrs, updates, knownblobs, typerec.tag);

    FOREVERY (RECORD entity FROM updates)
    {
      YIELD [ status := `Update entities for type ${typerec.tag}`, progress := 40m + 50m * nowrecords / totalrecords ];
      nowrecords := nowrecords + 1;
      RECORD pos := RecordLowerBound(existing, entity, [ "WRD_GUID" ]);
      IF (NOT pos.found)
        CONTINUE;

      TRY
      {
        type->UpdateEntity(existing[pos.position].wrd_id, entity, CELL[ importmode := TRUE, whfsmapper, decodeinvalidutf8as := "ISO-8859-15" ]);
      }
      CATCH (OBJECT e)
      {
        e->what := `${e->what} (while synchronizing ${typerec.tag} entity ${entity.wrd_guid})`;
        THROW;
      }
    }

    IF (options.commitoften)
    {
      GetPrimary()->PopWork();
      GetPrimary()->PushWork();
    }
  }

  FOREVERY (RECORD typerec FROM deferreddeletes)
  {
    OBJECT type := typerec.type;

    IF (LENGTH(typerec.ids) = 0)
      CONTINUE;

    YIELD [ status := `Delete entities for type ${type->tag}`, progress := 40m + 50m * nowrecords / totalrecords ];
    nowrecords := nowrecords + LENGTH(typerec.ids);
    type->DeleteEntities(typerec.ids);

    IF (options.commitoften)
    {
      GetPrimary()->PopWork();
      GetPrimary()->PushWork();
    }
  }

  YIELD [ status := `Updating settings`, progress := 90m, important := TRUE ];

  RECORD schemadef := OpenWRDSchemaDefFile("mod::wrd/dummyresource.xml", [ overridedata := res.schemadefinition, addbaseschema := FALSE ]);

  BOOLEAN settingschanges := UpdateSchemaSettings(
      wrdschema,
      schemadef,
      remotepeer,
      remoteschemaname,
      res,
      isfullsync,
      now,
      options);

  YIELD [ status := `Committing`, progress := 95m, important := TRUE ];
  GetPrimary()->PopWork();

  RETURN [ anychanges := totalrecords != 0 OR settingschanges ];
}

BOOLEAN FUNCTION UpdateSchemaSettings(
    OBJECT wrdschema,
    RECORD schemadef,
    OBJECT remotepeer,
    STRING remoteschemaname,
    RECORD syncinstrs,
    BOOLEAN isfullsync,
    DATETIME now,
    RECORD options)
{
  BOOLEAN settingschanges;

  // Decode the schema settings from the remote schema
  RECORD ARRAY schemadef_settings :=
      SELECT name :=    ToLowercase(name)
           , value :=   AnyTypeFromBlobString(keyvalue.data, keyvalue.blobdata, keyvalue.type)
        FROM schemadef.keyvaluestore;

  // Get current settings of the target schema
  RECORD ARRAY allorgsettings := wrdschema->ListSchemaSettings();

  RECORD ARRAY settings := JoinArrays(
      (SELECT name, orgdata := CELL[ value ] FROM allorgsettings),
      "name",
      (SELECT name, newdata := CELL[ value ] FROM schemadef_settings),
      [ newdata := DEFAULT RECORD ],
      [ presentfield :=     "present"
      , rightouterjoin :=   TRUE
      , leftouterjoin :=    [ orgdata := DEFAULT RECORD ]
      ]);

  // Sync all (non-ignored) settings when changed
  FOREVERY (RECORD rec FROM settings)
  {
    IF (__MatchesAnyMask(rec.name, ignore_schemasettings))
      CONTINUE;

    IF (rec.present = "left")
    {
      settingschanges := TRUE;
      wrdschema->RemoveSchemaSetting(rec.name);
    }
    ELSE IF (rec.present = "right" OR EncodeHSON(rec.orgdata.value) != EncodeHSON(rec.newdata.value))
    {
      settingschanges := TRUE;
      wrdschema->SetSchemaSetting(rec.name, rec.newdata.value);
    }
  }

  // Remove wrd:schemaresources to force new updates, but don't report it as change
  IF (RecordExists(SELECT FROM allorgsettings WHERE name = "wrd:schemaresources"))
    wrdschema->RemoveSchemaSetting("wrd:schemaresources");

  RETURN settingschanges;
}

OBJECTTYPE TypeBlobGetter
<
  OBJECT wrdtype;

  RECORD ARRAY attrs;
  STRING ARRAY blobattrs;

  MACRO NEW(OBJECT wrdtype)
  {
    this->wrdtype := wrdtype;

    this->attrs := GenerateProcessingInstructions(this->wrdtype, 0, [ "*" ]);
    DELETE FROM this->attrs WHERE NOT __haveblob;
    this->blobattrs := SELECT AS STRING ARRAY COLUMN localtag FROM this->attrs WHERE __haveblob;
  }

  /** Returns all blobs from a set of entities
      @param entityids Entity ids
      @return List of blobs (image, file and richdocument embedding), ordered on hash. Only blobs with hashes are returned
      @cell(string) return.hash Blob hash
      @cell(blob) return.data Blob data
  */
  PUBLIC RECORD ARRAY FUNCTION GetBlobsOfEntities(INTEGER ARRAY entityids)
  {
    RECORD ARRAY currententities := this->wrdtype->RunQuery(
        [ outputcolumns :=  this->blobattrs
        , filters :=        [ [ field := "WRD_ID", value := entityids ]
                            , [ field := "WRD_TYPE", value := this->wrdtype->id ]
                            ]
        , historymode :=    "__getfields"
        ]);

    RETURN SELECT * FROM GetKnownBlobs(this->attrs, currententities) ORDER BY hash;
  }
>;

/** Calculate the root parent type for a list of types
    @param types List of types
    @cell(integer) types.id Type ID
    @cell(integer) types.parenttype Parent type id (0 if no parent)
    @return List of type senriched with ID of root type @includecelldef #CalculateRootTypes.types
    @cell return.roottype ID of root parent type
*/
RECORD ARRAY FUNCTION CalculateRootTypes(RECORD ARRAY types)
{
  types :=
      SELECT *
           , roottype :=    parenttype ?? id
        FROM types
    ORDER BY id;

  BOOLEAN anychange := TRUE;
  WHILE (anychange)
  {
    anychange := FALSE;
    FOREVERY (RECORD rec FROM types)
    {
      IF (rec.id != rec.roottype)
      {
        RECORD pos := RecordLowerBound(types, [ id := rec.roottype ], [ "ID" ]);
        IF (NOT pos.found)
          THROW NEW Exception(`Could not locate parent type`);
        IF (types[pos.position].roottype != rec.roottype)
        {
          anychange := TRUE;
          types[#rec].roottype := types[pos.position].roottype;
        }
      }
    }
  }
  RETURN types;
}

OBJECT FUNCTION *RescaleProgress(OBJECT itr, MONEY begin, MONEY range)
{
  WHILE (TRUE)
  {
    RECORD rec := itr->Next();
    IF (rec.done)
      RETURN rec.value;
    YIELD CELL[ ...rec.value, progress := begin + rec.value.progress * range / 100m ];
  }
}

OBJECT FUNCTION *ProcessSourceTargetEntityLists(OBJECT wrdtype, RECORD ARRAY sourceentities, RECORD ARRAY targetentities, DATETIME now, BOOLEAN forceupdate)
{
  GetPrimary()->PushWork();
  TRY
  {
    RECORD ARRAY toupdate;
    INTEGER ARRAY todelete;
    RECORD ARRAY unchanged;

    // create new entities
    INTEGER spos := 0, slen := LENGTH(sourceentities), tpos := 0, tlen := LENGTH(targetentities);
    INTEGER added := 0, updated := 0, deleted := 0, actionsinwork := 0, actions;

    YIELD [ status := `Process entity list for ${wrdtype->tag} ${spos}/${slen} (actions: ${actions})`, progress := 0m ];

    WHILE (spos < slen OR tpos < tlen)
    {
      INTEGER cmp;
      IF (tpos = tlen)
        cmp := -1;
      ELSE IF (spos = slen)
        cmp := 1;
      ELSE IF (sourceentities[spos].wrd_guid <= targetentities[tpos].wrd_guid)
        cmp := sourceentities[spos].wrd_guid = targetentities[tpos].wrd_guid ? 0 : -1;
      ELSE
        cmp := 1;

      IF (cmp = -1) // new entity
      {
        RECORD sdata := sourceentities[spos];
        INTEGER wrd_id := wrdtype->CreateEntity(CELL
            [ sdata.wrd_guid
            , wrd_modificationdate :=   AddTimeToDate(-1, sdata.wrd_modificationdate)
            ], [ importmode := TRUE, temp := TRUE ])->id;

        INSERT CELL[ sourceid := sdata.wrd_id, sdata.wrd_guid, wrd_id ] INTO toupdate AT END;
        added := added + 1;
        actionsinwork := actionsinwork + 1;
        actions := actions + 1;
      }
      ELSE IF (cmp = 0)
      {
        RECORD sdata := sourceentities[spos];
        RECORD tdata := targetentities[tpos];
        IF (sdata.wrd_modificationdate != tdata.wrd_modificationdate OR forceupdate)
        {
          INSERT CELL[ sourceid := sdata.wrd_id, sdata.wrd_guid, wrd_id := tdata.wrd_id ] INTO toupdate AT END;
          updated := updated + 1;

          IF (tdata.wrd_limitdate >= now AND tdata.wrd_creationdate != MAX_DATETIME)
          {
            // close the entity to release constraints on its unique attributes
            wrdtype->UpdateEntity(tdata.wrd_id, CELL[ wrd_limitdate := now, tdata.wrd_modificationdate ]);
            actions := actions + 1;
            actionsinwork := actionsinwork + 1;
          }
        }
        ELSE
          INSERT CELL[ sdata.wrd_guid, wrd_id := tdata.wrd_id ] INTO unchanged AT END;
      }
      ELSE // cmp = 1
      {
        RECORD tdata := targetentities[tpos];
        deleted := deleted + 1;
        INSERT tdata.wrd_id INTO todelete AT END;
        IF (tdata.wrd_limitdate >= now)
        {
          // close the entity to release constraints on its unique attributes
          wrdtype->UpdateEntity(tdata.wrd_id, [ wrd_limitdate := now ]);
          actions := actions + 1;
          actionsinwork := actionsinwork + 1;
        }
      }

      IF (actionsinwork >= 1000)
      {
        GetPrimary()->PopWork();
        GetPrimary()->PushWork();
        actionsinwork := 0;
      }

      IF (cmp <= 0)
      {
        spos := spos + 1;
        IF ((spos % 1000) = 0)
          YIELD [ status := `Process entity list for ${wrdtype->tag} ${spos}/${slen} (actions: ${actions})`, progress := 100m * spos / slen ];
      }
      IF (cmp >= 0)
        tpos := tpos + 1;
    }

    RETURN CELL
        [ unchanged
        , toupdate
        , todelete
        ];
  }
  FINALLY (OBJECT e)
    DoPopWork(e);
}

INTEGER ARRAY FUNCTION GetReferencedDomains(RECORD ARRAY attrs)
{
  INTEGER ARRAY domains;
  FOREVERY (RECORD attr FROM attrs)
  {
    IF (attr.attributetypename = "ARRAY")
      domains := domains CONCAT GetReferencedDomains(attr.fields);
    IF (CellExists(attr, "DOMAIN") AND attr.domain != 0)
      INSERT attr.domain INTO domains AT END;
  }
  RETURN GetSortedSet(domains);
}

// Enrich all processing instructions with translation maps (of the root type)
RECORD ARRAY FUNCTION GetIncrementalSyncAttrMaps(OBJECT wrdschema, RECORD ARRAY attrs, RECORD ARRAY targettypes, RECORD ARRAY mappings)
{
  FOREVERY (RECORD attr FROM attrs)
  {
    IF (attr.attributetypename = "ARRAY")
      attrs[#attr].fields := GetIncrementalSyncAttrMaps(wrdschema, attr.fields, targettypes, mappings);
    IF (NOT CellExists(attr, "DOMAIN") OR attr.domain = 0)
      CONTINUE;

    RECORD ttype := SELECT * FROM targettypes WHERE id = attr.domain;
    IF (NOT RecordExists(ttype))
      THROW NEW Exception(`Could not find target type #${attr.domain}`);
    RECORD pos := RecordLowerBound(mappings, ttype, [ "ROOTTYPE" ]);
    INSERT CELL __map := mappings[pos.position].mappings INTO attrs[#attr];
  }

  RETURN attrs;
}

/** Return the list of schemadef defined attributes for a type
    @param schemadef Remote schema definition
    @param typetag Tag of type
    @return List of attribute tags
*/
STRING ARRAY FUNCTION GetRemoteCustomAttributes(RECORD schemadef, STRING typetag)
{
  STRING ARRAY attrtags;

  // The list of attributes is the union of the attributes for that type plus of
  // those defined in its parents
  WHILE (typetag != "")
  {
    RECORD type := SELECT * FROM schemadef.types WHERE tag = typetag;
    attrtags := attrtags CONCAT SELECT AS STRING ARRAY tag FROM type.attrs;
    typetag := type.parenttype_tag;
  }

  RETURN attrtags;
}

// Pop work, rolling back when an exception is received on the top pushed work
MACRO DoPopWork(OBJECT exc)
{
  IF (NOT ObjectExists(exc) OR GetPrimary()->IsNestedWorkOpen())
    GetPrimary()->PopWork();
  ELSE
    GetPrimary()->RollbackWork();
}

/** Synchronize a local schema with the contents of an external schema, using incremental updates
    @param wrdschema WRD schema to update
    @param remotepeer Peer where the source schema is located (DEFAULT OBJECT to use this WebHare installation)
    @param remoteschemaname Name of the source schema
    @cell(string array) options.excludetypes List of types that must not be updated
    @cell(string array) options.includetypes If not empty, list of types that must be updated (excludedtypes takes priority over this list)
    @cell(string array) options.forcetypes List of mask for types for which all entities must be updated
    @cell(object %WebBrowser) options.browser Optional browser to use
    @cell(boolean) options.commitoften Whether to commit multiple times during the syncing process (instead of only once, after the sync)
    @cell(boolean) options.updateall Set to TRUE to update all entities with their source data
*/
PUBLIC OBJECT FUNCTION *SyncFromExternalSchemaIncremental(OBJECT wrdschema, OBJECT remotepeer, STRING remoteschemaname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ excludetypes :=   STRING[]
      , includetypes :=   STRING[]
      , forcetypes :=     STRING[]
      , browser :=        DEFAULT OBJECT
      , commitoften :=    FALSE
      , updateall :=      FALSE
      ], options);

  // Is this a full synchronization?
  BOOLEAN isfullsync := LENGTH(options.excludetypes) = 0 AND (LENGTH(options.includetypes) = 0 OR "*" IN options.includetypes);

  FOREVERY (STRING s FROM options.excludetypes)
    options.excludetypes[#s] := ToUppercase(s);
  FOREVERY (STRING s FROM options.includetypes)
    options.includetypes[#s] := ToUppercase(s);
  options.includetypes := options.includetypes;

  OBJECT whfsmapper := NEW WHFSResourceNameMapper;

  // ListTypeEntities and RunWRDQuery knownblob support are only present in 5.0.1 and older
  BOOLEAN peer_supports_isync := TRUE;
  IF (ObjectExists(remotepeer))
  {
    RECORD conndata := remotepeer->InvokeAdminService("Connect");
    peer_supports_isync := CellExists(conndata, "semver") AND VersionSatisfiesRange(conndata.semver, ">= 5.0.1-dev", [ comparemode := "webhare" ]);
  }

  // Get the schema structure first
  YIELD [ status := `Getting schema structure instructions`, progress := 0m, important := TRUE ];
  RECORD schemasyncinstr;
  IF (NOT ObjectExists(remotepeer))
    schemasyncinstr := GetSyncInstructions(OpenWRDSchema(remoteschemaname), RECORD[], [ excludetypes := [ "*" ] ]);
  ELSE
    schemasyncinstr := remotepeer->InvokeWRDSyncService("GetSyncInstructions", remoteschemaname, RECORD[], [ excludetypes := [ "*" ] ]);

  YIELD [ status := `Applying schema updates`, progress := 5m, important := TRUE ];

  // Apply type updates
  RECORD sourceschemadef := OpenWRDSchemaDefFile("mod::wrd/dummyresource.xml", [ overridedata := schemasyncinstr.schemadefinition, addbaseschema := FALSE ]);
  GetPrimary()->PushWork();
  TRY
    UpdateSchema(wrdschema, sourceschemadef, CELL[ fromexternal := TRUE, skipmigrations := TRUE ]);
  FINALLY (OBJECT e)
    DoPopWork(e);

  // Re-parse the schema definition to get the list of available types
  STRING ARRAY sourcetypes := SELECT AS STRING ARRAY tag FROM sourceschemadef.types;

  // List the local types that also exist in the source schema
  RECORD ARRAY targettypes :=
      SELECT *
           , targetwrdtype := wrdschema->GetTypeById(id)
        FROM wrdschema->ListTypes()
       WHERE tag IN sourcetypes;

  targettypes := CalculateRootTypes(targettypes);

  // List of wrd_guid->wrd_id mappings, per root type
  RECORD ARRAY mappings :=
      SELECT roottype
           , mappings :=    RECORD[]
        FROM targettypes
    GROUP BY roottype;

  RECORD ARRAY dotargettypes :=
      SELECT *
        FROM targettypes
       WHERE NOT __MatchesAnyMask(tag, options.excludetypes)
         AND (IsDefaultValue(options.includetypes) OR __MatchesAnyMask(tag, options.includetypes));

  DATETIME now := GetCurrentDateTime();

  RECORD ARRAY toprocess;
  FOREVERY (RECORD targettype FROM dotargettypes)
  {
    MONEY progress_begin := 10m + 30m * #targettype / LENGTH(dotargettypes);
    MONEY progress_range := 30m / LENGTH(dotargettypes);

    YIELD [ status := `Getting entity list for ${targettype.tag}`, progress := progress_begin ];

    RECORD ARRAY sourceentities;
    IF (peer_supports_isync)
    {
      IF (NOT ObjectExists(remotepeer))
        sourceentities := RPC_ListTypeEntities(remoteschemaname, targettype.tag).entities;
      ELSE
        sourceentities := remotepeer->InvokeWRDSyncService("ListTypeEntities", remoteschemaname, targettype.tag).entities;
    }
    ELSE
    {
      RECORD query :=
          [ outputcolumns := [ "WRD_ID", "WRD_GUID", "WRD_MODIFICATIONDATE" ]
          , typefilter := STRING[ targettype.tag ]
          , historymode := "__getfields"
          ];

      IF (NOT ObjectExists(remotepeer))
        sourceentities := RPC_RunWRDQuery(remoteschemaname, targettype.tag, query).data;
      ELSE
        sourceentities := remotepeer->InvokeWRDSyncService("RunWRDQuery", remoteschemaname, targettype.tag, query).data;

      sourceentities := SELECT * FROM sourceentities ORDER BY wrd_guid;
    }

    RECORD ARRAY targetentities := targettype.targetwrdtype->__GetTypeEntityList();

    // Process the entity lists, determine which entities to update/delete, create new entities and close updated entities
    // Yields progress from 0..100, so rescale it
    OBJECT itr := ProcessSourceTargetEntityLists(targettype.targetwrdtype, sourceentities, targetentities, now, __MatchesAnyMask(targettype.tag, options.forcetypes));
    RECORD res := YIELD *RescaleProgress(itr, progress_begin, progress_range);

    // Update the mappings of the root type. Keep it sorted (inheritance isn't used often enough to care about costs for reduntant sorts for now)
    RECORD rootpos := RecordLowerBound(mappings, targettype, [ "ROOTTYPE" ]);
    IF (NOT rootpos.found)
      THROW NEW Exception(`Could not find mappings for rootttype ${targettype.roottype}`);
    mappings[rootpos.position].mappings := SELECT * FROM mappings[rootpos.position].mappings CONCAT res.unchanged CONCAT res.toupdate ORDER BY wrd_guid;

    // Register the instructions for fase 2
    INSERT CELL
        [ targettype.tag
        , targettype.targetwrdtype
        , res.toupdate
        , res.todelete
        , targettype.roottype
        ] INTO toprocess AT END;
  }

  MONEY phase2_progress_start := 40, phase2_progress_range := 45;

  // Calculate the attributes that will be synced plus the list of referenced domains
  INTEGER ARRAY referenceddomains;
  FOREVERY (RECORD dotype FROM toprocess)
  {
    STRING ARRAY remotecustomattrs := GetRemoteCustomAttributes(sourceschemadef, dotype.tag);

    STRING ARRAY outputcolumns := [ "WRD_ID" ] CONCAT
        SELECT AS STRING ARRAY tag
          FROM dotype.targetwrdtype->ListAttributes(0)
         WHERE NOT isunsafetocopy
           AND NOT isreadonly
           AND (base OR tag IN remotecustomattrs);

    RECORD ARRAY attrs := GenerateProcessingInstructions(dotype.targetwrdtype, 0, outputcolumns);

    toprocess[#dotype] := CELL
        [ ...dotype
        , outputcolumns
        , attrs
        ];

    referenceddomains := referenceddomains CONCAT GetReferencedDomains(attrs);
  }

  // Collect additional wrd_guid->wrd_id mappings for unsynced types that are referenced from the synced set
  RECORD ARRAY unmappedtypes :=
        SELECT *
          FROM targettypes
         WHERE id IN referenceddomains
           AND id NOT IN (SELECT AS INTEGER ARRAY id FROM dotargettypes);

  IF (IsValueSet(unmappedtypes))
  {
    MONEY progress_range := 5;
    FOREVERY (RECORD type FROM unmappedtypes)
    {
      YIELD [ status := `Getting additional mapping for ${type.tag}`, progress := phase2_progress_start + progress_range * #type / LENGTH(unmappedtypes) ];

      RECORD ARRAY entities := type.targetwrdtype->__GetTypeEntityList();

      RECORD rootpos := RecordLowerBound(mappings, type, [ "ROOTTYPE" ]);
      IF (NOT rootpos.found)
        THROW NEW Exception(`Could not find mappings for rootttype ${type.roottype}`);
      mappings[rootpos.position].mappings := SELECT * FROM mappings[rootpos.position].mappings CONCAT (SELECT wrd_id, wrd_guid FROM entities) ORDER BY wrd_guid;
    }

    phase2_progress_start := phase2_progress_start + progress_range;
    phase2_progress_range := phase2_progress_range - progress_range;
  }

  // Calculate progress per type for the following fase
  INTEGER total_toupdate := SELECT AS INTEGER SUM(LENGTH(toupdate)) FROM toprocess;
  INTEGER total_todelete := SELECT AS INTEGER SUM(LENGTH(todelete)) FROM toprocess;
  INTEGER now_updates;
  FOREVERY (RECORD rec FROM toprocess)
  {
    INSERT CELL progress_begin := phase2_progress_start + phase2_progress_range * now_updates / (total_toupdate ?? 1) INTO toprocess[#rec];
    INSERT CELL progress_range := phase2_progress_range * LENGTH(rec.toupdate) / (total_toupdate ?? 1) INTO toprocess[#rec];
    now_updates := now_updates + LENGTH(rec.toupdate);
  }

  // Process fase 2 sync (updating entities)
  FOREVERY (RECORD dotype FROM toprocess)
  {
    RECORD ARRAY attrswithmapping := GetIncrementalSyncAttrMaps(wrdschema, dotype.attrs, targettypes, mappings);
    OBJECT blobgetter := NEW TypeBlobGetter(dotype.targetwrdtype);

    INTEGER step := 512;
    FOR (INTEGER i := 0; i < LENGTH(dotype.toupdate); i := i + step)
    {
      YIELD [ status := `Updating entities for ${dotype.tag} ${i}/${LENGTH(dotype.toupdate)}`, progress := dotype.progress_begin + dotype.progress_range * i / LENGTH(dotype.toupdate) ];
      RECORD ARRAY todo := ArraySlice(dotype.toupdate, i, step);

      RECORD query := CELL
          [ dotype.outputcolumns
          , typefilter := STRING[ dotype.tag ]
          , filters := [ [ field := "wrd_id", value := SELECT AS INTEGER ARRAY sourceid FROM todo ] ]
          , historymode := "__getfields"
          ];

      RECORD syncopts :=
          [ mapwhfslinks := TRUE
          ];

      // Gather list of known blobs for the updated entities (support in RPC_RunWRDQuery was added in WebHare 5.0.1)
      RECORD ARRAY knownblobs;
      IF (peer_supports_isync)
      {
        knownblobs := blobgetter->GetBlobsOfEntities(SELECT AS INTEGER ARRAY wrd_id FROM todo);
        INSERT CELL knownblobs := SELECT AS STRING ARRAY hash FROM knownblobs INTO syncopts;
      }

      RECORD res;
      IF (NOT ObjectExists(remotepeer))
        res := RPC_RunWRDQuery(remoteschemaname, dotype.tag, query, syncopts);
      ELSE
        res := remotepeer->InvokeWRDSyncService("RunWRDQuery", remoteschemaname, dotype.tag, query, syncopts);

      // Restore local links and blobs from attribute mappings and knownblobs
      res.data :=
          SELECT *
            FROM RestoreLocalLinks(targettypes, attrswithmapping, res.data, knownblobs, dotype.targetwrdtype->tag)
        ORDER BY wrd_guid;

      GetPrimary()->PushWork();
      TRY
      {
        FOREVERY (RECORD rec FROM todo)
        {
          RECORD pos := RecordLowerBound(res.data, rec, [ "WRD_GUID" ]);
          IF (NOT pos.found)
          {
            // entity was deleted during processing
            INSERT rec.sourceid INTO toprocess[#dotype].todelete AT END;
            CONTINUE;
          }

          // WRD_ID is from the wrong server, WRD_GUID is the same as the updated entity (avoid costly guid checks in entity update)
          RECORD entitydata := CELL[ ...res.data[pos.position], DELETE wrd_id, DELETE wrd_guid ];
          dotype.targetwrdtype->UpdateEntity(rec.wrd_id, entitydata, CELL[ importmode := TRUE, whfsmapper, decodeinvalidutf8as := "ISO-8859-15" ]);
        }
      }
      FINALLY (OBJECT e)
        DoPopWork(e);
    }
  }

  // Entity deletion
  FOREVERY (RECORD dotype FROM toprocess)
    IF (IsValueSet(dotype.todelete))
    {
      YIELD [ status := `Deleting entities for ${dotype.tag}`, progress := 85m + 10m * #dotype / LENGTH(toprocess) ];
      GetPrimary()->PushWork();
      TRY
        dotype.targetwrdtype->DeleteEntities(dotype.todelete);
      FINALLY (OBJECT e)
        DoPopWork(e);
    }

  YIELD [ status := `Updating settings`, progress := 95m ];
  BOOLEAN settingschanges;
  GetPrimary()->PushWork();
  TRY
  {
    settingschanges := UpdateSchemaSettings(
        wrdschema,
        sourceschemadef,
        remotepeer,
        remoteschemaname,
        schemasyncinstr,
        isfullsync,
        now,
        options);
  }
  FINALLY (OBJECT e)
    DoPopWork(e);

  RETURN [ anychanges := total_toupdate + total_todelete != 0 OR settingschanges ];
}
