<?wh
/** @short WRD authentication
    @topic wrdauth/api
*/
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::publisher/lib/siteprofiles.whlib";

LOADLIB "mod::wrd/lib/auth/passwordpolicy.whlib";
LOADLIB "mod::wrd/lib/internal/userapi.whlib" EXPORT GetWRDAuthUserAPI;
LOADLIB "mod::wrd/lib/internal/auth/support.whlib" EXPORT CreateAuthenticationSettingsFromPasswordHash, GetDefaultAuthenticationSettings, IsDefaultAuthenticationSettings;
LOADLIB "mod::wrd/lib/internal/auth/saml.whlib";


/** @short Get the authentication plugin for the specified url
    @long This function looks up the fsobject for the url (using LookupPublisherURL) and then obtains the wrdauth plugin object, if ant
    @param url URL to look up
    @cell options.clientwebserver Id of client webserver, if known
    @return The auth plugin. Throws an exception if no plugin is registered */
PUBLIC OBJECT FUNCTION GetWRDAuthPlugin(STRING url, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ clientwebserver := -1 ], options);

  OBJECT wrdauthplugin := GetWebContextForURL(url, options)->GetPlugin("http://www.webhare.net/xmlns/wrd", "wrdauth");
  IF(NOT ObjectExists(wrdauthplugin))
    THROW NEW Exception("No wrdauth plugin registered for URL " || url);

  RETURN wrdauthplugin;
}

/** Base class for WRDuth support objects
*/
PUBLIC STATIC OBJECTTYPE WRDAuthSupportBase <
  OBJECT plugin;

  MACRO NEW(OBJECT plugin)
  {
    this->plugin := plugin;
  }

  /** @short Lookup an OIDC login */
  PUBLIC RECORD FUNCTION LookupOIDCLogin(RECORD payload, RECORD context)
  {
    RECORD trylogin := this->GetOIDCLoginName(CELL[wrd_id := context.oidc_client, wrd_tag := context.oidc_tag, context.loginfield ], payload);
    IF(NOT RecordExists(trylogin))
    {
      LogDebug("wrd:auth-oidc-lookupfailure", CELL[ payload, context, error := "Configuration issue, unable to figure out login field to check" ]);
      RETURN DEFAULT RECORD;
    }

    INTEGER userid := this->LookupLogin(trylogin.value);
    LogDebug("wrd:auth-oidc-lookupresult", CELL[ payload, context, userid, trylogin.field, trylogin.value ]);
    RETURN CELL [ userid, trylogin.field, trylogin.value ];
  }

  /** @short Lookup a login */
  PUBLIC INTEGER FUNCTION LookupLogin(STRING loginname)
  {
    RETURN this->plugin->accounttype->Search(this->plugin->wrdschema->accountlogintag, TrimWhitespace(loginname), [ matchcase := FALSE ]);
  }
  /** @short Login
      @return A record
      @cell return.success True if the login was successful
      @cell return.code Error code ("", "UNKNOWNLOGIN", "INCORRECTPASSWORD")
  */
  PUBLIC RECORD FUNCTION Login(STRING login, STRING password, RECORD options)
  {
    RETURN this->plugin->__GetWRDAuth()->Login(login, password, options);
  }

  /** @short Extract the login name from an OIDC payload
      @param providerinfo Provider information
      @cell(integer) providerinfo.wrd_id ID
      @cell(string) providerinfo.wrd_tag Tag
      @cell(string) providerinfo.loginfield Login field to use
      @param payload OIDC payload describing the user*/
  RECORD FUNCTION GetOIDCLoginName(RECORD providerinfo, RECORD payload)
  {
    IF(providerinfo.loginfield != "")
    {
      IF(CellExists(payload, providerinfo.loginfield) AND TYPEID(GetCell(payload, providerinfo.loginfield)) = TYPEID(STRING))
        RETURN CELL [ field := providerinfo.loginfield, value := GetCell(payload, providerinfo.loginfield) ];
      RETURN DEFAULT RECORD;
    }

    //Fallback configuration.
    IF(CellExists(payload, 'email') AND CellExists(payload, 'email_verified') AND payload.email_verified)
      RETURN [ field := "email", value := payload.email ];
    ELSE IF(CellExists(payload, 'employeeid')) //FIXME remove this exception (currently used for UT/Azure) and explicitly configure the provider to look in the employeeid claim
      RETURN [ field := "employeeid", value := payload.employeeid ];
    ELSE
      RETURN [ field := "sub", value := payload.sub ];

    RETURN DEFAULT RECORD;
  }


  PUBLIC OBJECT FUNCTION GetSAMLSPConfig(OBJECT plugin, STRING sp_tag, RECORD configdata)
  {
    RETURN NEW SAMLWebhareSPConfig(plugin, configdata);
  }

  PUBLIC OBJECT FUNCTION GetSAMLIDPConfig(OBJECT plugin, RECORD configdata)
  {
    RETURN NEW SAMLWebhareIDPConfig(plugin, configdata);
  }

  /** @short Get the current user editing policy
      @long Get the current policry for editing users<br>
      This function is called:<br>
      - when the user data has just been loaded (atsubmit is FALSE)<br>
      - when the user presses submit (atsubmit is TRUE)<br>
      - when the submit request has been handled  (atsubmit is FALSE)<br>
      The state of input fields is then updated according to the returned policy.
      @param userid Current user id. 0 for new users
      @param fields Current values. Is DEFAULT RECORD at user screen initialization and when getting searchable fields.
      @cell(string) fields.username Current filled in username
      @cell(string) fields.email Currently filled in email
      @cell(integer) fields.unit Currently selected unit
      @param atsubmit Whether the data is being submitted (might have more stringent rules)
      @return Policy record
      @cell(boolean) return.haspassword Whether the user can set a password in WebHare (eg not synced to AD or LDAP)
      @cell(string) return.passwordvalidationchecks Password validation checks
      @cell(record) return.searchablefields For every authorisation object (unit, role and person) the list of searchable fields
      @cell(string array) return.searchablefields.unit List of searchable fields for a unit
      @cell(string array) return.searchablefields.role List of searchable fields for a role
      @cell(string array) return.searchablefields.person List of searchable fields for a person
      @cell(record) return.screenextension Optional screen extension to load for the user screen
      @cell(string) return.screenextension.file File with the screen tabextension
      @cell(string) return.screenextension.name Name of the tabextension node
  */
  PUBLIC RECORD FUNCTION GetUserEditPolicy(INTEGER userid, RECORD fields, BOOLEAN atsubmit) {
    // When updating this function, please call WRDAuthSupportBase::GetUserEditPolicy, and then
    // edit the returned policy record
    RECORD retval :=
        [ haspassword :=        TRUE
        , searchablefields := [ unit   := [ "WRD_TITLE", "WHUSER_COMMENT" ]
                              , role   := [ "WRD_TITLE", "WHUSER_COMMENT" ]
                              , person := [ "WRD_FIRSTNAME", "WRD_FIRSTNAMES", "WRD_FULLNAME", "WRD_LASTNAME", "WHUSER_LOGIN", "WRD_TITLE", "WHUSER_COMMENT", "WRD_CONTACT_EMAIL" ]
                              ]
        , screenextension := DEFAULT RECORD
        , passwordvalidationchecks := ""
        ];

    IF (ObjectExists(this->plugin->wrdschema))
    {
      retval := CELL[ ...retval, ...GetDefaultWRDSchemaPasswordPolicy(this->plugin->wrdschema) ];

      IF (RecordExists(fields)) // not always set
      {
        INTEGER unit := fields.unit;
        WHILE (unit != 0)
        {
          RECORD data := this->plugin->wrdschema->^whuser_unit->GetEntityFields(unit, [ "wrd_leftentity", "override_passwordchecks", "passwordchecks" ]);
          IF (data.override_passwordchecks)
          {
            retval.passwordvalidationchecks := data.passwordchecks;
            BREAK;
          }
          unit := data.wrd_leftentity;
        }
      }
    }

    RETURN retval;
  }
>;

/** Check whether the URL has its own checks (eg authorization or hashed URLs) and should be excepted from login checks */
PUBLIC BOOLEAN FUNCTION IsWHSafePublicEndpoint(STRING url)
{
  IF(url NOT LIKE "http:*" AND url NOT LIKE "https:*")
    RETURN FALSE;

  // Safe URLs. Too many, so we will slowly transition to moving all behind /.wh/
  STRING relpath := UnpackURL(url).urlpath;
  RETURN relpath LIKE ".wh/*" //this should be the ONLY url in the future
          OR relpath LIKE "wh_services/*"
          OR relpath LIKE ".ap/*"
          OR relpath LIKE ".se/*" // used for tracking by publisher/js/analytics/gtm.es
          OR relpath LIKE ".uc/*"
          OR relpath LIKE ".wrd/*"
          OR relpath LIKE ".publisher/sd/*"
          //until enough bookmark users have transitioned to new URLs
          OR relpath LIKE ".publisher/common/debug/*"
          OR relpath LIKE ".publisher/common/find/*"
          //TODO consider whether we should just open all of well-known.
          OR relpath LIKE ".well-known/openid-configuration";
}
