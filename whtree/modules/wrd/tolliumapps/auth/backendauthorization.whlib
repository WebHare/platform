<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::util/otp.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::wrd/lib/internal/auth/support.whlib";


PUBLIC STATIC OBJECTTYPE BackendAuthorizationDialog EXTEND TolliumScreenBase
<
  RECORD options;

  MACRO Init(RECORD data)
  {
    this->options := ValidateOptions(
        [ askpassword :=        TRUE
        , asksecondfactor :=    TRUE
        , returnpassword :=     FALSE
        , allowemptypassword := FALSE
        ], data);

    RECORD settings := this->GetSettings();

    ^btn_next->title := RecordExists(settings.totp) AND this->options.asksecondfactor
        ? GetTid("~next") ||  " \xE2\x80\xBA\xE2\x80\xBA"
        : GetTid("~ok");

    // Don't ask for the password when the passwordhash is empty and empty passwords are allowed
    IF (this->options.allowemptypassword AND (IsDefaultValue(settings.passwords) OR settings.passwords[END-1].passwordhash IN [ "", "*" ]))
      this->options.askpassword := FALSE;

    IF (NOT this->options.askpassword)
    {
      ^password->required := FALSE;
      this->DoNext();
    }
  }

  RECORD FUNCTION GetSettings()
  {
    VARIANT settings := this->contexts->user->entity->GetField(this->contexts->userapi->wrdschema->accountpasswordtag);
    IF (TypeID(settings) = TypeID(STRING))
      settings := CreateAuthenticationSettingsFromPasswordHash(settings, [ validfrom := DEFAULT DATETIME ]);
    settings := settings ?? GetDefaultAuthenticationSettings();

    RETURN settings;
  }

  MACRO ReturnFailure()
  {
    this->__SetScreenResult(DEFAULT RECORD);
  }

  MACRO ReturnSuccess()
  {
    RECORD retval := [ result := "ok" ];
    IF (this->options.returnpassword)
      INSERT CELL password := ^password->value INTO retval;

    this->__SetScreenResult(retval);
  }

  MACRO DoNext()
  {
    // Re-read settings from entity, don't want to allow backupcode re-use
    RECORD settings := this->GetSettings();
    IF (^tabs->selectedtab = ^tab_password)
    {
      STRING passwordhash := RecordExists(settings) AND IsValueSet(settings.passwords) ? settings.passwords[END-1].passwordhash : "";

      IF (this->options.askpassword)
      {
        // FIXME: verify via wrdauthplugin
        OBJECT work := this->BeginWork([ validate := OBJECT[ ^tab_password ]]);
        IF (NOT work->HasFailed())
        {
          IF (NOT VerifyWebHarePasswordHash(^password->value, passwordhash))
            work->AddErrorFor(^password, this->GetTid(".incorrectpassword"));
        }
        IF (NOT work->Finish())
          RETURN;
      }

      IF (RecordExists(settings) AND RecordExists(settings.totp) AND this->options.asksecondfactor)
      {
        ^tabs->selectedtab := ^tab_secondfactor;
        ^btn_next->title := GetTid("~ok");
        ^frame->focused := ^totpcode;
      }
      ELSE
        this->ReturnSuccess();
    }
    ELSE IF (^tabs->selectedtab = ^tab_secondfactor)
    {
      // FIXME: verify via wrdauthplugin, count failures
      OBJECT work := this->BeginWork([ validate := OBJECT[ ^tab_secondfactor ] ]);

      IF (NOT RecordExists(settings) OR NOT RecordExists(settings.totp))
      {
        this->ReturnSuccess();
        work->Cancel();
        RETURN;
      }

      IF (NOT work->HasFailed())
      {
        RECORD parsed := UnpackOTPUrl(settings.totp.url);
        RECORD res := TestTOTPCode(parsed.secret, ^totpcode->value, parsed.options);
        IF (NOT res.success OR settings.totp.locked != DEFAULT DATETIME)
        {
          IF (NOT RecordExists(SELECT FROM settings.totp.backupcodes WHERE code = ^totpcode->value AND used = DEFAULT DATETIME))
            work->AddErrorFor(^totpcode, this->GetTid(".incorrectcode"));
          ELSE
          {
            // FIXME: directly offer to re-enroll 2FA
            UPDATE settings.totp.backupcodes SET used := GetCurrentDateTime() WHERE code = ^totpcode->value;
            this->contexts->user->entity->UpdateEntity(CellInsert(DEFAULT RECORD, this->contexts->userapi->wrdschema->accountpasswordtag, settings));
          }
        }
      }
      IF (NOT work->Finish())
        RETURN;
      this->ReturnSuccess();
    }
  }

  RECORD FUNCTION Submit()
  {
    RETURN DEFAULT RECORD;
  }
>;
