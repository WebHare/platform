<?wh

LOADLIB "wh::datetime.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whfs/events.whlib";

LOADLIB "mod::tollium/lib/maintenance.whlib";

LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/internal/tasks.whlib";
LOADLIB "mod::publisher/lib/internal/tollium-helpers.whlib";

OBJECT trans;
trans := OpenPrimary();

//ADDME: Deal with race conditions due to tasks 'just' completing (or find better ways to 'enforce' proper scheduled icons)
MACRO CheckScheduledTasks()
{
  trans->BeginWork();

  /////////////////////////////////////////////////////////////////////
  // Get a list of all scheduled tasks
  RECORD ARRAY tasks := SELECT * FROM publisher.schedule;

  /////////////////////////////////////////////////////////////////////
  // Make sure all files listed in 'tasks' are marked as scheduled
  FOREVERY(RECORD task FROM tasks)
  {
    RECORD badfile := SELECT * FROM system.fs_objects WHERE id = task.file AND TestFlagFromPublished(published, PublishedFlag_Scheduled) = FALSE;
    IF (RecordExists(badfile))
    {
      UPDATE system.fs_objects SET published := SetFlagsInPublished(published, PublishedFlag_Scheduled, TRUE) WHERE id=task.file;
      PRINT("File #" || task.file || " had a pending task, but seemed to be incorrectly not marked with a scheduled task icon\n");
      GetWHFSCommitHandler()->ObjectUpdate(badfile.parentsite, badfile.parent, badfile.id);
    }
  }

  /////////////////////////////////////////////////////////////////////
  // Make sure no files are marked as scheduled that don't really have a schedule
  RECORD ARRAY scheduled_files := SELECT * FROM system.fs_objects
                                          WHERE published >= PublishedFlag_Scheduled //this criterium just helps the database optimizer weed out improbable matches
                                                AND TestFlagFromPublished(published, PublishedFlag_Scheduled) = TRUE
                                                AND NOT RecordExists(SELECT FROM tasks WHERE tasks.file = fs_objects.id);

  FOREVERY(RECORD file FROM scheduled_files)
  {
    PRINT("File #" || file.id || " had no pending tasks, but seemed to be incorrectly marked with a scheduled task icon\n");
    UPDATE system.fs_objects SET published := SetFlagsInPublished(published, PublishedFlag_Scheduled, FALSE) WHERE id=file.id;
    GetWHFSCommitHandler()->ObjectUpdate(file.parentsite, file.parent, file.id);
  }

  trans->CommitWork();
}

MACRO CheckPublicDrafts()
{
  trans->BeginWork();

  INTEGER ARRAY files_with_public_drafts :=
      SELECT AS INTEGER ARRAY DISTINCT filelink
        FROM system.fs_objects
       WHERE parent = whconstant_whfsid_drafts;

  RECORD ARRAY badfiles :=
      SELECT id
           , parent
           , parentsite
        FROM system.fs_objects
       WHERE id IN files_with_public_drafts
         AND NOT TestFlagFromPublished(published, PublishedFlag_HasPublicDraft);

  badfiles := badfiles CONCAT
      SELECT id
           , parent
           , parentsite
        FROM system.fs_objects
       WHERE published >= PublishedFlag_HasPublicDraft //this criterium just helps the database optimizer weed out improbable matches
         AND id NOT IN files_with_public_drafts
         AND TestFlagFromPublished(published, PublishedFlag_HasPublicDraft);

  FOREVERY (RECORD rec FROM badfiles)
  {
    IF (rec.id NOT IN files_with_public_drafts)
      PRINT("File #" || rec.id || " had a public draft, but seemed to be incorrectly not marked with a draft icon\n");
    ELSE
      PRINT("File #" || rec.id || " has no public drafts, but seemed to be incorrectly marked with a draft icon\n");

    UPDATE system.fs_objects
       SET published := SetFlagsInPublished(published, PublishedFlag_HasPublicDraft, id IN files_with_public_drafts)
     WHERE id = rec.id;

    GetWHFSCommitHandler()->ObjectUpdate(rec.parentsite, rec.parent, rec.id);
  }

  trans->CommitWork();
}

MACRO RemoveObsoleteDrafts()
{
  trans->BeginWork();

  //We'll take the trashcan expiry limit for autosave ('private draft') too
  INTEGER max_recycle_days := ReadRegistryKey("publisher.trashcan.trashcanexpire");
  DATETIME cutoff := AddDaysToDate(-max_recycle_days, GetCurrentDatetime());

  DELETE FROM system.fs_objects WHERE parent = whconstant_whfsid_autosaves AND modificationdate<cutoff;

  //We can also safely delete any public/private draft whose associated file is already gone (and out of the recyclebin) - they're unreachable for normal users anyway
  DELETE FROM system.fs_objects WHERE parent IN [ whconstant_whfsid_drafts, whconstant_whfsid_autosaves ] AND filelink = 0;

  trans->CommitWork();
}

RECORD ARRAY FUNCTION GetRemovableTargets(RECORD ARRAY intargets)
{
  DELETE FROM intargets WHERE NOT (CellExists(intargets,'folderid') AND folderid > 0); //virtual folders, never cleanup
  INTEGER ARRAY toget := SELECT AS INTEGER ARRAY folderid FROM intargets;
  IF(Length(toget) = 0)
    RETURN RECORD[];

  RECORD ARRAY sources := SELECT id, creationdate := EncodeDateTime(creationdate)
                            FROM system.fs_objects
                           WHERE id IN toget AND isactive;
  DELETE FROM intargets WHERE RecordExists(SELECT FROM sources WHERE sources.id = intargets.folderid AND sources.creationdate = intargets.foldercreationdate);
  RETURN intargets; //unmatched folders can go
}

CheckScheduledTasks();
CheckPublicDrafts();
RemoveObsoleteDrafts();
CleanupObsoleteFavorites("publisher:app", PTR GetRemovableTargets);

//WH5.6 Deleting old version folders
trans->BeginWork();
DELETE FROM system.fs_objects WHERE id = 17 AND name = "whfs-versionhistory" AND parent = whconstant_whfsid_private_system;
DELETE FROM system.fs_objects WHERE id = 18 AND name = "whfs-versionarchive" AND parent = whconstant_whfsid_private_system;
trans->CommitWork();

trans->BeginWork();
ExecuteLifecycleCleanup();
trans->CommitWork();
