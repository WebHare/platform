<?wh
LOADLIB "wh::os.whlib";

LOADLIB "mod::publisher/lib/urlhistory.whlib";
LOADLIB "mod::publisher/lib/internal/dbschema.whlib";

LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/database.whlib";

RECORD args := ParseArguments(GetConsoleArguments(), [ [ name := "recursive", type := "switch" ]
                                                     , [ name := "pin", type := "switch" ]
                                                     , [ name := "saveurlhistory", type := "switch" ]
                                                     , [ name := "restoreurlhistory", type := "switch" ]
                                                     , [ name := "__restoremodificationdatefromurlhistory", type := "switch" ]
                                                     , [ name := "unpin", type := "switch" ]
                                                     , [ name := "dryrun", type := "switch" ]
                                                     , [ name := "paths", type := "paramlist" ]
                                                     ]);
IF (NOT RecordExists(args) OR Length(args.paths) = 0)
{
  Print("Usage: wh publisher:whfstool path [path ...]\n");
  Print("       path         The whfs path(s) to process, wildcards are permitted\n");
  SetConsoleExitCode(1);
  RETURN;
}
IF(args.pin AND args.unpin)
{
  Print("Cannot pin & unpin at the same time\n");
  SetConsoleExitCode(1);
  RETURN;
}

OBJECT trans := OpenPrimary();
OBJECT saveurlhistorytype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/savedurlhistory");
BOOLEAN listonly := NOT (args.pin OR args.unpin OR args.saveurlhistory OR args.__restoremodificationdatefromurlhistory OR args.restoreurlhistory);
INTEGER ARRAY startobjids;

IF((args.restoreurlhistory OR args.__restoremodificationdatefromurlhistory) AND args.saveurlhistory)
  TerminateScriptWithError("save and restore cannot be mixed");

FOREVERY(STRING path FROM args.paths)
{
  OBJECT dest := OpenWHFSObjectByPath(path);
  IF(NOT ObjectExists(dest))
  {
    Print("Invalid path: " || path || "\n");
    SetConsoleExitCode(1);
    RETURN;
  }

  INSERT dest->id INTO startobjids AT END;
}

RECORD ARRAY FUNCTION GetInterestingStuff(INTEGER ARRAY objids, BOOLEAN matchparent)
{
  RETURN SELECT id, whfspath, isfolder, ispinned
           FROM system.fs_objects
          WHERE (matchparent ? (parent IN objids) : (id IN objids));
}

MACRO ExecuteAction(RECORD ARRAY objects, BOOLEAN recursive)
{
  IF(listonly)
  {
    FOREVERY(RECORD path FROM objects)
      Print(path.whfspath||"\n");
  }
  ELSE
  {
    IF(args.pin OR args.unpin)
    {
      FOREVERY(RECORD topin FROM SELECT id,whfspath FROM objects WHERE ispinned = args.unpin)
      {
        Print( (args.pin ? "Pin: " : "Unpin: ") || topin.whfspath || "\n");
        OpenWHFSObject(topin.id)->UpdateMetadata( [ ispinned := args.pin ]);
      }
    }
    IF(args.saveurlhistory)
    {
      INTEGER ARRAY ids := SELECT AS INTEGER ARRAY id FROM objects;
      RECORD ARRAY history := SELECT urlhistory.creationdate
                                   , urlhistory.url
                                   , urlhistory.fsobject
                                FROM publisher.urlhistory
                               WHERE fsobject IN VAR ids;
      RECORD ARRAY objinfo := SELECT originalid := id
                                   , objecturl
                                   , creationdate
                                   , modificationdate
                                   , modifiedby
                                   , path := whfspath
                                FROM system.fs_objects
                               WHERE id IN VAR ids;

      RECORD ARRAY targeturls := SELECT source.id
                                      , target.whfspath
                                   FROM system.fs_objects AS source
                                      , system.fs_objects AS target
                                  WHERE source.filelink = target.id
                                        AND source.id IN VAR ids;

      FOREVERY(RECORD obj FROM objinfo)
      {
        saveurlhistorytype->SetInstanceData(obj.originalid,
          [ ...obj
          , targetpath := (SELECT AS STRING whfspath FROM targeturls WHERE id = obj.originalid)
          , urlhistory := (SELECT creationdate, url FROM history WHERE fsobject = obj.originalid)
          ], [ isvisibleedit := FALSE ]);
      }
    }
    IF(args.restoreurlhistory)
    {
      objects := saveurlhistorytype->Enrich(objects, "ID", [ "urlhistory" ]);
      FOREVERY(RECORD obj FROM objects)
        FOREVERY(RECORD row FROM obj.urlhistory)
          AddURLHistoryEntry(obj.id, row.url LIKE "//*" ? "https:" || row.url : row.url);
    }
    IF(args.__restoremodificationdatefromurlhistory)
    {
      objects := saveurlhistorytype->Enrich(objects, "ID", [ "modificationdate" ]);
      FOREVERY(RECORD obj FROM objects)
        IF(obj.modificationdate != DEFAULT DATETIME)
          UPDATE system.fs_objects SET modificationdate := obj.modificationdate WHERE id = obj.id;
    }
  }

  IF(NOT recursive)
    RETURN;

  INTEGER ARRAY folderids := SELECT AS INTEGER ARRAY id FROM objects WHERE isfolder;
  IF(Length(folderids)=0)
    RETURN;

  ExecuteAction(GetInterestingStuff(folderids, TRUE), recursive);
}

GetPrimary()->BeginWork();

ExecuteAction(GetInterestingStuff(startobjids, FALSE), args.recursive);

IF(args.dryrun)
  GetPrimary()->RollbackWork();
ELSE
  GetPrimary()->CommitWork();
