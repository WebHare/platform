<?wh
LOADLIB "wh::datetime.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib" ;
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/whfs/drafts.whlib" EXPORT StartWorkflowUpdate, ListObjectHistory;

PUBLIC OBJECT FUNCTION CreateObjectWithHistory(OBJECT user, OBJECT parent, RECORD metadata, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  metadata := ValidateOptions(CELL[ typens := ""
                                  , instances := RECORD[]
                                  ], metadata, [ passthroughin := "objectdata"
                                               , required := ["typens"]
                                               , title := "metadata"
                                               ]);
  options := ValidateOptions(CELL[], options);

  OBJECT targettype := OpenWHFSType(metadata.typens);
  IF(NOT ObjectExists(targettype))
    THROW NEW Exception(`No such type: ${metadata.typens}`);
  IF(NOT (targettype->foldertype OR targettype->filetype))
    THROW NEW Exception(`Type is not a file/folder type: ${metadata.typens}`);

  DATETIME now := GetCurrentDatetime();
  RECORD objectdata := CELL[ ...metadata.objectdata
                           , modificationdate := now
                           ];
  OBJECT final := targettype->foldertype ? parent->CreateFolder(objectdata) : parent->CreateFile(objectdata);
  UPDATE system.fs_objects SET creationdate := now WHERE id = final->id; //can't set it directly through the Create APIs
  final := OpenWHFSObject(final->id); //force reload creationdate

  FOREVERY(RECORD instance FROM metadata.instances)
  {
    IF(NOT CellExists(instance,'whfstype'))
      THROW NEW Exception(`Instance #${#instance} has no cell 'whfstype'`);
    final->SetInstanceData(instance.whfstype, CELL [...instance, DELETE whfstype], [ isvisibleedit := FALSE ]);
  }

  RECORD userinfo := user->GetUserDataForLogging();
  INSERT CELL[ fs_object := final->id
             , user := user->authobjectid  //TODO obsolete in the future?
             , userdata := EncodeHSON(userinfo)
             , type := whconstant_historytype_created
             , when := now
             , version := "0.1"
             ] INTO system_internal.fs_history;

  RETURN final;
}

/** Manage the draft/autosave/publish workflow for an editor */
PUBLIC STATIC OBJECTTYPE WorkflowManager <
  /// The original object, outside draft/autosave namespace
  OBJECT baseobject;

  /// Current autosave object
  OBJECT currentautosave;

  /// Current draft object
  OBJECT currentdraft;

  RECORD options;

  PUBLIC PROPERTY useworkflow(this->options.useworkflow,-);

  RECORD ARRAY workflowtypes;

  /** @param options.useworkflow - Enable to only show workflow-enabled tabs
   */
  MACRO NEW(INTEGER objid, RECORD options DEFAULTSTO DEFAULT RECORD) {
    this->options := ValidateOptions(CELL[ readonly := FALSE
                                         , useworkflow := FALSE
                                         , assumewriteaccess := FALSE
                                         , user := DEFAULT OBJECT
                                         , workflowtypes := STRING[]
                                         ], options);

    this->AddTypes(this->options.workflowtypes);
    this->baseobject := OpenWHFSObject(objid);

    //TODO Or handle this as part of state requests
    IF(NOT ObjectExists(this->baseobject))
      THROW NEW Exception(`No such object: ${objid}`);
  }

  PUBLIC BOOLEAN FUNCTION IsReadOnly() { //TODO cache, shouldn't poll rights every time
    RETURN this->options.readonly
           OR IsReadonlyWHFSSpace(this->baseobject->whfspath)
           OR (NOT this->options.assumewriteaccess
               AND (NOT ObjectExists(this->options.user) OR NOT this->options.user->HasRightOn("system:fs_fullaccess", this->baseobject->id)));
  }

  PUBLIC INTEGER FUNCTION GetObjectIdForInspect(STRING version) {
    SWITCH(version) {
      CASE "live" {
        RETURN this->baseobject->id;
      }
      CASE "draft" {
        RETURN ObjectExists(this->currentdraft) ? this->currentdraft->id : 0;
      }
      CASE "autosave" {
        RETURN ObjectExists(this->currentautosave) ? this->currentautosave->id : 0;
      }
      DEFAULT {
        THROW NEW Exception("Invalid version, must be one of 'live', 'draft' or 'autosave'");
      }
    }
  }

  PUBLIC STRING FUNCTION GetPreviewLink(STRING version, RECORD options DEFAULTSTO DEFAULT RECORD) {
    IF(version NOT IN ["live","draft","autosave"])
      THROW NEW Exception("Invalid version, must be one of 'live', 'draft' or 'autosave'");

    OBJECT toshow := version = "autosave" ? this->__GetAutosavedObject() : version = "draft" ? this->__GetDraftObject() : this->baseobject;
    RETURN GetPreviewLink(toshow->id, options);
  }

  //exported for some legacy preview code, but GetPreview should be used
  PUBLIC OBJECT FUNCTION __GetAutosavedObject() {
    this->LoadDrafts();
    RETURN ObjectExists(this->currentautosave) ? this->currentautosave->fsobject : this->__GetDraftObject();
  }

  PUBLIC OBJECT FUNCTION __GetDraftObject() {
    this->LoadDrafts();
    RETURN ObjectExists(this->currentdraft) ? this->currentdraft->fsobject : this->baseobject;
  }

  /** Register additional types. This is okay as long as we haven't started working on the autosave yet */
  PUBLIC MACRO AddTypes(STRING ARRAY types) {
    IF(Length(types) > 0) {
      IF(ObjectExists(this->currentautosave))
        THROW NEW Exception("Can't add types when an autosave is already active");
      IF(NOT this->options.useworkflow)
        THROW NEW Exception("Setting 'workflowtypes' requires setting 'useworkflow' to TRUE");
    }

    FOREVERY(STRING type FROM types) {
      IF(RecordExists(SELECT FROM this->workflowtypes WHERE namespace = VAR type OR scopedtype = VAR type))
        CONTINUE;

      RECORD typeinfo := LookupContentTypeByName(type);
      IF(NOT RecordExists(typeinfo))
        THROW NEW Exception(`Type '${type}' is not a known content type`);
      IF(NOT typeinfo.cloneonarchive AND NOT typeinfo.clonencopy)
        THROW NEW Exception(`Type '${type}' is not copyable and not a suitable workflow type`);

      INSERT typeinfo INTO this->workflowtypes AT END;
    }
  }
  PUBLIC RECORD FUNCTION GetInstanceData(STRING whfstype) {
    this->LoadDrafts();

    RECORD match := SELECT * FROM this->workflowtypes WHERE namespace = VAR whfstype OR scopedtype = VAR whfstype;
    IF(NOT RecordExists(match))
      THROW NEW Exception(`Type '${whfstype}' is not setup to be tracked in the workflow`);

    BOOLEAN hasworkflow := SELECT AS BOOLEAN workflow FROM system_internal.fs_instances WHERE fs_object = this->__GetAutosavedObject()->id AND fs_type = match.id;
    RETURN hasworkflow ? this->__GetAutosavedObject()->GetInstanceData(whfstype) : this->baseobject->GetInstanceData(whfstype);
  }
  MACRO EnsureAutosave() {
    this->LoadDrafts();
    IF(NOT ObjectExists(this->currentautosave))   //The autosave must be linked to the file we're editing, but we should grab instance data from the draft if it exists, otherwise we miss uncached data (as __FlushInstanceData won't see it)
      this->currentautosave := StartWorkflowUpdate(ObjectExists(this->currentdraft) ? this->currentdraft->id : this->baseobject->id,
          [ user := this->options.user, workflowtypes := SELECT AS INTEGER ARRAY id FROM this->workflowtypes ]);
  }
  PUBLIC MACRO SetInstanceData(STRING whfstype, RECORD data) {
    IF(NOT RecordExists(SELECT FROM this->workflowtypes WHERE namespace = VAR whfstype OR scopedtype = VAR whfstype))
      THROW NEW Exception(`Type '${whfstype}' is not setup to be tracked in the workflow`);

    this->EnsureAutosave();
    //TODO workflow validation?
    this->currentautosave->fsobject->SetInstanceData(whfstype, data, [ ifreadonly := "update", workflow := TRUE ]);
  }
  PUBLIC RECORD FUNCTION GetMetadata() {
    OBJECT historicobj := this->currentautosave ?? this->currentdraft;
    IF(ObjectExists(historicobj)) {
      RETURN historicobj->GetMetadata();
    } ELSE {
      RETURN SELECT name, title, keywords, description, data FROM system.fs_objects WHERE id = this->baseobject->id;
    }
  }

  PUBLIC MACRO UpdateData(BLOB newdata) {
    this->EnsureAutosave();
    this->currentautosave->fsobject->UpdateMetadata(CELL[data := newdata ], [ ifreadonly := "update" ]);
  }

  PUBLIC MACRO UpdateMetadata(RECORD updates) {
    this->EnsureAutosave();
    this->currentautosave->UpdateMetadata(updates);
    /* TODO is the drafts.whlib API really adding something useful... will there be other API users or is WorkflowManager more useful for everyone?
    updates := ValidateOptions(CELL[ name := "", title := "", description := "" , keywords := "" ], updates, [ optional := ["*"], title := "updates" ] );

    IF(CellExists(updates,'name'))
      this->currentautosave->SetInstanceData("http://www.webhare.net/xmlns/publisher/draftmetadata", CELL[  updates.name ], [ ifreadonly := "update" ]);

    RECORD directupdates :=  PickCells(updates, ["title","description","keywords"]);
    IF(Length(UnpackRecord(directupdates))>0)
      this->currentautosave->UpdateMetadata(directupdates);
    */
  }

  RECORD ARRAY FUNCTION LoadDrafts() {
    IF(this->IsReadOnly()) //when readonly only the finals are relevant to you
      RETURN RECORD[];

    //TODO skip if our cached info should be up to date
    RECORD ARRAY drafts := GetDrafts(this->baseobject->id);
    RECORD lastautosave := SELECT * FROM drafts WHERE ispublic = FALSE ORDER BY creationdate DESC LIMIT 1;
    RECORD lastdraft := SELECT * FROM drafts WHERE ispublic = TRUE ORDER BY creationdate DESC LIMIT 1;

    this->currentautosave := RecordExists(lastautosave) AND lastautosave.mine ? OpenDraft(this->baseobject->id, lastautosave.id) : DEFAULT OBJECT;
    this->currentdraft := RecordExists(lastdraft) ? OpenDraft(this->baseobject->id, lastdraft.id) : DEFAULT OBJECT;

    RETURN drafts;
  }

  PUBLIC RECORD FUNCTION GetCurrentDraft() {
    IF(NOT this->options.useworkflow)
      THROW NEW Exception("Draft management requires setting 'useworkflow'");

    //FIXME this currently sets this->currentdraft but the APIs shouldn't rely on a user invoking GetCompetingDraft
    RECORD ARRAY drafts := this->LoadDrafts();

    RECORD activedraft := SELECT * FROM drafts WHERE ispublic  ORDER BY creationdate DESC LIMIT 1;
    IF(NOT this->IsReadOnly() AND RecordExists(activedraft)) {
      RETURN CELL[ user_auth_object := activedraft.user
                 , draft_saved := activedraft.creationdate //FIXME is this right? isn't this when autosaving would have started instead of draft's last save?
                 , mine := activedraft.mine
                 ];
    }
    RETURN DEFAULT RECORD;
  }

  PUBLIC RECORD FUNCTION GetResumableAutosave() {
    IF(NOT this->options.useworkflow)
      THROW NEW Exception("Draft management requires setting 'useworkflow'");

    RECORD ARRAY drafts := this->LoadDrafts();
    IF(ObjectExists(this->currentautosave))
      RETURN CELL[]; //no useful metadata yet to report (TODO last mod date?

    RETURN DEFAULT RECORD;
  }

  PUBLIC MACRO DiscardAutosavedChanges() {
    CleanupMyPrivateDrafts(this->baseobject->id);
    this->currentautosave := DEFAULT OBJECT;
  }

  PUBLIC MACRO DiscardDraftAndAutosavedChanges() {
    IF (ObjectExists(this->currentautosave))     {
      this->currentautosave->DeleteSelf();
      this->currentautosave := DEFAULT OBJECT;
    }
    IF (ObjectExists(this->currentdraft)) {
      this->currentdraft->DeleteSelf();
      this->currentdraft := DEFAULT OBJECT;
    }
  }

  PUBLIC RECORD FUNCTION GetObjectMetadata() {
    IF(ObjectExists(this->currentautosave ?? this->currentdraft)) {
      RECORD meta := (this->currentautosave ?? this->currentdraft)->GetMetadata();
      RETURN CELL [ name := meta.name
                  , title := meta.title
                  , keywords := meta.keywords
                  , description := meta.description
                  ];
    } ELSE {
      RETURN CELL [ name := this->baseobject->name
                  , title := this->baseobject->title
                  , keywords := this->baseobject->keywords
                  , description := this->baseobject->description
                  ];
    }
  }

  PUBLIC BOOLEAN FUNCTION HaveAutosavedChanges() {
    RETURN ObjectExists(this->currentautosave);
  }

  PUBLIC BOOLEAN FUNCTION HaveDraftOrAutosavedChanged() { //ie 'there may be something to revert
    RETURN ObjectExists(this->currentautosave ?? this->currentdraft);
  }

  PUBLIC MACRO Save(BOOLEAN withpublish) {
    this->LoadDrafts();

    IF (withpublish = FALSE) { ///This is "SAVE". 'currentautosave' was either linked to the current public draft or the current published object
      this->currentautosave->SaveAsNewPublicDraft(this->options.user);
    } ELSE { // commit or publish
      OBJECT source := this->currentautosave ?? this->currentdraft;
      IF (ObjectExists(source)) {
        // Deletes the autosave and the public draft too (but keep it when it's versioned, will probably contain other data)
        source->SaveAsFinal(this->options.user);
      }
    }
    this->LoadDrafts();
  }


>;
