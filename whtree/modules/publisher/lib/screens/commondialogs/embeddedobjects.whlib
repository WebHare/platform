<?wh

LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/whfs.whlib";

LOADLIB "mod::tollium/lib/dialogs.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";
LOADLIB "mod::tollium/lib/internal/support.whlib";
LOADLIB "mod::tollium/lib/internal/screenparser.whlib";

LOADLIB "mod::publisher/lib/internal/siteprofiles/widgets.whlib";


PUBLIC OBJECTTYPE Editor EXTEND TolliumScreenBase
<
  STRING whfstype;
  OBJECT valuecomponent;
  OBJECT editextension;

  PUBLIC OBJECT component;

  PUBLIC PROPERTY value(GetValue, -);

  MACRO Init(RECORD data)
  {
    this->instance->basefsobject := data.fsbaseobject;
    this->whfstype := data.whfstype;

    this->instance->type := OpenWHFSType(data.whfstype);

    this->frame->title := GetTid(data.typedef.title);

    IF (data.typedef.editor.type = "extension")
    {
      ^extensiontabs->extendcomponents := [ [ name := "contentdata", component := this->instance ] ];

      // We want to prevent crashing an application due to errors in one of the extensions because:
      // - A user may lose data upon a crash, so showing the error and then cancelling the editting is a much better user experience
      // - When developing extensions it lowers the amount of times you have to restart an application due to an error
      TRY
      {
        RECORD result := this->extensiontabs->LoadTabsExtension(data.typedef.editor.extension);
        this->editextension := result.fragment;
        IF (this->editextension NOT EXTENDSFROM TolliumTabsExtensionBase)
          THROW NEW TolliumException(result.components[0], "Widget editextension does not extend TolliumTabsExtensionBase");
      }
      CATCH(OBJECT err)
      {
        LogHarescriptException(err);
        RunExceptionReportDialog(this, err);

        // Don't offer an incomplete editor, just cancel this screen
        this->tolliumresult := "cancel";
        RETURN;
      }

      ^body->spacers := DEFAULT RECORD;
      ^extensiontabs->visible := TRUE;
      ^extensiontabs->type := ^extensiontabs->GetNumVisiblePages() > 1 ? "regular" : "server";
      IF(^extensiontabs->IsResizeSuggested())
      {
        this->frame->savestatebasekey := `${this->frame->savestatebasekey}(${data.typedef.editor.extension})`;
        this->frame->allowresize := TRUE;
        this->frame->savestate := ["size"];
      }

      this->component := this->instance;
      this->valuecomponent := this->instance;
    }
    ELSE IF (data.typedef.editor.type="fragment")
    {
      IF(GetDtapStage() = "development")
        this->RunSimpleScreen("warning", `editfragment= has been deprecated, switch to editextension= for embedded object type ${this->whfstype}`);

      this->component := this->instance;
      this->positioningpanel->extendcomponents := [[ name := "fsinstance", component := this->instance ] //ADDME deprecate at some point. contentdata is consistent with tabsextensions, and we need that if a fragment is being shared between widgets & contentdata
                                                  ,[ name := "contentdata", component := this->instance ]
                                                  ];
      this->positioningpanel->visible := TRUE;
      this->positioningpanel->LoadFragment(GetResourceNameFromScreenPath(data.typedef.editor.fragment), GetScreenNameFromScreenPath(data.typedef.editor.fragment));
      this->valuecomponent := this->instance;
    }
    ELSE
    {
      THROW NEW Exception("Don't know how to construct an editor for embedded object type '" || this->whfstype || "'");
    }

    this->valuecomponent->value := data.value;
    ^extensiontabs->RunExtensionsPostInit();
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT feedback := this->BeginFeedback(); //implies validation on ^extensiontabs

    IF (NOT feedback->HasFailed())
    {
      RECORD val := this->value;
      IF (RecordExists(val))
      {
        IF (NOT CellExists(val, "WHFSTYPE"))
          feedback->AddError(this->GetTid(".missingwhfstype", this->whfstype));
        ELSE IF (val.whfstype != this->whfstype)
          feedback->AddError(this->GetTid(".wrongtypereturned", val.whfstype, this->whfstype));
      }
    }

    ^extensiontabs->SubmitExtensions(feedback);

    RETURN feedback->Finish();
  }

  RECORD FUNCTION GetValue()
  {
    RETURN this->valuecomponent->value ?? [ whfstype := this->whfstype ];
  }
>;

PUBLIC OBJECTTYPE ChooseType EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD ARRAY allcontenttypes;
  RECORD rtdtypeinfo;
  RECORD ARRAY addwidgets;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY value(GetValue, SetValue);

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->rtdtypeinfo := data.rtdtypeinfo;
    this->addwidgets := data.addwidgets;
    this->RefreshList();
    IF(Length(this->groups->rows)=1)
      this->groups->selection := this->groups->rows[0];
    ELSE IF(NOT RecordExists(this->groups->selection))
      this->groups->SetValueIfValid("http://www.webhare.net/xmlns/publisher/generalwidgets");
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  STRING FUNCTION GetValue()
  {
    RETURN this->contenttypes->value;
  }

  MACRO SetValue(STRING newvalue)
  {
    STRING groupns := SELECT AS STRING primarygroup.namespace FROM this->allcontenttypes WHERE namespace = newvalue;
    this->groups->value := groupns;
    this->contenttypes->value := newvalue;
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO OnRefresh(STRING event, RECORD data)
  {
    this->RefreshList();
  }

  // ---------------------------------------------------------------------------
  //
  // List refreshes
  //
  RECORD ARRAY FUNCTION GetApplicableTypes(RECORD rtdtypeinfo)
  {
    RECORD ARRAY contenttypes;
    RECORD ARRAY allowedobjects := rtdtypeinfo.allowedobjects CONCAT this->addwidgets;

    IF(NOT this->rtdtypeinfo.ignoresiteprofilewidgets AND ObjectExists(this->contexts->applytester))
      FOREVERY(RECORD setting FROM this->contexts->applytester->GetCustomSettings("http://www.webhare.net/xmlns/publisher/siteprofile", "allowwidgettype"))
        INSERT ParseAllowWidgetType(setting.node) INTO allowedobjects AT END;

    FOREVERY (RECORD rec FROM allowedobjects)
    {
      STRING lookuptype := rec.type;
      RECORD ARRAY newtypes := LookupContentTypes(lookuptype);

      IF(Length(newtypes) = 0)
      {
        Print("The type '" || lookuptype || "' did not match any installed type\n");
        CONTINUE;
      }

      FOREVERY(RECORD type FROM newtypes)
      {
        IF(NOT type.isembeddedobjecttype)
        {
          Print("Ignoring type '" || type.namespace || "', it is not an <embeddedobjecttype>\n");
          CONTINUE;
        }
        IF(type.namespace = "http://www.webhare.net/xmlns/publisher/embedvideo")
          CONTINUE; //ignore, we have a button for this

        IF(RecordExists(SELECT FROM contenttypes WHERE contenttypes.namespace = type.namespace))
          CONTINUE; //dupe
        INSERT type INTO contenttypes AT END;
      }
    }
    RETURN contenttypes;
  }

  MACRO RefreshList()
  {
    RECORD ARRAY contenttypes := this->GetApplicableTypes(this->rtdtypeinfo);
    RECORD default_group :=
        [ namespace :=          "_default_group"
        , title :=              ":" || this->GetTid(".other")
        , tolliumicon :=        "database/schema"
        ];

    this->allcontenttypes :=
        SELECT *
             , rowkey :=        namespace
             , title :=         GetTid(title)
             , primarygroup :=  primarygroup ?? default_group
             , icon :=          tolliumicon != "" ? this->contenttypes->GetIcon(tolliumicon) : 0
          FROM contenttypes;

    this->groups->rows :=
        SELECT rowkey :=        Any(primarygroup.namespace)
             , namespace :=     Any(primarygroup.namespace)
             , title :=         GetTid(Any(primarygroup.title))
             , icon :=          Any(primarygroup.tolliumicon) != "" ? this->groups->GetIcon(Any(primarygroup.tolliumicon)) : 0
          FROM this->allcontenttypes
      GROUP BY primarygroup.namespace;

    IF (Length(this->groups->rows) = 1)
    {
      this->groups->selection := this->groups->rows[0];
      this->groupspart->visible := FALSE;
      this->contenttypes->borders.left := TRUE;
    }
    ELSE
    {
      this->groupspart->visible := TRUE;
      this->contenttypes->borders.left := FALSE;
    }
  }

  MACRO OnGroupSelect()
  {
    this->contenttypes->rows :=
        SELECT *
          FROM this->allcontenttypes
         WHERE primarygroup.namespace = this->groups->value;
  }
>;
