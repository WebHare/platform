<?wh

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/whfs.whlib";

LOADLIB "mod::tollium/lib/dialogs.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";
LOADLIB "mod::tollium/lib/internal/support.whlib";

LOADLIB "mod::publisher/lib/internal/siteprofiles/widgets.whlib";


PUBLIC OBJECTTYPE Editor EXTEND TolliumScreenBase
<
  STRING whfstype;
  OBJECT valuecomponent;
  OBJECT editextension;

  PUBLIC OBJECT component;

  PUBLIC PROPERTY value(GetValue, -);

  MACRO Init(RECORD data)
  {
    this->instance->basefsobject := data.fsbaseobject;
    this->whfstype := data.whfstype;

    this->instance->type := OpenWHFSType(data.whfstype);

    this->frame->title := GetTid(data.typedef.title);
    ^filetitle->value := data.currenttitle;

    IF (data.typedef.editor.type = "extension")
    {
      ^extensiontabs->extendcomponents := [ [ name := "contentdata", component := this->instance ]
                                          , [ name := "filetitle", component := ^filetitle ]
                                          ];

      // We want to prevent crashing an application due to errors in one of the extensions because:
      // - A user may lose data upon a crash, so showing the error and then cancelling the editting is a much better user experience
      // - When developing extensions it lowers the amount of times you have to restart an application due to an error
      TRY
      {
        RECORD result := this->extensiontabs->LoadTabsExtension(data.typedef.editor.extension);
        this->editextension := result.fragment;
        IF (this->editextension NOT EXTENDSFROM TolliumTabsExtensionBase)
          THROW NEW TolliumException(result.components[0], "Widget editextension does not extend TolliumTabsExtensionBase");
      }
      CATCH(OBJECT err)
      {
        LogHarescriptException(err);
        RunExceptionReportDialog(this, err);

        // Don't offer an incomplete editor, just cancel this screen
        this->tolliumresult := "cancel";
        RETURN;
      }

      ^body->spacers := DEFAULT RECORD;
      ^extensiontabs->visible := TRUE;
      ^extensiontabs->type := ^extensiontabs->GetNumVisiblePages() > 1 ? "regular" : "server";
      IF(^extensiontabs->IsResizeSuggested())
      {
        this->frame->savestatebasekey := `${this->frame->savestatebasekey}(${data.typedef.editor.extension})`;
        this->frame->allowresize := TRUE;
        this->frame->savestate := ["size"];
      }

      IF(data.isfilewidget AND ^extensiontabs->GetNumVisiblePages() >= 1)
      {
        //FIXME this is a hack, and theoretically the first tab might not even be visible due to visibleon... should we offer a <insert> alternative for widgets? or even do title insertion ONLY for widgts working that way?
        ^filetitle->visible := TRUE;
        ^filetitle->required := TRUE; //TODO this might be too harsh for existing widgets... let's see....
        ^filetitle->RemoveFromParent();
        ^extensiontabs->pages[0]->InsertComponentBefore(^filetitle, DEFAULT OBJECT, TRUE);
      }

      this->component := this->instance;
      this->valuecomponent := this->instance;
    }
    ELSE IF (data.typedef.editor.type="fragment")
    {
      IF(GetDtapStage() = "development")
        this->RunSimpleScreen("warning", `editfragment= has been deprecated, switch to editextension= for embedded object type ${this->whfstype}`);

      this->component := this->instance;
      this->positioningpanel->extendcomponents := [[ name := "fsinstance", component := this->instance ] //ADDME deprecate at some point. contentdata is consistent with tabsextensions, and we need that if a fragment is being shared between widgets & contentdata
                                                  ,[ name := "contentdata", component := this->instance ]
                                                  ];
      this->positioningpanel->visible := TRUE;
      this->positioningpanel->LoadFragment(GetResourceNameFromScreenPath(data.typedef.editor.fragment), GetScreenNameFromScreenPath(data.typedef.editor.fragment));
      this->valuecomponent := this->instance;
    }
    ELSE
    {
      THROW NEW Exception("Don't know how to construct an editor for embedded object type '" || this->whfstype || "'");
    }

    this->valuecomponent->value := data.value;
    ^extensiontabs->RunExtensionsPostInit();
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT feedback := this->BeginFeedback(); //implies validation on ^extensiontabs

    IF (NOT feedback->HasFailed())
    {
      RECORD val := this->value;
      IF (RecordExists(val))
      {
        IF (NOT CellExists(val, "WHFSTYPE"))
          feedback->AddError(this->GetTid(".missingwhfstype", this->whfstype));
        ELSE IF (val.whfstype != this->whfstype)
          feedback->AddError(this->GetTid(".wrongtypereturned", val.whfstype, this->whfstype));
      }
    }

    ^extensiontabs->SubmitExtensions(feedback);

    RETURN feedback->Finish();
  }

  RECORD FUNCTION GetValue()
  {
    RETURN this->valuecomponent->value ?? [ whfstype := this->whfstype ];
  }

  PUBLIC STRING FUNCTION GetFileTitle()
  {
    RETURN ^filetitle->value;
  }
>;

PUBLIC STATIC OBJECTTYPE ChooseType EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD ARRAY allcontenttypes;
  RECORD ARRAY widgets;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY value(GetValue, SetValue);

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->widgets := data.widgets;
    this->RefreshList();
    IF(Length(^groups->rows)=1)
      ^groups->selection := ^groups->rows[0];
    ELSE IF(NOT RecordExists(^groups->selection))
      ^groups->SetValueIfValid("http://www.webhare.net/xmlns/publisher/generalwidgets");
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  STRING FUNCTION GetValue()
  {
    RETURN ^contenttypes->value;
  }

  MACRO SetValue(STRING newvalue)
  {
    STRING groupns := SELECT AS STRING primarygroup.namespace FROM this->allcontenttypes WHERE namespace = newvalue;
    ^groups->value := groupns;
    ^contenttypes->value := newvalue;
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO OnRefresh(STRING event, RECORD data)
  {
    this->RefreshList();
  }

  // ---------------------------------------------------------------------------
  //
  // List refreshes
  //
  RECORD ARRAY FUNCTION GetApplicableTypes()
  {
    RECORD ARRAY contenttypes;

    FOREVERY (RECORD rec FROM this->widgets)
    {
      STRING lookuptype := rec.type;
      RECORD newtype := LookupContentType(lookuptype);

      IF(NOT RecordExists(newtype))
      {
        Print("The type '" || lookuptype || "' did not match any installed type\n");
        CONTINUE;
      }

      IF(NOT newtype.isembeddedobjecttype)
      {
        Print("Ignoring type '" || newtype.namespace || "', it is not an <embeddedobjecttype>\n");
        CONTINUE;
      }
      IF(newtype.namespace = "http://www.webhare.net/xmlns/publisher/embedvideo")
        CONTINUE; //ignore, we have a button for this

      IF(RecordExists(SELECT FROM contenttypes WHERE contenttypes.namespace = newtype.namespace))
        CONTINUE; //dupe
      INSERT newtype INTO contenttypes AT END;
    }
    RETURN contenttypes;
  }

  MACRO RefreshList()
  {
    RECORD ARRAY contenttypes := this->GetApplicableTypes();
    RECORD default_group :=
        [ namespace :=          "_default_group"
        , title :=              ":" || this->GetTid(".other")
        , tolliumicon :=        "database/schema"
        ];

    this->allcontenttypes :=
        SELECT *
             , rowkey :=        namespace
             , title :=         GetTid(title)
             , primarygroup :=  primarygroup ?? default_group
             , icon :=          tolliumicon != "" ? ^contenttypes->GetIcon(tolliumicon) : 0
          FROM contenttypes;
     ^groups->rows :=
        SELECT rowkey :=        Any(primarygroup.namespace)
             , namespace :=     Any(primarygroup.namespace)
             , title :=         GetTid(Any(primarygroup.title))
             , icon :=          Any(primarygroup.tolliumicon) != "" ? ^groups->GetIcon(Any(primarygroup.tolliumicon)) : 0
          FROM this->allcontenttypes
      GROUP BY primarygroup.namespace;

    IF (Length(^groups->rows) = 1)
    {
      ^groups->selection := ^groups->rows[0];
      ^groupspart->visible := FALSE;
      ^contenttypes->borders.left := TRUE;
    }
    ELSE
    {
      ^groupspart->visible := TRUE;
      ^contenttypes->borders.left := FALSE;
    }
  }

  MACRO OnGroupSelect()
  {
    ^contenttypes->rows :=
        SELECT *
          FROM this->allcontenttypes
         WHERE primarygroup.namespace = ^groups->value;
  }
>;
