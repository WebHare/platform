<?wh

LOADLIB "wh::files.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";

LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::publisher/lib/contentlibraries.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/widgets.whlib";
LOADLIB "mod::publisher/lib/internal/contentlibraries/support.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

DATETIME FUNCTION ReadLastMod(STRING path)
{
  TRY
  {
    RECORD data := DecodeJSONBlob(GetDiskResource(path));
    data := EnforceStructure([ lastmodifiedwidget := DEFAULT DATETIME ], data);
    RETURN data.lastmodifiedwidget;
  }
  CATCH(OBJECT e)
  {
    RETURN DEFAULT DATETIME;
  }
}

PUBLIC RECORD ARRAY FUNCTION ListSlotsNeedingRepublish()
{
  RECORD ARRAY slots;
  OBJECT slotsfoldertype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/adaptivecontent/slots");

  INTEGER ARRAY slotfolders := SELECT AS INTEGER ARRAY id FROM system.fs_objects WHERE type = slotsfoldertype->id AND NOT IsRecycleOrHistoryWHFSPath(whfspath);
  IF(Length(slotfolders) = 0)
    RETURN RECORD[];

  slots := SELECT id, creationdate
             FROM system.fs_objects
            WHERE parent IN slotfolders;

  slots := SELECT *, guid := GetSlotGuid(slots) FROM slots;
  slots := SELECT *, diskpath := `${GetModuleStorageRoot("publisher")}slots/${guid}.json` FROM slots;
  slots := SELECT *, disklastmod := ReadLastMod(diskpath) FROM slots;

  RECORD ARRAY widgets := SELECT parent, lastmodified := MAX(modificationdate)
                            FROM system.fs_objects
                           WHERE parent IN (SELECT AS INTEGER ARRAY id FROM slots)
                        GROUP BY parent;

  slots := SELECT *, expectlastmod := (SELECT AS DATETIME lastmodified FROM widgets WHERE widgets.parent = slots.id) ?? creationdate FROM slots;

  DELETE FROM slots WHERE disklastmod = expectlastmod;
  RETURN slots;
}

STRING FUNCTION GetRenderedSlotWidget(OBJECT webdesign, RECORD widget)
{
  RETURN BlobToString(GetPrintedAsBlob(PTR webdesign->CallWithScope(PTR webdesign->RenderSharedBlock(ResolveWidgetAsSharedBlock(widget.id)))));
}


PUBLIC MACRO RepublishSingleSlot(RECORD slot)
{
  //TODO Make this more robust, eg by running each slot into a separate job.
  OBJECT applytester := GetApplyTesterForObject(slot.id);
  RECORD webdesigninfo := applytester->GetWebDesignObjinfo();
  IF (NOT RecordExists(webdesigninfo))
    THROW NEW Exception(`Unable to load webdesign for slot #${slot.id}`);

  OBJECT webdesign := InstantiateWebDesign(applytester, webdesigninfo, 0, DEFAULT OBJECT, DEFAULT OBJECT, FALSE);
  RECORD slotinfo := GetSlotInfo(slot.id);
  slotinfo.widgets :=
      SELECT name
           , condition
           , content := GetRenderedSlotWidget(webdesign, widgets)
        FROM slotinfo.widgets;

  CreateDiskDirectoryRecursive(GetDirectoryFromPath(slot.diskpath), TRUE);
  dumpvalue(slotinfo);
  StoreDiskFile(slot.diskpath, EncodeJSONBlob(slotinfo), [ overwrite := TRUE ]);
}

PUBLIC MACRO RepublishSlots(RECORD ARRAY slots)
{
  FOREVERY(RECORD slot FROM slots)
    RepublishSingleSlot(slot);

  //Clear out old slots (DELETEDISKFILE)
}
