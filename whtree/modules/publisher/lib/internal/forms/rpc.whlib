<?wh
LOADLIB "wh::files.whlib";
LOADLIB "wh::internal/any.whlib";
LOADLIB "wh::internal/graphics.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::platform/lib/captcha/captchamgmt.whlib";

LOADLIB "mod::publisher/lib/forms/api.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/internal/forms/support.whlib";
LOADLIB "mod::system/lib/cache.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/mailer.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::publisher/lib/internal/rtd/service.whlib";

LOADLIB "mod::wrd/lib/address.whlib";
LOADLIB "mod::wrd/lib/internal/addressfields.whlib";

OBJECT FUNCTION GetFormObject(RECORD submitinfo)
{
  OBJECT form;
  STRING url := GetWebOriginURL(submitinfo.url);
  originalformrequesturl := url; //Allows GetFormVariable to work in RPCs
  form := OpenFormByTarget(submitinfo.target, [ __applycontext := TRUE ]);
  RETURN form;
}

PUBLIC RECORD FUNCTION RPC_FormSubmit(RECORD submitinfo)
{
  OpenPrimary();
  OBJECT form := GetFormObject(submitinfo);
  form->formcheckratelimits := TRUE;
  //ignoring non-existent fields.. might be client/server out of sync but not worth rejecting a submissionover
  form->SetFormValues(RECORD ARRAY(submitinfo.vals), [ rpcjs := TRUE, ignorenonexisting := TRUE ]);

  RECORD extradata := CellExists(submitinfo,'extrasubmit') ? submitinfo.extrasubmit : DEFAULT RECORD;
  RECORD submitres := form->FormExecuteSubmit(CELL[extradata]);
  submitres.errors :=  SELECT name := Objectexists(comp) ? comp->name : "", message, metadata FROM submitres.errors;
  submitres.warnings :=  SELECT name := Objectexists(comp) ? comp->name : "", message, metadata FROM submitres.warnings;
  RETURN submitres;
}

PUBLIC RECORD FUNCTION RPC_FormInvoke(RECORD submitinfo)
{
  OpenPrimary();
  OBJECT form := GetFormObject(submitinfo);
  form->SetFormValues(RECORD ARRAY(submitinfo.vals), [ rpcjs := TRUE, ignorenonexisting := TRUE ]);
  RETURN form->__FormDoInvoke(submitinfo.methodname, submitinfo.args);
}

PUBLIC STRING FUNCTION RPC_GetUploadedFileFinalURL(STRING uploadurl)
{
  RECORD file := ParseDataURL(uploadurl);
  RECORD wrapped := WrapBlob(file.data, "");
  OpenPrimary();
  RETURN IsSupportedImageResizeType(wrapped.mimetype) ? GetCachedFSImageURL("", CreateTempUploadedFile(wrapped)->id, [method := "none", fixorientation := TRUE])
                                                      : GetCachedFSFileURL("", CreateTempUploadedFile(wrapped)->id);
}
PUBLIC STRING FUNCTION RPC_GetImgFromRemoteURL(STRING uploadurl)
{
  OpenPrimary();

  BLOB content;
  IF(uploadurl LIKE "data:*")
  {
    RECORD res := ParseDataURL(uploadurl);
    IF(NOT RecordExists(res))
      THROW NEW Exception("Invalid data url");

    content := res.data;
  }
  ELSE
  {
    RECORD unp := UnpackURL(uploadurl);
    IF(unp.user != "" OR unp.password != "") //we're not a password tryout service either
      THROW NEW Exception("Authority information may not be specified on a URL");
    IF(unp.scheme NOT IN ['http','https'])
      THROW NEW Exception("Unsupported URL: " || uploadurl);
    IF(NOT unp.isdefaultport) //we're not a port knocker (though we allow it for this WebHare installation)
    {
      IF (GetDtapStage() != "development")
        THROW NEW Exception("Not supporting URLs with a nonstandard port: " || uploadurl);
      RECORD unp_primary := UnpackURL(GetPrimaryWebhareInterfaceURL());
      IF (unp.host != unp_primary.host)
        THROW NEW Exception("Not supporting URLs with a nonstandard port: " || uploadurl || ". Please run tests on the primary interface host.");
    }

    OBJECT browser := NEW WebBrowser;
    browser->timeout := 30000;

    IF (NOT browser->GotoWebPage(uploadurl))
      THROW NEW Exception("Cannot retrieve URL " || uploadurl);

    content := browser->content;
  }


  RECORD wrapped := WrapBlob(content,"");
  IF(wrapped.width = 0 OR wrapped.height = 0)
    THROW NEW Exception("Unsupported image");

  RETURN GetCachedFSImageURL("", CreateTempUploadedFile(wrapped)->id, [method := "none", fixorientation := TRUE]);
}

PUBLIC RECORD FUNCTION RPC_RequestBuiltinForm(RECORD submitinfo, STRING filename, STRING formname)
{
  OpenPrimary();
  RECORD targetinfo := DecryptForThisServer("publisher:formtarget", submitinfo.target);
  INTEGER objid := targetinfo.incontext ?? targetinfo.fsobj;
  OBJECT form := GetWebdesign(objid)->OpenForm("__builtin:" || filename || ":" || formname);
  RETURN [ html := BlobToString(GetPrintedAsBlob(PTR form->RenderForm))
         ];
}

PUBLIC RECORD FUNCTION RPC_GetCaptchaConfiguration(RECORD submitinfo) {
  STRING url := GetWebOriginURL(submitinfo.url);
  originalformrequesturl := url; //Allows GetFormVariable to work in RPCs

  OpenPrimary();
  OBJECT wc := GetWebContextForURL(url, [ clientwebserver := GetClientWebserver() ] );
  IF(wc->AllowToSkipCaptchaCheck())
    RETURN DEFAULT RECORD;

  RECORD provider := GetCaptchaProvider(url);
  RETURN RecordExists(provider) ? PickCells(provider, ["apikey","name"]) : DEFAULT RECORD;
}

//TODO should probably be in a RTE service and not formservice lib...
PUBLIC RECORD FUNCTION RPC_ValidateEmbeddedObjects(STRING ARRAY objrefs)
{
  STRING ARRAY tokill;
  OpenPrimary();
  FOREVERY(STRING objref FROM objrefs)
    IF(NOT ValidateObjectDataRef(objref))
      INSERT objref INTO tokill AT END;
  RETURN [ tokill := tokill ];
}

PUBLIC RECORD FUNCTION RunEmailChecks(STRING langcode, STRING email, RECORD restrictions)
{
  RECORD correction := GetEmailAutocorrection(email);
  BOOLEAN forced;
  IF(RecordExists(correction) AND correction.force)
  {
    email := correction.suggestion;
    forced := TRUE;
  }

  IF(RecordExists(correction) AND correction.blocked)
  {
    STRING domain := '@' || ToLowercase(Tokenize(email,'@')[1]);
    RETURN [ blocked := GetTidForLanguage(langcode, "publisher:site.forms.commonerrors.email_baddomain", domain) ?? "blocked"
           ];
  }

  IF(RecordExists(restrictions) AND Length(restrictions.acceptableemailmasks) > 0 AND NOT __MatchesAnyMask(email, restrictions.acceptableemailmasks))
    RETURN [ blocked := restrictions.unacceptableemailerror ?? GetTidForLanguage(langcode, "publisher:site.forms.commonerrors.unacceptableemail") ];

  IF(forced)
    RETURN [ force := email ];

  IF(RecordExists(correction))
    RETURN [ suggestion := correction.suggestion ];

  RETURN DEFAULT RECORD;
}

RECORD FUNCTION GetEmailRestrictions(RECORD submitinfo)
{
  OBJECT form := GetFormObject(submitinfo);
  OBJECT field := form->__GetFormMember(submitinfo.field);
  RECORD restrictions;
  IF(ObjectExists(field) AND MemberExists(field, "GetEmailRestrictions"))
    restrictions := field->GetEmailRestrictions();

  RETURN CELL[ value := CELL [ restrictions
                             , langcode := GetTidLanguage() //GetFormObject has set the tid language
                             ]
             , ttl := 15*1000 // TODO we want eventmasks to extend this TTL, but GetFormObject needs to record those for us. so now we just absorb peaks
             ];
}

PUBLIC RECORD FUNCTION RPC_FormValidateEmail(RECORD submitinfo, STRING emailaddress)
{
  OpenPrimary(); //TODO avoid by caching the emailrules
  RECORD info := GetAdhocCached(submitinfo, PTR GetEmailRestrictions(submitinfo));
  RECORD baseresult := RunEmailChecks(info.langcode, emailaddress, info.restrictions);
  RETURN baseresult;
}

PUBLIC RECORD FUNCTION RPC_ValidateEmail(STRING langcode, STRING email)
{
  langcode := Tokenize(langcode,'-')[0]; //GetTidForLanguage isn't smart enough for that
  OpenPrimary(); //TODO avoid by caching the emailrules
  RETURN RunEmailChecks(langcode, email, DEFAULT RECORD);
}

PUBLIC RECORD FUNCTION RPC_VerifyAddress(STRING url, RECORD value, RECORD options)
{
  //TODO cache addresslookup settings so we don't always have to go the database
  OpenPrimary();

  options := EnforceStructure([ checks := STRING[], lang := "" ], options);

  OBJECT wc := GetWebContextForURL(GetWebOriginURL(url), [ clientwebserver := GetClientWebserver() ] );
  RECORD info := __LookupFormIntegrationAddressInfo(wc->targetapplytester);
  STRING lang := options.lang ?? "en";

  OBJECT validator;
  IF (CellExists(value, "country"))
    validator := __GetAddressLookupAPIForSettings(info, value.country);

  RECORD verifyresult := [ status := "unknown", errors := RECORD[], corrections := DEFAULT RECORD ];

  IF(ObjectExists(validator))
  {
    IF (value.country = "NL" AND "nl-zip-force" IN options.checks)
      value := CELL[ ...value, street := "", city := "" ];

    RECORD result := validator->CheckAddress(value);

    verifyresult.corrections := PickCells(result.looked_up, stored_address_fields);

    FOREVERY(RECORD field FROM UnpackRecord(verifyresult.corrections))
      IF(CellExists(value, field.name) AND GetCell(value,field.name ) = field.value) //so there was no real correction?
        verifyresult.corrections := CellDelete(verifyresult.corrections, field.name);

    IF(Length(UnpackRecord(verifyresult.corrections))=0)
      verifyresult.corrections := DEFAULT RECORD;

    SWITCH(result.status)
    {
      CASE "invalid_city"
      {
        // We'll target the right field but we don't want to supply N translations for 'invalid city'
        INSERT [ fields := ["city"], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.address_not_found") ] INTO verifyresult.errors AT END;
      }
      CASE "invalid_zip"
      {
        INSERT [ fields := ["zip"], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.invalid_zip") ] INTO verifyresult.errors AT END;
      }
      CASE "zip_not_found"
      {
        INSERT [ fields := ["zip","nr_detail"], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.zip_not_found") ] INTO verifyresult.errors AT END;
      }
      CASE "invalid_nr_detail"
      {
        INSERT [ fields := ["nr_detail"], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.invalid_nr_detail") ] INTO verifyresult.errors AT END;
      }
      CASE "address_not_found"
      {
        INSERT [ fields := STRING[], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.address_not_found") ] INTO verifyresult.errors AT END;
      }
      CASE "incomplete", "ok" //incomplete = the lookup corrected it (if it didn't it would return not_enough_data)
      {
        verifyresult.status := "ok";
      }
    }
  }

  IF(value.country = "NL" AND "nl-zip-force" IN options.checks AND verifyresult.status != "ok" AND Length(verifyresult.errors) = 0)
    INSERT [ fields := STRING[], message := GetTidForLanguage(lang, "publisher:site.forms.addressfield.address_not_found") ] INTO verifyresult.errors AT END;

  IF(Length(verifyresult.errors) > 0)
    verifyresult.status := "error";

  RETURN verifyresult;
}
