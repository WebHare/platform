<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";

LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/forms/api.whlib";
LOADLIB "mod::publisher/lib/forms/base.whlib";
LOADLIB "mod::publisher/lib/webtools/internal/formcomponents.whlib";
LOADLIB "mod::publisher/lib/webtools/internal/formhandlers.whlib";
LOADLIB "mod::publisher/lib/internal/forms/opener.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/tasks.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/mail/mergefields.whlib";


PUBLIC STATIC OBJECTTYPE WebtoolFormBase EXTEND FormBase
<
  OBJECT storehandlerobject;
  RECORD ARRAY formhandlers;
  OBJECT pvt_results;
  STRING pvt_editguid;
  STRING pvt_resultguid;
  STRING pvt_idfieldvalue;
  BOOLEAN pvt_retrievedguid;
  OBJECT captchaquestion;
  RECORD captchasettings;
  OBJECT directhookobject;

  //Custom data generated by the page which will be stored with the form results
  PUBLIC RECORD pagedata;

  PUBLIC PROPERTY formresults(GetFormResults, -);

  PUBLIC PROPERTY editingguid(pvt_editguid, -);
  PUBLIC PROPERTY resultguid(GetResultGuid, -);

  ///If set, the form is unavailable and this text should be shown
  PUBLIC RECORD unavailabletext;

  MACRO NEW()
  {
    // Redirect JSONRPC traffic to the current file
    this->__form.externalformname := "-";
    this->formvariables := CELL[...this->formvariables, formsubmittype := "new" ];

    // TODO Optimize/cache ?  We could've gotten this information when loading the form I think... or we should just do the formload here ?
    IF(ObjectExists(this->formcontext))
    {
      RECORD formsettings := OpenWHFSType("http://www.webhare.net/xmlns/publisher/formwebtool")->GetInstanceData(this->__form.webtoolformid);
      IF(NOT formsettings.disablecaptcha)
      {
        OBJECT formintegrationplugin := this->formcontext->GetPlugin("http://www.webhare.net/xmlns/publisher/siteprofile", "formintegration");
        IF(ObjectExists(formintegrationplugin) AND formintegrationplugin->usecaptcha)
        {
          this->captchaquestion := this->AppendFormField(DEFAULT OBJECT, "http://www.webhare.net/xmlns/publisher/forms#captcha", "__webtoolform__captcha");
          this->captchaquestion->required := TRUE;
        }
      }
      IF(formsettings.unavailable)
        this->unavailabletext := formsettings.unavailabletext;
    }

    IF(RecordExists(this->unavailabletext))
      RETURN;

    // Instantiate the fixed store results handler
    RECORD storehandler :=
        [ handlertype := `${xmlns_forms}#storeresultshandler`
        , guid := ""
        , condition := DEFAULT RECORD
        , settings := CELL[]
        , handlertask := ""
        , handlertaskfor := "submit"
        , handlerobject := "mod::publisher/lib/webtools/formhandlers/storeresults.whlib#StoreResultsHandler"
        ];
    this->storehandlerobject := InstantiateFormHandler(this, storehandler, this->__form.webtoolformid);

    // Initialize the form handlers
    FOREVERY (RECORD handler FROM this->__form.handlers)
      INSERT CELL[...handler
                 , handlerobject := InstantiateFormHandler(this, handler, this->__form.webtoolformid)
                 ] INTO this->formhandlers AT END;

    IF(this->__form.forcewebtoolformbase)
      RETURN; //no need to load hooks if we're doing a results-only load

    OBJECT targetformapplytester := GetApplyTesterForObject(this->__form.webtoolformid); //TODO we could cache endresult of this lookup while parsing formdef ?
    IF(ObjectExists(targetformapplytester))
    {
      RECORD targetformsettings := targetformapplytester->GetPluginConfiguration("http://www.webhare.net/xmlns/publisher/siteprofile","formintegration");
      IF(RecordExists(targetformsettings) AND targetformsettings.webtoolformhooks != "")
      {
        RECORD save__passthrough := __passthrough;
        TRY
        {
          __passthrough := [ form := this ];
          this->directhookobject := MakeObject(targetformsettings.webtoolformhooks);

          IF(NOT (this->directhookobject EXTENDSFROM WebtoolFormHooks))
            THROW NEW Exception(`Object '${targetformsettings.webtoolformhooks}' should derive from WebtoolFormHooks`);
        }
        FINALLY
        {
          __passthrough := save__passthrough;
        }
      }
    }
  }

  //get either explicit or page hook object
  OBJECT FUNCTION GetHookobject()
  {
    IF(ObjectExists(this->directhookobject))
      RETURN this->directhookobject;

    //we can't set this in NEW(), because pageobject might be set yet there
    IF(MemberExists(this->formcontext, "pageobject") AND MemberExists(this->formcontext->pageobject, "__is_newstyle_pagebase"))
      RETURN this->formcontext->pageobject;

    RETURN DEFAULT OBJECT;
  }

  ///Returns true if the form is normally available
  PUBLIC BOOLEAN FUNCTION IsAvailable()
  {
    RETURN NOT RecordExists(this->unavailabletext);
  }

  // Let form handlers prefill the form fields before returning the witty date to print
  UPDATE PUBLIC RECORD FUNCTION GetWittyData()
  {
    FOREVERY (RECORD handler FROM this->formhandlers)
      IF(ObjectExists(handler.handlerobject))
        handler.handlerobject->PrepareRendering();

    RETURN FormBase::GetWittyData();
  }

  // Request a form handler object
  PUBLIC OBJECT ARRAY FUNCTION GetHandlers(STRING handlertype)
  {
    IF(handlertype NOT LIKE "*#*")
      handlertype := "http://www.webhare.net/xmlns/publisher/forms#" || handlertype;

    OBJECT ARRAY results;
    FOREVERY(RECORD handler FROM this->formhandlers)
      IF(handler.handlertype = handlertype)
        INSERT handler.handlerobject INTO results AT END;

    RETURN results;
  }

  // Are we editing?
  UPDATE PUBLIC BOOLEAN FUNCTION IsEditing()
  {
    RETURN this->pvt_editguid != "";
  }

  // Let form handlers validate the form after the default validation is already done
  UPDATE PUBLIC MACRO __FormValidateHooks(OBJECT workobj)
  {
    FOREVERY (RECORD handler FROM this->formhandlers)
      handler.handlerobject->ValidateForm(workobj);

    OBJECT hookobject := this->GetHookobject();
    IF (ObjectExists(hookobject))
      hookobject->Validate(workobj);
  }

  //Retrieve GUID but add some boobytraps against incorrect use
  PUBLIC STRING FUNCTION GetResultGuid()
  {
    IF(this->pvt_resultguid="")
      THROW NEW Exception("The result guid isn't available until submission has started");
    this->pvt_retrievedguid := TRUE;
    RETURN this->pvt_resultguid;
  }

  /** Set up the ID field and deduplicate existing submisisons if needed
      @param idvalue ID value to use (eg an email address or WRD GUID)
      @cell options.overwriteexisting If true, this submission replaces an earlier submission by this id (if EditExistingResult was not already invoked) */
  PUBLIC MACRO SetIDField(STRING idvalue, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ overwriteexisting := FALSE ], options);
    IF(this->pvt_retrievedguid AND options.overwriteexisting)
      THROW NEW Exception("Overwrite mode cannot be set once the result guid has been retrieved");

    this->pvt_idfieldvalue := idvalue;

    IF(this->pvt_editguid = "" AND options.overwriteexisting AND idvalue != "")
    {
      //Have we got an earlier submission?
      RECORD existingresult := SELECT guid
                                 FROM publisher.formresults
                                WHERE formresults.form_fsobject = this->__form.webtoolformid
                                      AND formresults.idfield = VAR idvalue
                                      AND formresults.status = 1;

      IF(RecordExists(existingresult))
      {
        this->pvt_editguid := existingresult.guid;
        this->pvt_resultguid := existingresult.guid;
      }
    }
  }

  /** List the current form handlers */
  PUBLIC RECORD ARRAY FUNCTION ListHandlers()
  {
    RETURN SELECT guid, handlertype, handlerobject FROM this->formhandlers;
  }

  /** Delete a handler by GUID. This will delete it for the current submission
      (if run in the submit handler) but not from the actual form file */
  PUBLIC MACRO DeleteHandlerByGUID(STRING guid)
  {
    INTEGER tokill := SELECT AS INTEGER #formhandlers + 1 FROM this->formhandlers WHERE formhandlers.guid = VAR guid;
    IF(tokill = 0)
      THROW NEW Exception(`No handler with guid '${guid}'`);
    DELETE FROM this->formhandlers WHERE formhandlers.guid = VAR guid;
  }

  // Let the form handlers process the form results after submission
  RECORD FUNCTION Submit(RECORD extradata)
  {
    IF(NOT this->IsAvailable())
      THROW NEW Exception("This form is currently unavailable");

    STRING mutexname := "publisher:form-" || this->__form.webtoolformid; //we use the lock to dedupe submissions
    OBJECT work := this->BeginWork( [ mutex := mutexname ] );

    this->pvt_resultguid := this->pvt_editguid ?? GenerateUFS128BitId();

    // If the validation hasn't failed, run the WebtoolFormPage submit handler
    RECORD result;
    IF (NOT work->HasFailed())
    {
      OBJECT hookobject := this->GetHookobject();
      IF (ObjectExists(hookobject))
        result := hookobject->Submit(work, extradata);
    }

    RECORD ARRAY activehandlers := SELECT * FROM this->formhandlers WHERE this->MatchFormCondition(condition, DEFAULT RECORD).success;

    // Run the e-mail confirmation task first
    RECORD confirmationhandler := SELECT * FROM activehandlers WHERE handlerobject->IsConfirmationHandler();
    DELETE FROM activehandlers WHERE handlerobject->IsConfirmationHandler();
    IF (RecordExists(confirmationhandler))
    {
      IF (NOT work->HasFailed())
      {
        confirmationhandler.handlerobject->PrepareSubmit(work);

        IF (this->formsubmittype = "new")
        {
          this->formsubmittype := "pending";

          IF (NOT work->HasFailed())
          {
            IF(confirmationhandler.handlertask != "")
              ScheduleManagedTask(confirmationhandler.handlertask,
                                  CELL[ formid := this->__form.webtoolformid
                                      , formname := this->__form.name
                                      , formhandler := confirmationhandler.guid
                                      , resultsguid := this->pvt_resultguid
                                      , submittype := this->formsubmittype
                                      ],
                                  [ auxdata := CELL[ extradata ] ]);
          }
        }
        ELSE IF (this->formsubmittype IN [ "confirm", "duplicate" ])
        {
          FOREVERY(RECORD page FROM this->__formpages)
          {
            IF(page.role = "thankyou") //first non normal page
              BREAK;
            //hide everything up to the first thankyou page.
            page.obj->visible := FALSE;
          }
        }
      }
    }

    // If the WebtoolFormPage submit handler hasn't failed and this isn't a duplicate submission, run the store results handler
    IF (NOT work->HasFailed() AND this->formsubmittype != "duplicate")
    {
      RECORD options := [ idfieldvalue := this->pvt_idfieldvalue
                        , guid := this->pvt_resultguid
                        , isedit := this->pvt_editguid != ""
                        , ispending := this->formsubmittype = "pending"
                        , isconfirm := this->formsubmittype = "confirm"
                        ];

      // The store handler is processed inline
      RECORD submitresult := this->storehandlerobject->Submit(this, extradata, options);
      this->__HandleWorkResult(submitresult.errors, submitresult.warnings);
    }

    IF (this->formsubmittype NOT IN [ "pending", "duplicate" ])// don't run handlers for pending or duplicate submissions
    {
      // Run post submission handlers which may still fail work, but get a chance now that we've stored the primary settings
      FOREVERY (RECORD handler FROM activehandlers)
        IF(NOT work->HasFailed())
          handler.handlerobject->PrepareSubmit(work);

      // If the store handler hasn't failed, schedule a task for each handler
      IF (NOT work->HasFailed())
      {
        FOREVERY (RECORD handler FROM activehandlers)
        {
          IF(handler.handlertask != "" AND handler.handlerobject->IsSubmitHandler())
            ScheduleManagedTask(handler.handlertask, CELL[ formid := this->__form.webtoolformid
                                                         , formname := this->__form.name
                                                         , formhandler := handler.guid
                                                         , resultsguid := this->pvt_resultguid
                                                         , submittype := this->formsubmittype
                                                         ],
                                                         [ auxdata := CELL[ extradata ] ]);
        }
      }
    }

    // Submission was successful if there are no errors
    BOOLEAN success := work->Finish();
    IF (NOT success)
      RETURN DEFAULT RECORD;

    result := CELL[ ...result
                  , resultsguid := this->pvt_resultguid
                  , submittype := this->formsubmittype
                  ];

    IF (this->formsubmittype NOT IN [ "pending", "duplicate" ])
    {
      //NOW aftersubmit handlers can do their thing
      FOREVERY (RECORD handler FROM activehandlers)
        result := handler.handlerobject->UpdateResultAfterSubmit(result);
      IF (RecordExists(confirmationhandler))
        result := confirmationhandler.handlerobject->UpdateResultAfterSubmit(result);
    }

    // Merge result fields into result page RTD's
    INSERT CELL richvalues := this->MergeThankYouPageRTDFields() INTO result;

    // If this is a confirmation or a duplicate submission, the form is opened on the thankyou page, without being submitted,
    // so we'll pre-render the RTD contents, filling the merge fields before rendering the form
    IF (this->formsubmittype IN [ "confirm", "duplicate" ])
    {
      FOREVERY (RECORD richvalue FROM result.richvalues)
      {
        RECORD field := SELECT * FROM this->__formfields WHERE ToUppercase(name) = ToUppercase(richvalue.field);
        IF (RecordExists(field))
          field.obj->__renderedmergefields := richvalue.value;
      }
    }

    RETURN result;
  }

  PUBLIC RECORD ARRAY FUNCTION __GetOriginalFields()
  {
    RECORD ARRAY fields;
    FOREVERY(RECORD page FROM this->__form.pages)
      fields := fields CONCAT page.fields;
    RETURN fields;
  }

  PUBLIC MACRO PTR FUNCTION GetFormBody()
  {
    RETURN PTR this->RenderForm();
  }

  // Cancel an earlier submission
  PUBLIC MACRO CancelExistingResult(STRING resultsguid)
  {
    this->formresults->CancelResult(resultsguid);
    this->formvariables := CELL[...this->formvariables, formsubmittype := "cancel" ];
    this->formsubmittype := "cancel";

    FOREVERY(RECORD page FROM this->__formpages)
    {
      IF(page.role = "thankyou") //first non normal page
        BREAK;
      //hide everything up to the first thankyou page.
      page.obj->visible := FALSE;
    }

    FOREVERY (RECORD handler FROM this->formhandlers)
    {
      IF(handler.handlertask != "" AND handler.handlerobject->IsCancelHandler() AND this->MatchFormCondition(handler.condition, DEFAULT RECORD).success)
      {
        ScheduleManagedTask(handler.handlertask, CELL[ formid := this->__form.webtoolformid
                                                     , formname := this->__form.name
                                                     , formhandler := handler.guid
                                                     , resultsguid
                                                     , submittype := "cancel"
                                                     ]);

      }
    }
  }

  PUBLIC BOOLEAN FUNCTION EditExistingResult(STRING resultsguid)
  {
    IF(NOT this->PrefillWithResults(resultsguid))
      RETURN FALSE;

    this->formvariables := CELL[...this->formvariables, formsubmittype := "change" ];
    this->pvt_editguid := resultsguid;
    this->formsubmittype := "change";
    RETURN TRUE;
  }

  PUBLIC BOOLEAN FUNCTION PrefillWithResults(STRING resultsguid)
  {
    RECORD results := this->formresults->GetSingleResult(resultsguid, [__form := this]);
    IF (NOT RecordExists(results))
      RETURN FALSE;

//    this->PrefillWithSingleResult(results); //FIXME the above GetSingleResult already loaded into us, so I don't think we need this anymore...
    RETURN TRUE;
  }

  PUBLIC BOOLEAN FUNCTION __MaybeConfirmResult()
  {
    STRING confirm := GetFormWebVariable("confirm");
    IF (confirm = "")
      RETURN TRUE;

    RECORD confirmdata;
    TRY
      confirmdata := ValidateOptions(
          [ r := "" // result guid
          , h := "" // handler guid
          ], DecodeHSON(DecryptForThisServer("publisher:confirmation", confirm)));
    CATCH;
    IF (NOT RecordExists(confirmdata))
      RETURN FALSE;

    RECORD confirmationhandler := SELECT * FROM this->formhandlers WHERE guid = confirmdata.h;
    IF (NOT RecordExists(confirmationhandler) OR NOT confirmationhandler.handlerobject->IsConfirmationHandler())
      RETURN TRUE;

    RECORD results := this->formresults->GetSingleResult(confirmdata.r, [ __form := this, allowpending := TRUE ]);
    IF (NOT RecordExists(results) OR results.status != "pending")
      RETURN FALSE;

    IF (results.submittype = "new" AND confirmationhandler.handlerobject->IsDuplicateSubmission(results, this->formresults))
    {
      this->formvariables := CELL[...this->formvariables, formsubmittype := "duplicate" ];
      this->pvt_editguid := confirmdata.r;
      this->formsubmittype := "duplicate";
    }
    ELSE
    {
      this->formvariables := CELL[...this->formvariables, formsubmittype := "confirm" ];
      this->pvt_editguid := confirmdata.r;
      this->formsubmittype := "confirm";
    }

    // The captcha field is not required when the confirmation link is used
    IF (ObjectExists(this->captchaquestion))
      this->captchaquestion->required := FALSE;

    this->__SubmitFormNow();

    RETURN TRUE;
  }

  OBJECT FUNCTION GetFormResults()
  {
    IF (NOT ObjectExists(this->pvt_results))
    {
      //RECORD ARRAY fields := this->ListFields();
      OBJECT whfsobject := OpenWHFSObject(this->__form.webtoolformid);
      this->pvt_results := OpenFormFileResults(whfsobject);
    }
    RETURN this->pvt_results;
  }

  RECORD ARRAY FUNCTION MergeThankYouPageRTDFields()
  {
    RECORD ARRAY richvalues;
    IF (MemberExists(this->formcontext, "__mergefields"))
    {
      OBJECT formdefinition := OpenFormFileDefinition(OpenWHFSObject(this->__form.webtoolformid), [ formname := this->__form.name ]);
      RECORD mergedata := this->GetWittyResultData();
      OBJECT mergefields := NEW MergeFieldsContext([ type := "formdef", formdef := formdefinition, data := mergedata ], this->formlanguagecode);

      OBJECT oldmergefields := this->formcontext->__mergefields;
      this->formcontext->__mergefields := mergefields;

      OBJECT webdesign;
      FOREVERY (RECORD page FROM SELECT * FROM this->__form.pages WHERE role = "thankyou")
      {
        FOREVERY (RECORD field FROM SELECT * FROM page.fields WHERE qname = "http://www.webhare.net/xmlns/publisher/forms#richtext" AND mayhavemergefields)
        {
          OBJECT fieldobj := GetMember(this, "^" || field.name);
          IF (fieldobj->IsNowVisible())
          {
            IF(NOT ObjectExists(webdesign)) //TODO: avoid opening full webdesign if possible. perhaps if there are no witty fields or no embedded objects ?
            {
              RECORD webdesigninfo := this->formcontext->targetapplytester->GetWebDesignObjinfo();
              webdesign := InstantiateWebDesign(this->formcontext->targetapplytester, webdesigninfo, 0, DEFAULT OBJECT, DEFAULT OBJECT, FALSE);
              webdesign->__mergefields := this->formcontext->__mergefields;
            }

            BLOB richcontent := GetPrintedAsBlob(PTR webdesign->CallWithScope(PTR webdesign->RenderRTD(field.richvalue.data)));
            INSERT [ field := field.name, value := BlobToString(richcontent) ] INTO richvalues AT END;
          }
        }
      }
      this->formcontext->__mergefields := oldmergefields;
    }
    RETURN richvalues;
  }
>;

