<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";

RECORD basebundleconfig := [ extrarequires := DEFAULT STRING ARRAY
                           , languages := DEFAULT STRING ARRAY
                           , whpolyfills := TRUE
                           , environment := "window"
                           , aftercompiletask := ""
                           , compatibility := whconstant_default_compatibility
                           , esbuildsettings := ""
                           , basecompiletoken := "adhoc" //adhoc bundles have no real configuration, so don't bother with forced recompilation (well perhaps default_compatibility?)
                           ];

PUBLIC STRING FUNCTION GetBundleOutputRootPath()
{
  RETURN GetEnvironmentVariable("WEBHARE_DATAROOT") || 'generated/platform/ap/';
}

PUBLIC STRING FUNCTION GetBundleOutputPath(STRING outputtag)
{
  IF(outputtag LIKE "platform:*")
    RETURN GetModuleInstallationRoot("platform") || '/generated/ap/' || Substitute(outputtag,':','.') || "/";

  RETURN GetEnvironmentVariable("WEBHARE_DATAROOT") || 'generated/platform/ap/' || Substitute(outputtag,':','.') || "/";
}

PUBLIC DATETIME FUNCTION GetBundleLastModDate(STRING outputtag)
{
  RECORD diskres := GetDiskFileProperties(GetBundleOutputPath(outputtag) || "assetpackstate.hson");
  RETURN RecordExists(diskres) ? diskres.modified : DEFAULT DATETIME;
}

PUBLIC RECORD FUNCTION WaitForCompiledAssetpack(STRING outputtag)
{
  IF(outputtag = "")
    THROW NEW Exception("Invalid asset pack name");

  OBJECT service := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  RECORD res := WaitForPromise(service->WaitForCompile(outputtag, FALSE));
  service->CloseService();
  RETURN res;
}

PUBLIC MACRO RemoveObsoleteCacheFolders()
{
  OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  RECORD status := WaitForPromise(assetpackcontrol->GetStatus());
  STRING ARRAY keeppackages := SELECT AS STRING ARRAY outputtag FROM status.bundles;
  STRING ARRAY validfolders := keeppackages CONCAT SELECT AS STRING ARRAY outputtag FROM system_internal.assetpacks;
  validfolders := SELECT AS STRING ARRAY Substitute(val,":",'.') FROM ToRecordArray(validfolders,'val');

  RECORD ARRAY currentfolders := ReadDiskDirectory(GetBundleOutputRootPath(), "*");
  FOREVERY(RECORD folder FROM currentfolders)
  {
    IF(folder.name LIKE "platform.*" OR folder.name NOT IN validfolders)
    {
      LogInfo("publisher:assetpackcontrol", "Deleting obsolete assetpack " || folder.name, [ type := "publisher:deleteassetpack", name := folder.name ]);
      DeleteDiskDirectoryRecursive(folder.path);
    }
  }
}

PUBLIC RECORD ARRAY FUNCTION GetPersistentBundles()
{
  //do not return bundles from uninstalled modules. scheduled compilations will fail and may race against (re)installation of modules
  RECORD ARRAY dbbundles :=
     SELECT TEMPORARY parsedsettings :=       ParseAssetPackSettings(assetpacks.outputtag, assetpacks.settings)
          , *
          , bundleconfig :=   bundleconfig != "" ? DecodeHSON(bundleconfig) : DEFAULT RECORD
          , savedstate :=     DEFAULT RECORD
          , origentrypoint := entrypoint
          , isdev :=          parsedsettings.dev
       FROM system_internal.assetpacks
      WHERE (outputtag LIKE "*:*" ? IsModuleInstalled(Tokenize(outputtag,':')[0]) : TRUE);

  // Prefer core packs first, then the rest. The check order is order in which recompiles are scheduled.
  dbbundles := SELECT * FROM dbbundles ORDER BY outputtag LIKE "platform:*" DESC;

  RETURN dbbundles;
}
PUBLIC RECORD FUNCTION PreFixupBundleconfig(RECORD bundle)
{
  bundle.bundleconfig := CELL[ ...basebundleconfig, ...bundle.bundleconfig];

  //ADDME: Direct extrarequires is legacy, remove
  IF (CellExists(bundle, "EXTRAREQUIRES") AND bundle.extrarequires != "")
  {
    bundle.bundleconfig.extrarequires := Tokenize(bundle.extrarequires, "\t");
    DELETE CELL extrarequires FROM bundle;
  }

  RETURN bundle;
}

PUBLIC RECORD FUNCTION GetBundle(STRING byoutputtag)
{
  RECORD bundle := SELECT * FROM GetPersistentBundles() WHERE outputtag = VAR byoutputtag;
  IF(NOT RecordExists(bundle))
    THROW NEW Exception(`No such bundle ${byoutputtag} registered`);

  bundle := PreFixupBundleconfig(bundle);
  INSERT CELL outputpath := GetBundleOutputPath(bundle.outputtag) INTO bundle;

  RETURN bundle;
}

PUBLIC RECORD FUNCTION ParseAssetPackSettings(STRING outputtag, STRING insettings)
{
  RECORD settings;
  IF(insettings != "")
    settings := DecodeHSON(insettings);

  RETURN EnforceStructure([ dev := GetDtapStage() = "development" AND outputtag NOT LIKE "platform:*" ], settings);
}
PUBLIC RECORD FUNCTION GetAssetPackSettings(INTEGER assetpackid)
{
  STRING outputtag := SELECT AS STRING COLUMN outputtag  FROM system_internal.assetpacks WHERE id = VAR assetpackid;
  RETURN ParseAssetPackSettings(outputtag, SELECT AS STRING assetpacks.settings FROM system_internal.assetpacks WHERE id = VAR assetpackid);
}

PUBLIC MACRO UpdateAssetPackSettings(INTEGER assetpackid, RECORD newsettings)
{
  STRING uuid := SELECT AS STRING outputtag FROM system_internal.assetpacks WHERE id = assetpackid;
  RECORD settings := ParseAssetPackSettings(uuid, SELECT AS STRING assetpacks.settings FROM system_internal.assetpacks WHERE id = assetpackid);
  settings := CELL[ ...settings
                  , ...ValidateOptions([ dev := FALSE ], newsettings, [ title := "Assetpack settings", optional := ["*"]])
                  ];
  UPDATE system_internal.assetpacks SET settings := EncodeHSON(VAR settings) WHERE id = assetpackid;
  GetPrimary()->BroadcastOnCommit("publisher:assetpackcontrol.settings." || uuid, DEFAULT RECORD);
}
