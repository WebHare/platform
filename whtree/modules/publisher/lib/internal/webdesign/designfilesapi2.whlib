<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";

RECORD basebundleconfig := [ extrarequires := DEFAULT STRING ARRAY
                           , languages := DEFAULT STRING ARRAY
                           , webharepolyfills := TRUE
                           , environment := "window"
                           , aftercompiletask := ""
                           , compatibility := whconstant_default_compatibility
                           , esbuildsettings := ""
                           ];

PUBLIC STRING FUNCTION GetBundleOutputPath(STRING outputtag)
{
  RETURN GetWebHareConfiguration().varroot || 'publisher.ap/' || Substitute(outputtag,':','.') || "/";
}

PUBLIC DATETIME FUNCTION GetBundleLastModDate(STRING outputtag)
{
  RECORD diskres := GetDiskFileProperties(GetWebHareConfiguration().varroot || 'publisher.ap/' || Substitute(outputtag,':','.') || "/assetpackstate.hson");
  RETURN RecordExists(diskres) ? diskres.modified : DEFAULT DATETIME;
}

PUBLIC RECORD FUNCTION WaitForCompiledAssetpack(STRING outputtag)
{
  IF(outputtag = "")
    THROW NEW Exception("Invalid asset pack name");

  OBJECT service := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  RECORD res := WaitForPromise(service->WaitForCompile(outputtag, FALSE));
  service->CloseService();
  RETURN res;
}

PUBLIC RECORD FUNCTION MakeEmptyBundle()
{
  RETURN [ assetpack := ""
         , basedependency := ""
         , bundleconfig := basebundleconfig
         , adhoc := FALSE
         ];
}

PUBLIC STRING FUNCTION GetHashForBundle(RECORD requesteddesign)
{
  RECORD hashbase := [ basedependency := requesteddesign.basedependency
                     , extrarequires := (SELECT AS STRING ARRAY DISTINCT req FROM ToRecordArray(requesteddesign.bundleconfig.extrarequires,"req") ORDER BY req)
                     , languages := (SELECT AS STRING ARRAY DISTINCT lang FROM ToRecordArray(requesteddesign.bundleconfig.languages,"lang") ORDER BY lang)
                     , environment := requesteddesign.bundleconfig.environment
                     , aftercompiletask := requesteddesign.bundleconfig.aftercompiletask //making this part of the hash so we refire the task if it changes
                     , esbuildsettings := requesteddesign.bundleconfig.esbuildsettings
                     ];
  STRING designhash := ToLowercase(EncodeUFS(GetMD5Hash(EncodeHSON(hashbase))));
  RETURN designhash;
}

PUBLIC MACRO RemoveObsoleteCacheFolders()
{
  OBJECT assetpackcontrol := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
  RECORD status := WaitForPromise(assetpackcontrol->GetStatus());
  STRING ARRAY keeppackages := SELECT AS STRING ARRAY outputtag FROM status.bundles;
  STRING ARRAY validfolders := keeppackages CONCAT SELECT AS STRING ARRAY outputtag FROM system_internal.assetpacks;
  validfolders := SELECT AS STRING ARRAY Substitute(val,":",'.') FROM ToRecordArray(validfolders,'val');

  RECORD ARRAY currentfolders := ReadDiskDirectory(GetWebHareConfiguration().varroot || "publisher.ap", "*");
  FOREVERY(RECORD folder FROM currentfolders)
  {
    IF(folder.name NOT IN validfolders)
    {
      LogInfo("publisher:assetpackcontrol", "Deleting obsolete assetpack " || folder.name, [ type := "publisher:deleteassetpack", name := folder.name ]);
      DeleteDiskDirectoryRecursive(folder.path);
    }
  }
}

/** @short Call a function, and retry it if the connection failed */
VARIANT FUNCTION CallAndRetryOnConnectionFailure(FUNCTION PTR fptr)
{
  TRY
  {
    RETURN fptr();
  }
  CATCH(OBJECT<ServiceDisconnectException> e)
  {
    RETURN fptr();
  }
}

PUBLIC RECORD FUNCTION GetPackingInfo(RECORD requestedbundle)
{
  TRY
  {
    OBJECT service := WaitForPromise(OpenWebHareService("publisher:assetpackcontrol"));
    RECORD bundle := WaitForPromise(service->GetBundle(requestedbundle, [ nowait := FALSE ]));
    service->CloseService();
    INSERT CELL stale := FALSE INTO bundle;
    RETURN [ ttl := 15 * 60 * 1000
           , value := bundle
           , eventmasks := [ "publisher:assetpackcontrol.change.all"
                           , "publisher:assetpackcontrol.change." || bundle.outputtag
                           ]
           ];
  }
  CATCH(OBJECT< ServiceUnavailableException > e)
  {
    //Do we have the bundle in the database ?
    STRING hash := GetHashForBundle(requestedbundle);
    RECORD bundleinfo := SELECT * FROM system_internal.assetpacks WHERE outputtag = hash;
    IF(NOT RecordExists(bundleinfo))
      THROW NEW Exception("The assetpackmgr is unreachable and the bundle does not yet exist");

    STRING bundleuuid := bundleinfo.outputtag;
    RETURN [ ttl := 1 * 60 * 1000
           , value := [ id := bundleinfo.id
                      , outputtag := bundleuuid
                      , stale := TRUE
                      ]
           , eventmasks := [ "publisher:assetpackcontrol.change.all"
                           , "publisher:assetpackcontrol.change." || bundleuuid
                           ]
           ];
  }
}


STATIC OBJECTTYPE Resolver
<
  RECORD packinginfo;
  STRING ARRAY addedrequires;
  RECORD requestedbundle;
  STRING assetpack;

  MACRO NEW(STRING assetpack, STRING basedependency, STRING ARRAY languages)
  {
    BOOLEAN adhoc := assetpack NOT LIKE "*:*"; //adhocs are just a 128bit id

    this->assetpack := assetpack;
    IF(assetpack = "" AND basedependency != "")
    {
      this->requestedbundle := MakeEmptyBundle();
      this->requestedbundle.basedependency := basedependency;
      this->requestedbundle.adhoc := adhoc;
      this->requestedbundle.bundleconfig.languages := languages;
    }
  }

  MACRO EnsurePackingInfo()
  {
    IF(RecordExists(this->packinginfo))
      RETURN;

    IF(this->assetpack = "" AND RecordExists(this->requestedbundle))
    {
      RECORD torequest := this->requestedbundle;
      torequest.bundleconfig.extrarequires := SELECT AS STRING ARRAY DISTINCT req FROM ToRecordArray(torequest.bundleconfig.extrarequires,'req') ORDER BY req;

      STRING designhash := GetHashForBundle(this->requestedbundle);
      FUNCTION PTR getter := /*PTR CallAndRetryOnConnectionFailure*/(PTR GetPackingInfo(this->requestedbundle));
      IF(torequest.adhoc)
        this->packinginfo := getter().value;
      ELSE
        this->packinginfo := GetAdhocCached([ designhash := designhash], getter);

      INSERT CELL designhash := designhash INTO this->packinginfo;
      this->assetpack := this->packinginfo.designhash;
    }
  }

  PUBLIC MACRO PrintHeaders(OBJECT webdesign, STRING usedesignroot, STRING cachebuster DEFAULTSTO "")
  {
    this->EnsurePackingInfo();
    Print(GetAssetpackIntegrationCode(this->assetpack, CELL
      [ designroot := usedesignroot
      , cachebuster
      ]));

    IF(NOT ObjectExists(webdesign) OR webdesign->wittyencoding NOT LIKE "*-NI")
      Print('\n');
  }
>;

PUBLIC OBJECT FUNCTION CreateDependencyResolverForModuleDesign(RECORD webdesigninfo)
{
  IF(webdesigninfo.designfolder="")
    THROW NEW Exception("No module design folder specified");

  OBJECT res := NEW Resolver(webdesigninfo.assetpack, "", webdesigninfo.supportedlanguages);
  RETURN res;
}

PUBLIC OBJECT FUNCTION CreateDependencyResolverForJSFile(STRING jspath, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ supportedlanguages := STRING[]
      ], options);

  OBJECT res := NEW Resolver("", jspath, options.supportedlanguages);
  RETURN res;
}

/// Returns the outputtag for the URL-name of an assetpack
PUBLIC STRING FUNCTION UnmapBundleUuid(STRING inuuid)
{
  IF(inuuid LIKE "*.*")
  {
    INTEGER dotpos := SearchSubstring(inuuid, '.');
    inuuid := Left(inuuid, dotpos) || ':' || Substring(inuuid, dotpos + 1);
  }
  RETURN inuuid;
}

PUBLIC RECORD ARRAY FUNCTION GetPersistentBundles()
{
  //do not return bundles from uninstalled modules. scheduled compilations will fail and may race against (re)installation of modules
  RECORD ARRAY dbbundles :=
     SELECT TEMPORARY parsedsettings :=       ParseAssetPackSettings(assetpacks.outputtag, assetpacks.settings)
          , *
          , bundleconfig :=   bundleconfig != "" ? DecodeHSON(bundleconfig) : DEFAULT RECORD
          , adhoc :=          FALSE
          , savedstate :=     DEFAULT RECORD
          , origentrypoint := entrypoint
          , isdev :=          parsedsettings.dev
       FROM system_internal.assetpacks
      WHERE (outputtag LIKE "*:*" ? IsModuleInstalled(Tokenize(outputtag,':')[0]) : TRUE);

  // Prefer tollium first, then the rest. The check order is order in which recompiles are scheduled.
   dbbundles := SELECT * FROM dbbundles
                     ORDER BY outputtag LIKE "tollium:*" DESC;

  RETURN dbbundles;
}
PUBLIC RECORD FUNCTION PreFixupBundleconfig(RECORD bundle)
{
  bundle.bundleconfig := CELL[ ...basebundleconfig, ...bundle.bundleconfig];

  //ADDME: Direct extrarequires is legacy, remove
  IF (CellExists(bundle, "EXTRAREQUIRES") AND bundle.extrarequires != "")
  {
    bundle.bundleconfig.extrarequires := Tokenize(bundle.extrarequires, "\t");
    DELETE CELL extrarequires FROM bundle;
  }

  BOOLEAN fullsourcemap := NOT bundle.isdev;
  INSERT CELL fullsourcemap := fullsourcemap INTO bundle.bundleconfig;

  RETURN bundle;
}

PUBLIC RECORD FUNCTION GetBundle(STRING byoutputtag)
{
  OpenPrimary();
  RECORD bundle := SELECT * FROM GetPersistentBundles() WHERE outputtag = VAR byoutputtag;
  IF(NOT RecordExists(bundle))
    THROW NEW Exception(`No such bundle ${byoutputtag} registered`);

  bundle := PreFixupBundleconfig(bundle);
  INSERT CELL outputpath := GetBundleOutputPath(bundle.outputtag) INTO bundle;

  RETURN bundle;
}

PUBLIC RECORD FUNCTION ParseAssetPackSettings(STRING outputtag, STRING insettings)
{
  RECORD settings;
  IF(insettings != "")
    settings := DecodeHSON(insettings);

  RETURN EnforceStructure([ dev := GetDtapStage() = "development" AND outputtag NOT LIKE "tollium:*" ], settings);
}
PUBLIC RECORD FUNCTION GetAssetPackSettings(INTEGER assetpackid)
{
  STRING outputtag := SELECT AS STRING COLUMN outputtag  FROM system_internal.assetpacks WHERE id = VAR assetpackid;
  RETURN ParseAssetPackSettings(outputtag, SELECT AS STRING assetpacks.settings FROM system_internal.assetpacks WHERE id = VAR assetpackid);
}

PUBLIC MACRO UpdateAssetPackSettings(INTEGER assetpackid, RECORD newsettings)
{
  STRING uuid := SELECT AS STRING outputtag FROM system_internal.assetpacks WHERE id = assetpackid;
  RECORD settings := ParseAssetPackSettings(uuid, SELECT AS STRING assetpacks.settings FROM system_internal.assetpacks WHERE id = assetpackid);
  settings := CELL[ ...settings
                  , ...ValidateOptions([ dev := FALSE ], newsettings, [ title := "Assetpack settings", optional := ["*"]])
                  ];
  UPDATE system_internal.assetpacks SET settings := EncodeHSON(VAR settings) WHERE id = assetpackid;
  GetPrimary()->BroadcastOnCommit("publisher:assetpackcontrol.settings." || uuid, DEFAULT RECORD);
}
