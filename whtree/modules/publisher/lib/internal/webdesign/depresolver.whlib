<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internal/graphs.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::publisher/lib/internal/blit/api.whlib";
LOADLIB "mod::publisher/lib/internal/webdesign/support.whlib";

LOADLIB "mod::publisher/lib/database.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/resources.whlib";


INTEGER globalversion := 4; //update this whenever we improve/fix the compilation process, to ensure new keys

PUBLIC STATIC OBJECTTYPE DepResolver
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  INTEGER fsobjectid;
  INTEGER designfolder;
  RECORD ARRAY adduses;
  STRING ARRAY addusegrids; //ADDME actually allow setting this
  RECORD ARRAY addloads;
  STRING ARRAY flags;
  STRING basefile;
  STRING relativelinksscope;

  INTEGER outputmode_js;
  INTEGER outputmode_css;


  RECORD ARRAY repositories;
  PUBLIC STRING designroot;

  // ---------------------------------------------------------------------------
  //
  // Public variables
  //

  PUBLIC RECORD ARRAY includes;
  PUBLIC INTEGER ARRAY sourcefolders;
  PUBLIC STRING ARRAY sourceeventmasks;
  PUBLIC RECORD ARRAY packagelisting;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  /** Construct a new dependency handler
      @param fsobjectid
      @param basefile
      @param outouttype
      @param adduses
      @param addloads
      @param repositories
      @param flags
  */
  MACRO NEW(INTEGER fsobjectid, STRING basefile, RECORD ARRAY addrepositories)
  {
    this->basefile := basefile;
    OBJECT depslocaltype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/localdesignsettings");

    IF(fsobjectid != 0)
    {
      RECORD designconfig := LocateDesignConfig(OpenWHFSObject(fsobjectid));
      this->fsobjectid := fsobjectid;
      this->designfolder := designconfig.folder->id;
      this->designroot := designconfig.folder->url;

      IF(basefile != "--none--") //this is a hack to prevent any initial designfiles from loading
      {
        RECORD siteresult := basefile = "" ? GetClassicSiteFiles(this->designfolder) : GetSiteFile(this->designfolder, basefile, 1);
        this->includes := siteresult.includes;
      }
    }

    // Make sure we have data of all the needed versions of repositories
    this->InitRepositories(addrepositories);
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING FUNCTION RewriteLocalAssetURL(RECORD repo, STRING url)
  {
    IF (CellExists(repo, "REWRITEROOT") AND repo.rewriteroot != "")
      url := repo.rewriteroot || SubString(url, LENGTH(repo.root->url));
    RETURN url;
  }

  MACRO InitRepositories(RECORD ARRAY addrepositories)
  {
    //Ensure we have the required dependencies
    RECORD ARRAY repositories;
    BOOLEAN changedversion;

    IF(this->designfolder != 0)
    {
      OBJECT depstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfolder");
      OBJECT depslocaltype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/localdesignsettings");

      RECORD currentdeps := depstype->GetInstanceData(this->designfolder);
      RECORD currentlocaldeps := depslocaltype->GetInstanceData(this->designfolder);

      FOREVERY (RECORD rec FROM currentdeps.repositories)
      {
        INTEGER localfolderid;
        IF(rec.uuid != "")
        {
          localfolderid :=
            SELECT AS INTEGER localversion
              FROM currentlocaldeps.repositories AS localreps
             WHERE localreps.uuid = rec.uuid;
        }

        IF (localfolderid != 0)
        {
          // FIXME: update linked version id?

          INSERT CELL islocal := TRUE INTO rec;
        }
        ELSE
        {
          // Get anonymous connection URL
          STRING server := CalculateRepositoryURL(rec.server, TRUE);

          OBJECT connector := rec.repository = ""
              ? GetRepoConnectorByUUID(server, rec.uuid)
              : GetRepoConnectorByPath(server, "Designfiles/designfiles " || rec.repository);

          IF (rec.version = 0 OR rec.uuid = "")
          {
            RECORD status := connector->GetRepo()->GetStatus();
            rec.uuid := status.repository_uuid;
            IF(rec.version =  0)
              rec.version := status.version;

            currentdeps.repositories[#rec] := rec;
            changedversion := TRUE;
          }
          OBJECT folder := GetCheckoutTree(rec.server, rec.uuid, rec.version, connector);
          localfolderid := folder->id;
          INSERT CELL islocal := FALSE INTO rec;
        }

        INSERT CELL localversion := localfolderid INTO rec;
        INSERT rec INTO repositories AT END;
      }

      IF (changedversion)
      {
        GetPrimary()->PushWork();
        depstype->SetInstanceData(this->designfolder, currentdeps);
        GetPrimary()->PopWork();
      }
    }

    // Make sure the addedrepositories are also checked out
    FOREVERY (RECORD rec FROM addrepositories)
    {
      // If no local version is supplied, check it out.
      IF (rec.localversion = 0)
      {
        STRING server := CalculateRepositoryURL(rec.server, TRUE);

        OBJECT connector := rec.repository = ""
            ? GetRepoConnectorByUUID(server, rec.uuid)
            : GetRepoConnectorByPath(server, "Designfiles/designfiles " || rec.repository);

        RECORD status := connector->GetRepo()->GetStatus();

        OBJECT folder := GetCheckoutTree(rec.server, status.repository_uuid, status.version, connector);
        addrepositories[#rec].localversion := folder->id;
      }
    }

    this->repositories :=
        SELECT *
             , root := OpenWHFSObject(localversion)
          FROM repositories
                CONCAT (SELECT *, islocal := TRUE FROM addrepositories);

  }

  PUBLIC RECORD ARRAY FUNCTION GetRepositories()
  {
    RETURN SELECT server, repository, version := islocal ? 0 : version, localfolder := islocal ? localversion : 0 FROM this->repositories;
  }
  PUBLIC RECORD ARRAY FUNCTION GetRepositoryNameAndVersions()
  {
    RETURN SELECT repository, version := islocal ? 0 : version FROM this->repositories;
  }

  BOOLEAN FUNCTION CheckAssetFlags(STRING flags)
  {
    IF (flags = "")
      RETURN TRUE;
    FOREVERY(STRING checkflag FROM Tokenize(flags," "))
      IF((checkflag LIKE "!*" AND Substring(checkflag,1) IN this->flags)
          OR (checkflag NOT LIKE "!*" AND checkflag NOT IN this->flags))
        RETURN FALSE;
    RETURN TRUE;
  }

  RECORD ARRAY FUNCTION ResolvePackageInclude(STRING packagename, STRING referencedby, STRING url)
  {
    // Moduleroot-compatibility package?
    IF (packagename LIKE "MODULEROOT::*" OR packagename LIKE "MOD::*")
      RETURN [ CreateModuleRootAsset(packagename, url) ];
    // Module package?
    IF (packagename LIKE "*:*")
      RETURN [ CreateModuleAsset(packagename, url) ];

    OBJECT fstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfiles/cachedfolder");
    FOREVERY (RECORD repo FROM this->repositories)
    {
      IF(packagename LIKE "*/*")
        THROW NEW Exception("Package names cannot contain slashes (the LOAD of '" || packagename || "' failed, did you mean 'USE' ?)");

      STRING packagepath := Substitute(packagename, ".", "/");
      OBJECT folder := repo.root->OpenByPath(packagepath);
      IF (NOT ObjectExists(folder) OR NOT folder->isfolder)
        CONTINUE;

      STRING hash := fstype->GetInstanceData(folder->id).hash;
      IF (NOT repo.islocal)
      {
        // Check if the asset folder still exists. Regenerate if not there
        STRING basepath := GetCachedAssetPath(hash, "");
        IF (NOT RecordExists(GetDiskFileProperties(basepath)))
          ForceCacheFolderRebuild(repo.uuid, repo.version, packagepath);
      }

      RECORD ARRAY assets :=
          SELECT assettype :=       "package"
               , id :=              packagename
               , filename :=        name
               , settings :=        GetAssetSettings(description)
               , type :=            name LIKE "*.css"
                                          ? "css"
                                          : name LIKE "*.js"
                                                ? "js"
                                                : "asset"
               , url :=             repo.islocal
                                        ? this->RewriteLocalAssetURL(repo, fs_objects.objecturl)
                                        : "/.publisher/df/" || ToLowercase(hash) || "/" || EncodeURL(name)
               , data
               , moddate :=         modificationdate
               , whfsfolder :=      repo.islocal ? folder->id : 0
               , domid :=           ""
               , round := 0
            FROM system.fs_objects
           WHERE parent = folder->id
             AND NOT isfolder;

      // Delete assets that don't adhere to our flags
      DELETE
        FROM assets
       WHERE NOT this->CheckAssetFlags(settings.flags);

      FOREVERY (RECORD asset FROM assets)
        assets[#asset] := MakeMergedRecord(asset, ExtractHeader(asset.data, TRUE, packagename));

      UPDATE assets SET package := packagename;

      IF (LENGTH(assets) = 0)
        THROW NEW Exception("Package folder '" || packagename || "' referenced by '" || referencedby || "' has no asset files");

      RETURN assets;
    }

    THROW NEW Exception("Cannot locate package '" || packagename || "' referenced by '" || referencedby || "'");
  }

  MACRO EnsureOutputExistence(RECORD hashes, INTEGER outputmode_js, INTEGER outputmode_css)
  {
    //ADDME it should probably be safe to adhoc-cache stuff like this for a long time
    //ADDME perhaps the compileddesigns table should tell us what we exactly need to include css/js wise, so we have less to scan ourselves ?

    DATETIME now := GetCurrentDatetime();
    RECORD compileddesign := SELECT * FROM publisher.compileddesigns WHERE hash = hashes.confighash;
    IF(RecordExists(compileddesign) AND compileddesign.datahash = hashes.datahash)
    {
      IF (compileddesign.lastuse < AddTimeToDate(-60 * 60 * 1000, now))
      {
        // Update lastuse every hour
        UPDATE publisher.compileddesigns SET lastuse := now WHERE id = compileddesign.id;
        GetPrimary()->BroadcastOnCommit("blexdev_designfiles:compileddesigns.update", [ id := compileddesign.id ]);
      }
    }
    ELSE
    {
      this->CreateOutputFiles(hashes.confighash, outputmode_js, outputmode_css);

      IF(NOT RecordExists(compileddesign))
      {
        INTEGER id := MakeAutoNumber(publisher.compileddesigns, "ID");
        INSERT INTO publisher.compileddesigns(id, hash, created, lastuse, designfolder, datahash)
                VALUES(id, hashes.confighash, now, now, this->designfolder, hashes.datahash);

        GetPrimary()->BroadcastOnCommit("blexdev_designfiles:compileddesigns.add", [ id := id ]);
      }
      ELSE
      {
        UPDATE publisher.compileddesigns
               SET lastuse := now
                 , datahash := hashes.datahash
             WHERE id = compileddesign.id;
        GetPrimary()->BroadcastOnCommit("blexdev_designfiles:compileddesigns.update", [ id := compileddesign.id ]);
      }
    }

    STRING baseurl := "/.publisher/cd/" || ToLowercase(hashes.confighash) || "/";

    RECORD ARRAY newincludes;
    IF(RecordExists(SELECT FROM this->includes WHERE type="css") AND outputmode_css != 0)
    {
      INSERT [ moddate := DEFAULT DATETIME, type := "css", media := "", url := baseurl || "wh.css", domid := "wh-designfiles-combined-css" ] INTO newincludes AT END;
    }
    ELSE
      newincludes := newincludes CONCAT SELECT * FROM this->includes WHERE type = "css";

    IF(RecordExists(SELECT FROM this->includes WHERE type="js") AND outputmode_js != 0)
      INSERT [ moddate := DEFAULT DATETIME, type := "js", media := "", url := baseurl || "wh.js", domid := "wh-designfiles-combined-js" ] INTO newincludes AT END;
    ELSE
      newincludes := newincludes CONCAT SELECT * FROM this->includes WHERE type = "js";

    this->includes := newincludes;
  }

  MACRO CreateOutputFiles(STRING hash, INTEGER outputmode_js, INTEGER outputmode_css)
  {
    //Let the fun begin. Generate the output
    STRING diskfinalpath := GetWebHareConfiguration().varroot || "publisher.cd/" || ToLowercase(hash);
    STRING append := ".$$" || GenerateUFS128BitId();

    IF(NOT CreateDiskDirectoryRecursive(diskfinalpath,TRUE))
      THROW NEW Exception("I/O error creating temporary storage for compiled output files");

    RECORD ARRAY outfiles := this->GenerateOutputFiles(outputmode_js, outputmode_css);

    FOREVERY(RECORD outfile FROM outfiles)
      StoreDiskFile(diskfinalpath || "/" || outfile.name || append, outfile.data, [ overwrite := TRUE ]);

    FOREVERY(RECORD outfile FROM outfiles)
      IF(NOT MoveDiskPath(diskfinalpath || "/" || outfile.name || append, diskfinalpath || "/" || outfile.name))
       THROW NEW Exception("I/O error moving final path in place");
  }

  RECORD FUNCTION CalculateHashes(INTEGER outputmode_js, INTEGER outputmode_css)
  {
    /* We need to generate a unique key to refer to these design files which
       should be stable as long as the base files aren't updated
    */
    STRING confighash := EncodeUFS(GetSHA1Hash(EncodeHSON(
                         [ outputmode_js := outputmode_js
                         , outputmode_css := outputmode_css
                         , version := globalversion
                         , relativelinksscope := this->relativelinksscope
                         , designfolder := this->designfolder
                         , adduses := this->adduses
                         , addloads := this->addloads
                         , basefile := this->basefile
                         ])));

    RECORD finalconfig := [ packages := (SELECT moddate, package, filename FROM this->includes ORDER BY moddate,package,filename)
                          , confighash := confighash
                          ];

    STRING datahash := EncodeUFS(GetSHA1Hash(EncodeHSON(finalconfig)));

    RETURN [ datahash := datahash
           , confighash := confighash
           ];
  }

  RECORD ARRAY FUNCTION GetDependentAssets(RECORD depsrecord)
  {
    RECORD ARRAY addedassets;

    STRING referencedby := (depsrecord.package != "" ? depsrecord.package || ":" : "") || depsrecord.filename;

    RECORD ARRAY tolookup :=
        (SELECT assettype := "use", id := ToUppercase(name), use := name FROM ToRecordArray(depsrecord.use, "NAME")) CONCAT
        (SELECT assettype := "usegrid", id := ToUppercase(name), use := name FROM ToRecordArray(depsrecord.usegrid, "NAME")) CONCAT
        (SELECT assettype := "package", id := ToUppercase(rec.name), use := rec.name, url := rec.url FROM ToRecordArray(depsrecord.depends, "REC"));

    FOREVERY (RECORD rec FROM tolookup)
    {
      RECORD pos := RecordLowerBound(this->includes, rec, [ "ASSETTYPE", "ID" ]);
      IF (pos.found)
        CONTINUE;

      RECORD ARRAY assets;

      SWITCH (rec.assettype)
      {
        CASE "use"      { assets := [ ResolveLocalUseInclude(rec.use, referencedby, depsrecord.round) ]; }
        CASE "usegrid"  { }
        CASE "package"  { assets := this->ResolvePackageInclude(rec.use, referencedby, rec.url); }
        DEFAULT         { THROW NEW Exception("???"); }
      }

      this->includes := ArraySlice(this->includes, 0, pos.position) CONCAT assets CONCAT ArraySlice(this->includes, pos.position);
      addedassets := addedassets CONCAT assets;
    }

    RETURN addedassets;
  }

  /** Very rough algorithm to see if a block ends in block-comment-mode
  */
  BOOLEAN FUNCTION EndsInBlockComment(STRING str)
  {
    INTEGER curr := 0;
    WHILE (TRUE)
    {
      INTEGER oldcurr := curr;
      curr := SearchSubstring(str, "/*", curr);
      IF (curr = -1)
        RETURN FALSE;

      curr := curr + 2;
      STRING part := SubString(str, oldcurr, curr - 2 - oldcurr);
      IF (SearchLastSubstring(part, "\n") < SearchLastSubstring(part, "//"))
      {
        curr := SearchSubstring(str, "\n", curr);
        IF (curr = -1)
          RETURN FALSE;

        curr := curr + 1;
        CONTINUE;
      }

      curr := SearchSubstring(str, "*/", curr + 2);
      IF (curr = -1)
        RETURN TRUE;
      curr := curr + 2;
    }
  }

  /// Rewrites url( links in css (to make combining possible), separate out imports & rest of css
  MACRO RewriteCSSLinks(BLOB incss, STRING cssurl, INTEGER import_stream, INTEGER output_stream, BOOLEAN rewritelinks)
  {
     cssurl := ResolveToAbsoluteURL(this->designroot,cssurl);

    // Create something that looks like the url where the combined css will be hosted
    STRING base := this->designroot = "" ? "" : ResolveToAbsoluteURL(this->designroot, "/.publisher/cd/dummy/");

    STRING str;
    IF (rewritelinks)
    {
      // Rewrite all urls wrapped in 'url('
      STRING ARRAY parts := Tokenize(BlobToString(incss, -1), "url(");
      FOREVERY (STRING part FROM parts)
      {
        IF (#part != 0)
        {
          INTEGER closepos := SearchSubstring(part, ")");
          STRING parturl := Left(part, closepos);
          IF (parturl LIKE "'*" OR parturl LIKE '"*')
            parturl := SubString(parturl, 1);
          IF (parturl LIKE "*'" OR parturl LIKE '*"')
            parturl := Left(parturl, LENGTH(parturl) - 1);

          STRING quoted;
          IF (parturl NOT LIKE "/*" AND NOT IsAbsoluteUrl(parturl))
          {
            STRING fullurl := ResolveToAbsoluteURL(cssurl, parturl);
            STRING relative := MakeRelativeLinkFromURL(base, fullurl, "");
            quoted := '"' || relative || '"';
          }
          ELSE
            quoted := '"' || parturl|| '"';

          str := str || "url(" || quoted;
          str := str || SubString(part,closepos);
        }
        ELSE
          str := str || part;
      }
    }
    ELSE
      str := BlobToString(incss, -1);

    // Heuristics parser to separate @imports from the rest. Very rough, not very reliable. FIXME: use real css parser for this?

    // Imports must appear first in the result css
    INTEGER last_import := SearchLastSubstring(str, "@import");
    IF (last_import != -1)
    {
      STRING import_part := Left(str, last_import);
      IF (this->EndsInBlockComment(import_part))
      {
        // Import is commented out. Include until end of comment/file whichever comes first
        INTEGER comment_close := SearchSubstring(str, "*/", last_import);
        IF (comment_close = -1)
          last_import := LENGTH(str);
        ELSE
          last_import := comment_close + 2;
      }
      ELSE
      {
        // Use until end of line
        last_import := SearchSubstring(str, "\n", last_import) + 1;
        IF (last_import = 0)
          last_import := LENGTH(str);
      }
    }

    IF (cssurl LIKE this->designroot || "*") // Tollium regen - conceal host
      cssurl := SubString(cssurl, LENGTH(this->designroot));
    IF (cssurl LIKE ResolveToAbsoluteURL(this->designroot, "/.tollium/*")) // Tollium regen - conceal host
      cssurl := SubString(cssurl, LENGTH(ResolveToAbsoluteURL(this->designroot, "/")) - 1);

    // Got import statements?
    IF (last_import != -1)
    {
      STRING imports := Left(str, last_import);
      PrintTo(import_stream, "/* CSS-import: " || cssurl || " */\n\n");
      PrintTo(import_stream, imports);
      IF (imports NOT LIKE "*\n")
        PrintTo(import_stream, "\n");
    }

    // Print rest of css
    PrintTo(output_stream, "/* CSS-output: " || cssurl || " */\n\n");
    PrintTo(output_stream, Substring(str, last_import));
    IF (str NOT LIKE "*\n")
      PrintTo(output_stream, "\n");
  }

  MACRO ExpandIncludes(RECORD ARRAY worklist)
  {
    WHILE (LENGTH(worklist) != 0)
    {
      RECORD rec := worklist[0];
      DELETE FROM worklist AT 0;

      worklist := worklist CONCAT this->GetDependentAssets(rec);
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //
  PUBLIC MACRO CalculateDependencies(RECORD ARRAY adduses, RECORD ARRAY addloads, STRING ARRAY flags, STRING relativelinksscope)
  {
    this->Adduses := adduses;
    this->addloads := addloads;
    this->flags := flags;
    this->relativelinksscope := relativelinksscope;
    // Make sure includes are ordered
    this->includes := SELECT * FROM this->includes ORDER BY type, id;

    /* First worklist: the user includes (in <webdesign>, just one, the basedependency) and any webdesign whlib AddLoads
       (and throw in grids too, they don't do anything weird dependency-wise) */
    RECORD ARRAY worklist :=
        [ [ use :=        DEFAULT STRING ARRAY
          , usegrid :=    this->addusegrids
          , depends :=    (SELECT name, url FROM this->addloads)
          , filename :=   "<base dependencies>"
          , package  :=   ""
          ]
        ] CONCAT this->includes;

    // Expand 'design' includes (in <webdesign>, currently just one)
    this->ExpandIncludes(worklist);

    /* Add expliclity requestd files. These usually come from <webdesign>
       AddUseAbsolute. If they were not yet included, users generally don't
       realize that their libraries will depend on domready handlers (and other
       code) from the base library to have already been loaded. So add this
       dependency implicitly
       (the most common error otherwise: formhandlers not being initialized) */
    INTEGER currentround := 2;
    FOREVERY(RECORD adduse FROM this->adduses)
    {
      IF(RecordExists(SELECT FROM this->includes WHERE id = ToUppercase(adduse.require)))
        CONTINUE; //already seen

      worklist := [[ use := [STRING(adduse.require)]
                   , usegrid := DEFAULT STRING ARRAY
                   , depends := DEFAULT RECORD ARRAY
                   , filename := adduse.fromwhere
                   , package := ""
                   , round := currentround
                  ]];
      currentround := currentround + 1;
      this->ExpandIncludes(worklist);
    }

    // Reorder and finalize dependencies
    this->includes := ReorderDependencies(this->includes);

    // Calculate the new package revision numbers. Keep current list, update with setdeps, remove unreferences packages.
    OBJECT depstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfolder");


    //the current set defines the actual sourcefolders to watch for changes. includes may be reset by the packaging code
    this->sourcefolders := SELECT AS INTEGER ARRAY DISTINCT whfsfolder FROM this->includes WHERE whfsfolder != 0;
    RECORD ARRAY relevantincludes := SELECT * FROM this->includes WHERE whfsfolder=0 AND (id LIKE "MODULEROOT::*" OR id LIKE "MOD::*");
    IF(Length(relevantincludes) > 0)
    {
      //non-combining is simply forbidden with moduleroot includes
      this->outputmode_js := 1;
      this->outputmode_css := 1;
      this->sourceeventmasks := GetResourceEventMasks(SELECT AS STRING ARRAY ToLowercase(id) FROM relevantincludes);
    }

    IF (this->outputmode_js != 0 OR this->outputmode_css != 0) //grab any custom settings - ADDME: fallback to uncompressed, direct links on failure to create compressed versions?
    {
      // ADDME exclude any CDN-hosted assets from minify/file generation, but still explicitly include those
      RECORD hashes := this->CalculateHashes(this->outputmode_js, this->outputmode_css);
      GetPrimary()->BeginLockedWork("publisher:depscalculation." || hashes.confighash);

      //ADDME Create a list of files to package together, excluding remote assets (eg CNN mootools) and non-packageable files (explicitly marked, or local CSS files), and only offer those for processing

      IF(RecordExists(SELECT FROM this->includes WHERE moddate = DEFAULT DATETIME))
        ABORT("bailing out - some files have no moddate, not sure it's safe to compile"); //what -exactly- happens to packages anyway?

      IF (this->outputmode_js = 2) //ADDME leave at 2 and implement minify
        this->outputmode_js := 1;
      IF (this->outputmode_css = 2) //ADDME leave at 2 and implement minify
        this->outputmode_css := 1;

      // Ensure it exists
      this->EnsureOutputExistence(hashes, this->outputmode_js, this->outputmode_css);
      //FIXME If outputmode != 0, we will be generating a reference and need to allocate a global mutex, or something similar
      GetPrimary()->CommitWork();
    }
  }

  PUBLIC RECORD ARRAY FUNCTION GenerateOutputFiles(INTEGER outputmode_js, INTEGER outputmode_css)
  {
    RECORD ARRAY outfiles;

    INTEGER outcss_imports := CreateStream();
    INTEGER outcss_output := CreateStream();
    INTEGER outjs := CreateStream();

    PrintTo(outcss_imports,"/* combined css file, generated " || FormatISO8601Datetime(GetCurrentDatetime()) || " */\n");
    PrintTo(outjs,"/* combined js file, generated " || FormatISO8601Datetime(GetCurrentDatetime()) || " */\n");


    TRY
    {
      //Walk all the packages. Create original and auxilliary files.
      //ADDME minify, compress and rewrite dupe urls
      //ADDME grid handling
      FOREVERY(RECORD incl FROM this->includes)
      {
        IF (incl.type = "css" AND outputmode_css != 0)
        {
          this->RewriteCSSLinks(incl.data, incl.url, outcss_imports, outcss_output, incl.assettype != "package");
        }
        ELSE IF(incl.type="js" AND outputmode_js != 0)
        {
          STRING jsurl := incl.url;
          IF (jsurl LIKE this->designroot || "*") // Tollium regen - conceal host
            jsurl := SubString(jsurl, LENGTH(this->designroot));

          PrintTo(outjs, "/* JS-output: " || jsurl || " */");

          // Add ';' between javascript files - fix concatenating files ending in expression and next starting with '(function($){...'
          PrintTo(outjs, ";\n\n");
          SendBlobTo(outjs, incl.data);
          PrintTo(outjs,"\n");
        }
      }

      //Copy any assets from 'local' packages. We're going to assume you're debugging concatenation/minify if you actually bothered to enable an outputmode
      //ADDME? If you update any auxilliary files for a local package without updating css/js, it will not change the hash and not be picked up..
      STRING ARRAY seenfilenames := ["WH.CSS","WH.JS"];

      RECORD ARRAY clonefiles := SELECT name := filename, data
                                   FROM this->includes
                                  WHERE type="asset";

      FOREVERY(RECORD toclone FROM clonefiles)
      {
        IF(ToUppercase(toclone.name) IN seenfilenames) //ADDME we should be generating unique names where possible, but would all packages understand that? we can rewrite css, but not as easily js..
          THROW NEW Exception("Duplicate filename '" || toclone.name || "' in compiled package");
        IF(NOT IsSafeFilePath(toclone.name, FALSE))
          THROW NEW Exception("Unacceptable filename '" || toclone.name || "' in compiled package");

        INSERT ToUppercase(toclone.name) INTO seenfilenames AT END;
        INSERT [ name := ToLowercase(toclone.name), data := toclone.data ] INTO outfiles AT END;
      }

      //Now walk all the 'extra' files in all the packages, and spit those out
      BLOB finalcss := MakeComposedBlob(
          [ [ data := MakeBlobFromStream(outcss_imports) ]
          , [ data := MakeBlobFromStream(outcss_output) ]
          ]);
      BLOB finaljs := MakeBlobFromStream(outjs);

      IF (outputmode_css != 0) //  AND Length(finalcss)>0)
      {
        INSERT [ name := "wh.css", data := finalcss ] INTO outfiles AT END;
      }
      IF (outputmode_js != 0) // AND Length(finaljs)>0)
      {
        INSERT [ name := "wh.js", data := finaljs ] INTO outfiles AT END;
      }

      RETURN outfiles;
    }
    CATCH(OBJECT e)
    {
      MakeBlobFromStream(outcss_imports);
      MakeBlobFromStream(outcss_output);
      MakeBlobFromStream(outjs);
      THROW e;
    }
  }

  PUBLIC RECORD FUNCTION GetFilesToInclude()
  {
    RETURN [ sourcefolders := this->sourcefolders
           , includes := this->includes
           , deps := this->packagelisting
           , designroot := this->designroot
           , sourceeventmasks := this->sourceeventmasks
           ];
  }
>;

RECORD FUNCTION CreateModuleRootAsset(STRING depname, STRING url)
{
  //STRING abspath := GetWebHareResourceDiskPath(depname);
  RECORD info := RetrieveWebhareResource(ToLowercase(depname));
  RECORD baseasset := [ assettype := "package"
                      , id := depname
                      , data := info.data
                      , url := url
                      , type := ToLowercase(depname) LIKE "*.js" ? "js" : "css"
                      , filename := GetNameFromPath(ToLowercase(depname))
                      , moddate := info.modified
                      , whfsfolder := 0
                      , domid := ""
                      , round := 0
                      ];
  baseasset := MakeMergedRecord(baseasset, ExtractHeader(baseasset.data, TRUE, ""));

  RETURN baseasset;
}

/** Create an asset from a module
    @return Parsed asset definition
    @cell return.data Data
    @cell return.url Asset URL
    @cell return.type Asset type ('js' or 'css')
    @cell return.filename File name of the asset
    @cell return.moddate Modification date
    @cell return.whfsfolder WHFS folder ID (if applicable)
    @cell return.domid Id of the DOM element

    @cell(record array) return.depends List of dependencies (see ExtractHeader)
    @cell(string) package Package (here always '')
    @cell(string array) after List of stuff marked as 'AFTER'
    @cell(string array) use Site paths ('site::...') marked as 'USE'.
    @cell(string array) usegrid  Site paths ('site::...') marked as 'USE'.
    @cell(string) media CSS media (deprecated)
*/
RECORD FUNCTION CreateModuleAsset(STRING depname, STRING url)
{
  depname := ToUppercase(depname);

  STRING pathname := CollapsePath(ToLowercase(Tokenize(depname,":")[1]));

  STRING modulename := ToLowercase(Tokenize(depname,":")[0]);
  RECORD baseasset := [ assettype := "package"
                      , id := depname
                      , data := DEFAULT BLOB
                      , url := url
                      , type := pathname LIKE "*.js" ? "js" : "css"
                      , filename := GetNameFromPath(pathname)
                      , moddate := DEFAULT DATETIME
                      , whfsfolder := 0
                      , domid := ""
                      , round := 0
                      ];


  STRING ARRAY tried;
  STRING diskpath := GetModuleInstallationRoot(modulename) || "web/" || pathname;
  INSERT diskpath INTO tried AT END;
  RECORD props := GetDiskFileProperties(diskpath);
  baseasset.url := "/." || modulename || "/" || pathname;
  IF(NOT RecordExists(props))
  {
    diskpath := GetModuleInstallationRoot(modulename) || "web/resources/" || pathname;
    INSERT diskpath INTO tried AT END;
    baseasset.url := "/tollium_todd.res/"  || modulename || "/" || pathname;
    props := GetDiskFileProperties(diskpath);
  }
  IF(NOT RecordExists(props))
    THROW NEW Exception("No such asset " || ToLowercase(depname) || " (tried " || Detokenize(tried,", ") || ")");

  baseasset.data := GetDiskResource(diskpath);
  baseasset.moddate := props.modified;

  baseasset := MakeMergedRecord(baseasset, ExtractHeader(baseasset.data, TRUE, ""));
  IF(baseasset.package = "") //ADDME require PACKAGE ?
    baseasset.package := depname;
  ELSE IF(baseasset.package != depname)
    THROW NEW Exception("Conflicting package name, expect: " || depname || " got " || baseasset.package);

  RETURN baseasset;
}

RECORD FUNCTION ResolveLocalUseInclude(STRING use, STRING referredby, INTEGER round)
{
  IF(ToUppercase(use) NOT LIKE "SITE::*")
    THROW NEW Exception("Unexpected USE syntax: '" || use || "' referred by '" || referredby || "'");

  OBJECT file := OpenWHFSObjectByPath(use);
  IF(NOT ObjectExists(file) OR file->isfolder)
    THROW NEW Exception("No such file '" || use || "' referred by '" || referredby || "'");
  RETURN GetFileAsInclude(file, round);
}

STRING FUNCTION GetVertexLabel(OBJECT vertex)
{
  RETURN RecordExists(vertex->data) ? (vertex->data.package != "" ? vertex->data.package : "<local>") || (CellExists(vertex->data, "filename") ? ":" || vertex->data.filename : "") : "local file barrier";
}

RECORD ARRAY FUNCTION ReorderDependencies(RECORD ARRAY includes)
{
  IF (Length(includes) = 0)
    RETURN DEFAULT RECORD ARRAY;

  // Create a graph, with one vertex per package and file
  OBJECT graph := NEW GraphObject;
  INTEGER id;

  // Group the files by package, create a vertex for each package
  RECORD ARRAY pkgs := SELECT package
                            , vertex := NEW GraphVertex
                            , files := GroupedValues(includes)
                            , type := "package"
                         FROM includes
                        GROUP BY package;
  pkgs := SELECT *
               , id := VAR id + #pkgs + 1
            FROM pkgs;
  id := SELECT AS INTEGER Max(COLUMN id) FROM pkgs;

  OBJECT ARRAY rounds;
  INTEGER highestround := SELECT AS INTEGER MAX(round) FROM includes;
  FOR(INTEGER i := 0; i < highestround; i := i + 1)
  {
    OBJECT localfilebarrier := NEW GraphVertex;
    localfilebarrier->data := [ type := "barrier after round #" || i ];
    graph->AddVertex(localfilebarrier);

    INSERT localfilebarrier INTO rounds AT END;

    IF(i>0)
      rounds[i-1]->AddSimpleEdge(localfilebarrier);
  }
  //For robustness, group all 'local' files and make sure they always get loaded after everything else

  FOREVERY (RECORD pkg FROM pkgs)
  {
    pkg.vertex->data := pkg;
    graph->AddVertex(pkg.vertex);

    // For each file within the package, create a vertex
    pkgs[#pkg].files := SELECT data := files
                             , id := VAR id + #files + 1
                             , vertex := NEW GraphVertex
                             , round
                          FROM pkg.files;
    id := SELECT AS INTEGER Max(COLUMN id) FROM pkgs[#pkg].files;

    FOREVERY (RECORD file FROM pkgs[#pkg].files)
    {
      file.vertex->data :=
          [ type := "file"
          , package := pkg.package
          , file := file.data
          ];
      graph->AddVertex(file.vertex);

      IF(file.round > 0)
        rounds[file.round-1]->AddSimpleEdge(file.vertex);
      IF(file.round < Length(rounds))
        file.vertex->AddSimpleEdge(rounds[file.round]);

/*      IF(pkg.package="") //local file
      {
        localfilebarrier->AddSimpleEdge(file.vertex);
      }
      ELSE
      {
        file.vertex->AddSimpleEdge(localfilebarrier);
      }*/
    }
  }

  // Create links for dependencies
  // An edge from A to B is created if:
  //  1. A is a file within package B (A should be loaded before package B is complete)
  //  2. A is a package required by file B (A should be loaded before B)
  //  3. B should be loaded after A (files within a package)
  FOREVERY (RECORD pkg FROM pkgs)
  {
    FOREVERY (RECORD file FROM pkg.files)
    {
      // Create a link from the file to the package
      file.vertex->AddSimpleEdge(pkg.vertex);

      // Create links from depedency packages to the file
      STRING ARRAY deps := SELECT AS STRING ARRAY name FROM file.data.depends;
      FOREVERY (RECORD dep FROM SELECT * FROM pkgs WHERE package IN deps)
        dep.vertex->AddSimpleEdge(file.vertex);

      // Create links from package files to be loaded before this file
      FOREVERY (RECORD after FROM SELECT * FROM pkg.files WHERE data.filename IN file.data.after)
        after.vertex->AddSimpleEdge(file.vertex);

      // Create USE links
      FOREVERY (RECORD use FROM SELECT * FROM pkg.files WHERE data.filename IN file.data.use)
        use.vertex->AddSimpleEdge(file.vertex);
    }
  }

  // Eliminate graph cycles
  OBJECT ARRAY neworder;
  WHILE (TRUE)
  {
    TRY
    {
      // Creates a topological sort; this will return the correct order. Throws on finding a cycle.
      neworder := TopologicalSort(graph);
      BREAK;
    }
    CATCH (OBJECT e)
    {
      /* A throw: a cycle was found. Find all strongly connected components (components in which
         all vertices are reachable from every other vertices). Those are the cycles. */
      RECORD ARRAY sccs := CalculateStronglyConnectedComponents(graph);
      FOREVERY (RECORD c FROM sccs)
      {
        /* A strongly connected component must be broken when it contains two or more vertices,
           or when a single vertex has a link to itself.
           In that case, always delete one vertex, so forward progress is guaranteed.
        */
        IF (LENGTH(c.vertices) > 1 OR (c.vertices[0] IN c.vertices[0]->linked_vertices))
        {
          // This is a cycle. Construct a path
          OBJECT ARRAY path := [ OBJECT(c.vertices[0]) ];

          FOR (INTEGER i := 0; i < LENGTH(c.vertices); i := i + 1)
          {
            FOREVERY (OBJECT v FROM path[END-1]->linked_vertices)
              IF (v IN c.vertices AND v NOT IN path)
                INSERT v INTO path AT END;
          }

          STRING ARRAY descriptions;
          FOREVERY (OBJECT pathitem FROM path)
          {
            SWITCH (pathitem->data.type)
            {
              CASE "package"          { /*INSERT "package " || pathitem->data.package INTO descriptions AT END;*/ }
              CASE "localfilebarrier" { /*INSERT "local file barrier" INTO descriptions AT END;*/ }
              CASE "file"             { INSERT (pathitem->data.package = "" ? "" : pathitem->data.package || ":") || pathitem->data.file.filename INTO descriptions AT END; }
              DEFAULT                 { THROW NEW Exception("Unknown graph type '" || pathitem->data.type || "'"); }
            }
          }

          THROW NEW Exception("Cycle detected in designfiles LOADS/USES. Relevant files: " || Detokenize(descriptions, ", "));
        }
      }
    }
  }

  // Calculate the return retval
  includes := DEFAULT RECORD ARRAY;
  FOREVERY (OBJECT v FROM neworder)
  {
    // Only interested in files
    IF (v->data.type != "file")
      CONTINUE;

    // Delete our added fields
    INSERT v->data.file INTO includes AT END;
  }
  //Abort("\n" || DebugGetGraphDisplay(graph, PTR GetVertexLabel) || AnyToString((SELECT filename, package, url FROM includes), "boxed"));

  RETURN includes;
}

/** Get classic site files assets
    @return
    @cell return.includes List of assets
*/
RECORD FUNCTION GetClassicSiteFiles(INTEGER designfolder)
{
  RECORD ARRAY includes;
  INTEGER ARRAY sourcefolders;

  RECORD jsfolder := SELECT id, url := objecturl FROM system.fs_objects WHERE parent=designfolder AND ToUppercase(name) = "JS";
  RECORD cssfolder := SELECT id, url := objecturl FROM system.fs_objects WHERE parent=designfolder AND ToUppercase(name) = "CSS";

  IF(RecordExists(jsfolder))
  {
    //Analyze the JS files
    includes := includes CONCAT
              (SELECT assettype := "classic_include"
                    , id := ToString(id)
                    , name
                    , data
                    , filename := name
                    , url := jsfolder.url || EncodeURL(name)
                    , flags := DEFAULT STRING ARRAY
                    , type := "js"
                    , moddate := modificationdate
                    , whfsfolder := parent
                    , domid := ""
                    , round := 1
                 FROM system.fs_objects
                WHERE parent = jsfolder.id
                      AND type = 6
                      AND publish
             ORDER BY ordering, ToUppercase(name));

    //ADDME stable and smart include ordering..
    INSERT jsfolder.id INTO sourcefolders AT END;
  }

  FOREVERY(RECORD jsfile FROM includes)
    IF(jsfile.type="js")
      includes[#jsfile] := MakeMergedRecord(jsfile, ExtractHeader(jsfile.data, TRUE, ""));

  //includes := ResolveJSIncludes(includes, baseurl);

  IF(RecordExists(cssfolder))
  {
    //Analyze the CSS files
    includes := includes CONCAT SELECT assettype := "classic_css"
                     , id := ToString(id)
                     , name
                     , data
                     , url := cssfolder.url || EncodeURL(name)
                     , type := "css"
                     , filename := name
                     , moddate := modificationdate
                     , whfsfolder := parent
                     , domid := ""
                     , round := 1
                  FROM system.fs_objects
                 WHERE parent = cssfolder.id
                       AND type = 9
                       AND publish
              ORDER BY ordering;

    INSERT cssfolder.id INTO sourcefolders AT END;
  }
  FOREVERY(RECORD cssfile FROM includes)
    IF(cssfile.type="css")
      includes[#cssfile] := MakeMergedRecord(cssfile, ExtractHeader(cssfile.data, TRUE, ""));

  RETURN [ includes := includes ];
}

/** Get DB file asset
    @param fileobj File
    @return Parsed asset definition
*/
RECORD FUNCTION GetFileAsInclude(OBJECT fileobj, INTEGER round)
{
  IF(fileobj->name NOT LIKE "*.js" AND fileobj->name NOT LIKE "*.css")
    THROW NEW Exception("Unable to figure out what to do with basefile '" || fileobj->name || "' (expected .js or .css file)");

  STRING filepath := "site::" || (SELECT AS STRING name FROM system.sites WHERE id = fileobj->parentsite) || "/" || Substring(fileobj->fullpath,1);

  RECORD basefileincl := [ assettype := "use"
                         , id := ToUppercase(filepath)
                         , data := fileobj->data
                         , url := fileobj->url
                         , type := fileobj->name LIKE "*.js" ? "js" : "css"
                         , filename := filepath
                         , moddate := fileobj->modificationdate
                         , whfsfolder := fileobj->parent
                         , domid := ""
                         , round := round
                         ];

  basefileincl := MakeMergedRecord(basefileincl, ExtractHeader(fileobj->data, FALSE, filepath));
  RETURN basefileincl;
}

/** Get sitefile assets
    @return
    @cell return.includes List of assets
*/
RECORD FUNCTION GetSiteFile(INTEGER designfolder, STRING basefile, INTEGER round)
{
  OBJECT basefileobj;
  //FIXME have callers fix this for us and rewrite everything to site:: - <webdesign> knows enough..
  IF(basefile NOT LIKE "*::*")
  {
    //FIXME sourcefolder discovery as we walk the dependencies - FIXME what did i mean by this?-Arnold
    OBJECT designfolderobj := OpenWHFSObject(designfolder);
    basefileobj := designfolderobj->OpenByPath(basefile);
    IF(NOT ObjectExists(basefileobj))
      THROW NEW Exception("Unable to locate '" || basefile || "' in folder " || designfolderobj->whfspath);
  }
  ELSE
  {
    basefileobj := OpenWHFSObjectByPath(basefile);
    IF(NOT ObjectExists(basefileobj))
      THROW NEW Exception("Unable to locate '" || basefile || "'");
  }

  RETURN [ includes := [ GetFileAsInclude(basefileobj, round) ]
         ];
}

