<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/queries.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_commands.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";

LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

INTEGER publisher_index, publisher_source;

INTEGER ARRAY FUNCTION GetIndexedWHFSObjects(INTEGER folderid)
{
  RECORD query := MakeTermQuery("whfstree", ToString(folderid));
  RECORD result := QueryIndexManager(publisher_index, query, [ count := -1, mapping := [ whfsid := "" ] ]);
  IF (result.status = SearchOk)
    RETURN
        SELECT AS INTEGER ARRAY DISTINCT ToInteger(whfsid, 0)
          FROM result.results;
  RETURN DEFAULT INTEGER ARRAY;
}

PUBLIC RECORD ARRAY FUNCTION ReindexWHFSChanges(RECORD ARRAY to_reindex, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD ARRAY results;
  options := ValidateOptions([ eventid := "", debug := FALSE, progress := FALSE ], options);

  IF (publisher_index = 0)
  {
    publisher_index := GetCatalogIdByName(whconstant_consilio_catalog_whfs);
    IF(publisher_index = -1) //not available yet, bootstrap? it's racy to wait for siteprofiles to generate the index
      THROW NEW Exception(`Publisher index '${whconstant_consilio_catalog_whfs}' not available`);

    publisher_source := GetContentSourceIdByTag("publisher:fsobjects");
  }

  INTEGER ARRAY to_update, to_delete;
  FOREVERY (RECORD obj FROM to_reindex)
  {
    IF (obj.isfolder)
    {
      // This will re-index the folder object contents recursively
      FOREVERY (INTEGER subobjid FROM GetIndexedWHFSObjects(obj.id))
      {
        IF (subobjid = 0)
          CONTINUE;
        // Reindexing an inactive group will delete it from content sources no longer responsible for it
        IF (obj.isdelete)
          INSERT subobjid INTO to_delete AT END;
        ELSE
          INSERT subobjid INTO to_update AT END;
      }
    }

    // This will re-index the folder or file object itself
    IF (obj.isdelete)
      INSERT obj.id INTO to_delete AT END;
    ELSE
      INSERT obj.id INTO to_update AT END;
  }

  to_update := GetSortedSet(to_update);
  to_delete := GetSortedSet(to_delete);

  IF (options.debug)
    Print(`To update: ${AnyToString(to_update, "tree")}To Delete: ${AnyToString(to_delete, "tree")}`);

  DATETIME now := GetCurrentDateTime();
  FOREVERY (INTEGER objid FROM to_delete)
  {
    RECORD data :=
        [ action := "DELETEGROUP"
        , commanddate := now
        , indexid := publisher_index
        , contentsourceid := publisher_source
        , groupid := "fsobj_" || objid
        ];

    DeleteGroup(data, [ refresh := TRUE ]);

    IF(options.progress)
      Print(`Deleting ${#objid+1}/${Length(to_delete)}: #${objid}\r`);
  }
  IF(options.progress AND Length(to_delete) > 0)
    Print(`\n`);

  FOREVERY (INTEGER objid FROM to_update)
  {
    RECORD data :=
        [ action := "CHECKGROUP"
        , commanddate := now
        , indexid := publisher_index
        , contentsourceid := publisher_source
        , groupid := "fsobj_" || objid
        ];

    IF(options.progress)
      Print(`Updating ${#objid+1}/${Length(to_update)}: #${objid}\r`);

    //TODO pass queueing priority based on startingpoint ordering
    RECORD result := CheckGroup(data, [ rebuild := data.action != "UPDATEGROUP"
                                      , refresh := TRUE
                                      ]);
    INSERT CELL[ objid, result ] INTO results AT END;
  }

  // Sort the results: first the requested ids in the order they're supplied, then other ids sorted ascending
  INTEGER ARRAY orgids := SELECT AS INTEGER ARRAY id FROM to_reindex;
  results := SELECT * FROM results ORDER BY SearchElement(orgids, objid) + 1 ?? objid;

  IF(options.progress AND Length(to_update) > 0)
    Print(`\n`);
  IF (options.eventid != "")
    BroadcastEvent(`system:whfs.index.response.${options.eventid}`, [ deleted := to_delete, updated := to_update ]);

  RETURN results;
}
