<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_commands.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";

LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";

OBJECT publisher_fsobjects_source;

INTEGER ARRAY FUNCTION GetIndexedWHFSObjectsForFolder(INTEGER folderid)
{
  RECORD query := CQMatch("whfstree", "=", ToString(folderid));
  RETURN SELECT AS INTEGER ARRAY DISTINCT whfsid
           FROM RunConsilioSearch(whconstant_consilio_catalog_whfs, query, [ count := -1, mapping := [ whfsid := 0 ] ]).results;
}

//Foregound WHFS (re)index
PUBLIC MACRO ReindexWHFSChanges(RECORD ARRAY to_reindex, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD ARRAY results;
  options := ValidateOptions([ eventid := "", debug := FALSE, progress := FALSE ], options);

  IF(NOT ObjectExists(publisher_fsobjects_source))
  {
    OBJECT catalog := OpenConsilioCatalog(whconstant_consilio_catalog_whfs);
    IF(NOT ObjectExists(catalog))
      THROW NEW Exception(`Publisher index '${whconstant_consilio_catalog_whfs}' not available`);

    publisher_fsobjects_source := OpenContentSource("publisher:fsobjects");
    IF(NOT ObjectExists(publisher_fsobjects_source))
      THROW NEW Exception(`Content source 'publisher:fsobjects' not available`);
  }

  INTEGER ARRAY to_update, to_delete;
  FOREVERY (RECORD obj FROM to_reindex)
  {
    IF (obj.isfolder)
    {
      // This will re-index the folder object contents recursively
      FOREVERY (INTEGER subobjid FROM GetIndexedWHFSObjectsForFolder(obj.id))
      {
        IF (subobjid = 0)
          CONTINUE;
        // Reindexing an inactive group will delete it from content sources no longer responsible for it
        IF (obj.isdelete)
          INSERT subobjid INTO to_delete AT END;
        ELSE
          INSERT subobjid INTO to_update AT END;
      }
    }

    // This will re-index the folder or file object itself
    IF (obj.isdelete)
      INSERT obj.id INTO to_delete AT END;
    ELSE
      INSERT obj.id INTO to_update AT END;
  }

  to_update := GetSortedSet(to_update);
  to_delete := GetSortedSet(to_delete);

  IF (options.debug)
    Print(`To update: ${EncodeJSON(to_update)}\nTo delete: ${EncodeJSON(to_delete)}\n`);

  DATETIME now := GetCurrentDateTime();
  FOREVERY (INTEGER objid FROM to_delete)
  {
    publisher_fsobjects_source->DeleteGroup("fsobj_" || objid, [ foreground := TRUE ]);
    IF(options.progress)
      Print(`Deleting ${#objid+1}/${Length(to_delete)}: #${objid}\r`);
  }
  IF(options.progress AND Length(to_delete) > 0)
    Print(`\n`);

  FOREVERY (INTEGER objid FROM to_update)
  {
    publisher_fsobjects_source->ReindexGroup("fsobj_" || objid, [ rebuild := TRUE, foreground := TRUE ]);
    IF(options.progress)
      Print(`Updating ${#objid+1}/${Length(to_update)}: #${objid}\r`);
  }

  // Sort the results: first the requested ids in the order they're supplied, then other ids sorted ascending
  INTEGER ARRAY orgids := SELECT AS INTEGER ARRAY id FROM to_reindex;
  results := SELECT * FROM results ORDER BY SearchElement(orgids, objid) + 1 ?? objid;

  IF(options.progress AND Length(to_update) > 0)
    Print(`\n`);

  // If anything was deleted or updated, refresh the index to make sure the results are available
  IF (Length(to_delete) + Length(to_update) > 0)
  {
    IF (options.progress)
      Print("Refreshing index...");
    publisher_fsobjects_source->catalog->Refresh();
    IF (options.progress)
      Print("\n");
  }

  IF (options.eventid != "")
    BroadcastEvent(`system:whfs.index.response.${options.eventid}`, [ deleted := to_delete, updated := to_update ]);
}

PUBLIC RECORD ARRAY FUNCTION ListPublisherContentSourcesFor(INTEGER fsobjid)
{
  INTEGER ARRAY tree := GetWHFSTree(fsobjid, 0);
  RETURN SELECT catalog := catalogid
              , contentsource := id
           FROM consilio.contentsources
          WHERE fsobject IN tree
                AND contentprovider = "publisher:webhare"
                AND status >= 0 //not disabled
                AND tag NOT LIKE "$consilio$deleted$*";
}
