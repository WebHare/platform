<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/services.whlib";

LOADLIB "mod::tollium/lib/dialogs.whlib";
LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/structuredef.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/widgets.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/rtd/support.whlib";

LOADLIB "mod::system/lib/internal/support.whlib";
LOADLIB "mod::system/lib/internal/webserver/config.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

PUBLIC STATIC OBJECTTYPE PropertyEditorException EXTEND Exception
<
  PUBLIC STRING extension;
  PUBLIC OBJECT originalexception;

  MACRO NEW(STRING extension, OBJECT originalexception)
  : Exception(originalexception->what)
  {
    IF(extension = "")
      ABORT(`PropertyEditorException::extension may not be empty`); //ABORT because this is basically a double-exception..

    this->originalexception := originalexception;
    this->extension := extension;
  }
>;

PUBLIC STRING FUNCTION EncodeDateTime(DATETIME dt) //used to encode creationdates for favorites...
{
  RETURN FormatDateTime("%Y%m%d%H%M%S%Q", dt);
}

PUBLIC BOOLEAN FUNCTION IsObjectHiddenForMe(OBJECT user, INTEGER objid)
{
  IF(objid IN GetWHFSObjectsToHide(user))
    RETURN TRUE;
  IF(user->HasRight("system:supervisor"))
    RETURN FALSE;
  INTEGER objtype := SELECT AS INTEGER type FROM system.fs_objects WHERE id=objid;
  RETURN objtype IN GetCachedSiteProfiles().hiddenfoldertypes;
}
STRING FUNCTION CombineOutputFolder(STRING diskfolder, STRING outputfolder, STRING innersite1rootfullpath)
{
  RETURN CollapsePath(diskfolder || "/" || outputfolder || "/" || innersite1rootfullpath) || "/";
}

//Which sites are contained inside the specified folderlist ?
RECORD ARRAY FUNCTION ContainedOutputs(INTEGER ARRAY folderlist)
{
  //Grab the full output folder of every to-be-deleted folder
  RECORD ARRAY folders := SELECT folderid := fs_objects.id
                               , diskfolder := webservers.diskfolder
                               , siteoutputfolder := sites.outputfolder
                               , fullpath := fs_objects.fullpath
                               , type := webservers.type
                            FROM system.fs_objects, system.sites, system.webservers
                           WHERE fs_objects.id IN folderlist
                                 AND fs_objects.parentsite = sites.id
                                 AND sites.outputweb = webservers.id;

  folders := EnrichWebserversWithOutputFolder(folders);
  folders := SELECT *
                  , containingfolder := CombineOutputFolder(outputfolder, siteoutputfolder, fullpath)
               FROM folders
              WHERE outputfolder != "";

  RECORD ARRAY siteoutputlist := SELECT base := folders.folderid
                                      , root := sites.root
                                      , name := sites.name
                                      , webservers.type
                                      , webservers.diskfolder
                                      , folders.containingfolder
                                      , siteoutputfolder := sites.outputfolder
                                   FROM system.sites, system.webservers, folders
                                  WHERE sites.outputweb = webservers.id
                                        AND sites.root NOT IN folderlist;

  siteoutputlist := EnrichWebserversWithOutputFolder(siteoutputlist);
  siteoutputlist := SELECT *
                      FROM siteoutputlist
                     WHERE siteoutputlist.outputfolder != ""
                           //webserver should cover this folder
                           AND ToUppercase(CombineOutputFolder(siteoutputlist.outputfolder, siteoutputfolder, "")) LIKE ToUppercase(siteoutputlist.containingfolder || "*")
                           ;
  RETURN SELECT base
              , root
              , name
           FROM siteoutputlist;
}


PUBLIC OBJECTTYPE ObjectDeletedException EXTEND Exception
< PUBLIC INTEGER objectid;
  MACRO NEW(INTEGER objectid, STRING message)
  : Exception(message)
  {
    this->objectid := objectid;
  }
>;

PUBLIC MACRO DoFSDownload(OBJECT frame, OBJECT fileobj, OBJECT downloadhandler)
{
  RECORD props :=
      [ name :=   fileobj->name
      , data :=   fileobj->data
      ];

  RECORD fileprops := ScanBlob(props.data, props.name);
  downloadhandler->SendFile(props.data, fileprops.mimetype, props.name);
}

PUBLIC RECORD ARRAY FUNCTION AnalyzeContents(INTEGER ARRAY objids)
{
  //DB-level check, find any sites contained in the to-be-deleted objects
  RECORD ARRAY conflictsites := GetContainedSites(objids);

  //Check if the deleted folders do not contain any sites (unless it's an entire-site deletion)
  RECORD ARRAY conflictoutputs := ContainedOutputs(objids);

  IF(Length(conflictsites)=0 AND Length(conflictoutputs)=0)
    RETURN DEFAULT RECORD ARRAY;

  //Return only the directories the user may access

  OBJECT user := GetEffectiveUser();
  BOOLEAN fullreadaccess := NOT ObjectExists(user) OR user->HasRightOn("system:fs_browse", 0);

  RECORD ARRAY retval;
  FOREVERY(RECORD conflictsite FROM conflictsites)
  {
    INSERT [ id := conflictsite.base /* the original offending folder */
           , isfatal := FALSE
           , errorcode := "CONTAINSSITEROOT"
           , errordata := fullreadaccess OR user->HasRightOn("system:fs_browse", conflictsite.root) ? conflictsite.name : ""
           ] INTO retval AT END;
  }
  FOREVERY(RECORD conflict FROM conflictoutputs)
  {
    INSERT [ id := conflict.base /* the original offending folder */
           , isfatal := TRUE
           , errorcode := "CONTAINSSITEOUTPUT"
           , errordata := fullreadaccess OR user->HasRightOn("system:fs_browse", conflict.root) ? conflict.name : ""
           ] INTO retval AT END;
  }

  RETURN retval;
}

PUBLIC STRING FUNCTION GetPublicationErrorMsg(INTEGER published, STRING errordata)
{
  INTEGER errorcode := GetErrorFromPublished(published);
  SWITCH(errorcode) //spelling out all gettids for the language editor's sake
  {
    CASE 101 { RETURN GetTid("publisher:publicationstatus.errors.hserror"); }
    CASE 102 { RETURN GetTid("publisher:publicationstatus.errors.abort"); }
    CASE 106 { RETURN GetTid("publisher:publicationstatus.errors.nofirstpage"); }
    CASE 108 { RETURN GetTid("publisher:publicationstatus.errors.noparts"); }
    CASE 109 { RETURN GetTid("publisher:publicationstatus.errors.noprofile"); }
    CASE 112 { RETURN GetTid("publisher:publicationstatus.errors.sitelocked"); }
    CASE 115 { RETURN GetTid("publisher:publicationstatus.errors.conflictingfile", errordata); }

    CASE 2001 { RETURN GetTid("publisher:publicationstatus.errors.unknowntype"); }
  }
  IF(errorcode >= 1001 AND errorcode <= 2000)
    RETURN GetTid("publisher:publicationstatus.errors.ioerror");
  IF(errorcode >= 2002 AND errorcode <= 3000)
    RETURN GetTid("publisher:publicationstatus.errors.unsupportedtype", errordata);

  RETURN GetTid("publisher:publicationstatus.errors.internalerror", errordata);
}

/** @param validuntil Validity of the link
    @param password Password to protect the preview with. Keep empty
    @param baseobj Base object to show (live version)
    @param toview Exact version to view (eg a draft). Leave 0 to show base version
    @return Preview url. An empty URL if this object cannot be previewed (the site has no output URL) */
PUBLIC STRING FUNCTION CreatePreviewLink(DATETIME validuntil, STRING password, INTEGER baseobj, INTEGER toview)
{
  RETURN GetPreviewLink(toview ?? baseobj, CELL[ validuntil, password ]);
}

PUBLIC RECORD FUNCTION DoEditWidget(OBJECT parent, OBJECT rte, STRING whfstype, RECORD value, OBJECT fsbaseobject, OBJECT applytester, BOOLEAN isedit, BOOLEAN isfilewidget, STRING currenttitle, RECORD widgetsettings)
{
  // Lookup embeddedobjecttype directly
  RECORD typedef := LookupContentType(whfstype);
  IF(NOT RecordExists(typedef))
    THROW NEW Exception(`Unable to find the object editor for widget type '${whfstype}'`);
  IF(NOT typedef.isembeddedobjecttype)
    THROW NEW Exception(`The type '${whfstype}' is not registered as a widget type`);

  IF(ObjectExists(applytester))
  {
    RECORD settings := GetRTDSettingsForApplyTester(applytester);
    IF(settings.namespace != "")
      typedef := applytester->GetUpdatedWidget(typedef);

    IF (NOT ObjectExists(fsbaseobject))
      fsbaseobject := OpenWHFSObject(applytester->__Deprecated_GetObjInfo().obj.id);
  }

  /* no editor configured - don't overwrite existing data (ie keep ...value) in case this
     is a mistake, but we always return something (no default record) as there is no way
     to cancel editting if there is nothing to edit

     when adding, return a initialized whfs instance but no furhter data, so we appear to be an OK
     when editing, return default record, as an editor shouldd never be invoked for an editor-less widget, so just appear to be a Cancel*/
  IF(NOT RecordExists(typedef.editor))
  {
    IF(NOT isedit)
      RETURN CELL[ title := currenttitle, widgetsettings := widgetsettings, instance := CELL[...value, whfstype ]];

    parent->RunSimpleScreen("info", GetTid("publisher:filemanager.main.messageboxes.cannoteditthiswidget"));
    RETURN DEFAULT RECORD;
  }

  IF(typedef.editor.type="function")
  {
    MACRO PTR editor := MakeFunctionPTR(typedef.editor.functionname, TypeID(RECORD), [ TYPEID(OBJECT), TYPEID(RECORD) ]);
    value := editor(parent, value);
    RETURN RecordExists(value) ? CELL[ title := currenttitle, widgetsettings := widgetsettings, instance := CELL[ ...value, whfstype ]] : DEFAULT RECORD;
  }

  RECORD contexts := [ applytester := applytester ];

  IF(ObjectExists(rte) AND MemberExists(rte, "__this_is_tolliumrichdocument"))
  {
    OBJECT context := NEW RichDocumentContext;
    context->__rtdtypeinfo := rte->rtdtypeinfo; // get the RTD settings
    DELETE FROM context->__rtdtypeinfo.allowedobjects WHERE NOT inherit;
    INSERT CELL richdocument := context INTO contexts;
  }

  RETURN parent->RunScreen("mod::publisher/tolliumapps/objecteditors/editwidget.xml#editor",
        [ whfstype := whfstype
        , typedef := typedef
        , fsbaseobject := fsbaseobject
        , rte := rte
        , value := value
        , isfilewidget := isfilewidget
        , currenttitle := currenttitle
        , widgetsettings := widgetsettings
        ], CELL[ contexts ]);
}

PUBLIC MACRO AddCopyMoveExceptionToWork(OBJECT work, OBJECT e, OBJECT destfolder)
{
  Print("CopyMoveException: " || e->errortag || "\n");
  SWITCH(e->errortag)
  {
    CASE "NOCREATERIGHTS"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.nocreaterights", e->errorobject->name));
    }
    CASE "DESTINATIONSITELOCKED"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.destinationsitelocked", e->errorobject->name));
    }
    CASE "NODELETERIGHTS"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.nodeleterights", e->errorobject->name));
    }
    CASE "RECURSIVE"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.cannotmovetosubfolder", e->errorobject->name, destfolder->name));
    }
    //ADDME: No error, but a confirmation?
    CASE "EXISTS"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.objectexists", e->errorobject->name, destfolder->name));
    }
    //ADDME: Maybe moving files to the root should be prevented by the interface
    CASE "NOFILESTOROOT"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.cannotmovefilestoroot", e->errorobject->name));
    }
    CASE "SITEINSITE"
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.cannotmovesiteinsite", e->errorobject->name, destfolder->name));
    }

    DEFAULT
    {
      work->AddError(GetTid("publisher:filemanager.main.messageboxes.unknownerror", e->errorobject->name, destfolder->name));
    }
  }
}
PUBLIC INTEGER FUNCTION __RunHistoryPropsDialog(OBJECT parent, RECORD data, STRING dialogname)
{
  RECORD ARRAY faultypropeditors;

  IF(dialogname = "site")
  {
    dialogname := "mod::publisher/screens/commondialogs/siteprops.xml";
  }
  ELSE IF (dialogname = "objectprops")
  {
    dialogname := "mod::publisher/tolliumapps/objectprops/objectprops-v2.xml";
  }

  WHILE (TRUE)
  {
    TRY
    {
      RETURN parent->RunScreen(dialogname, CELL[...data, faultypropeditors ]);
    }
    CATCH (OBJECT<PropertyEditorException> e)
    {
      // Exception is thrown when propertyeditor could not be loaded/initialized, try to create the dialog without this
      // propertyeditor
      RECORD fault := [ extension := e->extension
                      , error := e->what
                      ];
      Print("Property editor exception:\n" || AnyToString(fault,'boxed'));
      DumpValue(e->originalexception->trace,'boxed');

      INSERT fault INTO faultypropeditors AT END;
    }
    CATCH(OBJECT err)
    {
      // don't crash on any exception, we can just choose to not open the properties dialog
      // which is better than to crash the whole Publisher
      RunExceptionReportDialog(parent, err);
      RETURN 0;

    }
  }
}

RECORD ARRAY FUNCTION ApplyModifyTypes(RECORD ARRAY intypes, RECORD ARRAY modifyrules) {
  FOREVERY(RECORD mod FROM modifyrules) {
    UPDATE intypes
       SET __visible := mod.isallow
         , newonlytemplate := mod.isallow AND mod.setnewonlytemplate ? mod.newonlytemplate : newonlytemplate
     WHERE namespace LIKE mod.typedef OR scopedtype LIKE mod.typedef;
  }
  RETURN intypes;
}

PUBLIC RECORD ARRAY FUNCTION GetFolderTypes(OBJECT applytester, STRING languagecode, BOOLEAN showdevelopertypes, BOOLEAN showall)
{
  RECORD csp := GetCachedSiteProfiles();

  /* Select applicable folder types. We select at least the currently selected type.
     The 'standard' list and any added custom types are subject to the 'remove_folders' list */
  RECORD ARRAY folderTypes := SELECT id
                                   , title
                                   , namespace
                                   , tolliumicon
                                   , isdevelopertype := namespace IN VAR whconstant_developertypes
                                   , __visible := FALSE
                                   , newonlytemplate := FALSE
                                   , scopedtype
                                FROM csp.contenttypes
                               WHERE RecordExists(foldertype);

  IF(showall)
    UPDATE foldertypes SET __visible := TRUE;
  ELSE FOREVERY (RECORD apply FROM applytester->__GetAppliesForcell("MODIFYFOLDERTYPES"))
    foldertypes := ApplyModifyTypes(foldertypes, apply.modifyfoldertypes);

  IF(NOT applytester->__Deprecated_GetObjInfo().isfake)
    UPDATE foldertypes SET __visible := TRUE WHERE id = applytester->__Deprecated_GetObjInfo().obj.type;

  /* Select applicable folder types. We select at least the currently selected type.
     The 'standard' list and any added custom types are subject to the 'remove_folders' list */
  foldertypes := SELECT * FROM foldertypes
                               WHERE __visible=TRUE AND (showdevelopertypes OR isdevelopertype=FALSE)
                               ORDER BY /*id < 1000 DESC, id < 1000 ? id : 0*/id != 0, ToUppercase(title);
  RETURN foldertypes;
}

PUBLIC RECORD ARRAY FUNCTION GetFileTypes(OBJECT applytester, STRING languagecode, BOOLEAN showdevelopertypes, BOOLEAN showall, BOOLEAN isnew)
{
  RECORD csp := GetCachedSiteProfiles();

  /* Select applicable file types. We select at least the currently selected type.
     The 'standard' list and any added custom types are subject to the 'remove_files' list */
  RECORD ARRAY fileTypes := SELECT id
                                 , title
                                 , namespace
                                 , tolliumicon
                                 , isdevelopertype := namespace IN VAR whconstant_developertypes
                                 , iswidgettype := isembeddedobjecttype
                                 , requirescontent := filetype.requirescontent
                                 , __visible := FALSE
                                 , newonlytemplate := FALSE
                                 , scopedtype
                              FROM csp.contenttypes
                             WHERE RecordExists(filetype);

  IF(showall)
  {
    UPDATE filetypes SET __visible := TRUE;
  }
  ELSE FOREVERY (RECORD apply FROM applytester->__GetAppliesForcell("MODIFYFILETYPES"))
    filetypes := ApplyModifyTypes(filetypes, apply.modifyfiletypes);

  IF(NOT applytester->__Deprecated_GetObjInfo().isfake)
    UPDATE filetypes SET __visible := TRUE WHERE id = applytester->__Deprecated_GetObjInfo().obj.type;

  filetypes := SELECT * FROM filetypes
                               WHERE __visible=TRUE AND (showdevelopertypes OR isdevelopertype=FALSE)
                               ORDER BY /*id < 1000 DESC, id < 1000 ? id : 0*/id != 0, ToUppercase(title);
  RETURN filetypes;
}


PUBLIC MACRO SetWHFSObjectLastModifiedField(OBJECT modifiedfield, OBJECT whfsobject)
{
  modifiedfield->visible := ObjectExists(whfsobject);
  IF(NOT modifiedfield->visible)
    RETURN;

  modifiedfield->title := GetTid("publisher:tolliumapps.objectprops.objectprops.modified");

  STRING modifiedinfo, modifiedname;
  IF(whfsobject->modifiedby!=0)
    modifiedname := modifiedfield->owner->contexts->userapi->GetUserDisplayName(whfsobject->modifiedby);

  modifiedinfo := GetTid("publisher:tolliumapps.objectprops.objectprops.modifiedtext"
                        ,modifiedfield->owner->tolliumuser->FormatDateTime(whfsobject->modificationdate, "minutes", TRUE, FALSE)
                        ,modifiedname);

  IF(GetRoundedDatetime(whfsobject->creationdate, 60 * 1000) != GetRoundedDatetime(whfsobject->modificationdate, 60 * 1000)) //TODO msecs difference check, not just round?
  {
    STRING created := modifiedfield->owner->tolliumuser->FormatDateTime(whfsobject->creationdate, "minutes", TRUE, FALSE);
    modifiedinfo := modifiedinfo || " " || GetTid("publisher:tolliumapps.objectprops.objectprops.created", created);
  }

  modifiedfield->value := modifiedinfo;
}
