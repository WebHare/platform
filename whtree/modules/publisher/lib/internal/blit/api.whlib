<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/remoting/client.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::publisher/lib/internal/blit/hashapi.whlib";
LOADLIB "mod::publisher/lib/internal/blit/repositorytree.whlib";
LOADLIB "mod::publisher/lib/internal/blit/support.whlib";
LOADLIB "mod::publisher/lib/internal/blit/whfsintegration.whlib";


RECORD FUNCTION AuthHandler(RECORD result, STRING realm, STRING url)
{
  RETURN result;
}

MACRO WritebackCommitHandler(OBJECT datakeeper, STRING uuid, BOOLEAN commit)
{
  datakeeper->WriteToRepositoryCache();
  BroadcastEvent("publisher:blit.repo." || uuid, DEFAULT RECORD);
}

STATIC OBJECTTYPE RepoConnector
<
  STRING hosturl;
  STRING uuid;
  STRING path;

  OBJECT repo;
  INTEGER cb;

  BOOLEAN anonymous;

  PUBLIC OBJECT browser;

  MACRO NEW(STRING hosturl, STRING uuid, STRING path)
  {
    this->hosturl := hosturl;
    this->uuid := uuid;
    this->path := path;
    this->anonymous := hosturl LIKE "*/repository_anon*";

    this->browser := NEW WebBrowser;
  }

  MACRO OnTimeout()
  {
    this->cb := 0;
    this->ResetRepo();
  }

  PUBLIC MACRO SetRepo(OBJECT repo)
  {
    IF (ObjectExists(this->repo))
    {
      CloseRemotingSession(this->repo);
      IF (this->cb != 0)
        UnregisterCallback(this->cb);
    }

    this->repo := repo;
    this->cb := ObjectExists(repo) ? RegisterTimedCallback(AddTimeToDate(10000, GetCurrentDateTime()), PTR this->OnTimeout) : 0;
  }

  PUBLIC MACRO ResetRepo()
  {
    this->SetRepo(DEFAULT OBJECT);
  }

  PUBLIC OBJECT FUNCTION GetRepo()
  {
    IF (NOT ObjectExists(this->repo))
    {
      STRING service := this->anonymous ? "repository_anon" : "repository";

      STRING repositoryurl;
      IF (this->uuid != "")
        repositoryurl := ResolveToAbsoluteURL(this->hosturl, "/wh_services/blitserver/" || service || "/OpenByUUID");
      ELSE
        repositoryurl := ResolveToAbsoluteURL(this->hosturl, "/wh_services/blitserver/" || service || "/OpenByPath");

      OBJECT repo := InvokeRemoteFunctionWithBrowser(this->browser, repositoryurl, this->uuid ?? this->path, 1).repo;
      this->SetRepo(repo);
    }
    RETURN this->repo;
  }

  PUBLIC MACRO Close()
  {
    this->SetRepo(DEFAULT OBJECT);

    IF (ObjectExists(this->browser))
      this->browser->Close();
    this->browser := DEFAULT OBJECT;
  }
>;

PUBLIC OBJECT FUNCTION GetRepoConnectorByUUID(STRING serverurl, STRING uuid)
{
  RETURN NEW RepoConnector(serverurl, uuid, "");
}

PUBLIC OBJECT FUNCTION GetRepoConnectorByPath(STRING serverurl, STRING path)
{
  RETURN NEW RepoConnector(serverurl, "", path);
}

/** Takes a repo or a repoconnector, returns a repo */
PUBLIC OBJECT FUNCTION GetRepoFromObj(OBJECT obj)
{
  IF (obj EXTENDSFROM RepoConnector)
    obj := obj->GetRepo();
  RETURN obj;
}

/** Closes a repository or repoconnector */
PUBLIC MACRO CloseRepoObj(OBJECT obj)
{
  IF (ObjectExists(obj))
  {
    IF (obj EXTENDSFROM RepoConnector)
      obj->Close();
    ELSE
      CloseRemotingSession(obj);
  }
}

PUBLIC STRING FUNCTION CalculateRepositoryURL(STRING hosturl, BOOLEAN anonymous)
{
  IF (NOT anonymous)
    RETURN ResolveToAbsoluteURL(hosturl, "/wh_services/blitserver/repository/");
  ELSE
    RETURN ResolveToAbsoluteURL(hosturl, "/wh_services/blitserver/repository_anon/");
}

PUBLIC OBJECT FUNCTION OpenRemoteRepository(STRING hosturl, STRING repositoryuuid, OBJECT webbrowser, RECORD options)
{
  STRING repositoryurl;
  IF (CellExists(options, "USERNAME"))
  {
    repositoryurl := CalculateRepositoryURL(hosturl, FALSE);
    webbrowser->onauth := PTR AuthHandler([ username := options.username, password := options.password ], #1, #2);
  }
  ELSE
  {
    repositoryurl := CalculateRepositoryURL(hosturl, TRUE);
  }

  RECORD res := InvokeRemoteFunctionWithBrowser(webbrowser, repositoryurl || "OpenByUUID", repositoryuuid, blitapiversion);
  CheckServerAPILevel(res);

  OBJECT connector := GetRepoConnectorByUUID(repositoryurl, repositoryuuid);
  connector->SetRepo(res.repo);

  RETURN connector;
}

PUBLIC RECORD FUNCTION CheckoutWorkingCopy(OBJECT repo, OBJECT folder, STRING filename, STRING repohosturl, RECORD options)
{
  OBJECT parentrepo := FindRepositoryRoot(folder);
  IF (ObjectExists(parentrepo))
    THROW NEW Exception("Root folder is already part of a repository");

  IF (ObjectExists(folder->OpenByName(filename)))
    THROW NEW Exception("Folder already exists");

  repo := GetRepoFromObj(repo);

  RECORD repo_status := repo->GetStatus();
  STRING roothash := repo_status.roothash;
  INTEGER version := repo_status.version;

  IF (CellExists(options, "VERSION") AND options.version != 0)
  {
    roothash :=
        SELECT AS STRING COLUMN roothash
          FROM repo->GetCommitLog(DEFAULT STRING ARRAY)
          WHERE COLUMN version = options.version;

    IF (roothash = "")
      THROW NEW Exception("Version " || options.version || " does not exist");

    version := options.version;
  }

  OBJECT datakeeper := MakeTreeDataKeeper();
  OBJECT remote_tree := EncapsulateRawRepositoryTree(GetDecompressedObjectTree(repo, roothash));
  GetTreeData(repo, remote_tree, datakeeper);

  OBJECT diffrtree := RepositoryTreeDiff3(DEFAULT OBJECT, DEFAULT OBJECT, remote_tree);

  OBJECT changes := GenerateWHFSDescriptionDiffTree(diffrtree);

  OBJECT trans := GetPrimaryWebhareTransactionObject();
  trans->PushWork();

  OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
  OBJECT localfolder := folder->CreateFolder([ name := filename ]);

  IF (NOT ObjectExists(localfolder))
  {
    trans->PopWork();
    THROW NEW Exception("Cannot create folder '" || filename || "'");
  }

  STRING localuuid := ToLowercase(EncodeBase16(GetSHA1Hash(GenerateUFS128BitId())));

  repostype->SetInstanceData(localfolder->id,
      [ repository_url :=       CalculateRepositoryURL(repohosturl, CellExists(options, "READONLY") AND options.readonly)
      , repository_path :=      repo_status.path
      , repository_uuid :=      repo_status.repository_uuid
      , repository_version :=   version
      , repository_roothash :=  roothash
      , repository_localuuid := localuuid
      ]);

  changes->Apply(localfolder);

  trans->PopWork();

  IF (trans->IsWorkOpen())
    trans->RegisterCommitHandler("", PTR WritebackCommitHandler(datakeeper, repo_status.repository_uuid, #1));
  ELSE
  {
    datakeeper->WriteToRepositoryCache();
    BroadcastEvent("publisher:blit.repo." || repo_status.repository_uuid, DEFAULT RECORD);
  }

  RETURN
      [ success :=    TRUE
      , folder :=     localfolder
      , newversion := version
      , hashestree := GetObjectHashesFromRepository(remote_tree)
      ];
}

/** Replaces the a working copy with a version from the server. Discards all local changes!
    @param folder Root of working copy
    @param options
    @cell(string) options.username
    @cell(string) options.password
    @cell(string) options.version Version to update to (optional, omit to update to trunk).
    @cell(string) options.alwaysdiscard Force clearing local changes when already up to date
*/
PUBLIC RECORD FUNCTION ForceUpdateWorkingCopy(OBJECT folder, RECORD options)
{
  RECORD rootdata := LocateRepository(folder);
  IF (NOT RecordExists(rootdata) OR rootdata.root->id != folder->id)
    THROW NEW Exception("Folder is not the root of a working copy");

  OBJECT root := rootdata.root;
  OBJECT datakeeper := MakeTreeDataKeeper();

  OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
  RECORD repodata := rootdata.repodata;

  OBJECT browser := NEW WebBrowser;

  browser->onauth := PTR AuthHandler([ username := options.username, password := options.password ], #1, #2);
  RECORD res := InvokeRemoteFunctionWithBrowser(browser, repodata.repository_url || "OpenByUUID", repodata.repository_uuid, blitapiversion);
  CheckServerAPILevel(res);
  OBJECT repo := res.repo;

  TRY
  {
    RECORD remote_status := repo->GetStatus();

    RECORD commit;
    IF (CellExists(options, "VERSION") AND options.version != 0)
      commit := repo->GetCommitByVersion(options.version);
    ELSE
      commit := remote_status;

    IF (repodata.repository_version = commit.version AND (NOT CellExists(options, "ALWAYSDISCARD") OR NOT options.alwaysdiscard))
    {
      RETURN
          [ success :=    TRUE
          , updated :=    FALSE
          , oldversion := repodata.repository_version
          , newversion := commit.version
          ];
    }

    OBJECT dtree_local := CreateWHFSDescriptionTree(folder);
    IF (dtree_local->has_errors)
      THROW NEW Exception("Cannot update, local tree has errors");

    OBJECT rtree_local := dtree_local->BuildRepositoryTree();
    UpdateFSCache(rtree_local);

    datakeeper->AddTreeData(rtree_local);

    OBJECT rtree_remote := EncapsulateRawRepositoryTree(repo->GetObjectTree(commit.roothash));
    GetTreeData(repo, rtree_remote, datakeeper);

    // Calculate diffrtree that replaces local tree with remote tree
    OBJECT diffrtree := RepositoryTreeDiff3(rtree_local, rtree_local, rtree_remote);
    OBJECT moddtree := GenerateWHFSDescriptionDiffTree(diffrtree);

    OBJECT trans := GetPrimaryWebhareTransactionObject();
    trans->PushWork();

    moddtree->Apply(folder);

    INTEGER oldversion := repodata.repository_version;

    repodata.repository_version := commit.version;
    repodata.repository_roothash := commit.roothash;
    repodata.repository_path := remote_status.path;

    repostype->SetInstanceData(folder->id, repodata);

    trans->PopWork();

    IF (trans->IsWorkOpen())
      trans->RegisterCommitHandler("", PTR WritebackCommitHandler(datakeeper, repodata.repository_uuid, #1));
    ELSE
    {
      datakeeper->WriteToRepositoryCache();
      BroadcastEvent("publisher:blit.repo." || repodata.repository_uuid, DEFAULT RECORD);
    }

    RETURN
        [ success :=    TRUE
        , updated :=    TRUE
        , oldversion := oldversion
        , newversion := commit.version
        ];
  }
  FINALLY
  {
    CloseRepoObj(repo);
  }
}

PUBLIC STATIC OBJECTTYPE BlitUpdater
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Repository
  OBJECT repoconnector;

  OBJECT workingcopy;

  OBJECT datakeeper;

  /// Repository data from local repository
  RECORD repodata;

  /// Status of remote repository
  RECORD remote_status;

  /// WHFS Description tree of working copy
  OBJECT dtree_local;

  /// WHFS description modification tree which contains the modifications to local working copy
  OBJECT moddtree;

  /** List of modifications done by user, from the @a moddtree
      @param rowkey Path
      @param obj Tree record
      @param tresolution Resolution for type/existence conflict
      @param nresolution Resolution for name conflict
      @param dresolution Resolution for data conflict
      @param bresolution Resolution for base data conflict
      @param mresolution Resolutions for instance data conflicts
  */
  RECORD ARRAY pvt_modifications;

  STRING localtreehash;

  OBJECT rtree_parent;
  OBJECT dtree_parent;

  OBJECT rtree_remote;
  OBJECT dtree_remote;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /// Version nr of local working copy
  PUBLIC PROPERTY localversion(GetWorkingCopyVersion, -);

  PUBLIC PROPERTY remoteversion(GetRemoteVersion, -);

  PUBLIC PROPERTY modifications(pvt_modifications, -);

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO NEW(OBJECT repoconnector, OBJECT workingcopy)
  {
    this->repoconnector := repoconnector;
    this->workingcopy := workingcopy;

    OBJECT repo := GetRepoFromObj(this->repoconnector);

    OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
    this->repodata := repostype->GetInstanceData(this->workingcopy->id);

    this->remote_status := repo->GetStatus();

    // Early exit. No update (and costly calculations) are needed
    IF (this->localversion = this->remoteversion)
      RETURN;

    // Populate datakeeper with repository cache
    this->datakeeper := MakeTreeDataKeeper();

    // Get parent & remote tree from the remote server
    this->rtree_parent := EncapsulateRawRepositoryTree(GetDecompressedObjectTree(repo, this->repodata.repository_roothash));
    this->rtree_remote := EncapsulateRawRepositoryTree(GetDecompressedObjectTree(repo, this->remote_status.roothash));

    // Fill remote tree with data (we need its inclusion settings). Stores new blobs in datakeeper too.
    GetTreeData(repo, this->rtree_remote, this->datakeeper);

    // Construct remote dtree
    this->dtree_remote := CreateWHFSDescriptionTreeFromRepository(this->rtree_remote);

    // Construct a whfs-d-tree from the local working copy.
    this->dtree_local := CreateWHFSDescriptionTree(this->workingcopy,
        [ overrideinclusionsettings := this->dtree_remote
        ]);

    IF (this->dtree_local->has_errors) // Currently no way to get errors
      THROW NEW Exception("Cannot construct the description tree, it has errors");

    // Build a repository tree form that d-tree, and store id->hash cache in FS cache
    OBJECT rtree_local := this->dtree_local->BuildRepositoryTree();
    UpdateFSCache(rtree_local);

    this->localtreehash := rtree_local->GetTreeHash();

    // Populate datakeeper with all cached hash->blob records
    this->datakeeper->AddTreeData(rtree_local);

    // Get parent data too
    GetTreeData(repo, this->rtree_parent, this->datakeeper);

    this->datakeeper->WriteToRepositoryCache();

//    PRINT("Updating (rtree)\nParent\n" || this->rtree_parent->ShortDump());
//    PRINT("Remote\n" || this->rtree_remote->ShortDump());
//    PRINT("Local\n" || rtree_local->ShortDump());

//    PRINT("Updating (dtree)\nParent\n" || CreateWHFSDescriptionTreeFromRepository(this->rtree_parent)->ShortDump());
//    PRINT("Remote\n" || CreateWHFSDescriptionTreeFromRepository(this->rtree_remote)->ShortDump());
//    PRINT("Local\n" || this->dtree_local->ShortDump());

    // Calculate the differences on repositorytree level
    OBJECT diffrtree := RepositoryTreeDiff3(rtree_local, this->rtree_parent, this->rtree_remote);

//    PRINT("Diffrtree\n" || diffrtree->ShortDump());

    this->moddtree := GenerateWHFSDescriptionDiffTree(diffrtree);

//    PRINT("Moddtree\n" || this->moddtree->ShortDump());

    this->pvt_modifications :=
        SELECT rowkey :=        "path-" || Detokenize(path, "/")
             , path
             , hasconflict :=   status LIKE "*-conflict"
             , canmerge :=      FALSE
             , resolvestatus := ""
             , obj :=           obj
             , status
             , tresolution :=   DEFAULT RECORD
             , nresolution :=   DEFAULT RECORD
             , dresolution :=   DEFAULT RECORD
             , bresolution :=   DEFAULT RECORD
             , mresolution :=   DEFAULT RECORD
          FROM this->moddtree->GetAllTreeObjects() AS obj
      ORDER BY Detokenize(path, "/");

    // Try to resolve all data conflicts as far as possible
    this->TryResolveConflicts();
    this->UpdateResolveStatus();
  }

  MACRO UpdateResolveStatus()
  {
    UPDATE this->pvt_modifications AS row
      SET resolvestatus := hasconflict ? this->GetResolveStatus(row) : "";
  }

  STRING FUNCTION GetResolveStatus(RECORD row)
  {
    STRING status;
    IF (RecordExists(row.obj.tconflict))
    {
      IF (NOT RecordExists(row.tresolution))
        RETURN "unresolved";
      ELSE
        status := "resolved";
    }
    IF (RecordExists(row.obj.nconflict))
    {
      IF (NOT RecordExists(row.nresolution))
        RETURN "unresolved";
      ELSE
        status := "resolved";
    }
    IF (RecordExists(row.obj.bconflict))
    {
      IF (NOT RecordExists(row.bresolution))
        RETURN "unresolved";
      ELSE
        status := "resolved";
    }
    IF (RecordExists(row.obj.mconflict))
    {
      IF (this->GetMConflictState(row) = "unresolved")
        RETURN "unresolved";
      ELSE
        status := "resolved";
    }
    IF (RecordExists(row.obj.dconflict))
    {
      IF (NOT RecordExists(row.dresolution))
        RETURN "unresolved";
      IF (row.dresolution.type IN [ "postponed", "merged" ])
        RETURN row.dresolution.type;
      status := "resolved";
    }
    RETURN status;
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  INTEGER FUNCTION GetWorkingCopyVersion()
  {
    RETURN this->repodata.repository_version;
  }

  INTEGER FUNCTION GetRemoteVersion()
  {
    RETURN this->remote_status.version;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING FUNCTION GetMConflictState(RECORD rec)
  {
    IF (NOT RecordExists(rec.obj.mconflict))
      RETURN "";

    IF (NOT RecordExists(rec.mresolution))
      RETURN "unresolved";
    RETURN rec.mresolution.type;
/*
    STRING ARRAY resolutions :=
        SELECT AS STRING ARRAY DISTINCT
                 (SELECT AS STRING type
                    FROM rec.mresolution.instances
                   WHERE typens = conflicts.typens)
          FROM rec.obj.mconflict.conflicts;

    IF ("" IN resolutions)
      RETURN "unresolved";
    IF (LENGTH(resolutions) = 1)
      RETURN resolutions[0];
    RETURN "resolved";*/
  }

  MACRO TryResolveConflicts()
  {
    // FIXME: do diff3 stuff only for text-based files
    FOREVERY (RECORD mod FROM this->pvt_modifications)
      IF (mod.hasconflict AND RecordExists(mod.obj.dconflict) AND LENGTH(mod.path) != 0)
      {
        BLOB currentdata := mod.obj.dconflict.current.data;
        IF (IsTextFile(currentdata, mod.path[END-1]))
        {
          this->pvt_modifications[#mod].canmerge := TRUE;
          this->ResolveDataConflictByMerge(mod.rowkey);
        }
      }
  }

  RECORD FUNCTION SelectConflictTree(RECORD conflict, STRING method, BOOLEAN unresolvedasdefault)
  {
    RECORD res;
    IF (method = "mine")
      res := [ type := "mine", result := conflict.current ];
    ELSE IF (method = "theirs")
      res := [ type := "theirs", result := conflict.changes ];
    ELSE IF (method = "unresolved")
      res := unresolvedasdefault ? DEFAULT RECORD : [ type := "unresolved" ];
    ELSE
      THROW NEW Exception("Unknown conflict resolve method '" || method || "'");
    IF (RecordExists(res) AND CellExists(conflict, "TYPENS"))
      INSERT CELL typens := conflict.typens INTO res;
    RETURN res;
  }

  PUBLIC OBJECT FUNCTION GetResolvedModTree()
  {
    // Copy the tree, and apply the conflict resolutions
    OBJECT tree := this->moddtree->Clone();

    FOREVERY (RECORD mod FROM this->pvt_modifications)
    {
      IF (RecordExists(mod.tresolution))
        tree->ResolveTypeConflict(mod.obj.path, mod.tresolution.result);
      IF (RecordExists(mod.nresolution))
        tree->ResolveNameConflict(mod.obj.path, mod.nresolution.result);
      IF (RecordExists(mod.dresolution))
        tree->ResolveDataConflict(mod.obj.path, mod.dresolution.result.data);
      IF (RecordExists(mod.bresolution))
        tree->ResolveBasedataConflict(mod.obj.path, mod.bresolution.result);
      IF (RecordExists(mod.mresolution))
        tree->ResolveMetadataConflict(mod.obj.path, mod.mresolution.resolves);
    }

    RETURN tree;
  }

  RECORD FUNCTION UpdateInstanceConflictResolution(RECORD mresolution, RECORD mconflict, STRING typens, STRING method, BOOLEAN onlyunresolved)
  {
    IF (NOT RecordExists(mresolution))
    {
      mresolution :=
          [ type :=         "unresolved"
          , resolves :=     DEFAULT RECORD ARRAY
          ];
    }

    // Determine conflicts to resolve
    RECORD ARRAY conflicts :=
        SELECT *
          FROM mconflict.conflicts
         WHERE (VAR typens = "*" ? TRUE : COLUMN typens = VAR typens);

    IF (onlyunresolved)
    {
      STRING ARRAY alreadyresolved :=
          SELECT AS STRING ARRAY COLUMN typens
            FROM mresolution.resolves;

      DELETE FROM conflicts WHERE COLUMN typens IN alreadyresolved;
      mresolution.resolves := DEFAULT RECORD ARRAY;
    }

    FOREVERY (RECORD conflict FROM conflicts)
    {
      RECORD resolution := this->SelectConflictTree(conflict, method, TRUE);
      RECORD tpos := RecordLowerBound(mresolution.resolves, conflict, [ "TYPENS" ]);
      IF (tpos.found != RecordExists(resolution))
      {
        IF (RecordExists(resolution))
          INSERT resolution INTO mresolution.resolves AT tpos.position;
        ELSE
          DELETE FROM mresolution.resolves AT tpos.position;
      }
      ELSE IF (RecordExists(resolution))
        mresolution.resolves[tpos.position] := resolution;
    }

    STRING ARRAY resolves := SELECT AS STRING ARRAY DISTINCT type FROM mresolution.resolves;
    mresolution.type := LENGTH(mresolution.resolves) != LENGTH(mconflict.conflicts)
        ? "unresolved"
        : LENGTH(resolves) = 1
              ? resolves[0]
              : "resolved";

    RETURN
        [ mresolution :=    mresolution
        , resolved :=       SELECT AS STRING ARRAY COLUMN typens FROM conflicts
        ];
   }

  MACRO ResolveInstanceConflictInternal(STRING rowkey, STRING typens, STRING method, BOOLEAN onlyunresolved)
  {
    RECORD pos := RecordLowerBound(this->pvt_modifications, [ rowkey := rowkey ], [ "ROWKEY" ]);
    IF (NOT pos.found)
      THROW NEW Exception("No such rowkey!");

    RECORD mod := this->pvt_modifications[pos.position];

    RECORD res := this->UpdateInstanceConflictResolution(mod.mresolution, mod.obj.mconflict, typens, method, onlyunresolved);
    this->pvt_modifications[pos.position].mresolution := res.mresolution;

    this->UpdateResolveStatus();
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC RECORD FUNCTION GetObjectVersions(STRING rowkey)
  {
    RECORD pos := RecordLowerBound(this->pvt_modifications, [ rowkey := rowkey ], [ "ROWKEY" ]);
    IF (NOT pos.found)
      THROW NEW Exception("No such rowkey!");

    RECORD mod := this->pvt_modifications[pos.position];

    // Calc the parent dtree if not yet done
    IF (NOT ObjectExists(this->dtree_parent))
      this->dtree_parent := CreateWHFSDescriptionTreeFromRepository(this->rtree_parent);

    // Update the local tree with the only selected changes
    OBJECT modtree := this->GetResolvedModTree();
    modtree := FilterWHFSDescriptionDiffTree(modtree, [ [ path := mod.path ] ]);

    RECORD result :=
        [ rowkey :=               rowkey
        , path :=                 mod.path
        , canmerge :=             mod.canmerge
        , parent :=               this->dtree_parent->GetObjectByPath(mod.path)
        , result :=               DEFAULT RECORD
        , local :=                this->dtree_local->GetObjectByPath(mod.path)
        , remote :=               this->dtree_remote->GetObjectByPath(mod.path)
        , typeunresolved :=       FALSE
        , nameunresolved :=       FALSE
        , dataunresolved :=       FALSE
        , basedataunresolved :=   FALSE
        , instancesunresolved :=  DEFAULT STRING ARRAY
        , typeresolution :=       ""
        , nameresolution :=       ""
        , dataresolution :=       ""
        , basedataresolution :=   ""
        , instanceresolutions :=  DEFAULT RECORD ARRAY
        ];

    IF (mod.status LIKE "*-conflict")
    {
      // Resolve remaining conflicts
      IF (RecordExists(mod.obj.tconflict))
      {
        IF (NOT RecordExists(mod.tresolution))
        {
          result.typeunresolved := TRUE;
          modtree->ResolveTypeConflict(mod.obj.path, this->SelectConflictTree(mod.obj.tconflict, "mine", TRUE).result);
        }
        ELSE
          result.typeresolution := mod.tresolution.type;
      }
      IF (RecordExists(mod.obj.nconflict))
      {
        IF (NOT RecordExists(mod.nresolution))
        {
          result.nameunresolved := TRUE;
          modtree->ResolveNameConflict(mod.obj.path, this->SelectConflictTree(mod.obj.nconflict, "mine", TRUE).result);
        }
        ELSE
          result.nameresolution := mod.nresolution.type;
      }
      IF (RecordExists(mod.obj.dconflict))
      {
        IF (NOT RecordExists(mod.dresolution))
        {
          result.dataunresolved := TRUE;
          modtree->ResolveDataConflict(mod.obj.path, this->SelectConflictTree(mod.obj.dconflict, "mine", TRUE).result.data);
        }
        ELSE
          result.dataresolution := mod.dresolution.type;
      }
      IF (RecordExists(mod.obj.bconflict))
      {
        IF (NOT RecordExists(mod.bresolution))
        {
          result.basedataunresolved := TRUE;
          modtree->ResolveBaseDataConflict(mod.obj.path, this->SelectConflictTree(mod.obj.bconflict, "mine", TRUE).result);
        }
        ELSE
          result.basedataresolution := mod.bresolution.type;
      }
      IF (RecordExists(mod.obj.mconflict))
      {
        // Rebuild the mresolution from the still existing conflicts
        RECORD res := this->UpdateInstanceConflictResolution(mod.mresolution, mod.obj.mconflict, "*", "mine", TRUE);
        IF (LENGTH(res.mresolution.resolves) != 0)
          modtree->ResolveMetadataConflict(mod.obj.path, res.mresolution.resolves);
        result.instancesunresolved := res.resolved;
        IF (RecordExists(mod.mresolution))
          result.instanceresolutions := SELECT type, typens FROM mod.mresolution.resolves;
      }
    }

    IF (modtree->HasConflicts())
      ABORT("Still conflicts present!");

    OBJECT fdtree := modtree->ApplyOnDescriptionTree(this->dtree_local);

    result.result := fdtree->GetObjectByPath(mod.path);

    RETURN result;
  }

  PUBLIC BOOLEAN FUNCTION AnyUnresolved()
  {
    RETURN RecordExists(
        SELECT
          FROM this->pvt_modifications
         WHERE resolvestatus = "unresolved");
  }

  PUBLIC BOOLEAN FUNCTION AnyProblem()
  {
    RETURN RecordExists(
        SELECT
          FROM this->pvt_modifications
         WHERE resolvestatus IN [ "unresolved", "postponed" ]);
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveTypeConflictSimple(STRING rowkey, STRING method)
  {
    UPDATE this->pvt_modifications
       SET tresolution := this->SelectConflictTree(obj.tconflict, method, TRUE)
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveDataConflictSimple(STRING rowkey, STRING method)
  {
    UPDATE this->pvt_modifications
       SET dresolution := this->SelectConflictTree(obj.dconflict, method, TRUE)
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Automatic merge
  PUBLIC BOOLEAN FUNCTION ResolveDataConflictByMerge(STRING rowkey)
  {
    OBJECT repo := GetRepoFromObj(this->repoconnector);

    BOOLEAN success := TRUE;
    FOREVERY (RECORD mod FROM this->pvt_modifications)
      IF (mod.rowkey = rowkey AND RecordExists(mod.obj.dconflict) AND mod.canmerge)
      {
        RECORD dconflict := mod.obj.dconflict;
        RECORD diff3 := DoLineEndingCompensatedDiff3(repo,
            CellExists(dconflict.current, "DATA") ? dconflict.current.data : DEFAULT BLOB,
            CellExists(dconflict.parent, "DATA") ? dconflict.parent.data : DEFAULT BLOB,
            CellExists(dconflict.changes, "DATA") ? dconflict.changes.data : DEFAULT BLOB);

        success := NOT diff3.conflicts;
        this->pvt_modifications[#mod].dresolution :=
            [ type :=       diff3.conflicts ? "postponed" : "merged"
            , result :=     [ data := diff3.final ]
            ];
      }
    this->UpdateResolveStatus();
    RETURN success;
  }

  /// Manual resolve of file conflict
  PUBLIC MACRO ResolveDataConflict(STRING rowkey, BLOB newdata, BOOLEAN stillhasconflicts)
  {
    UPDATE this->pvt_modifications
       SET dresolution := [ type := stillconflict ? "postponed" : "manual", result := newdata ]
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveNameConflictSimple(STRING rowkey, STRING method)
  {
    UPDATE this->pvt_modifications
       SET nresolution := this->SelectConflictTree(obj.nconflict, method, TRUE)
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveBaseDataConflictSimple(STRING rowkey, STRING method)
  {
    UPDATE this->pvt_modifications
       SET bresolution := this->SelectConflictTree(obj.bconflict, method, TRUE)
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Manual resolve of basedata
  PUBLIC MACRO ResolveBaseDataConflict(STRING rowkey, RECORD newdata)
  {
    UPDATE this->pvt_modifications
       SET bresolution := [ type := "manual", result := newdata ]
     WHERE COLUMN rowkey = VAR rowkey;
    this->UpdateResolveStatus();
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveInstanceConflictSimple(STRING rowkey, STRING typens, STRING method)
  {
    this->ResolveInstanceConflictInternal(rowkey, typens, method, FALSE);
  }

  /// Easy choice (mine/theirs)
  PUBLIC MACRO ResolveAllInstanceConflictsSimple(STRING rowkey, STRING method)
  {
    this->ResolveInstanceConflictInternal(rowkey, "*", method, FALSE);
  }

  PUBLIC MACRO Execute()
  {
    IF (this->AnyUnresolved())
      THROW NEW Exception("Still unresolved conflicts!");

    // No update? Then trees have not been filled, and this is a no-op
    IF (this->localversion = this->remoteversion)
      RETURN;

    // Copy the tree, and apply the conflict resolutions
    OBJECT tree := this->GetResolvedModTree();

    OBJECT trans := GetPrimaryWebhareTransactionObject();
    trans->BeginLockedWork("blexdev_blit:" || this->workingcopy->id);

    TRY
    {
      OBJECT dtree_local := CreateWHFSDescriptionTree(this->workingcopy,
          [ overrideinclusionsettings := this->dtree_remote
          ]);
      OBJECT rtree_local;
      IF (NOT this->dtree_local->has_errors)
      {
        rtree_local := dtree_local->BuildRepositoryTree();
        UpdateFSCache(rtree_local);
      }

      IF (NOT ObjectExists(rtree_local) OR rtree_local->GetTreeHash() != this->localtreehash)
        THROW NEW Exception("The local tree has changed during the update process");

//      PRINT("** Apply update\nTree:\n" || this->dtree_local->ShortDump() || "Update\n" || tree->ShortDump());

      tree->Apply(this->workingcopy);

      OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");

      RECORD repodata := repostype->GetInstanceData(this->workingcopy->id);
      repodata.repository_version := this->remote_status.version;
      repodata.repository_roothash := this->remote_status.roothash;
      repodata.repository_path := this->remote_status.path;

      repostype->SetInstanceData(this->workingcopy->id, repodata);

      RECORD ARRAY errors := trans->CommitWork();
      IF (RecordExists(errors))
        THROW NEW Exception(AnyToString(errors, "boxed"));

      BroadcastEvent("publisher:blit.repo." || repodata.repository_uuid, DEFAULT RECORD);
    }
    FINALLY
    {
      IF (trans->IsWorkOpen())
        trans->RollbackWork();
    }
  }
>;

PUBLIC STATIC OBJECTTYPE BlitCommitter
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Repository
  OBJECT repoconnector;

  RECORD repodata;

  OBJECT workingcopy;

  RECORD remote_status;

  OBJECT datakeeper;

  /// Repository tree of local data
  OBJECT rtree_local;

  /// Description tree of local data
  OBJECT dtree_local;

  /// Repository tree of remote head
  OBJECT rtree_parent;

  /// Description tree of remote head
  OBJECT dtree_parent;

  /// Description tree with modifications to transform remote tree into local tree
  OBJECT moddtree;

  BOOLEAN pvt_cleanwhitespace;

  RECORD ARRAY pvt_conflictmarkers;

  RECORD ARRAY pvt_cleanedwhitespace;

  RECORD ARRAY pvt_modificationlist;

  STRING pvt_comment;

  RECORD hooks;

  RECORD ARRAY pvt_messages;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY localversion(GetWorkingCopyVersion, -);

  PUBLIC PROPERTY remoteversion(GetRemoteVersion, -);

  PUBLIC PROPERTY modificationlist(pvt_modificationlist, -);

  PUBLIC PROPERTY comment(pvt_comment, pvt_comment);

  PUBLIC PROPERTY messages(pvt_messages, -);

  /// Whether whitespace cleaning is enabled (defaults to TRUE)
  PUBLIC PROPERTY cleanwhitespace(pvt_cleanwhitespace, SetCleanWhitespace);

  /** List of (text) files that had whitespace cleanups performed
      @cell(integer) id WHFS id of the file
      @cell(string array) path
      @cell(blob) data Whitespace cleaned data
  */
  PUBLIC PROPERTY cleanedwhitespace(pvt_cleanedwhitespace, -);

  /** List of (text) files that have conflict markers in them
      @cell(integer) id WHFS id of the file
      @cell(string array) path
      @cell(blob) data Data (whitespace cleaned if @a cleanwhitespace is TRUE!)
  */
  PUBLIC PROPERTY conflictmarkers(pvt_conflictmarkers, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT repoconnector, OBJECT workingcopy)
  {
    this->repoconnector := repoconnector;
    this->workingcopy := workingcopy;
    this->pvt_cleanwhitespace := TRUE;

    this->datakeeper := MakeTreeDataKeeper();

    this->RefreshModificationList();
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  INTEGER FUNCTION GetWorkingCopyVersion()
  {
    RETURN this->repodata.repository_version;
  }

  INTEGER FUNCTION GetRemoteVersion()
  {
    RETURN this->remote_status.version;
  }

  MACRO SetCleanWhitespace(BOOLEAN newvalue)
  {
    this->pvt_cleanwhitespace := newvalue;
    this->RefreshModificationList();
  }

  RECORD FUNCTION CheckRepoVersions(OBJECT root)
  {
    TRY
    {
      RECORD rec := LocateDesignConfig(root);

      FOREVERY (RECORD reporec FROM rec.data.repositories)
      {
        IF (ObjectExists(reporec.localversion))
        {
          OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
          RECORD repodata := repostype->GetInstanceData(reporec.localversion->id);

          OBJECT browser, repo, repoconnector;

          TRY
          {
            browser := NEW WebBrowser;
            STRING repourl := CalculateRepositoryURL(repodata.repository_url, TRUE);
            repo := OpenRemoteRepository(repodata.repository_url, repodata.repository_uuid, browser, DEFAULT RECORD);

            RECORD status := GetWorkingCopyGlobalStatus(repo, reporec.localversion);
            IF (status.modified)
            {
              IF (status.localversion > reporec.version) //an update is coming in anyway, so prep for that
                UpdateRepositoryVersion(rec.folder, reporec.uuid, status.localversion, repo);

              RETURN
                  [ type :=         "warning"
                  , msg :=          GetTid("publisher:filemanager.dependencies.messages.uncommitted", EncodeJava(reporec.localversion->name))
                  , action :=       "commit"
                  , folder :=       reporec.localversion
                  ];
            }
            ELSE IF (status.localversion < reporec.version)
            {
              RETURN
                  [ type :=         "warning"
                  , msg :=          GetTid("publisher:filemanager.dependencies.messages.notuptodate", EncodeJava(reporec.localversion->name))
                  , action :=       "update"
                  , folder :=       reporec.localversion
                  ];
            }
            ELSE IF (status.localversion != reporec.version)
            {
              // Make sure the committed version matches the currenly checked out repository version
              UpdateRepositoryVersion(rec.folder, reporec.uuid, status.localversion, repo);
            }
          }
          FINALLY
          {
            IF (ObjectExists(repo))
              CloseRemotingSession(repo);
            browser->Close();
          }

          BREAK;
        }
      }
    }
    CATCH (OBJECT e)
    {
    }

    RETURN DEFAULT RECORD;
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC MACRO RefreshModificationList()
  {
    OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
    this->repodata := repostype->GetInstanceData(this->workingcopy->id);

    OBJECT repo := GetRepoFromObj(this->repoconnector);

    this->pvt_messages := DEFAULT RECORD ARRAY;

    /* Run before refresh hooks. Designfiles uses this to check connected local repo's and to update the version
    */
    RECORD res := this->CheckRepoVersions(this->workingcopy);
    IF (RecordExists(res))
      INSERT res INTO this->pvt_messages AT END;

    OBJECT trans := GetPrimaryWebhareTransactionObject();
    trans->BeginLockedWork("blexdev_blit:" || this->workingcopy->id);

    TRY
    {
      // Generate description tree of local data - cleanup whitespace
      this->dtree_local := CreateWHFSDescriptionTree(this->workingcopy, [ cleanwhitespace := this->pvt_cleanwhitespace ]);

      this->pvt_conflictmarkers :=
          SELECT rowkey :=            "path-" || Detokenize(path, "/")
               , id :=                cachedata.id
               , name
               , path
               , data
               , modificationdate :=  cachedata.modificationdate
            FROM this->dtree_local->GetAllTreeObjects() AS obj
           WHERE NOT isfolder
             AND CellExists(obj, "CACHEDATA")
             AND CellExists(cachedata, "ID")
             AND cachedata.has_conflictmarker;

      this->pvt_cleanedwhitespace :=
          SELECT rowkey :=            "path-" || Detokenize(path, "/")
               , id :=                cachedata.id
               , name
               , path
               , data
               , modificationdate :=  cachedata.modificationdate
            FROM this->dtree_local->GetAllTreeObjects() AS obj
           WHERE NOT isfolder
             AND CellExists(obj, "CACHEDATA")
             AND CellExists(cachedata, "ID")
             AND cachedata.modified_whitespace;

      // Generate repository tree, store file->hash mapping in fscache and hash->blobs into datakeeper
      this->rtree_local := this->dtree_local->BuildRepositoryTree();
      UpdateFSCache(this->rtree_local);
      this->datakeeper->AddTreeData(this->rtree_local);

      this->remote_status := repo->GetStatus();

      // Get HEAD of remote repository, populate with blobs
      this->rtree_parent := EncapsulateRawRepositoryTree(GetDecompressedObjectTree(repo, this->repodata.repository_roothash));
      GetTreeData(repo, this->rtree_parent, this->datakeeper);

      // Generate whfs description tree from remote repository tree FIXME Find out WHY, and EXPLAIN!!!
      // DANGEROUS: if you revert your local inclusion settings, this dtree won't be rebuilt!!
      this->dtree_parent := CreateWHFSDescriptionTreeFromRepository(this->rtree_parent)->ApplyInclusionSettings(this->dtree_local);

      // Calculate the tree that modifies the remote tree to the local tree
      OBJECT diffrtree := RepositoryTreeDiff3(this->rtree_parent, this->rtree_parent, this->rtree_local);

      this->moddtree := GenerateWHFSDescriptionDiffTree(diffrtree);

      // Filter by local inclusion settings. FIXME Find out WHY, and EXPLAIN!!!
      this->moddtree := this->moddtree->ApplyInclusionSettings(this->dtree_local);

      this->pvt_modificationlist :=
          SELECT rowkey :=          "path-" || Detokenize(path, "/")
               , path
               , status
               , isfolder
               , whitespacechanged := CellExists(mod, "CACHEDATA") ? CACHEDATA : DEFAULT RECORD
            FROM this->moddtree->GetAllTreeObjects() AS mod
           WHERE status != "merge";

      IF (this->remote_status.version != this->repodata.repository_version)
      {
        INSERT
            [ type :=     "error"
            , msg :=      GetTid("publisher:blit.errors.notuptodate")
            , action :=   "update"
            , folder :=   this->workingcopy
            ] INTO this->pvt_messages AT 0;
      }
    }
    FINALLY
    {
      trans->RollbackWork();
    }

    this->datakeeper->WriteToRepositoryCache();
  }

  PUBLIC RECORD FUNCTION GetObjectVersions(STRING rowkey)
  {
    RECORD sel := SELECT * FROM this->pvt_modificationlist WHERE COLUMN rowkey = VAR rowkey;
    IF (NOT RecordExists(sel))
      THROW NEW Exception("Rowkey does not exist in list");

    RETURN
        [ parent :=     this->dtree_parent->GetObjectByPath(sel.path)
        , changes :=    this->moddtree->GetObjectByPath(sel.path)
        ];
  }

  PUBLIC RECORD FUNCTION Commit()
  {
    STRING ARRAY rowkeys := SELECT AS STRING ARRAY rowkey FROM this->pvt_modificationlist;
    RETURN this->CommitSelection(rowkeys);
  }

  PUBLIC RECORD FUNCTION CommitSelection(STRING ARRAY rowkeys)
  {
    IF (ToLowercase(this->repodata.repository_url) LIKE "*/repository_anon/")
      THROW NEW Exception("Cannot commit to a readonly repository");

    OBJECT repo := GetRepoFromObj(this->repoconnector);

    OBJECT trans := GetPrimaryWebhareTransactionObject();
    trans->BeginLockedWork("blexdev_blit:" || this->workingcopy->id);

    STRING returnstatus;
    BOOLEAN allaccepted;

    TRY
    {
      // Get list of accepted modifications
      RECORD ARRAY accepted :=
          SELECT path
            FROM this->pvt_modificationlist
           WHERE rowkey IN rowkeys;

      IF (LENGTH(accepted) = 0)
        RETURN [ status := "nochange" ];

      allaccepted := NOT RecordExists(SELECT FROM this->pvt_modificationlist WHERE rowkey NOT IN rowkeys);

      // Check for modifications. Be resilient for errors, treat them as modifications
      OBJECT check_dtree_local := CreateWHFSDescriptionTree(this->workingcopy, [ cleanwhitespace := this->pvt_cleanwhitespace  ]);
      OBJECT check_rtree_local;
      IF (NOT check_dtree_local->has_errors)
      {
        check_rtree_local := check_dtree_local->BuildRepositoryTree();
        UpdateFSCache(check_rtree_local);
      }

      IF (NOT ObjectExists(check_rtree_local) OR check_rtree_local->GetTreeHash() != this->rtree_local->GetTreeHash())
      {
        trans->RollbackWork();
        this->RefreshModificationList();
        RETURN [ status := "treechanged" ];
      }

      // Keep only those modifications in the diff tree
      OBJECT fdf := FilterWHFSDescriptionDiffTree(this->moddtree, accepted);

      // Retrieve the parent tree from the repository, build the description tree from it
      OBJECT rtree_parent := EncapsulateRawRepositoryTree(GetDecompressedObjectTree(repo, this->repodata.repository_roothash));
      GetTreeData(repo, rtree_parent, this->datakeeper);
      OBJECT dtree_parent := CreateWHFSDescriptionTreeFromRepository(rtree_parent);

      // Apply the filtered diff tree, and convert to repository tree
      OBJECT fdtree := fdf->ApplyOnDescriptionTree(dtree_parent);

      // Apply (new) inclusion settings to updated tree
      fdtree := fdtree->ApplyInclusionSettings(DEFAULT OBJECT);

      // Filter out non-necessary type descriptions
      fdtree := fdtree->FilterTypeDescriptions();

      OBJECT frtree := fdtree->BuildRepositoryTree();
/*
      // And check it, before uploading it FIXME: still needed now we allow external references?
      IF (NOT fdtree->CheckReferences())
        THROW NEW Exception("Error checking references");
*/
      // Get cheap pre-list of existing objects (we already have it locally)
      RECORD ARRAY current_remote_objects :=
          SELECT hash
            FROM rtree_parent->GetAllTreeObjects()
        ORDER BY hash;

      // Get list of objects
      RECORD ARRAY objects := frtree->GetAllTreeObjects();

      RECORD ARRAY candidate_missing_objects :=
          SELECT *
            FROM objects
           WHERE NOT RecordLowerBound(current_remote_objects, objects, [ "HASH" ]).found;

      RECORD ARRAY candidate_missing_object_status := repo->CheckObjectsPresence(
          SELECT hash
               , isfolder
            FROM candidate_missing_objects
        ORDER BY hash);

      RECORD curr_repodata := repo->GetStatus();

      RECORD result :=
          [ status := "notuptodate"
          , version := curr_repodata.version
          ];

      IF (curr_repodata.version = this->repodata.repository_version)
      {
        RECORD ARRAY repoobjects;
        BOOLEAN have_multiadd := MemberExists(repo, "AddObjects");

        // ADDME: upload list progress dialog?
        FOREVERY (RECORD obj FROM candidate_missing_objects)
          IF (candidate_missing_object_status[RecordLowerBound(candidate_missing_object_status, obj , [ "HASH" ]).position].status != "found")
          {
            IF (obj.isfolder)
            {
              //PRINT("Upload folder '" || Detokenize(obj.path, "/") || "'\n");

              // Only send name and hash of children, filter out data blob and recursive folder children
              RECORD ARRAY childrendata :=
                  SELECT name
                       , hash
                    FROM obj.children;

              IF (have_multiadd)
                INSERT [ hash := obj.hash, isfolder := TRUE, objects := childrendata ] INTO repoobjects AT END;
              ELSE
                repo->AddFolder(obj.hash, childrendata);
            }
            ELSE
            {
              //PRINT("Upload file   '" || Detokenize(obj.path, "/") || "'\n");
              IF (have_multiadd)
                INSERT [ hash := obj.hash, isfolder := FALSE, data := obj.data ] INTO repoobjects AT END;
              ELSE
                repo->AddFile(obj.hash, obj.data);
            }
          }

        IF (have_multiadd)
          repo->AddObjects(repoobjects);

        result := repo->CommitTree(this->repodata.repository_version, this->repodata.repository_roothash, frtree->GetTreeHash(), this->pvt_comment);
      }

      SWITCH (result.status)
      {
      CASE "ok"
        {
          this->repodata.repository_version := result.version;
          this->repodata.repository_roothash := result.roothash;
          this->repodata.repository_path := curr_repodata.path;

          OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
          repostype->SetInstanceData(this->workingcopy->id, this->repodata);

          returnstatus := "ok";

          trans->CommitWork();

          BroadcastEvent("publisher:blit.repo." || this->repodata.repository_uuid, DEFAULT RECORD);

          IF (allaccepted)
            this->pvt_modificationlist := DEFAULT RECORD ARRAY;
          ELSE
            this->RefreshModificationList();

          RETURN
              [ status :=           "ok"
              , version :=          result.version
              , allcommitted :=     allaccepted
              ];
        }
      CASE "notuptodate"
        {
          RETURN
              [ status :=           "notuptodate"
              , remote_version :=   result.version
              , local_version :=    this->repodata.repository_version
              ];
        }
      CASE "nochange"
        {
          RETURN
              [ status :=           "nochange"
              ];
        }
      DEFAULT // rootnotavailable
        {
          RETURN
              [ status :=           "unhandledstatus"
              , resultstatus :=     result.status
              ];
        }
      }
    }
    FINALLY
    {
      IF (trans->IsWorkOpen())
        trans->RollbackWork();

      // Make sure the stuff is in the cache
      this->datakeeper->WriteToRepositoryCache();
    }
  }

  PUBLIC RECORD FUNCTION RevertSelection(STRING ARRAY rowkeys)
  {
    OBJECT trans := GetPrimaryWebhareTransactionObject();
    trans->BeginLockedWork("blexdev_blit:" || this->workingcopy->id);

    TRY
    {
      // Check for modifications. Be resilient for errors, treat them as modifications
      OBJECT check_dtree_local := CreateWHFSDescriptionTree(this->workingcopy, [ cleanwhitespace := this->pvt_cleanwhitespace  ]);
      OBJECT check_rtree_local;
      IF (NOT check_dtree_local->has_errors)
      {
        check_rtree_local := check_dtree_local->BuildRepositoryTree();
        UpdateFSCache(check_rtree_local);
      }

      IF (NOT ObjectExists(check_rtree_local) OR check_rtree_local->GetTreeHash() != this->rtree_local->GetTreeHash())
      {
        trans->RollbackWork();
        this->RefreshModificationList();
        RETURN [ status := "treechanged" ];
      }

      OBJECT diffrtree := RepositoryTreeDiff3(this->rtree_local, this->rtree_local, this->rtree_parent);

      RECORD ARRAY torevert :=
          SELECT path
            FROM this->pvt_modificationlist
          WHERE rowkey IN rowkeys;

      OBJECT changes := GenerateWHFSDescriptionDiffTree(diffrtree);
      OBJECT filtered := FilterWHFSDescriptionDiffTree(changes, torevert);

      filtered->Apply(this->workingcopy);

      trans->CommitWork();

      BroadcastEvent("publisher:blit.repo." || this->repodata.repository_uuid, DEFAULT RECORD);

      this->RefreshModificationList();
      RETURN [ status := "ok" ];
    }
    FINALLY
    {
      IF (trans->IsWorkOpen())
        trans->RollbackWork();
    }
  }
>;

/** Does a working copy have local updates ? */
PUBLIC BOOLEAN FUNCTION IsWorkingCopyModified(OBJECT workingcopy, STRING roothash)
{
  // Construct a whfs-d-tree from the local working copy.
  OBJECT dtree_local := CreateWHFSDescriptionTree(workingcopy);//, [ cleanwhitespace := TRUE ]);

  // Build a repository tree form that d-tree, and store id->hash cache in FS cache
  OBJECT rtree_local := dtree_local->BuildRepositoryTree();
  UpdateFSCache(rtree_local);

  RETURN roothash != rtree_local->GetTreeHash();
}

/** Global status of repository (quicker to calculate than full per-file changes)
*/
PUBLIC RECORD FUNCTION GetWorkingCopyGlobalStatus(OBJECT repoconnector, OBJECT workingcopy)
{
  OBJECT repostype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
  RECORD repodata := repostype->GetInstanceData(workingcopy->id);

  OBJECT repo := GetRepoFromObj(repoconnector);
  RECORD remote_status := repo->GetStatus();

  // Get datakeeper
  OBJECT datakeeper := MakeTreeDataKeeper();

  // Construct a whfs-d-tree from the local working copy.
  OBJECT dtree_local := CreateWHFSDescriptionTree(workingcopy, DEFAULT RECORD);

  // Build a repository tree form that d-tree, and store id->hash cache in FS cache
  OBJECT rtree_local := dtree_local->BuildRepositoryTree();
  UpdateFSCache(rtree_local);

  RETURN
      [ modified :=         IsWorkingCopyModified(workingcopy, repodata.repository_roothash)
      , pendingupdates :=   repodata.repository_version != remote_status.version
      , localversion :=     repodata.repository_version
      , remoteversion :=    remote_status.version
      ];
}

PUBLIC RECORD ARRAY FUNCTION GetMassWorkingCopiesStatus(OBJECT user, STRING url, STRING ARRAY uuids)
{
  OBJECT browser := NEW WebBrowser;
  RECORD ARRAY results;
  RECORD opts := GetServerCredentials(user, url);

  FOREVERY(STRING uuid FROM uuids)
  {
    RECORD repository := [ uuid := uuid
                         , remoteerror := ""
                         , version := 0
                         ];

    // ADDME: Get servers to provide a mass 'get status' API
    TRY
    {
      OBJECT repos := OpenRemoteRepository(url, uuid, browser, opts);
      RECORD status := repos->GetRepo()->GetStatus();
      repository.version := status.version;
    }
    CATCH(OBJECT e)
    {
      repository.remoteerror := e->what;
    }
    INSERT repository INTO results AT END;
  }
  RETURN results;
}

PUBLIC RECORD ARRAY FUNCTION EnrichWorkingCopiesWithLocalStatus(RECORD ARRAY workingcopies)
{
  FOREVERY(RECORD copy FROM workingcopies)
  {
    BOOLEAN ismod;
    STRING localerror;
    TRY
    {
      ismod := IsWorkingCopyModified(OpenWHFSObject(copy.id), copy.repository_roothash);
    }
    CATCH(OBJECT e)
    {
      localerror := e->what;
    }
    INSERT CELL modified := ismod INTO copy;
    INSERT CELL localerror := localerror INTO copy;
    workingcopies[#copy] := copy;
  }
  RETURN workingcopies;
}

/* List working copies on the local server */
PUBLIC RECORD ARRAY FUNCTION ListWorkingCopies(STRING finduuid)
{
  OBJECT blittype := OpenWHFSType("http://www.webhare.net/xmlns/blexdev_blit/v2/checkedoutfolder");
  INTEGER ARRAY blitfolderids := blittype->FindObjectsByMemberValueMask("repository_uuid", finduuid || "*", FALSE);
  RECORD ARRAY blitfolders := SELECT id
                                   , whfspath
                                FROM system.fs_objects WHERE id IN blitfolderids AND isactive;

  blitfolders := SELECT id
                      , whfspath
                      , repository_url
                      , repository_path
                      , repository_uuid
                      , repository_roothash
                      , localversion := repository_version
                   FROM blittype->EnrichWithBulkData(blitfolders, ["repository_url","repository_path","repository_uuid","repository_version","repository_roothash"]);

  RETURN blitfolders;
}

PUBLIC MACRO UpdateRepositoryVersion(OBJECT designfilesfolder, STRING uuid, INTEGER newversion, OBJECT repo)
{
  OBJECT designfoldertype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfolder");
  OBJECT localsettingstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/localdesignsettings");

  RECORD data := designfoldertype->GetInstanceData(designfilesfolder->id);
  RECORD localdata := localsettingstype->GetInstanceData(designfilesfolder->id);

  BOOLEAN has_change;
  FOREVERY (RECORD reporec FROM data.repositories)
  {
    IF (reporec.uuid = uuid)
    {
      data.repositories[#reporec].version := newversion;
      has_change := TRUE;
    }

    // If not connected to a local folder, make sure the requested version is present
    IF ((SELECT AS INTEGER localversion FROM localdata.repositories WHERE repositories.uuid = reporec.uuid) = 0)
      GetCheckoutTree(reporec.server, reporec.uuid, newversion, repo);
  }

  OBJECT trans := GetPrimaryWebHareTransactionObject();
  trans->BeginWork();
  designfoldertype->SetInstanceData(designfilesfolder->id, data);
  trans->CommitWork();

  IF (has_change)
    BroadcastEvent("blexdev_designfiles:resetdependencies", DEFAULT RECORD);
}


PUBLIC RECORD FUNCTION LocateDesignConfig(OBJECT file)
{
  OBJECT designtype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfolder");
  OBJECT depslocaltype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/localdesignsettings");

  RECORD folderinfo := SELECT highestparent, type FROM system.fs_objects WHERE id=file->id AND isactive;

  OBJECT designfolder;
  IF(RecordExists(folderinfo) AND folderinfo.type = designtype->id) //the user is pointing us straight to the requested designfolder
  {
    designfolder := file;
  }
  ELSE
  {
    IF(NOT RecordExists(folderinfo) OR folderinfo.highestparent=0)
      THROW NEW Exception("Cannot detect the site root folder for fs object #" || file->id);
    IF(folderinfo.highestparent=1)//it's the repository
      THROW NEW Exception("Cannot detect the site root folder for fs object #" || file->id || " (it's in the repository, we need an explicit reference to the design folder)");

    RECORD ARRAY designfolders := SELECT id FROM system.fs_objects WHERE parent = folderinfo.highestparent AND type = designtype->id;
    IF(Length(designfolders)=0)
      THROW NEW Exception("Cannot find a design folder in root folder #" || folderinfo.highestparent);
    IF(Length(designfolders)>1)
      THROW NEW Exception("Multiple design folders in root folder #" || folderinfo.highestparent);
    designfolder := OpenWHFSObject(designfolders[0].id);
  }

  RECORD data := designtype->GetInstanceData(designfolder->id);
  RECORD currentlocaldeps := depslocaltype->GetInstanceData(designfolder->id);

  data.repositories :=
      SELECT *
           , localversion :=
                  SELECT AS OBJECT OpenWHFSObject(localversion)
                    FROM currentlocaldeps.repositories AS localreps
                   WHERE localreps.uuid = repositories.uuid
        FROM data.repositories;

  RETURN
      [ folder :=       designfolder
      , data :=         data
      ];
}


/** Make sure a version from a repository is checked out
    @param repo_hosturl HTTP url of repository host
    @param repo_uuid UUID of the repository
    @param version Version to check out
    @param getrepo Function to get the repo when needed
    @return Folder of working copy
*/
PUBLIC OBJECT FUNCTION GetCheckoutTree(STRING repo_hosturl, STRING repo_uuid, INTEGER version, OBJECT repoconnector)
{
  OBJECT reporoot := GetRepositoryStoreFolder(repo_uuid);

  STRING versionfoldername := "v" || version;
  OBJECT versionfolder := reporoot->OpenByPath(versionfoldername);
  IF (NOT ObjectExists(versionfolder))
  {
    IF(NOT ObjectExists(repoconnector))
      THROW NEW Exception("The version '" || reporoot->whfspath || versionfoldername || "' does not exist and we do not have repository access to generate it");

    OBJECT trans := GetPrimary();
    trans->BeginLockedWork("publisher:create_designfiles_checkout");

    TRY
    {
      versionfolder := reporoot->OpenByPath(versionfoldername);
      IF (NOT ObjectExists(versionfolder))
      {
        OBJECT repo := GetRepoFromObj(repoconnector);

        OBJECT fstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/designfiles/cachedfolder");

        RECORD res := CheckoutWorkingCopy(repo, reporoot, versionfoldername, repo_hosturl, [ readonly := TRUE, version := version ]);
        IF (RecordExists(res.hashestree->root))
          SetHashesIntoCachedFolders(res.folder, res.hashestree->root, fstype);


        WriteWorkingCopyPackagesToDisk(res.folder, FALSE, TRUE, fstype);

        versionfolder := res.folder;
        version := res.newversion;
      }
    }
    FINALLY
    {
      trans->CommitWork();
    }
  }

  RETURN versionfolder;
}

/** Get the webhare-private folder for a repository
    @param uuid
    @return Repository folder object
*/
PUBLIC OBJECT FUNCTION GetRepositoryStoreFolder(STRING uuid)
{
  IF(uuid="")
    THROW NEW Exception("No UUID specified in call to GetRepositoryStoreFolder");

  OBJECT root := OpenWHFSObject(10); // webhare-private

  OBJECT folder_repo := root->OpenByPath("publisher/designfiles/" || uuid);
  IF (ObjectExists(folder_repo))
    RETURN folder_repo;

  OBJECT trans := GetPrimary();
  trans->BeginLockedWork("publisher:create_designfiles_repofolder");

  OBJECT folder_publisher := root->EnsureFolder([ name := "publisher" ] );
  OBJECT folder_designfiles := folder_publisher->EnsureFolder([ name := "designfiles" ]);
  folder_repo := folder_designfiles->EnsureFolder([ name := uuid ]);

  trans->CommitWork();

  RETURN folder_repo;
}

MACRO SetHashesIntoCachedFolders(OBJECT parent, RECORD rec, OBJECT fstype)
{
  OBJECT fsobj := rec.name = "" ? parent : parent->OpenByPath(rec.name);
  fstype->SetInstanceData(fsobj->id, [ hash := SubString(rec.hash, 2) ]);

  IF (rec.isfolder)
    FOREVERY (RECORD child FROM rec.children)
      SetHashesIntoCachedFolders(fsobj, child, fstype);
}

/** Write all packages to the disk cache. Recursively adds all subfolders too. Use only under single lock.
    @param folder Packages folder (hash must be stored in cache instance)
*/
PUBLIC MACRO WriteWorkingCopyPackagesToDisk(OBJECT folder, BOOLEAN force, BOOLEAN recurse, OBJECT fstype)
{
  RECORD ARRAY contents :=
      SELECT id
           , name
           , isfolder
           , data
        FROM system.fs_objects
       WHERE parent = folder->id;

  RECORD ARRAY files :=
      SELECT *
        FROM contents
       WHERE NOT isfolder;

  IF (RecordExists(files))
  {
    STRING hash := fstype->GetInstanceData(folder->id).hash;

    STRING basepath := GetCachedAssetPath(hash, "");
    IF (NOT RecordExists(GetDiskFileProperties(basepath)) OR force)
    {
      // Package not available on disk. Can use _tmp as temp name because under single lock.
      STRING tmppath := GetCachedAssetPath("_tmp", "");
      IF (RecordExists(GetDiskFileProperties(tmppath)))
        DeleteDiskDirectoryRecursive(tmppath);
      CreateDiskDirectoryRecursive(tmppath, TRUE);

      FOREVERY (RECORD rec FROM files)
        StoreDiskFile(MergePath(tmppath, ToLowercase(rec.name)), rec.data, [overwrite := TRUE]);

      MoveDiskPath(tmppath, basepath);
    }
  }

  IF (recurse)
  {
    FOREVERY (RECORD obj FROM contents)
      IF (obj.isfolder)
        WriteWorkingCopyPackagesToDisk(OpenWHFSObject(obj.id), TRUE, force, fstype);
  }
}

/** Return the path of an asset
    @param baseroot Hash of package contents
    @param subpath Path of name within the package (optional)
    @return Path of the package (file).
*/
PUBLIC STRING FUNCTION GetCachedAssetPath(STRING baseroot, STRING subpath)
{
  RETURN GetWebhareConfiguration().varroot || "publisher.cache/" || ToLowercase(baseroot || (subpath != "" ? "/" || subpath : ""));
}

