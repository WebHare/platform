<?wh

LOADLIB "wh::os.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/remoting/client.whlib";

LOADLIB "mod::publisher/lib/internal/blit/api.whlib";
LOADLIB "mod::publisher/lib/internal/blit/hashapi.whlib";
LOADLIB "mod::publisher/lib/internal/blit/support.whlib";

RECORD FUNCTION BlitAuthHandler(RECORD result, STRING realm, STRING url)
{
  RETURN result;
}

MACRO PrintWithNewline(STRING s)
{
  PRINT(s || "\n");
}

PUBLIC OBJECT FUNCTION LoginToRepository(RECORD repodata, OBJECT user, RECORD options)
{
  FOREVERY (RECORD rec FROM UnpackRecord(options))
    IF (rec.name NOT IN [ "DONTTERMINATE", "SHOWERRORFUNC" ])
      THROW NEW Exception("Illegal option '" || rec.name || "'");

  BOOLEAN dontterminate := CellExists(options, "DONTTERMINATE") AND options.dontterminate;
  FUNCTION PTR showerror := CellExists(options, "SHOWERRORFUNC") AND options.showerrorfunc != DEFAULT FUNCTION PTR
      ? options.showerrorfunc
      : PTR PrintWithNewline;

  //FIXME dontc= store usernames/passwords, instead exchange them for a blitserver-specific cookie on first login, and use that? either way, find -something- that avoids storing actual credentials
  STRING username,password;

  STRING ARRAY credinfo := Tokenize(user->GetRegistryKey(GetCredentialsRegistryKey(repodata.repository_url),""),":");
  IF(Length(credinfo)=2)
  {
    username := DecodeBase64(credinfo[0]);
    password := DecodeBase64(credinfo[1]);
  }

  OBJECT connector := GetRepoConnectorByUUID(repodata.repository_url, repodata.repository_uuid);

  RECORD res;
  FOR (INTEGER i := 0; i < 3; i := i + 1)
  {
    IF (password != "" OR repodata.repository_url LIKE "*/repository_anon/")
    {
      connector->browser->onauth := PTR BlitAuthHandler([ username := username, password := password ], #1, #2);

      TRY
      {
        res := InvokeRemoteFunctionWithBrowser(connector->browser, repodata.repository_url || "OpenByUUID", repodata.repository_uuid, blitapiversion);
        BREAK;
      }
      CATCH (OBJECT e)
      {
        RECORD status := connector->browser->GetHTTPStatus();
//        dumpvalue(status,'tree');
        IF (NOT RecordExists(status) OR status.code != 401)
        {
          showerror("Cannot contact repository: " || e->what);
          RETURN DEFAULT OBJECT;
        }
      }
    }

    PRINT("Authentication for host " || UnpackURL(repodata.repository_url).host || " " || (i = 0 ? "needed" : "failed, pleasy try again") || "\n");
    PRINT("Enter username: ");
    username := ReadLineFrom(0, 4096, TRUE);
    PRINT("Enter password: ");
    SetConsoleEcho(FALSE);
    password := ReadLineFrom(0, 4096, TRUE);
    SetConsoleEcho(TRUE);
    PRINT("\n");
    IF (username = "")
    {
      IF (dontterminate)
        RETURN DEFAULT OBJECT;
      SetConsoleExitCode(1);
      TerminateScript();
    }
  }

  // three times tried to login and failed
  IF (NOT RecordExists(res))
  {
    IF (dontterminate)
    {
      PRINT("Authentication failed too many times\n");
      RETURN DEFAULT OBJECT;
    }
    PRINT("Authentication failed too many times, quitting\n");
    SetConsoleExitCode(1);
    TerminateScript();
  }

  CheckServerAPILevel(res);

  IF (username != "")
  {
    GetPrimary()->BeginWork();
    user->SetRegistryKey(GetCredentialsRegistryKey(repodata.repository_url), EncodeBase64(username) || ":" || EncodeBase64(password));
    GetPrimary()->CommitWork();
  }

  connector->SetRepo(res.repo);

  RETURN connector;
}

