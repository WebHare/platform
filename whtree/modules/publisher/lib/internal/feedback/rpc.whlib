<?wh


LOADLIB "mod::system/lib/cluster.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";

LOADLIB "mod::publisher/lib/internal/feedback/feedbacksupport.whlib";

LOADLIB "mod::wrd/lib/auth.whlib";


PUBLIC RECORD FUNCTION RPC_StoreFeedback(STRING pathname, STRING scope, RECORD data)
{
  data := EnforceStructure(
      [ version := 0
      , screenshot :=
        [ htmlattrs := [ [ name := "", value := "" ] ]
        , stylesheets := STRING[]
        , bodyattrs := [ [ name := "", value := "" ] ]
        , bodyContents := ""
        ]
      , size :=
        [ width := 0
        , height := 0
        ]
      , element :=
        [ top := 0
        , left := 0
        , width := 0
        , height := 0
        ]
      , browser := ""
      , device := ""
      , useragent := ""
      , extradata := DEFAULT RECORD
      ], data);

  RECORD userdata;
  TRY
  {
    OBJECT authplugin := GetWRDAuthPlugin(GetWebOriginURL(pathname));
    IF (ObjectExists(authplugin->userapi))
      userdata := authplugin->userapi->GetUser(authplugin->GetLoggedInEntity())->GetUserDataForLogging();
  }
  CATCH(OBJECT e)
  {
    LogHarescriptException(e);
  }

  GetPrimary()->BeginWork();
  TRY
  {
    STRING guid := StoreFeedback(scope, CELL[ ...data, status := "creating", userdata ]);
    RETURN CELL
        [ success := TRUE
        , guid
        ];
  }
  // Use FINALLY here to catch the exception, so we can safely rollback or commit in case of error resp. success (using CATCH
  // to catch the exception 'eats' the exception)
  FINALLY (OBJECT e)
  {
    IF (ObjectExists(e))
    {
      GetPrimary()->RollbackWork();
      RETURN
          [ success := FALSE
          , error := e->what
          ];
    }
    ELSE
      GetPrimary()->CommitWork();
  }
}
