<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::filetypes/xml.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/support.whlib";

LOADLIB "mod::system/lib/commonxml.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/tasks.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/rightsmgmt.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whfs/events.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/whfs/objects.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";

PUBLIC RECORD __webdesign_config; //used to initialize webdesign configuration

//eventmasks to use when caching site -> csp rules mappinsg
CONSTANT STRING ARRAY site_referrals_mask := [ "publisher:internal.siteprofiles.recompiled", "system:whfs.sitemeta.*", "system:sites" ];
OBJECT current_apply_rule_tester_cache;

PUBLIC STRING ARRAY FUNCTION DefaultListConfigurationNodeAttributes(OBJECT node) {
  STRING ARRAY names;
  FOREVERY(OBJECT attr FROM node->attributes->GetCurrentNodes())
    IF(attr->namespaceuri = "")
      INSERT ToUppercase(attr->nodename) INTO names AT END;
  RETURN names;
}

PUBLIC RECORD FUNCTION GetDefaultFolderSettings()
{
  RETURN [ ordering := "orderable"
         , filterscreen := ""
         , filtersettings := DEFAULT RECORD
         , contentslisthandler := [ objectname := "mod::publisher/lib/components/filelist.whlib#DefaultContentsListHandler"
                                  ]
         ];
}

BOOLEAN FUNCTION IsResourceMatch(INTEGER ARRAY rule_siteprofileids, INTEGER ARRAY test_siteprofileids)
{
  RETURN Length(rule_siteprofileids) = 0 //applies everywhere
         OR Length(ArrayIntersection(rule_siteprofileids, test_siteprofileids)) > 0;
}

BOOLEAN FUNCTION MatchPathRegex(STRING pattern, STRING path)
{
  OBJECT compiledpattern := NEW RegEx(pattern, "i"); //case insensitive
  BOOLEAN result := compiledpattern->Test(path);
  RETURN result;
}

RECORD FUNCTION UpdateListedAttributes(RECORD origrec, RECORD updatewith)
{
  FOREVERY(STRING fld FROM updatewith.haslist)
    IF(CellExists(origrec,fld))
      origrec := CellUpdate(origrec, fld, GetCell(updatewith,fld));
  RETURN origrec;
}

PUBLIC STATIC OBJECTTYPE SiteProfileObject
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /// Name of this siteprofile (path like site:..., module:..., etc)
  PUBLIC STRING name;

  /// Modification date for the data of this siteprofile
  PUBLIC DATETIME modtime;

  /// XML document for this siteprofile
  PUBLIC OBJECT xmldoc;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(STRING name, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ xmldoc := DEFAULT OBJECT ], options);

    OBJECT fsobj;
    RECORD profdata;

    this->xmldoc := options.xmldoc;
    IF(NOT ObjectExists(this->xmldoc))
    {
      IF (ObjectExists(fsobj))
      {
        profdata :=
            [ data :=       fsobj->data
            , modified :=   fsobj->modificationdate
            ];
      }
      ELSE
        profdata := RetrieveWebHareResource(name);

      this->xmldoc := MakeXMLDocument(profdata.data, "UTF-8", TRUE);
      this->modtime := profdata.modified;
    }
    this->name := name;

    //ADDME make siteprofile code robust against corrupt xmldocs (just don't load them)
    IF(NOT ObjectExists(this->xmldoc) OR NOT ObjectExists(this->xmldoc->documentelement))
      THROW NEW Exception(`Siteprofile ${name} appears to be empty`);
  }


  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC STRING FUNCTION ParseFSPath(OBJECT node, STRING attrname)
  {
    IF(NOT node->HasAttribute(attrname))
      RETURN "";

    RETURN this->ParseFSPathString(node->GetAttribute(attrname));
  }

  PUBLIC STRING FUNCTION ParseFSPathString(STRING val)
  {
    IF(val LIKE "mod::*" OR val LIKE "site::*")
      RETURN val;

    IF(val LIKE "currentsite::*")
    {
      IF(this->name NOT LIKE "site::*")
        THROW NEW Exception("currentsite paths are not supported by siteprofiles not loaded from a site (offending path = '" || val || "')");
      RETURN Tokenize(this->name,"/")[0] || "/" || Substring(val,13);
    }
    IF(val LIKE "/*")
    {
      IF(this->name NOT LIKE "site::*")
      {
        THROW NEW Exception("currentsite paths are not supported by siteprofiles not loaded from a site (offending path = '" || val || "')");
      }
      RETURN Tokenize(this->name,"/")[0] || val;
    }
    RETURN MakeAbsoluteResourcePath(this->name, val);
  }

  PUBLIC STRING FUNCTION ParseFSTwopartPathString(STRING site, STRING fullpath)
  {
    IF(fullpath LIKE "mod::*")
      RETURN fullpath;

    IF(site!="")
      RETURN "site::" || site || (fullpath LIKE "/*" ? "" : "/") || fullpath;

    RETURN MakeAbsoluteResourcePath(this->name, fullpath);
  }
>;

PUBLIC INTEGER FUNCTION GetHareScriptTypeForMember(RECORD memberrec)
{
  //                                     0     1           2        3                4          5      6         7         8       9       10    11        12
  //member type is index of typename in ["nvt","SELECTONE","STRING","SELECTMULTIPLE","DATETIME","FILE","BOOLEAN","INTEGER","FLOAT","MONEY","nvt","WHFSREF","ARRAY"]
  SWITCH (memberrec.type)
  {
    CASE 1,2,3
    {
      RETURN TypeID(STRING);
    }
    CASE 6
    {
      RETURN TypeID(BOOLEAN);
    }
    CASE 7
    {
      RETURN TypeID(INTEGER);
    }
    DEFAULT
    {
      THROW NEW Exception("Unsupported member type " || memberrec.type);
    }
  }
}


/////////////////////////////////////////////////////////////////////
//
// APPLY/TO interpretation
//
RECORD FUNCTION GetFakeRootObject()
{
  RETURN [ id := 0,  parent := 0, parentsite := 0, fullpath := "", whfspath := "/", url := "", type := 0, indexdoc := 0 ];
}

RECORD FUNCTION GetFakeObject(BOOLEAN isfolder, INTEGER type, STRING basefullpath, STRING basewhfspath, STRING url, INTEGER parentid, INTEGER objid)
{
  IF (Right(basefullpath,1) != '/')
    basefullpath := basefullpath || '/';
  IF (Right(basewhfspath,1) != '/')
    basewhfspath := basewhfspath || '/';

  RETURN [ id := objid
         , parent := parentid
         , isfolder := isfolder
         , type := type
         , fullpath := basefullpath || "new object" || (isfolder ? "/" : "")
         , whfspath := basewhfspath || "new object" || (isfolder ? "/" : "")
         , parentsite := (SELECT AS INTEGER highestparent FROM system.fs_objects WHERE id=parentid)
         , filelink := 0
         , indexdoc := 0
         , url := url
         ];
}

RECORD FUNCTION GetBaseInfoForApplyCheck(INTEGER fsobjectid)
{
  RECORD fsobjinfo := SELECT id, parent, parentsite, type, filelink, fullpath, whfspath, indexdoc, isfolder, url FROM system.fs_objects WHERE id = fsobjectid;
  IF(NOT RecordExists(fsobjinfo))
    RETURN DEFAULT RECORD;

  RECORD siteapply := GetSiteApplicabilityInfo(fsobjinfo.parentsite);
  RECORD site;
  IF (fsobjinfo.parentsite != 0) //TODO consider caching this info with GetSiteApplicabilityInfo
  {
    site := SELECT * FROM system.sites WHERE id = fsobjinfo.parentsite;
    INSERT CELL type := siteapply.roottype  INTO site;
  }

  RECORD objectitself := fsobjinfo;
  RECORD parent := fsobjinfo.parentsite = fsobjectid ? objectitself : RECORD(SELECT * FROM system.fs_objects WHERE id = fsobjinfo.parent);
  RETURN CELL[ site
             , parent
             , obj := objectitself
             , isfile := fsobjinfo.isfolder = FALSE
             , isfake := FALSE
             , siteapply.siteprofileids
             , siteapply.sitedesign
             ];
}

RECORD FUNCTION GetFakeBaseInfoForApplyCheck(INTEGER parentfolder, BOOLEAN isfile, INTEGER ftypeid)
{
  RECORD curparent;
  IF (parentfolder != 0)
    curparent := SELECT id, parent, parentsite, fullpath, whfspath, type, indexdoc, url FROM system.fs_objects WHERE id = parentfolder;
  ELSE
    curparent := GetFakeRootObject();

  // Create a fake file/folder record, for site profiles to work
  RECORD curitem := GetFakeObject(NOT isfile, ftypeid, curparent.fullpath, curparent.whfspath, curparent.url, curparent.id, 0);
  RECORD siteapply := GetSiteApplicabilityInfo(curparent.parentsite);
  RECORD parentsite := RecordExists(curparent) ? RECORD(SELECT * FROM system.sites WHERE id = curparent.parentsite) : DEFAULT RECORD;
  IF (RecordExists(parentsite))
  {
    INSERT CELL type := siteapply.roottype INTO parentsite;
  }

  RETURN CELL[ site := parentsite
             , parent := curparent
             , obj := curitem
             , isfile
             , isfake := TRUE
             , siteapply.siteprofileids
             , siteapply.sitedesign
             ];
}

PUBLIC RECORD FUNCTION GetDefaultWebDesignInfo()
{
  RECORD webdesign := [ objectname      := "mod::publisher/lib/webdesign.whlib#WebDesignBase"
                      , witty           := "mod::publisher/lib/defaultwebdesign.witty"
                      , getdata         := ""
                      , siteresponsefactory := ""
                      , assetpack       := ""
                      , designfolder    := ""
                      , maxcontentwidth := ""
                      , wittyencoding   := "HTML"
                      , defaultgid      := ""
                      , module          := FALSE

                      , renderinfo      := DEFAULT RECORD
                      , supportserrors  := TRUE
                      , supportsaccessdenied := FALSE
                      , siteprofile     := ""
                      , is404           := FALSE
                      , contentnavstops := DEFAULT STRING ARRAY
                      , has_assetpack   := FALSE
                      ];
  RETURN webdesign;
}
OBJECTTYPE RepublishState
<
  RECORD csp;
  RECORD ARRAY repub_instructions;
  INTEGER ARRAY repub_linkdests;

  PUBLIC MACRO NEW()
  {
    this->csp := GetCachedSiteProfiles();
  }

  /**
      @param type Modification type (0=metadata changed, 1=content changed, 3=content deleted, 2=content created)
  */
  PUBLIC MACRO AddDepsOf(INTEGER fsobj, INTEGER type)
  {
    OBJECT applytester := GetApplyTesterForObject(fsobj);
    IF(NOT ObjectExists(applytester) OR applytester->__Deprecated_GetObjInfo().obj.parentsite=0)
      RETURN;

    IF(applytester->__Deprecated_GetObjInfo().isfile)
      INSERT fsobj INTO this->repub_linkdests AT END; //make sure attached links are republished

    //ADDME: Prevent repeated lookups of the same file(s) (eg a sitemap)
    FOREVERY(RECORD apply FROM applytester->__GetAppliesForcell("REPUBLISHES"))
    {
      FOREVERY(RECORD republish FROM apply.republishes)
      {
        //Skip if onchange is set, and it is not pointing to metadata, or this is a content modification
        IF(republish.onchange != "" AND (republish.onchange != "metadata" OR type != 0))
          CONTINUE;

        IF(republish.scope = "references")
        {
          RECORD ARRAY links := this->GetReferencesTo([fsobj]);
          FOREVERY(RECORD link FROM links)
            this->ExecuteRepubDep(republish, link.parent, link.parentsite, apply.siteprofileids);

        }
        ELSE IF(republish.scope="")
        {
          this->ExecuteRepubDep(republish, applytester->__Deprecated_GetObjInfo().isfile ? applytester->__Deprecated_GetObjInfo().obj.parent : fsobj, applytester->__Deprecated_GetObjInfo().obj.parentsite, apply.siteprofileids);
        }
      }
    }

    FOREVERY(RECORD apply FROM applytester->__GetAppliesForcell("SCHEDULETASKNOWS"))
      FOREVERY(RECORD scheduletask FROM apply.scheduletasknows)
      {
        TRY
        {
          ScheduleTimedTask(scheduletask.task, [ when := AddTimeTodate(scheduletask.delay, GetCurrentDatetime() )]);
        }
        CATCH(OBJECT e)
        {
          //The user seeing it is not likely the cause but siteprofiles are messed up. So just log it and ignore...
          LogHarescriptException(e);
          CONTINUE;
        }
      }

    FOREVERY(RECORD apply FROM applytester->__GetAppliesForcell("SCHEDULEMANAGEDTASKS"))
      FOREVERY(RECORD scheduletask FROM apply.schedulemanagedtasks)
      {
        TRY
        {
          ScheduleManagedTask(scheduletask.task, [ whfsid := fsobj ]);
        }
        CATCH(OBJECT e)
        {
          //The user seeing it is not likely the cause but siteprofiles are messed up. So just log it and ignore...
          LogHarescriptException(e);
          CONTINUE;
        }
      }
  }

  RECORD ARRAY FUNCTION GetReferencesTo(INTEGER ARRAY linkdests)
  {
    //Eliminate duplicate ids in the list
    linkdests := SELECT AS INTEGER ARRAY DISTINCT id FROM ToRecordArray(linkdests, "ID") WHERE id != 0;

    RECORD ARRAY linkinglist;
    WHILE(Length(linkdests)>0)
    {
      //work in groups of 1000
      INTEGER ARRAY workslice := ArraySlice(linkdests,0,1000);
      linkdests := ArraySlice(linkdests,1000);

      //Get intlink/contentlink references
      linkinglist := linkinglist CONCAT SELECT id, parent, parentsite
                                          FROM system.fs_objects
                                         WHERE filelink IN workslice
                                               AND fs_objects.isactive;

      //Get contenttype references
      linkinglist := linkinglist CONCAT SELECT fs_objects.id, fs_objects.parent, fs_objects.parentsite
                                          FROM system.fs_objects
                                             , system.fs_settings
                                             , system.fs_instances
                                         WHERE fs_settings.fs_object IN workslice
                                               AND fs_settings.fs_instance = fs_instances.id
                                               AND fs_instances.fs_object = fs_objects.id
                                               AND fs_objects.isactive;
    }
    RETURN SELECT DISTINCT * FROM linkinglist;
  }

  PUBLIC MACRO DoRepublishes()
  {
    OBJECT handler := GetWHFSCommitHandler();

    //ADDME: More collapsing and cleaning?
    this->repub_instructions := SELECT DISTINCT * FROM this->repub_instructions;

    FOREVERY(RECORD instruction FROM this->repub_instructions)
      ExecuteRepublishInstruction(instruction.basefolder, instruction.mask, instruction.recursive, TRUE, instruction.indexonly, handler);

    DELETE FROM this->repub_instructions ALL;

    RECORD ARRAY links := this->GetReferencesTo(this->repub_linkdests);
    IF(Length(links)>0)
    {
       UPDATE system.fs_objects
          SET published := ConvertToWillpublish(published, FALSE, FALSE, PubPrio_DirectEdit)
        WHERE id IN (SELECT AS INTEGER ARRAY id FROM links);

       FOREVERY (RECORD rec FROM links)
         handler->FileRepublish(rec.parentsite, rec.parent, rec.id);
     }
  }

   PRIVATE MACRO ExecuteRepubDep(RECORD republish, INTEGER basefolder, INTEGER basesite, INTEGER ARRAY siteprofileids)
   {
     IF(republish.sitemask!="") //takes precedence over have_site
     {
       IF(republish.folder="")
         RETURN; //don't care without a folder

       RECORD ARRAY affected_sites := SELECT * FROM GetSitesReferredByResources(siteprofileids) WHERE ToUppercase(name) LIKE ToUppercase(republish.sitemask);
       FOREVERY(RECORD siterec FROM affected_sites)
       {
         INTEGER target := LookupWHFSObject(siterec.id, republish.folder);
         IF(target != 0)
         {
           INSERT INTO this->repub_instructions(basefolder, mask, recursive, indexonly)
                       VALUES(target, republish.mask, republish.recursive, republish.indexonly)
                       AT END;
         }
       }
       RETURN;
     }

     //Resolve paths
     IF(republish.folder!="" AND republish.folder LIKE '/*')
     {
       INTEGER target := LookupWHFSObject(basesite, republish.folder);
       IF(target = 0)
         RETURN;

       basefolder := target;
     }
     ELSE IF(republish.folder!="")
     {
       STRING folderpath := SELECT AS STRING fullpath FROM system.fs_objects WHERE id=basefolder;
       IF(folderpath="")
         RETURN;

       INTEGER target := LookupWHFSObject(basesite, CollapsePath(folderpath || "/" || republish.folder));
       IF(target = 0)
         RETURN;

       basefolder := target;
     }

     INSERT INTO this->repub_instructions(basefolder, mask, recursive, indexonly)
            VALUES(basefolder, republish.mask, republish.recursive, republish.indexonly)
            AT END;
   }
>;

PUBLIC OBJECT FUNCTION CreateRepublishState()
{
  RETURN NEW RepublishState;
}

MACRO ExecuteRepublishInstruction(INTEGER folder, STRING mask, BOOLEAN recursive, BOOLEAN toplevel, BOOLEAN indexonly, OBJECT handler)
{
  IF(indexonly)
  {
    INTEGER indexdoc :=
        SELECT AS INTEGER folders.indexdoc
          FROM system.fs_objects AS folders
             , system.fs_objects AS files
         WHERE folders.id = folder
           AND folders.isfolder
           AND files.id = folders.indexdoc
           AND files.publish
           AND files.isfolder = FALSE;

    IF(indexdoc!=0)
    {
      UPDATE system.fs_objects
             SET published := ConvertToWillpublish(published, FALSE, FALSE, toplevel ? PubPrio_FolderRepub : PubPrio_SubFolderRepub)
             WHERE fs_objects.id = VAR indexdoc
                   AND fs_objects.publish = TRUE;

      handler->FileRepublish((SELECT AS INTEGER parentsite FROM system.fs_objects WHERE id=VAR folder), folder, indexdoc);
    }
  }
  ELSE
  {
    __RepublishFolder(folder, toplevel, /*non-template-too=*/FALSE, mask, FALSE);
  }
  IF(recursive)
  {
    FOREVERY(INTEGER id FROM SELECT AS INTEGER ARRAY fs_objects.id FROM system.fs_objects WHERE parent=folder AND isfolder)
      ExecuteRepublishInstruction(id, mask, TRUE, FALSE, indexonly, handler);
  }
}

PUBLIC OBJECT FUNCTION InstantiateWebDesign(OBJECT applytester, RECORD webdesigninfo, INTEGER errorcode, OBJECT override_contentobject, OBJECT pageobject, BOOLEAN renderwidgetpreview, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ navigationobject := DEFAULT OBJECT
                                 , htmldataset := DEFAULT RECORD
                                 ], options);

  RECORD saveconfig := __webdesign_config;

  TRY
  {
    __webdesign_config := CELL[ ...webdesigninfo
                              , applytester
                              , errorcode
                              , override_contentobject
                              , options.navigationobject
                              , options.htmldataset
                              , pageobject
                              , renderwidgetpreview
                              ];

    //Prevent oldstyle webdesigns
    IF(NOT webdesigninfo.has_assetpack)
      THROW NEW Exception(`The webdesign for this page didn't set assetpack=`);
    IF(webdesigninfo.designfolder = "")
      THROW NEW Exception(`The webdesign for this page didn't set a designfolder`);

    IF(webdesigninfo.siteresponsefactory != "" OR webdesigninfo.getdata != "")
      webdesigninfo.objectname := "mod::publisher/lib/internal/webdesign/wrappedjsdesign.whlib#WrappedJSDesign";

    OBJECT designobj := MakeObject(webdesigninfo.objectname);
    IF(NOT MemberExists(designobj, "__PREPAREPAGE"))
      THROW NEW Exception(`The design object ${webdesigninfo.objectname} does not derive from WebDesignBase`);
    designobj->__PreparePage();
    RETURN designobj;
  }
  FINALLY
  {
    __webdesign_config := saveconfig;
  }
}

PUBLIC RECORD FUNCTION GetSystemRedirectInfo(INTEGER fileid)
{
  OBJECT applytester := GetApplyTesterForObject(fileid);
  IF(NOT ObjectExists(applytester))
    RETURN [ success := FALSE, error := "fsobject id #" || fileid || " unmatched (deleted?)" ];

  RECORD webdesign;
  TRY
  {
    webdesign := applytester->GetWebDesignObjinfo();
    IF(RecordExists(webdesign) AND webdesign.is404)
      RETURN [ success := FALSE, error := "The file #" || fileid || " links to a nonexisting file" ];
  }
  CATCH(OBJECT e)
  {
    LogHarescriptException(e);
    RETURN [ success := FALSE, error := `Cannot get webdesign info for #${fileid}: ${e->what}` ];
  }
  INTEGER ARRAY folders := [ INTEGER(applytester->__Deprecated_GetObjInfo().obj.parent) ];
  OBJECT executiontester;
  RECORD settings;

  INTEGER finaltype := applytester->__Deprecated_GetObjInfo().obj.type;
  IF(finaltype = whconstant_whfstype_contentlink)
    finaltype := SELECT AS INTEGER type FROM system.fs_objects WHERE id = applytester->__Deprecated_GetObjInfo().obj.filelink;

  IF(finaltype = whconstant_whfstype_shtmlfile)
  {
    OBJECT dest := OpenWHFSObject(applytester->__Deprecated_GetObjInfo().obj.type = 20 ? applytester->__Deprecated_GetObjInfo().obj.filelink : fileid);

    settings := [ startmacro := ""
                , webpageobjectname := ""
                , routerfunction := ""
                , cachettl := 0
                , pagefolder := ""
                , shtmlfile := ObjectExists(dest) AND dest->isactive ? dest->GetResourceName() : ""
                ];
  }
  ELSE
  {
    IF(finaltype = whconstant_whfstype_dynamicfoldercontents)
    {
      executiontester := applytester->GetApplyTesterForParent();
      IF(NOT ObjectExists(executiontester))
        THROW NEW Exception("unable to retrieve parent settings for fsobject #" || fileid);

      INSERT executiontester->__Deprecated_GetObjInfo().obj.parent INTO folders AT END;
      finaltype := executiontester->__Deprecated_GetObjInfo().obj.type;
    }
    ELSE
    {
      executiontester := applytester;
    }

    RECORD result := executiontester->GetDynExecProfileSettings(finaltype);
    IF(NOT result.success)
    {
      IF(result.badtype)
      {
        STRING ns := SELECT AS STRING " (" || namespace || ")" FROM system.fs_types WHERE id = result.type;
        RETURN [ success := FALSE, error := "Unable to retrieve dynamic execution settings for #" || executiontester->__Deprecated_GetObjInfo().obj.id || " - its type #" || result.type || ns || " is not a dynamicexecution type" ];
      }
      ELSE
        RETURN [ success := FALSE, error := "Unable to retrieve dynamic execution settings for #" || executiontester->__Deprecated_GetObjInfo().obj.id || " - no apply rule with <dynamicexecution> matched" ];
    }

    settings := result.dyn;
  }

  INSERT CELL folders := folders INTO settings;
  INSERT CELL success := TRUE INTO settings;
  INSERT CELL objurlpath := UnpackURL(applytester->__Deprecated_GetObjInfo().obj.url).urlpath INTO settings;

  RETURN settings;
}

STATIC OBJECTTYPE ApplyRuleTesterCache
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /** Cache for types namespace->id
      @cell namespace Type namespace (sorted on this cell)
      @cell id Id of type
      @cell obj WHFSType object (filled when requested)
  */
  RECORD ARRAY typecache;

  /** Cache for type id->namespace
      @cell id
      @cell namespace
  */
  RECORD ARRAY revtypecache;

  /** Instance data cache
      @cell type Type id
      @cell id WHFS object id
      @cell data
  */
  RECORD ARRAY instancecache;

  // ---------------------------------------------------------------------------
  //
  // Public interface
  //

  PUBLIC RECORD FUNCTION GetWHFSTypeNamespace(INTEGER id, BOOLEAN isfolder)
  {
    IF (id = 0)
      RETURN GetNamespacesForType(0, isfolder);

    RECORD pos := RecordLowerBound(this->revtypecache, [ id := id ], [ "ID" ]);
    RECORD rec;
    IF (NOT pos.found) {
      rec := CELL[ id, ...GetNamespacesForType(id, isfolder) , obj := DEFAULT OBJECT ];
      INSERT rec INTO this->revtypecache AT pos.position;
      INSERT rec INTO this->typecache AT RecordUpperBound(this->typecache, rec, [ "NAMESPACE" ]);
    } ELSE {
      rec := this->revtypecache[pos.position];
    }
    RETURN CELL[ rec.namespace, rec.scopedtype ];
  }

  PUBLIC OBJECT FUNCTION GetWHFSTypeObject(STRING namespace)
  {
    RECORD pos := RecordLowerBound(this->typecache, [ namespace := namespace ], [ "NAMESPACE"]);
    IF (NOT pos.found)
    {
      OBJECT whfstype := OpenWHFSType(namespace);
      INSERT
          [ namespace :=  namespace
          , id :=         ObjectExists(whfstype) ? whfstype->id : 0
          , obj :=        whfstype
          ] INTO this->typecache AT pos.position;
    }
    ELSE IF (NOT ObjectExists(this->typecache[pos.position].obj))
      this->typecache[pos.position].obj := OpenWHFSTypeById(this->typecache[pos.position].id);

    RETURN this->typecache[pos.position].obj;
  }

  PUBLIC RECORD FUNCTION GetInstanceData(STRING namespace, INTEGER fsobjectid)
  {
    OBJECT obj := this->GetWHFSTypeObject(namespace);
    IF (NOT ObjectExists(obj))
      RETURN DEFAULT RECORD;

    RECORD pos := RecordLowerBound(this->instancecache, [ type := obj->id, id := fsobjectid ], [ "ID", "TYPE" ]);
    IF (NOT pos.found)
    {
      INSERT
          [ type :=   obj->id
          , id :=     fsobjectid
          , data :=   obj->GetInstancedata(fsobjectid)
          ] INTO this->instancecache AT pos.position;
    }

    RETURN this->instancecache[pos.position].data;
  }
>;

MACRO ClearApplyRuleTesterCache(BOOLEAN iscommit DEFAULTSTO TRUE)
{
  current_apply_rule_tester_cache := DEFAULT OBJECT;
}

/** Apply rule tester
    @public
    @topic siteprofiles/api
*/
STATIC OBJECTTYPE ApplyRuleTester <
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT cache;

  RECORD objinfo;

  RECORD csp;

  RECORD ARRAY matchinfo;

  INTEGER contenttype;

  OBJECT clink_applytester;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /** @type(integer) Type of the file/folder for this tester */
  PUBLIC PROPERTY objtype(this->objinfo.obj.type, -);

  /** @type(string) Namespace of the type of the file/folder for this tester */
  PUBLIC PROPERTY objtypens(GetObjTypeNS, -);

  /// @type(integer) The parent of the current object. This parent may point outside the site
  PUBLIC PROPERTY objparent(this->objinfo.obj.parent, -);

  /// @type(integer) The site of the current object
  PUBLIC PROPERTY objsite(this->objinfo.obj.parentsite, -);

  /// @type(boolean) Are we applied to a folder?
  PUBLIC PROPERTY objisfolder(this->objinfo.obj.isfolder, -);

  /// @type(string) Webdesign
  PUBLIC PROPERTY webdesign(this->objinfo.sitedesign, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(RECORD objinfo)
  {
    this->contenttype := -1;
    this->objinfo := objinfo;

    this->InitCache();
    this->ReadCSP();
  }

  STRING FUNCTION GetObjTypeNS()
  {
    RETURN GetFSTypeNS(this->objinfo.obj.type, this->objinfo.obj.isfolder);
  }

  /** Get a cachekey for this applytester (ie all unique fields)
      @return Cache key
  */
  PUBLIC STRING FUNCTION __GetCacheKey()
  {
    RETURN EncodeHSON(this->objinfo.obj);
  }

  /** Get accounting source to which we allocate hits
      @return The accounting source for use in %LogAccountingHit */
  PUBLIC STRING FUNCTION GetAccountingSource()
  {
    //TODO Allow apply rules to set/override accounting source (but we may still want to prefix then?)
    IF(this->objsite != 0)
    {
      STRING sitesource := SELECT AS STRING "site:" || name FROM system.sites WHERE id = this->objsite;
      IF(sitesource != "")
        RETURN sitesource;
    }
    RETURN "site:#" || this->objsite;
  }

  PUBLIC STRING FUNCTION DescribeTarget()
  {
    IF(this->objinfo.obj.id != 0)
      RETURN (SELECT AS STRING whfspath FROM system.fs_objects WHERE id = this->objinfo.obj.id) ?? `deleted object #${this->objinfo.obj.id}`;

    STRING parent := (SELECT AS STRING whfspath FROM system.fs_objects WHERE id = this->objparent) ?? `deleted parent #${this->objparent}`;
    RETURN (this->objinfo.isfile ? "file" : "folder") || " of type " || ((SELECT AS STRING namespace FROM system.fs_types WHERE id = this->objinfo.obj.type) ?? `#${this->objinfo.obj.type}`);
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO InitCache()
  {

    IF (NOT ObjectExists(current_apply_rule_tester_cache))
    {
      current_apply_rule_tester_cache := NEW ApplyRuleTesterCache;
      IF (GetPrimary()->IsWorkOpen())
        GetPrimary()->RegisterCommitHandler("", PTR ClearApplyRuleTesterCache);
      ELSE
        ScheduleMicroTask(PTR ClearApplyRuleTesterCache);
    }
    this->cache := current_apply_rule_tester_cache;
  }

  RECORD ARRAY FUNCTION MinimizeApplies(RECORD ARRAY recs)
  {
    FOREVERY (RECORD rec FROM recs)
    {
      FOREVERY (RECORD c FROM UnpackRecord(rec))
        IF (IsDefaultValue(c.value) AND c.name != "CRITERIA")
          rec := CellDelete(rec, c.name);
      recs[#rec] := rec;
    }

    UPDATE recs
       SET criteria :=  this->MinimizeApplies(criteria)
     WHERE CellExists(recs, "CRITERIA");

    RETURN recs;
  }

  RECORD ARRAY FUNCTION FilterApplies(RECORD ARRAY recs, INTEGER ARRAY siteprofileids)
  {
    FOREVERY (RECORD rec FROM recs)
    {
      FOREVERY (RECORD c FROM UnpackRecord(rec))
        IF (IsDefaultValue(c.value) AND c.name NOT IN [ "SITEPROFILE", "TOS", "APPLYINDEX", "APPLYNODETYPE", "SITEPROFILEIDS", "LINE", "COL" ])
          rec := CellDelete(rec, c.name);
      rec.tos := this->MinimizeApplies(rec.tos);
      recs[#rec] := rec;
    }

    DELETE FROM recs WHERE NOT IsResourceMatch(recs.siteprofileids, VAR siteprofileids);
    RETURN recs;
  }

  RECORD FUNCTION GetCacheableCSPSubset(INTEGER siteid)
  {
    RECORD value := MakeReplacedRecord(
          [ applies :=                DEFAULT RECORD ARRAY
          ], GetCachedSiteProfiles());

    value.applies := this->FilterApplies(value.applies, GetSiteApplicabilityInfo(siteid).siteprofileids);

    RETURN
        [ value :=        value
        , eventmasks :=   site_referrals_mask
        //CSP subset can still be a lot of data, so updated cache from earlier 1 to 15 minutes. if this triggers more CI races, good to know the invalidation was broken
        , ttl :=          15 * 60 * 1000
        ];
  }

  MACRO ReadCSP()
  {
    INTEGER siteid := RecordExists(this->objinfo.site) ? this->objinfo.site.id : 0;

    this->csp := GetAdhocCached([ type := "filteredcsp", siteid := siteid ], PTR this->GetCacheableCSPSubset(siteid));
    this->matchinfo := RepeatElement(
        [ tested :=   FALSE
        , matches :=  FALSE
        ], LENGTH(this->csp.applies));
  }

  MACRO TestApply(INTEGER nr)
  {
    this->matchinfo[nr].tested := TRUE;
    this->matchinfo[nr].matches := this->ApplyIsMatch(this->csp.applies[nr]);
  }

  BOOLEAN FUNCTION MatchType(INTEGER foldertype, STRING matchwith, BOOLEAN isfolder)
  {
    IF(foldertype<1000 AND matchwith=ToString(foldertype)) //only match by ID for well-knowns
      RETURN TRUE;

    RECORD ns := this->cache->GetWHFSTypeNamespace(foldertype, isfolder);
    IF (ns.namespace LIKE matchwith OR ns.scopedtype LIKE matchwith)
      RETURN TRUE;
    RETURN FALSE;
  }

  BOOLEAN FUNCTION MatchWithinType(INTEGER foldertype, STRING matchwith, BOOLEAN isfolder)
  {
    //TODO cache within type matching
    INTEGER tryparent := this->objinfo.parent.id;
    FOR(INTEGER maxdepth := 16; maxdepth > 0; maxdepth := maxdepth - 1)
    {
      RECORD rec := SELECT id, type, parent FROM system.fs_objects WHERE id = tryparent;
      IF(NOT RecordExists(rec))
        RETURN FALSE;

      RECORD ns := this->cache->GetWHFSTypeNamespace(rec.type, TRUE);
      IF (ns.namespace LIKE matchwith OR ns.scopedtype LIKE matchwith)
        RETURN TRUE;

      IF(RecordExists(this->objinfo.site) AND rec.parent = this->objinfo.site.id)
        BREAK; //done!

      tryparent := rec.parent;
    }
    RETURN FALSE;
  }

  BOOLEAN FUNCTION TestPathConstraint(RECORD rec, RECORD site, RECORD parentitem)
  {
    IF (CellExists(rec, "PATHMASK") AND rec.pathmask!="" AND (ToUppercase(this->objinfo.obj.fullpath) NOT LIKE ToUppercase(rec.pathmask)))
      RETURN FALSE;
    IF (CellExists(rec, "PARENTMASK") AND rec.parentmask!="" AND (NOT RecordExists(parentitem) OR ToUppercase(parentitem.fullpath) NOT LIKE ToUppercase(rec.parentmask)))
      RETURN FALSE;
    IF (CellExists(rec, "PARENTTYPE") AND rec.parenttype!="" AND (NOT RecordExists(parentitem) OR NOT this->MatchType(parentitem.type, rec.parenttype,TRUE)))
      RETURN FALSE;
    IF (CellExists(rec, "WITHINTYPE") AND rec.withintype!="" AND (NOT RecordExists(parentitem) OR NOT this->MatchWithinType(parentitem.type, rec.withintype,TRUE)))
      RETURN FALSE;
    IF (CellExists(rec, "WHFSPATHMASK") AND rec.whfspathmask!="" AND (ToUppercase(this->objinfo.obj.whfspath) NOT LIKE ToUppercase(rec.whfspathmask)))
      RETURN FALSE;
    IF (CellExists(rec, "SITETYPE") AND rec.sitetype != "" AND (NOT RecordExists(site) OR NOT this->MatchType(site.type, rec.sitetype, TRUE)))
      RETURN FALSE;
    IF (CellExists(rec, "PATHREGEX") AND rec.pathregex!="" AND NOT MatchPathRegex(rec.pathregex, this->objinfo.obj.fullpath))
      RETURN FALSE;
    IF (CellExists(rec, "WHFSPATHREGEX") AND rec.whfspathregex!="" AND NOT MatchPathRegex(rec.whfspathregex, this->objinfo.obj.whfspath))
      RETURN FALSE;
    IF (CellExists(rec, "PARENTREGEX") AND rec.parentregex!="" AND (NOT RecordExists(parentitem) OR NOT MatchPathRegex(rec.parentregex, parentitem.fullpath)))
      RETURN FALSE;
    RETURN TRUE;
  }

  INTEGER FUNCTION GetContentType()
  {
    IF(this->objinfo.obj.type != 20) //contentlink
      RETURN this->objinfo.obj.type;
    IF(this->contenttype != -1)
      RETURN this->contenttype;

    this->contenttype := SELECT AS INTEGER fs_objects.type
                           FROM system.fs_objects
                          WHERE fs_objects.id = this->objinfo.obj.filelink;
    RETURN this->contenttype;
  }

  ///Get the applytester for the actual content (if this is a contentlink)
  OBJECT FUNCTION GetContentApplyTester() {
    IF (this->objinfo.obj.type != whconstant_whfstype_contentlink)
      RETURN this;

    IF(NOT ObjectExists(this->clink_applytester)) {
      this->clink_applytester := GetApplyTesterForObject(this->objinfo.obj.filelink);
      IF(NOT ObjectExists(this->clink_applytester) OR this->clink_applytester->__Deprecated_GetObjInfo().obj.type = whconstant_whfstype_contentlink) {
        // This may happen during new content link file creation. Just use the original then
        this->clink_applytester := this;
      }
    }
    RETURN this->clink_applytester;
  }

  BOOLEAN FUNCTION ToIsMatch(RECORD element, RECORD site, RECORD folder)
  {
    SWITCH(element.type)
    {
      CASE "and"
      {
        FOREVERY(RECORD crit FROM element.criteria)
          IF (NOT this->ToIsMatch(crit, site, folder))
            RETURN FALSE;
        RETURN TRUE;
      }
      CASE "or"
      {
        FOREVERY(RECORD crit FROM element.criteria)
          IF (this->ToIsMatch(crit, site, folder))
            RETURN TRUE;
        RETURN FALSE;
      }
      CASE "not"
      {
        FOREVERY(RECORD crit FROM element.criteria)
          IF (this->ToIsMatch(crit, site, folder))
            RETURN FALSE;
        RETURN TRUE;
      }
      CASE "testdata"
      {
        INTEGER testid;

        IF(element.target="parent")
          testid := folder.id;
        ELSE IF(element.target="root")
          testid := RecordExists(site) ? site.id : 0;
        ELSE
          testid := this->objinfo.obj.id;

        IF(testid=0)
          RETURN FALSE;

        RECORD instance := this->cache->GetInstanceData(element.typedef, testid);
        STRING membername := element.membername;
        IF(NOT CellExists(instance, membername))
          RETURN FALSE;

        IF(TypeId(GetCell(instance, membername))=TypeId(STRING) AND GetCell(instance, membername) = (CellExists(element, "VALUE") ? element.value : ""))
          RETURN TRUE;
        IF(TypeId(GetCell(instance, membername))=TypeId(INTEGER) AND GetCell(instance, membername) = (CellExists(element, "VALUE") ? ToInteger(element.value,-1) : 0))
          RETURN TRUE;
        IF(TypeId(GetCell(instance, membername))=TypeId(BOOLEAN) AND GetCell(instance, membername) = (CellExists(element, "VALUE") ? ParseXSBoolean(element.value) : FALSE))
          RETURN TRUE;
        IF(TypeId(GetCell(instance, membername))=TypeId(DATETIME) AND GetCell(instance, membername) = (CellExists(element, "VALUE") ? MakeDateFromText(element.value) : DEFAULT DATETIME))
          RETURN TRUE;

        RETURN FALSE;
      }
      CASE "to"
      {
        IF (CellExists(element, "MATCH_FILE") AND element.match_file AND NOT this->objinfo.isfile)
          RETURN FALSE;
        IF (CellExists(element, "MATCH_INDEX") AND element.match_index AND (NOT RecordExists(folder) OR folder.indexdoc != this->objinfo.obj.id))
          RETURN FALSE;
        IF (CellExists(element, "MATCH_FOLDER") AND element.match_folder AND this->objinfo.isfile)
          RETURN FALSE;

        IF (CellExists(element, "FOLDERTYPE") AND element.foldertype!="" AND NOT this->MatchType(this->objinfo.obj.type, element.foldertype, TRUE))
          RETURN FALSE;
        IF (CellExists(element, "FILETYPE") AND element.filetype!="" AND NOT this->MatchType(this->objinfo.obj.type, element.filetype, FALSE))
          RETURN FALSE;
        //WHFSTYPE is used by YML rules
        IF (CellExists(element, "WHFSTYPE") AND element.whfstype!="" AND NOT this->MatchType(this->objinfo.obj.type, element.whfstype, this->objinfo.obj.isfolder))
          RETURN FALSE;

        IF (CellExists(element, "TYPENEEDSTEMPLATE") AND element.typeneedstemplate AND NOT this->IsTypeNeedsTemplate())
          RETURN FALSE;
        IF (CellExists(element, "WEBFEATURES") AND Length(element.webfeatures) > 0 AND NOT this->MatchWebfeatures(element.webfeatures))
          RETURN FALSE;

        //TODO can we somehow share with GetMatchesBySiteFilter ?
        IF (CellExists(element, "SITENAME") AND (NOT RecordExists(site) OR ToUppercase(site.name) != ToUppercase(element.sitename)))
            RETURN FALSE;
        IF (CellExists(element, "SITEMASK") AND (NOT RecordExists(site) OR ToUppercase(site.name) NOT LIKE ToUppercase(element.sitemask)))
            RETURN FALSE;
        IF (CellExists(element, "SITEREGEX") AND (NOT RecordExists(site) OR NOT MatchPathRegex(element.siteregex, site.name)))
            RETURN FALSE;
        IF (CellExists(element, "WEBROOTREGEX") AND (NOT RecordExists(site) OR NOT MatchPathRegex(element.webrootregex, site.webroot)))
            RETURN FALSE;

        IF (NOT this->TestPathConstraint(element, site, folder))
          RETURN FALSE;
      }
    }
    RETURN TRUE;
  }

  BOOLEAN FUNCTION ApplyIsMatch(RECORD apply) {
    IF(NOT IsResourceMatch(apply.siteprofileids, this->objinfo.siteprofileids))
      RETURN FALSE;

    IF(CellExists(apply,'whfstype') AND apply.whfstype != "") { //directly applied to the type
      RECORD ns := this->cache->GetWHFSTypeNamespace(this->objinfo.obj.type, this->objinfo.obj.isfolder);
      RETURN ns.namespace = apply.whfstype OR ns.scopedtype = apply.whfstype;
    }

    FOREVERY (RECORD appl FROM apply.tos)
      IF (this->ToIsMatch(appl, this->objinfo.site, this->objinfo.parent))
        RETURN TRUE;

    RETURN FALSE;
  }

  RECORD FUNCTION GetTypeRecordData()
  {
    RETURN
        SELECT needstemplate
             , capturesubpaths
             , isacceptableindex
             , ispublishedassubdir
          FROM system.fs_types
         WHERE id = this->GetContentType();
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Is this a type needing a template?
      @return TRUE if this file type needs a template
  */
  PUBLIC BOOLEAN FUNCTION IsTypeNeedsTemplate()
  {
    //Split off as API to allow us to cache stuff
    RECORD typerec := this->GetTypeRecordData();
    RETURN RecordExists(typerec) AND typerec.needstemplate;
  }
  /** Are any of these webfeatures active? (like <to webfeatures=)
  */
  PUBLIC BOOLEAN FUNCTION MatchWebfeatures(STRING ARRAY masks)
  {
    OBJECT sitesettingstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/sitesettings");
    FOREVERY (STRING feature FROM sitesettingstype->GetInstanceData(this->objsite).webfeatures)
      IF (MatchCommonXMLWildcardMasks(feature, masks))
        RETURN TRUE;
    RETURN FALSE;
  }

  /** Returns all relevant applies for a specific cell
      @cell return.siteprofile
      @cell return.applyindex
      @cell return.siteids
  */
  PUBLIC RECORD ARRAY FUNCTION __GetAppliesForcell(STRING cellname)
  {
    RECORD ARRAY filtered;
    FOREVERY (RECORD apply FROM this->csp.applies)
    {
      IF (cellname != "" AND (NOT CellExists(apply,cellname) OR IsDefaultValue(GetCell(apply, cellname))))
        CONTINUE;
      IF (NOT this->matchinfo[#apply].tested)
        this->TestApply(#apply);
      IF (this->matchinfo[#apply].matches)
      {
        IF (cellname = "")
          INSERT apply INTO filtered AT END;
        ELSE
        {
          // Only give back requested cell plus a few standard cells
          RECORD result :=
              CELL[ apply.siteprofile
                  , apply.applyindex
                  , apply.applynodetype
                  , apply.siteprofileids
                  ];

          result := CellInsert(result, cellname, GetCell(apply, cellname));
          INSERT result INTO filtered AT END;
        }
      }
    }
    RETURN filtered;
  }

  /** @short Invoke the intercepts for a siteprofile hook target
      @long Module hooks are a low-level mechanism to allow external code to hook into your code.
      @param targetname Hook target to invoke (module:targetname)
      @param data Data to pass to the intercept functions. Each intercept can update the data
      @return The data as returned by the last intercept. If the target was not intercepted it will simply return the original data */
  PUBLIC RECORD FUNCTION RunSiteprofileHookTarget(STRING targetname, RECORD data)
  {
    RECORD ARRAY intercepts;
    FOREVERY (RECORD applyrule FROM this->__GetAppliesForcell("hookintercepts"))
      FOREVERY(RECORD intercept FROM applyrule.hookintercepts)
        IF(intercept.target = targetname)
          INSERT intercept INTO intercepts AT END;

    //OrderIntercepts also returns errors which made satisfying constraints impossible... but how to report these? dtap-based-throw?  message in inspect <apply> ?
    intercepts := OrderIntercepts(intercepts).intercepts;
    FOREVERY(RECORD intercept FROM intercepts)
    {
      FUNCTION PTR func := MakeFunctionPtr(intercept.interceptfunction, TypeID(RECORD), [ TypeID(RECORD) ]);
      data := func(data);
    }
    RETURN data;
  }

  PUBLIC RECORD FUNCTION GetFormDefinitionFile(STRING name) {
    IF(this->__Deprecated_GetObjInfo().obj.type = 20) //contentlink - forward it
      RETURN this->GetContentApplyTester()->GetFormDefinitionFile(name);

    IF(name != "") {
      RECORD plugins := __GetExtractedConfig("plugins");
      STRING modmatch := SELECT AS STRING path FROM plugins.form_definitions WHERE form_definitions.name = name;
      IF(modmatch != "")
        RETURN [ path := modmatch ];
    }

    RECORD match;
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell("FORMDEFINITIONS"))
      FOREVERY(RECORD formdef FROM apply.formdefinitions)
        IF(formdef.name = name)
          match := formdef;
    RETURN match;
  }

  PUBLIC RECORD FUNCTION GetCachedProperty(STRING cellname, RECORD defaultvalue)
  {
    RECORD retval := defaultvalue;
    STRING ARRAY fields := SELECT AS STRING ARRAY name FROM UnpackRecord(defaultvalue);

    FOREVERY(RECORD apply FROM this->__GetAppliesForcell(cellname))
      retval := UpdateListedAttributes(retval, GetCell(apply, cellname));

    RETURN retval;
  }

  PUBLIC STRING FUNCTION GetSiteLanguage()
  {
    STRING lang := "en";
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell("SITELANGUAGE"))
    {
      IF(apply.sitelanguage.has_lang)
        lang := apply.sitelanguage.lang ?? "en";
    }

    RETURN lang ?? "en";
  }

  PUBLIC RECORD ARRAY FUNCTION GetMailTemplates()
  {
    RECORD ARRAY mailtemplates;
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell("MAILTEMPLATES"))
      FOREVERY(RECORD mailtemplate FROM apply.mailtemplates)
      {
        IF(mailtemplate.path != "") //refers to a titled template
          INSERT [ path := mailtemplate.path, title := mailtemplate.title ?? ":" || mailtemplate.path, ordering := mailtemplate.ordering ] INTO mailtemplates AT END;

        FOREVERY (RECORD source FROM mailtemplate.sources)
        {
          OBJECT sourceobj := this->LookupSource(source);
          IF (ObjectExists(sourceobj))
          {
            mailtemplates := mailtemplates
                             CONCAT
                             SELECT path := OpenWHFSObject(id)->GetResourceName()
                                  , title := ":" || title
                                  , ordering
                               FROM system.fs_objects
                              WHERE parent = sourceobj->id
                                    AND title != ""
                                    AND (type = 5 //HTML
                                         OR type = 26 //witty
                                         OR (type = 21 AND ToUppercase(name) LIKE "*.HTML") //plain text
                                        );
          }
        }
      }

    //Post process the templates. For any dupes, use ordering (and then alphabetic ordering) to find first title match
    mailtemplates := SELECT TEMPORARY title := (SELECT AS STRING COLUMN title FROM GroupedValues(mailtemplates) ORDER BY ordering, ToUppercase(COLUMN title))
                          , title := title
                          , path
                       FROM mailtemplates
                   GROUP BY path
                   ORDER BY ANY(ordering), ToUppercase(title), ToUppercase(path);

    RETURN mailtemplates;
  }

  PUBLIC STRING FUNCTION GetDefaultMailTemplate()
  {
    RECORD mailtempl := this->GetMailTemplates();
    RETURN RecordExists(mailtempl) ? mailtempl.path : "";
  }

  /** Get our <rtddoc> settings
      @return Default record if `<rtddoc rtdtype=>` is not set */
  PUBLIC RECORD FUNCTION GetRTDTypeSettings()
  {
    RECORD rtddoc := [ rtdtype := ""
                     , htmlclass := ""
                     , bodyclass := ""
                     , margins := ""
                     , has_htmlclass := FALSE
                     , has_bodyclass := FALSE
                     ];
    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("RTDDOC"))
    {
      rtddoc := CELL[...rtddoc, ...apply.rtddoc];
      IF(CellExists(apply.rtddoc,'htmlclass'))
        rtddoc.has_htmlclass := TRUE;
      IF(CellExists(apply.rtddoc,'bodyclass'))
        rtddoc.has_bodyclass := TRUE;
    }

    RETURN rtddoc.rtdtype != "" ? rtddoc : DEFAULT RECORD;
  }

  PUBLIC RECORD FUNCTION GetWebDesignObjinfo()
  {
    RECORD webdesign := GetDefaultWebDesignInfo();

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("WEBDESIGN"))
    {
      webdesign.witty           := apply.webdesign.witty           ?? webdesign.witty;
      webdesign.designfolder    := apply.webdesign.designfolder    ?? webdesign.designfolder;
      webdesign.maxcontentwidth := apply.webdesign.maxcontentwidth ?? webdesign.maxcontentwidth;
      webdesign.siteprofile     := apply.siteprofile;
      webdesign.wittyencoding   := apply.webdesign.wittyencoding   ?? webdesign.wittyencoding ;

      IF(apply.webdesign.has_assetpack) {
        webdesign.assetpack            := apply.webdesign.assetpack;
        webdesign.has_assetpack        := TRUE;
      }

      webdesign.supportserrors       := apply.webdesign.has_supportserrors       ? apply.webdesign.supportserrors       : webdesign.supportserrors;
      webdesign.supportsaccessdenied := apply.webdesign.has_supportsaccessdenied ? apply.webdesign.supportsaccessdenied : webdesign.supportsaccessdenied;
      webdesign.contentnavstops      := apply.webdesign.has_contentnavstops      ? apply.webdesign.contentnavstops      : webdesign.contentnavstops;

      IF(apply.webdesign.objectname != "")
      {
        webdesign.objectname      := apply.webdesign.objectname;
        webdesign.siteresponsefactory := "";
        webdesign.getdata := "";
      }
      ELSE IF( (CellExists(apply.webdesign,'siteresponsefactory') AND apply.webdesign.siteresponsefactory != "")  //introduced in 5.2
               OR (CellExists(apply.webdesign,'getdata') AND apply.webdesign.getdata != "")) //introduced in 5.7
      {
        webdesign.objectname := "";
        webdesign.siteresponsefactory := apply.webdesign.siteresponsefactory;
        webdesign.getdata := apply.webdesign.getdata;
      }
    }

    IF (RecordExists(webdesign))
      webdesign.renderinfo := this->GetContentApplyTester()->GetObjRenderInfo();

    RETURN webdesign;
  }

  PUBLIC RECORD FUNCTION GetObjRenderInfo()
  {
    RECORD typerec := this->GetTypeRecordData();
    RECORD bodyrenderer := CELL[  //default rendering settings from publisher.siteprl.xml
      objectname := "mod::publisher/lib/webdesign.whlib#StaticPageBase",
      capturesubpaths := RecordExists(typerec) AND typerec.capturesubpaths,
      renderer := ""
    ];

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("BODYRENDERER"))
      IF (apply.bodyrenderer.objectname != "" OR apply.bodyrenderer.renderer != "") { //we always reset them together
        bodyrenderer.objectname := apply.bodyrenderer.objectname;
        bodyrenderer.renderer := apply.bodyrenderer.renderer;
      }

    RETURN bodyrenderer;
  }

  PUBLIC RECORD ARRAY FUNCTION GetWebDesignPlugins()
  {
    RECORD ARRAY plugins;

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("PLUGINS"))
      plugins := plugins CONCAT apply.plugins;

    RETURN
        SELECT AS RECORD ARRAY CellInsert(Any(plugins), "DATAS", Any(plugins).yaml_property = "" ? GroupedValues(data) : this->GetYamlPluginSettings(Any(plugins).yaml_property))
          FROM plugins
      GROUP BY combine ? "name:" || name : "id:" || ToString(#plugins)
             , combine ? namespace : "";
  }

  PUBLIC RECORD FUNCTION GetPluginConfiguration(STRING namespace, STRING localname)
  {
    RECORD plugin := SELECT * FROM this->GetWebDesignPlugins() AS plugins WHERE plugins.namespace = VAR namespace AND plugins.name = VAR localname;
    IF(NOT RecordExists(plugin))
      RETURN DEFAULT RECORD;
    RETURN CombinePartialNodes(plugin.datas);
  }

  /** Test whether the user has the requested right
      @param rightname Right to check. Must either be granted globally or for system:fs_fullaccess/system:fs_browse, on the fsobject or any of its parents
      @return True if the user has the right, or if rightname is empty*/
  PUBLIC BOOLEAN FUNCTION HasRequiredRight(OBJECT user, STRING rightname)
  {
    IF (rightname = "")
      RETURN TRUE;

    IF (rightname IN [ "system:fs_fullaccess", "system:fs_browse" ]) //TODO look at the target of the right, so custom rights can also apply to fsobjects
      RETURN user->HasRightOn(rightname, this->objinfo.obj.id ?? this->objinfo.obj.parent);

    RETURN IsRightGlobal(rightname) ? user->HasRight(rightname) : user->HasRightOn(rightname, 0);
  }

  //Tollium Publisher version of GetCustomFields
  PUBLIC RECORD FUNCTION GetCustomFields(OBJECT user, STRING langcode)
  {
    //ADDME: Gettext the error messages!
    RECORD retval := [ propertyeditors := DEFAULT RECORD ARRAY
                     , errors := DEFAULT STRING ARRAY
                     ];

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("EXTENDPROPERTIES"))
      FOREVERY(RECORD extendprops FROM apply.extendproperties)
      {
        IF(NOT this->HasRequiredRight(user, extendprops.requireright))
          CONTINUE;

        INSERT CELL[ ...extendprops
                   , tabsextension := extendprops.extension
                   ] INTO retval.propertyeditors AT END;
      }

    RETURN retval;
  }

  PUBLIC RECORD FUNCTION GetFolderSettings()
  {
    RECORD settings := GetDefaultFolderSettings();
    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("FOLDERSETTINGS"))
    {
      IF(apply.foldersettings.has_filterscreen)
        settings.filterscreen := apply.foldersettings.filterscreen;
      IF(apply.foldersettings.ordering!="")
        settings.ordering := apply.foldersettings.ordering;
      IF(RecordExists(apply.foldersettings.contentslisthandler))
        settings.contentslisthandler := apply.foldersettings.contentslisthandler;
    }
    RETURN settings;
  }

  /** Resolve userdata */
  PUBLIC RECORD FUNCTION GetUserData(STRING keyname) {
    RECORD retvalue;
    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("USERDATA")) {
      FOREVERY (RECORD userdata FROM apply.userdata)  {
        IF(userdata."key" = keyname)
          retvalue := CELL[...retvalue, ...DecodeJSON(userdata.value)];
      }
    }
    RETURN retvalue;
  }

  PUBLIC INTEGER FUNCTION GetUploadFileTypeMapping(STRING filename, STRING mimetype)
  {
    STRING suggestfiletype;

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("UPLOADTYPEMAPPING"))
    {
      FOREVERY(RECORD mapping FROM apply.uploadtypemapping)
      {
        IF(mapping.filenamemask != "" AND ToUppercase(filename) NOT LIKE ToUppercase(mapping.filenamemask))
          CONTINUE;
        IF(mapping.mimetypemask != "" AND ToUppercase(mimetype) NOT LIKE ToUppercase(mapping.mimetypemask))
          CONTINUE;
        suggestfiletype := mapping.filetype;
      }
    }

    IF(suggestfiletype != "")
    {
      RECORD suggested := LookupContentTypeByName(suggestfiletype);
      RETURN RecordExists(suggested) AND RecordExists(suggested.filetype) ? suggested.id : 0;
    }

    INTEGER totype := MimetypeToFiletype(mimetype);
    IF(totype = 4) { //Word document is suggested by the mapping
      //But can this folder even convert wordocs ? If not still map it to a download
      IF(NOT RecordExists(this->GetCustomSettings("http://www.webhare.net/xmlns/publisher/siteprofile", "mswordconversion")))
        totype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/msworddownload")->id; //make downloadable
    }
    RETURN totype;
  }

  PUBLIC RECORD FUNCTION GetURLHistorySettings()
  {
    RETURN this->GetCachedProperty("urlhistory", [ accesscheck := "" ]);
  }

  PUBLIC RECORD FUNCTION GetUsePublishTemplate() {
    IF(this->__Deprecated_GetObjInfo().obj.type = 20) //contentlink - forward it
      RETURN this->GetContentApplyTester()->GetUsePublishTemplate();

    RECORD usetempl := [ script := "mod::publisher/scripts/internal/publishother.whscr"
                       , isdefault := TRUE
                       ];
    RECORD csp := GetCachedSiteProfiles();
    IF(RecordExists(csp))
    {
      // Dynamic execute files types (and of type dynamicfoldercontents) must be published by publishsystemredirect
      RECORD contenttype;
      IF(this->__Deprecated_GetObjInfo().obj.type != 0)
        contenttype := LookupContentTypeById(this->__Deprecated_GetObjInfo().obj.type);
      IF (RecordExists(contenttype)
          AND (RecordExists(contenttype.dynamicexecution)
               OR contenttype.namespace IN [ "http://www.webhare.net/xmlns/publisher/dynamicfoldercontents"
                                           , "http://www.webhare.net/xmlns/publisher/shtmlfile"
                                           ]))
      {
        usetempl.script := "mod::publisher/scripts/internal/publishsystemredirect.whscr";
        usetempl.isdefault := FALSE;
        RETURN usetempl; //these are now forced to publishsystemredirect so a systemredirect can handle them
      }

      FOREVERY(RECORD apply FROM this->__GetAppliesForcell("USEPUBLISHTEMPLATE"))
      {
        usetempl := apply.usepublishtemplate;
        INSERT CELL isdefault := FALSE INTO usetempl;
      }
    }
    RETURN usetempl;
  }

  //Return the workflow editor for a file (ie a editdocument based separate app editor)
  PUBLIC RECORD FUNCTION GetWorkflowEditor() {
    RECORD editorinfo := this->GetLastValueForCell("SETOBJECTEDITOR"); //TODO this is replicating the editor selection logic from RunFSObjectEditApplication, cleaner?
    IF(RecordExists(editorinfo) AND editorinfo.name != "") {
      RECORD objeditor := GetObjectEditor(editorinfo.name);
      IF(RecordExists(objeditor) AND objeditor.documenteditor != "") { //TODO also support (RecordExists(editorinfo) AND editorinfo.separateapp) ? or phase that out?
        RETURN CELL[];
      }
    }

    RETURN DEFAULT RECORD;
  }

  PUBLIC RECORD FUNCTION GetLastValueForCell(STRING cellname)
  {
    RECORD ARRAY applies := this->__GetAppliesForcell(cellname);
    RETURN Length(applies) > 0 ? GetCell(applies[END-1], cellname) : DEFAULT RECORD;
  }

  PUBLIC INTEGER FUNCTION GetSitePlaceHolder()
  {
    RECORD contentlisting := this->GetLastValueForCell("CONTENTLISTING");
    IF(NOT RecordExists(contentlisting))
      RETURN 0;

    // Resolve site/fullpath - FIXME - Use the siteprofile's site as the base, not the current site
    INTEGER filesite := this->__Deprecated_GetObjInfo().obj.parentsite;
    IF (contentlisting.site != "")
      filesite := SELECT AS INTEGER id FROM system.sites WHERE ToUppercase(name) = ToUppercase(contentlisting.site);

    //We accept accidentally selecting a folder.. should be rare an WHFS stored contentlistings are obsolete anyway
    RETURN LookupWHFSObject(filesite, contentlisting.fullpath);
  }

  /** @short Get tag repository for a specific contenttype member */
  PUBLIC RECORD FUNCTION GetTagSourceForFSMember(STRING contenttype, STRING membername)
  {
    RECORD result;
    RECORD searchrec := [ contenttype := contenttype, membername := membername ];

    FOREVERY (RECORD apply FROM this->__GetAppliesForcell("TAGSOURCES"))
    {
      RECORD pos := RecordLowerBound(apply.tagsources, searchrec, [ "CONTENTTYPE", "MEMBERNAME" ]);
      IF (pos.found)
      {
        RECORD tagsource := apply.tagsources[pos.position];
        result :=
            [ tagfolder :=  tagsource.tagfolder
            , repository := tagsource.repository
            , allowcreate := tagsource.allowcreate
            ];
      }
    }

    IF(RecordExists(result))
      RETURN [ success := TRUE, data := result ];

    RETURN [ success := FALSE ];
  }

  /** Is this object a site root ? */
  PUBLIC BOOLEAN FUNCTION IsSiteRoot()
  {
    RETURN this->objinfo.obj.id = this->objinfo.site.id;
  }

  /** Is this object new ? */
  PUBLIC BOOLEAN FUNCTION IsNew()
  {
    RETURN this->objinfo.obj.id = 0;
  }

  /** Is this object an index document */
  PUBLIC BOOLEAN FUNCTION IsIndexDoc()
  {
    RETURN this->objinfo.obj.id = this->objinfo.parent.indexdoc;
  }

  /** Return an apply tester for the parent object. If the parent is outside the
      site, this will simply return itself, not an applytester for an out-of-site object */
  PUBLIC OBJECT FUNCTION GetApplyTesterForParent()
  {
    RECORD baseinfo := this->objinfo;
    IF(baseinfo.obj.id = baseinfo.site.id) //you already had the highest parent
      RETURN this;

    baseinfo.obj := baseinfo.parent;
    baseinfo.parent := RECORD(SELECT * FROM system.fs_objects WHERE id = baseinfo.parent.parent);
    baseinfo.isfile := FALSE;
    RETURN NEW ApplyRuleTester(baseinfo);
  }

  /** @short Get dynamic execution settings */
  PUBLIC RECORD FUNCTION GetDynExecProfileSettings(INTEGER finaltype)
  {
    RECORD csp := GetcachedSiteProfiles();
    RECORD dyn;

    RECORD contenttype;
    IF(finaltype != 0)
      contenttype := LookupContentTypeById(finaltype);

    IF(NOT RecordExists(contenttype) OR NOT RecordExists(contenttype.dynamicexecution))
      RETURN [ success := FALSE, badtype := TRUE, type := finaltype ];

    dyn := contenttype.dynamicexecution;
    IF(RecordExists(dyn))
      RETURN [ success := TRUE, dyn := dyn ];

    RETURN [ success := FALSE, badtype := FALSE ];
  }

  PUBLIC RECORD FUNCTION GetUpdatedWidget(RECORD intypedef)
  {
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell("setwidget"))
      FOREVERY(RECORD setwidget FROM apply.setwidget)
      {
        IF(setwidget.contenttype = intypedef.namespace)
        {
          IF(RecordExists(setwidget.editor))
            intypedef.editor := setwidget.editor;
          IF(RecordExists(setwidget.renderer))
            intypedef.renderer := setwidget.renderer;
          IF(setwidget.has_wittycomponent)
          {
            intypedef.wittycomponent := setwidget.wittycomponent;
            intypedef.previewcomponent := setwidget.previewcomponent;
          }
          ELSE IF(setwidget.has_previewcomponent)
            intypedef.previewcomponent := setwidget.previewcomponent;
        }
      }
    RETURN intypedef;
  }

  /** Get the yaml plugin settings associated with the specified name
      @param name The name of the plugin, corresponding to a <module>:<name> property. Snake case if it was mixed case in the YAML
      @return An array of settings records found. Each record includes a 'source' member specifying the source site profile rule. It's up to the caller to merge them as needed
  */
  PUBLIC RECORD ARRAY FUNCTION GetYamlPluginSettings(STRING name) {
    STRING cellname := "yml_" || ToSnakeCase(name);
    RECORD ARRAY results;
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell(cellname)) {
      RECORD source := CELL[ siteprofile := apply.siteprofile, applyindex := apply.applyindex];
      FOREVERY(RECORD setting FROM GetCell(apply, cellname)) {
        INSERT CELL[ ...setting, source ] INTO results AT END;
      }
    }

    RETURN results;
  }

  PUBLIC RECORD ARRAY FUNCTION GetCustomSettings(STRING ns, STRING localname)
  {
    RECORD ARRAY retval;
    FOREVERY(RECORD apply FROM this->__GetAppliesForcell("customnodes"))
    {
      RECORD ARRAY matchingnodes := SELECT * FROM apply.customnodes WHERE customnodes.namespaceuri = ns AND customnodes.localname = localname;
      IF(Length(matchingnodes)>0)
      {
        OBJECT siteprof := NEW SiteProfileObject(apply.siteprofile);
        OBJECT applynode := siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS(whconstant_xmlns_publisher, apply.applynodetype)->Item(apply.applyindex);

        IF(ObjectExists(applynode))
        {
          OBJECT ARRAY matchingchildren := applynode->ListChildren(ns, localname);
          FOREVERY(OBJECT child FROM matchingchildren)
            INSERT [ siteprofile := siteprof, applynode := applynode, node := child ] INTO retval AT END;
        }
      }
    }
    RETURN retval;
  }

  OBJECT FUNCTION LookupSource(RECORD source)
  {
    STRING resolvename := source.path;

    IF(resolvename NOT LIKE "*::*")
    {
      // Resolve relative to the site if this is an absolute path, or relative to the target object itself if this is a folder,
      // or relative to the parent if this is a file
      OBJECT relativeto;
      IF(resolvename LIKE "/*")
        relativeto := OpenWHFSObject(this->objinfo.site.id);
      ELSE
        relativeto := OpenWHFSObject(this->objinfo.obj.isfolder ? this->objinfo.obj.id : this->objinfo.obj.parent);
      IF(NOT ObjectExists(relativeto) OR NOT relativeto->isactive)
        RETURN DEFAULT OBJECT;

      resolvename := MakeAbsoluteResourcePath(relativeto->GetResourceName(), resolvename);
    }

    RETURN OpenWHFSObjectByPath(resolvename);
  }

  PUBLIC INTEGER ARRAY FUNCTION GetLibrary(STRING libraryname)
  {
    // Each apply with a setmedialibrary overwrites the media library, so we only have to check the last apply
    RECORD lastmatchrule;
    FOREVERY(RECORD applyrule FROM this->__GetAppliesForcell("setlibrary"))
      FOREVERY(RECORD setlibrary FROM applyrule.setlibrary)
      {
        IF(setlibrary.name != libraryname)
          CONTINUE;

        lastmatchrule := setlibrary;
      }

    IF(NOT RecordExists(lastmatchrule)) //nothing at all found
      RETURN DEFAULT INTEGER ARRAY;

    INTEGER ARRAY retval;
    FOREVERY (RECORD source FROM lastmatchrule.sources)
    {
      OBJECT sourceobj := this->LookupSource(source);
      IF (ObjectExists(sourceobj) AND sourceobj->isfolder)
        INSERT sourceobj->id INTO retval AT END;
    }
    RETURN retval;
  }

  /** Get objinfo from this object. Just so we don't have to recalculate it for performance reasons.
  */
  PUBLIC RECORD FUNCTION __Deprecated_GetObjInfo() __ATTRIBUTES__(DEPRECATED "Don't use, move functionality into this object")
  {
    RETURN this->objinfo;
  }
>;

/** Returns an apply tester for a specific WHFS file/folder
    @param obj WHFS id of the file/folder
    @return(object #ApplyRuleTester) Apply tester
    @topic siteprofiles/api
    @public
    @loadlib mod::publisher/lib/siteprofiles.whlib
*/
PUBLIC OBJECT FUNCTION GetApplyTesterForObject(INTEGER obj)
{
  RECORD objinfo := GetBaseInfoForApplyCheck(obj);
  IF (NOT RecordExists(objinfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW ApplyRuleTester(objinfo);
}

/** Returns an apply tester for a hypothetical WHFS file/folder
    @param parentfolder WHFS id of the parent folder
    @param isfile Whether the hypothetical object is a file
    @param ftypeid File/folder type id of the hypothetical object
    @return(object #ApplyRuleTester) Apply tester
    @topic siteprofiles/api
    @public
    @loadlib mod::publisher/lib/siteprofiles.whlib
*/
PUBLIC OBJECT FUNCTION GetApplyTesterForFakeObject(INTEGER parentfolder, BOOLEAN isfile, INTEGER ftypeid)
{
  RECORD objinfo := GetFakeBaseInfoForApplyCheck(parentfolder, isfile, ftypeid);
  IF (NOT RecordExists(objinfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW ApplyRuleTester(objinfo);
}

PUBLIC OBJECT FUNCTION GetApplyTesterForHSInfo(RECORD __hsinfo)
{
  /* see __getHSInfo
      ismocked:
      objectid:
      parentfolder:
      type:
      name:

    TODO: Get a full Baseinfo object from TS so we don't have to rescan CSP
*/
  IF(__hsinfo.ismocked)
  {
    OBJECT targettype := OpenWHFSType(__hsinfo.type);
    RETURN GetApplyTesterForFakeObject(__hsinfo.parentfolder, targettype->filetype, targettype->id); //TODO also consider 'name"?
  }
  ELSE
  {
    RETURN GetApplyTesterForObject(__hsinfo.objectid);
  }
}

RECORD FUNCTION GetCacheableRTDType(STRING typename)
{
  RECORD csp := GetcachedSiteProfiles();
  //fallback to 'contenttypes' to have a chance to run with not yet recompiled WH5.8 CSPs in WH5.9
  RECORD typedef := SELECT * FROM CellExists(csp,'rtdtypes') ? csp.rtdtypes : csp.contenttypes WHERE namespace=typename AND isrtdtype;

  //Ensure fields created in a new WebHare update but not yet in the CSP exist (eg tag_b in 4.28.3)
  IF(RecordExists(typedef))
  {
    typedef := EnforceStructure(MakeBaseSiteprofileXMLStructure(), typedef);
  }

  RETURN [ value := typedef
         , eventmasks := [ "publisher:internal.siteprofiles.recompiled" ]
         ];
}

PUBLIC RECORD FUNCTION GetRTDType(STRING typename)
{
  RETURN GetAdhocCached([ getrtdtype := typename ], PTR GetCacheableRTDType(typename));
}

//Get a map of the resource IDs to which all sites refer. This is needed to resolve things like GetSiteSettingIDs.
PUBLIC RECORD ARRAY FUNCTION GetSiteActiveProfileReferrals(RECORD gathersp)
{
  RECORD ARRAY allsites := SELECT sites.id, sites.name, roottype := fs_objects.type, sites.webroot
                             FROM system.sites, system.fs_objects
                            WHERE sites.id = fs_objects.id;

  /* We need orphans to deal with a temporary corrupted siteprl losing sitedesign/webfeatures features. Shouldn't ever
     get through CI but may happen if you messed up local source checkout. */
  OBJECT sitesettingstype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/sitesettings", [ openorphans := TRUE ]);
  allsites := sitesettingstype->Enrich(allsites, "ID", ["SITEDESIGN","WEBFEATURES"], [ orphans := TRUE]);
  UPDATE allsites SET sitedesign := "publisher:nodesign" WHERE sitedesign = "";

  FOREVERY(RECORD site FROM allsites)
  {
    INTEGER ARRAY siteprofileids;
    RECORD ARRAY tocheck := (SELECT * FROM gathersp.profilerefs WHERE name = site.sitedesign AND isfeature = FALSE)
                            CONCAT
                            (SELECT * FROM gathersp.profilerefs WHERE name IN site.webfeatures AND isfeature = TRUE);
    FOREVERY(RECORD result FROM tocheck)
      siteprofileids := siteprofileids CONCAT result.siteprofileids;

    INSERT CELL siteprofileids := GetSortedSet(siteprofileids) INTO allsites[#site];
  }

  RETURN allsites;
}

RECORD ARRAY FUNCTION GenerateReferrals(RECORD csp)
{
  RECORD ARRAY referrals := GetSiteActiveProfileReferrals(csp);
  referrals := SELECT id, name, roottype, webroot, siteprofileids, sitedesign FROM referrals ORDER BY id;
  RETURN referrals;
}
RECORD FUNCTION GetCacheableCurrentProfileReferrals()
{
  RETURN CELL[ value := GenerateReferrals(GetCachedSiteProfiles())
             , ttl := 60*60*1000
             , eventmasks := site_referrals_mask
             ];
}
PUBLIC MACRO UpdateSiteProfileRefs(RECORD csp)
{
  RECORD ARRAY referrals := GenerateReferrals(csp ?? GetCachedSiteProfiles());
  STRING configpath := GetModuleStorageRoot("system") || "config";
  CreateDiskDirectoryRecursive(configpath, TRUE);
  StoreDiskFile(configpath || "/siteprofilerefs.json", EncodeJSONBlob(referrals), [ overwrite := TRUE ]);
}

RECORD ARRAY FUNCTION GetCurrentProfileReferrals()
{
  RETURN GetAdhocCached([ type := "profilereferrals" ], PTR GetCacheableCurrentProfileReferrals);
}

RECORD ARRAY FUNCTION GetSitesReferredByResources(INTEGER ARRAY siteprofileids)
{
  RECORD ARRAY activeprofiles := GetCurrentProfileReferrals();
  RETURN SELECT * FROM activeprofiles WHERE IsResourceMatch(VAR siteprofileids, activeprofiles.siteprofileids);
}

//expand a <sitesetting> to explain to which sites it applies
PUBLIC INTEGER ARRAY FUNCTION GetSiteSettingIDs(RECORD sitesetting)
{
  //first filter the sites by whether they actually use on of our siteprofiles
  RECORD ARRAY filtered := GetSitesReferredByResources(sitesetting.siteprofileids);

  //apply regexes
  IF(RecordExists(sitesetting.sitefilter))
  {
    OBJECT compiledpattern;
    IF(CellExists(sitesetting.sitefilter, "siteregex"))
      compiledpattern := NEW RegEx(sitesetting.sitefilter.siteregex, "i"); //case insensitive

    OBJECT compiledwebrootpattern;
    IF(CellExists(sitesetting.sitefilter, "webrootregex"))
      compiledwebrootpattern := NEW RegEx(sitesetting.sitefilter.webrootregex, "i"); //case insensitive

    filtered := SELECT *
                  FROM filtered
                 WHERE (CellExists(sitesetting.sitefilter, "sitename") ? ToUppercase(name) = ToUppercase(sitesetting.sitefilter.sitename) : TRUE)
                       AND (CellExists(sitesetting.sitefilter, "sitemask") ? ToUppercase(name) LIKE ToUppercase(sitesetting.sitefilter.sitemask) : TRUE)
                       AND (CellExists(sitesetting.sitefilter, "siteregex") ? compiledpattern->Test(name) : TRUE)
                       AND (CellExists(sitesetting.sitefilter, "webrootregex") ? compiledwebrootpattern->Test(webroot) : TRUE);
  }
  RETURN SELECT AS INTEGER ARRAY id FROM filtered;
}

//describe a specific site for apply testing
PUBLIC RECORD FUNCTION GetSiteApplicabilityInfo(INTEGER siteid)
{
  IF(siteid != 0)
  {
    RECORD ARRAY referrals := GetCurrentProfileReferrals();
    INTEGER matchpos := RecordBinaryFind(referrals, [ id := siteid ], [ "ID" ]);
    IF(matchpos >= 0)
      RETURN referrals[matchpos];
  }

  RETURN [ siteprofileids := INTEGER[], roottype := 0, sitedesign := "" ];
}

PUBLIC RECORD FUNCTION GetBaseProperties(OBJECT applytester) {
  RECORD baseprops := applytester->GetCachedProperty("baseproperties",
    CELL[ description := TRUE
        , isunlisted := FALSE
        , keywords := NOT applytester->objisfolder
        , seotab := FALSE
        , noindex := FALSE
        , nofollow := FALSE
        , noarchive := FALSE
        , requiretitle := FALSE
        , seotabrequireright := ""
        , seotitle := FALSE
    ]);
  RETURN CELL [
    ...baseprops,
    no_index := baseprops.noindex,
    no_follow := baseprops.nofollow,
    no_archive := baseprops.noarchive,
    DELETE noindex,
    DELETE nofollow,
    DELETE noarchive
  ];
}
