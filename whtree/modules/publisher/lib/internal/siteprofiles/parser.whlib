<?wh
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/structuredef.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/support.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::tollium/lib/internal/gettid.whlib";

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::javascript.whlib";

CONSTANT RECORD csp_base_applyrule :=
  [ siteprofile := ""
  , line := 0
  , col := 0

  , baseproperties := DEFAULT RECORD
  , bodyrenderer := DEFAULT RECORD
  , contentlisting := DEFAULT RECORD
  , customnodes := DEFAULT RECORD ARRAY
  , disabletemplateprofile := FALSE
  , extendproperties := DEFAULT RECORD ARRAY
  , folderindex := DEFAULT RECORD
  , setlibrary := DEFAULT RECORD ARRAY
  , modifyfiletypes := DEFAULT RECORD ARRAY
  , modifyfoldertypes := DEFAULT RECORD ARRAY
  , plugins := DEFAULT RECORD ARRAY
  , republishes := DEFAULT RECORD ARRAY
  , scheduletasknows := DEFAULT RECORD ARRAY
  , schedulemanagedtasks := RECORD[]
  , setobjecteditor := DEFAULT RECORD
  , setwidget := DEFAULT RECORD ARRAY
  , sitelanguage := DEFAULT RECORD
  , tagsources := DEFAULT RECORD ARRAY
  , typemappings := DEFAULT RECORD ARRAY
  , uploadtypemapping := DEFAULT RECORD ARRAY
  , urlhistory := DEFAULT RECORD
  , usepublishtemplate := DEFAULT RECORD
  , webdesign := DEFAULT RECORD
  , formdefinitions := DEFAULT RECORD ARRAY
  , mailtemplates := RECORD[]
  , foldersettings := DEFAULT RECORD
  , webtoolsformrules := DEFAULT RECORD ARRAY
  , rtddoc := DEFAULT RECORD
  , hookintercepts := RECORD[]
  , userdata := RECORD[]
  , tos := RECORD[]
  , priority := 0
  , applyindex := 0
  , applynodetype := ""
  , whfstype := ""
];

STRING ARRAY FUNCTION GetHasList(OBJECT node, STRING ARRAY searchfor)
{
  STRING ARRAY haslist;
  FOREVERY(STRING attr FROM searchfor)
    IF(node->HasAttribute(attr))
      INSERT ToUppercase(attr) INTO haslist AT END;
  RETURN GetSortedSet(haslist);
}

STATIC OBJECTTYPE SiteprofileCompilationContext <
  RECORD ARRAY errormessages;
  RECORD ARRAY warnings;
  RECORD ARRAY hints;
  RECORD ARRAY icons;
  STRING filename;
  OBJECT siteprof;
  OBJECT parameters;
  PUBLIC STRING toplevelgid;
  STRING module;
  PUBLIC RECORD ARRAY contenttypes;
  PUBLIC RECORD ARRAY rtdtypes;

  PUBLIC PROPERTY siteprofile(siteprof, -);

  MACRO NEW(STRING filename, OBJECT siteprof, OBJECT parameters)
  {
    this->parameters := parameters;
    this->filename := filename;
    this->siteprof := siteprof;
    //__GetModuleBaseFromResourceName fallback is needed to support texts in site-based siteprofiles
    this->module := GetModuleNameFromResourcePath(filename);
    this->toplevelgid := ParseXMLGid(this->module, "", this->siteprof->xmldoc->documentelement, "", "gid");
  }

  PUBLIC RECORD ARRAY FUNCTION GetErrors()
  {
    RETURN this->errormessages;
  }
  PUBLIC RECORD ARRAY FUNCTION GetWarnings()
  {
    RETURN this->warnings;
  }
  PUBLIC RECORD ARRAY FUNCTION GetHints()
  {
    RETURN this->hints;
  }
  PUBLIC RECORD ARRAY FUNCTION GetIcons()
  {
    RETURN this->icons;
  }

  PUBLIC MACRO AddHint(OBJECT node, STRING message)
  {
    INSERT [ resourcename := this->filename
           , line  :=        node->linenum
           , col :=          0
           , message :=      message
           ] INTO this->hints AT END;
  }
  PUBLIC MACRO AddWarning(OBJECT node, STRING warning)
  {
    INSERT [ resourcename := this->filename
           , line  :=        node->linenum
           , col :=          0
           , message :=      warning
           ] INTO this->warnings AT END;
  }
  PUBLIC MACRO AddError(OBJECT node, STRING error)
  {
    INSERT [ resourcename:= this->filename
           , line  :=        node->linenum
           , col :=          0
           , message :=      error
           ] INTO this->errormessages AT END;
  }
  PUBLIC MACRO AddIcon(OBJECT node, STRING icon)
  {
    IF (icon != "")
    {
      INSERT [ resourcename := this->filename
             , line  :=        node->linenum
             , col :=          0
             , icon :=         icon
             ] INTO this->icons AT END;
    }
  }

  PUBLIC STRING FUNCTION ParseFSPath(OBJECT node, STRING attrname)
  {
    IF(NOT node->HasAttribute(attrname))
      RETURN "";

    STRING val := node->GetAttribute(attrname);
    IF(val LIKE "site::*")
      RETURN val;

    IF(val LIKE "module::*" OR val LIKE "modulescript::*" OR val LIKE "moduledata::*" OR val LIKE "moduleroot::*")
    {
      this->AddError(node, `Old module resource namespaces (eg, module::, moduledata::) are no longer supported`);
      RETURN "";
    }
    IF(val LIKE "site::*" OR val LIKE "mod::*")
      RETURN MakeAbsoluteResourcePath("",val);

    IF(val LIKE "currentsite::*")
    {
      IF(this->filename NOT LIKE "site::*")
      {
        this->AddError(node, "Currentsite paths are not supported by siteprofiles not loaded from a site");
        RETURN "";
      }
      RETURN Tokenize(this->filename,"/")[0] || "/" || Substring(val,13);
    }
    IF(val LIKE "/*")
    {
      IF(this->filename NOT LIKE "site::*")
      {
        this->AddError(node, "currentsite paths are not supported by siteprofiles not loaded from a site");
        RETURN "";
      }
      RETURN Tokenize(this->filename,"/")[0] || val;
    }
    IF(val NOT LIKE "*::*") //its just a relative path
    {
      RETURN MakeAbsoluteResourcePath(this->filename, val);
    }
    this->AddError(node, "Did not recognize siteprofile path format");
    RETURN "";
  }

  STRING FUNCTION ParseTolliumRef(OBJECT node, STRING attr)
  {
    IF(NOT node->HasAttribute(attr))
      RETURN "";
    STRING editfragment := node->GetAttribute(attr);
    IF(editfragment != "" AND editfragment NOT LIKE ".*" AND editfragment NOT LIKE "*#*" AND editfragment NOT LIKE "*:*")
    {
      editfragment := "." || editfragment;

      //we don't warn yet for legacy siteprofiles...
      IF(this->filename NOT LIKE "site::*")
        this->AddError(node, "A reference to a local tollium fragment should be prefixed with '.'");
    }

    STRING fragmentref := MakeAbsoluteScreenReference(this->filename, editfragment);
    IF(fragmentref="")
    {
      this->AddError(node, "Failed to resolve the fragment reference to '" || node->GetAttribute("editfragment") || "' in '" || this->filename || "'");
      RETURN "";
    }
    RETURN fragmentref;
  }

  PUBLIC RECORD FUNCTION GetWidgetEditor(OBJECT node)
  {
    BOOLEAN has_extension := node->HasAttribute("editextension");
    BOOLEAN has_function := node->HasAttribute("editfunctionname");

    IF (has_extension)
    {
      IF(has_function)
        this->AddError(node, "Only one of the editextension or editfunctionname attributes can be specified");

      RETURN [ type := "extension", extension := this->ParseTolliumRef(node,"editextension") ];
    }

    IF(has_function)
      RETURN [ type := "function", functionname := MakeAbsoluteResourcePath(this->filename, node->GetAttribute("editfunctionname")) ];

    RETURN DEFAULT RECORD;
  }

  STRING FUNCTION ParseFunctionRef(OBJECT node, STRING legacylibattr, STRING nameattr, STRING deprecatedsince)
  {
    IF(node->HasAttribute(nameattr))
    {
      STRING objectname := node->GetAttribute(nameattr);
      IF(objectname LIKE "*#*")
      {
        objectname := MakeAbsoluteResourcePath(this->filename, objectname);
      }
      ELSE
      {
        IF(NOT node->HasAttribute(legacylibattr))
        {
          this->AddError(node, `No library specified which would contain '${objectname}'`);
          RETURN "";
        }
        objectname := this->ParseFSPath(node, legacylibattr) || "#" || objectname;
        IF(deprecatedsince != "")
          this->AddWarning(node, `${legacylibattr}= is deprecated, you can specify the full object name in ${nameattr}= since WebHare ${deprecatedsince}`);
      }
      RETURN objectname;
    }
    RETURN "";
  }

  PUBLIC RECORD FUNCTION GetWidgetRenderer(OBJECT node)
  {
    STRING objectname := this->ParseFunctionRef(node, "renderlibrary", "renderobjectname", "4.30.0");
    RETURN objectname != "" ? [ objectname := objectname ] : DEFAULT RECORD;
  }

  PUBLIC MACRO ParseFolderTypes()
  {
    this->ParseFileFolderTypes("foldertype", PTR this->ReadFolderType);
  }
  PUBLIC MACRO ParseFileTypes()
  {
    this->ParseFileFolderTypes("filetype", PTR this->ReadFileType);
  }

  RECORD FUNCTION ParseScopedType(OBJECT node)
  {
    RECORD retval := [ scopedtype := "", namespace := "" ];
    BOOLEAN uses_namespace := node->HasAttribute("namespace");
    retval.namespace := uses_namespace ? node->GetAttribute("namespace") : node->GetAttribute("typedef"); //typedef is the 'old' name before we merged contenttype with filetype
    IF(retval.namespace = "")
      THROW NEW Exception(`No namespace set on <${node->localname}>`);

    RETURN retval;
  }

  PUBLIC MACRO ParseFileFolderTypes(STRING whichtype, FUNCTION PTR parser)
  {
    FOREVERY(OBJECT ftype FROM this->siteprof->xmldoc->documentelement->ListChildren(whconstant_xmlns_publisher, whichtype))
    {
      TRY
      {
        RECORD scopedtypeinfo := this->ParseScopedType(ftype);
        RECORD insertpos := RecordLowerBound(this->contenttypes, [namespace:=scopedtypeinfo.namespace], ["NAMESPACE"]);
        IF(NOT insertpos.found)
          THROW NEW Exception(`Content type ${scopedtypeinfo.namespace} is not defined in this file`);

        OBJECT membersnode := PickFirst(ftype->ListChildren(whconstant_xmlns_publisher, "members"));
        IF(ObjectExists(membersnode) AND ftype->HasAttribute("typedef"))
          this->AddError(ftype, `A type cannot define <members> if it still uses typedef=`);

        RECORD ctype := this->contenttypes[insertpos.position];
        IF(RecordExists(ctype.foldertype) OR RecordExists(ctype.filetype))
          this->AddError(ftype, `Content type ${scopedtypeinfo.namespace} is already setup as a file or folder type`);

        ctype := parser(ctype, ftype);
        this->contenttypes[insertpos.position] := ctype;
      }
      CATCH(OBJECT e)
      {
        this->AddError(ftype, e->what);
      }
    }
  }

  RECORD FUNCTION ReadFileOrFolderType(RECORD ctype, OBJECT ftype)
  {
    ctype.tolliumicon := ftype->GetAttribute("tolliumicon") ?? ftype->GetAttribute("icon"); //TODO once everyone is 4.30, deprecate tolliumicon= and move everyone back to simple icon=
    ctype.title := ParseXMLTIDPtr(this->filename, this->toplevelgid, ftype, "title") ?? ":" || ctype.namespace;
    this->AddIcon(ftype, ctype.tolliumicon);

    OBJECT dyninfo := PickFirst(ftype->ListChildren(whconstant_xmlns_publisher, "dynamicexecution"));
    IF(ObjectExists(dyninfo))
      ctype.dynamicexecution := this->ParseDynamicExecuteData(dyninfo);

    RETURN ctype;
  }

  RECORD FUNCTION ReadFileType(RECORD ctype, OBJECT ftype)
  {
    ctype := this->ReadFileOrFolderType(ctype, ftype);

    ctype.filetype := GetBaseFiletypeRecord();
    if(NOT ftype->HasAttribute("blobiscontent") AND NOT ftype->HasAttribute("kind"))
      this->AddError(ftype, "At least one of 'blobiscontent' and 'kind' attributes must be set");
    if(ftype->HasAttribute("kind") AND ftype->HasAttribute("typedef"))
      this->AddError(ftype, "kind= cannot be used with typedef=, you need to switch to namespace=");

    SWITCH(ftype->GetAttribute("kind"))
    {
      CASE "rawfile"
      {
        ctype.filetype.blobiscontent := TRUE;
        ctype.filetype.ispublishable := TRUE;
      }
      CASE "virtualfile"
      {
        ctype.filetype.needstemplate := TRUE;
        ctype.filetype.ispublishable := TRUE;
        ctype.filetype.ispublishedassubdir := TRUE;
        ctype.filetype.isacceptableindex := TRUE;
      }
    }

    IF(ftype->HasAttribute("blobiscontent"))
     ctype.filetype.blobiscontent := ParseXSBoolean(ftype->GetAttribute("blobiscontent"));
    ctype.filetype.pagelistprovider := this->ParseFSPath(ftype, "pagelistprovider");
    IF(ftype->HasAttribute("needstemplate"))
      ctype.filetype.needstemplate := ParseXSBoolean(ftype->GetAttribute("needstemplate"));
    ctype.filetype.requirescontent := ParseXSBoolean(ftype->GetAttribute("requirescontent"));
    IF(ftype->HasAttribute("isacceptableindex"))
      ctype.filetype.isacceptableindex := ParseXSBoolean(ftype->GetAttribute("isacceptableindex"));
    IF(ftype->HasAttribute("ispublishedassubdir"))
      ctype.filetype.ispublishedassubdir := ParseXSBoolean(ftype->GetAttribute("ispublishedassubdir"));
    IF(ftype->HasAttribute("ispublishable"))
      ctype.filetype.ispublishable := ParseXSBoolean(ftype->GetAttribute("ispublishable"));
    ctype.filetype.searchcontentprovider := QualifyName(this->module, ftype->GetAttribute("searchcontentprovider"));
    ctype.filetype.browserpreview := ftype->GetAttribute("browserpreview");
    ctype.filetype.indexversion := QualifyName(this->module, ftype->GetAttribute("indexversion"));
    ctype.filetype.capturesubpaths := ParseXSBoolean(ftype->GetAttribute("capturesubpaths"));

    IF (RecordExists(ctype.dynamicexecution))
    {
      ctype.filetype.ispublishedassubdir := TRUE;
      ctype.filetype.ispublishable := TRUE;
    }

    IF (ctype.filetype.capturesubpaths AND NOT ctype.filetype.ispublishedassubdir)
    {
      ctype.filetype.capturesubpaths := FALSE;
      this->AddError(ftype, "The option 'capturesubpaths' can only be enabled when 'ispublishedassubdir' is also enabled.");
    }

    IF(ftype->HasAttribute("extensions"))
    {
      ctype.filetype.extensions := Tokenize(TrimWhitespace(ftype->GetAttribute("extensions")), " ");
      IF (Length(ctype.filetype.extensions) > 0 AND ctype.filetype.extensions[0] = "")
        ctype.filetype.extensions := DEFAULT STRING ARRAY;
    }

    ctype.filetype.initialpublish := ctype.filetype.ispublishable AND ParseXSBoolean(ftype->GetAttribute("initialpublish") ?? "true");
    ctype.workflow := ctype.filetype.ispublishable AND NOT ctype.filetype.initialpublish AND ctype.filetype.needstemplate;
    RETURN ctype;
  }

  RECORD FUNCTION ReadFolderType(RECORD ctype, OBJECT ftype)
  {
    ctype := this->ReadFileOrFolderType(ctype, ftype);

    //Now construct the final folder type information record
    ctype.foldertype := GetBaseFolderTypeRecord();
    ctype.foldertype.protectindexfile := ParseXSBoolean(ftype->GetAttribute("protectindexfile"));

    IF (ftype->HasAttribute('indextype'))
    {
      ctype.foldertype.indexfile := 'contentlisting:' || ftype->GetAttribute("indextype"); //NOTE: not really a contentlisting, but a workaround to share the codepath...
    }
    ELSE IF (ftype->HasAttribute('indexfile'))
    {
      IF (ftype->GetAttribute("indexfile") = "none")
        ctype.foldertype.indexfile := "none";
      IF (ftype->GetAttribute("indexfile") = "contentlisting")
        ctype.foldertype.indexfile := "contentlisting:http://www.webhare.net/xmlns/publisher/contentlisting";
    }

    IF (RecordExists(ctype.dynamicexecution)
        AND
        (ctype.dynamicexecution.webpageobjectname != "" OR ctype.dynamicexecution.startmacro != "" OR ctype.dynamicexecution.routerfunction != ""))
    {
      ctype.foldertype.indexfile := "contentlisting:http://www.webhare.net/xmlns/publisher/dynamicfoldercontents";
      ctype.foldertype.protectindexfile := TRUE;
    }
    RETURN ctype;
  }
  PUBLIC STRING FUNCTION ExpandWittyComponent(OBJECT node, STRING attrname)
  {
    IF(NOT node->HasAttribute(attrname))
      RETURN "";
    RETURN MakeAbsoluteResourcePath(this->filename, node->GetAttribute(attrname));
  }

  PUBLIC MACRO ReadContentTypes()
  {
    // All xml elements that contain contenttype definitions
    RECORD ARRAY contenttypeelements :=
        [ [ ns := whconstant_xmlns_publisher,   name := "contenttype" ]
        , [ ns := whconstant_xmlns_publisher,   name := "widgettype" ]
        , [ ns := whconstant_xmlns_publisher,   name := "filetype" ]
        , [ ns := whconstant_xmlns_publisher,   name := "foldertype" ]
        ];

    OBJECT ARRAY contenttypes;
    FOREVERY (RECORD rec FROM contenttypeelements)
    {
      //TODO read them in source order so we get the duplicate type errors in order
      contenttypes := contenttypes CONCAT this->siteprof->xmldoc->documentelement->ListChildren(rec.ns, rec.name);
    }

    FOREVERY(OBJECT ctype FROM contenttypes)
    {
      IF(NOT ctype->HasAttribute("namespace") AND NOT ctype->HasAttribute("scopedtype")) //if neither is set this is an old-style filetype definition (typedef=) which is separate from its contenttype
        CONTINUE;

      TRY
      {
        RECORD typeinfo := this->ReadContentType(ctype);
        RECORD insertpos := RecordLowerBound(this->contenttypes, typeinfo, ["NAMESPACE"]);
        IF(insertpos.found)
          THROW NEW Exception(`Duplicate contenttype definition for ${typeinfo.namespace}`);

        INSERT typeinfo INTO this->contenttypes AT insertpos.position;
      }
      CATCH(OBJECT e)
      {
        this->AddError(ctype, e->what);
      }
    }

    FOREVERY(OBJECT rtdtype FROM this->siteprof->xmldoc->documentelement->ListChildren(whconstant_xmlns_publisher, "rtdtype")) {
      RECORD typeinfo := ParseSiteprofXMLStructure(this, rtdtype);
      typeinfo.namespace := rtdtype->GetAttribute("namespace");

      RECORD insertpos := RecordLowerBound(this->rtdtypes, typeinfo, ["NAMESPACE"]);
      INSERT typeinfo INTO this->rtdtypes AT insertpos.position;
    }
  }

  RECORD FUNCTION ReadCTMembers(OBJECT memberparent, STRING namespace)
  {
    RECORD ARRAY members;
    STRING ARRAY seennames;
    FOR(OBJECT node := memberparent->firstelementchild;ObjectExists(node);node:=node->nextelementsibling)
    {
      IF (node->localname = "member" OR node->localname IN whconstant_whfstype_membertypes)
      {
        RECORD memberinfo := [ name := ToLowercase(node->GetAttribute('name'))
                             , type := GetFSMemberTypeID(node->localname = "member" ? node->GetAttribute('type') : node->localname)
                             , children := DEFAULT RECORD ARRAY
                             ];

        IF(memberinfo.name="")
          this->AddError(node, `Invalid member name '${memberinfo.name}'`);
        ELSE IF(memberinfo.name IN seennames)
          this->AddError(node, `Duplicate member '${memberinfo.name}'`);

        IF(node->HasAttribute("comment"))
          INSERT CELL comment := node->GetAttribute("comment") INTO memberinfo;

        INSERT memberinfo.name INTO seennames AT END;

        IF(ToUppercase(memberinfo.name) LIKE "WHFS*")
        {
          this->AddError(node, `Member names starting with 'WHFS' are reserved and should not be used`);
          CONTINUE;
        }
        IF(memberinfo.type<1)
        {
          this->AddError(node, `Invalid member type '${node->GetAttribute('type')}'`);
          CONTINUE;
        }

        IF(memberinfo.type=12) // array
        {
          RECORD ctmembers := this->ReadCTMembers(node, namespace);
          memberinfo.children := ctmembers.members;
        }
        INSERT memberinfo INTO members AT END;
      }
    }
    RETURN CELL [ members ];
  }

  RECORD FUNCTION ReadContentType(OBJECT ctype)
  {
    // Type of the contenttype is the localname (ignore the namespace)
    STRING nodename := ctype->localname ?? ctype->nodename;

    RECORD scopedtypeinfo := this->ParseScopedType(ctype);
    BOOLEAN set_cloneoncopy := nodename != "contenttype" OR (ctype->HasAttribute("cloneoncopy") = FALSE OR ParseXSBoolean(ctype->GetAttribute("cloneoncopy")));
    INTEGER typedefid;

    OBJECT membersnode := ctype->GetChildElementsByTagNameNS(whconstant_xmlns_publisher, "members")->Item(0);
    RECORD newmembers := this->ReadCTMembers(membersnode ?? ctype, scopedtypeinfo.namespace);

    RECORD typeinfo := MakeBasicTypeInfo(nodename);
    typeinfo.id := typedefid;
    typeinfo.scopedtype := scopedtypeinfo.scopedtype;
    typeinfo.namespace := scopedtypeinfo.namespace;
    typeinfo.siteprofile := this->filename;
    typeinfo.line := ctype->linenum;
    typeinfo.title := ParseXMLTIDPtr(this->filename, this->toplevelgid, ctype, "title") ?? ":" || scopedtypeinfo.namespace;
    typeinfo.tolliumicon := ctype->GetAttribute("tolliumicon") ?? ctype->GetAttribute("icon"); //TODO once everyone is 4.30, deprecate tolliumicon= and move everyone back to simple icon=
    typeinfo.cloneoncopy := set_cloneoncopy;
    typeinfo.cloneonarchive := set_cloneoncopy;
    INSERT CELL members := newmembers.members INTO typeinfo;

    this->AddIcon(ctype, typeinfo.tolliumicon);

    IF (nodename = "widgettype")
    {
      INSERT CELL editor := this->GetWidgetEditor(ctype)
                , renderer := this->GetWidgetRenderer(ctype)
                , embedtype := ctype->GetAttribute("embedtype") ?? "block"
                , requiremergefieldscontext := ParseXSBoolean(ctype->GetAttribute("requiremergefieldscontext"))
             INTO typeinfo;

      IF(typeinfo.tolliumicon = "")
        typeinfo.tolliumicon := "tollium:files/widget";

      typeinfo.filetype :=  GetBaseFiletypeRecord();
      typeinfo.filetype.needstemplate := nodename!="widgettype";
      typeinfo.filetype.ispublishedassubdir := nodename!="widgettype";
      typeinfo.filetype.ispublishable := nodename!="widgettype" AND ParseXSBoolean(ctype->GetAttribute("ispublishable"));
      typeinfo.filetype.generatepreview := nodename="widgettype";

      typeinfo.wittycomponent := this->ExpandWittyComponent(ctype, "wittycomponent");
      typeinfo.previewcomponent := this->ExpandWittyComponent(ctype, "previewcomponent");

      typeinfo.ingroup := ctype->GetAttribute("ingroup");
    }

    RETURN typeinfo;
  }

  RECORD FUNCTION ParseWebDesign(OBJECT node)
  {
    RECORD webdesign := [ objectname               := this->ParseFunctionRef(node, "library", "objectname", "")
                        , getdata                  := this->ParseFSPath(node, "getdata")
                        , siteresponsefactory      := this->ParseFSPath(node, "siteresponsefactory")
                        , witty                    := this->ParseFSPath(node, "witty")
                        , assetpack                := ""
                        , wittyencoding            := node->GetAttribute("wittyencoding")
                        , designfolder             := this->ParseFSPath(node, "designfolder")
                        , maxcontentwidth          := node->GetAttribute("maxcontentwidth")
                        , siteprofile              := this->siteprof->name
                        , supportserrors           := ParseXSBoolean(node->GetAttribute("supportserrors"))
                        , supportsaccessdenied     := ParseXSBoolean(node->GetAttribute("supportsaccessdenied"))
                        , contentnavstops          := ParseXSList(node->GetAttribute("contentnavstops"))

                        , has_assetpack            := node->HasAttribute("assetpack")
                        , has_supportserrors       := node->HasAttribute("supportserrors")
                        , has_supportsaccessdenied := node->HasAttribute("supportsaccessdenied")
                        , has_contentnavstops      := node->HasAttribute("contentnavstops")
                        ];

    webdesign.assetpack := QualifyName(this->module,node->GetAttribute("assetpack"));
    IF(webdesign.assetpack != "" AND webdesign.assetpack != "publisher:__dummy__") //publisher:__dummy__ is how we separate 'publisher:nodesign' from 'forgot to set asset pack'
    {
      RECORD assetpackinfo := SELECT * FROM this->parameters->assetpacks WHERE ToUppercase(name) = ToUppercase(webdesign.assetpack);
      IF(NOT RecordExists(assetpackinfo))
        this->AddError(node, `No such assetpack '${webdesign.assetpack}'`);
    }

    IF(webdesign.designfolder != "" AND webdesign.designfolder NOT LIKE "*/")
      webdesign.designfolder := webdesign.designfolder || "/";

    RETURN webdesign;
  }

  RECORD FUNCTION ParseDynamicExecuteData(OBJECT node)
  {
    STRING startmacro := this->ParseFunctionRef(node, "library", "startmacro", "4.30.0");
    STRING webpageobjectname := this->ParseFunctionRef(node, "library", "webpageobjectname", "4.30.0");
    STRING routerfunction := this->ParseFunctionRef(node, "library", "routerfunction", "4.30.0");

    IF (startmacro = "" AND webpageobjectname = "" AND routerfunction="") //specifying both is acceptable, startmacro will take precedence but webpageobjectname will be used for RPCs
    {
      this->AddError(node, "Either 'startmacro', 'webpageobjectname' or 'routerfunction' must be specified");
      RETURN DEFAULT RECORD;
    }

    RETURN
        CELL[ startmacro
            , webpageobjectname
            , routerfunction

            , cachettl                := ParseXSInt(node->GetAttribute("cachettl"))
            , cachewebvariables       := ParseXSList(ToUppercase(node->GetAttribute("cachewebvariables")))
            , cacheblacklistvariables := ParseXSList(ToUppercase(node->GetAttribute("cacheblacklistvariables")))
            , cachewebcookies         := ParseXSList(ToUppercase(node->GetAttribute("cachewebcookies")))
            , cacheblacklistcookies   := ParseXSList(ToUppercase(node->GetAttribute("cacheblacklistcookies")))
            ];
  }

  MACRO ValidateRegex(OBJECT node, STRING pattern, STRING attributename)
  {
    IF(pattern = "")
      RETURN;

    OBJECT compiledpattern := NEW RegEx(pattern, "i"); //case insensitive
    TRY compiledpattern->Test("");
    CATCH (OBJECT e)
    {
      //if it throws, the regex is broken
      this->AddError(node, `Invalid regular expression in '${attributename}': ${e->what}`);
    }
  }

  MACRO ValidateSiteFilter(OBJECT node, RECORD sitefilter)
  {
    IF(CellExists(sitefilter, "siteregex"))
      this->ValidateRegex(node, sitefilter.siteregex, "siteregex");
    IF(CellExists(sitefilter, "webrootregex"))
      this->ValidateRegex(node, sitefilter.webrootregex, "webrootregex");
  }

  RECORD FUNCTION ReadSiteFilter(OBJECT matchnode) {
    RECORD retval;

    IF(matchnode->HasAttribute("sitename"))
      INSERT CELL sitename := matchnode->GetAttribute("sitename") INTO retval;

    IF(matchnode->HasAttribute("sitemask"))
      INSERT CELL sitemask := matchnode->GetAttribute("sitemask") INTO retval;

    IF(matchnode->HasAttribute("siteregex"))
      INSERT CELL siteregex := matchnode->GetAttribute("siteregex") INTO retval;

    IF(matchnode->HasAttribute("webrootregex"))
      INSERT CELL webrootregex := matchnode->GetAttribute("webrootregex") INTO retval;

    IF((CellExists(retval,'sitename') ? 1:0) + (CellExists(retval,'sitemask') ? 1:0) > 1 + (CellExists(retval,'siteregex') ? 1:0))
      this->AddError(matchnode, "<to and <sitesettings rules should use only one of sitename=, sitemask= and siteregex=");

    RETURN retval;
  }

  PUBLIC RECORD ARRAY FUNCTION ParseApplyTosRecurse(OBJECT basenode) {
    RECORD ARRAY applytos;

    //ADDME: Instead of continueing, report the error during compilation
    FOREVERY(OBJECT crit FROM basenode->childnodes->GetCurrentElements())
      IF(crit->namespaceuri = whconstant_xmlns_publisher)
      {
        RECORD applyto;
        SWITCH(crit->localname)
        {
          CASE "and", "or", "not"
          {
            applyto := [ type := crit->localname
                       , criteria := this->ParseApplyTosRecurse(crit)
                       ];
          }
          CASE "to"
          {
            STRING type := crit->GetAttribute("type");

            applyto :=
                  CELL [ ...this->ReadSiteFilter(crit)
                       , type         := "to"
                       , match_all    := type="all"
                       , match_file   := type="file" OR type="index"
                       , match_index  := type="index"
                       , match_folder := type="folder"
                       , pathmask     := crit->GetAttribute("pathmask")
                       , pathregex    := crit->GetAttribute("pathregex")
                       , whfspathmask := crit->GetAttribute("whfspathmask")
                       , whfspathregex:= crit->GetAttribute("whfspathregex")
                       , parentmask   := crit->GetAttribute("parentmask")
                       , parentregex  := crit->GetAttribute("parentregex")
                       , parenttype   := crit->GetAttribute("parenttype")
                       , withintype   := crit->GetAttribute("withintype")
                       , sitetype     := crit->GetAttribute("sitetype")
                       , filetype     := crit->GetAttribute("filetype") ?? crit->GetAttribute("contentfiletype") //TODO Post WH5.9 consider deprecating or simply dropping contentfiletype=
                       , foldertype   := crit->GetAttribute("foldertype")
                       , typeneedstemplate := ParseXSBoolean(crit->GetAttribute("typeneedstemplate"))
                       , webfeatures  := ParseXSList(ToUppercase(crit->GetAttribute("webfeatures" )))
                       ];

            this->ValidateSiteFilter(crit, applyto);

            // Prevent duplicate attributes that may conflict with each other but also make YML mapping harder (as YML will just use on attribute for all these groups below)
            IF((applyto.pathmask != "" ? 1:0) + (applyto.pathregex != "" ? 1:0) > 1)
              this->AddError(crit, "<to rules should use only one of pathmask= and pathregex=");
            IF((applyto.whfspathmask != "" ? 1:0) + (applyto.whfspathregex != "" ? 1:0) > 1)
              this->AddError(crit, "<to rules should use only one of whfspathmask= and whfspathregex=");
            IF((applyto.parentmask != "" ? 1:0) + (applyto.parentregex != "" ? 1:0) > 1)
              this->AddError(crit, "<to rules should use only one of parentmask= and parentregex=");
            IF((applyto.filetype != "" ? 1:0) + (applyto.foldertype != "" ? 1:0) > 1)
              this->AddError(crit, "<to rules should use only one of filetype= and foldertype=");

            IF(applyto.pathregex != "")
              this->ValidateRegex(crit, applyto.pathregex, "pathregex");
            IF(applyto.parentregex != "")
              this->ValidateRegex(crit, applyto.parentregex, "parentregex");
            IF(applyto.whfspathregex != "")
              this->ValidateRegex(crit, applyto.whfspathregex, "whfspathregex");
            IF(applyto.filetype!="" AND NOT applyto.match_file)
            {
              this->AddError(crit, "Apply <to> rule is trying to match a file type, but is not set to apply to files");
              CONTINUE;
            }
            IF(applyto.foldertype!="" AND NOT applyto.match_folder)
            {
              this->AddError(crit, "Apply <to> rule is trying to match a folder type, but is not set to apply to folders");
              CONTINUE;
            }
          }
          CASE "testdata"
          {
            applyto := [ type        := "testdata"
                       , target      := crit->GetAttribute("target")
                       , typedef     := crit->GetAttribute("typedef")
                       , membername  := crit->GetAttribute("member")
                       , value       := crit->GetAttribute("value")
                       ];
          }
          DEFAULT
          {
            CONTINUE;//ADDME: Log error?
          }
        }
      INSERT applyto INTO applytos AT END;
    }
    RETURN applytos;
  }

  RECORD ARRAY FUNCTION ParseSources(OBJECT node)
  {
    RECORD ARRAY paths := SELECT path := sourcenode->GetAttribute("path")
                               , relativeto := sourcenode->GetAttribute("relativeto") ?? "siteprofile"
                            FROM ToRecordArray(node->childnodes->GetCurrentElements(), "sourcenode");
    UPDATE paths SET relativeto := "siteprofile" WHERE path LIKE "*::*";
    UPDATE paths SET path := MakeAbsoluteResourcePath(this->filename, path) WHERE relativeto="siteprofile";
    RETURN paths;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportApplies()
  {
    OBJECT ARRAY applies := this->siteprof->xmldoc->documentelement->ListElements(whconstant_xmlns_publisher, "*");
    RECORD ARRAY applyrules;
    RECORD counters := [ apply := 0, filetype := 0, foldertype := 0, widgettype := 0 ];
    FOREVERY(OBJECT applyblock FROM applies)
    {
      STRING applynodetype := applyblock->localname;

      IF(NOT CellExists(counters, applynodetype)) //is it <apply>, <widgettype>, <filetype> or <foldertype> ?
        CONTINUE; //don't care for this node


      INTEGER applyindex := GetCell(counters, applynodetype);
      counters := CellUpdate(counters, applynodetype, applyindex + 1);

      IF(NOT IsNodeApplicableToThisWebHare(applyblock))
        CONTINUE;

      RECORD apply := this->ImportApplyItems(applyblock, applynodetype = "apply" ? "" : applyblock->GetAttribute("namespace"));
      IF(NOT RecordExists(apply))
        CONTINUE; //no content

      apply.priority := ParseXSInt(applyblock->GetAttribute("priority"));
      apply.applyindex := applyindex;
      apply.applynodetype := applynodetype;

      IF(applynodetype = "apply")
        apply.tos := this->ParseApplyTosRecurse(applyblock);
      ELSE
        apply.whfstype := applyblock->GetAttribute("namespace");

      INSERT apply INTO applyrules AT END;
    }
    RETURN applyrules;
  }

  RECORD FUNCTION ImportApplyItems(OBJECT applyblock, STRING targetnamespace)   {
    BOOLEAN errorsarenowfatal;
    BOOLEAN anynode;
    RECORD apply := CELL[
      ...csp_base_applyrule,
      siteprofile := this->siteprof->name,
      line := applyblock->linenum,
      col := 0
      ];

    STRING ARRAY seenuniques;

    FOREVERY(OBJECT node FROM applyblock->childnodes->GetCurrentElements())
    {
      //Skip non-aplpyitems (<to> rules and filetype/foldertype nodes)
      IF(node->localname IN ["to","not","and","or","xor","testtype","testdata","dynamicexecution","members"])
        CONTINUE;

      anynode := TRUE;

      IF(node->localname IN ["bodyrenderer","sitelanguage","folderindex", "contentlisting", "rtddoc"
                            ,"setobjecteditor"])
      {
        IF(node->localname IN seenuniques)
        {
          this->AddError(node, "Duplicate <" || node->localname || "> in a single apply block");
          CONTINUE;
        }
        INSERT node->localname INTO seenuniques AT END;
      }

      TRY
      {
        IF(node->namespaceuri = whconstant_xmlns_publisher)
        {
          SWITCH(node->localname)
          {
            CASE "extendproperties"
            {
              STRING extension := this->ParseTolliumRef(node,"extension");
              STRING contenttype := node->GetAttribute("contenttype") ?? targetnamespace;
              IF(targetnamespace = "") //an <apply> block
              {
                IF(contenttype = "" AND extension != "")
                  this->AddError(node, "An extendproperties with extension= requires a content type");
              }

              RECORD applynode := [ contenttype := contenttype
                                  , requireright := node->GetAttribute("requireright")
                                  , extension := extension
                                  ];
              INSERT applynode INTO apply.extendproperties AT END;
              CONTINUE;
            }
            CASE "formdefinitions"
            {
              INSERT [ path := MakeLegacyAbsoluteResourcePath(this->filename, node->GetAttribute("path"), "data")
                     , name := node->GetAttribute("name")
                     ] INTO apply.formdefinitions AT END;
              CONTINUE;
            }
            CASE "webdesign"
            {
              apply.webdesign :=  this->ParseWebDesign(node);
              CONTINUE;
            }
            CASE "baseproperties"
            {
              apply.baseproperties := [ haslist := GetHasList(node, [ "title", "description", "keywords", "striprtdextension", "seotab", "seotabrequireright", "noindex", "nofollow", "noarchive", "seotitle" ])
                                      , title := ParseXSBoolean(node->GetAttribute("title"))
                                      , description := ParseXSBoolean(node->GetAttribute("description"))
                                      , keywords := ParseXSBoolean(node->GetAttribute("keywords"))
                                      , striprtdextension := ParseXSBoolean(node->GetAttribute("striprtdextension"))
                                      , seotab := ParseXSBoolean(node->GetAttribute("seotab"))
                                      , seotabrequireright := node->GetAttribute("seotabrequireright")
                                      , noindex := ParseXSBoolean(node->GetAttribute("noindex"))
                                      , nofollow := ParseXSBoolean(node->GetAttribute("nofollow"))
                                      , noarchive := ParseXSBoolean(node->GetAttribute("noarchive"))
                                      , seotitle := ParseXSBoolean(node->GetAttribute("seotitle"))
                                      ];
              CONTINUE;
            }
            CASE "urlhistory"
            {
              RECORD urlhistory := [ haslist := GetHasList(node, ["accesscheck"])
                                   , accesscheck := MakeAbsoluteResourcePath(this->filename, node->GetAttribute("accesscheck"))
                                   ];

              IF(Length(urlhistory.haslist) > 0)
                apply.urlhistory := urlhistory;

              CONTINUE;
            }
            CASE "bodyrenderer"
            {
              apply.bodyrenderer := [ objectname := this->ParseFunctionRef(node, "library", "objectname", "4.30.0")
                                    , renderer := MakeAbsoluteResourcePath(this->filename, node->GetAttribute("renderer"))
                                    ];
              CONTINUE;
            }
            CASE "sitelanguage"
            {
              apply.sitelanguage := [ lang := node->GetAttribute("lang")
                                    , has_lang := node->HasAttribute("lang")
                                    ];
              CONTINUE;
            }
            CASE "usepublishtemplate"
            {
              RECORD usepublishtemplate := [ script := this->ParseFSPath(node, "script")
                                           ];

              IF(usepublishtemplate.script = "")
              {
                usepublishtemplate.script := this->siteprof->ParseFSTwopartPathString(node->GetAttribute("site"), node->GetAttribute("fullpath"));
                this->AddWarning(node, `<usepublishtemplate/> should use script=, not site=/fullpath=`);
              }
              IF(usepublishtemplate.script = "") //still unset
              {
                this->AddError(node, `<usepublishtemplate/> must set a script=`);
              }
              ELSE
              {
                apply.usepublishtemplate := usepublishtemplate;
              }
              CONTINUE;
            }
            CASE "allowfoldertype"
            {
              INSERT [ isallow := TRUE
                     , typedef := node->GetAttribute("typemask") ?? node->GetAttribute("typedef")
                     , newonlytemplate := ParseXSBoolean(node->GetAttribute("newonlytemplate"))
                     , setnewonlytemplate := node->HasAttribute("newonlytemplate")
                     ] INTO apply.modifyfoldertypes AT END;
              CONTINUE;
            }
            CASE "denyfoldertype"
            {
              INSERT [ isallow := FALSE
                     , typedef := node->GetAttribute("typemask") ?? node->GetAttribute("typedef")
                     ] INTO apply.modifyfoldertypes AT END;
              CONTINUE;
            }
            CASE "allowfiletype"
            {
              INSERT [ isallow := TRUE
                     , typedef := node->GetAttribute("typemask") ?? node->GetAttribute("typedef")
                     , newonlytemplate := ParseXSBoolean(node->GetAttribute("newonlytemplate"))
                     , setnewonlytemplate := node->HasAttribute("newonlytemplate")
                     ] INTO apply.modifyfiletypes AT END;
              CONTINUE;
            }
            CASE "denyfiletype"
            {
              INSERT [ isallow := FALSE
                     , typedef := node->GetAttribute("typemask") ?? node->GetAttribute("typedef")
                     ] INTO apply.modifyfiletypes AT END;
              CONTINUE;
            }
            CASE "uploadtypemapping"
            {
              INSERT [ filenamemask := node->GetAttribute("filenamemask")
                     , mimetypemask := node->GetAttribute("mimetypemask")
                     , filetype     := node->GetAttribute("filetype")
                     ] INTO apply.uploadtypemapping AT END;
              CONTINUE;
            }
            CASE "tagsource"
            {
              RECORD rec :=
                  [ contenttype :=    node->GetAttribute("contenttype")
                  , membername :=     node->GetAttribute("member")
                  , tagfolder :=      this->ParseFSPath(node, "tagfolder")
                  , repository :=     node->GetAttribute("repository")
                  , allowcreate :=    ParseXSBoolean(node->GetAttribute("allowcreate"))
                  ];
              INSERT rec INTO apply.tagsources AT RecordUpperBound(apply.tagsources, rec, [ "CONTENTTYPE", "MEMBERNAME" ]);
              CONTINUE;
            }
            CASE "republish"
            {
              INSERT [ onchange := node->GetAttribute("onchange")
                     , sitemask := node->GetAttribute("sitemask")
                     , folder   := node->GetAttribute("folder")
                     , mask     := node->HasAttribute("mask") ? node->GetAttribute("mask") : "*"
                     , recursive:= ParseXSBoolean(node->GetAttribute("recursive"))
                     , indexonly:= ParseXSBoolean(node->GetAttribute("indexonly"))
                     , scope    := node->GetAttribute("scope")
                     ] INTO apply.republishes AT END;
              CONTINUE;
            }
            CASE "scheduletimedtask"
            {
              INSERT [ task := node->GetAttribute("task")
                     , delay := ParseXSInt(node->GetAttribute("delay"))
                     ] INTO apply.scheduletasknows AT END;
              CONTINUE;
            }
            CASE "schedulemanagedtask"
            {
              INSERT [ task := node->GetAttribute("task")
                     ] INTO apply.schedulemanagedtasks AT END;
              CONTINUE;
            }
            CASE "folderindex"
            {
              RECORD data := [ indexfile        := node->GetAttribute("indexfile")
                             , protectindexfile := ParseXSBoolean(node->GetAttribute("protectindexfile"))
                             , fullpath         := node->GetAttribute("fullpath")
                             , site             := node->GetAttribute("site")
                             , newfiletype      := node->GetAttribute("newfiletype")
                             , newfilename      := node->GetAttribute("newfilename")
                             ];

              IF (data.indexfile = "copy_of_file" AND data.fullpath="")
              {
                this->AddError(node, "Folder index definition selected copy_of_file, but does not specify fullpath");
                CONTINUE;
              }
              IF (data.indexfile = "newfile" AND data.newfiletype="")
              {
                this->AddError(node, "Folder index definition selected newfile, but does not specify a newfiletype");
                CONTINUE;
              }
              IF(data.indexfile IN ["","none"])
                data.protectindexfile := FALSE; // no newly created file to protect so stabilize our outptu
              apply.folderindex := data;
              CONTINUE;
            }
            CASE "rtddoc"
            {
              RECORD data := [ margins := node->GetAttribute("margins")
                             , rtdtype := node->GetAttribute("rtdtype")
                             , htmlclass := node->GetAttribute("htmlclass")
                             , bodyclass := node->GetAttribute("bodyclass")
                             ];

              IF(NOT node->HasAttribute("margins") OR data.margins NOT IN whconstant_tollium_rtd_margins)
                DELETE CELL margins FROM data;
              IF(NOT node->HasAttribute("rtdtype"))
                DELETE CELL rtdtype FROM data;
              IF(NOT node->HasAttribute("htmlclass"))
                DELETE CELL htmlclass FROM data;
              IF(NOT node->HasAttribute("bodyclass"))
                DELETE CELL bodyclass FROM data;

              apply.rtddoc := data;
              CONTINUE;
            }
            CASE "contentlisting"
            {
              RECORD data := [ fullpath := node->GetAttribute("fullpath")
                             , site := node->GetAttribute("site")
                             ];
              IF(data.fullpath="")
              {
                this->AddError(node, "<" || node->localname || "> definition does not specify fullpath");
                CONTINUE;
              }

              apply := CellUpdate(apply, node->localname, data);
              this->AddWarning(node, "<contentlisting> is only supported by template-v2.whlib designs and will be removed in the future");
              CONTINUE;
            }
            CASE "setobjecteditor"
            {
              apply.setobjecteditor := [ name := node->GetAttribute("name")
                                       , screen := MakeAbsoluteScreenReference(this->filename, node->GetAttribute("screen"))
                                       , separateapp := ParseXSBoolean(node->GetAttribute("separateapp"))
                                       ];

              IF(apply.setobjecteditor.name = "" AND apply.setobjecteditor.screen = "")
                this->Adderror(node, "<setobjecteditor> lacks both name and screen");
              ELSE IF(apply.setobjecteditor.name != "" AND apply.setobjecteditor.screen != "")
                this->Adderror(node, "<setobjecteditor> has both name and screen, only one is allowed");
              CONTINUE;
            }
            CASE "setwidget"
            {
              apply.setwidget := apply.setwidget CONCAT
                 [[ contenttype := node->GetAttribute("contenttype")
                  , editor := this->GetWidgetEditor(node)
                  , renderer := this->GetWidgetRenderer(node)
                  , wittycomponent := this->ExpandWittyComponent(node, "wittycomponent")
                  , previewcomponent := this->ExpandWittyComponent(node, "previewcomponent")
                  , has_wittycomponent := node->HasAttribute("wittycomponent")
                  , has_previewcomponent := node->HasAttribute("previewcomponent")
                 ]];
            }
            CASE "disablelegacysitesettings"
            {
              CONTINUE;
            }
            CASE "customplugin"
            {
              RECORD plugin := MakePluginRecord(this->ParseFunctionRef(node, "library", "objectname", "4.30.0"));
              plugin := InstantiatePlugin(plugin);
              plugin.combine := FALSE;

              INSERT plugin INTO apply.plugins AT END;
              CONTINUE;
            }
            CASE "setlibrary"
            {
              INSERT [ name := node->GetAttribute("name")
                     , sources := this->ParseSources(node)
                     ] INTO apply.setlibrary AT END;
              CONTINUE;
            }
            CASE "foldersettings"
            {
              apply.foldersettings := [ filterscreen := MakeAbsoluteResourcePath(this->filename, node->GetAttribute("filterscreen"))
                                      , has_filterscreen := node->HasAttribute("filterscreen")
                                      , ordering := node->GetAttribute("ordering")
                                      , contentslisthandler := DEFAULT RECORD
                                      ];

              OBJECT contentslisthandler := node->GetElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile","contentslisthandler")->Item(0);
              IF(ObjectExists(contentslisthandler))
              {
                apply.foldersettings.contentslisthandler := [ objectname := this->ParseFunctionRef(contentslisthandler, "library", "objectname", "4.31.0")
                                                            ];
              }
              CONTINUE;
            }
            CASE "mailtemplate"
            {
              INSERT CELL[ path := this->siteprof->ParseFSPath(node, "path")
                         , title := ParseXMLTidPtr(this->filename, this->toplevelgid, node, "title")
                         , ordering := ParseXSInt(node->GetAttribute("ordering"))
                         , sources := this->ParseSources(node)
                         ] INTO apply.mailtemplates AT END;
              CONTINUE;
            }
            CASE "allowformquestion","denyformquestion"
            {
              INSERT
                  [ comp := "component"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
            CASE "allowformhandler","denyformhandler"
            {
              INSERT
                  [ comp := "handler"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
            CASE "allowformrtdtype","denyformrtdtype"
            {
              INSERT
                  [ comp := "rtdtype"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
            CASE "intercept"
            {
              RECORD intercept := ParseIntercept(this, this->filename, node);
              IF(RecordExists(intercept))
                INSERT intercept INTO apply.hookintercepts AT END;
              CONTINUE;
            }
            CASE "userdata"
            {
              STRING value := node->GetAttribute("value");
              VARIANT decode := DecodeJSON(value);
              IF(TYPEID(decode) != TYPEID(RECORD) OR NOT RecordExists(decode))
              {
                this->AddError(node, "Invalid JSON in userdata");
                CONTINUE;
              }
              INSERT [ "key" := node->GetAttribute("key")
                      , "value" := value //we don't decode here so we can save case-sensitive properties for JS
                      ] INTO apply.userdata AT END;
              CONTINUE;
            }
          }
        }

        //Verify it against the list of plugins
        BOOLEAN matched;
        FOREVERY(RECORD plugin FROM this->parameters->webdesignplugins)
          IF(plugin.namespace = node->namespaceuri AND plugin.name = node->localname) {
            plugin := InstantiatePlugin(plugin);

            IF(plugin.parser != "") { //A seperate parser entrypoint. Should be used to cut back on LOADLIBs/compilations triggered by SP parsing
              errorsarenowfatal := TRUE; //any error here should abort siteprofile compilation to avoid plugins silently disappearing due to out-of-date errors
              FUNCTION PTR parser := MakeFunctionPtr(plugin.parser);
              errorsarenowfatal := FALSE;

              plugin.data := parser(this, node);
              IF(RecordExists(plugin.data)) {
                IF(NOT CellExists(plugin.data, "__attributes"))
                  INSERT CELL __attributes := DefaultListConfigurationNodeAttributes(node) INTO plugin.data;
                plugin.data := CELL [...plugin.data, __location := this->filename || ":" || node->linenum ];
              }
            } ELSE { //Pre 5.8 approach: instantiate the plugin to get to its parser APIs
              //Instantiate the plugin to let it parse its own settings
              errorsarenowfatal := TRUE; //any error here should abort siteprofile compilation to avoid plugins silently disappearing due to out-of-date errors
              OBJECT pluginobj := MakeObject(plugin.objectname);
              errorsarenowfatal := FALSE;

              plugin.data := pluginobj->ParseConfigurationNode(this, node);
              IF(RecordExists(plugin.data))
              {
                INSERT CELL __attributes := pluginobj->ListConfigurationNodeAttributes(node)
                          , __location := this->filename || ":" || node->linenum
                      INTO plugin.data;
              }
            }

            INSERT plugin INTO apply.plugins AT END;
            matched := TRUE;
            BREAK;
          }

        IF(NOT matched)
          FOREVERY(RECORD siteprofnode FROM this->parameters->customnodes)
            IF(siteprofnode.namespace = node->namespaceuri  AND siteprofnode.name = node->localname)
            {
              matched := TRUE;
              INSERT [ namespaceuri := node->namespaceuri, localname := node->localname ] INTO apply.customnodes AT END;
              BREAK;
            }

        //Anything not processed, is a custom node requestable by GetCustomSiteProfileSettings
        IF(NOT matched)
        {
          this->AddError(node, "Unrecognized or unsupported node " || node->namespaceuri || "#" || node->localname);
        }
      }
      CATCH(OBJECT e)
      {
        IF(errorsarenowfatal)
          THROW;

        this->AddError(node, e->what);
      }
    }
    RETURN anynode ? apply : DEFAULT RECORD;
  }

  PUBLIC OBJECT ARRAY FUNCTION GetSiteSettingNodes()
  {
    OBJECT ARRAY applicablenodes;
    FOREVERY(OBJECT node FROM this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile", "sitesettings")->GetCurrentElements())
    {
      IF(NOT IsNodeApplicableToThisWebHare(node))
        CONTINUE;
      INSERT node INTO applicablenodes AT END;
    }
    RETURN applicablenodes;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportSiteSettings()
  {
    RECORD ARRAY sitesettings;
    FOREVERY(OBJECT siteset FROM this->GetSiteSettingNodes())
    {
      RECORD sitesetting := [ sitefilter := this->ReadSiteFilter(siteset)
                            , webrules := DEFAULT RECORD ARRAY
                            , addtocatalogs := DEFAULT RECORD ARRAY
                            , line := siteset->linenum
                            ];
      this->ValidateSiteFilter(siteset, sitesetting.sitefilter);

      OBJECT ARRAY sitewebrules := siteset->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/system/moduledefinition", "webruleset")->GetCurrentElements();
      FOREVERY(OBJECT webruleset FROM sitewebrules)
      {
        INTEGER priority := ParseWebRulePriority(webruleset->GetAttribute("priority"));

        FOREVERY(OBJECT webrule FROM GetWebRuleNodes(webruleset))
        {
          RECORD baserule := GetBaseWebRule(-9999999, webrule->GetAttribute("path"), priority, this->siteprof->name || ":" || webrule->linenum);
          RECORD parsed := ParseWebRuleData(this->module, baserule, webrule, this->siteprof->name);
          this->errormessages := this->errormessages CONCAT parsed.errors;
          this->warnings := this->warnings CONCAT parsed.warnings;

          IF(NOT RecordExists(parsed.rule))
            CONTINUE;

          RECORD therule := [ rule :=         parsed.rule
                            , module :=       this->module
                            , siteprofile :=  this->siteprof->name
                            , line :=         webrule->linenum
                            , col :=          0
                            ];

          INSERT therule INTO sitesetting.webrules AT END;
        }
      }

      OBJECT ARRAY addtocatalogs := siteset->GetChildElementsByTagNameNS(whconstant_xmlns_publisher, "addtocatalog")->GetCurrentElements();
      FOREVERY(OBJECT addtocatalog FROM addtocatalogs)
      {
        RECORD theindex := [ catalog := QualifyName(this->module, addtocatalog->GetAttribute("catalog"))
                           , module := this->module
                           , siteprofile := this->siteprof->name
                           , line := addtocatalog->linenum
                           , col := 0
                           , folder := addtocatalog->GetAttribute("folder") ?? "/"
                           ];

        INSERT theindex INTO sitesetting.addtocatalogs AT END;
      }

      INSERT sitesetting INTO sitesettings AT END;
    }
    RETURN sitesettings;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportGroupTypes()
  {
    RECORD ARRAY types;
    OBJECT ARRAY grouptypes := this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS(whconstant_xmlns_publisher, "grouptype")->GetCurrentElements();
    FOREVERY(OBJECT gtype FROM grouptypes)
    {
      RECORD typeinfo :=
          [ namespace :=          gtype->GetAttribute("namespace")
          , title :=              ParseXMLTIDPtr(this->filename, this->toplevelgid, gtype, "title") ?? ":" || gtype->GetAttribute("namespace")
          , tolliumicon :=        gtype->GetAttribute("tolliumicon") ?? gtype->GetAttribute("icon") //TODO once everyone is 4.30, deprecate tolliumicon= and move everyone back to simple icon=
          , members :=            DEFAULT RECORD ARRAY
          ];

      this->AddIcon(gtype, typeinfo.tolliumicon);

      INSERT typeinfo INTO types AT END;
  }
    RETURN types;
  }
  PUBLIC STRING ARRAY FUNCTION ParseApplySiteProfiles()
  {
    STRING ARRAY loadprofiles;
    FOREVERY(OBJECT resdep FROM this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile","applysiteprofile")->GetCurrentElements())
    {
      IF(NOT IsNodeApplicableToThisWebHare(resdep))
        CONTINUE;

      STRING toload;
      IF(resdep->HasAttribute("path"))
      {
        toload := this->siteprof->ParseFSPath(resdep, "path");
      }
      ELSE
      {
        toload := this->siteprof->ParseFSTwopartPathString(resdep->GetAttribute("site"), resdep->GetAttribute("fullpath"));
        this->AddWarning(resdep, `<applysiteprofile/> should use path=, not site=/fullpath=`);
      }
      toload := MakeAbsoluteResourcePath("", toload);
      TRY
      {
        GetWebhareResource(toload); //validate its existence
        INSERT toload INTO loadprofiles AT END;
      }
      CATCH(OBJECT e)
      {
        this->AddError(resdep, e->what);
      }
    }
    RETURN loadprofiles;
  }
>;

//it should be save to persist this for the current job, as compilation/validation jobs generally dont run long, but a full siteprof recompiler can otherwise build this object 100s of times (341 for me)
OBJECT parametersingleton;

PUBLIC RECORD FUNCTION ParseSiteProfile(STRING filename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF(filename LIKE "*.yml" OR filename LIKE "*.yaml")
    RETURN [ value := WaitForPromise(ImportJS("./parser.ts")->readAndParseSiteProfile(filename)) //CallJS is not availble during bootup
           , ttl := 60*60*1000
           , eventmasks := GetResourceEventMasks([filename])
           ];

  options := ValidateOptions( [ xmldoc := DEFAULT OBJECT
                              ], options);

  RECORD siteprofdata := [ name := filename
                         , applysiteprofiles := DEFAULT STRING ARRAY
                         , errors := RECORD[]
                         , warnings := RECORD[]
                         , hints := RECORD[]
                         , icons := RECORD[]
                         , contenttypes := DEFAULT RECORD ARRAY
                         , rtdtypes := RECORD[]
                         , grouptypes := DEFAULT RECORD ARRAY
                         , rules := RECORD[]
                         , gid := ""
                         ];

  RECORD ARRAY errors, warnings, hints, icons;
  OBJECT siteprof;
  OBJECT siteprofcontext;
  IF(NOT ObjectExists(parametersingleton))
    parametersingleton := NEW RecompileParameters;

  TRY
  {
    siteprof := NEW SiteProfileObject(filename, [ xmldoc := options.xmldoc ]);
    siteprofcontext := NEW SiteprofileCompilationContext(filename, siteprof, parametersingleton);
    OBJECT realdoc := siteprof->xmldoc;

    IF(Length(realdoc->GetParseErrors()) > 0)
    {
      siteprofdata.errors := SELECT resourcename := filename, line, col := 0, message FROM realdoc->GetParseErrors();
      RETURN [ value := siteprofdata
            , ttl := 60*60*1000
            , eventmasks := GetResourceEventMasks([filename])
            ];
    }

    OBJECT siteprofroot := siteprof->xmldoc->documentelement;

    siteprofcontext->ReadContentTypes();
    siteprofcontext->ParseFolderTypes();
    siteprofcontext->ParseFileTypes();
    siteprofdata.gid := siteprofcontext->toplevelgid;

    siteprofdata.rules := (SELECT *, ruletype := "apply" FROM siteprofcontext->ImportApplies())
                          CONCAT
                          (SELECT *, ruletype := "sitesetting" FROM siteprofcontext->ImportSiteSettings());

    siteprofdata.applysiteprofiles := siteprofcontext->ParseApplySiteProfiles();
    siteprofdata.grouptypes := siteprofcontext->ImportGroupTypes();
  }
  CATCH(OBJECT e)
  {
    INSERT [ resourcename := filename, line := 0, col := 0, message := e->what ] INTO errors AT END;
  }

  IF(ObjectExists(siteprofcontext))
  {
    errors := siteprofcontext->GetErrors() CONCAT errors;
    warnings := siteprofcontext->GetWarnings() CONCAT warnings;
    hints := siteprofcontext->GetHints() CONCAT hints;
    icons := siteprofcontext->GetIcons() CONCAT icons;
    siteprofdata.contenttypes := siteprofcontext->contenttypes;
    siteprofdata.rtdtypes := siteprofcontext->rtdtypes;
  }

  //Translate <foldertype indexfile= to a WHFSType-apply rule
  FOREVERY(RECORD ftype FROM siteprofdata.contenttypes)
    IF(ftype.type="foldertype") {
      IF(ftype.foldertype.indexfile LIKE "contentlisting:*") { //ie: not 'none' or ""
        RECORD set_indexfile := [ //prepare the new indexfile apply rule
              indexfile := "newfile",
              protectindexfile := ftype.foldertype.protectindexfile,
              fullpath := "",
              site := "",
              newfiletype := Substring(ftype.foldertype.indexfile, Length("contentlisting:")),
              newfilename := ""
            ];

        INTEGER matchrule := SELECT AS INTEGER #rules + 1 FROM siteprofdata.rules WHERE ruletype="apply" AND whfstype = ftype.namespace;
        IF(matchrule > 0) { //matching rule
          IF(NOT RecordExists(siteprofdata.rules[matchrule-1].folderindex))
            siteprofdata.rules[matchrule-1].folderindex := set_indexfile;
        } ELSE { //create a rule
          INSERT CELL[
            ...csp_base_applyrule,
            whfstype := ftype.namespace,
            ruletype := "apply",
            folderindex := set_indexfile
          ] INTO siteprofdata.rules AT END;
        }
      }
      DELETE CELL indexfile, protectindexfile FROM ftype.foldertype;
      siteprofdata.contenttypes[ #ftype ] := ftype; //update the record
    }

  siteprofdata.errors := errors;
  siteprofdata.warnings := warnings;
  siteprofdata.hints := hints;
  siteprofdata.icons := icons;

  // Stabilize per-siteprofile result
  siteprofdata.contenttypes := SELECT * FROM siteprofdata.contenttypes ORDER BY namespace;
  siteprofdata.rules := SELECT * FROM siteprofdata.rules
                             ORDER BY CellExists(rules,'whfstype') AND whfstype != "" DESC,
                                      CellExists(rules,'whfstype') ? whfstype : "",
                                      CellExists(rules,'priority') ? priority : 0;

  RETURN [ value := siteprofdata
         , ttl := 60*60*1000
         , eventmasks := GetResourceEventMasks([filename])
         ];
}

PUBLIC RECORD FUNCTION GetParsedSiteProfile(STRING resourcename)
{
  RETURN GetAdhocCached( CELL [resourcename ], PTR ParseSiteProfile(resourcename));
}

OBJECTTYPE RecompileParameters
<
  PUBLIC RECORD ARRAY webdesignplugins;
  PUBLIC RECORD ARRAY customnodes;
  PUBLIC STRING ARRAY basesiteprofiles;
  PUBLIC RECORD ARRAY assetpacks;
  PUBLIC RECORD webdesigns;

  MACRO NEW()
  {
    this->assetpacks := __GetExtractedConfig("assetpacks");
    this->webdesigns := __GetExtractedConfig("webdesigns");

    FOREVERY(RECORD mod FROM GetWebHareModules())
    {
      this->webdesignplugins := this->webdesignplugins CONCAT mod.webdesignplugins;
      this->customnodes := this->customnodes CONCAT mod.customnodes;
    }

    this->basesiteprofiles := GetSortedSet(this->basesiteprofiles CONCAT STRING ARRAY(this->webdesigns.siteprofiles));
  }
>;
