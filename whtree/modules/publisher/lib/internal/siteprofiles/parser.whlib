<?wh
LOADLIB "mod::publisher/lib/search/searchproviders.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/structuredef.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/support.whlib";
LOADLIB "mod::system/lib/internal/resources.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whconfig.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::tollium/lib/internal/gettid.whlib";

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::xml/xsd.whlib";

PUBLIC RECORD FUNCTION ReadSiteFilter(OBJECT matchnode)
{
  BOOLEAN hasname := matchnode->HasAttribute("sitename");
  BOOLEAN hasmask := matchnode->HasAttribute("sitemask");
  BOOLEAN hasregex := matchnode->HasAttribute("siteregex");
  IF(NOT hasname AND NOT hasmask AND NOT hasregex)
    RETURN DEFAULT RECORD;

  RETURN CELL[ matchname := matchnode->GetAttribute("sitename")
             , matchmask := matchnode->GetAttribute("sitemask")
             , matchregex := matchnode->GetAttribute("siteregex")
             , hasname
             , hasmask
             , hasregex
             ];
}

STRING ARRAY FUNCTION GetHasList(OBJECT node, STRING ARRAY searchfor)
{
  STRING ARRAY haslist;
  FOREVERY(STRING attr FROM searchfor)
    IF(node->HasAttribute(attr))
      INSERT ToUppercase(attr) INTO haslist AT END;
  RETURN haslist;
}

BOOLEAN FUNCTION TestWebhareResource(STRING path)
{
  TRY { GetWebhareResource(path); RETURN TRUE; }
  CATCH RETURN FALSE;
}

STATIC OBJECTTYPE SiteprofileCompilationContext
<
  RECORD ARRAY errormessages;
  RECORD ARRAY warnings;
  STRING filename;
  OBJECT siteprof;
  OBJECT parameters;
  STRING toplevelgid;
  STRING module;
  PUBLIC RECORD ARRAY contenttypes;

  PUBLIC PROPERTY siteprofile(siteprof, -);

  MACRO NEW(STRING filename, OBJECT siteprof, OBJECT parameters)
  {
    this->parameters := parameters;
    this->filename := filename;
    this->siteprof := siteprof;
    //__GetModuleBaseFromResourceName fallback is needed to support texts in site-based siteprofiles
    this->module := GetModuleNameFromResourcePath(filename) ?? __GetModuleBaseFromResourceName(this->filename);
    this->toplevelgid := ParseXMLGid(this->module, "", this->siteprof->xmldoc->documentelement, "gid");
  }

  PUBLIC RECORD ARRAY FUNCTION GetErrors()
  {
    RETURN this->errormessages;
  }
  PUBLIC RECORD ARRAY FUNCTION GetWarnings()
  {
    RETURN this->warnings;
  }

  PUBLIC MACRO AddWarning(OBJECT node, STRING warning)
  {
    INSERT [ resourcename := this->filename
           , line  :=        node->linenum
           , col :=          0
           , message :=      warning
           ] INTO this->warnings AT END;
  }
  PUBLIC MACRO AddError(OBJECT node, STRING error)
  {
    INSERT [ resourcename:= this->filename
           , line  :=        node->linenum
           , col :=          0
           , message :=      error
           ] INTO this->errormessages AT END;
  }

  PUBLIC MACRO AddErrorElsewhere(STRING filename, INTEGER line, STRING error)
  {
    INSERT [ resourcename := filename
           , line :=         line
           , col :=          0
           , message :=      error
           ] INTO this->errormessages AT END;
  }

  PUBLIC STRING FUNCTION ParseFSPath(OBJECT node, STRING attrname)
  {
    IF(NOT node->HasAttribute(attrname))
      RETURN "";

    STRING val := node->GetAttribute(attrname);
    IF(val LIKE "site::*")
      RETURN val;

    IF(val LIKE "module::*" OR val LIKE "site::*" OR val LIKE "modulescript::*" OR val LIKE "moduledata::*" OR val LIKE "moduleroot::*" OR val LIKE "mod::*")
      RETURN MakeAbsoluteResourcePath("",val);

    IF(val LIKE "currentsite::*")
    {
      IF(this->filename NOT LIKE "site::*")
      {
        this->AddError(node, "Currentsite paths are not supported by siteprofiles not loaded from a site");
        RETURN "";
      }
      RETURN Tokenize(this->filename,"/")[0] || "/" || Substring(val,13);
    }
    IF(val LIKE "/*")
    {
      IF(this->filename NOT LIKE "site::*")
      {
        this->AddError(node, "currentsite paths are not supported by siteprofiles not loaded from a site");
        RETURN "";
      }
      RETURN Tokenize(this->filename,"/")[0] || val;
    }
    IF(val NOT LIKE "*::*") //its just a relative path
    {
      RETURN MakeAbsoluteResourcePath(this->filename, val);
    }
    this->AddError(node, "Did not recognize siteprofile path format");
    RETURN "";
  }

  STRING FUNCTION ParseTolliumRef(OBJECT node, STRING attr)
  {
    IF(NOT node->HasAttribute(attr))
      RETURN "";
    STRING editfragment := node->GetAttribute(attr);
    IF(editfragment != "" AND editfragment NOT LIKE ".*" AND editfragment NOT LIKE "*#*" AND editfragment NOT LIKE "*:*")
    {
      editfragment := "." || editfragment;

      //we don't warn yet for legacy siteprofiles...
      IF(this->filename NOT LIKE "site::*")
        this->AddError(node, "A reference to a local tollium fragment should be prefixed with '.'");
    }

    STRING fragmentref := MakeAbsoluteScreenReference(this->filename, editfragment);
    IF(fragmentref="")
    {
      this->AddError(node, "Failed to resolve the fragment reference to '" || node->GetAttribute("editfragment") || "' in '" || this->filename || "'");
      RETURN "";
    }
    RETURN fragmentref;
  }

  PUBLIC RECORD FUNCTION GetWidgetEditor(OBJECT node)
  {
    BOOLEAN has_extension := node->HasAttribute("editextension");
    BOOLEAN has_fragment := node->HasAttribute("editfragment");
    BOOLEAN has_screen := node->HasAttribute("editscreen");
    BOOLEAN has_function := node->HasAttribute("editfunctionname");

    IF((has_extension ? 1 : 0) + (has_fragment ? 1 : 0) + (has_function ? 1 : 0) + (has_screen ? 1 : 0) > 1)
    {
      this->AddError(node, "Only one of the editextension, editfragment, editscreen or editfunctionname attributes can be specified");
      RETURN DEFAULT RECORD;
    }
    IF (has_extension)
    {
      STRING extensionref := this->ParseTolliumRef(node,"editextension");
      RETURN extensionref != "" ? [ type := "extension", extension := extensionref ] : DEFAULT RECORD;
    }
    IF(has_screen)
    {
      this->AddWarning(node, "editscreen= has been deprecated. Switch to editextension= (or editfunctionname=)");
      STRING screenref := this->ParseTolliumRef(node,"editscreen");
      RETURN screenref != "" ? [ type := "screen", screen := screenref ] : DEFAULT RECORD;
    }
    IF(has_fragment)
    {
      this->AddWarning(node, "editfragment= has been deprecated. Switch to editextension=");
      STRING fragmentref := this->ParseTolliumRef(node,"editfragment");
      RETURN fragmentref != "" ? [ type := "fragment", fragment := fragmentref ] : DEFAULT RECORD;
    }
    IF(has_function)
    {
      STRING funcname := this->ParseFunctionRef(node, "editlibrary", "editfunctionname");
      RETURN [ type := "function", functionname := funcname ];
    }
    RETURN DEFAULT RECORD;
  }

  STRING FUNCTION ParseFunctionRef(OBJECT node, STRING legacylibattr, STRING nameattr)
  {
    IF(node->HasAttribute(nameattr))
    {
      STRING objectname := node->GetAttribute(nameattr);
      IF(objectname LIKE "*#*")
      {
        objectname := MakeAbsoluteResourcePath(this->filename, objectname);
      }
      ELSE
      {
        IF(NOT node->HasAttribute(legacylibattr))
        {
          this->AddError(node, `No library specified which would contain '${objectname}'`);
          RETURN "";
        }
        objectname := this->ParseFSPath(node, legacylibattr) || "#" || objectname;
      }
      RETURN objectname;
    }
    RETURN "";
  }

  PUBLIC RECORD FUNCTION GetWidgetRenderer(OBJECT node)
  {
    STRING objectname := this->ParseFunctionRef(node, "renderlibrary", "renderobjectname");
    RETURN objectname != "" ? [ objectname := objectname ] : DEFAULT RECORD;
  }

  PUBLIC MACRO ParseFolderTypes()
  {
    this->ParseFileFolderTypes("foldertype", PTR this->ReadFolderType);
  }
  PUBLIC MACRO ParseFileTypes()
  {
    this->ParseFileFolderTypes("filetype", PTR this->ReadFileType);
  }

  PUBLIC MACRO ParseFileFolderTypes(STRING whichtype, FUNCTION PTR parser)
  {
    FOREVERY(OBJECT ftype FROM this->siteprof->xmldoc->documentelement->ListChildren(namespace_sp, whichtype))
    {
      TRY
      {
        STRING ns := ftype->GetAttribute("typedef");
        RECORD insertpos := RecordLowerBound(this->contenttypes, [namespace:=ns], ["NAMESPACE"]);
        OBJECT membersnode := PickFirst(ftype->ListChildren(namespace_sp, "members"));
        RECORD ctype;

        IF(NOT insertpos.found) //synthesize contenttype
        {
          ctype := MakeBasicTypeInfo("contenttype");
          ctype.namespace := ns;

          IF(ObjectExists(membersnode))
            INSERT CELL members := this->ReadCTMembers(membersnode, ns).members INTO ctype;
          ELSE
            INSERT CELL members := RECORD[] INTO ctype;

          INSERT ctype INTO this->contenttypes AT insertpos.position;
        }
        ELSE
        {
          ctype := this->contenttypes[insertpos.position];
          IF(RecordExists(ctype.foldertype) OR RecordExists(ctype.filetype))
            this->AddError(ftype, `Content type ${ns} is already setup as a file or folder type`);
          IF(ObjectExists(membersnode))
            this->AddError(ftype, `A type cannot define <members> if they were already defined by a previous <contenttype>`);
        }
        ctype := parser(ctype, ftype);
        this->contenttypes[insertpos.position] := ctype;
      }
      CATCH(OBJECT e)
      {
        this->AddError(ftype, e->what);
      }
    }
  }

  RECORD FUNCTION ReadFileType(RECORD ctype, OBJECT ftype)
  {
    ctype.filetype := GetBaseFiletypeRecord();
    IF(ftype->HasAttribute("icon"))
      this->AddWarning(ftype, "The option 'icon' is obsolete and should be removed");
    IF(ftype->HasAttribute("viewable"))
      this->AddWarning(ftype, "The attribute 'isviewable' is obsolete and should be removed");
    if(NOT ftype->HasAttribute("blobiscontent") AND NOT ftype->HasAttribute("kind"))
      this->AddError(ftype, "At least one of 'blobiscontent' and 'kind' attributes must be set");

    SWITCH(ftype->GetAttribute("kind"))
    {
      CASE "rawfile"
      {
        ctype.filetype.blobiscontent := TRUE;
        ctype.filetype.requirescontent := TRUE;
        ctype.fstype.ispublishable := TRUE;
      }
      CASE "virtualfile"
      {
        ctype.fstype.needstemplate := TRUE;
        ctype.fstype.ispublishable := TRUE;
        ctype.fstype.ispublishedassubdir := TRUE;
      }
    }

    ctype.filetype.tolliumicon := ftype->GetAttribute("tolliumicon");
    ctype.filetype.title := ParseXMLTIDPtr(this->module, this->toplevelgid, ftype, "title") ?? ":" || ctype.namespace;
    IF(ftype->HasAttribute("blobiscontent"))
     ctype.filetype.blobiscontent := ParseXSBoolean(ftype->GetAttribute("blobiscontent"));
    ctype.filetype.pagelistprovider := this->ParseFSPath(ftype, "pagelistprovider");
    IF(ftype->HasAttribute("needstemplate"))
      ctype.fstype.needstemplate := ParseXSBoolean(ftype->GetAttribute("needstemplate"));
    ctype.fstype.needsprofile := ParseXSBoolean(ftype->GetAttribute("needsprofile"));
    ctype.filetype.requirescontent := ParseXSBoolean(ftype->GetAttribute("requirescontent"));
    ctype.filetype.isdevelopertype := ParseXSBoolean(ftype->GetAttribute("isdevelopertype"));
    ctype.filetype.siteprofile := this->filename;
    ctype.filetype.line := ftype->linenum;
    ctype.fstype.isacceptableindex := ParseXSBoolean(ftype->GetAttribute("isacceptableindex"));
    IF(ftype->HasAttribute("ispublishedassubdir"))
      ctype.fstype.ispublishedassubdir := ParseXSBoolean(ftype->GetAttribute("ispublishedassubdir"));
    IF(ftype->HasAttribute("ispublishable"))
      ctype.fstype.ispublishable := ParseXSBoolean(ftype->GetAttribute("ispublishable"));
    ctype.fstype.previewlibrary := ftype->GetAttribute("previewlibrary");
    ctype.fstype.previewobjectname := ftype->GetAttribute("previewobjectname");
    ctype.fstype.searchprovider := this->ParseSearchProvider(ftype);
    ctype.filetype.searchcontentprovider := QualifyName(this->module, ftype->GetAttribute("searchcontentprovider"));
    ctype.filetype.indexversion := QualifyName(this->module, ftype->GetAttribute("indexversion"));
    ctype.fstype.capturesubpaths := ParseXSBoolean(ftype->GetAttribute("capturesubpaths"));
    ctype.fstype.isfiletype := TRUE;

    OBJECT dyninfo := ftype->GetChildElementsByTagNameNS(namespace_sp, "dynamicexecution")->Item(0);

    IF(ObjectExists(dyninfo))
      ctype.filetype.dynamicexecution := this->ParseDynamicExecuteData(dyninfo);

    IF (RecordExists(ctype.filetype.dynamicexecution))
    {
      ctype.fstype.ispublishedassubdir := TRUE;
      ctype.fstype.ispublishable := TRUE;
      ctype.fstype.isdynamicexecution := TRUE;
    }

    IF (ctype.fstype.capturesubpaths AND NOT ctype.fstype.ispublishedassubdir)
    {
      ctype.fstype.capturesubpaths := FALSE;
      this->AddError(ftype, "The option 'capturesubpaths' can only be enabled when 'ispublishedassubdir' is also enabled.");
    }

/*    IF (ftype->HasAttribute("webhare_builtintypeid"))
      typeinfo.ftypeid := ParseXSInt(ftype->GetAttribute("webhare_builtintypeid"));
*/
    IF(ftype->HasAttribute("extensions"))
    {
      ctype.filetype.extensions := Tokenize(TrimWhitespace(ftype->GetAttribute("extensions")), " ");
      IF (Length(ctype.filetype.extensions) > 0 AND ctype.filetype.extensions[0] = "")
        ctype.filetype.extensions := DEFAULT STRING ARRAY;
    }
    RETURN ctype;
  }

  RECORD FUNCTION ReadFolderType(RECORD ctype, OBJECT ftype)
  {
    STRING tolliumicon := ftype->GetAttribute("tolliumicon");
    IF(tolliumicon NOT LIKE '*:*')
      tolliumicon := "tollium:folders/normal";

    //Now construct the final folder type information record
    ctype.foldertype := [ tolliumicon := tolliumicon
                        , title := ParseXMLTIDPtr(this->module, this->toplevelgid, ftype, "title") ?? ":" || ctype.namespace
                        , isdevelopertype := ftype->GetAttribute("isdevelopertype") IN [ "true", "1" ]
                        , indexfile := ""
                        , protectindexfile := ftype->GetAttribute("protectindexfile") IN [ "true", "1" ]
                        , requirescontent := FALSE
                        , ishidden := ftype->GetAttribute("ishidden") IN [ "true", "1" ]
                        , dynamicexecution := DEFAULT RECORD

                        , siteprofile := this->filename
                        , line := ftype->linenum
                        ];


    IF (ftype->HasAttribute('indextype'))
    {
      ctype.foldertype.indexfile := 'contentlisting:' || ftype->GetAttribute("indextype"); //NOTE: not really a contentlisting, but a workaround to share the codepath...
    }
    ELSE IF (ftype->HasAttribute('indexfile'))
    {
      IF (ftype->GetAttribute("indexfile") = "none")
        ctype.foldertype.indexfile := "none";
      IF (ftype->GetAttribute("indexfile") = "contentlisting")
        ctype.foldertype.indexfile := "contentlisting:http://www.webhare.net/xmlns/publisher/contentlisting";
    }

    OBJECT dyninfo := PickFirst(ftype->ListChildren(namespace_sp, "dynamicexecution"));
    IF(ObjectExists(dyninfo))
      ctype.foldertype.dynamicexecution := this->ParseDynamicExecuteData(dyninfo);

    IF (RecordExists(ctype.foldertype.dynamicexecution)
        AND
        (ctype.foldertype.dynamicexecution.webpageobjectname != "" OR ctype.foldertype.dynamicexecution.startmacro != "" OR ctype.foldertype.dynamicexecution.routerfunction != ""))
    {
      ctype.foldertype.indexfile := "contentlisting:http://www.webhare.net/xmlns/publisher/dynamicfoldercontents";
      ctype.foldertype.protectindexfile := TRUE;
      ctype.fstype.isdynamicexecution := TRUE;
    }
    ctype.fstype.isfoldertype := TRUE;
    RETURN ctype;
  }
  PUBLIC STRING FUNCTION ExpandWittyComponent(OBJECT node, STRING attrname)
  {
    IF(NOT node->HasAttribute(attrname))
      RETURN "";
    RETURN MakeAbsoluteResourcePath(this->filename, node->GetAttribute(attrname));
  }

  PUBLIC MACRO  ReadContentTypes()
  {
    // All xml elements that contain contenttype definitions
    RECORD ARRAY contenttypeelements :=
        [ [ ns := namespace_sp,   name := "contenttype" ]
        , [ ns := namespace_sp,   name := "embeddedobjecttype" ]
        , [ ns := namespace_sp,   name := "widgettype" ]
        , [ ns := newsletter_sp,  name := "maildesigntype" ]
        , [ ns := namespace_sp,   name := "rtdtype" ]
        ];

    OBJECT ARRAY contenttypes;
    FOREVERY (RECORD rec FROM contenttypeelements)
      contenttypes := contenttypes CONCAT this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS(rec.ns, rec.name)->GetCurrentElements();

    FOREVERY(OBJECT ctype FROM contenttypes)
    {
      TRY
      {
        RECORD typeinfo := this->ReadContentType(ctype);
        RECORD insertpos := RecordLowerBound(this->contenttypes, typeinfo, ["NAMESPACE"]);
        IF(insertpos.found)
          THROW NEW Exception(`Duplicate contenttype definition for ${typeinfo.namespace}`);

        INSERT typeinfo INTO this->contenttypes AT insertpos.position;
      }
      CATCH(OBJECT e)
      {
        this->AddError(ctype, e->what);
      }
    }
  }

  RECORD FUNCTION ReadCTMembers(OBJECT memberparent, STRING namespace)
  {
    RECORD ARRAY members;
    RECORD ARRAY groupmemberships;
    STRING ARRAY seennames;
    FOR(OBJECT node := memberparent->firstelementchild;ObjectExists(node);node:=node->nextelementsibling)
    {
      IF (node->localname = "member" OR node->localname IN whconstant_whfstype_membertypes)
      {
        RECORD memberinfo := [ name := ToLowercase(node->GetAttribute('name'))
                             , type := GetFSMemberTypeID(node->localname = "member" ? node->GetAttribute('type') : node->localname)
                             , publish := node->GetAttribute("publish") IN ["1","true"]
                             , children := DEFAULT RECORD ARRAY
                             ];

        IF(memberinfo.name="")
          this->AddError(node, `Invalid member name '${memberinfo.name}'`);
        ELSE IF(memberinfo.name IN seennames)
          this->AddError(node, `Duplicate member '${memberinfo.name}'`);

        INSERT memberinfo.name INTO seennames AT END;

        IF(node->HasAttribute("publish") AND NOT memberinfo.publish)
          this->AddError(node, `Member name '${memberinfo.name}' is using publish=false - should be removed`);
        ELSE IF(memberinfo.publish)
        {
          IF(memberinfo.type IN [ 5,15 ])
            this->AddWarning(node,`Member name '${memberinfo.name}' of type '${node->GetAttribute('type')}' is using publish=true, this will be removed in a future version`);
          ELSE
            this->AddError(node,`Member name '${memberinfo.name}' of type '${node->GetAttribute('type')}' is using publish=true, this was never supported for this type`);
        }

        IF(ToUppercase(memberinfo.name) LIKE "WHFS*")
        {
          //Some names are grandfathered in, hopefully they can go away at some point
          IF(namespace||"#"||memberinfo.name NOT IN
             ["http://www.pthu.nl/v2/mainmenu#whfsitem"
             ])
          {
            this->AddWarning(node, `Member names starting with 'WHFS' are reserved and should not be used`);
          }
        }
        IF(memberinfo.type<1)
        {
          this->AddError(node, `Invalid member type '${node->GetAttribute('type')}'`);
          CONTINUE;
        }

        IF(memberinfo.type=12)
        {
          RECORD ctmembers := this->ReadCTMembers(node, namespace);
          memberinfo.children := ctmembers.members;
        }
        INSERT memberinfo INTO members AT END;
      }
      ELSE IF (node->localname = "ingroup")
      {
        INSERT
            [ grouptype :=    node->GetAttribute("type")
            , line :=         node->linenum
            , col :=          0
            ] INTO groupmemberships AT END;
      }
    }
    RETURN
        [ members :=            members
        , groupmemberships :=   groupmemberships
        ];
  }

  RECORD FUNCTION ReadContentType(OBJECT ctype)
  {
    // Type of the contenttype is the localname (ignore the namespace)
    STRING nodename := ctype->localname ?? ctype->nodename;
    // Namespace filled in?
    STRING ns := ctype->GetAttribute("namespace");
    IF (ns = "")
      THROW NEW Exception("No namespace specified for " || nodename);

    BOOLEAN set_cloneoncopy := nodename != "contenttype" OR (ctype->HasAttribute("cloneoncopy") = FALSE OR ParseXSBoolean(ctype->GetAttribute("cloneoncopy")));
    INTEGER typedefid;

    OBJECT membersnode := ctype->GetChildElementsByTagNameNS(namespace_sp, "members")->Item(0);
    RECORD newmembers := this->ReadCTMembers(membersnode ?? ctype, ns);

    RECORD typeinfo := nodename="rtdtype" ? ParseSiteprofXMLStructure(this, ctype) : MakeBasicTypeInfo(nodename);
    typeinfo.id := typedefid;
    typeinfo.namespace := ns;
    typeinfo.siteprofile := this->filename;
    typeinfo.line := ctype->linenum;
    typeinfo.col := 0;
    typeinfo.title := ParseXMLTIDPtr(this->module, this->toplevelgid, ctype, "title") ?? ":" || ns;
    typeinfo.tolliumicon := ctype->GetAttribute("tolliumicon");
    typeinfo.groupmemberships := newmembers.groupmemberships;
    typeinfo.fstype := [...GetFSTypeBase(), cloneoncopy := set_cloneoncopy ];
    INSERT CELL members := newmembers.members INTO typeinfo;

    IF(nodename = 'maildesigntype')
      this->AddWarning(ctype, "newsletter maildesigntype in siteprofiles are deprecated");

    IF (nodename IN [ "embeddedobjecttype", "maildesigntype", "widgettype" ])
    {
      INSERT CELL editor := this->GetWidgetEditor(ctype)
                , renderer := this->GetWidgetRenderer(ctype)
                , embedtype := ctype->GetAttribute("embedtype") ?? "block"
                , requiremergefieldscontext := ParseXSBoolean(ctype->GetAttribute("requiremergefieldscontext"))
             INTO typeinfo;

      IF(ParseXSBoolean(ctype->GetAttribute("isfiletype")) OR nodename="widgettype")
      {
        RECORD filetypeinfo := GetBaseFiletypeRecord();
        filetypeinfo.siteprofile := this->filename;
        filetypeinfo.line := ctype->linenum;

        filetypeinfo.isembeddedobjecttype := typeinfo.isembeddedobjecttype;
        filetypeinfo.tolliumicon := typeinfo.tolliumicon;
        IF(filetypeinfo.tolliumicon = "" AND filetypeinfo.isembeddedobjecttype)
          filetypeinfo.tolliumicon := "tollium:files/widget";

        filetypeinfo.title := typeinfo.title;
        typeinfo.fstype.needstemplate := nodename!="widgettype";
        typeinfo.fstype.isfiletype := TRUE;
        typeinfo.fstype.ispublishedassubdir := nodename!="widgettype";
        typeinfo.fstype.ispublishable := nodename!="widgettype" AND ParseXSBoolean(ctype->GetAttribute("ispublishable"));
        typeinfo.fstype.generatepreview := nodename="widgettype" OR ParseXSBoolean(ctype->GetAttribute("generatepreview"));

        typeinfo.wittycomponent := this->ExpandWittyComponent(ctype, "wittycomponent");
        typeinfo.previewcomponent := this->ExpandWittyComponent(ctype, "previewcomponent");
        typeinfo.filetype := filetypeinfo;
      }

      IF(nodename="widgettype" AND ctype->HasAttribute("ingroup"))
        typeinfo.groupmemberships := [[ line := 0, col := 0, grouptype := ctype->GetAttribute("ingroup") ]];
      IF( (nodename="widgettype" OR nodename="embeddedobjecttype") AND Length(typeinfo.groupmemberships)=0)
        typeinfo.groupmemberships := [[ line := 0, col := 0, grouptype := "http://www.webhare.net/xmlns/publisher/generalwidgets" ]];
    }

    RETURN typeinfo;
  }

  RECORD FUNCTION ParseWebDesign(OBJECT node)
  {
    RECORD webdesign := [ objectname               := this->ParseFunctionRef(node, "library", "objectname")
                        , witty                    := this->ParseFSPath(node, "witty")
                        , assetpack                := ""
                        , basedependency           := node->GetAttribute("basedependency")
                        , wittyencoding            := node->GetAttribute("wittyencoding")
                        , designfolder             := this->ParseFSPath(node, "designfolder")
                        , maxcontentwidth          := node->GetAttribute("maxcontentwidth")
                        , siteprofile              := this->siteprof->name
                        , supportserrors           := ParseXSBoolean(node->GetAttribute("supportserrors"))
                        , supportsaccessdenied     := ParseXSBoolean(node->GetAttribute("supportsaccessdenied"))
                        , asyncbundle              := ParseXSBoolean(node->GetAttribute("async"))
                        , lazyloadcss              := ParseXSBoolean(node->GetAttribute("lazyloadcss"))
                        , supportedlanguages       := ParseXSList(node->GetAttribute("supportedlanguages"))
                        , contentnavstops          := ParseXSList(node->GetAttribute("contentnavstops"))

                        , has_assetpack            := node->HasAttribute("assetpack")
                        , has_basedependency       := node->HasAttribute("basedependency")
                        , has_supportserrors       := node->HasAttribute("supportserrors")
                        , has_supportsaccessdenied := node->HasAttribute("supportsaccessdenied")
                        , has_asyncbundle          := node->HasAttribute("async")
                        , has_contentnavstops      := node->HasAttribute("contentnavstops")
                        , has_lazyloadcss          := node->HasAttribute("lazyloadcss")
                        ];

    webdesign.assetpack := QualifyName(this->module,node->GetAttribute("assetpack"));
    IF(webdesign.assetpack != "" AND webdesign.assetpack != "publisher:__dummy__") //TODO do we need an official way to invoke <webdesign> without __dummy__ ? may be easier to offer once everyone uses webdesigns instead of templates and we don't need to validate against V1 sites
    {
      IF(this->filename NOT LIKE "mod::*")
        this->AddError(node, "Assetpacks can only be specified for module-based siteprofiles");

      RECORD modinfo := GetWebhareModuleInfo(Tokenize(webdesign.assetpack,':')[0]);
      RECORD assetpackinfo;

      IF(RecordExists(modinfo))
        assetpackinfo := SELECT * FROM modinfo.assetpacks WHERE ToUppercase(name) = ToUppercase(webdesign.assetpack);

      IF(RecordExists(assetpackinfo))
      {
        //Cache important settings which would be too slow to look up separately from <webdeisgn>
        webdesign.supportedlanguages := assetpackinfo.supportedlanguages;
      }
      ELSE
      {
        this->AddError(node, `No such assetpack '${webdesign.assetpack}'`);
      }
    }

    IF(webdesign.designfolder != "" AND webdesign.designfolder NOT LIKE "*/")
      webdesign.designfolder := webdesign.designfolder || "/";

    IF(node->HasAttribute("basedependency")
       AND this->filename NOT LIKE "site::*"
       AND this->filename NOT LIKE "mod::webhare_testsuite/*")  //is testing old APIs
    {
      this->AddError(node, "For WebHare 4.06 and up, you should move away from basedependency=, use assetpack= and add an <assetpack> to your moduledefinition");
    }

    IF(node->GetAttribute("basedependency") != "" AND webdesign.designfolder LIKE "mod::*")
    {
      STRING basedep := this->ParseFSPath(node, "basedependency");
      IF(TestWebhareResource(basedep) OR TestWebhareResource(basedep || ".js") OR TestWebhareResource(basedep || ".es"))
      {
        webdesign.basedependency := basedep;
      }
      ELSE
      {
        //Try to resolve the base dependency versus the designfolder
        STRING relativetodesign := MakeAbsoluteResourcePath(webdesign.designfolder, webdesign.basedependency);
        this->AddError(node, "Unable to find the base dependency '" || webdesign.basedependency || "', tried '" || basedep || "' and '" || relativetodesign || "'");
      }
    }

    RETURN webdesign;
  }

  RECORD FUNCTION ParseDynamicExecuteData(OBJECT node)
  {
    STRING startmacro := this->ParseFunctionRef(node, "library", "startmacro");
    STRING webpageobjectname := this->ParseFunctionRef(node, "library", "webpageobjectname");
    STRING routerfunction := this->ParseFunctionRef(node, "library", "routerfunction");

    IF (startmacro = "" AND webpageobjectname = "" AND routerfunction="") //specifying both is acceptable, startmacro will take precedence but webpageobjectname will be used for RPCs
    {
      this->AddError(node, "Either 'startmacro', 'webpageobjectname' or 'routerfunction' must be specified");
      RETURN DEFAULT RECORD;
    }

    RETURN
        CELL[ startmacro
            , webpageobjectname
            , routerfunction

            , cachettl                := ParseXSInt(node->GetAttribute("cachettl"))
            , cachewebvariables       := ParseXSList(ToUppercase(node->GetAttribute("cachewebvariables")))
            , cacheblacklistvariables := ParseXSList(ToUppercase(node->GetAttribute("cacheblacklistvariables")))
            , cachewebcookies         := ParseXSList(ToUppercase(node->GetAttribute("cachewebcookies")))
            , cacheblacklistcookies   := ParseXSList(ToUppercase(node->GetAttribute("cacheblacklistcookies")))
            ];
  }

  STRING FUNCTION ParseSearchProvider(OBJECT node)
  {
    STRING provider := this->ParseFSPath(node, "searchprovider");
    IF (provider = "")
      RETURN "";

    STRING ARRAY parts := Tokenize(provider, "#");
    IF (Length(parts) != 2)
    {
      this->AddError(node, "Invalid search provider, expected '<library>#<object>'");
      RETURN "";
    }
    TRY
    {
      OBJECT providerobj := MakeObject(parts[0], parts[1]);
      IF (providerobj NOT EXTENDSFROM SearchProviderBase)
      {
        this->AddError(node, `Search provider '${provider}' does not derive from SearchProviderBase`);
        RETURN "";
      }
    }
    CATCH
    {
      this->AddError(node, `Could not find search provider '${provider}'`);
      RETURN "";
    }
    RETURN provider;
  }

  PUBLIC RECORD ARRAY FUNCTION ParseApplyTosRecurse(OBJECT basenode)
  {
    RECORD ARRAY applytos;

    //ADDME: Instead of continueing, report the error during compilation
    FOREVERY(OBJECT crit FROM basenode->childnodes->GetCurrentElements())
      IF(crit->namespaceuri = namespace_sp)
      {
        RECORD applyto;
        SWITCH(crit->localname)
        {
          CASE "and", "or", "not", "xor"
          {
            applyto := [ type := crit->localname
                       , criteria := this->ParseApplyTosRecurse(crit)
                       ];
          }
          CASE "to"
          {
            STRING type := crit->GetAttribute("type");

            applyto := [ type         := "to"
                       , match_all    := type="all"
                       , match_file   := type="file" OR type="index"
                       , match_index  := type="index"
                       , match_folder := type="folder"
                       , pathmask     := crit->GetAttribute("pathmask")
                       , pathregex    := crit->GetAttribute("pathregex")
                       , parentmask   := crit->GetAttribute("parentmask")
                       , parentregex  := crit->GetAttribute("parentregex")
                       , sitemask     := crit->GetAttribute("sitemask")
                       , sitename     := crit->GetAttribute("sitename")
                       , siteregex    := crit->GetAttribute("siteregex")
                       , parenttype   := crit->GetAttribute("parenttype")
                       , sitetype     := crit->GetAttribute("sitetype")
                       , filetype     := crit->GetAttribute("filetype")
                       , contentfiletype := crit->GetAttribute("contentfiletype")
                       , foldertype   := crit->GetAttribute("foldertype")
                       , typeneedstemplate := ParseXSBoolean(crit->GetAttribute("typeneedstemplate"))
                       , prebuiltmasks := ParseXSList(ToUppercase(crit->GetAttribute("prebuiltmasks")))
                       , webfeatures  := ParseXSList(ToUppercase(crit->GetAttribute("webfeatures" )))
                       ];

            IF( (applyto.filetype!="" OR applyto.contentfiletype != "") AND NOT applyto.match_file)
            {
              this->AddError(crit, "Apply <to> rule is trying to match a file type, but is not set to apply to files");
              CONTINUE;
            }
            IF(applyto.foldertype!="" AND NOT applyto.match_folder)
            {
              this->AddError(crit, "Apply <to> rule is trying to match a folder type, but is not set to apply to folders");
              CONTINUE;
            }
          }
          CASE "testdata"
          {
            applyto := [ type        := "testdata"
                       , target      := crit->GetAttribute("target")
                       , typedef     := crit->GetAttribute("typedef")
                       , membername  := crit->GetAttribute("member")
                       , value       := crit->GetAttribute("value")
                       ];
          }
          DEFAULT
          {
            CONTINUE;//ADDME: Log error?
          }
        }
      INSERT applyto INTO applytos AT END;
    }
    RETURN applytos;
  }

  RECORD ARRAY FUNCTION ParseSources(OBJECT node)
  {
    RECORD ARRAY paths := SELECT path := sourcenode->GetAttribute("path")
                               , relativeto := sourcenode->GetAttribute("relativeto") ?? "siteprofile"
                            FROM ToRecordArray(node->childnodes->GetCurrentElements(), "sourcenode");
    UPDATE paths SET relativeto := "siteprofile" WHERE path LIKE "*::*";
    UPDATE paths SET path := MakeAbsoluteResourcePath(this->filename, path) WHERE relativeto="siteprofile";
    RETURN paths;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportApplies()
  {
    OBJECT ARRAY applies := this->siteprof->xmldoc->documentelement->ListElements(namespace_sp, "*");
    RECORD ARRAY applyrules;
    RECORD counters := [ apply := 0, filetype := 0, foldertype := 0 ];
    FOREVERY(OBJECT applyblock FROM applies)
    {
      STRING applynodetype := applyblock->localname;

      IF(NOT CellExists(counters, applynodetype))
        CONTINUE; //don't care for this node


      INTEGER applyindex := GetCell(counters, applynodetype);
      counters := CellUpdate(counters, applynodetype, applyindex + 1);

      IF(NOT IsNodeApplicableToThisWebHare(applyblock))
        CONTINUE;

      RECORD apply := this->ImportApplyItems(applyblock);
      IF(NOT RecordExists(apply))
        CONTINUE; //no content

      apply := CELL[ ...apply
                   , tos := RECORD[]
                   , priority := ParseXSInt(applyblock->GetAttribute("priority"))
                   , applyindex
                   , applynodetype
                   ];

      IF(applynodetype = "apply")
      {
        apply.tos := this->ParseApplyTosRecurse(applyblock);
      }
      ELSE
      {
        apply.tos := [[ type         := "to"
                      , match_all    := FALSE
                      , match_file   := applynodetype = "filetype"
                      , match_index  := FALSE
                      , match_folder := applynodetype = "folderype"
                      , pathmask     := ""
                      , pathregex    := ""
                      , parentmask   := ""
                      , parentregex  := ""
                      , sitemask     := ""
                      , sitename     := ""
                      , siteregex    := ""
                      , parenttype   := ""
                      , sitetype     := ""
                      , filetype     := applynodetype = "filetype" ? applyblock->GetAttribute("typedef") : ""
                      , contentfiletype := ""
                      , foldertype   := applynodetype = "foldertype" ? applyblock->GetAttribute("typedef") : ""
                      , typeneedstemplate := FALSE
                      , prebuiltmasks := STRING[]
                      , webfeatures  := STRING[]
                      ]
                     ];
      }
      INSERT apply INTO applyrules AT END;
    }
    RETURN applyrules;
  }

  RECORD FUNCTION ImportApplyItems(OBJECT applyblock)
  {
    BOOLEAN errorsarenowfatal;
    BOOLEAN anynode;
    RECORD apply := [ siteprofile := this->siteprof->name
                    , line := applyblock->linenum
                    , col := 0

                    , allowprofiles := DEFAULT RECORD ARRAY
                    , allowtemplates := DEFAULT RECORD ARRAY
                    , baseproperties := DEFAULT RECORD
                    , bodyrenderer := DEFAULT RECORD
                    , contentlisting := DEFAULT RECORD
                    , customnodes := DEFAULT RECORD ARRAY
                    , defaultsettings := DEFAULT RECORD ARRAY
                    , disablelegacysitesettings := FALSE
                    , disabletemplateprofile := FALSE
                    , extendproperties := DEFAULT RECORD ARRAY
                    , folderindex := DEFAULT RECORD
                    , setlibrary := DEFAULT RECORD ARRAY
                    , modifyfiletypes := DEFAULT RECORD ARRAY
                    , modifyfoldertypes := DEFAULT RECORD ARRAY
                    , plugins := DEFAULT RECORD ARRAY
                    , republishes := DEFAULT RECORD ARRAY
                    , scheduletasknows := DEFAULT RECORD ARRAY
                    , setobjecteditor := DEFAULT RECORD
                    , setwidget := DEFAULT RECORD ARRAY
                    , sitelanguage := DEFAULT RECORD
                    , tagsources := DEFAULT RECORD ARRAY
                    , typemappings := DEFAULT RECORD ARRAY
                    , uploadtypemapping := DEFAULT RECORD ARRAY
                    , urlevents := DEFAULT RECORD
                    , urlhistory := DEFAULT RECORD
                    , usepublishtemplate := DEFAULT RECORD
                    , webdesign := DEFAULT RECORD
                    , formdefinitions := DEFAULT RECORD ARRAY
                    , prebuiltpages := DEFAULT RECORD ARRAY
                    , mailtemplates := RECORD[]
                    , foldersettings := DEFAULT RECORD
                    , webtoolsformrules := DEFAULT RECORD ARRAY
                    , rtddoc := DEFAULT RECORD
                    ];


    STRING ARRAY seenuniques;

    FOREVERY(OBJECT node FROM applyblock->childnodes->GetCurrentElements())
    {
      //Skip non-aplpyitems (<to> rules and filetype/foldertype nodes)
      IF(node->localname IN ["to","not","and","or","xor","testtype","testdata","dynamicexecution","members"])
        CONTINUE;

      anynode := TRUE;

      IF(node->localname IN ["bodyrenderer","sitelanguage","folderindex", "contentlisting", "rtddoc"
                            ,"setobjecteditor"])
      {
        IF(node->localname IN seenuniques)
        {
          this->AddError(node, "Duplicate <" || node->localname || "> in a single apply block");
          CONTINUE;
        }
        INSERT node->localname INTO seenuniques AT END;
      }

      TRY
      {
        IF(node->namespaceuri = namespace_sp)
        {
          SWITCH(node->localname)
          {
            CASE "extendproperties", "undoextendproperties"
            {
              STRING extension := this->ParseTolliumRef(node,"extension");
              STRING contenttype := node->GetAttribute("contenttype");
              IF(contenttype = "" AND extension != "")
                this->AddError(node, "An extendproperties with extension= requires a content type");
              IF(node->HasAttribute("name") AND applyblock->localname != "apply") //we really need to deprecate these...
                this->AddError(node, "Only <extendproperties contenttype=> can be used in a <filetype> or <foldertype>");

              RECORD applynode := [ isundo := node->localname = "undoextendproperties"
                                  , contenttype := contenttype
                                  , requireright := node->GetAttribute("requireright")
                                  , requirewebdesign := ParseXSBoolean(node->GetAttribute("requirewebdesign"))
                                  , name := node->GetAttribute("name")
                                  , extension := extension
                                  , mask := node->GetAttribute("mask")
                                  ];
              INSERT applynode INTO apply.extendproperties AT END;
              CONTINUE;
            }
            CASE "allowtemplate"
            {
              INSERT [ fullpath := node->GetAttribute("fullpath")
                     , site := node->GetAttribute("site")
                     ] INTO apply.allowtemplates AT END;
              CONTINUE;
            }
            CASE "allowprofile"
            {
              INSERT [ fullpath := node->GetAttribute("fullpath")
                     , site := node->GetAttribute("site")
                     ] INTO apply.allowprofiles AT END;
              CONTINUE;
            }
            CASE "formdefinitions"
            {
              INSERT [ path := MakeLegacyAbsoluteResourcePath(this->filename, node->GetAttribute("path"), "data")
                     , name := node->GetAttribute("name")
                     ] INTO apply.formdefinitions AT END;
              CONTINUE;
            }
            CASE "webdesign"
            {
              apply.webdesign :=  this->ParseWebDesign(node);
              CONTINUE;
            }
            CASE "baseproperties"
            {
              apply.baseproperties := [ haslist := GetHasList(node, ["title","description","keywords"])
                                      , title := ParseXSBoolean(node->GetAttribute("title"))
                                      , description := ParseXSBoolean(node->GetAttribute("description"))
                                      , keywords := ParseXSBoolean(node->GetAttribute("keywords"))
                                      ];
              CONTINUE;
            }
            CASE "urlhistory"
            {
              apply.urlhistory := [ haslist := GetHasList(node, ["redirecton404","store","passthrough"])
                                  , redirecton404 := ParseXSBoolean(node->GetAttribute("redirecton404"))
                                  , store := ParseXSBoolean(node->GetAttribute("store"))
                                  , passthrough := ParseXSList(node->GetAttribute("passthrough"))
                                  ];
              CONTINUE;
            }
            CASE "urlevents"
            {
              apply.urlevents := [ haslist := GetHasList(node, ["enabled"])
                                 , enabled := ParseXSBoolean(node->GetAttribute("enabled"))
                                 ];
              CONTINUE;
            }
            CASE "bodyrenderer"
            {
              apply.bodyrenderer := [ library := this->ParseFSPath(node, "library")
                                    , rendermacro := node->GetAttribute("rendermacro")
                                    , preparemacro := node->GetAttribute("preparemacro")
                                    , objectname  := this->ParseFunctionRef(node, "library", "objectname")
                                    ];
              CONTINUE;
            }
            CASE "sitelanguage"
            {
              apply.sitelanguage := [ lang := node->GetAttribute("lang")
                                    , has_lang := node->HasAttribute("lang")
                                    ];
              CONTINUE;
            }
            CASE "usepublishtemplate"
            {
              apply.usepublishtemplate := [ script := this->ParseFSPath(node, "script")
                                          , skipnormalrepublish := ParseXSBoolean(node->GetAttribute("skipnormalrepublish"))
                                          ];

              IF(apply.usepublishtemplate.script = "")
              {
                apply.usepublishtemplate.script := this->siteprof->ParseFSTwopartPathString(node->GetAttribute("site"), node->GetAttribute("fullpath"));
              }
              CONTINUE;
            }
            CASE "allowfoldertype", "denyfoldertype"
            {
              INSERT [ isallow := node->localname LIKE "allow*"
                     , typedef := node->GetAttribute("typedef")
                     ] INTO apply.modifyfoldertypes AT END;
              CONTINUE;
            }
            CASE "allowfiletype", "denyfiletype"
            {
              INSERT [ isallow := node->localname LIKE "allow*"
                     , typedef := node->GetAttribute("typedef")
                     ] INTO apply.modifyfiletypes AT END;
              CONTINUE;
            }
            CASE "uploadtypemapping"
            {
              INSERT [ filenamemask := node->GetAttribute("filenamemask")
                     , mimetypemask := node->GetAttribute("mimetypemask")
                     , filetype     := node->GetAttribute("filetype")
                     ] INTO apply.uploadtypemapping AT END;
              CONTINUE;
            }
            CASE "tagsource"
            {
              RECORD rec :=
                  [ contenttype :=    node->GetAttribute("contenttype")
                  , membername :=     node->GetAttribute("member")
                  , tagfolder :=      this->ParseFSPath(node, "tagfolder")
                  , repository :=     node->GetAttribute("repository")
                  , allowcreate :=    ParseXSBoolean(node->GetAttribute("allowcreate"))
                  ];
              INSERT rec INTO apply.tagsources AT RecordUpperBound(apply.tagsources, rec, [ "CONTENTTYPE", "MEMBERNAME" ]);
              CONTINUE;
            }
            CASE "republish"
            {
              INSERT [ onchange := node->GetAttribute("onchange")
                     , sitemask := node->GetAttribute("sitemask")
                     , folder   := node->GetAttribute("folder")
                     , mask     := node->HasAttribute("mask") ? node->GetAttribute("mask") : "*"
                     , recursive:= ParseXSBoolean(node->GetAttribute("recursive"))
                     , indexonly:= ParseXSBoolean(node->GetAttribute("indexonly"))
                     , scope    := node->GetAttribute("scope")
                     ] INTO apply.republishes AT END;
              CONTINUE;
            }
            CASE "scheduletimedtask"
            {
              INSERT [ task := node->GetAttribute("task")
                     ] INTO apply.scheduletasknows AT END;
              CONTINUE;
            }
            CASE "folderindex"
            {
              RECORD data := [ indexfile        := node->GetAttribute("indexfile")
                             , protectindexfile := ParseXSBoolean(node->GetAttribute("protectindexfile"))
                             , fullpath         := node->GetAttribute("fullpath")
                             , site             := node->GetAttribute("site")
                             , newfiletype      := node->GetAttribute("newfiletype")
                             , newfilename      := node->GetAttribute("newfilename")
                             ];

              IF (data.indexfile = "copy_of_file" AND data.fullpath="")
              {
                this->AddError(node, "Folder index definition selected copy_of_file, but does not specify fullpath");
                CONTINUE;
              }
              IF (data.indexfile = "newfile" AND data.newfiletype="")
              {
                this->AddError(node, "Folder index definition selected newfile, but does not specify a newfiletype");
                CONTINUE;
              }
              apply.folderindex := data;
              CONTINUE;
            }
            CASE "rtddoc"
            {
              RECORD data := [ margins := node->GetAttribute("margins")
                             , rtdtype := node->GetAttribute("rtdtype")
                             , htmlclass := node->GetAttribute("htmlclass")
                             , bodyclass := node->GetAttribute("bodyclass")
                             ];

              IF(NOT node->HasAttribute("margins") OR data.margins NOT IN whconstant_tollium_rtd_margins)
                DELETE CELL margins FROM data;
              IF(NOT node->HasAttribute("rtdtype"))
                DELETE CELL rtdtype FROM data;
              IF(NOT node->HasAttribute("htmlclass"))
                DELETE CELL htmlclass FROM data;
              IF(NOT node->HasAttribute("bodyclass"))
                DELETE CELL bodyclass FROM data;

              apply.rtddoc := data;
              CONTINUE;
            }
            CASE "contentlisting"
            {
              RECORD data := [ fullpath := node->GetAttribute("fullpath")
                             , site := node->GetAttribute("site")
                             ];
              IF(data.fullpath="")
              {
                this->AddError(node, "<" || node->localname || "> definition does not specify fullpath");
                CONTINUE;
              }

              apply := CellUpdate(apply, node->localname, data);
              this->AddWarning(node, "<contentlisting> is only supported by template-v2.whlib designs and will be removed in the future");
              CONTINUE;
            }
            CASE "defaultsettings"
            {
              RECORD settings := [ typedef := node->GetAttribute("typedef")
                                 , members := DEFAULT RECORD ARRAY
                                 ];
              FOREVERY(OBJECT memberobj FROM node->GetChildElementsByTagNameNS(namespace_sp, "member")->GetCurrentElements())
              {
                INSERT [ name := memberobj->GetAttribute("name")
                       , content := memberobj->textcontent
                       ] INTO settings.members AT END;
              }
              INSERT settings INTO apply.defaultsettings AT END;
              CONTINUE;
            }
            CASE "setobjecteditor"
            {
              apply.setobjecteditor := [ name := node->GetAttribute("name")
                                       , screen := MakeAbsoluteScreenReference(this->filename, node->GetAttribute("screen"))
                                       , separateapp := ParseXSBoolean(node->GetAttribute("separateapp"))
                                       , supportsversioning := ParseXSBoolean(node->GetAttribute("supportsversioning"))
                                       ];

              IF(apply.setobjecteditor.name = "" AND apply.setobjecteditor.screen = "")
                this->Adderror(node, "<setobjecteditor> lacks both name and screen");
              ELSE IF(apply.setobjecteditor.name != "" AND apply.setobjecteditor.screen != "")
                this->Adderror(node, "<setobjecteditor> has both name and screen, only one is allowed");
              CONTINUE;
            }
            CASE "setwidget"
            {
              apply.setwidget := apply.setwidget CONCAT
                 [[ contenttype := node->GetAttribute("contenttype")
                  , editor := this->GetWidgetEditor(node)
                  , renderer := this->GetWidgetRenderer(node)
                  , wittycomponent := this->ExpandWittyComponent(node, "wittycomponent")
                  , previewcomponent := this->ExpandWittyComponent(node, "previewcomponent")
                  , has_wittycomponent := node->HasAttribute("wittycomponent")
                  , has_previewcomponent := node->HasAttribute("previewcomponent")
                 ]];
            }
            CASE "disablelegacysitesettings"
            {
              apply.disablelegacysitesettings := TRUE;
              apply.disabletemplateprofile := ParseXSBoolean(node->GetAttribute("notemplateprofile"));
              CONTINUE;
            }
            CASE "customplugin"
            {
              RECORD plugin := MakePluginRecord(this->ParseFunctionRef(node, "library", "objectname"));
              plugin := InstantiatePlugin(plugin);
              plugin.combine := FALSE;

              INSERT plugin INTO apply.plugins AT END;
              CONTINUE;
            }
            CASE "setlibrary"
            {
              INSERT [ name := node->GetAttribute("name")
                     , sources := this->ParseSources(node)
                     ] INTO apply.setlibrary AT END;
              CONTINUE;
            }
            CASE "foldersettings"
            {
              apply.foldersettings := [ filterscreen := MakeAbsoluteResourcePath(this->filename, node->GetAttribute("filterscreen"))
                                      , has_filterscreen := node->HasAttribute("filterscreen")
                                      , ordering := node->GetAttribute("ordering")
                                      , contentslisthandler := DEFAULT RECORD
                                      ];

              OBJECT contentslisthandler := node->GetElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile","contentslisthandler")->Item(0);
              IF(ObjectExists(contentslisthandler))
              {
                apply.foldersettings.contentslisthandler := [ library := MakeAbsoluteResourcePath(this->filename, contentslisthandler->GetAttribute("library"))
                                                            , objectname := contentslisthandler->GetAttribute("objectname")
                                                            ];
              }
              CONTINUE;
            }
            CASE "prebuiltpage"
            {
              STRING ARRAY haslist := GetHasList(node, ["type","title","capturesubpaths"]) CONCAT ["dynexecute"];
              IF("title" NOT IN haslist AND node->HasAttribute("tid"))
                INSERT "title" INTO haslist AT END;
              IF(applyblock->localname != "apply") //we really need to deprecate these...
                this->AddError(node, "<prebuilttype> cannot be used on a <filetype> or <foldertype>");

              INSERT CELL [ type := node->GetAttribute('type')
                          , tag := node->GetAttribute('tag')
                          , haslist := haslist
                          , title := ParseXMLTidPtr(this->module, this->toplevelgid, node, "title")
                          , dynexecute := this->ParseDynamicExecuteData(node)
                          , capturesubpaths := ParseXSBoolean(node->GetAttribute("capturesubpaths"))
                          ]
                     INTO apply.prebuiltpages AT END;
              CONTINUE;
            }
            CASE "mailtemplate"
            {
              INSERT CELL[ path := this->siteprof->ParseFSPath(node, "path")
                         , title := ParseXMLTidPtr(this->module, this->toplevelgid, node, "title")
                         , ordering := ParseXSInt(node->GetAttribute("ordering"))
                         , sources := this->ParseSources(node)
                         ] INTO apply.mailtemplates AT END;
              CONTINUE;
            }
            CASE "allowformquestion","denyformquestion"
            {
              INSERT
                  [ comp := "component"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
            CASE "allowformhandler","denyformhandler"
            {
              INSERT
                  [ comp := "handler"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
            CASE "allowformrtdtype","denyformrtdtype"
            {
              INSERT
                  [ comp := "rtdtype"
                  , type := node->GetAttribute("type")
                  , allow := node->localname LIKE "allow*"
                  ] INTO apply.webtoolsformrules AT END;
              CONTINUE;
            }
          }
        }

        //Verify it against the list of plugins
        BOOLEAN matched;
        FOREVERY(RECORD plugin FROM this->parameters->webdesignplugins)
          IF(plugin.namespace = node->namespaceuri AND plugin.name = node->localname)
          {
            //Instantiate the plugin to let it parse its own settings
            errorsarenowfatal := TRUE; //any error here should abort siteprofile compilation to avoid plugins silently disappearing due to out-of-date errors
            OBJECT pluginobj := MakeObject(plugin.objectname);
            plugin := InstantiatePlugin(plugin);
            errorsarenowfatal := FALSE;

            plugin.data := pluginobj->ParseConfigurationNode(this, node);
            IF(RecordExists(plugin.data))
            {
              INSERT CELL __attributes := pluginobj->ListConfigurationNodeAttributes(node)
                        , __location := this->filename || ":" || node->linenum
                     INTO plugin.data;
            }

            INSERT plugin INTO apply.plugins AT END;
            matched := TRUE;
            BREAK;
          }

        IF(NOT matched)
          FOREVERY(RECORD siteprofnode FROM this->parameters->customnodes)
            IF(siteprofnode.namespace = node->namespaceuri  AND siteprofnode.name = node->localname)
            {
              matched := TRUE;
              INSERT [ namespaceuri := node->namespaceuri, localname := node->localname ] INTO apply.customnodes AT END;
              BREAK;
            }

        //Anything not processed, is a custom node requestable by GetCustomSiteProfileSettings
        IF(NOT matched)
        {
          this->AddError(node, "Unrecognized or unsupported node " || node->namespaceuri || "#" || node->localname);
        }
      }
      CATCH(OBJECT e)
      {
        IF(errorsarenowfatal)
          THROW;

        this->AddError(node, e->what);
      }
    }
    RETURN anynode ? apply : DEFAULT RECORD;
  }

  PUBLIC OBJECT ARRAY FUNCTION GetSiteSettingNodes()
  {
    OBJECT ARRAY applicablenodes;
    FOREVERY(OBJECT node FROM this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile", "sitesettings")->GetCurrentElements())
    {
      IF(NOT IsNodeApplicableToThisWebHare(node))
        CONTINUE;
      INSERT node INTO applicablenodes AT END;
    }
    RETURN applicablenodes;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportSiteSettings()
  {
    // Get the module from the siteprofile path
    STRING module;
    IF (this->siteprof->name LIKE "mod*::*/*")
      module := Tokenize(Tokenize(this->siteprof->name, ":")[2], "/")[0];

    RECORD ARRAY sitesettings;
    FOREVERY(OBJECT siteset FROM this->GetSiteSettingNodes())
    {
      RECORD sitesetting := [ sitefilter := ReadSiteFilter(siteset)
                            , webrules := DEFAULT RECORD ARRAY
                            , addtoindices := DEFAULT RECORD ARRAY
                            , line := siteset->linenum
                            ];

      OBJECT ARRAY sitewebrules := siteset->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/system/moduledefinition", "webruleset")->GetCurrentElements();
      FOREVERY(OBJECT webruleset FROM sitewebrules)
      {
        INTEGER priority := ParseWebRulePriority(webruleset->GetAttribute("priority"));

        FOREVERY(OBJECT webrule FROM GetWebRuleNodes(webruleset))
        {
          RECORD baserule := GetBaseWebRule(-9999999, webrule->GetAttribute("path"), priority, this->siteprof->name || ":" || webrule->linenum);
          RECORD parsed := ParseWebRuleData(module, baserule, webrule, this->siteprof->name);
          this->errormessages := this->errormessages CONCAT parsed.errors;
          this->warnings := this->warnings CONCAT parsed.warnings;

          IF(NOT RecordExists(parsed.rule))
            CONTINUE;

          RECORD therule := [ rule :=         parsed.rule
                            , module :=       GetModuleNameFromResourcePath(this->siteprof->name)
                            , siteprofile :=  this->siteprof->name
                            , line :=         webrule->linenum
                            , col :=          0
                            ];

          INSERT therule INTO sitesetting.webrules AT END;
        }
      }

      OBJECT ARRAY addtoindices := siteset->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/consilio", "addtoindex")->GetCurrentElements();
      FOREVERY(OBJECT addtoindex FROM addtoindices)
      {
        RECORD theindex := [ name := addtoindex->GetAttribute("name")
                           , tag := addtoindex->GetAttribute("tag")
                           , maxgroupobjects := ParseXSInt(addtoindex->GetAttribute("maxgroupobjects"))
                           , discardsummaries := ParseXSBoolean(addtoindex->GetAttribute("discardsummaries"))
                           , http_username := addtoindex->GetAttribute("http_username")
                           , http_password := addtoindex->GetAttribute("http_password")
                           , module := module
                           , siteprofile := this->siteprof->name
                           , line := addtoindex->linenum
                           , col := 0
                           ];

        INSERT theindex INTO sitesetting.addtoindices AT END;
      }
      INSERT sitesetting INTO sitesettings AT END;
    }
    RETURN sitesettings;
  }

  PUBLIC RECORD ARRAY FUNCTION ImportGroupTypes()
  {
    RECORD ARRAY types;
    OBJECT ARRAY grouptypes := this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS(namespace_sp, "grouptype")->GetCurrentElements();
    FOREVERY(OBJECT gtype FROM grouptypes)
    {
      RECORD typeinfo :=
          [ namespace :=          gtype->GetAttribute("namespace")
          , title :=              ParseXMLTIDPtr(this->module, this->toplevelgid, gtype, "title") ?? ":" || gtype->GetAttribute("namespace")
          , tolliumicon :=        gtype->GetAttribute("tolliumicon")
          , members :=            DEFAULT RECORD ARRAY
          ];

      INSERT typeinfo INTO types AT END;
  }
    RETURN types;
  }
  PUBLIC RECORD ARRAY FUNCTION ImportGlobalSettings()
  {
    RECORD ARRAY globalsettings;
    FOREVERY(OBJECT node FROM this->siteprof->xmldoc->documentelement->childnodes->GetCurrentElements())
    {
      //ADDME don't ignore namespaces completely, just ignore nodes that don't have an explicit definition
      IF(node->namespaceuri = "http://www.webhare.net/xmlns/publisher/siteprofile"
         OR node->namespaceuri = "http://www.webhare.net/xmlns/tollium/screens"
         OR node->namespaceuri = "http://www.webhare.net/xmlns/system/moduledefinition")
        CONTINUE;

      INSERT [ siteprofile := this->siteprof->name
//             , siteids := siteids
//             , allsites := allsites
             , idx := #node
             , ns := node->namespaceuri
             , localname := node->localname
             ] INTO globalsettings AT END;
    }
    RETURN globalsettings;
  }
  PUBLIC STRING ARRAY FUNCTION ParseApplySiteProfiles()
  {
    STRING ARRAY loadprofiles;
    FOREVERY(OBJECT resdep FROM this->siteprof->xmldoc->documentelement->GetChildElementsByTagNameNS("http://www.webhare.net/xmlns/publisher/siteprofile","applysiteprofile")->GetCurrentElements())
    {
      IF(NOT IsNodeApplicableToThisWebHare(resdep))
        CONTINUE;

      STRING toload;
      IF(resdep->HasAttribute("path"))
      {
        toload := this->siteprof->ParseFSPath(resdep, "path");
      }
      ELSE
      {
        toload := this->siteprof->ParseFSTwopartPathString(resdep->GetAttribute("site"), resdep->GetAttribute("fullpath"));
        this->AddWarning(resdep, `<applysiteprofile/> should use path=, not site=/fullpath=`);
      }
      toload := MakeAbsoluteResourcePath("", toload);
      TRY
      {
        GetWebhareResource(toload); //validate its existence
        INSERT toload INTO loadprofiles AT END;
      }
      CATCH(OBJECT e)
      {
        this->AddError(resdep, e->what);
      }
    }
    RETURN loadprofiles;
  }
>;

//it should be save to persist this for the current job, as compilation/validation jobs generally dont run long, but a full siteprof recompiler can otherwise build this object 100s of times (341 for me)
OBJECT parametersingleton;

PUBLIC RECORD FUNCTION ParseSiteProfile(STRING filename, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ xmldoc := DEFAULT OBJECT
                              ], options);

  RECORD siteprofdata := [ name := filename
                         , applysiteprofiles := DEFAULT STRING ARRAY
                         , errors := DEFAULT RECORD ARRAY
                         , warnings := RECORD[]
                         , contenttypes := DEFAULT RECORD ARRAY
                         , grouptypes := DEFAULT RECORD ARRAY
                         , rules := RECORD[]
                         ];

  RECORD ARRAY errors, warnings;
  OBJECT siteprof;
  OBJECT siteprofcontext;
  IF(NOT ObjectExists(parametersingleton))
    parametersingleton := PrepareCompile();

  TRY
  {
    siteprof := NEW SiteProfileObject(filename, [ xmldoc := options.xmldoc ]);
    siteprofcontext := NEW SiteprofileCompilationContext(filename, siteprof, parametersingleton);
    OBJECT realdoc := siteprof->xmldoc;

    IF(Length(realdoc->GetParseErrors()) > 0)
      errors := errors CONCAT SELECT resourcename := filename, line, col := 0, message FROM realdoc->GetParseErrors();

    IF(ObjectExists(parametersingleton->siteprofile_schemadef)) //no parse errors, schema available, validate!
    {
      RECORD ARRAY validateerrors := parametersingleton->siteprofile_schemadef->ValidateDocument(realdoc);
      IF(Length(validateerrors)>0)
        errors := errors CONCAT SELECT resourcename := filename, line, col := 0, message FROM validateerrors;
    }

    OBJECT siteprofroot := siteprof->xmldoc->documentelement;

    siteprofcontext->ReadContentTypes();
    siteprofcontext->ParseFolderTypes();
    siteprofcontext->ParseFileTypes();

    siteprofdata.rules := (SELECT *, ruletype := "apply" FROM siteprofcontext->ImportApplies())
                          CONCAT
                          (SELECT *, ruletype := "sitesetting" FROM siteprofcontext->ImportSiteSettings())
                          CONCAT
                          (SELECT *, ruletype := "globalsetting" FROM siteprofcontext->ImportGlobalSettings());

    siteprofdata.applysiteprofiles := siteprofcontext->ParseApplySiteProfiles();
    siteprofdata.grouptypes := siteprofcontext->ImportGroupTypes();
  }
  CATCH(OBJECT e)
  {
    INSERT [ resourcename := filename, line := 0, col := 0, message := e->what ] INTO errors AT END;
  }

  IF(ObjectExists(siteprofcontext))
  {
    errors := siteprofcontext->GetErrors() CONCAT errors;
    warnings := siteprofcontext->GetWarnings() CONCAT warnings;
    siteprofdata.contenttypes := siteprofcontext->contenttypes;
  }
  siteprofdata.errors := errors;
  siteprofdata.warnings := warnings;
  RETURN [ value := siteprofdata
         , ttl := 60*60*1000
         , eventmasks := GetResourceEventMasks([filename])
         ];
}

PUBLIC RECORD FUNCTION GetParsedSiteProfile(STRING resourcename)
{
  RETURN GetAdhocCached( CELL [resourcename ], PTR ParseSiteProfile(resourcename));
}

OBJECTTYPE RecompileParameters
<
  PUBLIC OBJECT siteprofile_schemadef;
  PUBLIC RECORD ARRAY webdesignplugins;
  PUBLIC RECORD ARRAY customnodes;
  PUBLIC STRING ARRAY basesiteprofiles;

  MACRO NEW()
  {
    RECORD sdef := __RetrieveCachedXMLSchema("mod::publisher/data/siteprofile.xsd");
    this->siteprofile_schemadef := sdef.doc;
  }
>;
PUBLIC OBJECT FUNCTION PrepareCompile()
{
  OBJECT parameters := NEW RecompileParameters;

  //Figure out what we need to look out for
  FOREVERY(RECORD mod FROM GetWebHareModules())
  {
    parameters->webdesignplugins := parameters->webdesignplugins CONCAT mod.webdesignplugins;
    parameters->customnodes := parameters->customnodes CONCAT mod.customnodes;
    parameters->basesiteprofiles := parameters->basesiteprofiles CONCAT mod.basesiteprofiles;
  }
  RETURN parameters;
}


