<?wh
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

///Convert scopedtype to classic namespace. Throws if invalid format (unless allowclassicnamespace is set).
PUBLIC STRING FUNCTION ScopedTypeToNamespace(STRING scopedtype, BOOLEAN isreference)
{
  IF(isreference) //we're a referring
  {
    IF(scopedtype LIKE "x-webhare-scopedtype:*" OR scopedtype LIKE "http://*" OR scopedtype LIKE "https://*")
      RETURN scopedtype; //saves us the trouble of remapping;
    IF(scopedtype LIKE "x-namespace:*")
      RETURN Substring(scopedtype, 12);
  }

  //This is a heuristic which we expected to work in the field.. you can escape
  //The regex must match ScopedType in siteprofile.xsd (without the module prefix)
  RECORD ARRAY split := NEW RegEx("^([a-z][a-z0-9_]+):([a-z][a-zA-Z0-9]+)\.([a-z][a-zA-Z0-9]+)")->Exec(scopedtype);
  IF(Length(split) != 4)
  {
    IF(isreference)
      RETURN scopedtype;
    THROW NEW Exception(`Invalid scoped type "${scopedtype}"`);
  }
  RETURN `x-webhare-scopedtype:${split[1].value}.${ToSnakeCase(split[2].value)}.${ToSnakeCase(split[3].value)}`;
}


PUBLIC RECORD FUNCTION CombinePartialNodes(RECORD ARRAY nodes)
{
  nodes := SELECT * FROM nodes WHERE RecordExists(nodes); //custom plugins currently wind up with 1 [DEFAULT RECORD] here

  RECORD retval;
  STRING ARRAY setfields;
  FOREVERY(RECORD upd FROM nodes)
  {
    IF(#upd=0)
    {
      setfields := upd.__attributes;
      retval := upd;
      CONTINUE;
    }
    //later nodes, only update the values that were actually set
    FOREVERY(STRING attr FROM upd.__attributes)
      IF(CellExists(upd, attr))
      {
        IF(attr NOT IN setfields)
          INSERT attr INTO setfields AT END;
        retval := CellUpdate(retval, attr, GetCell(upd, attr));
      }
  }
  DELETE CELL __attributes FROM retval;
  INSERT CELL __setfields := setfields INTO retval;

  INSERT CELL setattributes := retval.__setfields INTO retval;
  DELETE CELL __setfields, __location FROM retval;
  RETURN retval;
}


PUBLIC INTEGER FUNCTION GetFSMemberTypeID(STRING membertypename)
{
  RETURN SearchElement(whconstant_whfstype_membertypes, ToLowercase(membertypename));
}
PUBLIC STRING FUNCTION GetFSMemberTypeName(INTEGER membertypeid)
{
  IF(membertypeid >=0 AND membertypeid < Length(whconstant_whfstype_membertypes))
    RETURN whconstant_whfstype_membertypes[membertypeid];
  ELSE
    RETURN "";
}

/* basic types */
PUBLIC RECORD FUNCTION GetBaseFiletypeRecord()
{
  RETURN [ extensions := DEFAULT STRING ARRAY
         , blobiscontent := FALSE
         , pagelistprovider := ""
         , requirescontent := FALSE
         , generatepreview := FALSE
         , searchcontentprovider := ""
         , indexversion := ""
         , isacceptableindex := FALSE
         , needstemplate := FALSE
         , ispublishable := FALSE
         , initialpublish := FALSE
         , ispublishedassubdir := FALSE
         , capturesubpaths := FALSE
         ];
}

PUBLIC RECORD FUNCTION GetBaseFolderTypeRecord()
{
  RETURN [ indexfile := ""
         , protectindexfile := FALSE
         , ishidden := FALSE
         ];
}

PUBLIC RECORD FUNCTION MakePluginRecord(STRING objectname)
{
  RETURN [ objectname := objectname
         , parser := ""
         , name := ""
         , namespace := ""
         , hooksplugins := DEFAULT RECORD ARRAY
         , hooksfeatures := DEFAULT STRING ARRAY
         ];
}

PUBLIC RECORD FUNCTION InstantiatePlugin(RECORD plugin)
{
  INSERT CELL combine := TRUE
            , wittyname := ""
            , data := DEFAULT RECORD
         INTO plugin;
  RETURN plugin;
}

PUBLIC RECORD FUNCTION MakeBasicTypeInfo(STRING type)
{
  RETURN [ id := 0
         , namespace := ""
         , scopedtype := ""
         , type := type
         , siteprofile :=        ""
         , line := 0
         , title := ""
         , tolliumicon := ""
         , groupmemberships := DEFAULT RECORD ARRAY
         , isembeddedobjecttype := type = "widgettype"
         , isrtdtype := type = "rtdtype"
         , wittycomponent := ""
         , previewcomponent := ""
         , filetype := DEFAULT RECORD
         , foldertype := DEFAULT RECORD
         , orphan := FALSE
         , cloneoncopy := TRUE
         , isdevelopertype := FALSE //TODO can we deprecate this and just have 'ishidden' and allowfiletype/allowfoldertype deal with this?
         , dynamicexecution := DEFAULT RECORD
         ];
}

PUBLIC RECORD FUNCTION MakeBaseSiteprofileXMLStructure()
{
  RETURN MakeMergedRecord(MakeBasicTypeInfo("rtdtype"),
         [ structure := DEFAULT RECORD
         , cssfiles := DEFAULT RECORD ARRAY
         , internallinkroots := DEFAULT INTEGER ARRAY
         , css := ""
         , htmlclass := ""
         , bodyclass := ""
         , allowedobjects := DEFAULT RECORD ARRAY
         , allownewwindowlinks := FALSE
         , ignoresiteprofilewidgets := FALSE
         , applytester := DEFAULT OBJECT
         , linkhandlers := RECORD[]
         , margins := ""
         , tag_b := "b"
         , tag_i := "i"
         ]);
}
