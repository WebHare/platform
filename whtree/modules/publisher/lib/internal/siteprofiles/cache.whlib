<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";


PUBLIC MACRO __SetCSPCacheFromSourceData(RECORD data)
{
  CheckWHFSCache();

  StoreAdhocCached([ type := "siteprofiles" ],
      [ ttl :=          60 * 60 * 1000 // 1 hour
      , value :=        data
      , eventmasks :=   [ "publisher:internal.siteprofiles.recompiled" ]
      ]);
  whfscache_csp := data;
}

RECORD FUNCTION DoGetCacheableSiteProfiles()
{
  BLOB data := GetWebhareResource("storage::system/config/siteprofiles.bin");

  RETURN
      [ ttl :=          60 * 60 * 1000 // 1 hour
      , value :=        __HS_MarshalReadFromBlob(data)
      , eventmasks :=   [ "publisher:internal.siteprofiles.recompiled" ]
      ];
}
RECORD FUNCTION GetCacheableSiteProfiles()
{
  RETURN RunInSeparatePrimary(PTR DoGetCacheableSiteProfiles);
}

PUBLIC RECORD FUNCTION GetCachedSiteProfiles()
{
  CheckWHFSCache();

  IF (NOT RecordExists(whfscache_csp))
    whfscache_csp := GetAdhocCached([ type := "siteprofiles" ], PTR GetCacheableSiteProfiles);

  RETURN whfscache_csp;
}

/** Describes a content type
    @param id Id of the content type
    @cell(boolean) options.isfolder If provided, fallback on normal file / normal folder when the provided id is 0.
    @cell(boolean) options.mockifmissing If set and isfolder has been set, also return 'normal file' / 'normal folder' descriptions
      when the content type could not be found.
    @return Metadata for the content type
    @cell(integer) return.id Id of the content type
    @cell(string) return.namespace Namespace of the content type
    @cell(boolean) return.ispublishable Whether the content type is publishable
    @cell(boolean) return.initialpublish Whether the files should be published immediately after creation
    @cell(boolean) return.needstemplate Whether files of this type need a template
    @cell(string) return.title Tid with the title of the content type
    @cell(string) return.tolliumicon Icon of this content type
    @cell(record) return.dynamicexecution
    @cell(boolean) return.isacceptableindex Wether files of this type can be used as index
    @cell(string array) return.extensions
    @cell(string) return.searchprovider
    @cell(boolean) return.blobiscontent
    @cell(boolean) return.capturesubpaths
    @cell(string) return.siteprofile Siteprofile that defines this content type
    @cell(integer) return.line Line on which this content type is defined
    @cell(string) return.indexfile For folders, type of the index file
    @cell(boolean) return.protectindexfile For folders, whether the index file is protected (pinned automatically)
    @topic siteprofiles/api
    @public
    @loadlib mod::publisher/lib/siteprofiles.whlib
*/
PUBLIC RECORD FUNCTION DescribeContentTypeById(INTEGER id, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ isfolder := FALSE
                             , mockifmissing := FALSE
                             ], options, [optional := ["isfolder"]]);

  IF(options.mockifmissing AND NOT CellExists(options,'isfolder'))
   THROW NEW Exception("The 'mockifmissing' option requires 'isfolder' to be set");

  RECORD type;
  IF(id=0)
  {
    IF(NOT CellExists(options,'isfolder'))
      RETURN DEFAULT RECORD;
    type := LookupContentTypeByName(options.isfolder ? "http://www.webhare.net/xmlns/publisher/normalfolder" : "http://www.webhare.net/xmlns/publisher/unknownfile");
  }
  ELSE
  {
    type := LookupContentTypeById(id);
  }

  BOOLEAN ismissing;
  RECORD fstype;
  IF(NOT RecordExists(type))
  {
    IF(NOT options.mockifmissing)
      RETURN DEFAULT RECORD;

    ismissing := TRUE;
    type := LookupContentTypeByName(options.isfolder ? "http://www.webhare.net/xmlns/publisher/normalfolder" : "http://www.webhare.net/xmlns/publisher/unknownfile");
    fstype := SELECT * FROM system.fs_types WHERE fs_types.id = VAR id;
  }
  ELSE IF(CellExists(options,'isfolder'))
  {
    IF(options.isfolder AND NOT RecordExists(type.foldertype) AND NOT options.mockifmissing)
      RETURN DEFAULT RECORD;

    IF(NOT options.isfolder AND NOT RecordExists(type.filetype) AND NOT options.mockifmissing)
      RETURN DEFAULT RECORD;
  }

  STRING ns := ismissing ? RecordExists(fstype) ? fstype.namespace : "#" || id : type.namespace;
  RETURN [ id := id
         , namespace := ns
         , ispublishable := RecordExists(type.filetype) AND type.filetype.ispublishable
         , initialpublish := RecordExists(type.filetype) AND type.filetype.initialpublish
         , needstemplate := RecordExists(type.filetype) AND type.filetype.needstemplate
         , title := ismissing ? ":"||ns : type.title
         , tolliumicon := type.tolliumicon ?? (RecordExists(type.foldertype) ? whconstant_publisher_foldericonfallback : whconstant_publisher_fileiconfallback)
         , dynamicexecution := type.dynamicexecution
         , isacceptableindex := RecordExists(type.filetype) AND type.filetype.isacceptableindex
         , extensions := RecordExists(type.filetype) ? type.filetype.extensions : STRING[]
         , searchcontentprovider := RecordExists(type.filetype) ? type.filetype.searchcontentprovider : ""
         , indexversion := RecordExists(type.filetype) ? type.filetype.indexversion : ""
         , blobiscontent := RecordExists(type.filetype) AND type.filetype.blobiscontent
         , capturesubpaths := RecordExists(type.filetype) AND type.filetype.capturesubpaths
         , siteprofile := ismissing ? "" : type.siteprofile
         , browserpreview := RecordExists(type.filetype) ? type.filetype.browserpreview : ""
         , line := ismissing ? 0 : type.line
         , iswidgettype := RecordExists(type.filetype) AND type.filetype.generatepreview
         , ispublishedassubdir := RecordExists(type.filetype) AND type.filetype.ispublishedassubdir
         ];
}
PUBLIC RECORD FUNCTION LookupContentTypeById(INTEGER id)
{
  IF(id=0)
    THROW NEW Exception("LookupContentTypeById cannot be invoked with id 0");
  //FIXME cache or optimize
  RETURN SELECT * FROM GetCachedSiteProfiles().contenttypes WHERE contenttypes.id = VAR id;
}
PUBLIC RECORD FUNCTION LookupContentTypeByName(STRING ns)
{
  //FIXME its sorted so use that
  RETURN SELECT * FROM GetCachedSiteProfiles().contenttypes WHERE contenttypes.namespace = VAR ns OR contenttypes.scopedtype = VAR ns;
}
PUBLIC INTEGER ARRAY FUNCTION GetDynamicExecuteFolderTypes()
{
  RETURN SELECT AS INTEGER ARRAY id
           FROM GetCachedSiteProfiles().contenttypes
          WHERE RecordExists(foldertype) AND RecordExists(dynamicexecution);
}

/* Suggest a SEO friendly name. Allows us to centralize any needed tuning and logic (eg the limitutf8bytes line)
   fsobject - Currnet object, which will be used for typeinfo and ignoring conflicts with itself
    parentfolder - Parent folder to use for checking name uniqueness
    type - Content type to use, needed when fsobject is not provided
    isfolder - Whether the new object is a folder, needed when fsobject is not provided
    language - Language to use for getting the title tid if empty
*/
PUBLIC STRING FUNCTION SuggestSeoNameFromTitle(STRING title, RECORD options DEFAULTSTO DEFAULT RECORD) {
  options := ValidateOptions([
    fsobject := DEFAULT OBJECT,
    parentfolder := 0,
    typeinfo := DEFAULT RECORD,
    type := 0,
    isfolder := FALSE,
    language := ""
  ], options);

  INTEGER ignoreobject := ObjectExists(options.fsobject) ? options.fsobject->id : 0;
  INTEGER parentfolder := options.parentfolder ?? (ObjectExists(options.fsobject) ? options.fsobject->parent : 0);
  RECORD typeinfo := options.typeinfo;
  IF(NOT RecordExists(typeinfo)) {
    typeinfo := ObjectExists(options.fsobject) ? DescribeContentTypeById(options.fsobject->type, CELL[ options.fsobject->isfolder, mockifmissing := TRUE ])
                                               : DescribeContentTypeById(options.type, CELL[ options.isfolder, mockifmissing := TRUE ]);
  }

  STRING extension := typeinfo.ispublishedassubdir ? "" : PickFirst(typeinfo.extensions);
  IF(title = "" AND options.language != "")
    title := GetTidForLanguage(options.language, "platform:tolliumapps.publisher.common.newobject-name", GetTidForLanguage(options.language, typeinfo.title));

  STRING suggestedname := GetSafeName(LimitUTF8Bytes(title,200)) || extension;
  IF(options.parentfolder != 0)
    suggestedname := GenerateUniqueName(options.parentfolder, suggestedname, CELL[ ignoreobject]);

  RETURN suggestedname;
}
