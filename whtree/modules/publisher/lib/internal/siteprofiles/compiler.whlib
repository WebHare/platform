<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::publisher/lib/siteprofiles.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/dbschema.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/parser.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";
LOADLIB "mod::system/lib/internal/whfs/contenttypes.whlib";
LOADLIB "mod::system/lib/internal/whfs/events.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

CONSTANT RECORD sp_translations := //JSON key spelling. Must match siteprofiles.ts CachedSiteProfiles and any used types
  CELL[ //valueConstraints
        "minValue","maxValue","maxBytes","valueType","itemType"
      ];

PUBLIC RECORD ARRAY FUNCTION GetCurrentFSTypes()
{
  RETURN SELECT * FROM system.fs_types;
}

PUBLIC RECORD FUNCTION GatherSiteProfiles() {
  RECORD webdesigns_config := __GetExtractedConfig("webdesigns");

  //Gather unique list of siteprofiles
  RECORD ARRAY webdesigns  := SELECT * FROM GetAvailableWebDesigns(FALSE) WHERE Length(siteprofiles) > 0;
  RECORD ARRAY webfeatures := SELECT * FROM GetAvailableWebFeatures() WHERE siteprofile != "";
  STRING ARRAY allsiteprls := SELECT AS STRING ARRAY siteprofile FROM webfeatures;
  STRING ARRAY basesiteprofiles := webdesigns_config.siteprofiles;

  FOREVERY(RECORD webdesign FROM webdesigns)
    allsiteprls := allsiteprls CONCAT webdesign.siteprofiles;

  allsiteprls := GetSortedSet(allsiteprls CONCAT basesiteprofiles);

  //Rebuild a simple reference -> resourceid list
  RECORD ARRAY profilerefs := SELECT isfeature := TRUE
                                    , name := rowkey
                                    , siteprofileids := INTEGER[BinaryFind(allsiteprls, siteprofile) + 1 ]
                                FROM webfeatures;

  FOREVERY(RECORD webdesign FROM webdesigns)
  {
    INTEGER ARRAY siteprofileids;
    FOREVERY(STRING siteprof FROM webdesign.siteprofiles)
      INSERT BinaryFind(allsiteprls, siteprof) + 1 INTO siteprofileids AT END;

    INSERT CELL[ isfeature := FALSE
                , name := webdesign.rowkey
                , siteprofileids
                ] INTO profilerefs AT END;
  }

  INTEGER ARRAY baseprofiles := SELECT AS INTEGER ARRAY BinaryFind(allsiteprls, siteprl) + 1 FROM ToRecordArray(basesiteprofiles, "siteprl");

  RETURN CELL[ siteprofiles := allsiteprls
              , profilerefs
              , baseprofiles
              ];
}

PUBLIC STATIC OBJECTTYPE CoreRecompileContext <
  RECORD result;
  RECORD ARRAY overridemap;
  PUBLIC RECORD ARRAY siteprofiles;
  RECORD ARRAY contenttypes;

  PUBLIC BOOLEAN debug;
  RECORD ARRAY grouptypes;

  MACRO NEW(RECORD ARRAY overridemap DEFAULTSTO RECORD[]) {
    this->overridemap := overridemap;
    this->result := [ messages             := RECORD[]
                    , contenttypes         := RECORD[]
                    , rtdtypes             := RECORD[]
                    , grouptypes           := RECORD[]
                    , siteprofiles         := STRING[]
                    , profilerefs          := RECORD[]
                    , success              := FALSE
                    , applies              := RECORD[]
                    , webrules             := RECORD[]
                    , addtocatalogs        := RECORD[]
                    , hiddenfoldertypes    := INTEGER[]
                    ];
  }

  MACRO LogSPError(STRING resourcename, STRING message, INTEGER line)   {
    INSERT CELL[ resourcename, message, line, col := 0, type := "error" ] INTO this->result.messages AT END;
  }

  MACRO LoadSiteProfileRecursively(STRING name, INTEGER ARRAY siteprofileids, STRING ARRAY loadpath) {
    IF(this->debug)
      Print("Load " || name || " from " || Detokenize(loadpath," >") || "\n");

    IF(name IN loadpath) {
      this->LogSPError(name,"Recursive loadlib detected, path: " || Detokenize(loadpath," >"),0);
      RETURN;
    }
    INSERT name INTO loadpath AT END;

    //Do we have the siteprofile already
    INTEGER existingpos := (SELECT AS INTEGER #siteprofiles + 1 FROM this->siteprofiles WHERE resourcename = name)-1;
    RECORD loaded;
    IF(existingpos=-1) {
      existingpos := Length(this->siteprofiles);

      RECORD override := SELECT * FROM this->overridemap WHERE overridemap.name = name;

      IF(RecordExists(override))
        loaded := ParseSiteProfile(name, CELL[ overridetext := override.text ]).value;
      ELSE
        loaded := GetParsedSiteProfile(name);

      this->result.messages := this->result.messages CONCAT RECORD ARRAY(loaded.messages);
      this->result.rtdtypes := this->result.rtdtypes CONCAT RECORD ARRAY(loaded.rtdtypes);
      this->contenttypes := this->contenttypes CONCAT RECORD ARRAY(loaded.contenttypes);
      this->grouptypes := this->grouptypes CONCAT RECORD ARRAY(loaded.grouptypes);

      INSERT [ resourcename := name
             , siteprofileids := siteprofileids
             , siteprofile := loaded
             ] INTO this->siteprofiles AT END;
    } ELSE {
      loaded := this->siteprofiles[existingpos].siteprofile;

      //if both we and the siteprofile already have limited application, combine them
      IF(Length(this->siteprofiles[existingpos].siteprofileids) > 0)
      { //note that global siteprofiles load before anything specific, so we KNOW Length(siteprofileids) to be > 0
        this->siteprofiles[existingpos].siteprofileids := ArrayUnion(this->siteprofiles[existingpos].siteprofileids, siteprofileids);
      }
    }

    FOREVERY(STRING apply FROM loaded.applysiteprofiles) //note that if the siteprofile is already loaded, this just 'spreads' our siteprofileids recursively
      this->LoadSiteProfileRecursively(apply, this->siteprofiles[existingpos].siteprofileids, loadpath);

    IF(this->debug)
      Print("Done " || name || "\n");
  }

  MACRO ProcessGroupMemberships()   {
    this->grouptypes := SELECT * FROM this->grouptypes ORDER BY namespace;
    STRING ARRAY grouptypenamespaces := SELECT AS STRING ARRAY namespace FROM this->grouptypes;

    FOREVERY (RECORD fs_type FROM this->result.contenttypes) {
      RECORD ARRAY valid_memberships;
      RECORD ARRAY addtogroups;

      // First filter on valid groups, then add to groups as members. Keeps groupmembership lists valid everywhere.
      RECORD pos := RecordLowerBound(this->grouptypes, [ namespace := fs_type.ingroup ], [ "NAMESPACE" ]);
      IF (NOT pos.found) {
        this->LogSPError(fs_type.siteprofile, "Contenttype '" || fs_type.namespace || "' is member of non-existing group '" || fs_type.ingroup || "'", fs_type.line);
      } ELSE {
        RECORD pos2 := RecordLowerBound(this->grouptypes[pos.position].members, fs_type, [ "NAMESPACE" ]);
        IF (NOT pos2.found)
          INSERT fs_type INTO this->grouptypes[pos.position].members AT pos2.position;
      }
    }
  }

  PUBLIC RECORD FUNCTION CompileSiteprofiles(RECORD gathersp) {
    DATETIME now := GetCurrentDateTime();

    // First load all base profiles (these always apply)
    FOREVERY(INTEGER baseprofile FROM gathersp.baseprofiles)
      this->LoadSiteProfileRecursively(gathersp.siteprofiles[baseprofile - 1], INTEGER[], STRING[]);

    // Then run through the siteprofiles that can be activated by a resource id
    FOREVERY(STRING siteprofile FROM gathersp.siteprofiles)
      IF(#siteprofile + 1 NOT IN gathersp.baseprofiles)
        this->LoadSiteProfileRecursively(siteprofile, INTEGER[#siteprofile + 1], STRING[]);

    this->ProcessGroupMemberships();

     // Copy siteprofileids from siteprofiles to the individual rules
    FOREVERY(RECORD siteprof FROM this->siteprofiles) {
      FOREVERY(RECORD rule FROM siteprof.siteprofile.applyrules) {
        RECORD addrule;
        IF(rule.applynodetype = "apply") //explicit <apply> blocks are still scoped to their site(s)
          addrule := CELL[...rule, siteprofileids := siteprof.siteprofileids ];
        ELSE //<filetype> and <foldertype> are not scoped
          addrule := CELL[...rule, siteprofileids := INTEGER[] ];

        INSERT addrule INTO this->result.applies AT END;
      }
      FOREVERY(RECORD rule FROM siteprof.siteprofile.sitesettings) {
        IF(Length(siteprof.siteprofileids) = 0) {
          this->LogSPError(siteprof.resourcename, "Sitesettings may not be defined in siteprofiles that affect all sites", rule.line);
          CONTINUE;
        }

        this->result.webrules      := this->result.webrules      CONCAT SELECT *, siteprofileids := siteprof.siteprofileids, sitefilter := rule.sitefilter FROM rule.webrules;
        this->result.addtocatalogs := this->result.addtocatalogs CONCAT SELECT *, siteprofileids := siteprof.siteprofileids, sitefilter := rule.sitefilter FROM rule.addtocatalogs;
      }
    }
    //Sort apply rules. Note that sorts on record arrays are stable. We place any directly type applied rules to the top, above any priority
    this->result.applies := SELECT * FROM this->result.applies ORDER BY whfstype != "" DESC, priority;

    RETURN [ result := this->result  //FIXME state leak
           , allcontenttypes := this->contenttypes
           ];
  }
>;

PUBLIC STATIC OBJECTTYPE RecompileContext EXTEND CoreRecompileContext <
  RECORD ARRAY current_fs_types;
  RECORD ARRAY current_fs_members;

  INTEGER ARRAY seen_members;

  OBJECT parameters;
  PUBLIC BOOLEAN reportmissing;

  MACRO NEW() {
    this->current_fs_types := SELECT *
                                FROM system_internal.fs_types
                            ORDER BY namespace;
    this->current_fs_members := SELECT *
                                  FROM system_internal.fs_members
                              ORDER BY fs_type;
  }

  PUBLIC RECORD ARRAY FUNCTION GetMessages()   {
    RETURN this->result.messages;
  }

  PUBLIC RECORD ARRAY FUNCTION GetMembersFor(INTEGER gettype)
  {
    RETURN RecordRange(this->current_fs_members, [ fs_type := gettype ], [ "FS_TYPE" ]);
  }

  PUBLIC RECORD ARRAY FUNCTION PreprocessContentTypes(RECORD ARRAY suppliedcontenttypes, RECORD ARRAY currentcontenttypes) //public for test_compiler
  {
    currentcontenttypes := SELECT * FROM currentcontenttypes ORDER BY namespace;
    suppliedcontenttypes := SELECT * FROM suppliedcontenttypes ORDER BY namespace;

    RECORD ARRAY finalcontenttypes;
    FOREVERY(RECORD ctype FROM suppliedcontenttypes)
    {
      // Second time we see this type? If so, ignore this definition and say something
      IF(#ctype > 0)
      {
        RECORD prevctype := suppliedcontenttypes[#ctype-1];
        IF(prevctype.namespace = ctype.namespace)
        {
          this->LogSPError(prevctype.siteprofile, "Location of other definition of '" || ctype.namespace || "'", prevctype.line);
          this->LogSPError(ctype.siteprofile, "Second definition for type '" || ctype.namespace || "' found", ctype.line);
          CONTINUE;
        }
      }

      // These two types are both #0 and will never be inserted into the database, so just put them on the finallist and be done with it
      IF(ctype.namespace IN [ "http://www.webhare.net/xmlns/publisher/unknownfile", "http://www.webhare.net/xmlns/publisher/normalfolder" ])
      {
        INSERT ctype INTO finalcontenttypes AT END;
        CONTINUE;
      }

      /* We originally had GetFSTypeBase which was simply a list of fields that went to the database, triggering a lot of
         field duplication:

      PUBLIC RECORD FUNCTION GetFSTypeBase()
      {
        RETURN CELL [ cloneoncopy := TRUE, isfiletype := FALSE, isfoldertype := FALSE, orphan := FALSE
                    , isacceptableindex := FALSE
                    , needstemplate := FALSE, ispublishable := FALSE, ispublishedassubdir := FALSE
                    , generatepreview := FALSE
                    , isdynamicexecution := FALSE, capturesubpaths := FALSE
                    ];
      }

      I think a lot of these fields don't need to be in the database anymore. But to limit this refactor we'll simply rebuild this this structure

      Look at MakeBasicTypeInfo, GetBaseFolderTypeRecord and GetBaseFiletypeRecord to find out where these fields are in suppliedcontenttypes
      */
      RECORD fstype := CELL[ ctype.cloneoncopy
                           , ctype.scopedtype
                           , isfiletype := RecordExists(ctype.filetype)
                           , isfoldertype := RecordExists(ctype.foldertype)
                           , isdynamicexecution := RecordExists(ctype.dynamicexecution)
                           , orphan := FALSE //TODO isn't this always false? can the parser/compiler return orphans ?
                           , isacceptableindex := RecordExists(ctype.filetype) AND ctype.filetype.isacceptableindex
                           , needstemplate := RecordExists(ctype.filetype) AND ctype.filetype.needstemplate
                           , ispublishable := RecordExists(ctype.filetype) AND ctype.filetype.ispublishable
                           , ispublishedassubdir := RecordExists(ctype.filetype) AND ctype.filetype.ispublishedassubdir
                           , generatepreview := RecordExists(ctype.filetype) AND ctype.filetype.generatepreview
                           , capturesubpaths := RecordExists(ctype.filetype) AND ctype.filetype.capturesubpaths
                           ];

      RECORD existing := RecordLowerBound(currentcontenttypes, ctype, ["NAMESPACE"]);
      RECORD toupdate;

      IF(existing.found)
      {
        RECORD match := currentcontenttypes[existing.position];
        IF( (match.isfoldertype AND RecordExists(ctype.filetype)) OR (match.isfiletype AND RecordExists(ctype.foldertype)))
        {
          this->LogSPError(ctype.siteprofile, "Attempting to redefine file/foldertype", ctype.line);
          CONTINUE;
        }

        //FIXME PREVENT loss of isfoldertype if folders still exist

        ctype.id := match.id;
        FOREVERY(RECORD fld FROM UnpackRecord(fstype))
          IF(fld.value != GetCell(match, fld.name))
            toupdate := CellInsert(toupdate, fld.name, fld.value);

        INSERT CELL toupdate := toupdate INTO ctype;
      }
      ELSE
      {
        ctype.id := -1;
        INSERT CELL toupdate := fstype INTO ctype;
      }
      INSERT ctype INTO finalcontenttypes AT END;
    }
    RETURN finalcontenttypes;
  }

  RECORD ARRAY FUNCTION ApplyContentTypes(RECORD ARRAY contenttypes)
  {
    RECORD ARRAY outtypes;
    FOREVERY(RECORD ctype FROM contenttypes)
    {
      IF(ctype.id != 0) //this type lives in the database
      {
        IF(ctype.id = -1) //desires creation
        {
          ctype.id := MakeAutonumber(system.fs_types,'id');
          INSERT CELL[ ...ctype.toupdate
                     , ctype.id
                     , ctype.namespace
                     , ctype.scopedtype
                     ] INTO system.fs_types;
        }
        ELSE IF(RecordExists(ctype.toupdate))
        {
          UPDATE system.fs_types SET RECORD ctype.toupdate WHERE id = ctype.id;
        }

        RECORD updres := ApplyCTMembersRecurse(ctype.members, ctype.id, 0, FALSE, this->GetMembersFor(ctype.id));
        this->seen_members := this->seen_members CONCAT updres.seenmembers;
      }
      INSERT ctype INTO outtypes AT END;
    }
    RETURN outtypes;
  }

  PUBLIC RECORD FUNCTION RunSPCompiler()
  {
    RECORD gathersp := GatherSiteProfiles();
    RECORD compileresult := this->CompileSiteprofiles(gathersp);
    compileresult := this->ApplyStandardPostProcessing(compileresult);

    //this->result.siteprofiles := SELECT name := resourcename
    //                                  , applysiteprofiles := siteprofile.applysiteprofiles
    //                                  , sites := siteids
    //                               FROM this->siteprofiles;
    this->result.contenttypes := SELECT *, DELETE toupdate FROM this->ApplyContentTypes(compileresult.allcontenttypes);
    this->result.grouptypes := this->grouptypes;
    this->result.hiddenfoldertypes := compileresult.hiddenfoldertypes;
    this->result.profilerefs := gathersp.profilerefs;
    this->result.siteprofiles := gathersp.siteprofiles;

    SaveCompiledSiteProfiles(this->result);
    INSERT CELL fullcspdata := this->result INTO compileresult;

    compileresult := CELL[ ...compileresult
                         , this->result.messages
                         ];

    // Just assume we'll make changes
    GetWHFSCommitHandler()->FSTypesChanged();

    this->UpdateOrphanStatus();

    GetPrimary()->BroadcastOnCommit("publisher:internal.siteprofiles.recompiled", DEFAULT RECORD);
    GetPrimary()->BroadcastOnCommit("publisher:internal.siteprofiles.memberschanged", DEFAULT RECORD);

    CollectGarbage();

    RETURN compileresult;
  }

  MACRO UpdateOrphanStatus()
  {
    // Only hit the DB for records we need to change
    INTEGER ARRAY seen_content_type_ids := SELECT AS INTEGER ARRAY id FROM this->result.contenttypes ORDER BY id;
    INTEGER ARRAY set_orphan_types :=
        SELECT AS INTEGER ARRAY id
          FROM this->current_fs_types
         WHERE (orphan = FALSE OR orphansince = DEFAULT DATETIME) AND NOT LowerBound(seen_content_type_ids, id).found;

    INTEGER ARRAY clear_orphan_types :=
        SELECT AS INTEGER ARRAY id
          FROM this->current_fs_types
         WHERE orphan = TRUE AND LowerBound(seen_content_type_ids, id).found;

    INTEGER ARRAY seen_member_ids := GetSortedSet(this->seen_members);
    INTEGER ARRAY set_orphan_members :=
        SELECT AS INTEGER ARRAY id
          FROM this->current_fs_members
         WHERE (orphan = FALSE OR orphansince = DEFAULT DATETIME) AND NOT LowerBound(seen_member_ids, id).found;
    INTEGER ARRAY clear_orphan_members :=
        SELECT AS INTEGER ARRAY id
          FROM this->current_fs_members
         WHERE orphan = TRUE AND LowerBound(seen_member_ids, id).found;

    DATETIME now := GetCurrentDateTime();
    IF(Length(set_orphan_types) > 0)
    {
      UPDATE system_internal.fs_types
         SET orphan := TRUE
           , orphansince := now
       WHERE id IN set_orphan_types;
    }

    IF(Length(clear_orphan_types) > 0)
    {
      UPDATE system_internal.fs_types
          SET orphan := FALSE
            , orphansince := DEFAULT DATETIME
        WHERE id IN clear_orphan_types;
    }

    IF(Length(set_orphan_members) > 0)
    {
      UPDATE system_internal.fs_members
         SET orphan := TRUE
           , orphansince := now
       WHERE id IN set_orphan_members;
    }

    IF(Length(clear_orphan_members) > 0)
    {
      UPDATE system_internal.fs_members
         SET orphan := FALSE
           , orphansince := DEFAULT DATETIME
       WHERE id IN clear_orphan_members;
    }
  }

  PUBLIC RECORD FUNCTION ApplyStandardPostProcessing(RECORD compileresult) //public for test_compiler
  {
    compileresult.allcontenttypes := this->PreprocessContentTypes(compileresult.allcontenttypes, GetCurrentFSTypes());
    INSERT CELL hiddenfoldertypes := (SELECT AS INTEGER ARRAY id
                                           FROM compileresult.allcontenttypes
                                          WHERE namespace IN VAR whconstant_hiddentypes) INTO compileresult;
    RETURN compileresult;
  }
>;

MACRO SaveCompiledSiteProfiles(RECORD result)
{
  /* We stored this in WHFS to be able to share it in a potential cluster, but we're not there yet and JS stores it on disk anyway... so sort it out later
     If CSP in WHFS we need a working WHFS to read/write is ... but CreateFile/UpdateMetadata may use SetInstanceData and thus rely on CSP to be there */

  INTEGER str := CreateStream();
  __HS_MarshalWriteTo(str, result);
  BLOB blobdata := MakeBlobFromStream(str);

  //TODO This is not an atomic replace. consider combining siteprofiles and siteprofilerefs.json and have the 'fast path' simply update part of the refs file
  STRING configpath := GetModuleStorageRoot("system") || "config";
  UpdateSiteProfileRefs(result); //will also generate the needed directories
  CreateDiskDirectoryRecursive(configpath, TRUE);
  StoreDiskFile(configpath || "/siteprofiles.json", EncodeJSONBlob(result, sp_translations), [ overwrite := TRUE ]);
  StoreDiskFile(configpath || "/siteprofiles.bin", blobdata, [ overwrite := TRUE ]);
}

PUBLIC RECORD FUNCTION __DoRecompileSiteprofiles(BOOLEAN locked, BOOLEAN debug, BOOLEAN reportmissing)
{
  IF(NOT HavePrimaryTransaction()) //--twice already gives us one
    OpenPrimary();
  IF(locked)
    GetPrimary()->BeginLockedWork("publisher:compilesiteprofiles");
  ELSE
    GetPrimary()->BeginWork();

  RECORD response;
  TRY
  {
    OBJECT recompiler := NEW RecompileContext;
    recompiler->debug := debug;
    recompiler->reportmissing := reportmissing;
    response := recompiler->RunSPCompiler();
  }
  CATCH(OBJECT e)
  {
    GetPrimary()->RollbackWork();
    THROW e;
  }
  GetPrimary()->CommitWork();

  __SetCSPCacheFromSourceData(response.fullcspdata);

  RECORD ARRAY errors := SELECT * FROM response.messages WHERE type = "error";
  IF(Length(errors)>0)
    LogError("publisher:siteprofiles", "siteprofilecompilation-error", CELL[ errors ]);

  //async update webserver check/indices
  GetPrimary()->BeginWork();
  GetWHFSCommitHandler()->TriggerSiteSettingsCheckOnCommit();
  GetPrimary()->CommitWork();

  RETURN CELL [ response.messages
              ];
}

PUBLIC RECORD FUNCTION RecompileSiteProfiles()
{
  RETURN WaitForPromise(AsyncRecompileSiteProfiles());
}

PUBLIC ASYNC FUNCTION AsyncRecompileSiteProfiles()
{
  OBJECT service  := AWAIT OpenWebHareService("system:spcompiler");
  TRY
  {
    RECORD response := AWAIT service->RequestRecompile();
    RETURN response;
  }
  FINALLY
  {
    service->CloseService();
  }
}

//Compile the siteprofiles offline. This is a helper for gen_whfs especially during finalize-webhare
PUBLIC RECORD FUNCTION GetOfflineSiteProfiles(BOOLEAN keepsources, RECORD ARRAY overridemap) {
  RECORD gathersp := GatherSiteProfiles();
  OBJECT corecompiler := NEW CoreRecompileContext(overridemap);
  RECORD compileresult := corecompiler->CompileSiteprofiles(gathersp);
  RETURN CELL[
    ...compileresult,
    siteprofiles := keepsources ? corecompiler->siteprofiles : RECORD[]
  ];
}
