<?wh
/** @short Base classes for forms and form pages
    @topic forms/baseclasses
*/
/* Returns FormBase class and basic functions needed to implement backends for your forms (but not form files) */

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/tcpip.whlib";
LOADLIB "wh::util/comparisons.whlib";
LOADLIB "wh::util/localization.whlib";

LOADLIB "mod::publisher/lib/analytics.whlib";
LOADLIB "mod::publisher/lib/webtools/formhandlers/storeresults.whlib";
LOADLIB "mod::publisher/lib/internal/forms/opener.whlib";
LOADLIB "mod::publisher/lib/internal/forms/parser.whlib";
LOADLIB "mod::publisher/lib/internal/forms/rendering.whlib";
LOADLIB "mod::publisher/lib/internal/forms/support.whlib" EXPORT GetFormRequestURL, GetFormWebVariable;
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/internal/forms/conditions.whlib";
LOADLIB "mod::publisher/lib/internal/rtd/previewcontext.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/structuredef.whlib";
LOADLIB "mod::publisher/lib/internal/webdesign/webpagebase.whlib";
LOADLIB "mod::publisher/lib/forms/components.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/remoting/server.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";
LOADLIB "mod::tollium/lib/internal/support.whlib";


//we're not using this text yet, but prevent it from being deleted. can't mark individual tids as 'keep'
CONSTANT STRING wildcard_is_required_text := /*tid*/"publisher:site.forms.starsrequired";

OBJECT defaultrenderer;

OBJECTTYPE FormsFeedbackObject EXTEND FeedbackObjectBase
<
  OBJECT form;

  MACRO NEW(OBJECT form, OBJECT transaction, STRING mutex)
  : FeedbackObjectBase(transaction, mutex)
  {
    this->form := form;
  }

  PUBLIC BOOLEAN FUNCTION Finish()
  {
    IF(this->terminated)
      THROW NEW Exception("This feedback object has already been terminated");

    this->TryCommit();
    this->form->__HandleWorkResult(this->errors, this->warnings);
    RETURN NOT this->HasFailed();
  }
>;

RECORD FUNCTION GetRateLimitConfig()
{
  RETURN [ ttl := 15*60*1000
         , value := CELL[ allformsubmits_maxhits := ReadRegistryKey("publisher.forms.allformsubmits_maxhits")
                        , allformsubmits_timeperiod := ReadRegistryKey("publisher.forms.allformsubmits_timeperiod")
                        , ipformsubmits_maxhits := ReadRegistryKey("publisher.forms.ipformsubmits_maxhits")
                        , ipformsubmits_timeperiod := ReadRegistryKey("publisher.forms.ipformsubmits_timeperiod")
                        , disableratelimits := ReadRegistryKey("publisher.forms.disableratelimits")
                        ]
         , eventmasks := GetRegistryKeyEventMasks([ "publisher.forms.allformsubmits_maxhits"
                                                  , "publisher.forms.limitipformsubmits"
                                                  , "publisher.forms.ipformsubmits_maxhits"
                                                  , "publisher.forms.ipformsubmits_timeperiod"
                                                  , "publisher.forms.disableratelimits"
                                                  ])
         ];
}

STATIC OBJECTTYPE FormPage
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT form;
  RECORD page;

  //Name of callback to render page fields. Note that we take a freestanding function otherwise webtool forms cannot take advantage of this, as we deprecated extending WebtoolFormBase
  STRING fieldsrenderer;
  PUBLIC BOOLEAN visible;
  PUBLIC PROPERTY role(this->page.role,-);
  RECORD pvt_visiblecondition;
  RECORD pvt_redirect;
  STRING pvt_exitbutton;
  PUBLIC STRING title;

  //Redirect submit instruction
  PUBLIC PROPERTY redirect(pvt_redirect, SetRedirect);
  //Delay (in seconds) after which we automatically redirect. default -1, and then we won't even show/update the thankyou page unless exitbutotn is set.
  PUBLIC INTEGER redirectdelay;
  //If set, show an 'exit' button (basically a submit button) with the requested title which must be clicekd to trigger the redirect (or if redirectdelay >= 0 we'll still redirect then)
  PUBLIC PROPERTY exitbutton(pvt_exitbutton, SetExitButton);

  // ---------------------------------------------------------------------------
  //
  // Public variables and properties
  //

  PUBLIC PROPERTY visiblecondition(pvt_visiblecondition, SetVisibleCondition);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT form, RECORD page)
  {
    this->form := form;
    this->page := page;
    this->visible := TRUE;
    this->title := GetTid(page.title);
    this->pvt_visiblecondition := page.visiblecondition;
    this->fieldsrenderer := page.fieldsrenderer;

    IF(page.redirect != "")
      this->pvt_redirect := [ type := "redirect", url := page.redirect ];
    this->redirectdelay := page.redirectdelay;
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC BOOLEAN FUNCTION ContainsField(OBJECT field)
  {
    RETURN RecordExists(SELECT FROM this->page.fields WHERE name = field->name);
  }

  PUBLIC BOOLEAN FUNCTION IsNowVisible()
  {
    IF(NOT this->visible)
      RETURN FALSE;
    IF(RecordExists(this->visiblecondition) AND NOT this->form->MatchFormCondition(this->visiblecondition, DEFAULT RECORD).success)
      RETURN FALSE;
    RETURN TRUE;
  }

  PUBLIC MACRO RenderPageSearchPreview(RECORD previewsettings, OBJECT context)
  {
    IF(this->title != "")
      Print(`<h1>${EncodeHTML(this->title)}</h1>`);

    FOREVERY (RECORD field FROM this->page.fields)
    {
      RECORD fld := SELECT * FROM this->form->__formfields WHERE ToUppercase(name) = ToUppercase(field.name);
      Print(`<div>`);
      fld.obj->RenderFieldSearchPreview(previewsettings, context);
      Print(`</div>`);
    }
  }

  PUBLIC MACRO RenderPage(INTEGER pagenum)
  {
    IF(NOT this->visible) //permanently invisible
      RETURN;

    Print(`<div class="wh-form__page`);
    IF (pagenum>0)
      Print(" wh-form__page--hidden");
    ELSE
      Print(" wh-form__page--visible");
    Print(`"`);
    IF (this->title != "")
      Print(` data-wh-form-pagetitle="${EncodeValue(this->title)}"`);

    IF (this->page.name != "")
      Print(` data-wh-form-pagename="${EncodeValue(this->page.name)}"`);
    IF (this->page.role != "")
    {
      Print(` data-wh-form-pagerole="${EncodeValue(this->page.role)}"`);

      IF (this->page.role = "thankyou")
      {
        // Mark element as providing a status update.
        // This also implictly gives the aria-live of the element a default value of "polite",
        // making screenreaders read out the content when it becomes visible.
        Print(` role="status"`);

        IF(RecordExists(this->redirect))
        {
          Print(` data-wh-form-navigate-to="${EncodeValue(EncodeJSON(this->redirect))}"`);
          IF (this->redirectdelay >= 0)
            Print(` data-wh-form-pageredirect-delay="${this->redirectdelay}"`);
          IF (this->exitbutton != "")
            Print(` data-wh-form-exit-button="${EncodeValue(this->exitbutton)}"`);
        }
      }
    }
    IF (RecordExists(this->visiblecondition))
    {
      STRING condition := this->form->__ExplainConditionsForJS([ this ], "visiblecondition");
      Print(` data-wh-form-visible-if="${EncodeValue(condition)}"`);
    }
    Print('>');

    IF(this->fieldsrenderer != "")
      MakeFunctionPtr(this->fieldsrenderer)(this);
    ELSE
      this->RenderFields();

    Print(`</div>`);
  }

  PUBLIC MACRO RenderFields()
  {
    FOREVERY (RECORD field FROM this->page.fields)
    {
      RECORD fld := SELECT * FROM this->form->__formfields WHERE ToUppercase(name) = ToUppercase(field.name);
      fld.obj->RenderField();
    }
  }

  PUBLIC RECORD FUNCTION GetRenderTree()
  {
    RECORD ARRAY fields;
    FOREVERY(RECORD field FROM this->page.fields)
    {
      RECORD fld := SELECT * FROM this->form->__formfields WHERE ToUppercase(name) = ToUppercase(field.name) AND formgroup = "";
      IF(NOT RecordExists(fld) OR NOT fld.obj->IsFrontendVisible())
        CONTINUE;

      RECORD renderfld := fld.obj->GetRenderTree();
      IF(RecordExists(renderfld))
        INSERT renderfld INTO fields AT END;
    }

    RETURN CELL[ this->title
               , this->page.name
               , this->role
               , redirect := this->role = "thankyou" ? this->page.redirect : ""
               , visiblecondition := __ExplainConditions(this->form, OBJECT[ this ], "visiblecondition")
               , fields
               ];
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  MACRO SetVisibleCondition(RECORD newcondition)
  {
    newcondition := ValidateFormCondition(newcondition);
    this->pvt_visiblecondition := newcondition;
  }

  MACRO SetExitButton(STRING title) {
    IF(this->exitbutton = title)
      RETURN;

    this->pvt_exitbutton := title;
    this->UpdatePage();
  }

  MACRO SetRedirect(RECORD redirect) {
    IF(EncodeJSON(this->pvt_redirect) = EncodeJSON(redirect))
      RETURN;

    this->pvt_redirect := redirect;
    this->UpdatePage();
  }

  MACRO UpdatePage() {
    //FIXME setup guids for form pages so we can robustly refer to them, even with eg. captcha partway inserts
    STRING pagename := "#page." || (this->role ?? ToString(SELECT AS INTEGER #page FROM this->form->GetFormPages() AS page WHERE page.page = this));
    this->form->__SendFormMessage(pagename, 'data', CELL[ this->redirect, this->exitbutton ]);
  }
>;

/** @short Form base object
*/
PUBLIC STATIC OBJECTTYPE FormBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  PUBLIC RECORD __form;
  RECORD ARRAY __formerrors;
  RECORD ARRAY __formwarnings;
  RECORD ARRAY __formmessages;
  STRING __formphase;

  /** @cell name
      @cell obj
  */
  RECORD ARRAY __formfields;
  RECORD ARRAY __formpages;
  OBJECT __wrdauthplugin;
  BOOLEAN __didsearchwrdauthplugin;
  BOOLEAN __havepreinited;
  STRING __formlanguagecode;
  OBJECT __formlastwork;

  /// Callbacks that may add to the form dataset
  FUNCTION PTR ARRAY __formattributescallbacks;

  OBJECT __directhookobject;
  OBJECT __formrenderer;

  // ---------------------------------------------------------------------------
  //
  // Public properties and variables
  //

  /// The current value of the form as a record
  PUBLIC PROPERTY formvalue(__GetFormValue, __SetFormValue);

  /// Rendering engine for this form
  PUBLIC PROPERTY formrenderer(__GetFormRenderer, -);

  /// Webcontext for the form
  PUBLIC PROPERTY formcontext(this->__form.webcontext, -);

  /// Applytester for the form
  PUBLIC PROPERTY formapplytester(this->__form.applytester, -);

  /// prefix for ids. clear to disable ids
  PUBLIC STRING formidprefix;

  /// URL for the the form
  PUBLIC PROPERTY formurl(__GetFormUrl, -);

  /// Language for the form
  PUBLIC PROPERTY formlanguagecode(__formlanguagecode, -);

  //Custom data to be stored with the form results, usually generated by the page hosting the form
  PUBLIC RECORD pagedata;

  /// Additional form classes
  PUBLIC STRING ARRAY formclasses;

  /// Form JS handler. Defaults to publisher:rpc
  PUBLIC STRING formjshandler;

  /// Custom data attributes
  PUBLIC RECORD formdataset;

  /// Form ID (generally used for analytics)
  PUBLIC STRING formid;

  /// "Previous" page link for the first form page
  PUBLIC STRING formbacklink;

  /// Label for 'previous page' buttoon
  PUBLIC STRING formprevlabel;

  /// Label for 'next page' buttoon
  PUBLIC STRING formnextlabel;

  /// Label for 'submit' buttoon
  PUBLIC STRING formsubmitlabel;

  /// 'Fixed' form variables, used for conditions
  PUBLIC RECORD formvariables;

  /// Form submittype (new or edit)
  PUBLIC STRING formsubmittype;

  /// Allow historic values to be selected
  PUBLIC BOOLEAN selecthistoricvalues;

  /// Form reference (persisted over RPCs, seen and possible modifyable by clients so should not contain sensitive or replayable data)
  PUBLIC STRING formref;

  /// Whether to do a rate limit check at first BeginWork. Enabled by external submissions
  PUBLIC BOOLEAN formcheckratelimits;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    IF(NOT RecordExists(__passthrough))
      THROW NEW Exception("Forms should not be directly instantiated but created using OpenForm");

    this->formsubmittype := "new";
    this->__form := __passthrough;
    this->formid :=  __passthrough.formid;
    this->formclasses := __passthrough.classes;
    this->formref := __passthrough.formref;
    __passthrough := DEFAULT RECORD;
    this->formjshandler := this->__form.jshandler;
    this->formidprefix := this->__form.idprefix;
    this->__formlanguagecode := this->__form.languagecode ?? ObjectExists(this->formcontext) ? this->formcontext->languagecode : "en";
    this->formprevlabel :=    GetTidForLanguage(this->__formlanguagecode, this->__form.prevlabel ?? /*TID*/"publisher:site.forms.previouspage");
    this->formnextlabel :=    GetTidForLanguage(this->__formlanguagecode, this->__form.nextlabel ?? /*TID*/"publisher:site.forms.nextpage");
    this->formsubmitlabel :=  GetTidForLanguage(this->__formlanguagecode, this->__form.submitlabel ?? /*TID*/"publisher:site.forms.submit");

    //must do this last, at least so form components can access the languagecode
    this->__InstantiateFields(DEFAULT OBJECT, this->__form.fields);
    this->__InstantiatePages(this->__form.pages);
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  RECORD FUNCTION __GetFormValue()
  {
    RECORD val := CELL[];
    FOREVERY(RECORD fld FROM this->__formfields)
      IF (NOT fld.obj->novalue AND fld.name NOT LIKE "*.*" /* ignore subfields */ )
        val := CellInsert(val, fld.name, fld.obj->value);
    RETURN val;
  }

  MACRO __SetFormValue(RECORD newvalue)
  {
    FOREVERY(RECORD toset FROM UnpackRecord(newvalue))
    {
      RECORD matchfield := SELECT * FROM this->__formfields WHERE ToUppercase(name) = toset.name OR ToUppercase(guid) = toset.name;
      IF(NOT RecordExists(matchfield))
      {
        STRING bestmatch := GetBestMatch(toset.name, SELECT AS STRING ARRAY name FROM this->__formfields);
        THROW NEW Exception(`No matching form field '${toset.name}' in the form value${bestmatch != "" ? `, did you mean '${bestmatch}' ?` : ""}`);
      }
      IF(matchfield.obj->novalue)
        THROW NEW Exception(`Form field '${toset.name}' has no value, it cannot be set`);

      matchfield.obj->value := toset.value;
    }
  }

  STRING FUNCTION __GetFormURL()
  {
    RETURN (IsRequest() ? GetFormRequestURL() : "") ?? (ObjectExists(this->formcontext) ? this->formcontext->baseurl : "");
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  OBJECT ARRAY FUNCTION __InstantiateFields(OBJECT parent, RECORD ARRAY fields)
  {
    OBJECT ARRAY instantiated;
    FOREVERY(RECORD fld FROM fields)
    {
      OBJECT fldobj := this->__InstantiateField(parent, fld);
      INSERT fldobj INTO instantiated AT END;
      MemberInsert(this, "^" || fld.name, FALSE, fldobj);
    }
    RETURN instantiated;
  }

  MACRO __FormAllFields()
  {
    FOREVERY(RECORD page FROM this->GetRenderTree().pages)
      FOREVERY(RECORD fieldgroup FROM page.fields)
      {
        //our standard rendering 'flattens' groups
        this->formrenderer->PrintField(fieldgroup);
        IF(CellExists(fieldgroup,'type') AND fieldgroup.type = "group")
          FOREVERY(RECORD field FROM fieldgroup.fields)
            this->formrenderer->PrintField(field);
      }
  }

  MACRO __InstantiatePages(RECORD ARRAY pages)
  {
    OBJECT ARRAY instantiated;
    FOREVERY (RECORD page FROM pages)
    {
      OBJECT pageobj := NEW FormPage(PRIVATE this, page);
      INSERT CELL[ ...page, obj := pageobj ] INTO this->__formpages AT END;
      IF (page.name != "")
        MemberInsert(this, "^" || page.name, FALSE, pageobj);
    }
  }

  MACRO __FormPrologue() //renders anchors and prologue
  {
    Print(`<a class="wh-anchor"></a>`);
    Print(`<div class="wh-form__prologue"></div>`);
  }

  MACRO __FormAllPages()
  {
    this->formrenderer->PrintPages(this->GetRenderTree());
  }

  OBJECT FUNCTION __GetFormRenderer()
  {
    IF(NOT ObjectExists(this->__formrenderer))
    {
      this->__formrenderer := this->formcontext->GetPlugin("http://www.webhare.net/xmlns/publisher/siteprofile", "formintegration")->GetFormRenderer();
      IF(MemberExists(this->__formrenderer,"__form"))
        this->__formrenderer->__form := PRIVATE this; //transitional, this code will GO AWAY!
    }

    RETURN this->__formrenderer;
  }

  MACRO __SendFormMessage(STRING _field, STRING _prop, VARIANT data)
  {
    DELETE FROM this->__formmessages WHERE field = _field AND prop = _prop;
    INSERT [ field := _field, prop :=_prop, data := data ] INTO this->__formmessages AT END;
  }

  PUBLIC MACRO __EnsurePreInit()
  {
    this->__havepreinited := TRUE;
    FOREVERY(RECORD field FROM this->__formfields)
      field.obj->__EnsurePreInit();
  }

  RECORD FUNCTION __ResolveConditionGUIDs(RECORD condition)
  {
    SWITCH (condition.matchtype)
    {
      CASE "IN", "HAS", "IS", "HASVALUE", "AGE<", "AGE>="
      {
        STRING condition_field := condition.field;
        STRING extra_field;
        IF (condition_field LIKE "*$*")
        {
          condition_field := Tokenize(condition.field, "$")[0];
          extra_field := Substring(condition.field, Length(condition_field));
        }
        RECORD match := SELECT * FROM this->ListFields() WHERE guid = condition_field;
        IF(RecordExists(match))
          condition.field := match.obj->conditionname || extra_field;

        // Convert array values to string (JavaScript checks <input> values, which are always strings)
        IF (TypeID(condition.value) != TypeID(STRING ARRAY) AND IsTypeIDArray(TypeID(condition.value)))
        {
          STRING ARRAY value;
          IF(Length(condition.value) > 0) //more than one element
          {
            //detect type
            STRING rowkeytype := ToLowercase(GetTypeName(TypeID(condition.value[0])));
            value := SELECT AS STRING ARRAY UnmapValueType(rowkeytype, val, "", FALSE) FROM ToRecordArray(condition.value, "val");
          }
          condition := CELL[ ...condition, value ];
        }
        // If matching case insensitive, uppercase the condition values
        IF (condition.matchtype IN [ "IN", "HAS", "IS" ] AND CellExists(condition, "options") AND CellExists(condition.options, "matchcase") AND NOT condition.options.matchcase)
        {
          IF (IsTypeIDArray(TypeID(condition.value)))
            condition.value := SELECT AS STRING ARRAY ToUppercase(val) FROM ToRecordArray(condition.value, "val");
          ELSE IF (TypeID(condition.value) = TypeID(STRING))
            condition.value := ToUppercase(condition.value);
        }
      }
      CASE "AND", "OR"
      {
        FOREVERY (RECORD subcondition FROM condition.conditions)
          condition.conditions[#subcondition] := this->__ResolveConditionGUIDs(subcondition);
      }
      CASE "NOT"
      {
        condition.condition := this->__ResolveConditionGUIDs(condition.condition);
      }
    }
    RETURN condition;
  }

  // ---------------------------------------------------------------------------
  //
  // Internal public API
  //

  PUBLIC OBJECT FUNCTION __InstantiateField(OBJECT parent, RECORD field)
  {
    OBJECT newfield;
    INTEGER insertpos := Length(this->__formfields); //record planned position so we keep subfields from eg <select><option><textarea> _after_ us in eg. result lists
    field.formorder := Length(this->__formfields) + 1;
    TRY
      newfield := field.fieldobject(PRIVATE this, parent, field);
    CATCH (OBJECT e)
      THROW NEW Exception(`Error while instantiating field ${field.name} of type ${field.type}: ${e->what}`, [ trace := e->trace ]);

    INSERT
        CELL[ name := ToUppercase(field.name ?? field.guid)
            , field.isstatic
            , field.ishidden
            , field.isgroup
            , field.formpage
            , field.formgroup
            , field.guid
            , field.title
            , obj := newfield
            , field.supportedvalues
            , field.conditionscope
            , isneverrequired := NOT (field.required OR RecordExists(field.requiredcondition))
            ] INTO this->__formfields AT insertpos;
    RETURN newfield;
  }

  PUBLIC STRING FUNCTION __ExplainConditionsForJS(OBJECT ARRAY objs, STRING conditionname)
  {
    RECORD ARRAY conditions;
    FOREVERY (OBJECT obj FROM objs)
      IF (ObjectExists(obj))
      {
        RECORD cond := Getmember(obj, conditionname);
        IF (RecordExists(cond))
          INSERT cond INTO conditions AT END;
      }

    IF (LENGTH(conditions) > 1)
      conditions := [ CELL[ matchtype := "AND", conditions ] ];

    RECORD condition := conditions;
    IF(NOT RecordExists(condition))
      RETURN "";

    RETURN EncodeJSON([ c := this->__ResolveConditionGUIDs(condition) ]);
  }

  PUBLIC RECORD ARRAY FUNCTION GetFormPages() {
    RETURN SELECT page := page.obj
                , role := page.obj->role
             FROM ToRecordArray(this->__formpages, "page");
  }

  PUBLIC OBJECT FUNCTION EnsureFormCaptchaPage()
  {
    RECORD captchapage := SELECT * FROM this->__formpages WHERE role = "captcha";
    IF(RecordExists(captchapage))
      RETURN captchapage.obj;


    OBJECT pageobj := NEW FormPage(PRIVATE this, CELL[
      title := "",
      visiblecondition := DEFAULT RECORD,
      fieldsrenderer := "",
      fields := RECORD[],
      name := "",
      role := "captcha",
      redirect := "",
      redirectdelay := -1
    ]);

    //insert before thankyou page. if not found, insert at end
    INTEGER thankyoupageidx := (SELECT AS INTEGER #__formpages + 1 FROM this->__formpages WHERE role = "thankyou") ?? Length(this->__formpages) + 1;
    INSERT [ role := "captcha", obj := pageobj ] INTO this->__formpages AT thankyoupageidx - 1;
    RETURN pageobj;
  }

  PUBLIC OBJECT FUNCTION __GetPageContainingField(OBJECT field)
  {
    FOREVERY(RECORD page FROM this->__formpages)
      IF (page.obj->ContainsField(field))
        RETURN page.obj;
    RETURN DEFAULT OBJECT;
  }

  PUBLIC MACRO __HandleWorkResult(RECORD ARRAY errors, RECORD ARRAY warnings)
  {
    this->__formerrors := this->__formerrors CONCAT errors;
    this->__formwarnings := this->__formwarnings CONCAT warnings;
  }

  /** @short Set form values using a flat array. Safer when fieldnames may be long
      @param vals List of values to set
      @cell(string) vals.name Element name to set
      @cell vals.value Value to set
      @cell(boolean) options.rpcjs Set to TRUE if the value are coming from the RPC JS API (and thus need UpdateFromJS)
      @cell(boolean) options.ignorenonexisting Ignore non-existing fields (by default an exception is thrown) */
  PUBLIC MACRO SetFormValues(RECORD ARRAY vals, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ rpcjs := FALSE
                                , ignorenonexisting := FALSE
                                ], options);

    vals := SELECT *, seen := FALSE FROM vals;
    FOREVERY(RECORD field FROM this->__formfields)
    {
      INTEGER ARRAY matchvals := SELECT AS INTEGER ARRAY #vals FROM vals WHERE ToUppercase(vals.name) = ToUppercase(field.name);
      IF(Length(matchvals) > 1)
        THROW NEW Exception(`Attempting to setting field '${field.name}' twice`);
      IF(Length(matchvals) = 0)
        CONTINUE;

      VARIANT toset := vals[matchvals[0]].value;
      IF(options.rpcjs)
      {
        IF(NOT field.obj->IsFrontendVisible()) // The component was never sent to the client, so it cannot have been updated
          CONTINUE;
        field.obj->UpdateFromJS(toset);
      }
      ELSE
        field.obj->value := toset;

      vals[matchvals[0]].seen := TRUE;
    }

    IF(NOT options.ignorenonexisting)
    {
      STRING ARRAY unset := SELECT AS STRING ARRAY name FROM vals WHERE NOT seen;
      IF(Length(unset) > 0)
        THROW NEW Exception(`No such fields: '${Detokenize(unset, "', '")}'`);
    }

    this->__PullFormMessages(); //flush setvalue generated messages so we don't reflect received values
  }

  PUBLIC STRING FUNCTION GetFormTarget()
  {
    STRING extformname := this->__form.name;
    INTEGER fsobj := this->formcontext->targetobject->id;
    IF(extformname LIKE "webtoolform") //FIXME don't switch by name
    {
      RETURN EncryptForThisServer("publisher:formtarget", CELL[ fsobj := this->__form.targetid, name := "webtoolform", formref := this->formref, incontext := this->__form.incontext ]);
    }
    ELSE
    {
      //TODO isn't fsobj & targetid == context?
      RETURN EncryptForThisServer("publisher:formtarget", CELL[ fsobj, name := extformname, formref := this->formref, incontext := this->__form.incontext ]);
    }
  }

  //Prepare form for use in the frontend (either rendering or for result data)
  PUBLIC MACRO PrepareForFrontend()
  {
    IF(GetDtapStage() != "production") //not enabling this everywhere (yet?) as this mostly validation that everyone invokes the protocol right
    {
      IF(this->__formphase = "prepared-frontend")
        THROW NEW Exception(`Duplicate PrepareForFrontend`);
      IF(this->__formphase != "")
        THROW NEW Exception(`PrepareForFrontend was invoked but form is already in phase '${this->__formphase}'`);
    }
    this->__formphase := "prepared-frontend";
  }

  PUBLIC MACRO CheckRateLimits()
  {
    RECORD ratelimitconfig := GetAdhocCached([type := "ratelimitconfig"], PTR GetRateLimitConfig);
    IF(ratelimitconfig.disableratelimits != DEFAULT DATETIME AND ratelimitconfig.disableratelimits > GetCurrentDatetime())
      RETURN; //checks still blocked

    STRING userip := GetClientRemoteIP();
    STRING checkip := userip;
    IF(checkip LIKE "*:*") //ipv6, limit to subnet
      checkip := CanonicalizeIPAddress(checkip || "/64", TRUE);

    RECORD limitresult := CheckRateLimit(CELL[ type := "publisher:formsperip", checkip ], ratelimitconfig.ipformsubmits_maxhits, [ timeperiod := ratelimitconfig.ipformsubmits_timeperiod * 1000 ]);
    IF(NOT limitresult.accepted)
    {
      LogInfo("publisher:forms", `Form submission limit hit for IP ${userip}, throttling`, CELL[ url := GetFormRequestURL(), checkip, userip ]);
    }
    ELSE
    {
      limitresult := CheckRateLimit([ type := "publisher:allformsallips" ], ratelimitconfig.allformsubmits_maxhits, [ timeperiod := ratelimitconfig.allformsubmits_timeperiod * 1000]);
      IF(NOT limitresult.accepted)
      {
        LogInfo("publisher:forms", "Global form submission limit hit, throttling", CELL[ url := GetFormRequestURL(), userip ]);
      }
    }

    IF(NOT limitresult.accepted)
      THROW NEW RPCTooManyRequestsException((limitresult.backoff + 999)/1000);
  }

  /** Submit the form using its current values
      @cell(record) options.extradata Extra data to pass to the form
      @return Submission information
      @cell(boolean) return.success True if form was successfully submitted
      @cell(record) return.result Submission result record (contains the result of Submit)
      @cell(string) return.result.resultsguid GUID under which the results were stored
      @cell(record array) return.errors Fatal errors preventing submission
      @cell(object) return.errors.obj Object reporting the error (you would generally take its 'name' or 'title')
      @cell(string) return.errors.message Error message
      @cell(record array) return.warnings Non-fatal warnings
      @cell(object) return.warnings.obj Object reporting the warning (you would generally take its 'name' or 'title')
      @cell(string) return.warnings.message Warning message
  */
  PUBLIC RECORD FUNCTION FormExecuteSubmit(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(GetDtapStage() != "production") //not enabling this everywhere (yet?) as this mostly validation that everyone invokes the protocol right
    {
      IF(this->__formphase NOT IN [ "prepared-frontend", "submitted" ]) //Note that we don't mind multiple submissions
        THROW NEW Exception(`PrepareForFrontend must have been invoked before running form submit (phase=${this->__formphase})`);

      this->__formphase := "submitted";
    }

    options := ValidateOptions([ extradata := DEFAULT RECORD], options);
    //Construct the fields - FIXME move this back to NEW() but it gives confusing errors. #586
    IF(NOT MemberExists(this,'submit'))
      THROW NEW Exception("The object handling this form has no Submit() function to handle submissions");

    FUNCTION PTR submit := GetObjectMethodPtr(this,'submit');
    IF(NOT ValidateFunctionPtr(submit, TYPEID(RECORD), [TYPEID(RECORD)]))
      THROW NEW Exception("This form's submit handler must be of the form RECORD FUNCTION Submit(RECORD)");

    RECORD result;
    BOOLEAN worknotclosed;
    TRY
    {
      result := submit(options.extradata);
    }
    FINALLY
    {
      IF (ObjectExists(this->__formlastwork) AND NOT this->__formlastwork->terminated)
      {
        this->__formlastwork->Cancel();
        worknotclosed := TRUE;
      }
    }

    IF (worknotclosed)
      THROW NEW Exception("The Submit() function of the object handling this form returned with work still open");

    RETURN [ success := Length(this->__formerrors) = 0
           , result := result
           , errors :=   (SELECT comp, message := text, metadata FROM this->__formerrors   ORDER BY ObjectExists(comp) ? comp->formorder : -1)
           , warnings := (SELECT comp, message := text, metadata FROM this->__formwarnings ORDER BY ObjectExists(comp) ? comp->formorder : -1)
           , messages := this->__PullFormMessages()
           ];
  }

  PUBLIC OBJECT FUNCTION __GetFormMember(STRING name)
  {
    /* TODO Turns out we also get invoked if a form randomly makes up fieldnames
       with type=email, eg https://gitlab.webhare.com/utwente/utwente_base/-/issues/2589#note_222674

       We may need to explicitly mark email fields that actual support/have any form of server side validation
       to prevent us from calling out. Or explictly set a data-form-validator-rpc with eg the serverside field name
       which is just a generic form hint 'this may require immediate server side validation' and we can also offer
       that to 'plain' field types

        For now, we'll never THROW but return DEFAULT OBJECTs for that case
       */
    IF(name LIKE "*.*.*")
    {
      //TODO I don't think we have a server-side generic getmember informs ? this assumes 'contacts.0.email' syntax
      STRING ARRAY toks := Tokenize(name,'.');
      OBJECT target := GetMember(this, "^" || toks[0]);
      toks := ArraySlice(toks,1);

      WHILE(Length(toks) > 0)
      {
        //We assume toks[0] is the array index and toks[1] the actual array member. TODO perhaps verify it's actually an arrayfield at the toplevel we're dealing with?
        IF(Length(toks) = 1) //just one member
          RETURN DEFAULT OBJECT;

        IF(NOT MemberExists(target, "^" || toks[1]))
          RETURN DEFAULT OBJECT;

        target := GetMember(target, "^" || toks[1]);
        toks := ArraySlice(toks,2);
      }
      RETURN target;
    }

    RETURN MemberExists(this, "^" || name) ? GetMember(this, "^" || name) : DEFAULT OBJECT;
  }

  RECORD ARRAY FUNCTION __PullFormMessages() {
    RECORD ARRAY messages := this->__formmessages;
    this->__formmessages := DEFAULT RECORD ARRAY;
    RETURN messages;
  }

  PUBLIC RECORD FUNCTION __FormDoInvoke(STRING methodname, VARIANT ARRAY args)
  {
    STRING targetname := Left(methodname,SearchSubstring(methodname,'.'));
    OBJECT target;

    IF(targetname = "")
    {
      target := this->__directhookobject ?? this;
    }
    ELSE
    {
      target := this->__GetFormMember(targetname);
      IF(NOT ObjectExists(target) OR NOT (target EXTENDSFROM FormFieldBase))
        THROW NEW Exception(targetname || " is not a field");

      methodname := Substring(methodname, Length(targetname) + 1);
    }


    STRING callname := "RPC_" || ToUppercase(Left(methodname,1)) || Substring(methodname,1);
    IF(NOT MemberExists(target, callname))
      THROW NEW Exception(`${targetname = "" ? "Form" : `Field '${targetname}'`} object has no function '${callname}'`);
    IF (GetMemberType(target, callname) = "PRIVATE")
      THROW NEW Exception(`${targetname = "" ? "Form" : `Field '${targetname}'`} object function '${callname}' is private`);


    VARIANT result := CallAnyPtrVA(GetObjectMethodPtr(target, callname), args);
    RETURN [ result := result
           , messages := this->__PullFormMessages()
           ];
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC RECORD FUNCTION GetWittyData()
  {
    IF(GetDtapStage() != "production") //not enabling this everywhere (yet?) as this mostly validation that everyone invokes the protocol right
    {
      IF(this->__formphase NOT IN ["prepared-frontend","submitted"]) //submitted has checked for PrepareForFrontend too, render-after-submit happens in confirmation
      {
        IF(GetObjectTypeName(this) NOT IN ["FORMBASE","WEBTOOLFORMBASE"])
          THROW NEW Exception(`PrepareForFrontend must be invoked before attempting to render a form. If you did... check whether ${GetObjectTypeName(this)} updates PrepareForFrontend without invoking FormBase::PrepareForFrontend`);
        ELSE
          THROW NEW Exception(`PrepareForFrontend must be invoked before attempting to render a form`);
      }
    }

    RECORD wittydata := [ formattributes := PTR this->__FormAttributes
                        , formallfields := PTR this->__FormAllFields
                        , formprologue := PTR this->__FormPrologue
                        , formallpages := PTR this->__FormAllPages
                        , formrender := PTR this->RenderForm
                        , formrendernav := PTR this->__FormNavigation
                        , formclasses := [ "wh-form", "wh-styledinput", ...this->formclasses ]
                        ];

    // Create a witty fully describing the form
    FOREVERY(RECORD fld FROM this->__formfields)
    {
      wittydata := CellInsert(wittydata, fld.name, [ render := PTR fld.obj->RenderField
                                                   , renderintosubfield := PTR fld.obj->RenderIntoSubfield
                                                   ]);
    }
    RETURN wittydata;
  }

  PUBLIC RECORD FUNCTION GetRenderTree()
  {
    IF(GetDtapStage() != "production") //not enabling this everywhere (yet?) as this mostly validation that everyone invokes the protocol right
    {
      IF(this->__formphase NOT IN ["prepared-frontend","submitted"]) //submitted has checked for PrepareForFrontend too, render-after-submit happens in confirmation
        THROW NEW Exception(`PrepareForFrontend must be invoked before attempting to render a form (phase=${this->__formphase})`);
    }

    RECORD ARRAY pages := SELECT AS RECORD ARRAY page.obj->GetRenderTree()
                            FROM ToRecordArray(this->__formpages, "page")
                           WHERE page.obj->visible; //eliminate permanently invisible pages

    RETURN CELL[ classes := this->formclasses
               , ...BuildFormConfig(this)
               , variables := this->formvariables
               , dataset := this->formdataset
               , labels := GetFormLabels(this)
               , pages
               ];
  }

  PUBLIC MACRO RenderForm()
  {
    this->formrenderer->PrintForm(this->GetRenderTree());
  }
  PUBLIC RECORD FUNCTION GetIndexableContent(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ fsobject := DEFAULT OBJECT
                                   , applytester := DEFAULT OBJECT
                                   ], options, [ required := ["applytester"]]);

    INTEGER output := CreateStream();
    INTEGER saveoutput := RedirectOutputTo(output);
    STRING savelanguage := GetTidLanguage();

    TRY
    {
      SetTIDLanguage(options.applytester->GetSiteLanguage());

      RECORD rtdsettings := options.applytester->GetRTDTypeSettings();
      RECORD rtdtype := GetRTDSettingsFromType(rtdsettings.rtdtype);
      OBJECT context := NEW PreviewContext(options.fsobject, options.applytester, rtdtype, TRUE);
      RECORD previewsettings; //for future use, eg to control

      FOREVERY(RECORD page FROM this->__formpages)
        IF(page.role NOT IN ["thankyou"])
          page.obj->RenderPageSearchPreview(previewsettings, context);

      BLOB data := MakeBlobFromStream(output);
      output := 0;

      RETURN CELL [ ...WrapBlob(data, "form.html")
                  ];
    }
    FINALLY
    {
      SetTIDLanguage(savelanguage);
      RedirectOutputTo(saveoutput);

      IF(output != 0)
        MakeBlobFromStream(output);
    }
  }
  MACRO __FormAttributes()
  {
    Print(` method="post"`);
    Print(' action="javascript:console.error(\'No RPC handler installed\');"');

    Print(GetDatasetAsString(CELL[...this->formdataset
                                 ,...GetFormVariablesAsDataset(this->formvariables)
                                 ,...GetFormConfigAsDataset(BuildFormConfig(this))
                                 ]));

    FOREVERY(FUNCTION PTR callback FROM this->__formattributescallbacks)
    {
      STRING toadd := TrimWhitespace(callback());
      IF(toadd != "")
        Print(" " || toadd);
    }
  }

  MACRO __FormNavigation()
  {
    this->formrenderer->PrintNavigation([ labels := GetFormLabels(this) ]);
  }

  /** Get a field by name
      @param findname Name of field to get
      @return The field matching the name. DEFAULT OBJECT if not found */
  PUBLIC OBJECT FUNCTION GetFormField(STRING findname)
  {
    IF(findname = "")
      RETURN DEFAULT OBJECT;

    RETURN SELECT AS OBJECT obj FROM this->__formfields WHERE ToUppercase(name) = ToUppercase(VAR findname);
  }

  /** Register form attributes callbacks, use by fields that (only) need to add data to the `<form>`
      @param toadd Callback to add which will be invoked when the formattributes are rendered */
  PUBLIC MACRO AddFormAttributesCallback(MACRO PTR toadd)
  {
    INSERT toadd INTO this->__formattributescallbacks AT END;
  }

  /** Append a new field to the form
      @param parent Owner of the new field. DEFAULT OBJECT if the field will be a toplevel field
      @param type Type of the new field
      @param name Field name to use in the form. If not specified a random name is set.
      @cell(record) options.match Settings needed to select the proper field subtype
      @cell(string) options.valuetype Requests a specific valuetype from a <textedit> (shorthand for `[match := [valuetype := "..." ]]`)
      @cell(boolean) options.ishidden Creates a hidden field that will still be visible for results, merging and conditions just like static fields
      @return The newly created component
  */
  PUBLIC OBJECT FUNCTION AppendFormField(OBJECT parent, STRING type, STRING name, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    //FIXME 'ishidden' is a bit of a hack. it both hides the field (why not use 'hidden') AND marks the field for storage in the results (by participating in 'isstatic OR ishidden'. why is it named 'ishidden' then)
    options := ValidateOptions([ match := DEFAULT RECORD
                               , valuetype := ""
                               , ishidden := FALSE
                               ], options);

    IF(ObjectExists(parent) AND NOT (parent EXTENDSFROM FormFieldBase))
      THROW NEW Exception("The specified parent is not a form field");
    IF(ObjectExists(this->GetFormField(name)))
      THROW NEW Exception(`A field named '${name}' already exists`);
    IF(options.valuetype != "")
      options.match := CELL[ ...options.match, valuetype := options.valuetype ];

    RECORD field := GetComponentDefinition(type, options);
    field.name := name ?? "dynamic$" || Length(this->__formfields); //FIXME dedupe

    RETURN this->__InstantiateField(parent, field);
  }

  MACRO __FormValidateHooks(OBJECT workobj)
  {

  }

  /** @short Begin transactional work
      @long This function returns a transactional work object, and request any objects on the current screen to perform validation of their filled-in values
      @cell(object array) options.validate Objects to validate. If the list is empty, nothing is validated. If this options is not passed, all fields will be validated
      @cell(boolean) options.database Open work on the database. Defaults to TRUE
      @cell(string) options.mutex Name of mutex to use when opening work
      @return A transactional work object */
  PUBLIC OBJECT FUNCTION BeginWork(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ mutex := ""
                               , validate := [ this ]
                               , database := TRUE
                               ], options);

    IF (ObjectExists(this->__formlastwork) AND NOT this->__formlastwork->terminated)
      THROW NEW Exception(`Cannot call BeginWork, another work object is still open`);

    OBJECT workobj := NEW FormsFeedbackObject(PRIVATE this, options.database ? GetPrimary() : DEFAULT OBJECT, options.mutex);
    this->__formlastwork := workobj;

    TRY
    {
      //First check the specified form - ADDME support specifying a page object for partial validation ?
      IF(Length(options.validate) > 0)
      {
        FOREVERY(RECORD fld FROM this->__formfields)
          fld.obj->ValidateValue(workobj);
        this->__FormValidateHooks(workobj);
      }

      IF(this->formcheckratelimits AND NOT workobj->HasFailed()) //we have a rate limit check pending, and it makes sense ?
      {
        this->formcheckratelimits := FALSE;
        this->CheckRateLimits();
      }
    }
    CATCH (OBJECT e)
    {
      // Ensure the work object isn't leaked
      workobj->Cancel();
      THROW;
    }

    RETURN workobj;
  }

  PUBLIC OBJECT FUNCTION GetWRDAuthPlugin()
  {
    IF(this->__didsearchwrdauthplugin)
      RETURN this->__wrdauthplugin;

    IF(ObjectExists(this->__form.applytester))
    {
      OBJECT webcontext := __GetWebContextForApplyTester(this->__form.applytester, this->__form.applytester->__Deprecated_GetObjInfo().obj.id);
      this->__wrdauthplugin := webcontext->GetWRDAuthPLugin();
    }
    this->__didsearchwrdauthplugin := TRUE;
    RETURN this->__wrdauthplugin;
  }

  PUBLIC RECORD FUNCTION PrepareFormDataForComposer(OBJECT mailcomposer, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ attachfiles := FALSE
                               , language := this->formlanguagecode
                               ], options);

    RECORD result := this->GetWittyResultData( [ language := options.language ]);
    IF(options.attachfiles)
      ApplyWittyToComposer(mailcomposer, result);

    RETURN result;
  }

  PUBLIC RECORD FUNCTION GetWittyResultData(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ language := this->formlanguagecode
                                , submittedfields := STRING[]
                                ], options);
    RECORD retval := [ allfields := RECORD[]
                     , pages := RECORD[]
                     , files := RECORD[]
                     , field := CELL[]
                     , url := ""
                     , ipaddress := ""
                     , ipcountrycode := ""
                     , useragent := ""
                     , submitdate := ""
                     , submittime := ""
                     , pagedata := DEFAULT RECORD
                     , ischange := FALSE
                     , iscancel := FALSE
                     ];

    IF(IsRequest())
    {
      retval.url := GetFormRequestURL();
      retval.ipaddress := GetClientAssumedIP();
      retval.ipcountrycode := GetClientGeoIPCountry();
      retval.useragent := GetWebHeader("User-agent");
    }

    FOREVERY(RECORD page FROM (this->__formpages CONCAT [DEFAULT RECORD])) //'default record' allows us to add unpaged elements ('ishidden') to the results too
    {
      IF(RecordExists(page) AND page.obj->role != "")
        CONTINUE;

      RECORD ARRAY bygroup;
      FOREVERY(RECORD field FROM SELECT * FROM this->__formfields WHERE COLUMN formpage = (RecordExists(page) ? #page : -1))
      {
        IF(field.isgroup)
        {
          INSERT [ title := field.obj->title
                 , fields := RECORD[]
                 , name := field.obj->name
                 , hidetitle := field.obj->hidetitle
                 ] INTO bygroup AT END;
          CONTINUE;
        }
        IF(NOT (field.isstatic OR field.ishidden) OR "none" IN field.supportedvalues) //not a writable field
          CONTINUE;

        IF(NOT RecordExists(bygroup) OR ToUppercase(field.formgroup) != ToUppercase(bygroup[END-1].name)) //open a group
          INSERT [ title := ""
                 , fields := RECORD[]
                 , name := ""
                 , hidetitle := TRUE
                 ] INTO bygroup AT END;

        RECORD val := field.obj->GetComposableData();
        IF(NOT RecordExists(val))
          CONTINUE;

        val := CELL[ fieldname := field.name
                   , fieldguid := field.guid
                   , hidetitle := field.obj->hidetitle
                   , issubmitted := ToUppercase(field.guid ?? field.name) IN options.submittedfields
                   , link := ""
                   , ...val
                   ];

        //FIXME align with EncodeWittyField
        IF(NOT CellExists(val,'text'))
        {
          STRING textvalue;
          SWITCH(TYPEID(val.raw))
          {
            CASE TYPEID(BOOLEAN)
            {
              textvalue := GetTidForLanguage(options.language, val.raw ? "tollium:tilde.yes" : "tollium:tilde.no");
            }
            CASE TYPEID(STRING)
            {
              textvalue := val.raw;
            }
            CASE TYPEID(INTEGER)
            {
              textvalue := ToString(val.raw);
            }
            CASE TYPEID(DATETIME) //FIXME discovert and support time
            {
              // When "en" is specified, use GB notation (day month year) instead of US notation (month day, year) by default
              // (specify "en-US" to get the US notation)
              textvalue := this->FormatFormDate(val.raw, CELL[ options.language ]);
            }
            DEFAULT
            {
            }
          }
          INSERT CELL text := textvalue INTO val;
        }

        IF(Left(field.obj->name, 2) != "__") //do not add internal/guid stuff by its own name
          retval.field := CellInsert(retval.field, field.obj->name, val);

        INSERT val INTO retval.allfields AT END;
        INSERT val INTO bygroup[END-1].fields AT END;
        retval.files := retval.files CONCAT val.files;
      }

      bygroup := SELECT *
                      , anysubmitted := RecordExists(SELECT FROM bygroup.fields WHERE issubmitted)
                   FROM bygroup;

      IF(NOT RecordExists(page) //this is the 'extra' page for ishidden fields
         AND Length(bygroup)=0) // but there weren't any
      {
        CONTINUE;
      }

      INSERT CELL[ title := RecordExists(page) ? page.obj->title : ""
                 , groups := bygroup
                 , anysubmitted := RecordExists(SELECT FROM bygroup WHERE anysubmitted)
                 ] INTO retval.pages AT END;
    }

    RETURN retval;
  }

  PUBLIC STRING FUNCTION FormatFormDate(DATETIME value, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ language := this->formlanguagecode ], options);
    // When "en" is specified, use GB notation (day month year) instead of US notation (month day, year) by default
    // (specify "en-US" to get the US notation)
    RETURN LocalizeDatetime("dMMMMy", value, options.language = "en" ? "en-GB" : options.language);
  }

  PUBLIC RECORD FUNCTION MatchFormCondition(RECORD condition, RECORD result)
  {
    IF(NOT RecordExists(result))
    {
      result := [ form := this
                , submittype := this->formsubmittype
                ];
    }
    RETURN MatchFormCondition(condition, result, this->__formfields);
  }

  PUBLIC RECORD ARRAY FUNCTION ListFields()
  {
    RETURN SELECT * FROM this->__formfields WHERE (isstatic OR ishidden) AND "none" NOT IN supportedvalues;
  }

  PUBLIC MACRO PrefillWithSingleResult(RECORD results)
  {
    RECORD ARRAY formfields := this->ListFields();
    FOREVERY (RECORD resultfield FROM UnpackRecord(results.response))
    {
      OBJECT formfield := SELECT AS OBJECT obj FROM formfields WHERE ToUppercase(guid) = ToUppercase(resultfield.name);
      IF (NOT ObjectExists(formfield))
        formfield := SELECT AS OBJECT obj FROM formfields WHERE ToUppercase(name) = ToUppercase(resultfield.name);
      IF (ObjectExists(formfield) /*AND NOT IsDefaultValue(resultfield.value)*/ AND CanCastTypeTo(TypeID(resultfield.value), TypeID(formfield->value)))
        formfield->value := resultfield.value;
    }
  }

  /** @short Store the current value of the form
      @cell(integer) options.formid The id of the form file to store the results (defaults to current target)
      @cell(string) options.guid The result guid, defaults to a random guid, can be used to overwrite an existing result
      @cell(string) options.idfieldvalue The name of the field that should have a unique value across all form results
      @cell(boolean) options.isedit If this is an edit of an existing result
      @cell(boolean) options.ispending If this is a pending result that has to be confirmed before it's final
      @cell(record) options.extradata Additional data to pass to the submit handler
      @return The guid used to store the result
  */
  PUBLIC STRING FUNCTION StoreFormValue(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ formid := 0
        , guid := ""
        , idfieldvalue := ""
        , isedit := FALSE
        , ispending := FALSE
        , extradata := DEFAULT RECORD
        , __formsubmittype := ""
        ], options);

    IF(options.guid = "")
      options.guid := GenerateUFS128BitId();

    INTEGER formid := options.formid ?? this->__form.webtoolformid;
    DELETE CELL formid FROM options;
    IF (formid = 0 AND ObjectExists(this->formcontext) AND ObjectExists(this->formcontext->targetobject))
      formid := this->formcontext->targetobject->id;
    IF (formid = 0)
      THROW NEW Exception("Could not determine form file id, please set the formid option");

    OBJECT handler := InitializeStoreResultsHandler(this, formid);
    RETURN handler->Submit(this, options.extradata, CELL[...options, DELETE extradata]).result.guid;
  }
>;

/** Base class for hooking into a webtoolform. Invoked in frontend and in tollium contexts to allow forms to add extra
    cells to results */
PUBLIC STATIC OBJECTTYPE WebtoolFormHooks
<
  OBJECT __form;

  PROPERTY form(__form, -);

  MACRO NEW()
  {
    this->__form := __passthrough.form;
  }

  /** @short Invoked before rendering the form
  */
  PUBLIC MACRO PrepareRendering()
  {
  }

  /** @short Prepare for use with the frontend (rendering, rpc or validation)  (WebHare >= 4.34.1)
  */
  PUBLIC MACRO PrepareForFrontend()
  {
  }

  /** @short Do additional form validation
      @long This function is called after the validation of the individual form fields and before processing the form results.
      @param work The currently opened work object
  */
  PUBLIC MACRO Validate(OBJECT work)
  {
  }

  /** @short Do additional form processing
      @long This function is called after the work has been validated initially and before the results are stored. Additional
          errors and warning can be added to the work object. The result record is returned to the client. `resultsguid`
          should not be used as the name of a result record cell.
      @param work The currently opened work object
      @param extradata Extra form data
      @return The result record  */
  PUBLIC RECORD FUNCTION Submit(OBJECT work, RECORD extradata)
  {
    RETURN DEFAULT RECORD;
  }

>;

//TODO find a way so that WebtoolFormPage implements WebtoolFormHooks - but HS can't really do that yet

PUBLIC STATIC OBJECTTYPE WebtoolFormPage EXTEND WebPageBase
<
  PROPERTY form(__GetForm, -);

  PUBLIC OBJECT FUNCTION __GetForm()
  {
    RETURN this->webdesign->webtoolform;
  }

  UPDATE PUBLIC MACRO PTR FUNCTION GetPageBody()
  {
    IF(NOT IsDatabaseWritable())
      RETURN PTR this->webdesign->PrintSimpleErrorBody("publisher:formunavailable", GetTid("publisher:webtools.site.messages.formunavailable"), DEFAULT RECORD);

    IF(ObjectExists(this->form))
    {
      IF(RecordExists(this->form->unavailabletext)) //if the text is set, assume unavailable
        RETURN this->webdesign->GetRTDBody(this->form->unavailabletext);

      // __MaybeConfirmResult returns false if invalid confirmation data was supplied or if the result cannot be confirmed
      // (e.g. it could not be found or was already confirmed)
      IF (NOT this->form->__MaybeConfirmResult())
        RETURN PTR this->webdesign->PrintSimpleErrorBody("publisher:confirmlinkexpired", GetTid("publisher:webtools.site.messages.confirmlinkexpired"), DEFAULT RECORD);

      RETURN this->form->GetFormBody();
    }
    RETURN DEFAULT MACRO PTR;
  }

  /** @short Do additonal form validation
      @long This function is called after the validation of the individual form fields and before processing the form results.
      @param work The currently opened work object
  */
  PUBLIC MACRO Validate(OBJECT work)
  {
  }

  /** @short Do additional form processing
      @long This function is called after the work has been validated initially and before the results are stored. Additional
          errors and warning can be added to the work object. The result record is returned to the client. `resultsguid`
          should not be used as the name of a result record cell.
      @param work The currently opened work object
      @param extradata Extra form data
      @return The result record  */
  PUBLIC RECORD FUNCTION Submit(OBJECT work, RECORD extradata)
  {
    RETURN DEFAULT RECORD;
  }
>;
