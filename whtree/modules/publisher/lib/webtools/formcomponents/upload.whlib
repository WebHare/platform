<?wh
/** @short Standard form components
    @topic forms/standardcomponents
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/forms/base.whlib";
LOADLIB "mod::publisher/lib/forms/components.whlib";
LOADLIB "mod::system/lib/cache.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/networking/antivirus.whlib";
LOADLIB "mod::system/lib/webserver.whlib";


/*
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers

- A valid case-insensitive filename extension, starting with a period (".") character. For example: .jpg, .pdf, or .doc.
  (we don't support extensions yet)
- A valid MIME type string, with no extensions.
- The string audio/* meaning "any audio file".
- The string video/* meaning "any video file".
- The string image/* meaning "any image file".
*/

BOOLEAN FUNCTION IsAcceptableType(STRING filetype, STRING ARRAY masks)
{
  IF(filetype IN masks)
    RETURN TRUE;

  STRING basetype := Tokenize(filetype,'/')[0];
  IF(basetype IN ["image","video","audio"] AND basetype || "/*" IN masks)
    RETURN TRUE;

  RETURN FALSE;
}

STRING FUNCTION GetFileInfo(RECORD filerec)
{
  IF (NOT RecordExists(filerec))
    RETURN "";
  RETURN `${filerec.filename} (${(filerec.length + 1023) / 1024} KB, ${filerec.mimetype})`;
}

PUBLIC STRING FUNCTION __GetLinkToAttachment(STRING hash, INTEGER id) //seen some external users build manual webtool dl.shtml links .. so we'll export it for them..
{
  RETURN ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(),"/.wh/common/download/?type=formattachment&attachment=" || EncryptForThisServer("platform:formattachment", CELL[ hash, id ]));
}

///@private
PUBLIC STATIC OBJECTTYPE FileEditFieldBase EXTEND FormFieldBase
<
  RECORD ARRAY pvt_files;

  ///Acceptable mimetype masks
  PUBLIC STRING ARRAY accept; //TODO: suport extensions too?
  ///Custom error message to show when not accepting
  PUBLIC STRING accepterror;
  ///Maximum # of files. Defaults to 1. Setting it to above 1 changes the value to an array (the 'files' property will always be an array)
  PUBLIC INTEGER maxfiles;

  PUBLIC PROPERTY value(GetValue, SetValue);
  PUBLIC PROPERTY files(GetFiles, SetFiles);

  MACRO NEW(OBJECT form, OBJECT parent, RECORD field)
  : FormFieldBase(form, parent, field)
  {
    this->maxfiles := CellExists(field,'maxfiles') ? field.maxfiles : 1;
  }

  RECORD ARRAY FUNCTION GetFiles()
  {
    RETURN this->pvt_files;
  }

  STRING FUNCTION GetUCFileLink(STRING baseurl, RECORD file)
  {
    RETURN GetCachedFileLink(file, [ baseurl := baseurl, filename := file.filename ]);
  }

  STRING FUNCTION GetFileLink(STRING baseurl, INTEGER idx, RECORD file)
  {
    IF(CellExists(file,'__BLOBSOURCE') AND file.__blobsource != "")
      RETURN this->GetUCFileLink(baseurl, file);
    ELSE
      RETURN "x-original-file:" || (file.hash ?? ToString(idx)) || ":" || EncodeURL(file.filename);
  }

  MACRO SetFiles(RECORD ARRAY infiles)
  {
    IF(Length(infiles) > 0)
    {
      STRING baseurl := IsRequest() ? UnpackURL(GetRequestURL()).origin || "/" : GetPrimaryWebhareInterfaceURL();
      //Assign a working url if possible, otherwise just 'a url' so we can recognize re-receiving this value
      infiles := SELECT *
                      , link := this->GetFileLink(baseurl, #infiles, infiles)
                   FROM infiles;
    }
    this->pvt_files := infiles;
  }

  VARIANT FUNCTION GetValue()
  {
    IF(this->maxfiles > 1)
      RETURN this->files;
    ELSE
      RETURN PickFirst(this->files);
  }

  MACRO SetValue(VARIANT val)
  {
    IF(this->maxfiles > 1)
      IF(TYPEID(val) != TYPEID(RECORD ARRAY))
        THROW NEW Exception("Multi-file upload requires a RECORD ARRAY");
      ELSE
        this->files := val;
    ELSE
      IF(TYPEID(val) != TYPEID(RECORD))
        THROW NEW Exception("Single-file upload requires a RECORD ");
      ELSE
        this->files := RecordExists(val) ? RECORD[val] : DEFAULT RECORD ARRAY;
  }
  STRING FUNCTION GetLinkToWrappedBlob(RECORD val)
  {
    IF(RecordExists(val) AND CellExists(val,'__BLOBSOURCE') AND val.__blobsource LIKE "r*")
    {
      INTEGER id := ToInteger(Substring(val.__blobsource,1),0);
      RETURN __GetLinkToAttachment(val.hash, id);
    }

    IF(RecordExists(val) AND CellExists(val,'__BLOBSOURCE') AND val.__blobsource != "")
      RETURN GetCachedFileLink(val, [ baseurl := GetPrimaryWebhareInterfaceURL()
                                    , filename := val.filename
                                    ]);
    RETURN "";
  }
  UPDATE PUBLIC RECORD FUNCTION GetComposableData()
  {
    RECORD ARRAY files := SELECT *, link := this->GetLinkToWrappedBlob(files), text := GetFileInfo(CELL[ ...files, length := Length(files.data) ] ) FROM this->files;
    RECORD val := this->value;
    STRING link;

    RETURN CELL[ title := this->title
               , raw   := val
               , text  := Detokenize((SELECT AS STRING ARRAY text FROM files), '\n')
               , files
               , link  := Length(files) > 0 ? files[0].link : ""
               ];
  }
  UPDATE PUBLIC RECORD FUNCTION __GetRenderData()
  {
    RECORD base := this->GetBaseRenderData();
    RECORD dataset := base.dataset;

    IF(this->accepterror != "")
    {
      dataset := CELL[ ...dataset
                     , "wh-accepterror" := this->accepterror
                     ];

    }

    RETURN CELL[ ...base
               , value := (SELECT *, DELETE data FROM this->files)
               , type := "upload"
               , dataset
               , this->maxfiles
               , accept := Length(this->accept) > 0 ? Detokenize(this->accept, ', ') : ""
               ];
  }
  UPDATE PUBLIC MACRO ValidateValue(OBJECT work)
  {
    FormFieldBase::ValidateValue(work);
    IF(Length(this->accept) > 0) //mimetype filter is active
      FOREVERY(RECORD file FROM this->pvt_files)
        //TODO Specialize error if all masks are of type image/* and what you uploaded is not an image at all!
        IF(NOT IsAcceptableType(file.mimetype, this->accept)) //TODO explain which file, number or filename?
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.badfiletype"));

    IF(Length(this->pvt_files) > this->maxfiles) //the error is not fully applicable, but how did you avoid the client side validation anyway.. this just protects our virusscan loop
      work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.maxarray", ToString(this->maxfiles)));

    IF(NOT work->HasFailed() AND Length(this->pvt_files) > 0)
      FOREVERY(RECORD file FROM this->pvt_files)
    {
      RECORD scanresult := RunAntivirusScan(file.data);
      IF(scanresult.errorcode != "noscannersavailable")
      {
        RECORD auditdetails := CELL[ client_filename := file.filename
                                   , client_mimetype := file.mimetype
                                   , filehash := ToLowercase(EncodeBase16(GetHashForBlob(file.data, "SHA-256")))
                                   , field := this->name
                                   , scanresult.errorcode
                                   , scanresult.detail
                                   , scanresult.message
                                   , url := GetFormRequestURL()
                                   ];

        LogAuditEvent(scanresult.success ? "system:antivirusscan.ok" : "system:antivirusscan.fail", auditdetails);
        IF(scanresult.errorcode = "suspicious")
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.upload_suspicious"));
        ELSE IF(NOT scanresult.success)
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.upload_cannotcheck"));
      }
    }
  }
  UPDATE PUBLIC MACRO UpdateFromJS(VARIANT jsdata)
  {
    RECORD ARRAY setfiles;
    FOREVERY(RECORD file FROM RECORD ARRAY(jsdata))
    {
      IF(CellExists(file,'link') AND TYPEID(file.link) = TYPEID(STRING))
      {
        IF(file.link LIKE "data:*") //Old format uploads. Race during upgrade to 5.6? or someone trying to use the file edit backend code with data: urks
        {
          INSERT CELL[ ...WrapBlob(ParseDataURL(file.link).data, file.filename)
                     , file.link
                     ] INTO setfiles AT END;
        }
        ELSE
        {
          RECORD source := SELECT * FROM this->files WHERE link = file.link; //it's the same!
          IF(NOT RecordExists(source))
            source := GetWrappedSourceFromURL(file.link); //Still recognizing it as an existing image, maybe moddate changed
          IF(RecordExists(source))
            INSERT CELL[ ...source, file.link ] INTO setfiles AT END;
        }
      }
      ELSE IF(CellExists(file,'file') AND CellExists(file.file,'token'))
      {
        //refers to an uploaded file
       RECORD upload := GetUploadedFile(file.file.token);
       INSERT CELL[...WrapBlob(upload.data, file.file.name),link := ""] INTO setfiles AT END;
      }
    }
    this->pvt_files := setfiles;
  }
  UPDATE PUBLIC BOOLEAN FUNCTION IsSet()
  {
    RETURN Length(this->pvt_files) > 0;
  }
  UPDATE PUBLIC RECORD FUNCTION GetStorageValue()
  {
    IF(Length(This->pvt_files) = 0)
      RETURN DEFAULT RECORD ARRAY;

    RECORD ARRAY result, attachments;
    FOREVERY(RECORD file FROM this->files)
    {
      //Now generate hash and dominantcolors...
      RECORD storevalue := WrapBlob(file.data, file.filename, [ generatehash := TRUE, extractdominantcolor := TRUE ]);
      RECORD metadata := CELL[...storevalue, DELETE data, length := Length64(storevalue.data), seqnr := #file ];

      INSERT metadata INTO result AT END;
      INSERT file INTO attachments AT END;
    }

    RETURN CELL[ result, attachments ];
  }
  UPDATE PUBLIC MACRO SetFromStorage(VARIANT invalue, RECORD ARRAY attachments)
  {
    //formresults pre WH 5.6.1 may not store the seqnr
    this->files := SELECT * FROM attachments ORDER BY CellExists(attachments,'seqnr') ? attachments.seqnr : -1;
  }
  UPDATE PUBLIC RECORD ARRAY FUNCTION GetResultColumns(RECORD exportoptions)
  {
    RECORD ARRAY cols := [[ title := this->title
                          , name := "file"
                          , type := exportoptions.inlineattachments ? "file" : "text"
                         ]];

    IF(exportoptions.isfullexport AND NOT exportoptions.inlineattachments)
    {
      IF (exportoptions.withattachments)
      {
        INSERT [ title := this->title || " - path"
               , name := "filedata"
               , type := "attachment"
               ] INTO cols AT END;
      }
      ELSE
      {
        INSERT [ title := this->title || " - link"
               , name := "filelink"
               , type := "link"
               ] INTO cols AT END;
      }
    }

    RETURN cols;
  }
  //We need to return one record (per result) - but we're allowed to put arrays inside these record cells
  UPDATE PUBLIC RECORD FUNCTION EnrichAFormattedResult(RECORD exportoptions, VARIANT storedvalue, INTEGER formresult, RECORD ARRAY allattachments)
  {
    RECORD ARRAY rows;
    IF(TYPEID(storedvalue) = TYPEID(RECORD)) //Pre WH5.6.1 stores as record
      rows := RECORD[ storedvalue ];
    ELSE
      rows := storedvalue;

    IF (NOT exportoptions.isfullexport)
    {
      IF(NOT IsValueSet(storedvalue))
        RETURN CELL[ file := STRING[] ];

      RETURN [ file := SELECT AS STRING ARRAY GetFileInfo(rows) FROM rows ];
    }

    IF (exportoptions.inlineattachments)
    {
      IF(NOT IsValueSet(storedvalue))
        RETURN CELL[ file := RECORD[] ]; //because file is a RECORD[] here and a STRING[] elsewhere, we cant just put this IF at the top of this function

      RETURN [ file := SELECT title := GetFileInfo(rows), file := rows FROM rows ];
    }

    //formresults pre WH 5.6.1 may not store the seqnr
    RECORD ARRAY attachments := SELECT * FROM allattachments WHERE allattachments.formresult = VAR formresult ORDER BY CellExists(allattachments,'seqnr') ? allattachments.seqnr : -1;
    IF (exportoptions.withattachments)
    {
      IF(NOT IsValueSet(storedvalue))
        RETURN CELL[ file := STRING[], filedata := RECORD[] ];

      RETURN [ file := (SELECT AS STRING ARRAY GetFileInfo(rows) FROM rows)
             , filedata := (SELECT *, data := attachments[#rows].file FROM rows)
             ];
    }
    ELSE
    {
      IF(NOT IsValueSet(storedvalue))
        RETURN CELL[ file := STRING[], filedata := RECORD[], filelink := STRING[] ];

      RETURN [ file := (SELECT AS STRING ARRAY GetFileInfo(rows) FROM rows)
             , filelink := (SELECT AS STRING ARRAY __GetLinkToAttachment(rows.hash, attachments[#rows].id) FROM rows)
             , filedata := RECORD[]
             ];
    }
  }
  UPDATE PUBLIC RECORD ARRAY FUNCTION EnrichWithFormattedResults(RECORD exportoptions, RECORD ARRAY inputvalues)
  {
    INTEGER ARRAY formresultids := SELECT AS INTEGER ARRAY formresult FROM inputvalues WHERE IsValueSet(value);

    RECORD ARRAY allattachments;

    IF(exportoptions.isfullexport AND NOT exportoptions.inlineattachments)
      allattachments :=
          SELECT *
            FROM publisher.formattachments
           WHERE formattachments.formresult IN formresultids
                 AND formattachments.question = exportoptions.storename
        ORDER BY formattachments.formresult;

    RECORD ARRAY results := SELECT AS RECORD ARRAY this->EnrichAFormattedResult(exportoptions, value, formresult, allattachments) FROM inputvalues;
    RETURN results;
  }
>;

PUBLIC STATIC OBJECTTYPE UploadField EXTEND FileEditFieldBase
<
>;


PUBLIC RECORD FUNCTION ParseFormUpload(RECORD fielddef, OBJECT node, RECORD parsecontext)
{
  INSERT CELL maxfiles := node->HasAttribute("maxfiles") ? ParseXSInt(node->GetAttribute("maxfiles")) : 1 INTO fielddef;
  RETURN fielddef;
}
