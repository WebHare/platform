<?wh
/** @short Standard form components
    @topic forms/standardcomponents
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";

LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/forms/base.whlib";
LOADLIB "mod::publisher/lib/forms/components.whlib";
LOADLIB "mod::system/lib/cache.whlib";
LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/networking/antivirus.whlib";
LOADLIB "mod::system/lib/webserver.whlib";


/*
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file#Unique_file_type_specifiers

- A valid case-insensitive filename extension, starting with a period (".") character. For example: .jpg, .pdf, or .doc.
  (we don't support extensions yet)
- A valid MIME type string, with no extensions.
- The string audio/* meaning "any audio file".
- The string video/* meaning "any video file".
- The string image/* meaning "any image file".
*/

BOOLEAN FUNCTION IsAcceptableType(STRING filetype, STRING ARRAY masks)
{
  IF(filetype IN masks)
    RETURN TRUE;

  STRING basetype := Tokenize(filetype,'/')[0];
  IF(basetype IN ["image","video","audio"] AND basetype || "/*" IN masks)
    RETURN TRUE;

  RETURN FALSE;
}

STRING FUNCTION GetFileInfo(RECORD filerec)
{
  IF (NOT RecordExists(filerec))
    RETURN "";
  RETURN `${filerec.filename} (${(filerec.length + 1023) / 1024} KB, ${filerec.mimetype})`;
}

///@private
PUBLIC STATIC OBJECTTYPE FileEditFieldBase EXTEND FormFieldBase
<
  RECORD ARRAY pvt_files;

  ///Acceptable mimetype masks
  PUBLIC STRING ARRAY accept; //TODO: suport extensions too?
  ///Custom error message to show when not accepting
  PUBLIC STRING accepterror;
  ///Maximum # of files. Defaults to 1. Setting it to above 1 changes the value to an array (the 'files' property will always be an array)
  PUBLIC INTEGER maxfiles;

  PUBLIC PROPERTY value(GetValue, SetValue);
  PUBLIC PROPERTY files(GetFiles, SetFiles);

  MACRO NEW(OBJECT form, OBJECT parent, RECORD field)
  : FormFieldBase(form, parent, field)
  {
    this->maxfiles := CellExists(field,'maxfiles') ? field.maxfiles : 1;
  }

  RECORD ARRAY FUNCTION GetFiles()
  {
    RETURN this->pvt_files;
  }

  STRING FUNCTION GetUCFileLink(STRING baseurl, RECORD file)
  {
    RETURN GetCachedFileLink(file, [ baseurl := baseurl, filename := file.filename ]);
  }

  STRING FUNCTION GetFileLink(STRING baseurl, INTEGER idx, RECORD file)
  {
    IF(CellExists(file,'__BLOBSOURCE') AND file.__blobsource != "")
      RETURN this->GetUCFileLink(baseurl, file);
    ELSE
      RETURN "x-original-file:" || (file.hash ?? ToString(idx)) || ":" || EncodeURL(file.filename);
  }

  MACRO SetFiles(RECORD ARRAY infiles)
  {
    IF(Length(infiles) > 0)
    {
      STRING baseurl := IsRequest() ? UnpackURL(GetRequestURL()).origin || "/" : GetPrimaryWebhareInterfaceURL();
      //Assign a working url if possible, otherwise just 'a url' so we can recognize re-receiving this value
      infiles := SELECT *
                      , link := this->GetFileLink(baseurl, #infiles, infiles)
                   FROM infiles;
    }
    this->pvt_files := infiles;
  }

  VARIANT FUNCTION GetValue()
  {
    IF(this->maxfiles > 1)
      RETURN this->files;
    ELSE
      RETURN PickFirst(this->files);
  }

  MACRO SetValue(VARIANT val)
  {
    IF(this->maxfiles > 1)
      IF(TYPEID(val) != TYPEID(RECORD ARRAY))
        THROW NEW Exception("Multi-file upload requires a RECORD ARRAY");
      ELSE
        this->files := val;
    ELSE
      IF(TYPEID(val) != TYPEID(RECORD))
        THROW NEW Exception("Single-file upload requires a RECORD ");
      ELSE
        this->files := RecordExists(val) ? RECORD[val] : DEFAULT RECORD ARRAY;
  }
  UPDATE PUBLIC RECORD FUNCTION GetComposableData()
  {
    RECORD val := this->value;
    STRING link;
    IF(RecordExists(val) AND CellExists(val,'__BLOBSOURCE') AND val.__blobsource != "")
      link := GetCachedFileLink(val, [ baseurl := GetPrimaryWebhareInterfaceURL()
                                     , filename := val.filename
                                     ]);

    RETURN CELL[ title := this->title
               , raw   := val
               , text  := RecordExists(val) ? GetFileInfo(CELL[ ...val, length := Length(val.data) ] ) : ""
               , files := RecordExists(val) ? [ val ] : DEFAULT RECORD ARRAY
               , link
               ];
  }
  UPDATE PUBLIC RECORD FUNCTION __GetRenderData()
  {
    RECORD base := this->GetBaseRenderData();
    RECORD dataset := base.dataset;

    IF(this->accepterror != "")
    {
      dataset := CELL[ ...dataset
                     , "wh-accepterror" := this->accepterror
                     ];

    }

    RETURN CELL[ ...base
               , value := (SELECT *, DELETE data FROM this->files)
               , type := "upload"
               , dataset
               , this->maxfiles
               , accept := Length(this->accept) > 0 ? Detokenize(this->accept, ', ') : ""
               ];
  }
  UPDATE PUBLIC MACRO ValidateValue(OBJECT work)
  {
    FormFieldBase::ValidateValue(work);
    IF(Length(this->accept) > 0) //mimetype filter is active
      FOREVERY(RECORD file FROM this->pvt_files)
        //TODO Specialize error if all masks are of type image/* and what you uploaded is not an image at all!
        IF(NOT IsAcceptableType(file.mimetype, this->accept)) //TODO explain which file, number or filename?
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.badfiletype"));

    IF(Length(this->pvt_files) > this->maxfiles) //the error is not fully applicable, but how did you avoid the client side validation anyway.. this just protects our virusscan loop
      work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.maxarray", ToString(this->maxfiles)));

    IF(NOT work->HasFailed() AND Length(this->pvt_files) > 0)
      FOREVERY(RECORD file FROM this->pvt_files)
    {
      RECORD scanresult := RunAntivirusScan(file.data);
      IF(scanresult.errorcode != "noscannersavailable")
      {
        RECORD auditdetails := CELL[ client_filename := file.filename
                                   , client_mimetype := file.mimetype
                                   , filehash := ToLowercase(EncodeBase16(GetHashForBlob(file.data, "SHA-256")))
                                   , field := this->name
                                   , scanresult.errorcode
                                   , scanresult.detail
                                   , scanresult.message
                                   , url := GetFormRequestURL()
                                   ];

        LogAuditEvent(scanresult.success ? "system:antivirusscan.ok" : "system:antivirusscan.fail", auditdetails);
        IF(scanresult.errorcode = "suspicious")
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.upload_suspicious"));
        ELSE IF(NOT scanresult.success)
          work->AddErrorFor(this, GetTid("publisher:site.forms.commonerrors.upload_cannotcheck"));
      }
    }
  }
  UPDATE PUBLIC MACRO UpdateFromJS(VARIANT jsdata)
  {
    RECORD ARRAY setfiles;
    FOREVERY(RECORD file FROM RECORD ARRAY(jsdata))
    {
      IF(CellExists(file,'link') AND TYPEID(file.link) = TYPEID(STRING))
      {
        IF(file.link LIKE "data:*") //Old format uploads. Race during upgrade to 5.6? or someone trying to use the file edit backend code with data: urks
        {
          INSERT CELL[ ...WrapBlob(ParseDataURL(file.link).data, file.filename)
                     , file.link
                     ] INTO setfiles AT END;
        }
        ELSE
        {
          RECORD source := SELECT * FROM this->files WHERE link = file.link; //it's the same!
          IF(NOT RecordExists(source))
            source := GetWrappedSourceFromURL(file.link); //Still recognizing it as an existing image, maybe moddate changed
          IF(RecordExists(source))
            INSERT CELL[ ...source, file.link ] INTO setfiles AT END;
        }
      }
      ELSE IF(CellExists(file,'file') AND CellExists(file.file,'token'))
      {
        //refers to an uploaded file
       RECORD upload := GetUploadedFile(file.file.token);
       INSERT CELL[...WrapBlob(upload.data, file.file.name),link := ""] INTO setfiles AT END;
      }
    }
    this->pvt_files := setfiles;
  }
  UPDATE PUBLIC BOOLEAN FUNCTION IsSet()
  {
    RETURN Length(this->pvt_files) > 0;
  }
  UPDATE PUBLIC RECORD FUNCTION GetStorageValue()
  {
    IF(NOT RecordExists(this->value))
      RETURN DEFAULT RECORD;

    //Now generate hash and dominantcolors...
    RECORD storevalue := WrapBlob(this->value.data, this->value.filename, [ generatehash := TRUE, extractdominantcolor := TRUE ]);
    RECORD metadata := CELL[...storevalue, DELETE data, length := Length64(storevalue.data)];
    RETURN [ result      := metadata
           , attachments := RECORD[this->value]
           ];
  }
  UPDATE PUBLIC MACRO SetFromStorage(VARIANT invalue, RECORD ARRAY attachments)
  {
    IF(NOT RecordExists(invalue) OR Length(attachments)=0)
    {
      this->value := DEFAULT RECORD;
      RETURN;
    }
    this->value := attachments[0];
  }
  UPDATE PUBLIC RECORD ARRAY FUNCTION GetResultColumns(RECORD exportoptions)
  {
    RECORD ARRAY cols := [[ title := this->title
                          , name := "file"
                          , type := exportoptions.inlineattachments ? "file" : "text"
                         ]];

    IF(exportoptions.isfullexport AND NOT exportoptions.inlineattachments)
    {
      IF (exportoptions.withattachments)
      {
        INSERT [ title := this->title || " - path"
               , name := "filedata"
               , type := "attachment"
               ] INTO cols AT END;
      }
      ELSE
      {
        INSERT [ title := this->title || " - link"
               , name := "filelink"
               , type := "link"
               ] INTO cols AT END;
      }
    }

    RETURN cols;
  }
  UPDATE PUBLIC RECORD ARRAY FUNCTION EnrichWithFormattedResults(RECORD exportoptions, RECORD ARRAY inputvalues)
  {
    IF (NOT exportoptions.isfullexport)
    {
      RETURN
          SELECT file := GetFileInfo(value)
            FROM inputvalues;
    }

    IF (exportoptions.inlineattachments)
    {
      RETURN SELECT file := [ title := GetFileInfo(value), file := value ] FROM inputvalues;
    }
    ELSE IF (exportoptions.withattachments)
    {
      INTEGER ARRAY formresultids :=
          SELECT AS INTEGER ARRAY formresult
            FROM inputvalues
           WHERE RecordExists(value);

      RECORD ARRAY attachments :=
          SELECT *
            FROM publisher.formattachments
           WHERE formattachments.formresult IN formresultids
                 AND formattachments.question = exportoptions.storename
        ORDER BY formattachments.formresult;

      RETURN
          SELECT TEMPORARY attachmentpos := RecordLowerBound(attachments, inputvalues, [ "FORMRESULT" ])
               , file := GetFileInfo(value)
               , filedata := RecordExists(value) AND attachmentpos.found
                      ? CELL[ ...value
                            , data :=             attachments[attachmentpos.position].file
                            ]
                      : DEFAULT RECORD
            FROM inputvalues;
    }
    ELSE
    {
      STRING linkbase;
      IF(exportoptions.isfullexport)
        linkbase := ResolveToAbsoluteURL(GetPrimaryWebhareInterfaceURL(),"/.publisher/backend/webtools/dl.shtml");

      RETURN SELECT file := GetFileInfo(value)
                  , filelink := RecordExists(value) AND linkbase != "" ? linkbase || "?f=" || EncryptForThisServer("publisher:formupload", CELL[formresult, exportoptions.storename, value.hash]) : ""
                  , filedata := DEFAULT RECORD
               FROM inputvalues;
    }
  }
>;

PUBLIC STATIC OBJECTTYPE UploadField EXTEND FileEditFieldBase
<
>;


PUBLIC RECORD FUNCTION ParseFormUpload(RECORD fielddef, OBJECT node, RECORD parsecontext)
{
  INSERT CELL maxfiles := node->HasAttribute("maxfiles") ? ParseXSInt(node->GetAttribute("maxfiles")) : 1 INTO fielddef;
  RETURN fielddef;
}
