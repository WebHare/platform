<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";


// The publisher's moduledefinition.xml defined this namespace + tagname ("pollsettings")
// so <apply> rules can pass settings.
STRING webtoolsns := "http://www.webhare.net/xmlns/publisher/siteprofile";


/* Public API for polls */

OBJECT polltype;
OBJECT polltemplate;


OBJECTTYPE PollWebtool
<
  RECORD fileinfo;
  RECORD polldata;

  PUBLIC PROPERTY id(this->fileinfo.id, -);
  PUBLIC PROPERTY toolid(GetToolId, -);
  PUBLIC PROPERTY ismultiplechoice(this->polldata.ismultiplechoice, -); //SetMultipleChoice);
//PUBLIC PROPERTY allowvotestill(this->polldata.allowvotestill, -);


  MACRO NEW(RECORD fileinfo)
  {
    this->fileinfo := fileinfo;

    IF (NOT ObjectExists(polltype))
      polltype := OpenWHFSType("http://www.webhare.net/xmlns/publisher/pollwebtool");

    this->polldata := polltype->GetInstanceData(this->id);
    //ABORT(AnyToString(this->polldata, "tree"));
  }

  STRING FUNCTION GetToolId()
  {
    //wt=webtool
    STRING toolid := "poll:" || EncryptForThisServer("publisher:poll", [ i := this->fileinfo.id, c := this->fileinfo.creationdate ], [ algorithm := "SHA-1,BLOWFISH+CBC,0" ]);
    RETURN toolid;
  }


  /** @short Set the options for this poll
      @long  To keep an option and it's votes you must keep the GUID in it's RECORD.
             Votes for any options which doesn't exist in the new set anymore (it's GUID is not in any RECORD) will be deleted.
      @param options
      @cell  options.title
      @cell  options.guid (optional) Used to keep tracked whether options are new and to match voting statistics to the poll file.
                                     The user of the poll API might also use the GUID for their own purpose.
                                     When this cell doesn't exist or is an empty STRING an GUID is autogenerated (this is assumed the default behaviour).
  */
  PUBLIC MACRO SetOptions(RECORD ARRAY options)
  {
    this->UpdateSettings([ options := options ]);
  }

  // function instead of property setters because we need something explicit because we need an transaction
  PUBLIC MACRO UpdateSettings(RECORD settings)
  {
    BOOLEAN updatedoptions := CellExists(settings, "options");
    RECORD updatefields; // fields which will be fed to SetInstanceData

    IF (updatedoptions)
    {
      settings.options := SELECT AS RECORD ARRAY ValidateOptions(
          [ title := ""
          , guid := ""
          , hide := FALSE ], opts, [ required := ["title"] ]) FROM settings.options AS opts;

      STRING ARRAY updatedoptions_guids := SELECT AS STRING ARRAY guid
                                             FROM settings.options;

      // Enrich options which don't have a GUID yet
      // (the new options for which our called didn't specify a GUID themselves)
      UPDATE settings.options SET guid := GenerateUFS128BitId() WHERE guid = "";

      /*
      NOTE: we don't need to remove deleted options because:
            - options only exist in the database if they have been voted upon
            - if they have been voted upon we don't allow deletion (only hiding the option)
      */
      FOREVERY(RECORD option FROM settings.options)
      {
        IF (option.guid IN updatedoptions_guids)
        {
          UPDATE publisher.polloptions
            SET title := option.title // to find/restore orphaned options (which happen when a custom polledit doesn't check for voted on options or an archive extraction overwrites the poll file)
              , hide  := option.hide
          WHERE poll_fsobject = this->id
            AND guid = option.guid;
        }
      }

      this->polldata.options := settings.options;

      INSERT CELL options := settings.options INTO updatefields;
    }

    IF (CellExists(settings, "ismultiplechoice"))
    {
      this->polldata.ismultiplechoice := settings.ismultiplechoice;
      INSERT CELL ismultiplechoice := settings.ismultiplechoice INTO updatefields;
    }

    polltype->SetInstanceData(this->id, updatefields);

    // ADDME: fire an event... what would be the best nice for the event?
    //GetPrimary()->BroadcastOnCommit("publisher.webtoolspoll." || this->id, DEFAULT RECORD);

    // Return the options including the newly generated GUIDs
    //RETURN [ options := options ];
  }


  /** @short get the options of a poll (including hidden ones)
  */
  PUBLIC RECORD ARRAY FUNCTION GetOptions()
  {
    RETURN SELECT title, guid, hide FROM this->polldata.options;
  }


  /** @short get the options of a poll including how many votes each option received
             (hidden options are not returned)
  */
  PUBLIC RECORD FUNCTION GetResults() //GetOptionsWithStatistics()
  {
    RECORD ARRAY polloptions := this->GetOptions();

    INTEGER amountofvoters := Length(SELECT FROM publisher.pollvoters WHERE poll_fsobject = this->id);

    // get all relevant option entry's (which contain the total vote counts)
    RECORD ARRAY pollstats :=
        SELECT guid
             , votes
          FROM publisher.polloptions
         WHERE poll_fsobject = this->id
           AND NOT hide;
       //WHERE guid IN (SELECT AS STRING ARRAY guid FROM polldata.options);

    // Get the options from the original source (to keep the ordering) and enrich it with the votes counts
    // FIXME: do we want single-select polls percentages to add up to 100% ?
    RECORD ARRAY options :=
           SELECT TEMPORARY _votes := (SELECT AS INTEGER COLUMN votes FROM pollstats WHERE pollstats.guid = polloptions.guid)
                , title
                , guid
                , votes := _votes
                , votepercentage := amountofvoters > 0 ? INTEGER((100f * _votes / amountofvoters)+0.5) : 0 // % of responders which chose this option
             FROM polloptions
            WHERE NOT hide;

    RETURN [ toolid         := this->toolid
           , amountofvoters := amountofvoters
           , options        := options
           ];
  }


  PUBLIC RECORD FUNCTION GetWittyFields()
  {
    RECORD pollresults := this->GetResults();

    RECORD pollsettings :=
        [ allowvotingagainafter := 1440 // a day
        ];

    // Find all apply's where webtools settings are changed
    // (note: we could take the last one, but in case we will have multiple settings which can be overridden we do this instead)
    RECORD ARRAY settings := GetCustomSiteProfileSettings(webtoolsns, "pollsettings", this->fileinfo.id);
    FOREVERY(RECORD setting FROM settings)
    {
      STRING voteafter := setting.node->GetAttribute("allowvotingagainafter");
      IF (voteafter != "")
        pollsettings.allowvotingagainafter := ParseXSInt(voteafter);
    }

    /*
    ABORT([ toolid := this->fileinfo.id
          , applies := settings
          , pollsettings := pollsettings
          ]);
    */

    RETURN [ toolid           := this->toolid
           , ismultiplechoice := this->ismultiplechoice
           , amountofvoters   := pollresults.amountofvoters
           , options          := pollresults.options

           , title              := this->polldata.title
           , question           := this->polldata.question
           , messageaftervoting := this->polldata.messageaftervoting

           // pollembedinfo contains fields which are used by the poll handling code
           // Users must add the data-pollconfig attribute to ensure the poll API can function,
           // without any extra fields we add later breaking custom templates.
           , pollembedinfo      := EncodeJSON([ toolid := this->toolid
                                              , ismultiplechoice := this->ismultiplechoice
                                              , allowvotingagainafter := pollsettings.allowvotingagainafter
                                              ])
           ];
  }

  /** @short render the poll using the default template
      @param context a context (webdesign, webcontext) which provides a ->GetRTDBody() function
  */
  PUBLIC MACRO Render(OBJECT context)
  {
    IF (NOT ObjectExists(polltemplate))
      polltemplate := LoadWittyLibrary("mod::publisher/lib/webtools/internal/renderpoll.witty", "HTML-NI");

    // NOTE: we return DEFAULT FUNCTION PTR for an empty richdocument (DEFAULT RECORD)
    //       so any templates can detect those richdocuments are empty and leave out containers for those richdocuments.
    RECORD wittyfields := this->GetWittyFields();
    wittyfields :=
        SELECT *
             , question := context->GetRTDBody(this->polldata.question)
             , messageaftervoting := context->GetRTDBody(this->polldata.messageaftervoting)
          FROM [ Record(wittyfields) ];

    // FIXME: debug code
    INSERT CELL debugdata := PTR DumpValue(wittyfields, "htmltree") INTO wittyfields;

    polltemplate->RunComponent("renderpoll", wittyfields);
  }


  /** @short Cast a vote on the option with the specified optionguid.
             Callers should use a locked work around this

  FIXME: what should a CastVote in the generic API look like? (the RPC one adds ipaddress and useragent)
         Maybe some kind of origin..?

  PUBLIC STRING FUNCTION __CastVote(STRING optionguid)
  {
    INTEGER polloptionid := this->__IncrementPollOptionVoteCount(optionguid);
    INSERT INTO publisher.pollvotes
                ("option",     "when")
         VALUES (polloptionid, GetCurrentDateTime());
  }
  */


  PUBLIC INTEGER FUNCTION __IncrementPollOptionVoteCount(STRING optionguid)
  {
    RECORD polloption := SELECT * FROM publisher.polloptions WHERE COLUMN guid = VAR optionguid;
    IF (RecordExists(polloption))
    {
      IF (polloption.hide)
        THROW NEW Exception("The specified option is not available.");

      // update the votecount
      UPDATE publisher.polloptions
         SET votes := polloption.votes + 1
       WHERE poll_fsobject = this->id
             AND guid = optionguid;

      RETURN polloption.id;
    }
    ELSE
    {
      // Validate that indeed this is an option for this poll
      RECORD polldata := polltype->GetInstanceData(this->id);

      RECORD option := SELECT * FROM polldata.options WHERE COLUMN guid = VAR optionguid;
      IF (NOT RecordExists(option))
        THROW NEW Exception("The specified option does not exist.");

//abort(anytostring(polldata, "tree"));

      IF (option.hide)
        THROW NEW Exception("The specified option is not available.");

      INTEGER newid := MakeAutoNumber(publisher.polloptions, "id");

      // create a new entry with the vote count starting at 1
      INSERT INTO publisher.polloptions
                  (id,    poll_fsobject, guid,            votes)
           VALUES (newid, this->id,      optionguid, 1);

      RETURN newid;
    }
  }

  PUBLIC MACRO ResetVotes()
  {
    UPDATE publisher.polloptions SET votes := 0 WHERE poll_fsobject = this->id;
    DELETE FROM publisher.pollvoters WHERE poll_fsobject = this->id;
  }
>;


PUBLIC RECORD FUNCTION __DecodeToolId(STRING toolid)
{
  IF(toolid NOT LIKE "poll:*")
    RETURN DEFAULT RECORD;

  RETURN DecryptForThisServer("publisher:poll", Substring(toolid,5), [ fallback := DEFAULT RECORD, algorithm := "SHA-1,BLOWFISH+CBC,0" ]);
}



/** @short open the poll by it's whfsid
    @long this also allows you to open a poll which is not active anymore (in trash)
*/
PUBLIC OBJECT FUNCTION OpenPoll(INTEGER fileid)
{
  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = fileid;

  IF(NOT RecordExists(fileinfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW PollWebtool(fileinfo);
}


/** @short open the poll by it's toolid
    @param toolid ID which acts as both ID and as authorization for RPC users to access the poll
*/
PUBLIC OBJECT FUNCTION OpenPollByToolid(STRING toolid)
{
  RECORD decrypteddata := __DecodeToolId(toolid);
  IF (NOT RecordExists(decrypteddata))
    THROW NEW Exception(`Invalid poll webtool id '${toolid}'`);

  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = decrypteddata.i
                            AND creationdate = decrypteddata.c
                            AND isactive;

  IF(NOT RecordExists(fileinfo))
    THROW NEW Exception("This poll is no longer available");

  RETURN NEW PollWebtool(fileinfo);
}


// for internal use (in services.whlib)
PUBLIC OBJECT FUNCTION __OpenPollByToolid_nocheck(STRING toolid)
{
  RECORD decrypteddata := __DecodeToolId(toolid);
  IF (NOT RecordExists(decrypteddata))
    RETURN DEFAULT OBJECT;

  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = decrypteddata.i
                            AND creationdate = decrypteddata.c
                            AND isactive;

  IF(NOT RecordExists(fileinfo))
    RETURN DEFAULT OBJECT;
  ELSE
    RETURN NEW PollWebtool(fileinfo);
}
