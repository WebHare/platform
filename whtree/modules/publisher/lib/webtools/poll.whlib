<?wh
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";


STATIC OBJECTTYPE PollWebtool <
  RECORD fileinfo;
  RECORD polldata;

  PUBLIC PROPERTY id(this->fileinfo.id, -);
  PUBLIC PROPERTY toolid(GetToolId, -);
  PUBLIC PROPERTY ismultiplechoice(this->polldata.ismultiplechoice, -);
  PUBLIC PROPERTY title(this->polldata.title, -);

  MACRO NEW(RECORD fileinfo)
  {
    this->fileinfo := fileinfo;
    this->polldata := OpenWHFSType("http://www.webhare.net/xmlns/publisher/pollwebtool")->GetInstanceData(this->id);
  }

  STRING FUNCTION GetToolId()
  {
    STRING toolid := "poll:" || EncryptForThisServer("publisher:poll", [ i := this->fileinfo.id, c := this->fileinfo.creationdate ], [ algorithm := "SHA-1,BLOWFISH+CBC,0" ]);
    RETURN toolid;
  }


  /** @short Set the options for this poll
      @long  To keep an option and it's votes you must keep the GUID in it's RECORD.
             Votes for any options which doesn't exist in the new set anymore (it's GUID is not in any RECORD) will be deleted.
      @param options
      @cell  options.title
      @cell  options.guid (optional) Used to keep tracked whether options are new and to match voting statistics to the poll file.
                                     The user of the poll API might also use the GUID for their own purpose.
                                     When this cell doesn't exist or is an empty STRING an GUID is autogenerated (this is assumed the default behaviour).
  */
  PUBLIC MACRO SetOptions(RECORD ARRAY options)
  {
    this->UpdateSettings([ options := options ]);
  }

  // function instead of property setters because we need something explicit because we need an transaction
  PUBLIC MACRO UpdateSettings(RECORD settings)
  {
    settings := ValidateOptions(CELL[ options := RECORD[]
                                    , ismultiplechoice := FALSE
                                    , title := ""
                                    ], settings, [ title := "settings"
                                                 , optional := ["*"]
                                                 ]);

    BOOLEAN updatedoptions := CellExists(settings, "options");
    RECORD updatefields := PickCells(settings, ["title", "ismultiplechoice"]);

    IF (updatedoptions)
    {
      settings.options := SELECT AS RECORD ARRAY ValidateOptions(
          [ title := ""
          , guid := ""
          , hide := FALSE ], opts, [ required := ["title"] ]) FROM settings.options AS opts;

      STRING ARRAY updatedoptions_guids := SELECT AS STRING ARRAY guid
                                             FROM settings.options;

      // Enrich options which don't have a GUID yet
      // (the new options for which our called didn't specify a GUID themselves)
      UPDATE settings.options SET guid := GenerateUFS128BitId() WHERE guid = "";

      /*
      NOTE: we don't need to remove deleted options because:
            - options only exist in the database if they have been voted upon
            - if they have been voted upon we don't allow deletion (only hiding the option)
      */
      FOREVERY(RECORD option FROM settings.options)
      {
        IF (option.guid IN updatedoptions_guids)
        {
          UPDATE publisher.polloptions
            SET title := option.title // to find/restore orphaned options (which happen when a custom polledit doesn't check for voted on options or an archive extraction overwrites the poll file)
              , hide  := option.hide
          WHERE poll_fsobject = this->id
            AND guid = option.guid;
        }
      }

      INSERT CELL options := settings.options INTO updatefields;
    }

    OpenWHFSType("http://www.webhare.net/xmlns/publisher/pollwebtool")->SetInstanceData(this->id, updatefields);
    this->polldata := CELL[...this->polldata, ...updatefields];
  }


  /** @short get the options of a poll (including hidden ones)
      @cell(boolean) options.gethiddenoptions Return hidden options too
  */
  PUBLIC RECORD ARRAY FUNCTION GetOptions(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ gethiddenoptions := FALSE ], options);
    RETURN SELECT title, guid, hide
             FROM this->polldata.options
            WHERE VAR options.gethiddenoptions ? TRUE : hide = FALSE;
  }


  /** @short get the options of a poll including how many votes each option received
             (hidden options are not returned)
  */
  PUBLIC RECORD FUNCTION GetResults() //GetOptionsWithStatistics()
  {
    RECORD ARRAY polloptions := this->GetOptions();
    INTEGER amountofvoters := Length(SELECT FROM publisher.pollvoters WHERE poll_fsobject = this->id);

    // get all relevant option entry's (which contain the total vote counts)
    RECORD ARRAY pollstats :=
        SELECT guid
             , votes
          FROM publisher.polloptions
         WHERE poll_fsobject = this->id
           AND NOT hide;
       //WHERE guid IN (SELECT AS STRING ARRAY guid FROM polldata.options);

    // Get the options from the original source (to keep the ordering) and enrich it with the votes counts
    // FIXME: do we want single-select polls percentages to add up to 100% ?
    RECORD ARRAY options :=
           SELECT TEMPORARY _votes := (SELECT AS INTEGER COLUMN votes FROM pollstats WHERE pollstats.guid = polloptions.guid)
                , title
                , guid
                , votes := _votes
                , votepercentage := amountofvoters > 0 ? INTEGER((100f * _votes / amountofvoters)+0.5) : 0 // % of responders which chose this option
             FROM polloptions
            WHERE NOT hide;

    RETURN [ amountofvoters := amountofvoters
           , options        := options
           ];
  }


  PUBLIC RECORD FUNCTION GetWittyFields() {
    RECORD pollresults := this->GetResults();

    RECORD pollsettings := [ revote_after := "P1D" ]; //a day
    FOREVERY(RECORD poll FROM GetYamlPluginSettings(this->fileinfo.id, "pollSettings"))
      pollsettings := CELL[...pollsettings, ...poll]; // merge all settings, later settings override earlier ones

    ParseISO8601Duration(pollsettings.revote_after); //just to validate

    RETURN [ toolid           := this->toolid
           , ismultiplechoice := this->ismultiplechoice
           , amountofvoters   := pollresults.amountofvoters
           , options          := pollresults.options

           , title              := this->polldata.title
           , question           := this->polldata.question
           , messageaftervoting := this->polldata.messageaftervoting

           // pollembedinfo contains fields which are used by the poll handling code
           // Users must add the data-pollconfig attribute to ensure the poll API can function,
           // without any extra fields we add later breaking custom templates.
           , pollembedinfo      := EncodeJSON([ toolid := this->toolid
                                              , ismultiplechoice := this->ismultiplechoice
                                              , revote_after := pollsettings.revote_after
                                              ])
           ];
  }

  /** @short render the poll using the default template
      @param context a context (webdesign, webcontext) which provides a ->GetRTDBody() function
  */
  PUBLIC MACRO Render(OBJECT context)
  {
    // NOTE: we return DEFAULT FUNCTION PTR for an empty richdocument (DEFAULT RECORD)
    //       so any templates can detect those richdocuments are empty and leave out containers for those richdocuments.
    RECORD wittyfields := this->GetWittyFields();
    wittyfields :=
        SELECT *
             , question := context->GetRTDBody(this->polldata.question)
             , messageaftervoting := context->GetRTDBody(this->polldata.messageaftervoting)
          FROM [ Record(wittyfields) ];

    EmbedWittyComponent("mod::publisher/lib/webtools/internal/renderpoll.witty:renderpoll", wittyfields);
  }


  INTEGER FUNCTION IncrementPollOptionVoteCount(STRING optionguid)
  {
    RECORD polloption := SELECT * FROM publisher.polloptions WHERE COLUMN guid = VAR optionguid;
    IF (RecordExists(polloption))
    {
      IF (polloption.hide)
        THROW NEW Exception("The specified option is not available.");

      // update the votecount
      UPDATE publisher.polloptions
         SET votes := polloption.votes + 1
       WHERE poll_fsobject = this->id
             AND guid = optionguid;

      RETURN polloption.id;
    }
    ELSE
    {
      // Validate that indeed this is an option for this poll
      RECORD option := SELECT * FROM this->polldata.options WHERE COLUMN guid = VAR optionguid;
      IF (NOT RecordExists(option))
        THROW NEW Exception("The specified option does not exist.");

      IF (option.hide)
        THROW NEW Exception("The specified option is not available.");

      INTEGER newid := MakeAutoNumber(publisher.polloptions, "id");

      // create a new entry with the vote count starting at 1
      INSERT INTO publisher.polloptions
                  (id,    poll_fsobject, guid,            votes)
           VALUES (newid, this->id,      optionguid, 1);

      RETURN newid;
    }
  }

  PUBLIC MACRO ResetVotes()
  {
    UPDATE publisher.polloptions SET votes := 0 WHERE poll_fsobject = this->id;
    DELETE FROM publisher.pollvoters WHERE poll_fsobject = this->id;
  }

  /** @short Cast a vote on the option with the specified optionguid.
      @cell(string) options.voterid If set, prevent duplicate votes from this user/voter (will be hashed into the database) */
  PUBLIC RECORD FUNCTION CastVote(STRING ARRAY optionguids, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ ipaddress := ""
                                   , useragent := ""
                                   , voterid := ""
                                   ], options);
    IF(NOT HavePrimaryTransaction() OR GetPrimary()->IsWorkOpen())
      THROW NEW Exception("Voting requires a primary transaction without open work");

    IF (Length(optionguids) = 0)
      THROW NEW Exception("(we don't allow blank votes)");

    // ADDME: test whether voting is allowed
    //        (poll active, voting open, voting closedate not reached yet, ...)

    IF (NOT this->ismultiplechoice AND Length(optionguids) > 1)
      THROW NEW Exception("Casting multiple votes is only allow for multiple choice polls.");

    // Make sure the selected options are unique (to prevent )
    STRING ARRAY uniqueoptionguids := SELECT AS STRING ARRAY DISTINCT(guid) FROM ToRecordArray(optionguids, "guid");
    IF (Length(optionguids) != Length(uniqueoptionguids))
      THROW NEW Exception("Duplicate optionguids specified");

    GetPrimary()->BeginLockedWork("publisher:webtools_poll." || this->id);

    STRING idhash;
    IF(options.voterid != "")
    {
      /* We add the id of this poll to the hash to make it a slight bit harder to correlate votes. However until we offer
         an option to eliminate ipadress/useragent from the votelog there will be an easy correlation there, so we realize
         this has its limitations (even without considering correlation through accesslogs or that the 'voterid' search space
         is likely small enough to brute force). */
      idhash := GetHashForString(this->id || "." || options.voterid, "SHA-256");
      IF(RecordExists(SELECT FROM publisher.pollvoters WHERE poll_fsobject = this->id AND pollvoters.idhash = VAR idhash))
      {
        GetPrimary()->RollbackWork();
        RETURN [ success := FALSE, errorcode := "alreadyvoted" ];
      }
    }

    INTEGER pollvoterid  := MakeAutoNumber(publisher.pollvoters, "id");

    INSERT CELL[ id := pollvoterid
               , poll_fsobject := this->id
               , when := GetCurrentDateTime()
               , options.ipaddress
               , useragent := LimitUTF8Bytes(options.useragent, 512)
               , idhash
               ] INTO publisher.pollvoters;

    FOREVERY(STRING optionguid FROM optionguids)
    {
      INTEGER polloptionid := this->IncrementPollOptionVoteCount(optionguid);
      INSERT CELL[ voter := pollvoterid
                 , option := polloptionid
                 ] INTO publisher.pollvotes;
    }
    GetPrimary()->CommitWork();

    RETURN [ success := TRUE ];
  }
>;


RECORD FUNCTION DecodeToolId(STRING toolid)
{
  IF(toolid NOT LIKE "poll:*")
    RETURN DEFAULT RECORD;

  RETURN DecryptForThisServer("publisher:poll", Substring(toolid,5), [ fallback := DEFAULT RECORD, algorithm := "SHA-1,BLOWFISH+CBC,0" ]);
}



/** @short open the poll by it's whfsid
    @long this also allows you to open a poll which is not active anymore (in trash)
*/
PUBLIC OBJECT FUNCTION OpenPoll(INTEGER fileid)
{
  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = fileid;

  IF(NOT RecordExists(fileinfo))
    RETURN DEFAULT OBJECT;

  RETURN NEW PollWebtool(fileinfo);
}


/** @short open the poll by it's toolid
    @param toolid ID which acts as both ID and as authorization for RPC users to access the poll
*/
PUBLIC OBJECT FUNCTION OpenPollByToolid(STRING toolid)
{
  RECORD decrypteddata := DecodeToolId(toolid);
  IF (NOT RecordExists(decrypteddata))
    THROW NEW Exception(`Invalid poll webtool id '${toolid}'`);

  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = decrypteddata.i
                            AND creationdate = decrypteddata.c
                            AND isactive;

  IF(NOT RecordExists(fileinfo))
    THROW NEW Exception("This poll is no longer available");

  RETURN NEW PollWebtool(fileinfo);
}


// for internal use (in services.whlib)
PUBLIC OBJECT FUNCTION __OpenPollByToolid_nocheck(STRING toolid)
{
  RECORD decrypteddata := DecodeToolId(toolid);
  IF (NOT RecordExists(decrypteddata))
    RETURN DEFAULT OBJECT;

  RECORD fileinfo := SELECT id, creationdate
                       FROM system.fs_objects
                      WHERE id = decrypteddata.i
                            AND creationdate = decrypteddata.c
                            AND isactive;

  IF(NOT RecordExists(fileinfo))
    RETURN DEFAULT OBJECT;
  ELSE
    RETURN NEW PollWebtool(fileinfo);
}
