<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ooxml/spreadsheet.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::internal/enrichment.whlib";
LOADLIB "wh::util/comparisons.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/support.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/whfs/drafts.whlib";

LOADLIB "mod::publisher/lib/dialogs.whlib";
LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/internal/tollium-helpers.whlib";
LOADLIB "mod::publisher/lib/internal/versioning/helpers.whlib";
LOADLIB "mod::publisher/lib/internal/versioning/support.whlib";
LOADLIB "mod::publisher/tolliumapps/filemanager/inspect.whlib";


// By default, show version events within the last 30 days
INTEGER default_history_range := 30;

STRING FUNCTION GetNameFromFullpath(STRING fullpath)
{
  IF (fullpath = "")
    RETURN GetTid("publisher:tolliumapps.versioning.deleted");
  INTEGER pos := SearchLastSubString(fullpath, "/");
  RETURN SubString(fullpath, pos + 1);
}

RECORD ARRAY FUNCTION GetModifications(INTEGER versionevent)
{
  OBJECT whfs_draftmetadata := OpenWHFSType("http://www.webhare.net/xmlns/publisher/draftmetadata");
  RECORD sel :=
      SELECT *
        FROM system.fs_versionevents
       WHERE id = versionevent;

  IF (NOT RecordExists(sel))
    RETURN DEFAULT RECORD ARRAY;

  // Always use the request to see differences (the apply stores the version AFTER the apply)
  IF (sel.previousrequest != 0)
  {
    sel :=
        SELECT *
          FROM system.fs_versionevents
         WHERE id = sel.previousrequest;
  }
  RECORD draft_metadata := whfs_draftmetadata->GetInstanceData(sel.draft_object);
  RECORD draft_data :=
     SELECT *
       FROM system.fs_objects
      WHERE id = sel.draft_object;
  // Get last applied live version before this event
  RECORD org_version :=
      SELECT *
        FROM system.fs_versionevents
       WHERE live_object = sel.live_object
         AND when < sel.when
         AND eventtype = VersionEventType_AcceptApply
    ORDER BY when DESC;
  RECORD org_data, org_metadata;
  IF (RecordExists(org_version))
  {
    org_metadata := whfs_draftmetadata->GetInstanceData(org_version.draft_object);
    org_data := SELECT * FROM system.fs_objects WHERE id = org_version.draft_object;
  }
  ELSE
  {
    org_metadata := draft_metadata;
    org_metadata.flags := (org_metadata.flags BITAND BITNEG DraftFlag_Publish);
    org_data := draft_data;
  }
  // Overwrite the 'name' and 'parent' fields from the drafts
  draft_data := MakeReplacedRecord(draft_data, draft_metadata);
  org_data := MakeReplacedRecord(org_data, org_metadata);
  // Calculate 'published' field to get the policy for the original object
  INTEGER org_published := org_metadata.flags BITAND DraftFlag_Publish != 0
      ? ConvertToWillPublish(0, FALSE, TRUE, PubPrio_DirectEdit)
      : 0;

  THROW NEW Exception("This function is uncallable"); //FIXME
}


MACRO InspectPolicy(OBJECT parent, INTEGER versioningevent, INTEGER siteid)
{
  INTEGER live_id  := SELECT AS INTEGER live_object FROM system.fs_versionevents WHERE id = versioningevent;
  INTEGER draft_id := SELECT AS INTEGER draft_object FROM system.fs_versionevents WHERE id = versioningevent;
  THROW NEW Exception("This function is uncallable"); //FIXME
}

PUBLIC OBJECTTYPE Main EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT site;

  OBJECT policy;

  /** @cell screentitle
      @cell canreview
      @cell customlists
  */
  RECORD configdata;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->site := OpenSiteByName(data.sitename);
    IF (NOT ObjectExists(this->site))
      THROW NEW Exception(`Could not open site '${data.sitename}'`);
    THROW NEW Exception(`No versioning policy for '${data.sitename}' - is versioning enabled ?`);

    this->configdata := this->policy->GetReviewAppConfig(
        [ controller := this->tolliumcontroller
        , sitename :=   data.sitename
        ]);

    this->filterfrom->value := AddDaysToDate(-default_history_range, GetCurrentDatetime());
    this->frame->flags.canreview := this->configdata.canreview;
    this->frame->flags.issysop := this->tolliumuser->HasRight("system:sysop");
    this->frame->title := this->configdata.screentitle;

    this->whichlist->options := this->whichlist->options CONCAT
        SELECT rowkey := "custom-" || #customlists
             , title
          FROM this->configdata.customlists;

    this->listener->masks := [ "system:versionevent." || this->site->id || ".*" ];

    this->UpdateActionState();

    this->listmultirowbtn->pressed := this->actionlist->rowlayout != "";
    this->listsinglerowbtn->pressed := this->actionlist->rowlayout = "";

  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotVersioningEvents(RECORD ARRAY events)
  {
    this->actionlist->Invalidate();
  }

  MACRO OnWhichListChange()
  {
    this->actionlist->ReloadList();
  }

  MACRO OnFilterDateChange()
  {
    this->actionlist->ReloadList();
  }

  PUBLIC MACRO OnMessage(RECORD message)
  {
    IF(CellExists(message, "goto_id"))
    {
      /// In which list?
      IF(NOT CellExists(message, "inlist") OR message.inlist NOT IN [ "otherrequests", "myrequests", "allrequests", "recentlyreviewed", "recentlyoffline" ])
        RETURN;

      this->whichlist->value := message.inlist;
      this->OnWhichListChange();
      IF(message.goto_id NOT IN SELECT AS INTEGER ARRAY draft_object FROM this->actionlist->rows)
        RETURN;
      ELSE
      {
        RECORD toselect := SELECT * FROM this->actionlist->rows WHERE draft_object = message.goto_id;
        toselect.tolliumselected := TRUE;
        this->actionlist->selection := toselect;
      }
    }
  }

  MACRO OnSelectRequest()
  {
    this->ReloadRequestOverview();

    RECORD sel := this->actionlist->selection;
    STRING previewlink;
    IF(RecordExists(sel))
      ^previewbrowser->SetPreview(sel.live_object, [ contentfile := sel.draft_object]);
    ELSE
      ^previewbrowser->SetPreviewURL("");
  }

  // ---------------------------------------------------------------------------
  //
  // List reload
  //

  RECORD ARRAY FUNCTION GetFiles(INTEGER ARRAY ids, BOOLEAN leftouterjoin, BOOLEAN matchcase)
  {
    RETURN
        SELECT __joinid :=    id
             , id
             , isfolder
             , type
             , title
             , isactive
          FROM system.fs_objects
         WHERE id IN ids;
  }

  RECORD ARRAY FUNCTION GetActionListChildren(RECORD parentrow)
  {
    INTEGER siteid := this->site->id;
    RECORD ARRAY files;
    RECORD datefilters;
    IF (this->filterfrom->value != DEFAULT DATETIME)
      INSERT CELL from_date := GetRoundedDateTime(this->filterfrom->value, 24*60*60*1000) INTO datefilters;
    IF (this->filterto->value != DEFAULT DATETIME)
      INSERT CELL to_date := GetRoundedDateTime(AddDaysToDate(1, this->filterto->value), 24*60*60*1000) INTO datefilters;

    IF (this->whichlist->value LIKE "custom-*")
    {
      INTEGER listid := ToInteger(Substring(this->whichlist->value, 7), -1);
      IF (listid >= 0 AND listid < LENGTH(this->configdata.customlists))
        files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters, this->configdata.customlists[listid].filter));
    }
    ELSE
    {
      BOOLEAN sortascending := TRUE;
      SWITCH (this->whichlist->value)
      {
        CASE "otherrequests"
        {
          // All pending request for this user to review
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ iscurrent :=            TRUE
              , eventtypes :=           [ VersionEventType_Request ]
              , filter_user :=          this->tolliumuser->authobjectid
              , filter_user_negative := TRUE
              ]));
        }

        CASE "myrequests"
        {
          sortascending := FALSE;

          // All historic requests by this user (pending/processed)
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ eventtypes :=           [ VersionEventType_Request ]
              , filter_user :=          this->tolliumuser->authobjectid
              , toreturn :=             "requestresult"
              ]));
        }

        CASE "allrequests"
        {
          // All pending requests
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ iscurrent :=            TRUE
              , eventtypes :=           [ VersionEventType_Request ]
              ]));
        }

        CASE "recentlypublishedapproved"
        {
          sortascending := FALSE;

          // All processed requests
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ eventtypes :=           [ VersionEventType_AcceptApply ]
              , newpublished :=         "published"
              ]));
        }

        CASE "recentlydenied"
        {
          sortascending := FALSE;

          // All processed requests
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ eventtypes :=           [ VersionEventType_FinalDenial ]
              ]));
        }

        CASE "recentlyoffline"
        {
          sortascending := FALSE;

          // All requests that resulted in a file no longer being published (publish state changed to false or deletion of
          // published file)
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ eventtypes :=           [ VersionEventType_AcceptApply ]
              , newpublished :=         "nonpublished"
              ]));
        }

        CASE "expiring"
        {
          DATETIME now := GetCurrentDatetime();

          // All requests that resulted in a file no longer being published (publish state changed to false or deletion of
          // published file)
          files := RetrieveSiteVersioningEvents(siteid, MakeMergedRecord(datefilters,
              [ iscurrent :=            TRUE
              , eventtypes :=           [ VersionEventType_AcceptApply ]
              , max_expirydate :=       AddMonthsToDate(this->configdata.reviewperiodmonths, now)
              , toreturn :=             "current"
              ]));

          DATETIME soon_expire := AddDaysToDate(this->configdata.warnexpiringdays, now);

          files :=
              SELECT *
                   , when :=    expirydate
                   , style :=   expirydate < now
                                    ? "expired"
                                    : expirydate < soon_expire
                                        ? "expiring"
                                        : ""
                FROM files;
        }

        CASE ""
        {
          // Run at initialization, don't show files
        }

        DEFAULT
        {
          THROW NEW Exception(`Unhandled list type '${this->whichlist->value}'`);

        }

      }

      this->actionlist->sortascending := sortascending;
    }

    // Check which files have an open request for approval.
    INTEGER ARRAY locked_files := this->policy->GetApprovalRequestedObjects(SELECT AS INTEGER ARRAY live_object FROM files);

    files :=
        SELECT rowkey :=    id
             , when
             , live_object
             , draft_object
             , user
             , comment
             , fs_site
             , issite :=          id = siteid //ADDME: versionevent.id = this->site->id?
             , isowner :=         user = this->tolliumuser->authobjectid
             , isopenrequest :=   eventtype = VersionEventType_Request AND finished = DEFAULT DATETIME
             , hasopenrequest :=  live_object IN locked_files
             , eventtype
             , name :=            GetNameFromFullpath(eventtype = VersionEventType_AcceptApply ? (newfullpath ?? orgfullpath) : (orgfullpath ?? newfullpath))
             , versionnumber
             , expirydate
             , ordering
             , style :=           CellExists(files, "STYLE") ? style : ""
          FROM files;

    files := ExecuteEnrichment(files, "LIVE_OBJECT", DEFAULT RECORD, PTR this->GetFiles, DEFAULT FUNCTION PTR);
    files := this->contexts->userapi->EnrichUsers("USER", files, [ celltype := "authobjectid", rightouterjoin := TRUE ]);

    RETURN
        SELECT TEMPORARY enriched := EnrichFSObject(files)
             , *
             , filetypeicon :=  this->actionlist->GetIcon(enriched.pvt_iconname)
             , actionicon :=    [ 5, 3, 4 ][eventtype]
          FROM files;
  }

  // ---------------------------------------------------------------------------
  //
  //
  //

  STRING FUNCTION FormatExpiryDate(DATETIME date)
  {
    IF (date = MAX_DATETIME)
      RETURN this->GetTid(".expiresnever");

    RETURN this->tolliumuser->FormatDateTime(date, "minutes", TRUE, FALSE);
  }

  MACRO ReloadRequestOverview()
  {
    this->changespart->visible := /*this->whichlist->value = "requests" AND*/ this->actionlist->value != 0;
    IF (NOT this->changespart->visible)
      RETURN;

    RECORD sel := this->actionlist->selection;
    RECORD ARRAY previous_events :=
        SELECT ordering
             , expirydate
             , versionnumber
             , eventtype
          FROM system.fs_versionevents
         WHERE live_object = sel.live_object
           AND ordering < sel.ordering
      ORDER BY ordering DESC;

    DATETIME prev_expirydate :=
        SELECT AS DATETIME expirydate
          FROM previous_events
         WHERE eventtype = VersionEventType_AcceptApply;

    this->requestdescription->value := sel.comment;
    this->requestversionnumber->value := sel.versionnumber;
    this->requestexpirydate->value := this->FormatExpiryDate(sel.expirydate);
    this->previousexpirydate->value := this->FormatExpiryDate(prev_expirydate ?? MAX_DATETIME);
    this->modifications->rows := GetModifications(sel.rowkey);
  }

  MACRO UpdateActionState()
  {
    IF (NOT this->frame->flags.canreview)
    {
      this->accept_menu->disablemode := "hidden";
      this->accept_ctx->disablemode := "hidden";
      this->accept_btn->visible := FALSE;
      this->deny_menu->disablemode := "hidden";
      this->deny_ctx->disablemode := "hidden";
      this->deny_btn->visible := FALSE;

      DELETE FROM this->whichlist->options WHERE rowkey = "otherrequests";
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoToggleFilter()
  {
    this->filterbar->visible := NOT this->filterbar->visible;
    this->listfilterbtn->pressed := this->filterbar->visible;
  }

  MACRO DoFilelistSingleRow()
  {
    this->actionlist->rowlayout := "";
    this->listmultirowbtn->pressed := this->actionlist->rowlayout != "";
    this->listsinglerowbtn->pressed := this->actionlist->rowlayout = "";
  }

  MACRO DoFilelistMultiRow()
  {
    this->actionlist->rowlayout := "tworows";
    this->listmultirowbtn->pressed := this->actionlist->rowlayout != "";
    this->listsinglerowbtn->pressed := this->actionlist->rowlayout = "";
   }

  MACRO DoAccept()
  {
    this->LoadScreen(".acceptchange", [ draftobject := OpenWHFSDraft(this->actionlist->selection.draft_object) ])->RunModal();
  }

  MACRO DoDeny()
  {
    this->LoadScreen(".denychange", [ draftobject := OpenWHFSDraft(this->actionlist->selection.draft_object) ])->RunModal();
  }

  MACRO DoHistory()
  {
    RECORD data :=
        [ liveobject := OpenWHFSObject(this->actionlist->selection.live_object)
        , filterfrom := this->filterfrom->value
        , filterto := this->filterto->value
        ];
    OBJECT screen := this->LoadScreen(".history", data);
    IF (screen->RunModal() != "ok")
      RETURN;
  }

  MACRO DoToggleList()
  {
    this->dasecondlist->rowlayout := (this->dasecondlist->rowlayout = "singlerow") ? "tworows" : "singlerow";
  }

  MACRO DoInspectPolicy()
  {
    InspectPolicy(this, this->actionlist->selection.rowkey, this->actionlist->selection.fs_site);
  }

  MACRO DoCancelRequest()
  {
    IF(this->RunMessageBox(".surecancelrequest") != "yes")
      RETURN;

    OBJECT work := this->BeginWork();
    CancelApprovalRequestForDraft(OpenWHFSDraft(this->actionlist->selection.draft_object));
    work->Finish();
    this->actionlist->Invalidate();
  }

  MACRO OnDrop(RECORD dragdata, RECORD droptarget, STRING droptype, STRING dropaction)
  {
    FOREVERY (RECORD item FROM dragdata.items)
    {
      IF (RecordExists(droptarget))
        UPDATE this->droptarget->rows
           SET num := num + 1
             , stuff := item.data.stuff || " (" || (num + 1) || ")"
         WHERE rowkey = droptarget.rowkey;
      ELSE
        INSERT [ stuff := item.data.stuff, num := 1 ] INTO this->droptarget->rows AT END;
    }
  }

  MACRO DoUndelete()
  {
    OBJECT live_object := OpenWHFSObject(this->actionlist->selection.live_object);

    DoVersionedRestoreInternal(this, this->site->root, this->policy, this->configdata, live_object);
  }

  MACRO DoOpenInApp()
  {
    OBJECT live_object := OpenWHFSObject(this->actionlist->selection.live_object);
    IF (live_object->isactive)
      this->configdata.openfileinapp(this, live_object->id);
  }

  MACRO DoExport()
  {
    this->LoadScreen(".exportevents", [ site := this->site ])->RunModal();
  }
>;

PUBLIC OBJECTTYPE History EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  INTEGER siteid;

  OBJECT liveobject;

  OBJECT historyextcomp;
  OBJECT policy;

  RECORD configdata;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    IF (CellExists(data, "filterfrom"))
      this->filterfrom->value := data.filterfrom;
    ELSE
      this->filterfrom->value := AddDaysToDate(-default_history_range, GetCurrentDatetime());
    IF (CellExists(data, "filterto"))
      this->filterto->value := data.filterto;

    this->liveobject := data.liveobject;

    this->Refresh();
    this->frame->flags.issysop := this->tolliumuser->HasRight("system:sysop");
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotVersioningEvents(RECORD ARRAY events)
  {
    this->Refresh();
  }

  // ---------------------------------------------------------------------------
  //
  // List fills
  //

  MACRO Refresh()
  {
    DATETIME from_date := this->filterfrom->value;
    DATETIME to_date := this->filterto->value;
    IF (from_date != DEFAULT DATETIME)
      from_date := GetRoundedDateTime(from_date, 24*60*60*1000);
    IF (to_date != DEFAULT DATETIME)
      to_date := GetRoundedDateTime(AddDaysToDate(1, to_date), 24*60*60*1000);
    ELSE
      to_date := MAX_DATETIME;

    RECORD ARRAY rows :=
        SELECT rowkey :=    fs_versionevents.id
             , when
             , icon :=      [ 8, 1, 7 ][eventtype]
             , icon2 :=     0
             , user
             , filename :=  GetNameFromFullpath(eventtype = VersionEventType_AcceptApply ? (newfullpath ?? orgfullpath) : (orgfullpath ?? newfullpath))
             , comment
             , live_object
             , draft_object
             , fs_site
             , isactive
             , versionnumber
          FROM system.fs_versionevents
             , system.fs_objects
         WHERE fs_objects.id = live_object
               AND fs_objects.id = this->liveobject->id;

    // Need the siteid from versionevents, so filter on dates after this query
    this->siteid := SELECT AS INTEGER fs_site FROM rows WHERE fs_site != 0;
    rows := SELECT * FROM rows WHERE when >= from_date AND when < to_date;

    THROW NEW Exception("This function is uncallable"); //FIXME
  }

  MACRO OnSelectRequest()
  {
    RECORD sel := this->versionevents->selection;
    STRING previewlink;
    IF (RecordExists(sel))
    {
      this->requestdescription->value := sel.comment;
      this->modifications->rows := GetModifications(sel.rowkey);

      IF (ObjectExists(this->historyextcomp))
        this->historyextcomp->ViewHistoryForDraft(sel.draft_object);
      ^previewbrowser->SetPreview(sel.live_object, [ contentfile := sel.draft_object]);
    }
    ELSE
    {
      this->requestdescription->value := "";
      this->modifications->rows := DEFAULT RECORD ARRAY;
      IF (ObjectExists(this->historyextcomp))
        this->historyextcomp->ViewHistoryForDraft(0);
      this->previewbrowser->SetPreviewURL("");
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoInspectPolicy()
  {
    InspectPolicy(this, this->versionevents->selection.rowkey, this->versionevents->selection.fs_site);
  }

  MACRO DoCreateCopy()
  {
    STRING orgname := this->versionevents->selection.filename;
    RECORD restoredata;

    OBJECT draftobject := OpenWHFSDraft(this->versionevents->selection.draft_object);
    OBJECT draft_fsobject := draftobject->fsobject;

    IF (this->configdata.getrestorelocation != DEFAULT FUNCTION PTR)
    {
      restoredata := this->configdata.getrestorelocation(this, draft_fsobject,
          [ orgname :=    orgname
          ]);

      IF (NOT RecordExists(restoredata))
        RETURN;
    }
    ELSE
    {
      INTEGER target := RunBrowseForFSObjectDialog(this, [ acceptfiles := FALSE
                                                         , showreadonly := TRUE
                                                         , title := this->GetTid(".createhistorycopy")
                                                         , description := this->GetTid(".createhistorycopydescr")
                                                         ]);

      IF (target = 0)
        RETURN;

      restoredata :=
          [ parent :=   target
          , name :=     OpenWHFSObject(target)->GenerateUniqueName(orgname)
          ];
    }

    OBJECT work := this->BeginUnvalidatedWork();

    OBJECT targetobj := OpenWHFSObject(restoredata.parent);
    OBJECT live_object := OpenWHFSObject(this->versionevents->selection.live_object);

    // Copy the live object, disable publication
    OBJECT copy := live_object->CopyTo(targetobj, restoredata.name);
    copy->UpdateMetadata([ publish := FALSE ]);

    RECORD restorefields := this->policy->GetRestoreFields();

    ApplyDraftByVersionedFields(draftobject, restorefields, [ target := copy, applyreadonlyfields := TRUE ]);

    IF (work->Finish())
    {
      this->LoadScreen(".objectcopied",
            [ configdata := this->configdata
            , targetobj := targetobj
            , name := restoredata.name
            ])->RunModal();
    }
  }

  MACRO DoRestoreContent()
  {
    RECORD sel := this->versionevents->selection;

    RECORD options;
    IF (NOT this->versionevents->selection.isactive)
    {
      STRING orgname := GetNameFromPath(sel.filename);
      RECORD restoredata;

      IF (this->configdata.getrestorelocation != DEFAULT FUNCTION PTR)
      {
        OBJECT draftobject := OpenWHFSDraft(sel.draft_object);
        restoredata := this->configdata.getrestorelocation(this, draftobject->fsobject,
            [ orgname :=    orgname
            ]);

        IF (NOT RecordExists(restoredata))
          RETURN;
      }
      ELSE
      {
        INTEGER target := RunBrowseForFSObjectDialog(this, [ acceptfiles := FALSE
                                                           , showreadonly := TRUE
                                                           , title := this->GetTid(".undelete")
                                                           , description := this->GetTid(".undeletedescription")
                                                           , roots := INTEGER[this->siteid]
                                                           ]);
        IF(target = 0)
          RETURN;

        restoredata :=
            [ parent :=   target
            , name :=     OpenWHFSObject(target)->GenerateUniqueName(orgname)
            ];
      }

      options :=
          [ updates :=          restoredata
          , modifypublished :=  PTR ConvertToWontPublish
          ];
    }

    OBJECT draftobject := OpenWHFSDraft(sel.draft_object);
    HandleVersionRestore(this, this->policy, draftobject, options);
    this->Refresh();
  }
>;

PUBLIC OBJECTTYPE AcceptChange EXTEND TolliumScreenBase
<
  OBJECT draft;

  MACRO Init(RECORD data)
  {
    this->draft := data.draftobject;
    IF (NOT this->GetExclusiveAccess([ id := this->draft->source ]))
      RETURN;
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();

    AcceptApprovalRequestForDraft(this->draft,
        [ userobject :=   this->tolliumuser
        , message :=      this->description->value
        ]);

    RETURN work->Finish();
  }
>;

PUBLIC OBJECTTYPE DenyChange EXTEND TolliumScreenBase
<
  OBJECT draft;

  MACRO Init(RECORD data)
  {
    this->draft := data.draftobject;
    IF (NOT this->GetExclusiveAccess([ id := this->draft->source ]))
      RETURN;
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();

    DenyApprovalRequestForDraft(this->draft,
        [ userobject :=   this->tolliumuser
        , message :=      this->description->value
        ]);

    RETURN work->Finish();
  }
>;

PUBLIC OBJECTTYPE DiffView EXTEND TolliumScreenBase
<
  RECORD data;

  MACRO Init(RECORD data)
  {
    this->textdiff->value := data.diff;
    this->data := data;
    this->FillDiffArray();
    this->FillRequestArray();
    this->requestdescription->value := SELECT AS STRING comment FROM system.fs_versionevents WHERE id = data.event;
    this->modifications->rows := GetModifications(data.event);
  }

  MACRO FillDiffArray()
  {
    RECORD ARRAY outrows;
    FOREVERY(RECORD type FROM this->data.diffarray)
    {
      OBJECT typeinfo := OpenWHFSType(type.namespace);
      RECORD instance_left, instance_right;
      RECORD ARRAY leftside, rightside;
      IF(ObjectExists(typeinfo))
      {
        instance_left := typeinfo->GetInstanceData(this->data.fsobject);
        instance_right := typeinfo->GetInstanceData(this->data.fsdraft);
        leftside := UnpackCTYPEToDBInfoRows(typeinfo, 0, this->tolliumuser, instance_left, typeinfo->id || ".left", TRUE, FALSE);
        rightside := UnpackCTYPEToDBInfoRows(typeinfo, 0, this->tolliumuser, instance_right, typeinfo->id || ".right", TRUE, FALSE);
      }
      ELSE
      {
        instance_left := SELECT * FROM system.fs_objects WHERE id = this->data.fsobject;
        instance_right := SELECT * FROM system.fs_objects WHERE id = this->data.fsdraft;
        leftside := UnpackToDBInfoRows(this->tolliumuser, [ instance_left ], "base-left.", FALSE, FALSE);
        rightside := UnpackToDBInfoRows(this->tolliumuser, [ instance_right ], "base-right.", FALSE, FALSE);
      }
      RECORD entry :=  [ name := type.namespace
                       , rowkey := ToString(type.type)
                       , subnodes := DEFAULT RECORD ARRAY
                       , data := ""
                       , expanded := ObjectExists(typeinfo)/// Favor instance data
                       , canedit := FALSE
                       , candownload := FALSE
                       , type := "diff"
                       ];
      FOREVERY(RECORD diff FROM type.diff)
      {
        RECORD fieldinfo :=  [ name := diff.field
                             , rowkey := type.namespace || "." || diff.field
                             , subnodes := DEFAULT RECORD ARRAY
                             , data := ""
                             , expanded := FALSE
                             , canedit := FALSE
                             , candownload := FALSE
                             , type := "field"
                             ];
        RECORD leftfield := SELECT * FROM leftside WHERE ToUpperCase(name) = ToUpperCase(diff.field);
        fieldinfo.name := leftfield.name;/// This one has nice casing, whereas the version we have is uppercase
        leftfield.name := "Left (original)";
        RECORD rightfield := SELECT * FROM rightside WHERE ToUpperCase(name) = ToUpperCase(diff.field);
        rightfield.name := "Right (updated)";

        fieldinfo.subnodes := [ leftfield, rightfield ];

        INSERT fieldinfo INTO entry.subnodes AT END;
      }
      INSERT entry INTO outrows AT END;
    }
    this->arraydiff->rows := outrows;
  }

  MACRO FillRequestArray()
  {
    RECORD request :=  [ name := "system.fs_versionevents"
                       , rowkey := "versioningevent." || this->data.event
                       , subnodes := UnpackToDBInfoRows(this->tolliumuser, (SELECT * FROM system.fs_versionevents WHERE id = this->data.event), "versionevent.", FALSE, FALSE)
                       , data := ToString(this->data.event)
                       , expanded := FALSE
                       , canedit := FALSE
                       , candownload := FALSE
                       , type := "table row"
                       ];
    RECORD published :=  [ name := "system.fs_objects (published)"
                         , rowkey := "fsobject." || this->data.fsobject
                         , subnodes := UnpackToDBInfoRows(this->tolliumuser, (SELECT * FROM system.fs_objects WHERE id = this->data.fsobject), "liveobject.", FALSE, FALSE)
                         , data := ToString(this->data.fsobject)
                         , expanded := FALSE
                         , canedit := FALSE
                         , candownload := FALSE
                         , type := "table row"
                         ];
    RECORD draft :=  [ name := "system.fs_objects (draft)"
                     , rowkey := "fsobject." || this->data.fsdraft
                     , subnodes := UnpackToDBInfoRows(this->tolliumuser, (SELECT * FROM system.fs_objects WHERE id = this->data.fsdraft), "draftobject.", FALSE, FALSE)
                     , data := ToString(this->data.fsdraft)
                     , expanded := FALSE
                     , canedit := FALSE
                     , candownload := FALSE
                     , type := "table row"
                     ];
    this->versionrequest->rows := [ request, published, draft ];
  }

  MACRO DoShowPolicy()
  {
    this->RunMessageBox(".genericinfobox", this->data.policy->name);
  }

  MACRO DoInspectFSObject()
  {
    this->LoadScreen("mod::publisher/tolliumapps/filemanager/inspect.xml#inspect", [ fsobj := this->data.fsobject ])->RunModal();
  }

  MACRO DoShowPolicyInfo()
  {
    RETURN;/// Irrelevant now, might however become useful again in future iterations of the policy code
  }

  MACRO DoShowVersionedFields()
  {
    RECORD info := this->data.policyfields;/// readonly_fields, versioned_contenttypes, versioned_fields
    OBJECT file := OpenWHFSObject(this->data.fsobject);
    INTEGER type_id := file->type;
    RECORD typed;
    RECORD relevant := [ readonly := info.readonly_fields, instancedata := this->GetVersionedInstanceFields(info.versioned_contenttypes), base_fields := info.versioned_fields ];
    OBJECT screen := this->LoadScreen(".fieldsview", relevant);
    screen->frame->title := "Versioned fields for \"" || file->name || "\"";
    screen->RunModal();
  }

  RECORD ARRAY FUNCTION GetVersionedInstanceFields(INTEGER ARRAY versioned)
  {
    RECORD ARRAY outrows;
    RECORD ARRAY types := SELECT fs_type,id FROM system.fs_instances WHERE fs_object = this->data.fsobject AND fs_type IN versioned;
    FOREVERY(RECORD typ FROM types)
    {
      OBJECT typeinfo := OpenWHFSTypeById(typ.fs_type);
      RECORD instance := typeinfo->GetInstanceData(this->data.fsobject);
      INSERT [ name := typeinfo->namespace
             , rowkey := ToSTring(typ.fs_type)
             , subnodes := UnpackCTYPEToDBInfoRows(typeinfo, 0, this->tolliumuser, instance, typ.fs_type || ".", TRUE, FALSE)
             , data := ToString(typ.id)
             , expanded := TRUE/// expand top level
             , canedit := FALSE
             , candownload := FALSE
             , type := "whfs instance"
            ] INTO outrows AT END;

    }
    RETURN outrows;
  }

  BOOLEAN FUNCTION Submit()
  {
    RETURN TRUE;
  }
>;

PUBLIC OBJECTTYPE FieldsView EXTEND TolliumScreenBase
<
  MACRO Init(RECORD data)
  {
    RECORD ARRAY base_fields := ToRecordArray(data.base_fields, "name");
    this->basefields->rows := SELECT rowkey := #base_fields, name FROM base_fields;
    RECORD ARRAY readonly_fields := ToRecordArray(data.readonly, "name");
    this->readonlyfields->rows := SELECT rowkey := #readonly_fields, name FROM readonly_fields;
    this->contenttypes->rows := data.instancedata;// SELECT *, rowkey := #fields FROM data.instancedata.fields;
  }

  BOOLEAN FUNCTION Submit()
  {
    RETURN TRUE;
  }
>;

PUBLIC OBJECTTYPE ObjectCopied EXTEND TolliumScreenBase
<
  INTEGER fileid;
  RECORD configdata;

  MACRO Init(RECORD data)
  {
    this->configdata := data.configdata;
    this->objectcopiedto->value := this->GetTid(".objectcopiedto", data.name);
    this->fileid := data.targetobj->OpenByName(data.name)->id;
  }

  MACRO DoOpenInApp()
  {
    this->configdata.openfileinapp(this, this->fileid);
  }
>;

PUBLIC OBJECTTYPE ExportEvents EXTEND TolliumScreenBase
<
  OBJECT site;

  MACRO Init(RECORD data)
  {
    this->site := data.site;
  }

  BOOLEAN FUNCTION Submit()
  {
    RECORD ARRAY matching_events :=
        SELECT id
             , previousrequest
          FROM system.fs_versionevents
         WHERE fs_site = this->site->id
           AND when >= this->tolliumuser->LocalToUTC(this->fromdate->value)
           AND (this->todate->value = MAX_DATETIME
                  ? TRUE
                  : when < AddDaysToDate(1, this->tolliumuser->LocalToUTC(this->todate->value)));

    OBJECT whfs_draftmetadata := OpenWHFSType("http://www.webhare.net/xmlns/publisher/draftmetadata");

    // Get ids of all selected events here
    INTEGER ARRAY ids := SELECT AS INTEGER ARRAY id FROM matching_events;

    // Also get the ids of the referred requests
    INTEGER ARRAY prev_events := SELECT AS INTEGER ARRAY previousrequest FROM matching_events WHERE previousrequest != 0;

    // so now, we have all requests that are referred to in the matching period
    ids := GetSortedSet(ids CONCAT prev_events);

    // get the events referring to those requests too
    INTEGER ARRAY referring_event_ids := SELECT AS INTEGER ARRAY id FROM system.fs_versionevents WHERE previousrequest IN ids;
    ids := GetSortedSet(ids CONCAT referring_event_ids);

    RECORD ARRAY allevents :=
        SELECT id
             , when
             , previousrequest
             , eventtype
             , live_object
             , draft_object
             , user
             , comment
             , versionnumber
             , expirydate
             , newflags
             , fs_site
             , orgfullpath
             , orgurl
             , isdelete
             , newfullpath
             , newurl
          FROM system.fs_versionevents
         WHERE id IN ids
      ORDER BY ordering DESC;

    allevents := this->contexts->userapi->EnrichUsers("USER", allevents,
        [ celltype :=         "authobjectid"
        , rightouterjoin :=   TRUE
        ]);

    allevents := whfs_draftmetadata->Enrich(allevents, "DRAFT_OBJECT", [ "FLAGS" ], [ rightouterjoin := TRUE ]);

    RECORD ARRAY requests :=
        SELECT *
          FROM allevents
         WHERE eventtype = VersionEventType_Request;

    // Get the last event (highest ordering) for every request
    RECORD ARRAY finals :=
        SELECT id :=          previousrequest
             , finalevent :=  Any(allevents)
          FROM allevents
         WHERE previousrequest != 0
      GROUP BY previousrequest
      ORDER BY previousrequest;

    requests := JoinArrays(
        requests,
        "ID",
        finals,
        [ finalevent :=
              [ when :=           DEFAULT DATETIME
              , eventtype :=      -1
              , user :=           ""
              , comment :=        ""
              , versionnumber :=  ""
              , expirydate :=     DEFAULT DATETIME
              , newflags :=       0
              , displayname :=    ""
              , email :=          ""
              ]
        ],
        [ rightouterjoin := TRUE
        ]);

    STRING str_deleted := GetTid("publisher:versioning.export.deleted");
    STRING str_restored := GetTid("publisher:versioning.export.restored");
    STRING str_published := GetTid("publisher:versioning.export.published");
    STRING str_nonpublished := GetTid("publisher:versioning.export.nonpublished");
    STRING str_accepted := GetTid("publisher:versioning.export.accepted");
    STRING str_denied := GetTid("publisher:versioning.export.denied");
    STRING str_pending := GetTid("publisher:versioning.export.pending");

    RECORD ARRAY rows :=
        SELECT TEMPORARY old_publish_str := (flags BITAND DraftFlag_WasPublished) = 0 ? str_nonpublished : str_published
             , TEMPORARY new_publish_str := (newflags BITAND DraftFlag_Publish) = 0 ? str_nonpublished : str_published
             , TEMPORARY final_expirydate := finalevent.expirydate ?? expirydate
             , request_id :=              id
             , request_fileid :=          live_object
             , request_when :=            when
             , request_user :=            displayname
             , request_user_email :=      email
             , request_comment :=         comment
             , request_versionnumber :=   versionnumber
             , request_expirydate :=      final_expirydate = MAX_DATETIME ? DEFAULT DATETIME : final_expirydate
             , request_newflags :=        newflags
             , request_orgfullpath :=     orgfullpath ?? str_deleted
             , request_orgurl :=          orgurl
             , request_newfullpath :=     newfullpath ?? str_deleted
             , request_newurl :=          newurl
             , response_when :=           finalevent.when
             , response_eventtype :=      finalevent.eventtype
             , response_user :=           finalevent.displayname
             , response_user_email :=     finalevent.email
             , response_comment :=        finalevent.comment
             , response_versionnumber :=  finalevent.versionnumber
             , response_expirydate :=     finalevent.expirydate
             , response_newflags :=       finalevent.newflags
             , flags
             , live_object
             , draft_object
             , publishstatus :=           old_publish_str = new_publish_str
                                              ? old_publish_str
                                              : old_publish_str || ' -> ' || new_publish_str
             , location :=                orgfullpath ?? newfullpath
             , locationstatus :=          orgfullpath = ""
                                              ? str_restored
                                              : newfullpath = ""
                                                  ? str_deleted
                                                  : orgfullpath != newfullpath
                                                      ? "-> " || newfullpath
                                                      : ""
             , responsestatus :=          finalevent.eventtype = -1
                                              ? str_pending
                                              : finalevent.eventtype = VersionEventType_AcceptApply
                                                    ? str_accepted
                                                    : finalevent.eventtype = VersionEventType_FinalDenial
                                                        ? str_denied
                                                        : "???"
          FROM requests
      ORDER BY when;

    OBJECT sheet := NEW XLSXColumnFileWriter;
    sheet->columns :=
        [ [ name :=   "request_when",           title := GetTid("publisher:versioning.export.request_when"),            type := "datetime", precision := "minutes", storeutc := TRUE ]
        , [ name :=   "location",               title := GetTid("publisher:versioning.export.location"),                type := "text" ]
        , [ name :=   "locationstatus",         title := GetTid("publisher:versioning.export.locationstatus"),          type := "text" ]
        , [ name :=   "request_fileid",         title := GetTid("publisher:versioning.export.request_fileid"),          type := "integer" ]
        , [ name :=   "publishstatus",          title := GetTid("publisher:versioning.export.publishstatus"),           type := "text" ]
        , [ name :=   "request_versionnumber",  title := GetTid("publisher:versioning.export.request_versionnumber"),   type := "text" ]
        , [ name :=   "request_user_email",     title := GetTid("publisher:versioning.export.request_user_email"),      type := "text" ]
        , [ name :=   "request_user",           title := GetTid("publisher:versioning.export.request_user"),            type := "text" ]
        , [ name :=   "request_comment",        title := GetTid("publisher:versioning.export.request_comment"),         type := "text" ]
        , [ name :=   "request_expirydate",     title := GetTid("publisher:versioning.export.request_expirydate"),      type := "date", storeutc := TRUE ]
        , [ name :=   "response_when",          title := GetTid("publisher:versioning.export.response_when"),           type := "datetime", precision := "minutes", storeutc := TRUE ]
        , [ name :=   "responsestatus",         title := GetTid("publisher:versioning.export.responsestatus"),          type := "text" ]
        , [ name :=   "response_versionnumber", title := GetTid("publisher:versioning.export.response_versionnumber"),  type := "text" ]
        , [ name :=   "response_user_email",    title := GetTid("publisher:versioning.export.response_user_email"),     type := "text" ]
        , [ name :=   "response_user",          title := GetTid("publisher:versioning.export.response_user"),           type := "text" ]
        , [ name :=   "response_comment",       title := GetTid("publisher:versioning.export.response_comment"),        type := "text" ]
        ];
    sheet->timezone := "CET";
    sheet->WriteRows(rows);

    RECORD output := WrapBlob(sheet->MakeOutputFile(), GetSafeFileName("versionevent-export-" || this->site->name || ".xlsx"));

    this->frame->SendFileToUser(output.data, output.mimetype, output.filename, GetCurrentDateTime());
    RETURN TRUE;
  }

>;

PUBLIC MACRO DoVersionedRestoreInternal(OBJECT parentscreen, INTEGER siteroot, OBJECT policy, RECORD configdata, OBJECT live_object)
{
  RECORD lastevent := GetLastVersionApplyEvent(live_object->id);
  STRING restore_name := GetNameFromPath(lastevent.orgfullpath);

  RECORD restoredata;
  IF (configdata.getrestorelocation != DEFAULT FUNCTION PTR)
  {
    restoredata := configdata.getrestorelocation(parentscreen, live_object,
        [ orgname :=    restore_name
        ]);

    IF (NOT RecordExists(restoredata))
      RETURN;
  }
  ELSE
  {
    STRING path := GetDirectoryFromPath(lastevent.orgfullpath);

    OBJECT targetfolder := OpenSite(siteroot)->rootobject;
    IF (path != "/")
    {
      // Need to remove the leading / from the slash to get a relative path
      targetfolder := targetfolder->OpenByPath(SubString(path, 1)) ?? targetfolder;
    }

    INTEGER target := RunBrowseForFSObjectDialog(parentscreen,
        [ acceptfiles := FALSE
        , showreadonly := TRUE
        , title := GetTid("publisher:tolliumapps.versioning.undelete")
        , description := GetTid("publisher:tolliumapps.versioning.undeletedescription")
        , roots := INTEGER[siteroot]
        , folder := targetfolder->id
        ]);

    IF (target = 0)
      RETURN;

    restoredata :=
        [ parent :=   target
        , name :=     OpenWHFSObject(target)->GenerateUniqueName(restore_name)
        ];
  }

  RECORD feedbackdata := GetSubmitRequestApprovalMetadata(parentscreen, live_object);
  IF (NOT RecordExists(feedbackdata))
    RETURN;

  OBJECT work := parentscreen->BeginWork([validate := OBJECT[], mutex := `publisher:publishstate.${live_object->id}`]);

  UpdateMetadataForPolicy(
      policy,
      live_object,
      restoredata,
      [ modifypublished := PTR ConvertToWontPublish ]);

  SubmitApprovalRequestFromMetadata(work, live_object, feedbackdata);
  IF (work->Finish())
    parentscreen->RunMessageBox("mod::publisher/tolliumapps/versioning/versioning.xml#undeletesubmitted", restoredata.name);
}
