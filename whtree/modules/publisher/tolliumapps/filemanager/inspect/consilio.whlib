<?wh

LOADLIB "wh::ipc.whlib";

LOADLIB "mod::consilio/lib/pagelists.whlib";
LOADLIB "mod::consilio/lib/screens/catalog.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::tollium/lib/dialogs.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::publisher/lib/internal/consiliocontent.whlib";
LOADLIB "mod::publisher/lib/internal/consiliohandler.whlib";

PUBLIC RECORD ARRAY FUNCTION GetSubFiles(INTEGER objid)
{
  OpenPrimary();

  RECORD objinfo := SELECT parent FROM system.fs_objects WHERE id = objid;
  IF(NOT RecordExists(objinfo))
    RETURN RECORD[];

    RETURN GetSearchSubfiles((SELECT id, type, isfolder, modificationdate, parent FROM system.fs_objects WHERE id = objid), FALSE).subfiles;
}

PUBLIC RECORD ARRAY FUNCTION GetPageList(INTEGER objid)
{
  OpenPrimary();

  RETURN SELECT link, modificationdate, title, consiliofields FROM GetConsilioPagesForFile(objid);
}


PUBLIC STATIC OBJECTTYPE ConsilioTab EXTEND TolliumFragmentBase
<
  INTEGER objid;
  OBJECT fsobj;
  RECORD ARRAY subfiles;
  OBJECT subfilespromise;
  OBJECT pagelistpromise;

  PUBLIC MACRO Setup(INTEGER objid)
  {
    this->objid := objid;
  }
  PUBLIC MACRO Refresh(OBJECT fsobj)
  {
    this->fsobj := fsobj;
    this->RefreshSubFiles();
    this->RefreshConsilioPagelist(FALSE);
  }

  MACRO DoReindex()
  {
    RECORD ARRAY results := ReindexWHFSChanges([[ id := this->objid
                                                , isfolder := this->fsobj->isfolder
                                                , isdelete := FALSE
                                                ]]);

    /* We receive errorinfo in a nonstandard format (string, no trace).. we should
      probably fix THAT and ensure we get standard HS exceptions/traces before bothering
      with nicer display here */
    IF(Length(results) > 0 AND Length(results[0].result.errors) > 0)
      Reflect(results[0]);

    this->Refresh(this->fsobj);
  }
  MACRO DoInspectConsilio()
  {
    IF(NOT RunConsilioInspectDialog(this, whconstant_consilio_catalog_whfs, "", ^subfile->selection.groupid))
      this->owner->RunSimpleScreen("error", this->GetTid(".cannotinspectconsilio"));
  }

  ASYNC MACRO RefreshSubFiles()
  {
    IF (ObjectExists(this->subfilespromise))
      RETURN;

    this->subfiles := RECORD[];
    this->subfilespromise := AsyncCallFunctionFromJob(Resolve("#GetSubFiles"), this->objid);
    TRY
    {
      this->subfiles := AWAIT this->subfilespromise;

      IF(Length(this->subfiles) > 0)
      {
        ^subfile->options := SELECT rowkey := #subfiles
                                  , title := (RecordExists(subfiles) ? filename : "") || " (#" || #subfiles || ")"
                                  , groupid := "fsobj_" || this->objid || (#subfiles > 0 ? "_" || #subfiles: "")
                               FROM this->subfiles;
      }
      ELSE
      {
        ^subfile->options := [[ rowkey := 0, title := this->GetTid(".nosearchinfo"), groupid := "fsobj_" || this->objid ]];
      }
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      ^subfile->options := [[ rowkey := 0, title := this->GetTid(".searchinfoerror"), groupid := "fsobj_" || this->objid ]];
      RunExceptionReportDialog(this, e);
    }
    FINALLY
    {
      this->subfilespromise := DEFAULT OBJECT;
    }

    ^subfile->readonly := Length(^subfile->options) = 1;
  }

  MACRO OnSubfileChange()
  {
    RECORD matchfile := ^subfile->value < Length(this->subfiles) ? this->subfiles[^subfile->value] : DEFAULT RECORD;
    IF(RecordExists(matchfile))
      ^subfilecontent->blobvalue := matchfile.data;
    ELSE
      ^subfilecontent->blobvalue := DEFAULT BLOB;
  }

  MACRO DoRefreshPageList()
  {
    this->RefreshConsilioPagelist(TRUE);
  }

  ASYNC MACRO RefreshConsilioPagelist(BOOLEAN interactive)
  {
    IF(ObjectExists(this->pagelistpromise)) //already running
      RETURN; //ignore (or cancel running promise?)

    ^pagelist->rows := RECORD[];
    ^pagelist->empty := this->GetTid(".refreshingpagelist");
    this->pagelistpromise := AsyncCallFunctionFromJob(Resolve("#GetPagelist"), this->objid);
    TRY
    {
      RECORD ARRAY pages := AWAIT this->pagelistpromise;
      ^pagelist->empty := "";
      ^pagelist->rows := SELECT rowkey := link, url := link, modificationdate, title FROM pages;
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      ^pagelist->empty := this->GetTid(".refreshingpagelisterror");
      IF(interactive)
        RunExceptionReportDialog(this, e);
    }
    FINALLY
    {
      this->pagelistpromise := DEFAULT OBJECT;
    }
  }


>;
