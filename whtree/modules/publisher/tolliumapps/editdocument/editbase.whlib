<?wh

LOADLIB "wh::javascript.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::publisher/lib/history.whlib";
LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/internal/tollium-helpers.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::system/lib/whfs.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";
LOADLIB "mod::tollium/lib/yamlcomponents.whlib";

RECORD FUNCTION GetRecycledObjectInfo(OBJECT whuser, INTEGER objectid)
{
  RECORD res;

  RECORD historyinfo := SELECT * FROM system.fs_history WHERE fs_history.type = whconstant_historytype_recycled AND fs_history.fs_object = objectid ORDER BY when DESC;
  IF(NOT RecordExists(historyinfo))
    RETURN DEFAULT RECORD;

   RETURN [ deletionuser := historyinfo.user
          , deletiondate := historyinfo.when
          , origlocation := historyinfo.currentparent
          , originalpath := (SELECT AS STRING whfspath FROM system.fs_objects WHERE id=historyinfo.currentparent)
          , origname :=     historyinfo.currentname
          ];
}

PUBLIC STATIC OBJECTTYPE FieldScope EXTEND YamlScope
<
  OBJECT editor;
  RECORD controller;

  MACRO NEW(OBJECT editor, RECORD controller)
  {
    this->editor := editor;
    this->controller := controller;
  }
  UPDATE PUBLIC OBJECT FUNCTION ResolveComponentRef(OBJECT forcomp, STRING name)
  {
    IF(name LIKE "$type.*")
    {
      STRING ARRAY toks := Tokenize(name, '.');
      OBJECT match := this->controller.fsinstance->GetComponent(ToSnakeCase(toks[1]));
      IF(NOT ObjectExists(match))
      {
        STRING ARRAY availablerefs := SELECT AS STRING ARRAY ToCamelCase(compname) FROM ToRecordArray(this->controller.fsinstance->GetComponents(),'compname');
        THROW NEW TolliumException(forcomp, `No such field '${toks[1]}' available in type '${this->controller.type->namespace}'. Available: ${Detokenize(availablerefs, ', ')}`);
      }
      IF(Length(toks) > 2)
        THROW NEW TolliumException(forcomp, `No subfield support yet`);
      RETURN match;
    }
    RETURN YamlsCope::ResolveComponentRef(forcomp, name);
  }
>;

// Base class for ObjectProperties and the Document Editor. Preparing to share common code with objectprops
PUBLIC STATIC OBJECTTYPE PublisherEditorBase EXTEND TolliumScreenBase <
  /// Id of edited object, 0 for new or duplicate objects
  INTEGER itemid;

  // Metatabs renderer
  OBJECT renderer;
  /// Record definition of current (or new) type for the object
  RECORD curtype;
  /// Can the name follow the title?
  BOOLEAN namefollowstitle;
  // Metatabs config as received from describeMetaTabsForHS
  RECORD metatabsconfig;
  // Controllers for the metadata. For now we'll rely on compositions
  PUBLIC RECORD ARRAY metacontrollers;
  /// Whether to assume the user has write access (often used by editdocument into otherwise locked/hidden folders)
  BOOLEAN assumewriteaccess;
  /// Whether the edited object is in the recycle bin, and if so, what the original name etc was
  RECORD recyclebininfo;
  /// If the user only has read-only access to this file (fs_browse)
  BOOLEAN readonly;
  /// Whether the edited (or new) object is a folder
  BOOLEAN isfolder;
  /// Whether the object is a new object. It may already live in the user's autosave folder! (TODO EditProps may need to be careful when *actually* requesting props in the /webhare-private/ folder? or just not activate meta apply rules there)
  BOOLEAN isnew;
  /// Parent folder of the new/edited object
  OBJECT parentfolder;

  RECORD basesettings;

  /// Are we objectprops? some tweaks will be done
  BOOLEAN isobjectprops;
  /// Workflow editor settings, if any
  RECORD workfloweditor;

  /** Active propery extensions ('legacy tabs')
      @cell(string) name Name of the property editor
      @cell(object) Node XML node (&lt;extendproperties&gt;)
      @cell(object) siteprof Siteprofile object
      @cell(object array) components
      @cell(object) fragment Fragment object (only when it extends PropertyEditorBase)
      @cell(boolean) islegacypropertyeditor
      @cell(object) instance Instance object for tab extensions
  */
  RECORD ARRAY extendprops;

  OBJECT workflowmgr;

  MACRO NEW(BOOLEAN isobjectprops) {
    this->isobjectprops := isobjectprops;
  }

  MACRO RefreshReadonly()
  {
    BOOLEAN setreadonly := this->workflowmgr->IsReadOnly();
    this->readonly := setreadonly;
    this->OnReadonlyChange();
  }

  BOOLEAN FUNCTION CanWriteCurrentItem()
  {
    RETURN this->isnew OR (NOT RecordExists(this->recyclebininfo) AND this->tolliumuser->HasRightOn("system:fs_fullaccess", this->itemid));
  }

  MACRO OnReadonlyChange()
  {
    this->RefreshMetaTabsReadonly();
  }

  MACRO SetupBaseSettings()
  {
    this->basesettings := GetBaseProperties(this->contexts->applytester);

    ^name->title := this->isfolder ? GetTid("~foldername") : GetTid("~filename");
    ^description->visible := this->basesettings.description;
    ^keywords->visible := this->basesettings.keywords;
    ^isunlisted->visible := this->basesettings.isunlisted;
    ^title->required := this->basesettings.requiretitle;

    IF(this->namefollowstitle) {
      ^title->onchange := PTR this->SyncNameWithTitle;
      this->SyncNameWithTitle();
    }

    //FIXME restore seotabrequireright. see objectprops.whlib
    BOOLEAN needstemplate := this->isfolder ? FALSE : this->contexts->applytester->IsTypeNeedsTemplate();
    //As these are published, only files that go through a webdesign can show something useful
    ^seotitle->visible := needstemplate AND this->basesettings.seotitle;

    //TODO generalize further so metadata.ts also managed SEO settings
    this->renderer->RegisterMetaController(^webmetadata->type, ^webmetadata);
  }

  RECORD FUNCTION UpdatePinned()
  {
    //Do not honor 'pinned' for new objects... then it should apply only AFTER we finalize the dialog. Also ensures valid-whfsname validation still happens
    BOOLEAN pinned := (^pinobject->value OR RecordExists(this->recyclebininfo)) AND NOT this->isnew;
    BOOLEAN parentfullaccess := this->tolliumuser->HasRightOn("system:fs_fullaccess", this->parentfolder->id);

    ^name->enabled := NOT pinned AND parentfullaccess AND NOT this->readonly;

    RETURN CELL [pinned, parentfullaccess];
  }

  MACRO SetupEditBaseForExistingObject(INTEGER objectid, RECORD options) {
    BOOLEAN isfolder := SELECT AS BOOLEAN COLUMN isfolder FROM system.fs_objects WHERE id = VAR objectid;
    this->__SetupEditBase(objectid, 0, isfolder, -1, options);
  }

  MACRO SetupEditBaseForNewObject(INTEGER parent, BOOLEAN isfolder, INTEGER type) {
    this->isnew := TRUE;
    // ^title->required := TRUE; //as we don't go through LoadBaseData we need to set this ourselves
    this->__SetupEditBase(0, parent, isfolder, type, DEFAULT RECORD);
  }

  MACRO __SetupEditBase(INTEGER objectid, INTEGER parent, BOOLEAN isfolder, INTEGER type, RECORD options) {
    this->isnew := objectid = 0;

    options := ValidateOptions(CELL[ readonly := FALSE
                                   , useworkflow := FALSE
                                   , assumewriteaccess := FALSE
                                   , workflowtypes := STRING[]
                                  ], options);

    this->renderer := CreateMetatabsRenderer(CELL[ objectid, parent, isfolder, type, this->isobjectprops ]);
    this->metatabsconfig := this->renderer->metatabsconfig;
    this->workfloweditor := RecordExists(this->metatabsconfig) ? this->metatabsconfig.workfloweditor : DEFAULT RECORD;
    this->contexts->applytester := this->renderer->applytester;

    //We currently need this->parentfolder to be set so we can run UpdatePinned which will be triggered below by ^pinobject->value :=
    this->parentfolder := this->contexts->applytester->objparent = 0 ? OpenWHFSRootObject() : OpenWHFSObject(this->contexts->applytester->objparent);

    RECORD objinfo;
    IF(objectid != 0) {
      objinfo := SELECT COLUMN type, ispinned FROM system.fs_objects WHERE id = VAR objectid;
      ^pinobject->value := objinfo.ispinned;
      type := objinfo.type;
    }
    this->curtype := DescribeContentTypeById(type, CELL[ isfolder, mockifmissing := TRUE ]);
    this->namefollowstitle := type != whconstant_whfstype_foreignfolder AND (isfolder OR this->curtype.ispublishedassubdir);

    STRING ARRAY workflowtypes := STRING[ "platform:web.config", "platform:web.metadata", ...options.workflowtypes ];

    this->contexts->applytester := this->renderer->applytester;

    IF(objectid != 0) {
      IF(options.useworkflow AND RecordExists(this->renderer->metatabsconfig)) {
         //add the metacontroller requested types to the type edit list
        FOREVERY(RECORD t FROM this->renderer->metatabsconfig.types)
          INSERT t.namespace INTO workflowtypes AT END;
        FOREVERY(RECORD t FROM this->renderer->metatabsconfig.extend_props)
          INSERT t.whfs_type INTO workflowtypes AT END;
      }

      this->workflowmgr := NEW WorkflowManager(objectid,
        CELL[ user := this->contexts->user
            , ...options
            , workflowtypes := options.useworkflow ? workflowtypes : STRING[]
            ]);
    }

    this->itemid := objectid;
    this->SetupBaseSettings();
    this->assumewriteaccess := options.assumewriteaccess;
  }

  MACRO DoInspectMetaTabs() {
    Reflect(this->renderer->metatabsconfig);
  }

  STRING FUNCTION GetSuggestedSlug() {
    //FIXME don't select from database, we should just load this info at startup. we need it for the titlebar anyway
    RETURN ^title->value != "" ? SuggestSeoNameFromTitle(^title->value) : SELECT AS STRING name FROM system.fs_objects WHERE id = this->itemid;;
  }

  MACRO SyncNameWithTitle()  {
    ^name->placeholder := this->GetSuggestedSlug();
    //TODO can Tollium control the refresh button's visibility based on title set/not set ?
    ^refreshnamebutton->visible := ^title->value != "";
  }

  MACRO DoRefreshName() {
    ^name->value := this->GetSuggestedSlug();
  }

  MACRO RefreshMetaTabsReadonly()
  {
    this->renderer->SetControllersEnabled(NOT this->readonly);

    // objectprops is not allowed to edit workflow fields when editing existing files which have a true workflow (and document editor)
    BOOLEAN edit_workflow_metadata := this->isnew OR NOT RecordExists(this->workfloweditor) OR NOT this->isobjectprops;
    BOOLEAN needstemplate := this->isfolder ? FALSE : this->contexts->applytester->IsTypeNeedsTemplate();
    //As these are published, only files that go through a webdesign can show something useful
    ^seotitle->visible := needstemplate AND this->basesettings.seotitle AND edit_workflow_metadata;
    ^title->enabled := NOT this->readonly AND ^title->visible AND edit_workflow_metadata;
    ^isunlisted->enabled := NOT this->readonly AND ^isunlisted->visible AND edit_workflow_metadata;
    ^description->enabled := NOT this->readonly AND ^description->visible AND edit_workflow_metadata;
    ^keywords->enabled := NOT this->readonly AND ^keywords->visible AND edit_workflow_metadata;
    this->UpdatePinned();
  }

  MACRO LoadBaseData(OBJECT sourceobject) {
    //TODO instead of a sourceobject hack perhaps workflowmgr should handle recycle bin too?
    //TODO we might be overcomplicating by sharing LoadBaseData and then checking workflow settings.
    this->recyclebininfo := MemberExists(sourceobject, 'whfspath') AND IsRecycleBinWHFSPath(sourceobject->whfspath) ? GetRecycledObjectInfo(this->contexts->user, sourceobject->id) : DEFAULT RECORD;

    RECORD metadata := sourceobject->GetMetadata();
    ^name->value := metadata.name;
    ^title->value := metadata.title;
    ^keywords->value := metadata.keywords;
    ^description->value := metadata.description;
  }

  MACRO LoadMetadata(OBJECT sourceobject, BOOLEAN isduplicate) {
    // Read current contenttype from (source)file or use default (in case of a new file)
    // If this is a duplication action we must only read data if cloneoncopy hasn't been set to FALSE
    FOREVERY(RECORD controller FROM this->renderer->metacontrollers)
      IF(NOT (isduplicate AND NOT controller.type->Cloneoncopy))
        controller.fsinstance->value := sourceobject->GetInstanceData(controller.type->namespace);

    FOREVERY(RECORD extendprop FROM this->extendprops)
      IF(NOT (isduplicate AND NOT extendprop.whfsinstance->type->cloneoncopy)) {
        extendprop.whfsinstance->value := sourceobject->GetInstanceData(extendprop.whfsinstance->type->namespace);
      }
  }

  RECORD FUNCTION GetMetadata() {
    RECORD metadata;

    IF(^title->enabled)
      INSERT CELL title := ^title->value INTO metadata;
    IF(^description->enabled)
      INSERT CELL description := ^description->value INTO metadata;
    IF(^keywords->enabled)
      INSERT CELL keywords := ^keywords->value INTO metadata;
    IF(^isunlisted->enabled)
      INSERT CELL isunlisted := ^isunlisted->value INTO metadata;
    IF(ObjectExists(this->workflowmgr) AND this->workflowmgr->useworkflow)
      INSERT CELL name := ^name->value INTO metadata;

    RETURN metadata;
  }

  MACRO SaveMetadata(INTEGER targetobject) { //editdocument will always be invoking us with a draft as parameter
    OBJECT target := ObjectExists(this->workflowmgr) AND this->workflowmgr->useworkflow ? this->workflowmgr : OpenWHFSObject(targetobject);

    //FIXME ensure any specific validation rule *and* all valueConstraints are honored
    FOREVERY(RECORD controller FROM this->renderer->metacontrollers)
    {
      //broken fields (eg due to incompatible data/vaueConstraints) should be able to opt out, IsUpdateValue ?
      target->SetInstanceData(controller.type->namespace, controller.fsinstance->GetUpdateValue());
    }
    FOREVERY(RECORD extendprop FROM this->extendprops)
      target->SetInstanceData(extendprop.whfsinstance->type->namespace, extendprop.whfsinstance->GetUpdateValue());

    RECORD metadata := this->GetMetadata();
    IF(RecordExists(metadata))
      target->UpdateMetadata(metadata);
  }

  MACRO CheckNameConflict(OBJECT work) {

    IF(this->itemid != 0 AND RecordExists(SELECT FROM system.sites WHERE id = this->itemid)) { //it's a site
      STRING name := ^name->value ?? ^name->placeholder;

      // check for site conflict - do this first as even moving the site won't fix it
      OBJECT othersite := OpenSiteByName(name);
      IF(ObjectExists(othersite) AND othersite->id != this->itemid) {
        work->AddError(GetTid("publisher:common.errors.sitealreadyexists", name));
        RETURN;
      }
    }

    IF(^name->value != "") {
      // Test for an object with the same name at the target location
      OBJECT otherobject := this->parentfolder->OpenByName(^name->value);
      IF (ObjectExists(otherobject) AND otherobject->id != this->itemid) {
        BOOLEAN hiddenforme := IsObjectHiddenForMe(GetEffectiveUser(), otherobject->id);
        IF(hiddenforme)
          work->AddError(GetTid("publisher:common.errors.hiddenfolderexists", ^name->value, this->parentfolder->name));
        ELSE
          work->AddError(GetTid("publisher:common.errors.fileorfolderexists", ^name->value, this->parentfolder->name));

        RETURN;
      }
    }
  }

  PUBLIC INTEGER FUNCTION __GetTargetId()
  {
    RETURN this->isnew ? 0 : this->itemid;
  }

  /////////////////////////////////////////////////////////
  // Extend props (legacy tabs)

  /// Marks all siteprofile extension components as readonly
  MACRO MarkSiteProfileExtensionsReadonly() {
    FOREVERY(RECORD propeditor FROM this->extendprops)
      FOREVERY(OBJECT comp FROM propeditor.components)
        comp->readonly := TRUE;
  }

  /// Disables all siteprofile extension components as readonly
  MACRO MarkSiteProfileExtensionsDisabled() {
    FOREVERY(RECORD propeditor FROM this->extendprops)
      FOREVERY(OBJECT comp FROM propeditor.components)
        comp->enabled := FALSE;
  }

>;

PUBLIC STATIC OBJECTTYPE MetatabsRenderer <
  // Metatabs config as received from describeMetaTabsForHS
  PUBLIC RECORD metatabsconfig;

  // Applytester for the object
  PUBLIC OBJECT applytester;

  // Controllers for the metadata. For now we'll rely on compositions
  PUBLIC RECORD ARRAY metacontrollers;

  MACRO NEW(RECORD config, OBJECT applytester) {
    this->metatabsconfig := config;
    this->applytester := applytester;
  }

  PUBLIC MACRO RegisterMetaController(OBJECT type, OBJECT composition) {
    INSERT CELL[ fsinstance := composition, type ] INTO this->metacontrollers AT END;
  }


  PUBLIC RECORD ARRAY FUNCTION PrepareTypeSections(OBJECT contexts, RECORD type, RECORD options DEFAULTSTO DEFAULT RECORD) {
    options := ValidateOptions([
      dirtylistener := DEFAULT OBJECT
    ], options);

    OBJECT fsinstance := contexts->screen->CreateTolliumComponent("record");
    RECORD controller := CELL [ fsinstance, type := OpenWHFSType(type.namespace) ];
    fsinstance->yamlscope := NEW FieldScope(fsinstance, controller);
    INSERT controller INTO this->metacontrollers AT END;
    RECORD ARRAY sections;

    FOREVERY(RECORD section FROM type.sections) {
      RECORD addsection := [ title := GetTid(section.title)
                           , fields := section.fields
                           , lines := RECORD[]
                          ];
      //TODO restore tab merging - or have metatabsconfig calculate this for us?
      FOREVERY(RECORD field FROM section.fields) {
        STRING title := GetTid(field.title);
        OBJECT newcomp := CreateYamlComponent(contexts->screen, field.component, [
          composition := fsinstance,
          cellname := field.name,
          dirtylistener := options.dirtylistener,
          yamlscope := fsinstance->yamlscope
        ]);

        STRING layout := CellExists(field, 'layout') ? field.layout : newcomp->blockelement ? "block" : "inline";
        IF(title != "" AND layout = "block") { //put it in the H1 above.
          OBJECT heading := contexts->screen->CreateTolliumComponent("heading");
          heading->title := title;
          INSERT CELL[ layout := "form", line := heading ] INTO addsection.lines AT END;
        }

        newcomp->title := (layout = "inline" ? title : "");
        newcomp->errorlabel := title;
        INSERT CELL[ layout := layout = "inline" ? "form" : "left", line := newcomp ] INTO addsection.lines AT END;
      }
      INSERT addsection INTO sections AT END;
    }
    RETURN sections;
  }

  PUBLIC MACRO RenderTypeIntoTabs(OBJECT contexts, RECORD type, OBJECT maintabs, INTEGER insertpos, RECORD options DEFAULTSTO DEFAULT RECORD) {
    FOREVERY(RECORD section FROM this->PrepareTypeSections(contexts, type, options)) {
      OBJECT newtab := maintabs->InsertTabAt(insertpos, GetTid(section.title));
      insertpos := insertpos + 1;

      FOREVERY(RECORD line FROM section.lines) {
        newtab->layout := line.layout;
        newtab->InsertComponentAfter(line.line, DEFAULT OBJECT, TRUE);
      }
    }
  }

  PUBLIC MACRO SetControllersEnabled(BOOLEAN enabled) {
    FOREVERY(RECORD controller FROM this->metacontrollers)
      controller.fsinstance->enabled := enabled;
  }
>;

/** Create a metatabs renderer
    @param objdata Configuration record for the metatabs renderer
    @cell(integer) objdata.objectid
    @cell(integer) objdata.parent
    @cell(integer) objdata.isfolder
    @cell(integer) objdata.type
    @cell(boolean) objdata.requireworkflow
*/
PUBLIC OBJECT FUNCTION CreateMetatabsRenderer(RECORD objdata) {
  objdata := ValidateOptions([
    objectid := 0,
    parent := 0,
    isfolder := FALSE,
    type := -1,
    isobjectprops := FALSE,
    user := GetEffectiveUser()->entityid //TODO FIX for overrideuser, has no entityid
  ], objdata, [
    required := STRING[ "objectid", "parent", "isfolder", "type", "isobjectprops" ]
  ]);

  RECORD metatabsconfig := CallJS("@mod-publisher/lib/internal/siteprofiles/metatabs.ts#describeMetaTabsForHS", objdata);
  OBJECT applytester := RecordExists(metatabsconfig) ? GetApplyTesterForHSInfo(metatabsconfig.__hsinfo) : GetApplyTesterForObject(objdata.objectid); //fallback. test-whfs-history-v4 triggers it
  IF(NOT ObjectExists(applytester))
    THROW NEW Exception("No applytester found for this object");

  metatabsconfig := EnforceStructure(
    CELL[ extend_props := RECORD[]
        , workfloweditor := DEFAULT RECORD
        , types := RECORD[]
        ], metatabsconfig
  );

  DELETE CELL __hsinfo FROM metatabsconfig;

  RETURN NEW MetatabsRenderer(metatabsconfig, applytester);
}
