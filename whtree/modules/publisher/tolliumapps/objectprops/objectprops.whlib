<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/whfs/base.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/database.whlib";
LOADLIB "mod::publisher/lib/dialogs.whlib";
LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::publisher/lib/siteprofiles.whlib";
LOADLIB "mod::publisher/lib/components/whfsinstance.whlib";
LOADLIB "mod::publisher/lib/internal/actions.whlib";
LOADLIB "mod::publisher/lib/internal/files.whlib";
LOADLIB "mod::publisher/lib/internal/tollium-helpers.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/tolliumapps/editdocument/editbase.whlib";
LOADLIB "mod::publisher/tolliumapps/objectprops/tasks.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";
LOADLIB "mod::tollium/lib/internal/support.whlib";


/* ADDME: andere types om te wijzigen
   ADDME: toevoegen/verwijderen van rijen */

CONSTANT STRING ARRAY lockablefields := [ "no_index", "no_follow", "no_archive" ];

OBJECTTYPE ObjectPropsAPI
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT objectprops;
  MACRO PTR ARRAY onpinned;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /// Applytester
  PUBLIC PROPERTY applytester(GetApplyTester,-);

  /// Parent site
  PUBLIC PROPERTY targetsite(GetTargetSite,-);

  /// Parent folder
  PUBLIC PROPERTY targetfolder(GetTargetFolder,-);

  /// Id we're editing, may be 0
  PUBLIC PROPERTY targetid(GetTargetId,-);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT objectprops)
  {
    this->objectprops := objectprops;
  }

  OBJECT FUNCTION GetApplyTester()
  {
    RETURN this->objectprops->contexts->applytester;
  }

  // ---------------------------------------------------------------------------
  //
  // Getters/setters
  //

  OBJECT FUNCTION GetTargetSite()
  {
    RETURN this->objectprops->__GetTargetSite();
  }

  OBJECT FUNCTION GetTargetFolder()
  {
    RETURN this->objectprops->__GetTargetFolder();
  }

  INTEGER FUNCTION GetTargetId()
  {
    RETURN this->objectprops->__GetTargetId();
  }

  // ---------------------------------------------------------------------------
  //
  // Private API
  //

  PUBLIC MACRO __UpdateOnPinned(BOOLEAN newpinned)
  {
    FOREVERY(MACRO PTR onpinned FROM this->onpinned)
      onpinned(newpinned);
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Add a tabsextension
      @param extension Path to tabs extension
      @param whfstype WHFS type managed by the extension
      @param taboptions Extra options which will be passed as extensionoptions to the loaded tab */

  PUBLIC MACRO AddTabsExtension(STRING extension, STRING whfs_type, RECORD taboptions DEFAULTSTO DEFAULT RECORD) {
    this->objectprops->__DoAddTab( CELL[ whfs_type
                                       , extension
                                       , title := ""
                                       , taboptions
                                       ]);
  }

  PUBLIC MACRO AddOnPinnedListener(MACRO PTR newlistener)
  {
    INSERT newlistener INTO this->onpinned AT END;
  }

  PUBLIC MACRO OnChange()
  {
    this->objectprops->__CheckConstraints();
  }
>;

PUBLIC STATIC OBJECTTYPE ObjectProps EXTEND PublisherEditorBase <
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /** Data used to load the dialog
  */
  RECORD startdata;

  /// Whether to show developer options
  BOOLEAN showdeveloperoptions;

  /// Whether to show pinning
  BOOLEAN showpinning;

  /// Errors that happened during the loading of extensions (displayed when developer options are shown)
  STRING ARRAY pending_errors;

  /** \defgroup Initial object data, all set by SetCurrentObjectData
      @{
  */

  /// Whether this is specifically a duplication action
  BOOLEAN isduplicate;

  /// system.sites record for the parentsite of the parentfolder
  RECORD parentsite;

  /// system.sites record of the current folder (so only set when the current folder is a site)
  RECORD cursite;

  /// Source item (original file for duplications, draft or edited file when editing)
  OBJECT sourceitem;

  /**@}*/

  RECORD ARRAY addtabs;

  /** Messageboxes that need to be shown in the next submit round
  */
  RECORD ARRAY scheduledmessageboxes;

  // ---------------------------------------------------------------------------
  //
  // Public properties and variables
  //

  /// Webcontext for the currently edited item
  OBJECT webcontext;

  // ---------------------------------------------------------------------------
  //
  // Constructor & init
  //

  MACRO NEW(): PublisherEditorBase(TRUE) {
    this->contexts->objectpropsapi := NEW ObjectPropsAPI(this);
  }

  MACRO ReadUserSettings() {
    this->showdeveloperoptions := this->tolliumuser->HasRight("system:supervisor");
    this->showpinning := this->showdeveloperoptions OR this->tolliumuser->HasRight("publisher:pinning");
  }

  MACRO Init(RECORD data) {
    this->startdata := data;
    this->isduplicate := this->startdata.why = "duplicate";
    this->pending_errors := SELECT AS STRING ARRAY `Extension '${extension}' is not loaded, because it caused an error while loading:\n${error}`
                              FROM data.faultypropeditors;

    // Read the user settings
    this->ReadUserSettings();

    // Fill in the data about the object to edit/create.
    this->SetCurrentObjectData(); //handles SetupEditBaseForExistingObject / SetupEditBaseForNewObject

    /// Fill base fields from the source
    this->FillBaseFields(); //name,title,description

    BOOLEAN canschedule := RecordExists(this->parentsite) AND this->parentsite.outputweb != 0; // site is published _some_where
    IF (this->isfolder) {
      ^publish->visible := FALSE;
      ^makeindex->visible := FALSE;
      ^tasksettings->visible := FALSE;
    }

    //ADDME: Set using site profile?
    ^keywords->visible := NOT this->isfolder;

    IF (this->startdata.why IN [ "duplicate", "newfile", "newfolder" ]) {
      this->CalculateNameForNewObject();

      this->frame->title := this->isfolder ? this->GetTid(".newfolder-title")
                                           : this->GetTid(".newfile-title");

      IF (NOT this->isfolder) {
        IF (this->curtype.id IN [ whconstant_whfstype_internallink, whconstant_whfstype_contentlink]) {
          ^path->folder := this->parentfolder->id;
        }

        canschedule := canschedule AND this->curtype.ispublishable;
        BOOLEAN cansetpublish := canschedule;

        BOOLEAN initialpublish := cansetpublish AND this->curtype.initialpublish;

        ^notpublished->visible := NOT cansetpublish;
        ^notpublishedtext->value := this->curtype.ispublishable ? this->GetTid(".sitenotpublished") : this->GetTid(".typenotpublished", ^type->value);
        ^publish->visible := cansetpublish;
        //ADDME introduce 'initialpublish' or something like that for all file types. or it should somehow be linked to the use of the editdocument app, i can image editdocument to be more internalized than 'just an editor app'
        ^publish->value := initialpublish;

        // First file in the parentfolder? (no need to check if this type is acceptable, is done later)
        IF(NOT RecordExists(SELECT FROM system.fs_objects WHERE parent=this->parentfolder->id AND isfolder=FALSE))
          ^makeindex->value := TRUE;
      }
    }
    ELSE IF (this->startdata.why = "edit") {
      ^pinobject->value := this->sourceitem->ispinned;

      IF (RecordExists(this->recyclebininfo))
        this->InitFieldsForItemInRecycleBin();

      canschedule := canschedule AND this->sourceitem->isactive;

      IF (NOT this->isfolder)
      {
        canschedule := canschedule AND this->curtype.ispublishable;
        this->InitConsilioInfo();
      }

      this->frame->title := RecordExists(this->cursite)
                               ? this->GetTid(".editsite-title", this->sourceitem->name)
                               : this->isfolder ? this->GetTid(".editfolder-title", this->sourceitem->name)
                                                : this->GetTid(".editfile-title",   this->sourceitem->name);

    } ELSE {
      ABORT("Unknown 'why'");
    }

    // Initialization for edited/duplicated files
    IF (NOT this->isfolder AND this->startdata.why IN [ "duplicate", "edit" ]) {
      RECORD inittype := this->curtype;

      // Links cannot be versioned, so use the data of the sourceitem
      IF (inittype.id = whconstant_whfstype_externallink OR inittype.id = whconstant_whfstype_internallink) {
        IF (inittype.id = whconstant_whfstype_externallink)
          ^link->value := [ externallink := this->sourceitem->externallink, internallink := 0, append := ""  ];
        ELSE
          ^link->value := [ externallink := "", internallink := this->sourceitem->filelink, append := this->sourceitem->externallink ];
        ^link->visible := TRUE;
        ^link->required := TRUE;
      } ELSE IF (inittype.id = whconstant_whfstype_contentlink) {
        ^path->value := this->sourceitem->filelink;
        ^path->visible := TRUE;
        ^path->required := TRUE;

        IF (inittype.id = 20 //contentlink
            AND this->sourceitem->filelink != 0)
        {
          OBJECT linkedfile := OpenWHFSObject(this->sourceitem->filelink);
          IF (ObjectExists(linkedfile))
          {
            inittype := DescribeContentTypeById(linkedfile->type) ?? this->curtype;
          }
        }
      }
      //illegal filename? (can happen through webdav: eg word temp files)
      BOOLEAN cansetpublish := canschedule OR (this->sourceitem->publish AND (NOT inittype.ispublishable OR NOT IsValidWHFSName(this->sourceitem->name,FALSE)));

      ^notpublished->visible := NOT cansetpublish;
      ^notpublishedtext->value := NOT this->sourceitem->isactive ? this->GetTid(".trashnotpublished") : inittype.ispublishable ? this->GetTid(".sitenotpublished") : this->GetTid(".typenotpublished", ^type->value);
      ^publish->visible := cansetpublish;
      IF(this->startdata.why = "edit")
      {
        ^publish->value := this->sourceitem->publish;
      }

      IF(NOT this->isduplicate)
      {
        BOOLEAN isindex := this->sourceitem->id = this->parentfolder->indexdoc;
        ^makeindex->value := isindex;
      }
    }

    this->UpdateMakeIndexVisibility();

    // Tasks
    ^tasksettings->visible := canschedule;
    this->ReloadTaskList();
    this->SetupObjectProps();

    // Extensions
    this->InitializeExtensions();
    this->InitSeoSettings(); //setup the SEO Tab and the 2 additional title fields

    this->PrepareDialog();

    this->UpdatePinned();

    ^tablist->rows := SELECT tab := page->title, page FROM ToRecordArray(^maintabs->pages,"page") WHERE page->visible;
    ^tablist->selection := ^tablist->rows[0];
    FOREVERY(OBJECT page FROM ^maintabs->pages) {
      page->spacers := [ top :=true, bottom :=true, left:=true, right:= true];
      page->vscroll := TRUE;
    }

    // this must be the LAST thing we do or users will a) see an incomplete screen and b) not see spacers as changing that dynamically doesn't seem to work
    IF(this->showdeveloperoptions AND Length(this->pending_errors)>0) {
      Print("The following errors occured processing the site profiles:\n"||Detokenize(this->pending_errors,"\n"));
      this->RunSimpleScreen("warning", this->GetTid(".messageboxes.siteprofileerrors", Detokenize(this->pending_errors,"\n\n")));
    }
  }

  MACRO OnTabChange() //FIXME convert to visibleon. EXPERIMENTAL
  {
    ^maintabs->selectedtab := (^tablist->selection ?? ^tablist->rows[0]).page;
  }

  MACRO UpdateMakeIndexVisibility()
  {
    RECORD indexconstraints := this->CheckIndexConstraints();

    ^makeindex->visible := this->isduplicate = FALSE AND indexconstraints.acceptableindex AND indexconstraints.canedit;
    IF (NOT indexconstraints.acceptableindex OR this->isduplicate)
      ^makeindex->value := FALSE;
  }

  RECORD FUNCTION CheckIndexConstraints()
  {
    IF (this->isfolder)
      RETURN [ acceptableindex := FALSE, canedit := FALSE ];

    BOOLEAN canedit := NOT RecordExists(this->recyclebininfo) AND this->tolliumuser->HasRightOn("system:fs_fullaccess", this->parentfolder->id);

    IF (this->curtype.id = 20) // contentlink
    {
      // Do we have a filelink already?
      IF (^path->value != 0)
      {
        INTEGER destfiletype := SELECT AS INTEGER type FROM system.fs_objects WHERE id = ^path->value;
        RECORD desttype := DescribeContentTypeById(destfiletype);

        IF (NOT RecordExists(desttype) OR NOT desttype.isacceptableindex)
          RETURN CELL[ acceptableindex := FALSE, canedit ];
      }
    }
    ELSE
    {
      IF (NOT this->curtype.isacceptableindex)
        RETURN CELL[ acceptableindex := FALSE, canedit ];
    }

    RETURN CELL[ acceptableindex := TRUE, canedit ];
  }

  MACRO SetCurrentObjectData() { //always invoked by Init(), just after reading user prefs
    IF (this->startdata.why IN [ "duplicate", "newfile", "newfolder" ])
    {
      BOOLEAN isfolder := (this->startdata.why = "duplicate") ? (SELECT AS BOOLEAN COLUMN isfolder FROM system.fs_objects WHERE id = this->startdata.fsobj) : this->startdata.why = "newfolder";
      this->SetupEditBaseForNewObject(this->startdata.parentfolder, isfolder, this->startdata.type);
      this->parentsite := SELECT * FROM system.sites WHERE id = this->parentfolder->parentsite;

      IF (NOT ObjectExists(this->parentfolder) AND this->startdata.parentfolder != 0)
        THROW NEW Exception("No such file/folder " || this->startdata.parentfolder);

      INTEGER sourceobj := this->isduplicate ? this->startdata.fsobj : 0;

      IF (sourceobj = 0)
        this->isfolder := this->startdata.why != "newfile";
      ELSE
      {
        this->sourceitem := OpenWHFSObject(sourceobj);

        IF (NOT ObjectExists(this->sourceitem))
          THROW NEW Exception("No such file/folder " || this->startdata.fsobj);

        this->isfolder := this->sourceitem->isfolder;
      }

      this->ConfigureForObjectType(this->isduplicate ? this->sourceitem->type : this->startdata.type);
      this->RetrieveApplyBaseInfo(0, this->startdata.parentfolder);
    }
    ELSE IF (this->startdata.why = "edit")
    {
      this->SetupEditBaseForExistingObject(this->startdata.fsobj, CELL[this->startdata.readonly, useworkflow := FALSE]);
      this->sourceitem := OpenWHFSObject(this->itemid);

      IF (NOT ObjectExists(this->sourceitem))
        THROW NEW Exception("No such file/folder " || this->startdata.fsobj);

      this->isfolder := this->sourceitem->isfolder;

      IF(this->sourceitem->parent != 0)
      {
        this->parentfolder := OpenWHFSObject(this->sourceitem->parent);
        IF (NOT ObjectExists(this->parentfolder))
          THROW NEW Exception("No such file/folder " || this->sourceitem->parent || " which should have been a parent for " || this->startdata.fsobj);
      }
      ELSE
        this->parentfolder := OpenWHFSRootObject();

      this->parentsite := SELECT * FROM system.sites WHERE id = this->sourceitem->parentsite;

      this->RetrieveApplyBaseInfo(this->startdata.fsobj, this->sourceitem->parentsite);

      this->isfolder := this->sourceitem->isfolder;

      IF (this->isfolder)
        this->cursite := SELECT * FROM system.sites WHERE root = this->itemid;

      this->ConfigureForObjectType(this->sourceitem->type);
    }
    ELSE
    {
      ABORT("objectprops dialog get a unknown 'why' (expected 'duplicate', 'edit', 'newfile' or 'newfolder')");
    }

    //configure settings that depend on the applytester
    this->SetupBaseSettings();

    this->renderer->RegisterMetaController(^webconfig->type, ^webconfig);
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  INTEGER FUNCTION GetSiteId()
  {
    RETURN RecordExists(this->cursite) ? this->cursite.id : 0;
  }

  // ---------------------------------------------------------------------------
  //
  // Dialog init filling
  //

  /// Sets the name field for a new object
  MACRO CalculateNameForNewObject()
  {
    IF (ObjectExists(this->sourceitem))
    {
      // Calculate unique name for duplicate of file
      ^name->value := this->parentfolder->GenerateUniqueName(this->sourceitem->name);
    }
    ELSE IF(NOT this->namefollowstitle)
    {
      // The new file name
      STRING newname;
      IF (".html" IN this->curtype.extensions AND this->parentfolder->indexdoc = 0)
      {
        // The file is of an acceptable index type and there is no index document yet, so name the new file after an index file
        newname := GetWebserverDefaultPage(RecordExists(this->parentsite) ? this->parentsite.outputweb : 0);
      }
      ELSE
      {
        // Create a new file name based on the type name
        newname := GetTid(this->curtype.title);
        IF (Length(this->curtype.extensions) > 0)
          newname := newname || this->curtype.extensions[0];
        //ADDME: Deze tid zet gewoon 'nieuw' voor het bestandstype, wat een beetje lelijk is in het geval van niet-onzijdige
        //       typenamen, bijvoorbeeld 'nieuw contentopsomming.html'...
        newname := this->parentfolder->GenerateUniqueName(ToLowercase(this->GetTid(".newfile-name", newname)));
      }
      ^name->value := newname;
    }
  }

  MACRO FillBaseFields()
  {
    IF(ObjectExists(this->sourceitem)) //editing or duplicating
      this->LoadBaseData(this->sourceitem);

    INTEGER64 filesize := ObjectExists(this->sourceitem) AND NOT this->isfolder ? Length64(this->sourceitem->data) : 0i64;
    IF(filesize >= 1024)
      ^size->value := " (" || this->tolliumuser->FormatFileSize(filesize, 2) ||  ")";
    ELSE
      ^size->value := " (" || this->tolliumuser->FormatFileSize(filesize, 2) ||  ")";

    SetWHFSObjectLastModifiedField(^modified, this->isnew ? DEFAULT OBJECT : this->sourceitem);
  }

  MACRO PrepareDialog() {
    IF(this->showpinning)
    {
      ^pinobject->visible := TRUE;
      ^pinobject->label := this->isfolder ? this->GetTid(".pinfolder") : this->GetTid(".pinfile");
    }
    ELSE IF (^pinobject->value)
    {
      ^objectpinned->visible := TRUE;
      ^objectpinned->value := this->isfolder ? this->GetTid(".folderispinned") : this->GetTid(".fileispinned");
    }

    ^name->required := NOT this->isnew; //name becomes required as soon as you're done editing

    // If the item is deleted or if the user has no edit rights, setup the dialog as information window
    IF (NOT this->isnew AND (RecordExists(this->recyclebininfo) OR NOT this->CanWriteCurrentItem())) {
      ^name->readonly := TRUE;
      IF (^title->value = "")
        ^title->visible := FALSE;
      ELSE
        ^title->readonly := TRUE;
      IF (^description->value = "")
        ^description->visible := FALSE;
      ELSE
        ^description->readonly := TRUE;
      IF (^keywords->value = "")
        ^keywords->visible := FALSE;
      ELSE
        ^keywords->readonly := TRUE;
      ^link->readonly := TRUE;
      ^path->readonly := TRUE;

      ^publish->readonly := TRUE;
      ^makeindex->visible := FALSE;
      ^tasksactions->visible := FALSE;

      ^pinobject->visible := FALSE;

      // Read-only dialog only has an 'OK' button, which just closes the window
      ^ok_button->visible := FALSE;
      ^cancel_button->title := GetTid("~ok");
    }
    ^publicationsettings->visible := ^publish->visible OR ^makeindex->visible;
    ^publishpanel->visible := ^notpublished->visible OR ^publicationsettings->visible OR ^tasksettings->visible;
  }

  MACRO InitFieldsForItemInRecycleBin()
  {
    RECORD info := this->recyclebininfo;

    STRING deletionuser := this->contexts->userapi->GetUserDisplayName(info.deletionuser);

    STRING deletioninfo := this->GetTid(".deletedtext"
                                  ,this->tolliumuser->FormatDateTime(info.deletiondate, "minutes", TRUE, FALSE)
                                  ,deletionuser);
    ^deleted->value := deletioninfo;
    ^deleted->visible := TRUE;
    ^name->value := info.origname;

    ^originallocation->value := info.originalpath;
    ^originallocation->visible := TRUE;
  }

  MACRO SetupObjectProps()
  {
    ^description->visible := this->basesettings.description;
    ^keywords->visible := this->basesettings.keywords;
    ^isunlisted->visible := this->basesettings.isunlisted;
    ^title->required := this->basesettings.requiretitle;
  }

  UPDATE RECORD FUNCTION UpdatePinned()
  {
    RECORD basepinsettings := PublisherEditorBase::UpdatePinned();

    this->frame->flags.ispinned := basepinsettings.pinned;
    ^publish->enabled := NOT basepinsettings.pinned AND this->CanWriteCurrentItem();
    ^makeindex->enabled := NOT basepinsettings.pinned AND basepinsettings.parentfullaccess;

    this->contexts->objectpropsapi->__UpdateOnPinned(basepinsettings.pinned);

    RETURN basepinsettings;
  }

  /** Initializes type settings for the current type. Initializes this->curtype, and visibility for the 'url', 'path' and 'size' components
      @param settype Type to init for
  */
  MACRO ConfigureForObjectType(INTEGER settype)
  {
    ^type->value := GetTid(this->curtype.title);

    IF(this->curtype.id=18 OR this->curtype.id=19) //http://www.webhare.net/xmlns/publisher/externallink OR http://www.webhare.net/xmlns/publisher/internallink
    {
      ^link->visible := TRUE;
      ^link->required := TRUE;
      ^link->SetLinkType(this->curtype.id=18 ? "external" : "internal");
    }
    IF (this->curtype.id=20) //http://www.webhare.net/xmlns/publisher/contentlink
    {
      ^path->visible := TRUE;
      ^path->required := TRUE;
    }

    ^size->visible := NOT this->isfolder AND this->curtype.blobiscontent;
  }

  MACRO InitConsilioInfo()
  {
    IF (this->sourceitem->isactive)
    {
      ^linkcheck->visible := TRUE;
      ^objectreport->fs_object := this->itemid;
    }
  }

  MACRO ReloadTaskList()
  {
    IF (^tasksettings->visible AND this->itemid != 0)
    {
      ^tasks->rows :=
          SELECT id
               , task := GetTaskTitle(schedule)
               , event
               , folder
               , when
            FROM publisher.schedule
           WHERE file = this->itemid
        ORDER BY when;
    }
  }


  // ---------------------------------------------------------------------------
  //
  // Helper functions - misc
  //

  MACRO RetrieveApplyBaseInfo(INTEGER fsobjectid, INTEGER parentid)
  {
    IF (fsobjectid = 0)
      this->contexts->applytester := GetApplyTesterForFakeObject(parentid, NOT this->isfolder, this->curtype.id);
    ELSE
      this->contexts->applytester := GetApplyTesterForObject(fsobjectid);

    TRY
      this->webcontext := __GetWebContextForApplyTester(this->contexts->applytester, fsobjectid);
    CATCH (OBJECT e)
    {
      LogHarescriptException(e);
      PRINT("Got exception loading webcontext: " || e->what || "\n");
    }
  }

  MACRO AddTypesTabs() { //Insert metadata sheets as tabs
    INTEGER insertpos := 1;

    FOREVERY(RECORD type FROM this->renderer->metatabsconfig.types) {
      RECORD insertresult := this->renderer->RenderTypeIntoTabs(type, ^maintabs, insertpos, [ dirtylistener := ^dirtylistener ]);
      insertpos := insertpos + insertresult.sections;
    }

    this->RefreshMetaTabsReadonly();
  }


  // ---------------------------------------------------------------------------
  //
  // Helper functions - extensions
  //

  MACRO InitializeExtensions()
  {
    // If the item is not deleted and if the user has edit rights, setup site profile fields
    //ADDME: Just hiding these fields for now, a better solution would probably involve readonly compositions

    IF (this->CanWriteCurrentItem())
    {
      INTEGER parentfolderid := ObjectExists(this->parentfolder) ? this->parentfolder->id : 0;
      this->SetupSiteProfileExtensions(this->startdata.faultypropeditors);

      //For now we'll just append metatabs (assuming existing tabs are for eg. folders too and thus perserve order?), but we could attempt to insert them at the original positions
      this->AddTypesTabs();

      IF(this->isnew = FALSE AND RecordExists(this->recyclebininfo))
        this->MarkSiteProfileExtensionsReadonly();

      IF(ObjectExists(this->sourceitem))
        this->LoadMetadata(this->sourceitem, this->isduplicate);
      ELSE
        this->ResetSiteprofExtensions(parentfolderid, this->startdata.type);
    }

    ^maintabs->RunExtensionsPostInit();
  }

  MACRO ResetSiteprofExtensions(INTEGER parentid, INTEGER newtype) {
    FOREVERY(RECORD extendprop FROM this->extendprops) {
      OBJECT comp := extendprop.whfsinstance;
      IF(ObjectExists(comp)) {
        TRY {
          comp->SetDefaultInstanceDataForParent(parentid, this->isfolder, newtype);
        } CATCH (OBJECT<TolliumException> e) {
          LogHarescriptException(e);
          THROW NEW PropertyEditorException(extendprop.tabsextension, e);
        } CATCH (OBJECT e) {
          // Unknown exception, just continue to next composition
          Print("Could not set instance data for " || comp->name || " because of exception '" || e->what || "' from:\n");
          Print(AnyToString(e->trace, "boxed"));
          CONTINUE;
        }
      }
    }
  }

  MACRO SetupSiteProfileExtensions(RECORD ARRAY skipeditors) {
    //we'll point all settings to the end of their tab (for 'General' tab we ignore the readonly properties)
    ^maintabs->insertpoints := [ [ name := "name", component := ^insertpoint_generalsettings ]
                                , [ name := "title", component := ^insertpoint_generalsettings ]
                                , [ name := "description", component := ^insertpoint_generalsettings ]
                                , [ name := "keywords", component := ^insertpoint_generalsettings ]
                                , [ name := "publicationsettings", component := ^insertpoint_generalsettings ]
                                , [ name := "tasksettings", component := ^insertpoint_tasksettings ]
                                , [ name := "settings", component := ^insertpoint_generalsettings ]
                                , [ name := "properties", component := ^insertpoint_generalsettings ]
                                , [ name := "seosettings", component := ^insertpoint_generalsettings ]
                                , [ name := "advancedsettings", component := ^insertpoint_advancedsettings ]
                                ];
    ^maintabs->extendposition := 1; //site tabs come after "general"

    IF (ObjectExists(this->webcontext))
    {
      FOREVERY(OBJECT plugin FROM this->webcontext->GetPluginsByFeature("objectprops"))
        plugin->HookObjectProps(this->contexts->objectpropsapi);
    }

    RECORD ARRAY default_extendcomponents :=
        [ [ name := "fsobject_name", component := ^name ]
        , [ name := "fsobject_title", component := ^title ]
        , [ name := "fsobject_description", component := ^description ]
        , [ name := "fsobject_keywords", component := ^keywords ]
        ];

    STRING ARRAY seen_members;
    FOREVERY(RECORD propeditor FROM this->renderer->metatabsconfig.extend_props CONCAT this->addtabs) {
      // If we're not supposed to load the property editor because of an error, continue to the next
      RECORD skipreason := SELECT error FROM skipeditors WHERE extension = propeditor.extension;
      IF (RecordExists(skipreason))
        CONTINUE;

      TRY {
        STRING selector;
        RECORD ARRAY extendcomponents := default_extendcomponents;
        OBJECT whfsinstance;

        IF (propeditor.whfs_type != "") { //this was a tabsextension inserted by <extendproperties> with a contenttype. (they can also be added with AddTabsExtension and those may not have a contenttype)
          whfsinstance := this->CreateCustomComponent("http://www.webhare.net/xmlns/publisher/components", "whfsinstance");
          whfsinstance->type := OpenWHFSType(propeditor.whfs_type);
          IF(NOT ObjectExists(whfsinstance->type))
            THROW NEW Exception(`<tabsextension> is trying to handle unregistered type '${propeditor.whfs_type}'`);
          IF (ObjectExists(this->sourceitem))
            whfsinstance->basefsobject := this->sourceitem;

          INSERT [ name := "contentdata", component := whfsinstance ] INTO extendcomponents AT END;
        }

        ^maintabs->extendcomponents := extendcomponents;

        RECORD loadresult := ^maintabs->LoadTabsExtension(propeditor.extension
                                                         ,CellExists(propeditor, 'taboptions') ? propeditor.taboptions : DEFAULT RECORD);

        IF(ObjectExists(whfsinstance))
          INSERT CELL[ propeditor.whfs_type
                     , loadresult.components
                     , loadresult.fragment
                     , whfsinstance
                     , tabs := DEFAULT OBJECT
                     ] INTO this->extendprops AT END;
      }
      CATCH (OBJECT e)
      {
        LogHarescriptException(e);
        // Tab could not be inserted. We'll throw an exception containing the name of the propertyeditor which created
        // the component, so we can skip this propertyeditor in the next initialization.
        THROW NEW PropertyEditorException(propeditor.extension, e);
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  /// Called when internal link path has been modified
  MACRO OnPathChange()
  {
    OBJECT linked := OpenWHFSObject(^path->value);
    IF (ObjectExists(linked) AND this->curtype.namespace = "http://www.webhare.net/xmlns/publisher/contentlink")
    {
      // The file/folder to link to has changed, update the extension if necessary
      STRING curext := GetExtensionFromPath(^name->value);
      STRING newext := GetExtensionFromPath(linked->name);
      IF (curext != newext)
        ^name->value := Left(^name->value, Length(^name->value) - Length(curext)) || newext;
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoAddTask()
  {
    OBJECT taskdlg := this->LoadScreen("mod::publisher/tolliumapps/objectprops/tasks.xml#taskprops", [ why := "new"
                                                     , siteroot := this->parentsite.root
                                                     , isfolder := this->isfolder
                                                     ]);
    IF (taskdlg->RunModal() = "ok")
    {
      RECORD newtask := taskdlg->task;
      IF (newtask.event > 0)
      {
        INSERT [ id := 0
               , event := newtask.event
               , task := GetTaskTitle(newtask)
               , folder := newtask.folder
               , when := newtask.when
               ] INTO ^tasks->rows AT END;
        ^tasks->rows := SELECT * FROM ^tasks->rows ORDER BY when;
      }
    }
  }

  MACRO DoEditTask()
  {
    IF (RecordExists(^tasks->selection))
    {
      RECORD seltask := ^tasks->selection;
      OBJECT taskdlg := this->LoadScreen("mod::publisher/tolliumapps/objectprops/tasks.xml#taskprops", [ why := "edit"
                                                       , siteroot := this->parentsite.root
                                                       , event := seltask.event
                                                       , folder := seltask.folder
                                                       , when := seltask.when
                                                       , isfolder := this->isfolder
                                                       ]);
      IF (taskdlg->RunModal() = "ok")
      {
        RECORD newtask := taskdlg->task;
        IF (newtask.event > 0)
        {
          UPDATE ^tasks->rows
             SET event := newtask.event
               , task := GetTaskTitle(newtask)
               , folder := newtask.folder
               , when := newtask.when
           WHERE rowkey = seltask.rowkey;

          ^tasks->rows := SELECT * FROM ^tasks->rows ORDER BY when;
        }
      }
    }
  }

  MACRO DoDeleteTask()
  {
    IF (RecordExists(^tasks->selection) AND this->RunSimpleScreen("confirm", this->GetTid(".messageboxes.deletetaskconfirm")) = "yes")
      DELETE FROM ^tasks->rows WHERE rowkey = ^tasks->selection.rowkey;
  }

  MACRO DoGoToPublishedUrl()
  {
    this->frame->OpenBrowserWindow(this->sourceitem->url, "WebHarePublisherPreview");
  }

  // ---------------------------- -----------------------------------------------
  //
  // Submit
  //

  RECORD FUNCTION QueryDialog(STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ stoponfeedback :=       DEFAULT STRING ARRAY
        , params :=               DEFAULT STRING ARRAY
        ], options);

    RECORD def :=
        [ type :=                 type
        , done :=                 FALSE
        , feedback :=             ""
        , stoponfeedback :=       options.stoponfeedback
        , params :=               options.params
        , feedbackdata :=         DEFAULT RECORD
        ];

    FOREVERY (RECORD rec FROM this->scheduledmessageboxes)
    {
      IF (rec.done AND rec.type = def.type AND EncodeHSON(def.params) = EncodeHSON(rec.params))
        RETURN [ feedback := rec.feedback, data := rec.feedbackdata ];
    }

    INSERT def INTO this->scheduledmessageboxes AT END;
    RETURN DEFAULT RECORD;
  }

  STRING FUNCTION QueryMessageBox(STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD rec := this->QueryDialog(type, options);
    RETURN RecordExists(rec) ? rec.feedback : "";
  }

  // Returns whether the submit process may continue
  BOOLEAN FUNCTION RunScheduledMessageBoxes()
  {
    FOREVERY (RECORD rec FROM this->scheduledmessageboxes)
    {
      IF (rec.done)
        CONTINUE;

      STRING feedback;
      RECORD feedbackdata;
      SWITCH (rec.type)
      {
        CASE "contentlinkpointstononindex"
        {
          feedback := this->RunSimpleScreen("error", this->GetTid(".messageboxes.contentlinkpointstononindex"));
        }
        CASE "cannotreplacepinnedindex"
        {
          feedback := this->RunSimpleScreen("error", this->GetTid(".messageboxes.cannotreplacepinnedindex", rec.params[0]));
        }
        CASE "indexnotpublished"
        {
          feedback := this->RunSimpleScreen("warning", this->GetTid(".messageboxes.indexnotpublished"));
        }
        CASE "deleteoldindexconfirm"
        {
          feedback := this->RunSimpleScreen("confirm", this->GetTid(".messageboxes.deleteoldindexconfirm", rec.params[0], rec.params[1]));
        }
        CASE "replaceindexconfirm"
        {
          feedback := this->RunSimpleScreen("confirm", this->GetTid(".messageboxes.replaceindexconfirm", rec.params[0], rec.params[1]));
        }
        CASE "unpinconfirm"
        {
          feedback := this->RunSimpleScreen("confirm", this->GetTid(".messageboxes.unpinconfirm"), [ dontshowbuttons := ["yes"], dontshowkey := "publisher:objectprops.unpinconfirm" ]);
        }
        CASE "folderwithoutindex"
        {
          feedback := this->RunSimpleScreen("warning", this->GetTid(".messageboxes.folderwithoutindex"));
        }
        CASE "filecannotbenamedasindex"
        {
          feedback := this->RunSimpleScreen("error", this->GetTid(".messageboxes.filecannotbenamedasindex"));
        }
        DEFAULT
        {
          ABORT("Unhandled dialog type '" || rec.type || "'");
        }
      }

      this->scheduledmessageboxes[#rec].feedback := feedback ?? "cancel";
      this->scheduledmessageboxes[#rec].feedbackdata := feedbackdata;
      this->scheduledmessageboxes[#rec].done := TRUE;

      IF (feedback IN rec.stoponfeedback OR "*" IN rec.stoponfeedback)
        RETURN FALSE;
    }
    RETURN TRUE;
  }

  STRING FUNCTION GenerateAutoTitle()
  {
    STRING suggestedname := GetSafeFileName(UCLeft(^title->value, whconstant_publisher_autonamelength));
    IF (suggestedname LIKE "*_")
      suggestedname := Left(suggestedname,Length(suggestedname)-1);
    IF (suggestedname = "")
      suggestedname := "webhare";

    // Add extension for file type
    IF (NOT this->isfolder AND Length(this->curtype.extensions) > 0)
      suggestedname := suggestedname || this->curtype.extensions[0];

    RETURN this->parentfolder->GenerateUniqueName(suggestedname);
  }

  MACRO UpdateTasks(INTEGER objid)
  {
    //First, delete old tasks
    INTEGER ARRAY tasks := SELECT AS INTEGER ARRAY id FROM ^tasks->rows;
    FOREVERY (INTEGER id FROM (SELECT AS INTEGER ARRAY COLUMN id FROM publisher.schedule WHERE file = objid))
      IF (id NOT IN tasks)
        DeleteFileTask(id);

    FOREVERY (RECORD task FROM ^tasks->rows) //Add & EditFileTask will schedule publisher:scheduledtasks
    {
      IF (task.id = 0)
        AddFileTask(objid, task.when, task.event, task.folder);
      ELSE
        EditFileTask(task.id, task.when, task.event, task.folder);
    }
  }


  /** Calculate index actions
      @return
      @cell(boolean) return.makeindex If true, make this file the index
      @cell(boolean) return.resetindex If true, reset the index of the parent folder
      @cell(integer) return.recycleoldindex Id of old index file to recycle
      @cell(integer) return.scheduleoldindex Id of old index file republish
  */
  RECORD FUNCTION CheckMakeIndex() {
    // Calculate (new) parentfolder and parentsite
    OBJECT parentfolder := this->parentfolder;
    RECORD parentsite := this->parentsite;

    RECORD indexconstraints := this->CheckIndexConstraints();
    BOOLEAN makeindex := ^makeindex->visible AND ^makeindex->value;
    BOOLEAN forcedindex;

    // If the new name is a default page for this site, it will automatically become index anyway
    IF (RecordExists(this->parentsite) AND ToLowercase(^name->value) IN whconstant_webserver_indexpages)
    {
      IF (NOT indexconstraints.acceptableindex)
      {
        this->QueryDialog("filecannotbenamedasindex", [ stoponfeedback := [ "*" ]]);
        RETURN [ status := "retry" ];
      }

      makeindex := TRUE;
      forcedindex := TRUE;
    }

    INTEGER scheduleoldindex, recycleoldindex;

    IF (^makeindex->visible OR forcedindex OR NOT indexconstraints.acceptableindex)
    {
      IF (makeindex AND this->curtype.id = 20)
      {
        //verify the reference
        INTEGER destfiletype := SELECT AS INTEGER type FROM system.fs_objects WHERE id = ^path->value;
        RECORD destfiletypeprops := GetFileTypeProps(destfiletype);
        IF(NOT RecordExists(destfiletypeprops) OR NOT destfiletypeprops.isacceptableindex)
        {
          this->QueryMessageBox("contentlinkpointstononindex", [ stoponfeedback := [ "*" ]]);
          RETURN [ status := "retry" ];
        }
      }

      //Does this folder already have an index other than this file?
      IF (makeindex AND parentfolder->indexdoc != 0 AND (this->isnew OR parentfolder->indexdoc != this->sourceitem->id))
      {
        IF (RecordExists(parentsite))
        {
          //If this indexdoc has the name of an index file, it must be renamed or destroyed!
          RECORD indexfile := SELECT * FROM system.fs_objects WHERE id = parentfolder->indexdoc;

          IF(indexfile.ispinned) //a pinned index file will never go away implicitly. fixes webhare/webhare#1439
          {
            this->QueryMessageBox("cannotreplacepinnedindex", [ stoponfeedback := [ "*" ], params := [ STRING(indexfile.name)] ]);
            RETURN [ status := "retry" ];
          }

          IF (ToLowercase(indexfile.name) IN whconstant_webserver_indexpages) //indexpages can't be unmarked as index so need to go away - which is why we ask a different question
          {
            IF (indexfile.type = 24)
              recycleoldindex := indexfile.id;
            ELSE
            {
              STRING feedback := this->QueryMessageBox("deleteoldindexconfirm",
                  [ params := [ STRING(indexfile.name), ^name->value ] ]);
              IF (feedback = "")
                RETURN [ status := "retry"];
              ELSE IF (feedback = "yes")
                recycleoldindex := indexfile.id;
              ELSE
                makeindex := FALSE;
            }
          }
          ELSE //double-check index reassignment. this is just a flag move, no content is moved away
          {
            STRING feedback := this->QueryMessageBox("replaceindexconfirm", [ params := [ STRING(indexfile.name), ^name->value ] ]);
            IF (feedback = "")
              RETURN [ status := "retry" ];

            IF (feedback = "yes")
              scheduleoldindex := indexfile.id; //republish the old index
            ELSE
              makeindex := FALSE;
          }
        }
      }
      ELSE IF (NOT makeindex AND NOT this->isnew AND parentfolder->indexdoc = this->sourceitem->id)
      {
        IF (this->QueryMessageBox("folderwithoutindex") = "")
          RETURN [ status := "retry" ];
      }

      //publication disabled for index document? (no warning in versioned sites)
      IF (makeindex AND NOT ^publish->value)
      {
        IF (this->QueryMessageBox("indexnotpublished") = "")
          RETURN [ status := "retry" ];
      }
    }

    RETURN
        [ status :=           "ok"
        , makeindex :=        makeindex
        , resetindex :=       (^makeindex->visible OR NOT indexconstraints.acceptableindex) AND NOT makeindex AND NOT this->isnew AND this->parentfolder->indexdoc = this->sourceitem->id
        , scheduleoldindex := scheduleoldindex
        , recycleoldindex :=  recycleoldindex
        ];
  }

  INTEGER FUNCTION Submit() {
    // Auto-check for required fields
    OBJECT quickfeedback := this->BeginFeedback();
    IF(^name->value = "" AND ^title->value = "")
      quickfeedback->AddErrorFor(^name, this->GetTid(".nameortitle", this->isfolder ? "folder" : "file"));

    IF(quickfeedback->HasFailed())
    {
      quickfeedback->Finish();
      RETURN 0;
    }

    quickfeedback->Cancel(); //don't show any warnings now yet... the next BeginWork will.

    // Reset scheduled message boxes from previous submits
    this->scheduledmessageboxes := DEFAULT RECORD ARRAY;

    WHILE (TRUE) {
      // Run all scheduled messageboxes
      IF (NOT this->RunScheduledMessageBoxes())
        RETURN 0;

      OBJECT work := this->BeginWork();

      // Refresh cached data
      this->parentfolder->Refresh();

      // Get settable metadata plus filename. We won't be getting eg. title for RTDs we're editing
      RECORD metadata := this->GetMetadata();
      IF(^name->value != "")
        metadata := CELL[...metadata, name := ^name->value ];
      BOOLEAN update_ordering_otherfiles;

      IF (this->parentfolder->id != 0 AND GetApplyTesterForObject(this->parentfolder->id)->GetFolderSettings().ordering = "orderable") {
        IF(this->isduplicate) {
          //NOTE: When duplicating an item, the ordering should be original + 1, and any files that follow need to be shifted down appropriately, requiring an op transaction.
          INTEGER newordering := this->sourceitem->ordering + 1;
          INSERT CELL ordering := newordering INTO metadata;
          update_ordering_otherfiles := TRUE;
        } ELSE IF(this->isnew) {
          INTEGER newordering := ObjectExists(this->sourceitem) AND this->sourceitem->ordering != 0 ? this->sourceitem->ordering : SELECT AS INTEGER Max(ordering) + 1 FROM system.fs_objects WHERE parent = this->parentfolder->id;
          INSERT CELL ordering := newordering INTO metadata;
        }
      }

      this->CheckNameConflict(work);
      IF(work->HasFailed()) {
        work->Finish();
        RETURN 0;
      }

      RECORD indexactions;
      IF(NOT this->isfolder) {
        IF (^publish->visible) {
          INTEGER new_publish := this->isnew ? 0 : GetFlagsFromPublished(this->sourceitem->published);
          IF (RecordExists(this->parentsite) AND this->parentsite.outputweb != 0 AND ^publish->value)
            new_publish := ConvertToWillPublish(new_publish, FALSE, TRUE, PubPrio_DirectEdit);
          ELSE
            new_publish := ConvertToWontPublish(new_publish);

          INSERT CELL published := new_publish INTO metadata;
        }

        indexactions := this->CheckMakeIndex();
        IF (indexactions.status = "retry") {
          work->Cancel();
          CONTINUE;
        }
        IF (indexactions.status = "scheduleddelete")
          indexactions := DEFAULT RECORD;
      }

      //set pinning flag if it is changed, or set on a new object
      IF((this->isnew = TRUE AND ^pinobject->value) OR (this->isnew = FALSE AND ^pinobject->value != this->sourceitem->ispinned)) {
        //warn if pinning is removed from an existing object
        IF (this->isnew OR ^pinobject->value)
          INSERT CELL ispinned := ^pinobject->value INTO metadata;
        ELSE {
          STRING feedback := this->QueryMessageBox("unpinconfirm");
          IF (feedback = "") {
            work->Cancel();
            CONTINUE;
          }
          IF (feedback = "yes")
            INSERT CELL ispinned := ^pinobject->value INTO metadata;
        }
      }

      INTEGER linktype;
      IF(^link->visible) {
        IF (^link->value.internallink != 0) {
          linktype := 19;
          INSERT CELL filelink := ^link->value.internallink INTO metadata;
          INSERT CELL externallink := ^link->value.append INTO metadata;
        } ELSE {
          linktype := whconstant_whfstype_externallink;
          INSERT CELL filelink := 0 INTO metadata;
          INSERT CELL externallink := ^link->value.externallink INTO metadata;
        }
      } ELSE IF(^path->visible)
        INSERT CELL filelink := ^path->value INTO metadata;

      IF (this->isnew) {
        IF (NOT ObjectExists(this->sourceitem)) {
          INSERT CELL type := linktype ?? this->curtype.id INTO metadata;
        } ELSE {
          INSERT CELL type := linktype ?? this->sourceitem->type INTO metadata;
          IF(NOT this->sourceitem->isfolder) {
            INSERT CELL data := this->sourceitem->data INTO metadata;
            INSERT CELL dataistrusted := this->isduplicate INTO metadata;
          }
        }
      } ELSE IF (linktype != 0) {
        INSERT CELL type := linktype INTO metadata;
      }

      RECORD oldversion;
      IF(NOT this->isnew)
        oldversion := SELECT * FROM system.fs_objects WHERE id = this->sourceitem->id;

      IF(work->HasFailed()) {
        work->Finish();
        RETURN 0;
      }

      // All updates have been calculated, start applying them
      IF (update_ordering_otherfiles)
        UPDATE system.fs_objects SET ordering := ordering + 1 WHERE ordering >= metadata.ordering AND parent = this->parentfolder->id;

      OBJECT draftitem := this->sourceitem;

      // Create the new file/folder, apply non-versioned metadata
      INTEGER objid := this->itemid;
      IF(this->isnew) {
        IF(ObjectExists(this->sourceitem)) { //cloning an item
          draftitem := this->sourceitem->CopyTo(this->parentfolder, metadata.name);
          draftitem->UpdateMetadata(metadata);
        } ELSE IF (this->isfolder) {
          draftitem := this->parentfolder->CreateFolder(metadata, [ createdby := this->contexts->user ]);
        } ELSE {
          draftitem := this->parentfolder->CreateFile(metadata, [ createdby := this->contexts->user ]);
        }
        objid := draftitem->id;
      } ELSE {
        this->sourceitem->UpdateMetadata(metadata); //FIXME: Avoid this if nothing really changed (ie need to check contenttypes)
      }

      IF(work->HasFailed()) {
        work->Finish();
        RETURN 0;
      }

      // Execute index actions
      IF (RecordExists(indexactions))
      {
        // At this point, this->cursite is defined when adding and editing sites
        IF (indexactions.recycleoldindex > 0)
          OpenWHFSObject(indexactions.recycleoldindex)->RecycleSelf(); // recycle the current index document

        IF (indexactions.makeindex)
          this->parentfolder->UpdateMetadata ([indexdoc := objid]);
        IF (indexactions.resetindex AND this->parentfolder->indexdoc = objid)
          this->parentfolder->UpdateMetadata ([indexdoc := 0]);

        IF (indexactions.scheduleoldindex > 0)
          ScheduleFileRepublish(indexactions.scheduleoldindex); //republish the old index
      }

      //Update tasks for file
      IF (^tasksettings->visible)
        this->UpdateTasks(objid);

      // Write extension data
      this->SaveMetadata(objid);
      ^maintabs->SubmitExtensions(work);

      IF(NOT this->isnew AND this->isfolder AND this->curtype.id = whconstant_whfstype_photoalbum) { //photoalbums?      {
        //ADDME: Generalize so any type cna trigger a non-template-too republish if certain metadata fields changed
        //ADDME: Trigger only if width/height/publishoriginals properties changed
        ScheduleFolderRepublish(this->sourceitem->id, /*recursive=*/FALSE, /*non_template_too=*/TRUE);
      }

      //Invoke any hooks, add default contents to folders, if necessary
      IF(this->isnew) {
        IF(this->isfolder) {
          // Add the default index file if there is no template
          IF(NOT ObjectExists(this->sourceitem))
            AddDefaultIndexToFolder(objid);
          RunAddFolderHooks(objid);
        } ELSE
          RunAddFileHooks(objid);
      } ELSE {
        IF(this->isfolder)
          RunEditFolderHooks(oldversion, objid);
        ELSE
          RunEditFileHooks(objid);
      }

      IF (NOT work->Finish())
        RETURN 0;

      RETURN objid;
    } //while(TRUE)
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC MACRO __CheckConstraints()
  {
    this->UpdateMakeIndexVisibility();
  }

  PUBLIC OBJECT FUNCTION __GetTargetFolder()
  {
    RETURN this->parentfolder;
  }

  PUBLIC OBJECT FUNCTION __GetTargetSite()
  {
    RETURN RecordExists(this->cursite) ? OpenSite(this->cursite.id) : DEFAULT OBJECT;
  }

  PUBLIC MACRO __DoAddTab(RECORD tabinfo)
  {
    INSERT tabinfo INTO this->addtabs AT END;
  }

  PUBLIC OBJECT FUNCTION GetExtendedComponent(STRING whfstype, STRING cellname) {
    FOREVERY(RECORD extendprop FROM this->extendprops)
      IF(extendprop.whfs_type = whfstype) {
        OBJECT cellobj := extendprop.whfsinstance->GetComponent(cellname);
        IF(ObjectExists(cellobj))
          RETURN cellobj;
      }

    RETURN DEFAULT OBJECT;
  }

  // ---------------------------------------------------------------------------
  //
  // SEO Tab
  //

  MACRO ApplyAnyLocks(RECORD settings)
  {
    FOREVERY(STRING field FROM lockablefields)
      IF(GetCell(settings, field) AND GetMember(this, "^" || field)->enabled = TRUE) //still enabled...
      {
        GetMember(this, "^" || field)->enabled := FALSE;
        GetMember(this, "^" || field)->value := TRUE;
      }
  }

  MACRO InitSeoSettings()
  {
    BOOLEAN needstemplate := this->isfolder ? FALSE : this->contexts->applytester->IsTypeNeedsTemplate();

    ^advancedtab->visible := this->contexts->user->HasRight("publisher:advanced");
    ^seocustomization->visible := this->basesettings.seotab;
    ^canonical->visible := this->basesettings.seotab;
    ^no_index->visible := this->basesettings.seotab;
    ^no_follow->visible := this->basesettings.seotab;
    ^no_archive->visible := this->basesettings.seotab;
    ^customrobots->visible := this->basesettings.seotab;

    IF(this->contexts->applytester->objsite != this->contexts->objectpropsapi->targetid)
    {
      //we are contained in a site, and need to check parents for forced noindex/nofollow
      INTEGER ARRAY tree := this->contexts->objectpropsapi->targetfolder->GetFullTree();

      RECORD ARRAY curseosettings := OpenWHFSType("platform:web.config")->Enrich(ToRecordArray(tree,"ID"), "ID", STRING[...lockablefields, "custom_robots" ]);
      FOREVERY(RECORD setting FROM curseosettings)
      {
        this->ApplyAnyLocks(setting);

        IF(setting.custom_robots != "")
          ^customrobots->placeholder := setting.custom_robots;
      }
      }

    IF(NOT this->contexts->user->HasRight("system:supervisor"))
      ^customrobots->visible := FALSE;

    ^canonical->visible := NOT this->contexts->applytester->objisfolder;
    IF(NOT this->contexts->applytester->objisfolder)
    {
      //Then fields can also be locked through the siteprofile
      //TODO share GetBaseProperties with objectprops screen?
      RECORD baseprops := GetBaseProperties(this->contexts->applytester);
      this->ApplyAnyLocks(baseprops);
    }
  }
>;


/////////////////////////////////////////////////////////////////////
//
// Add/edit task dialog
//


PUBLIC MACRO RunPropertyDialog(OBJECT parent, RECORD target)
{
  RunFSObjectPropertiesDialog(parent, target.id);
}
