<?wh

LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::publisher/lib/internal/siteprofiles/widgets.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::system/lib/resources.whlib";

// Return record array of string arrays as a deduped record array
// Eg: [[ sa := ["a"],["b"] ], sa := ["a"],"c"] ] will return [ "a","b","c" ]
STRING ARRAY AGGREGATE FUNCTION DedupeStringArrays(RECORD ARRAY inarray)
{
  STRING ARRAY resultset;
  FOREVERY(RECORD row FROM inarray)
    resultset := resultset CONCAT row.sa;
  RETURN GetSortedSet(resultset);
}

PUBLIC STATIC OBJECTTYPE ChooseType EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD ARRAY widgets;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->widgets := data.widgets;
    this->RefreshList();
    IF(Length(^groups->rows)=1)
      ^groups->selection := ^groups->rows[0];
    ELSE IF(NOT RecordExists(^groups->selection))
      ^groups->SetValueIfValid("http://www.webhare.net/xmlns/publisher/generalwidgets");
  }


  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO OnRefresh(STRING event, RECORD data)
  {
    this->RefreshList();
  }

  // ---------------------------------------------------------------------------
  //
  // List refreshes
  //
  RECORD ARRAY FUNCTION GetApplicableTypes()
  {
    RECORD ARRAY contenttypes;

    FOREVERY (RECORD rec FROM this->widgets)
    {
      STRING lookuptype := rec.type;
      RECORD newtype := LookupContentType(lookuptype);

      IF(NOT RecordExists(newtype))
      {
        Print("The type '" || lookuptype || "' did not match any installed type\n");
        CONTINUE;
      }

      IF(NOT newtype.isembeddedobjecttype)
      {
        Print("Ignoring type '" || newtype.namespace || "', it is not a <widgettype>\n");
        CONTINUE;
      }

      IF(RecordExists(SELECT FROM contenttypes WHERE contenttypes.namespace = newtype.namespace))
        CONTINUE; //dupe
      INSERT newtype INTO contenttypes AT END;
    }
    RETURN contenttypes;
  }

  MACRO RefreshList()
  {
    RECORD ARRAY contenttypes := this->GetApplicableTypes();
    RECORD default_group :=
        [ namespace :=          "_default_group"
        , title :=              ":" || this->GetTid(".other")
        , tolliumicon :=        "database/schema"
        ];

    RECORD ARRAY allwidgettypes :=
        SELECT *
             , rowkey :=        namespace
             , title :=         GetTid(title)
             , primarygroup :=  primarygroup ?? default_group
             , icon :=          tolliumicon != "" ? ^contenttypes->GetIcon(tolliumicon) : 0
             , module :=        GetModuleNameFromResourcePath(siteprofile)
          FROM contenttypes;

     // Build the initial group list
     RECORD ARRAY groups := SELECT rowkey :=        Any(primarygroup.namespace)
                                 , namespace :=     Any(primarygroup.namespace)
                                 , title :=         GetTid(Any(primarygroup.title))
                                 , icon :=          Any(primarygroup.tolliumicon) != "" ? ^groups->GetIcon(Any(primarygroup.tolliumicon)) : 0
                                 , widgettypes :=   GroupedValues(allwidgettypes)
                                 , modules :=       (SELECT AS STRING ARRAY DISTINCT module FROM GroupedValues(allwidgettypes))
                              FROM allwidgettypes
                          GROUP BY primarygroup.namespace;


     // Gather groups that already have a duplicate title
     // If these groups cover multiple modules, they need to be split
     // (because otherwise splitting this group doesn't solve anything, but the module owner should be able to fix it)
     STRING ARRAY dupegrouptitles := SELECT AS STRING ARRAY ANY(ToUppercase(title))
                                         FROM groups
                                     GROUP BY namespace, ToUppercase(title)
                                       HAVING Length(GroupedValues(namespace)) > 1
                                              AND Length(DedupeStringArrays(CELL[ sa := modules ])) > 1;

     // If any widget title is duplicate and these dupes come from two different modules, we split the offending group
     // First build a list of duplicate titles and group their modules
     RECORD ARRAY dupetitles := SELECT primarygroup := ANY(primarygroup)
                                     , modules := GroupedValues(module)
                                  FROM allwidgettypes
                              GROUP BY primarygroup.namespace, ToUppercase(title)
                                HAVING Count(*) > 1;

     // Then get the groups with dupe titles that cover more than one module
     // (because otherwise splitting this group doesn't solve anything, but the module owner should be able to fix it)
     STRING ARRAY groupwithdupes := SELECT AS STRING ARRAY ANY(primarygroup.namespace)
                                         FROM dupetitles
                                        WHERE Length(GetSortedSet(modules)) > 1
                                     GROUP BY primarygroup.namespace;

     // We have both lists, build the list of groups
     RECORD ARRAY grouprows;
     FOREVERY(RECORD grouprec FROM groups)
     {
       IF(grouprec.namespace NOT IN groupwithdupes AND ToUppercase(grouprec.title) NOT IN dupegrouptitles) //If a group is sufficiently unique, copy one-by-one
       {
         INSERT grouprec INTO grouprows AT END;
         CONTINUE;
       }

       //This group needs to be split per module
       FOREVERY(RECORD modulepart FROM SELECT module, widgettypes := GroupedValues(widgettypes) FROM grouprec.widgettypes GROUP BY module)
         INSERT CELL[ rowkey := grouprec.rowkey || "#" || modulepart.module
                    , grouprec.namespace
                    , title := `${grouprec.title} (${modulepart.module})`
                    , grouprec.icon
                    , modulepart.widgettypes
                    ] INTO grouprows AT END;
     }

     ^groups->rows := grouprows;

    IF (Length(grouprows) = 1)
    {
      ^groups->selection := grouprows[0];
      ^groupspart->visible := FALSE;
      ^contenttypes->borders.left := TRUE;
    }
    ELSE
    {
      ^groupspart->visible := TRUE;
      ^contenttypes->borders.left := FALSE;
    }
  }

  MACRO OnGroupSelect()
  {
    ^contenttypes->rows := RecordExists(^groups->selection) ? ^groups->selection.widgettypes : RECORD[];
  }

  STRING FUNCTION Submit()
  {
    RETURN ^contenttypes->value;
  }
>;
