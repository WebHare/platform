<?wh
/** @topic consilio/api
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/queries.whlib" EXPORT require_allowed, require_required, require_prohibited;
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/contentproviders/contentprovider.whlib";
LOADLIB "mod::consilio/lib/internal/cqmatch.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT fetcher_trusted_ip;
LOADLIB "mod::consilio/lib/internal/fetcher_queue.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/linkreports.whlib";
LOADLIB "mod::consilio/lib/internal/finishhandler.whlib";
LOADLIB "mod::consilio/lib/internal/indexing.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/analysis.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";


CONSTANT RECORD default_contentsource_options := CELL[ maxgroupobjects := 0
                                                     , discardsummaries := FALSE
                                                     , enabled := TRUE
                                                     ];

/*

PUBLISHER SEARCH FIELDS



    RECORD ARRAY mapping := this->defaultmapping CONCAT
        [ [ name := "name", value := "" ]
        , [ name := "title", value := "" ]
        , [ name := "description", value := "" ]
        , [ name := "keywords", value := "" ]
        , [ name := "url", value := "", tokenized := FALSE ]
        , [ name := "whfsid", value := 0 ]
        , [ name := "whfsparent", value := 0 ]
        , [ name := "whfsobject", value := "", tokenized := FALSE ]

  whfsobject = file | folder

        , [ name := "whfstype", value := 0 ]
        , [ name := "whfspath", value := "" ]
        , [ name := "whfstree", value := "" ]
        , [ name := "date_creation", value := DEFAULT DATETIME ]
        , [ name := "date_modification", value := DEFAULT DATETIME ]
        ];



*/

INTEGER modecheck;

//Is this a valid indexname for use in Consilio?
PUBLIC BOOLEAN FUNCTION IsValidConsilioIndexName(STRING name)
{
  //We want to reserve '-' to detect suffixes, reserve names starting with _ and . for internal/dashboard stuff, and just limit names further to be on the safe side
  //48 is an estimate of what appeared to be reasonable
  RETURN NEW Regex("^[a-z][_a-z0-9]*$")->Test(name) AND Length(name) < 48;
}
/** @short Create a match query
    @long This query can be used to match a field with a given value. The matching behaviour depends on the matchtype and the
        type of the value. For INTEGER and STRING values, matchtype "=" means a literal match and matchtype "CONTAINS" means
        a value match. For INTEGER ARRAY and STRING ARRAY values, matchtype "IN" means that the fields must contain at least
        one of the values and matchtype "CONTAINS" means that the field must contain all of the values. For DATETIME values,
        the matchtype can be one of "<", "<=", "=", "=>" or ">" to search for date ranges.
    @param field The field to search
    @param matchtype How to match (possible values: 'IN', 'CONTAINS', '<', '<=', '=', '>=', '>')
    @param value The value to match
    @param options @private
    @return The match query
*/
PUBLIC RECORD FUNCTION CQMatch(STRING field, STRING matchtype, VARIANT value, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ datetimesupport := FALSE
      , __opensearch := FALSE //TODO: If Consilio indexmanager no longer has to be supported, make this the default and remove the whole modecheck stuff
      ], options, [ optional := ["__opensearch" ]]);

  IF (field = "")
    THROW NEW Exception("Query field is required for match query");

  //Have to move this optimization here, because some tests rely on CQMatch always doing this (so we can't wait for __delayed_cqmatch)
  IF (IsTypeIDArray(TypeID(value)) AND Length(value) = 0)
    RETURN CQNothing();

  //If unsure whether we'll be testing against OS or Indexmgr, delay evalation
  IF(NOT CellExists(options,'__opensearch'))
  {
    IF(modecheck = 0) //modecheck: 1 = mixed, 2 = ES, 23
    {
      INTEGER ARRAY activetypes := SELECT AS INTEGER ARRAY DISTINCT type FROM consilio.indexmanagers;
      modecheck := Length(activetypes) > 1 ? 1 : whconstant_consilio_indexmanager_legacybackend IN activetypes ? 2 : 3;
    }

    IF(modecheck = 1) //mixed
      RETURN CELL [ _type := "__delayed_cqmatch", __delayed_cqmatch := CELL[field,matchtype,value,options]];

    INSERT CELL __opensearch := modecheck = 3 INTO options;
  }

  //TODO temporarily split off to solve LOADLIB issues, move back when consilio is removed and all above hacks are unneeded?
  RETURN __CQMatch(field, matchtype, value, options);
}

/** Returns a query record that will match results in which a field values lies between the specified range
    @param field Field name
    @param lowerterm Lower range value
    @param includelower Whether to include exact matches of the lower range value
    @param upperterm Upper range value
    @param includeupper Whether to include exact matches of the upper range value
    @param options @private
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQRange(STRING field, VARIANT lowerterm, BOOLEAN includelower, VARIANT upperterm, BOOLEAN includeupper, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ datetimesupport := FALSE ], options);

  IF (field = "")
    THROW NEW Exception("Query field is required for range query");

  IF (TypeID(lowerterm) != TypeID(upperterm))
    THROW NEW Exception(`Range query lower term type '${GetTypeName(TypeID(lowerterm))}' not equal to upper term type '${GetTypeName(TypeID(upperterm))}'`);

  VARIANT lowersearchterm, uppersearchterm;
  IF (TypeID(lowerterm) = TypeID(INTEGER))
  {
    lowersearchterm := ToString(lowerterm);
    uppersearchterm := ToString(upperterm);
  }
  ELSE IF (TypeID(lowerterm) = TypeID(STRING))
  {
    lowersearchterm := STRING(lowerterm);
    uppersearchterm := STRING(upperterm);
  }
  ELSE IF (TypeID(lowerterm) = TypeID(DATETIME))
  {
    IF (NOT options.datetimesupport)
    {
      // Rewrite field name: 'field' to 'date_field', 'array.field@module' to 'array.date_field@module'
      IF (field LIKE "*.*@*")
      {
        INTEGER dot := SearchSubstring(field, ".") + 1;
        field := `${Left(field, dot)}date_${Substring(field, dot)}`;
      }
      ELSE
        field := `date_${field}`;
      lowersearchterm := FormatISO8601DateTime(lowerterm);
      uppersearchterm := FormatISO8601DateTime(upperterm);
    }
    ELSE
    {
      lowersearchterm := lowerterm;
      uppersearchterm := upperterm;
    }
  }
  ELSE
    THROW NEW Exception(`Invalid term type '${GetTypeName(TypeID(lowerterm))}' for range query`);

  RETURN [ _type := "range"
         , field := field
         , matchtype := (includelower ? "[" : "{") || (includeupper ? "]" : "}")
         , lowerterm := lowersearchterm
         , upperterm := uppersearchterm
         , boost := 1f
         ];
}

/** Returns a query record that will never match anything
    @return Consilio query record
*/
RECORD FUNCTION CQNothing()
{
  RETURN [ _type := "nothing"
         , boost := 1f
         ];
}

/** @short Returns a query record that matches all results that have a value for the specified field
    @param field Field to look at
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQHas(STRING field)
{
  IF (field = "")
    THROW NEW Exception("Query field is required for has query");

  RETURN [ _type := "exists"
         , field := field
         , boost := 1f
         ];
}

/** @short Returns a query record that matches all results
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQAll()
{
  RETURN [ _type := "all"
         , boost := 1f
         ];
}

/** @short Overwrites the boost factor of a query (which defaults to 1.0)
    @param query Query to adjust the boost factor of
    @param boost Boost factor
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQBoost(RECORD query, FLOAT boost)
{
  query.boost := boost;
  RETURN query;
}

/** @short Combine queries using AND
    @param inputqueries Consilio queries to combine
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQAnd(RECORD ARRAY inputqueries)
{
  RETURN CombineSubqueries(inputqueries, TRUE);
}

/** @short Combine queries using OR
    @param inputqueries Consilio queries to combine
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQOr(RECORD ARRAY inputqueries)
{
  RETURN CombineSubqueries(inputqueries, FALSE);
}

RECORD FUNCTION CombineSubqueries(RECORD ARRAY subqueries, BOOLEAN required)
{
  RECORD resultquery :=
      [ _type := "boolean"
      , subqueries := RECORD[]
      , boost := 1f
      ];
  FOREVERY (RECORD query FROM subqueries)
  {
    // If the first input query is a boolean query with the requested requirement, just add the other input queries
    IF (query._type = "boolean")
    {
      // If this subquery is a boolean query with the requested requirement, just add its subqueries directly
      IF (NOT RecordExists(SELECT FROM query.subqueries WHERE COLUMN required != VAR required OR prohibited))
      {
        // If this is the first query, replace the query
        IF (#query = 0)
          resultquery := query;
        ELSE
          resultquery.subqueries := resultquery.subqueries CONCAT query.subqueries;
      }
      ELSE
      {
        // Move every prohibited subquery a level up
        resultquery.subqueries := resultquery.subqueries CONCAT SELECT * FROM query.subqueries WHERE prohibited;
        DELETE FROM query.subqueries WHERE prohibited;
        // If there are any subqueries left, add the remaining boolean query
        IF (RecordExists(query.subqueries))
          INSERT CELL[ query, required, prohibited := FALSE ] INTO resultquery.subqueries AT END;
      }
    }
    ELSE IF(query._type = "nothing")
    {
      IF(required)  //In a serie of ANDs, nothing matches a poison.
      {
        resultquery.subqueries := RECORD[];
        RETURN resultquery;
      }
      //but for OR queries, just ignore it
    }
    ELSE
    {
      INSERT CELL[ query, required, prohibited := FALSE ] INTO resultquery.subqueries AT END;
    }
  }
  RETURN resultquery;
}

/** @short Negate query
    @param inputquery Consilio query to negate
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQNot(RECORD inputquery)
{
  IF(inputquery._type = "nothing")
    RETURN CQAll();
  ELSE IF(inputquery._type = "all")
    RETURN CQNothing();
  RETURN [ _type := "boolean"
         , subqueries := [ [ query := inputquery
                           , required := FALSE
                           , prohibited := TRUE
                           ]
                         ]
         , boost := 1f
         ];
}

/** @short Parse a user query
    @long If searches are saved (the save_searches option for %RunConsilioSearch, or the save_searches property of the
        SearchObject), this is the query that is saved (not the complete query that is sent to the index manager)
    @param userquery User query string
    @cell(string) options.querymode How to combine the toplevel terms, either 'AND' or 'OR' (defaults to 'AND')
    @cell(record array) options.defaultfields Fields to search for terms without explicit field specification
    @cell(string) options.defaultfields.field Field name
    @cell(float) options.defaultfields.boost Boost factor applied when a match is found in this field (defaults to 1.0)
    @cell(boolean) options.defaultfields.stemmed_field Set to true to also use stemming when searching for terms in this field
    @cell(integer) options.thesaurusid If set, use the thesaurus of this index id (legacy Consilio only)
    @cell(boolean) options.synonyms If the catalog synonyms list should be used (defaults to TRUE, Opensearch only)
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQParseUserQuery(STRING userquery, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ querymode := "AND"
      , defaultfields := DEFAULT RECORD ARRAY
      , thesaurusid := 0
      , synonyms := TRUE
      ],
      options,
      [ enums := [ querymode := [ "AND", "OR" ] ]
      , discard := [ "defaultrequire" ] //FIXME: If this parameter is removed from all calls to CQParseUserQuery, it can be removed here
      ]);

  RECORD ARRAY thesaurus;
  IF (options.thesaurusid != 0)
    thesaurus := GetIndexThesaurus(options.thesaurusid);

  userquery := TrimWhitespace(userquery);
  IF(userquery = "") //FIXME validate for other weird stuff that should require us to just discard this
    RETURN CQNothing();

  RETURN CELL[ _type := "user"
             , userquery
             , defaultrequire := options.querymode = "AND" ? require_required : require_allowed
             , options.defaultfields
             , thesaurus
             , options.synonyms
             , boost := 1f
             ];
}

/** @short Builds an aggregation query. Only works on ElasticSearch catalogs.
    @param field Field to aggregate over
    @param type Aggregation type ('count', 'min', 'max', terms", 'top_hits')
    @cell options.name Name of the query, to refer to this query (defaults to the used field)
    @cell options.size Nr of items to keep after ordering (only for aggregation types 'terms' and 'top_hits')
    @cell options.orderby Field to order over (only for aggregation types 'terms' and 'top_hits')
    @cell options.orderdesc Whether to reverse the ordering (only for aggregation types 'terms' and 'top_hits')
    @cell options.query Query to run the aggregation over (defaults to matching all results)
    @cell options.aggregations Subaggregations (returned by #CQAggregate)
    @return Consilio aggregation query record
*/
PUBLIC RECORD FUNCTION CQAggregate(STRING field, STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ name := ""
      , size := 0
      , orderby := ""
      , orderdesc := TRUE
      , query := DEFAULT RECORD
      , aggregations := DEFAULT RECORD ARRAY
      ], options);

  // Make sure either field or name is given
  IF (field = "" AND type != "count")
    THROW NEW Exception("Field is required for aggregation");
  ELSE IF (type = "count" AND options.name = "")
    THROW NEW Exception("Name option is required for aggregation type 'count'");

  // For top_hits, a size must be given
  IF (type IN [ "terms", "top_hits" ] AND options.size <= 0)
    THROW NEW Exception("A non-zero size option is required for aggregation type 'top_hits'");

  RECORD aggregation :=
      CELL[ _type := type
          , name := options.name ?? field
          , field
          , options.aggregations
          ];
  IF (type IN [ "min", "max", "count" ])
  {
  }
  ELSE IF (type IN [ "terms", "top_hits" ])
  {
    aggregation := CELL[ ...aggregation, options.size, options.orderby, options.orderdesc ];
  }
  ELSE
    THROW NEW Exception(`Invalid aggregation type '${type}'`);

  RECORD res := CELL[ aggregation ];
  IF (RecordExists(options.query))
    INSERT CELL query := options.query INTO res;
  RETURN res;
}

RECORD ARRAY FUNCTION Highlight(RECORD ARRAY results, STRING ARRAY fields, STRING class)
{
  FOREVERY(STRING opt FROM fields)
    fields[#opt] := ToUppercase(opt);

  FOREVERY(RECORD res FROM results)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(res))
    {
      IF(TypeID(cellrec.value)!=TypeID(STRING))
        CONTINUE;

      STRING newval := cellrec.value;
      IF(cellrec.name IN fields)
      {
        // OpenSearch seems to not add the pre tag when the highlight starts at the start of the string or add the post tag
        // when the highlight ends at the end of the string
        INTEGER firstclose := SearchSubstring(newval, "\x1C");
        IF (firstclose >= 0 AND SearchSubstring(newval, "\x1D") < 0)
          newval := "\x1D" || newval;
        INTEGER lastopen := SearchSubstring(newval, "\x1D");
        IF (lastopen >= 0 AND SearchSubstring(newval, "\x1C") < lastopen)
          newval := newval || "\x1C";

        //translate the markers to something that will survive EncodeHTML
        newval := Substitute(newval, "\x1D", '\uF8F0');
        newval := Substitute(newval, "\x1C", '\uF8F1');
        newval := EncodeHTML(newval);
        newval := Substitute(newval, "&#63728;", '<span class="' || EncodeValue(class) || '">');
        newval := Substitute(newval, "&#63729;", '</span>');
      }
      ELSE
      {
        newval := Substitute(newval, "\x1D", '');
        newval := Substitute(newval, "\x1C", '');
      }
      // Remove hyperlink markers
      newval := Substitute(newval, "\x1F", '');
      res := CellUpdate(res, cellrec.name, newval);
    }
    results[#res] := res;
  }
  RETURN results;
}

STRING FUNCTION ValidateIndexTag(STRING indextag)
{
  IF(indextag = "" OR indextag NOT LIKE "?*:?*" OR indextag LIKE "*:*:*")
    THROW NEW Exception(`Invalid indextag '${indextag}'`);

  RETURN indextag;
}

/** @short Get a token to access a consilio search engine's autosuggest API */
PUBLIC STRING FUNCTION GetConsilioRPCToken(STRING indextag, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ autosuggest := FALSE ], options);
  RETURN EncryptForThisServer("consilio:suggest", CELL [ c := GetCurrentDatetime(), t := indextag, ag := options.autosuggest ]);
}

RECORD ARRAY FUNCTION GetContentSourceMatches(INTEGER ARRAY candidateids)
{
  RETURN SELECT catalogid, fsobject
           FROM consilio.contentsources
          WHERE fsobject IN candidateids
                AND contentprovider = "publisher:webhare"
                AND orphansince = DEFAULT DATETIME
                AND tag NOT LIKE "$consilio$deleted$*"
       ORDER BY SearchElement(candidateids, fsobject) DESC; //prefer closest match

}

/** @short List configured index managers
    @cell (string) return.type Index type: 'opensearch'
    @cell (string) return.url URL to connect to the server */
PUBLIC RECORD ARRAY FUNCTION ListIndexManagers()
{
  BOOLEAN prefer_legacy_indexmanager := GetEnvironmentVariable("WEBHARE_PREFERINDEXMANAGER") != "";
  RETURN SELECT id
              , type := type = whconstant_consilio_indexmanager_legacybackend ? "legacy-indexmanager" : "opensearch"
              , isbuiltin := address IN ["builtin","builtin-opensearch"]
              , isdefault := address = (prefer_legacy_indexmanager ? "builtin" : "builtin-opensearch")
              , name
              , url := address = "builtin" ? "" : address = "builtin-opensearch" ? `http://localhost:${GetWebHareConfiguration().baseport + 6}/` : address
           FROM consilio.indexmanagers;
}

/** @short Look up the 'best' catalog for a folder/site
    @long Lookup the catalog to use. Prefers catalog that more specifically target this folder and catalogs that contain less other contentsources
    @param folder Folder it to look up. If you're not specifically targetting folders we recommend specifying the site id
    @return Catalog name (as suitable for RunConsilioSearch). Empty if no catalog found */
PUBLIC STRING FUNCTION GetConsilioPublisherCatalog(INTEGER folder)
{
  RECORD ARRAY candidates := GetContentSourceMatches([folder]);
  IF(Length(candidates) = 0)
    candidates := GetContentSourceMatches(GetWHFSTree(folder,0));

  IF(Length(candidates) = 0)
    RETURN "";

  IF(Length(candidates) > 1) //more than 1? eliminate all but the closest match
    DELETE FROM candidates AS c WHERE fsobject != candidates[0].fsobject;

  RECORD ARRAY catalogs := SELECT id, name
                             FROM consilio.catalogs
                            WHERE id IN (SELECT AS INTEGER ARRAY DISTINCT catalogid FROM candidates);

  IF(Length(catalogs) = 0)
    RETURN "";

  IF(Length(catalogs) =  1)
    RETURN catalogs[0].name;

  //Prefer the catalog which most closely matches what we need. resolve ties by taking the lowest catalogid (we need a stable result..)
  INTEGER smallestcatalog := SELECT AS INTEGER catalogid
                               FROM consilio.contentsources
                              WHERE catalogid IN (SELECT AS INTEGER ARRAY id FROM catalogs)
                           GROUP BY catalogid
                           ORDER BY COUNT(*), catalogid;

  RETURN SELECT AS STRING name FROM catalogs WHERE id = smallestcatalog;
}

/** @short Search an index
    @param indextag Index to search (module:tag)
    @param query Search query
    @cell(boolean) options.refresh Refresh the catalog before searching, making sure very recent changes are picked up
    @cell(string) options.language The language to use (legacy Consilio indices only, defaults to the language returned by
        %GetTidLanguage)
    @cell(integer) options.first The first result to return (0-based, defaults to 0)
    @cell(integer) options.count The number of results to return (-1 for all results, defaults to 100)
    @cell(boolean) options.save_searches If the search query should be saved for search reports (defaults to `FALSE`)
    @cell(integer) options.save_searches_site Set an explicit site id to save the query for (by default, Consilio tries to
        determine the site id by checking if the index contains only one publisher content source or by using
        %LookupPublisherUrl on the `restrict_url`)
    @cell(integer) options.summary_length The length of the summary to generate for each result (-1 for default length, 0 to
        prevent summary generation, defaults to -1)
    @cell(string) options.highlightclass The CSS class used to highlight found query words in the `highlightfields`
    @cell(string array) options.highlightfields The fields in which found query words should be highlighted
    @cell(string) options.summaryfield The name of the field to return the summary in (set to emtpy string to not return the
        summary, defaults to `"summary"`)
    @cell(string) options.scorefield The name of the field to return the result score in (set to empty string to not return
        scores, defaults to `""`)
    @cell(record) options.mapping The fields in this record will be returned in the search results and updated with the
        values returned by Consilio (defaults to `DEFAULT RECORD`, which returns all known fields)
    @cell(string) options.orderby Field to order over (defaults to `""`, which orders descending by score, can be set to the
        value of the `scorefield` option, doesn't have to be a field in the `mapping` option)
    @cell(boolean) options.orderdesc Whether to reverse the ordering (defaults to `TRUE` when ordering by score or `FALSE`
        when ordering by another field)
    @cell(record array) options.ordering Advanced results ordering, overrides the `orderby` and `orderdesc` options
    @cell(string) options.ordering.orderby Field to order over (required, can be set to the value of the `scorefield` option,
        doesn't have to be a field in the `mapping` option)
    @cell(boolean) options.ordering.orderdesc Whether to reverse the ordering (defaults to `TRUE` when ordering by score or
        `FALSE` when ordering by another field)
    @cell(string) options.ordering.ordermode Sort mode to use (one of `"min"`, `"max"`, `"sum"`, `"avg"` or `"median"`,
        defaults to `"min"` when sorting ascending or `"max"` when sorting descending)
    @cell(string) options.restrict_url For site searches: Only results with a URL starting with this restrict_url are
        returned
    @cell(string array) options.exclude_urls For site searches: Results with a URL starting with one of these exclude_urls
        are not returned
    @return The search result
    @cell(integer) return.totalcount The total number of results (not necessarily the number of returned results, if `count`
        is set to a value >= 0)
    @cell(record array) return.results The actual results
    @cell(string array) return.eventmasks Event masks to listen to for changes to this query
*/
PUBLIC RECORD FUNCTION RunConsilioSearch(STRING indextag, RECORD query, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ language := ""
      , first := 0
      , count := default_consilio_search_count
      , save_searches := FALSE
      , save_searches_site := 0
      , summary_length := -1
      , highlightclass := "consilio--highlight"
      , highlightfields := STRING[]
      , summaryfield := "summary"
      , scorefield := ""
      , mapping := DEFAULT RECORD
      , orderby := ""
      , orderdesc := FALSE
      , ordering := DEFAULT RECORD ARRAY
      , restrict_url := ""
      , exclude_urls := STRING[]
      , debug := FALSE
      , throwonfailure := FALSE
      , refresh := FALSE
      ], options, [ optional := [ "orderdesc" ] ]);

  indextag := ValidateIndexTag(indextag);
  FOREVERY (RECORD ordering FROM options.ordering)
    options.ordering[#ordering] := ValidateOptions(
        [ orderby := ""
        , orderdesc := ""
        , ordermode := ""
        ],
        ordering,
        [ title := "ordering"
        , required := [ "orderby" ]
        , optional := [ "orderdesc", "ordermode" ]
        , enums :=
            [ ordermode := [ "min", "max", "sum", "avg", "median" ]
            ]
        ]);

  STRING language := options.language ?? GetTidLanguage();
  IF(NOT RecordExists(query)
      OR (CellExists(query, "query") AND query.query._type = "nothing")
      OR (NOT CellExists(query, "query") AND query._type = "nothing")) //will not return anything
    RETURN [ totalcount := 0
           , results := RECORD[]
           , eventmasks := STRING[]
           ];

  OBJECT search_obj := OpenSearchObject(language, indextag);
  IF(options.refresh)
    OpenConsilioCatalogById(search_obj->catalogid)->Refresh();

  search_obj->highlightfields := options.highlightfields;
  search_obj->save_searches := options.save_searches;
  IF (options.save_searches)
    search_obj->session_site := options.save_searches_site;
  search_obj->summary_length := options.summary_length;
  search_obj->debug := options.debug;
  search_obj->throwonfailure := options.throwonfailure;
  IF (RecordExists(options.mapping))
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(options.mapping))
      IF(cellrec.name LIKE "_*")
        THROW NEW Exception("Internal fields may not be requested through mapping"); //TODO perhaps we should allow this? but how to deal with various conflicting settings between this and summaryfield/scorefield ?

    search_obj->empty_result_record := options.mapping;
  }

  search_obj->restrict_url := options.restrict_url;
  search_obj->exclude_urls := options.exclude_urls;

  IF (RecordExists(options.ordering))
    query := CELL[ ...query, options.ordering ];
  ELSE IF (options.orderby != "")
  {
    RECORD ordering := CELL[ options.orderby ];
    IF (CellExists(options, "orderdesc"))
      ordering := CELL[ ...ordering, options.orderdesc ];
    query := CELL[ ...query, ordering := [ ordering ] ];
  }
  IF (CellExists(query, "ordering") AND RecordExists(query.ordering))
  {
    // If orderinging on scorefield, ordering on "_score", otherwise if not already orderinging on "_score", add it for consistency
    INTEGER scoreordering :=
        (SELECT AS INTEGER #ordering + 1
           FROM query.ordering
          WHERE orderby = (options.scorefield ?? "_score")) - 1;
    IF (scoreordering >= 0)
      query.ordering[scoreordering].orderby := "_score";
    ELSE
      INSERT [ orderby := "_score" ] INTO query.ordering AT END;
  }

  RECORD results := search_obj->__SearchQuery(query, options.first, options.count, options.scorefield != "");
  IF(CellExists(results,'results'))
  {
    //Translate results to the requested format
    //(should probablyhave returned proper results in the first place, but wait until we're ready to deprecate older apis)
    //cant fix it using the mapping, as it's unset before __searchquery
    IF(options.summaryfield = "")
    {
      results.results := SELECT *, DELETE _summary, DELETE summary FROM results.results;
    }
    ELSE
    {
      results.results := SELECT AS RECORD ARRAY CellInsert(CELL[...result, DELETE _summary, DELETE summary], options.summaryfield, options.summary_length != 0 ? result._summary : "")
                             FROM results.results AS result;
    }

    IF(options.scorefield = "")
    {
      results.results := SELECT *, DELETE _score FROM results.results;
    }
    ELSE IF(ToUppercase(options.scorefield) != "_SCORE")
    {
      results.results := SELECT AS RECORD ARRAY CellInsert(CELL[...result, DELETE _score], options.scorefield, result._score)
                              FROM results.results AS result;
    }

    IF(Length(options.highlightfields) != 0)
      results.results := Highlight(results.results, options.highlightfields, options.highlightclass);
  }

  INSERT CELL eventmasks := [ "consilio:index." || search_obj->catalogid ] INTO results;
  RETURN results;
}

/** Get completion suggestions for a text
    @param indextag Index to search (module:tag)
    @param searchtext The text to get suggestions for
    @cell options.count maximum number of suggestions to return (0 for all matches, defaults to 10)
    @return List of suggestions
    @cell(string) return.text The suggestion text
    @cell(integer) return.num The number of documents which match the suggestion
*/
PUBLIC RECORD ARRAY FUNCTION GetConsilioSuggestions(STRING indextag, STRING searchtext, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ count := 10 ], options);
  indextag := ValidateIndexTag(indextag);

  OBJECT suggest_obj := OpenSuggestObject(indextag);

  // Return all terms starting with "bla"
  RETURN SELECT num := suggestions.count //rename, 'count' is an annoying column to select, it clashes with the global AND count(*)
              , text
           FROM suggest_obj->GetSuggestions(searchtext, options.count) AS suggestions;
}

/** Content source object
    @public
*/
STATIC OBJECTTYPE ContentSource
<
  RECORD contentsource;
  OBJECT __catalog;

  /// @type(integer) Id of this contentsource
  PUBLIC PROPERTY id(this->contentsource.id, -);

  /// @type(string) Tag of this contentsource
  PUBLIC PROPERTY tag(this->contentsource.tag, -);

  /// @type(boolean) True if this source is enabled (automatically indexing)
  PUBLIC PROPERTY enabled(GetEnabled, -);

  /// @type(string) Contentprovidertype (generally publisher:webhare or consilio:custom)
  PUBLIC PROPERTY contentprovider(this->contentsource.contentprovider, -);

  /// @type(integer) Base object for this content source
  PUBLIC PROPERTY fsobject(this->contentsource.fsobject, -);

  /// @type(object) Parent catalog
  PUBLIC PROPERTY catalog(this->__catalog, -);

  MACRO NEW(OBJECT catalog, RECORD contentsource)
  {
    this->__catalog := catalog;
    this->contentsource := contentsource;
  }

  BOOLEAN FUNCTION GetEnabled()
  {
    RETURN this->contentsource.status != -1;
  }

  /// Marks this content source as an orphan
  PUBLIC MACRO MarkAsOrphan()
  {
    UPDATE consilio.contentsources
           SET orphansince := GetCurrentDatetime()
           WHERE id = this->contentsource.id
                AND orphansince = DEFAULT DATETIME;

    GetConsilioFinishHandler()->mustcleanupindices := TRUE; //remove stale indices ASAP
  }

  /// Reactivate this content source
  PUBLIC MACRO ReactivateContentSource()
  {
    UPDATE consilio.contentsources
           SET orphansince := DEFAULT DATETIME
           WHERE id = this->contentsource.id;

    //FIXME schedule recheck on this countent source
    //GetConsilioFinishHandler()->mustcleanupindices := TRUE; //remove stale indices ASAP
  }

  /** Construct the provider for this source
      @return Contentprovider object
  */
  PUBLIC OBJECT FUNCTION OpenProvider()
  {
    RECORD cprec := SELECT * FROM GetContentProviders() WHERE name = this->contentsource.contentprovider;
    IF (NOT RecordExists(cprec))
      THROW NEW Exception(`Content provider '${this->contentsource.contentprovider}' not found for content source #${this->contentsource.id}`);

    OBJECT cpobj := cprec.createcontentprovider();

    // Decode the source-specific data
    RECORD source := this->contentsource;
    RECORD csdata := DecodeHSON(source.data);
    DELETE CELL data FROM source;
    INSERT CELL data := csdata INTO source;

    // Add the contentlinksonly flag (in the future this might be made configurable)
    INSERT CELL contentlinksonly := ReadRegistryKey("consilio.linkchecker.contentlinksonly") INTO source;

    source := CELL[ ...source
                  , contentsourceid := this->contentsource.id
                  , contentsourcetag := this->contentsource.tag
                  , catalogtag := this->catalog->tag
                  ];
    cpobj->Init(source);
    RETURN cpobj;
  }

  /** Update content source settings
      @record settings Settings to apply
      @cell(string) settings.definedby Definition location */
  PUBLIC MACRO UpdateContentSource(RECORD settings)
  {
    settings := ValidateOptions([ definedby := ""
                                , settings := DEFAULT RECORD
                                , tag := ""
                                , enabled := FALSE
                                ], settings, [ optional := [ "definedby", "tag", "enabled" ]
                                             , title := "settings"
                                             ]);

    //If 'settings' is set we'll be merging it with the current data. but this whole settings thing is ugly and should
    //probably be made transparant/flat... but we use it for contentobject which should preferably go away at all and
    //be taken from moduledefs
    IF(RecordExists(settings.settings))
    {
      RECORD newsettings := settings.settings;
      STRING cursettings := SELECT AS STRING data FROM consilio.contentsources WHERE id = this->id;
      IF(cursettings != "")
        newsettings := CELL[ ...DecodeHSON(cursettings), ...newsettings];
      settings := CELL[ ...settings, data := EncodeHSON(newsettings), DELETE settings ];
    }
    ELSE
    {
      DELETE CELL settings FROM settings;
    }

    IF(CellExists(settings,'tag'))
    {
      STRING curprovider := SELECT AS STRING contentprovider FROM consilio.contentsources WHERE id = this->id;
      IF(curprovider = "publisher:webhare" AND settings.tag != "")
        THROW NEW Exception(`A publisher:webhare contentsource may not have a tag`);
      IF(curprovider = "consilio:custom" AND settings.tag = "")
        THROW NEW Exception(`A consilio:custom contentsource must have a tag`);

      IF(settings.tag != ""
        AND RecordExists(SELECT FROM consilio.contentsources WHERE ToUppercase(COLUMN tag) = ToUppercase(settings.tag) AND id != this->id))
      {
        THROW NEW Exception(`A contentsource with tag '${settings.tag}' already exists (note: tags must currently be globally unique!)`);
      }
    }

    IF(CellExists(settings,'enabled'))
    {
      IF(settings.enabled AND NOT this->enabled)
        settings := CELL[ ...settings, status := 0 ];
      ELSE IF(NOT settings.enabled AND this->enabled)
        settings := CELL[ ...settings, status := -1 ];

      DELETE CELL enabled FROM settings;
    }

    UPDATE consilio.contentsources SET RECORD settings WHERE id = this->id;
    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    //quick&dirty metadata update
    this->contentsource := RECORD(SELECT * FROM consilio.contentsources WHERE id = this->id) ?? this->contentsource;
  }

  RECORD FUNCTION GetBaseDebugInfo()
  {
    RETURN CELL[ catalog := this->catalog->tag
               , catalogid := this->catalog->id
               , contentsource := this->tag ?? "fsobj #" || this->fsobject
               , contentsourceid := this->id
               , trace := ArraySlice(GetStackTrace(),2)
               ];
  }

  /** Reindex this entire content source
      @long Reindex all groups. The reindexing takes place in the background
      @cell(boolean) options.rebuild Force a rebuild, even if it doesn't look necessary
  */
  PUBLIC MACRO ReindexContentSource(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ rebuild := FALSE ], options);

    STRING command := (options.rebuild ? "CHECKINDEX " : "UPDATEINDEX ") || this->catalog->id || " " || this->id;
    IF(IsDebugTagEnabled("consilio:queues"))
      LogDebug("consilio", "ContentSource::ReindexContentSource", CELL[...this->GetBaseDebugInfo(), options.rebuild]);
    SendQueueManagerData(GetQueueDataFromCommand(command));
  }
  /** Reindex a group
      @long Reindex a specific group
      @param groupid Group to reindex
      @cell(boolean) options.rebuild Force a rebuild, even if it doesn't look necessary
      @cell(boolean) options.foreground Reindex in the foreground
  */
  PUBLIC MACRO ReindexGroup(STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , rebuild := FALSE
                                ], options);

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := options.rebuild ? "CHECKGROUP" : "UPDATEGROUP"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , indexid := this->catalog->id
              ];

      //TODO have a lowerlevel call 'checkgroup' thatis invoked on the content source and directly does listgroups3... as CheckGroup is reexecuting api.whlib to get the catalog
      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#CheckGroup")(data, [ rebuild := data.action != "UPDATEGROUP"
                                        , refresh := TRUE
                                        ]);
      IF (Length(result.errors) > 0)
        THROW NEW Exception(result.errors[0].message);
    }
    ELSE
    {
      STRING command := (options.rebuild ? "FASTCHECKGROUP " : "UPDATEGROUP ") || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::ReindexGroup", CELL[ ...this->GetBaseDebugInfo(), options.rebuild, groupid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /// Delete a group
  PUBLIC MACRO DeleteGroup(STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                ], options);

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "DELETEGROUP"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , indexid := this->catalog->id
              ];

      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#DeleteGroup")(data, [ refresh := TRUE ]);
      IF (RecordExists(result.error))
        THROW NEW Exception(result.error.message);
    }
    ELSE
    {
      STRING command := "DELETEGROUP " || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::DeleteGroup", CELL[ ...this->GetBaseDebugInfo(), groupid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /** Reindex an object
      @long Reindex a specific object in a specific group
      @param groupid Group to reindex the object in
      @param objectid Object to reindex
      @cell(boolean) options.foreground Reindex in the foreground
  */
  PUBLIC MACRO ReindexObject(STRING groupid, STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                ], options);

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "CHECKOBJECT"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , objectid
              , indexid := this->catalog->id
              ];

      //TODO have a lowerlevel call 'checkgroup' thatis invoked on the content source and directly does listgroups3... as CheckGroup is reexecuting api.whlib to get the catalog
      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#CheckObject")(data, [ refresh := TRUE ]);
      IF (Length(result.errors) > 0)
        THROW NEW Exception(result.errors[0].message);
    }
    ELSE
    {
      STRING command := ("CHECKOBJECT ") || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid) || " " || EncodeJSON(objectid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::ReindexObject", CELL[ ...this->GetBaseDebugInfo(), options.rebuild, groupid, objectid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /// Delete an object
  PUBLIC MACRO DeleteObject(STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                ], options);

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "DELETEOBJECT"
              , commanddate := GetCurrentDateTime()
              , objectid
              , indexid := this->catalog->id
              ];

      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#DeleteObject")(data, [ refresh := TRUE ]);
      IF (Length(result.errors) > 0)
        THROW NEW Exception(result.errors[0].message);
    }
    ELSE
    {
      STRING command := "DELETEOBJECT " || this->catalog->id || " " || EncodeJSON(objectid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::DeleteObject", CELL[ ...this->GetBaseDebugInfo(), objectid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /// Delete this content source
  PUBLIC MACRO DeleteSelf()
  {
    UPDATE consilio.contentsources
       SET tag := "$consilio$deleted$" || id
     WHERE id = this->id;

    this->contentsource.id := 0; //to be safe
    GetConsilioFinishHandler()->mustcleanupindices := TRUE; //remove deleted contentsources async
  }

  /// Wait for catalog being completey done
  PUBLIC MACRO WaitForIndexingDone(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    DoWaitForContentSourceDone(this->id, options);
    this->catalog->Refresh();
  }

  /// Get the path this source refers to
  PUBLIC STRING FUNCTION GetWHFSPath()
  {
    IF(this->contentsource.fsobject = 0)
      RETURN "";

    RETURN SELECT AS STRING whfspath FROM system.fs_objects WHERE id = this->contentsource.fsobject;
  }

>;

/** Catalog object
    @public
*/
STATIC OBJECTTYPE Catalog
<
  RECORD catalog;

  /// @type(integer) Id of this catalog
  PUBLIC PROPERTY id(this->catalog.id,-);

  /// @type(string) Tag of this catalog
  PUBLIC PROPERTY tag(this->catalog.name,-);

  /// @type(string) Language of this catalog
  PUBLIC PROPERTY lang(this->catalog.lang,-);

  /// @type(boolean) Is this a managed catalog?
  PUBLIC PROPERTY ismanaged(GetIsManaged,-);

  /// @type(string) Where was this catalog defined?
  PUBLIC PROPERTY definedby(this->catalog.definedby,-);

  MACRO NEW(RECORD catalog)
  {
    this->catalog := catalog;
  }

  /** List of indices for this catalog. First returned record is the primary index
      @cell(integer) id ID (for update and delete)
      @cell(string) indexname Name of the index on the indexmanager
      @cell(integer) indexmanager Id of the indexmanager
      @cell(string) type Type of the indexmanager (opensearch)
      @cell(boolean) primary Whether this is the primary catalogindex
  */
  PUBLIC RECORD ARRAY FUNCTION ListAttachedIndices()
  {
    RETURN
        SELECT catalog_indexmanagers.id
             , catalog_indexmanagers.indexname
             , catalog_indexmanagers.primary //FIXME under discussion, perhaps searchpriority or searchorder? don't rely on this yet...
             , indexmanager :=        indexmanagers.id
             , type := indexmanagers.type = whconstant_consilio_indexmanager_legacybackend ? "legacy-indexmanager" : "opensearch"
          FROM consilio.indexmanagers
             , consilio.catalog_indexmanagers
         WHERE catalog_indexmanagers.catalogid = this->catalog.id
               AND indexmanagers.id = catalog_indexmanagers.indexmanager
               AND NOT deleted
      ORDER BY primary DESC;
  }

  BOOLEAN FUNCTION GetIsManaged()
  {
    RETURN this->catalog.type = whconstant_consilio_catalogtype_managed;
  }

  /** Describe how the catalog is stored. Useful for debugging
      @return Storage info, will not contain linefeeds but should be considered free form (so we can extend/modify it later) */
  PUBLIC STRING FUNCTION GetStorageInfo()
  {
    STRING ARRAY storage;
    FOREVERY(RECORD attachedindex FROM this->ListAttachedIndices())
      INSERT attachedindex.indexname INTO storage AT END;

    IF(Length(storage) >= 1)
      RETURN `${this->tag} => (${Detokenize(storage,', ')})`;
    ELSE
      RETURN `${this->tag} => (unattached)`;
  }

  /// Explicitly refresh. You'll sometimes need this to ensure visibility of recent index changes
  PUBLIC MACRO Refresh()
  {
    //TODO cache these ids... they won't change that often..
    //TODO suffixes? or just always attach a wildcard? or should the caller ghive us the suffix(es) to  refresh?
    FOREVERY(RECORD opensearch FROM SELECT * FROM this->ListAttachedIndices() WHERE type = "opensearch")
      RefreshIndexManager(opensearch.indexmanager, this->id);
  }

  /** Attach an index (backing store) to a catalog
      @parmm indexmanager Index manager to use. Use 0 for the builtin index manager
      @cell(string) options.indexname Index name
      @return ID of the newly attached index*/
  PUBLIC INTEGER FUNCTION AttachIndex(INTEGER indexmanager, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ indexname := "" ], options);
    RECORD usemgr := SELECT * FROM ListIndexManagers() WHERE VAR indexmanager = 0 ? isdefault : id = VAR indexmanager;
    IF(NOT RecordExists(usemgr))
      THROW NEW Exception(indexmanager != 0 ? `No such indexmanager #${indexmanager}` : "No default indexmanager configured");

    IF(options.indexname = "")
    {
      IF(usemgr.isbuiltin)
        options.indexname := __GenerateIndexName();
      ELSE
        THROW NEW Exception(`An indexname is required when using an external indexmanager`);
    }

    //OpenSearch requires lowercasen names;
    IF(options.indexname != ToLowercase(options.indexname))
      THROW NEW Exception(`An indexname must be lowercase`);
    IF(NOT IsValidConsilioIndexName(options.indexname))
      THROW NEW Exception(`Invalid indexname '${options.indexname}'`);

    INTEGER newid := MakeAutonumber(consilio.catalog_indexmanagers, "id");
    INSERT CELL[ id := newid
               , catalogid :=    this->id
               , indexmanager := usemgr.id
               , options.indexname
               , primary := Length(SELECT FROM consilio.catalog_indexmanagers WHERE catalogid = this->id AND NOT deleted) = 0
               , rebuild :=      TRUE
               ] INTO consilio.catalog_indexmanagers;

    // Ensure the indexes are created at the indexmanagers
    IF (this->ismanaged)
      EnsureIndexManagerIndex(this->id);

    RETURN newid;
  }

  PUBLIC MACRO DetachIndex(INTEGER indexid)
  {
    RECORD todelete := SELECT * FROM consilio.catalog_indexmanagers WHERE id = indexid AND catalogid = this->id;
    IF(NOT RecordExists(todelete))
      THROW NEW Exception(`No such attached index #${indexid}`);

    UPDATE consilio.catalog_indexmanagers
       SET deleted := TRUE
     WHERE id = VAR indexid;

    GetConsilioFinishHandler()->mustcleanupindices := TRUE; //remove stale indices ASAP (TODO only for builtin indexmanagers?)
  }

  /** Update catalog settings
      @param settings Settings to apply
      @cell(string) settings.definedby Definition location
  */
  PUBLIC BOOLEAN FUNCTION UpdateCatalog(RECORD settings)
  {
    settings := ValidateOptions([ definedby := ""
                                , lang := ""
                                ], settings, [ optional := ["*"]
                                             , title := "settings"
                                             ]);

    RECORD catalog_index_updates;

    // If the catalog language changes, the catalog has to be rebuilt
    BOOLEAN language_changed := CellExists(settings, "lang") AND settings.lang != this->lang;
    IF (language_changed AND this->ismanaged)
      INSERT CELL rebuild := TRUE INTO catalog_index_updates;

    UPDATE consilio.catalogs SET RECORD settings WHERE id = this->id;

    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    this->catalog := SELECT * FROM consilio.catalogs WHERE id = this->id;

    IF (language_changed)
    {
      // Note: this doesn't update the 'synonym' filter, so we don't have to explicitly add that here
      RECORD indexsettings :=
          [ analysis := GetAnalysisForLanguage(settings.lang)
          ];
      UpdateIndexManagerIndexSettings(this->id, indexsettings);
    }
    RETURN language_changed;
  }

  /// Delete this catalog
  PUBLIC MACRO DeleteSelf()
  {
    UPDATE consilio.catalogs SET name := "$consilio$deleted$" || id WHERE id = this->id;
    UPDATE consilio.contentsources SET tag := "$consilio$deleted$" || id WHERE catalogid = this->id;

    GetPrimary()->BroadCastOnCommit("consilio:indiceschanged", DEFAULT RECORD);
    this->catalog.id := 0; //to be safe

    GetConsilioFinishHandler()->mustcleanupindices := TRUE; //remove stale indices ASAP
  }

  MACRO DoEnsureIndex(STRING suffix, STRING ARRAY fieldgroups, BOOLEAN strict, INTEGER ARRAY contentsourceids)
  {
    EnsureIndexManagerIndex(this->id, CELL
        [ suffix
        , throwonfailure := TRUE
        , synonyms := SELECT AS STRING ARRAY `# wordgroup ${wordgroupid}\n` || Detokenize(words, ", ") FROM this->GetSynonyms()
        ]);

    // Legacy backend doesn't support mapping
    IF (NOT RecordExists(SELECT FROM this->ListAttachedIndices() WHERE type = "opensearch"))
      RETURN;

    RECORD newmapping;
    IF (Length(fieldgroups) = 0)
    {
      fieldgroups :=
          SELECT AS STRING ARRAY fieldgroup
            FROM ToRecordArray(Tokenize((SELECT AS STRING COLUMN fieldgroups FROM consilio.catalogs WHERE id = this->id), " "), "fieldgroup")
           WHERE fieldgroup != "";
    }
    IF(Length(fieldgroups) = 0)
    {
      TRY
        newmapping := GetIndexFieldDefinition(SELECT AS STRING name FROM consilio.catalogs WHERE id = this->id);
      CATCH (OBJECT e)
        IF (NOT this->ismanaged)
          THROW;
    }
    ELSE
    {
      newmapping := GetFieldgroupsFieldDefinition(fieldgroups, strict);
    }
    IF (Length(contentsourceids) > 0)
    {
      RECORD ARRAY basefields := this->ismanaged ? defaultmappingfields : RECORD[];
      IF (RecordExists(newmapping))
        basefields := basefields CONCAT newmapping.properties;
      RECORD ARRAY properties := GetContentSourcesMapping(contentsourceids, basefields);
      IF (RecordExists(properties))
      {
        IF (NOT RecordExists(newmapping))
          newmapping := CELL[ properties, strict ];
        ELSE
          newmapping.properties := properties;
      }
    }
    IF (NOT RecordExists(newmapping))
      RETURN;

    //Updating overwrites dynamic_templates, but our prepared mapping may be incomplete, so copy existing dynamic mappings
    //TODO how to remove a dynamic template?
    //FIXME lock around these steps! we update dynamic_templates so shouldn't risk racing
    RECORD currentmapping := GetIndexManagerMapping(this->id, CELL[ suffix, throwonfailure := TRUE ]);
    RECORD finalupdate := PrepareMappingUpdate(newmapping);

    STRING ARRAY newtemplates;
    FOREVERY(RECORD newtemplate FROM finalupdate.dynamic_templates)
      INSERT UnpackRecord(newtemplate)[0].name INTO newtemplates AT END;

    FOREVERY(RECORD templ FROM currentmapping.dynamic_templates)
    {
      STRING name := UnpackRecord(templ)[0].name;
      IF(name NOT IN newtemplates)
        INSERT templ INTO finalupdate.dynamic_templates AT END; //keep existing
    }

    EnsureIndexManagerMapping(this->id, finalupdate, CELL[ suffix, throwonfailure := TRUE ]);
  }

  /** @short Get the catalog's synonyms list
      @return The grouped synonyms
      @cell(integer) wordgroupid Word group id
      @cell(string array) words The words within this group
  */
  PUBLIC RECORD ARRAY FUNCTION GetSynonyms()
  {
    RETURN
        SELECT wordgroupid := wordgroup
             , words := GroupedValues(word)
          FROM consilio.thesaurus
         WHERE catalogid = this->id
         GROUP BY wordgroup;

  }

  /** @short Update the catalog's synonyms list
      @param words The grouped synonyums
      @includecelldef #GetSynonyms.return
  */
  PUBLIC MACRO SetSynonyms(RECORD ARRAY words)
  {
    INTEGER ARRAY updated;
    BOOLEAN anychanges;
    FOREVERY (RECORD row FROM words)
    {
      INTEGER wordgroupid := CellExists(row, "wordgroupid")
          ? row.wordgroupid
          : (SELECT AS INTEGER Max(wordgroup) FROM consilio.thesaurus) + 1;
      IF (CellExists(row, "wordgroupid"))
        INSERT row.wordgroupid INTO updated AT END;

      RECORD ARRAY oldwordgroup := SELECT id, word FROM consilio.thesaurus WHERE wordgroup = wordgroupid;
      STRING ARRAY newwordgroup := row.words;

      // Delete old words that are not in the new words group
      FOREVERY (RECORD todelete FROM oldwordgroup)
        IF (todelete.word NOT IN newwordgroup)
        {
          DELETE FROM consilio.thesaurus WHERE id = todelete.id;
          anychanges := TRUE;
        }

      // Add new words that are not in the old words group
      STRING ARRAY toadd := ArrayDelete(newwordgroup, SELECT AS STRING ARRAY word FROM oldwordgroup);
      FOREVERY (STRING word FROM toadd)
      {
        INSERT INTO consilio.thesaurus(catalogid, word, wordgroup)
               VALUES(this->id, word, wordgroupid);
        anychanges := TRUE;
      }
    }
    IF (RecordExists(SELECT FROM consilio.thesaurus WHERE catalogid = this->id AND wordgroup NOT IN updated))
    {
      DELETE FROM consilio.thesaurus WHERE catalogid = this->id AND wordgroup NOT IN updated;
      anychanges := TRUE;
    }

    IF (anychanges)
    {
      // Update the synonyms list of the 'synonym' filter (the rest of the settings are left alone)
      RECORD settings :=
          [ analysis :=
            [ filter :=
              [ synonym :=
                [ synonyms := SELECT AS STRING ARRAY `# wordgroup ${wordgroupid}\n` || Detokenize(synonyms.words, ", ") FROM this->GetSynonyms() AS synonyms ]
              ]
            ]
          ];
      //TODO: This doesn't update the synonyms for suffixed indices
      UpdateIndexManagerIndexSettings(this->id, settings);
    }
  }

  RECORD FUNCTION GetBaseDebugInfo()
  {
    RETURN CELL[ catalog := this->tag
               , catalogid := this->id
               , trace := ArraySlice(GetStackTrace(),2)
               ];
  }
>;

STATIC OBJECTTYPE UnmanagedCatalog EXTEND Catalog
<
  //have we ensured yet that the index exists?
  STRING ARRAY ensured;

  /** @short Add objects to this catalog
      @param objects The objects to add
      @cell(string) objects.objectid Unique objectid. Reusing this will replace the document in the index+suffix combo
      @cell(record) objects.documentfields Document fields
      @cell(string) options.suffix Use this parameter to create a subindex with this suffix
      @cell(boolean) options.synchronous Wait for the added documents to become visible
  */
  PUBLIC MACRO AddObjects(RECORD ARRAY objects, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ suffix := ""
                                , chunksize := 128
                                , synchronous := FALSE
                                ], options);
    //are these still relevant? only used by legacy consilio
    // @cell objects.suggestfields
    // @cell objects.suggestprefixes

    IF(options.suffix NOT IN this->ensured)
      this->EnsureIndex(CELL[ options.suffix ]);

    objects := SELECT objectid, documentfields FROM objects;
    FOREVERY (RECORD chunk FROM SELECT docs := GroupedValues(objects) FROM objects GROUP BY #objects / options.chunksize)
    {
      AddIndexManagerObjects(this->id, DEFAULT RECORD, "", chunk.docs, [ throwonfailure := TRUE, suffix := options.suffix, refresh := options.synchronous ]);
    }
  }

  /** @short Delete objects from this catalog
      @param objectids Delete objects with these objectids in the index+suffix combo
      @cell(string) options.suffix Use this parameter to create a subindex with this suffix
      @cell(boolean) options.synchronous Wait for the added documents to become visible
  */
  PUBLIC MACRO DeleteObjects(STRING ARRAY objectids, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ suffix := ""
                                , chunksize := 128
                                , synchronous := FALSE
                                ], options);

    FOR (INTEGER curchunk := 0; curchunk < Length(objectids); curchunk := curchunk + options.chunksize)
    {
      STRING ARRAY chunk := ArraySlice(objectids, curchunk, options.chunksize);
      DeleteIndexManagerObjects(this->id, 0, chunk, [ throwonfailure := TRUE, suffix := options.suffix, refresh := options.synchronous ]);
    }
  }

  /** @short Make sure the (sub)index exists on the index manager
      @cell(string) options.suffix Use this parameter to create a subindex with this suffix
      @cell(string) options.fieldgroups Override fieldgroups used to ensure mapping
      @cell(boolean) options.strict Set strict setting when overriding the field group. defaults to TRUE
  */
  PUBLIC MACRO EnsureIndex(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ suffix := ""
                               , fieldgroups := STRING[]
                               , strict := TRUE
                               ], options);

    this->DoEnsureIndex(options.suffix, options.fieldgroups, options.strict, INTEGER[]);

    IF(options.suffix NOT IN this->ensured AND Length(options.fieldgroups) = 0) //overriding fieldgroups does not count as having guaranteed ensurance
      INSERT options.suffix INTO this->ensured AT END;
  }

  /** @short Delete the (sub)index from the index manager
      @cell(string) options.suffix Set this parameter to only delete the subindex with this suffix
  */
  PUBLIC MACRO DeleteIndex(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([suffix := ""], options);

    //FIXME multiindex support.
    RECORD res := DeleteIndexManagerContentSource(this->ListAttachedIndices()[0].indexmanager, this->id, 0, CELL[ options.suffix ]);
    IF(res.status != SearchOk AND res.status != "indexnotfound") //it's fine if the index is already deleted (this can happen because we currently mark indices as deleted but DeleteIndexManagerContentSource still attempts to delete them again)
      THROW NEW Exception(`Unable to DeleteIndex: ${res.status}`);

    IF(options.suffix IN this->ensured)
      DELETE FROM this->ensured AT SearchElement(this->ensured, options.suffix);
  }

  /** @short List suffixes created in this index
      @return The suffixes
      @cell(string) return.suffix Suffix name. Can be empty for the main index*/
  PUBLIC RECORD ARRAY FUNCTION ListSuffixes()
  {
    RECORD indexmgr := this->ListAttachedIndices();
    IF(NOT RecordExists(indexmgr) OR indexmgr.type != "opensearch")
      RETURN RECORD[] ; //TODO or should we throw ?

    RETURN ListOpenSearchIndexSuffixes(indexmgr.indexmanager, indexmgr.indexname);
  }
>;

STATIC OBJECTTYPE ManagedCatalog EXTEND Catalog
<
  /** @short Make sure the (sub)index exists on the index manager
      @cell(string) options.fieldgroups Override fieldgroups used to ensure mapping
      @cell(boolean) options.strict Set strict setting when overriding the field group. defaults to TRUE
  */
  PUBLIC MACRO EnsureIndex()
  {
    this->DoEnsureIndex("", STRING[], TRUE, SELECT AS INTEGER ARRAY id FROM this->ListContentSources());
  }

  /** List the contentsources in this catalog
      @return List of contentsources
      @cell(integer) return.id Id of the contentsource
      @cell(string) return.contentprovider Content provider type
      @cell(string) return.contentobject Content objecttype implement with this source
      @cell(string) return.tag Tag of the contentsource
      @cell(string) return.title Title of the contentsource
      @cell(integer) return.fsobject Associated filesystem object
      @cell(boolean) return.isorphan Whether the contentsource is an orphan
  */
  PUBLIC RECORD ARRAY FUNCTION ListContentSources(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ __withdeleted := FALSE ], options);
    RECORD ARRAY sources :=
        SELECT TEMPORARY settings := (data = "" ? DEFAULT RECORD : DecodeHSON(data))
             , id
             , contentprovider
                                //TODO lookup contentobject from moduledefs where possible, bad experiences with db-stored HS references
             , contentobject := CellExists(settings, 'contentobject') AND settings.contentobject != "" ? settings.library || "#" || settings.contentobject : ""
             , tag
             , title
             , fsobject
             , isorphan := orphansince != DEFAULT DATETIME
             , isdeleted := tag LIKE "$consilio$deleted$*" //flagged as deleted
                            OR (contentprovider = "publisher:webhare"  //contentsource whose target folder is deleted
                                AND fsobject = 0
                                AND NOT CellExists(settings,"folder") //AND has been converted by setcontentsourcefsobjects.whscr
                               )
             , definedby
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id;

    IF (NOT options.__withdeleted)
      sources := SELECT *, DELETE isdeleted FROM sources WHERE NOT isdeleted;

    RETURN sources;
  }

  OBJECT FUNCTION CreateContentSource(RECORD csourcesettings)
  {
    INTEGER srcid := MakeAutonumber(consilio.contentsources, "id");
    csourcesettings := CELL[ id := srcid
                           , catalogid := this->catalog.id
                           , csourcesettings.maxgroupobjects
                           , csourcesettings.discardsummaries
                           , csourcesettings.definedby
                           , ...csourcesettings
                           , data := EncodeHSON(CellExists(csourcesettings,'data') ? csourcesettings.data : DEFAULT RECORD)
                           , status := csourcesettings.enabled ? 0 : -1
                           , DELETE enabled
                           ];

    INSERT csourcesettings INTO consilio.contentsources;

    OBJECT contentsource := this->OpenContentSourceById(srcid);
    INSERT PTR contentsource->ReindexContentSource() INTO GetConsilioFinishHandler()->execoncommit AT END;

    contentsource->OpenProvider()->UpdateContentSourceFields();
    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    this->EnsureIndex();

    RETURN contentsource;
  }

  /** Add a publisher content source
      @param targetfolder Folder to index
      @cell options.maxgroupobjects Maximum number of objects within a group that will be indexed
      @cell options.discardsummaries Whether to discard summaries
      @cell options.definedby Use to describe who added this custom content source was added
      @rreutn Newly created content source
  */
  PUBLIC OBJECT FUNCTION AddPublisherContentSource(INTEGER targetfolder, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options :=  ValidateOptions(
        CELL[ ...default_contentsource_options
            , definedby :=            "AddPublisherContentSource from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
            ], options);

    FOREVERY (RECORD contentsource FROM
        SELECT id, fsobject
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id
               AND contentprovider = "publisher:webhare"
               AND tag NOT LIKE "$consilio$deleted$*")
    {
      IF ((contentsource.fsobject = targetfolder) OR IsFolderAncestorOf(contentsource.fsobject, targetfolder)) // targetfolder is already covered by searchroot
      {
        STRING path := SELECT AS STRING whfspath FROM system.fs_objects WHERE id = targetfolder;
        THROW NEW Exception(`A contentsource containing folder #${targetfolder} (${path}) already exists in catalog '${this->tag}'`);
      }
      ELSE IF (IsFolderAncestorOf(targetfolder, contentsource.fsobject)) // folderid contains searchroot
      {
        UPDATE consilio.contentsources SET tag := "$consilio$deleted$" || id || ":" || tag WHERE id = contentsource.fsobject; // remove contained folder
      }
    }

    RETURN this->CreateContentSource(CELL[ ...options
                                          , contentprovider := "publisher:webhare"
                                          , fsobject := targetfolder
                                          ]);
  }

  INTEGER FUNCTION CheckFolderInIndex(INTEGER indexid, INTEGER folderid, INTEGER searchid DEFAULTSTO -1)
  {
    INTEGER res;
    FOREVERY (RECORD contentsource FROM (
        SELECT id, fsobject
          FROM consilio.contentsources
         WHERE id != searchid
               AND contentsources.catalogid = VAR indexid
               AND contentprovider = "publisher:webhare"
               AND tag NOT LIKE "$consilio$deleted$*"))
    {
      IF ((contentsource.fsobject = folderid) OR IsFolderAncestorOf(contentsource.fsobject, folderid)) // folderid is already covered by searchroot
      {
        res := -1;
        BREAK;
      }
      ELSE IF (IsFolderAncestorOf(folderid, contentsource.fsobject)) // folderid contains searchroot
      {
        res := 1;
        UPDATE consilio.contentsources SET tag := "$consilio$deleted$" || id || ":" || tag WHERE id = contentsource.fsobject; // remove contained folder
      }
    }
    RETURN res;
  }

  /** Add a new custom content source to a index
      @param tag Tag of the new content source
      @param contentsourceobject Library and name of object that handles indexing (lib#name)
      @cell options.maxgroupobjects Maximum number of objects within a group that will be indexed
      @cell options.discardsummaries Whether to discard summaries
      @cell options.definedby Use to describe who added this custom content source was added
      @cell options.contentcheckinterval Interval between rechecks (defaults to -1, no recheck)
      @cell options.folder Associated folder
      @cell options.title Title for the content source
  */
  PUBLIC OBJECT FUNCTION AddCustomContentSource(STRING tag, STRING contentsourceobject, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(tag="" OR tag NOT LIKE "?*:?*" OR tag LIKE "*:*:*")
      THROW NEW Exception(`Invalid content source tag '${tag}'`);

    options :=  ValidateOptions(
        CELL[ ...default_contentsource_options
            , definedby :=            "AddCustomContentSource from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
            , contentcheckinterval := -1
            , title := ""
            ], options);

    IF (RecordExists(SELECT FROM consilio.contentsources WHERE ToUppercase(COLUMN tag) = ToUppercase(VAR tag)))
      THROW NEW Exception(`A contentsource with tag '${tag}' already exists (note: tags must currently be globally unique!)`);

    STRING ARRAY parts := Tokenize(contentsourceobject, "#");
    RECORD settings :=
        [ library :=              parts[0]
        , contentobject :=        parts[1]
        , contentcheckinterval := options.contentcheckinterval
        , lastcontentscheck :=    ""
        ];

    RETURN this->CreateContentSource(CELL[ ...options
                                          , contentprovider := "consilio:custom"
                                          , tag
                                          , data := settings
                                          , DELETE contentcheckinterval
                                          ]);
  }

  /** @short Open catalog by tag
      @param tag Tag of the contentsource
      @return(object #ContentSource) The content source object
  */
  PUBLIC OBJECT FUNCTION OpenContentSource(STRING tag)
  {
    RECORD match :=
        SELECT *
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id
               AND ToUppercase(contentsources.tag) = ToUppercase(VAR tag);
    IF(RecordExists(match))
      RETURN NEW ContentSource(this, match);
    ELSE
      RETURN DEFAULT OBJECT;
  }

  /** Rebuild all content sources in this catalog
      @long Force reindexing of everything in this content source. The check takes place in the background */
  //PUBLIC MACRO RebuildAllContentSources()
  //{
  //  STRING command := "CHECKINDEX " || this->catalog->id || " " || this->id;
  //  IF(IsDebugTagEnabled("consilio:queues"))
  //    LogDebug("consilio", "ContentSource::RebuildContentSource", this->GetBaseDebugInfo());
  //  SendQueueManagerData(GetQueueDataFromCommand(command));
  //}

  /** @short Open catalog by id
      @param id Id of the contentsource
      @return(object #ContentSource) The content source object
  */
  PUBLIC OBJECT FUNCTION OpenContentSourceById(INTEGER id)
  {
    RECORD match := SELECT * FROM consilio.contentsources WHERE contentsources.id = VAR id AND tag NOT LIKE "$consilio$deleted$*";
    IF(RecordExists(match))
      RETURN NEW ContentSource(this, match);
    ELSE
      RETURN DEFAULT OBJECT;
  }

  PUBLIC MACRO ReindexCatalog(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ rebuild := FALSE ], options);

    STRING command := (options.rebuild ? "CHECKINDEX " : "UPDATEINDEX ") || this->id;
    IF(IsDebugTagEnabled("consilio:queues"))
      LogDebug("consilio", "ManagedCatalog::ReindexCatalog", CELL[...this->GetBaseDebugInfo(), options.rebuild]);
    SendQueueManagerData(GetQueueDataFromCommand(command));
  }
>;

/** @short List all Consilio catalogs
    @param options Options
    @return List of catalogs
    @cell return.id Catalog id
    @cell return.tag Catalog tag
    @cell(boolean) return.ismanaged True if this is managed catalog (supports contentsources)
    @cell return.indexmanager Index manager
*/
PUBLIC RECORD ARRAY FUNCTION ListConsilioCatalogs(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ __withdeleted := FALSE ], options);
  RECORD ARRAY catalogs :=
      SELECT id
           , tag := name
           , ismanaged := type = whconstant_consilio_catalogtype_managed
        FROM consilio.catalogs
       WHERE options.__withdeleted OR name NOT LIKE "$consilio$deleted$*";
  RECORD ARRAY indexmanagers :=
      SELECT indexmanager
           , id := catalogid
        FROM consilio.catalog_indexmanagers
       WHERE catalogid IN (SELECT AS INTEGER ARRAY id FROM catalogs)
         AND NOT deleted
    ORDER BY primary DESC;
  catalogs := JoinArrays(catalogs, "id", indexmanagers, [ indexmanager := 0 ], [ rightouterjoin := TRUE ]);
  IF (options.__withdeleted)
    catalogs := SELECT *, isdeleted := tag LIKE "$consilio$deleted$*" FROM catalogs;
  RETURN catalogs;
}

/** @short Open catalog by tag
    @param tag Catalog tag
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION OpenConsilioCatalog(STRING tag)
{
  RECORD match :=
      SELECT * FROM consilio.catalogs
       WHERE ToUppercase(name) = ToUppercase(tag)
             AND name NOT LIKE "$consilio$deleted$*";
  IF(RecordExists(match))
  {
    IF (match.type = whconstant_consilio_catalogtype_unmanaged)
      RETURN NEW UnmanagedCatalog(match);
    RETURN NEW ManagedCatalog(match);
  }
  ELSE
    RETURN DEFAULT OBJECT;
}

/** @short Open catalog by id
    @param id Catalog id
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION OpenConsilioCatalogById(INTEGER id)
{
  RECORD match :=
      SELECT * FROM consilio.catalogs
       WHERE catalogs.id = VAR id
             AND name NOT LIKE "$consilio$deleted$*";
  IF(RecordExists(match))
  {
    IF (match.type = whconstant_consilio_catalogtype_unmanaged)
      RETURN NEW UnmanagedCatalog(match);
    RETURN NEW ManagedCatalog(match);
  }
  ELSE
    RETURN DEFAULT OBJECT;
}

/** @short Open content source by tag
    @param tag Content source tag
    @return(object #ContentSource) The content source object
*/
PUBLIC OBJECT FUNCTION OpenContentSource(STRING tag)
{
  INTEGER catalogid :=
      SELECT AS INTEGER contentsources.catalogid
        FROM consilio.contentsources
       WHERE ToUppercase(contentsources.tag) = ToUppercase(VAR tag);
  OBJECT catalog := OpenConsilioCatalogById(catalogid);
  RETURN ObjectExists(catalog) ? catalog->OpenContentSource(tag) : DEFAULT OBJECT;
}

/** @short Open content source by id
    @param id Content source id
    @return(object #ContentSource) The content source object
*/
PUBLIC OBJECT FUNCTION OpenContentSourceById(INTEGER id)
{
  INTEGER catalogid :=
      SELECT AS INTEGER contentsources.catalogid
        FROM consilio.contentsources
       WHERE contentsources.id = VAR id
             AND tag NOT LIKE "$consilio$deleted$*";
  OBJECT catalog := OpenConsilioCatalogById(catalogid);
  RETURN ObjectExists(catalog) ? catalog->OpenContentSourceById(id) : DEFAULT OBJECT;
}

/** @short Create a new Consilio catalog.
    @param tag The name of the catalog (this name should be unique)
    @param options Options
    @cell options.title An optional description for the catalog
    @cell options.priority (-9 to 9, 0 is the default)
    @cell(boolean) options.managed Create a managed catalog. Defaults to TRUE
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION CreateConsilioCatalog(STRING tag, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF(tag="" OR tag NOT LIKE "?*:?*" OR tag LIKE "*:*:*")
    THROW NEW Exception(`Invalid catalog tag '${tag}'`);

  // Index name should be unique
  IF (RecordExists(SELECT FROM consilio.catalogs WHERE ToUppercase(name) = ToUppercase(tag)))
    THROW NEW Exception(`Catalog with tag '${tag}' already exists`);

  options := ValidateOptions( [ loglevel := 0
                              , priority := 0
                              , title := ""
                              , definedby := "CreateConsilioCatalog from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
                              , fieldgroups := STRING[]
                              , managed := TRUE
                              , lang := ""
                              ], options);

  INTEGER indexid := MakeAutoNumber(consilio.catalogs, "id");

  // Create index
  INSERT CELL[ id := indexid
             , name := tag
             , description := options.title
             , options.loglevel
             , options.priority
             , options.definedby
             , type := options.managed ? whconstant_consilio_catalogtype_managed
                                       : whconstant_consilio_catalogtype_unmanaged
             , fieldgroups := Detokenize(options.fieldgroups, " ")
             , options.lang
             ] INTO consilio.catalogs;

  GetPrimary()->BroadCastOnCommit("consilio:indiceschanged", DEFAULT RECORD);

  OBJECT catalog := OpenConsilioCatalogById(indexid);
  IF(options.managed)  //only managed indices are attached immediately - with unmanaged the caller might want to create only suffixed indices
  {
    TRY
    {
      catalog->AttachIndex(0);
    }
    CATCH
    {
      DELETE FROM consilio.catalogs WHERE id=indexid;
      THROW;
    }

    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
  }

  RETURN catalog;
}

PUBLIC STRING FUNCTION __GenerateIndexName()
{
  RETURN "c_" || ToLowercase(EncodeBase16(DecodeUFS(GenerateUFS128BitId())));
}

/** @short Generate linkcheck report for WRD
    @cell(integer) options.entity ID of entity to request a linkcheck report for
    @return A list of links found and their checking status
    @cell(datetime) return.checked Last check (UTC)
    @cell(string) return.referrer Name of attribute referring to this field
    @cell(integer) return.status Status code (use EnrichLinkCheckStatuses to get texts and icons)
    @cell(string) return.text Text content of the link
    @cell(string) return.url The link */
PUBLIC RECORD ARRAY FUNCTION GetWRDLinkCheckReport(RECORD options)
{
  options := ValidateOptions([ entity := 0 ], options);
  RETURN SELECT checked, referrer, status, text, url
           FROM GetLinksForWRDEntity(options.entity);
}

STRING FUNCTION MapStatusIcon(INTEGER status)
{
  IF (status <= 0)
    RETURN "tollium:status/unknown";
  IF (status < 100)
    RETURN "tollium:status/serious_error";
  IF (status < 200)
    RETURN "tollium:status/warning";
  IF (status < 300)
    RETURN "tollium:status/positive";
  IF (status < 400)
    RETURN "tollium:status/warning";
  IF (status < 500)
    RETURN "tollium:status/error";
  RETURN "tollium:status/abort_error";
}

/** @short Enrich a linkcheck report with text and icons for statuses
    @param links List of links to enrich
    @return The original record array, enriched with statustext and statusicon
    @cell(string) return.statustext Text explaining the status (using the current GetTid language)
    @cell(string) return.statusicon Reference to icon to use for this status */
PUBLIC RECORD ARRAY FUNCTION EnrichLinkCheckStatuses(RECORD ARRAY links)
{
  links := SELECT *
                , statustext := GetStatusText(status)
                , statusicon := MapStatusIcon(status)
             FROM links;
  RETURN links;
}
