<?wh
/** @topic consilio/api
*/

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::os.whlib";

//The exports from catalogs.whlib are for legacy users... caller should switch to the catalogs.whlib and as soon as they're all >5.02+ we will remove the exports
LOADLIB "mod::consilio/lib/catalogs.whlib" EXPORT CreateConsilioCatalog, ListConsilioCatalogs, OpenContentSource, OpenConsilioCatalog, OpenConsilioCatalogById;
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT fetcher_trusted_ip;

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";

LOADLIB "mod::tollium/lib/gettid.whlib";


PUBLIC CONSTANT INTEGER require_allowed, require_required, require_prohibited;

/*

PUBLISHER SEARCH FIELDS



    RECORD ARRAY mapping := this->defaultmapping CONCAT
        [ [ name := "name", value := "" ]
        , [ name := "title", value := "" ]
        , [ name := "description", value := "" ]
        , [ name := "keywords", value := "" ]
        , [ name := "url", value := "", tokenized := FALSE ]
        , [ name := "whfsid", value := 0 ]
        , [ name := "whfsparent", value := 0 ]
        , [ name := "whfsobject", value := "", tokenized := FALSE ]

  whfsobject = file | folder

        , [ name := "whfstype", value := 0 ]
        , [ name := "whfspath", value := "" ]
        , [ name := "whfstree", value := "" ]
        , [ name := "date_creation", value := DEFAULT DATETIME ]
        , [ name := "date_modification", value := DEFAULT DATETIME ]
        ];



*/


/** @short Create a match query
    @long This query can be used to match a field with a given value. The matching behaviour depends on the matchtype and the
        type of the value. For INTEGER and STRING values, matchtype "=" means a literal match and matchtype "CONTAINS" means
        a value match. For INTEGER ARRAY and STRING ARRAY values, matchtype "IN" means that the fields must contain at least
        one of the values and matchtype "CONTAINS" means that the field must contain all of the values. For DATETIME values,
        the matchtype can be one of "<", "<=", "=", "=>" or ">" to search for date ranges.
    @param field The field to search
    @param matchtype How to match (possible values: 'IN', 'CONTAINS', '<', '<=', '=', '>=', '>')
    @param value The value to match
    @param options @private
    @return The match query
*/
PUBLIC RECORD FUNCTION CQMatch(STRING field, STRING matchtype, VARIANT value, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ datetimesupport := FALSE
      ], options);

  IF (field = "")
    THROW NEW Exception("Query field is required for match query");

  SWITCH (TypeID(value))
  {
    CASE TypeID(STRING ARRAY)
       , TypeID(INTEGER ARRAY)
       , TypeID(INTEGER64 ARRAY)
       , TypeID(MONEY ARRAY)
       , TypeID(FLOAT ARRAY)
       , TypeID(DATETIME ARRAY)
       , TypeID(BOOLEAN ARRAY)
    {
      IF (matchtype NOT IN [ "IN", "CONTAINS" ])
        THROW NEW Exception(`Invalid match type '${matchtype}' for ${GetTypeName(TypeID(value))} match query`);
    }
    CASE TypeID(STRING)
       , TypeID(INTEGER)
       , TypeID(INTEGER64)
       , TypeID(MONEY)
       , TypeID(FLOAT)
       , TypeID(DATETIME)
    {
      IF (matchtype NOT IN [ "CONTAINS", "<", "<=", "=", ">=", ">" ])
        THROW NEW Exception(`Invalid match type '${matchtype}' for ${GetTypeName(TypeID(value))} match query`);
      IF (matchtype = "CONTAINS" AND TypeID(value) != TypeID(STRING))
        matchtype := "="; // Match the literal query value within an indexed array
    }
    CASE TypeID(BOOLEAN)
    {
      IF (matchtype NOT IN [ "=" ])
        THROW NEW Exception(`Invalid match type '${matchtype}' for ${GetTypeName(TypeID(value))} match query`);
    }
    DEFAULT
    {
      THROW NEW Exception(`Invalid value type '${GetTypeName(TypeID(value))}' for match query`);
    }
  }

  IF (IsTypeIDArray(TypeID(value)))
  {
    IF (Length(value) = 0)
      RETURN CQNothing();
    RETURN [ _type := "boolean"
           , subqueries :=
               (SELECT query :=
                         CELL[ _type := matchtype = "IN" ? "literal" : "term"
                             , field
                             , term
                             , boost := 1f
                             ]
                     , required := (matchtype = "CONTAINS")
                     , prohibited := FALSE
                  FROM ToRecordArray(value, "term"))
           , boost := 1f
           ];
  }
  ELSE IF (matchtype IN [ "<", "<=", ">=", ">" ])
  {
    RETURN
        CELL[ _type := "range"
            , field
            , matchtype
            , term := value
            , boost := 1f
            ];
  }

  RETURN
      CELL[ _type := matchtype = "=" ? "literal" : "term"
          , field
          , term := value
          , boost := 1f
          ];
}

/** Returns a query record that will match results in which a field values lies between the specified range
    @param field Field name
    @param lowerterm Lower range value
    @param includelower Whether to include exact matches of the lower range value
    @param upperterm Upper range value
    @param includeupper Whether to include exact matches of the upper range value
    @param options @private
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQRange(STRING field, VARIANT lowerterm, BOOLEAN includelower, VARIANT upperterm, BOOLEAN includeupper, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ datetimesupport := FALSE ], options);

  IF (field = "")
    THROW NEW Exception("Query field is required for range query");

  IF (TypeID(lowerterm) != TypeID(upperterm))
    THROW NEW Exception(`Range query lower term type '${GetTypeName(TypeID(lowerterm))}' not equal to upper term type '${GetTypeName(TypeID(upperterm))}'`);

  VARIANT lowersearchterm, uppersearchterm;
  IF (TypeID(lowerterm) = TypeID(INTEGER))
  {
    lowersearchterm := ToString(lowerterm);
    uppersearchterm := ToString(upperterm);
  }
  ELSE IF (TypeID(lowerterm) = TypeID(STRING))
  {
    lowersearchterm := STRING(lowerterm);
    uppersearchterm := STRING(upperterm);
  }
  ELSE IF (TypeID(lowerterm) = TypeID(DATETIME))
  {
    IF (NOT options.datetimesupport)
    {
      // Rewrite field name: 'field' to 'date_field', 'array.field@module' to 'array.date_field@module'
      // But not if already prefixed with date_ ... as OpenSearch simply wants the raw names (and doesn't inset date_) but Consilio still wants to add date_ itself...
      IF (field LIKE "*.*@*")
      {
        IF(field NOT LIKE "*.date_*@*")
        {
          INTEGER dot := SearchSubstring(field, ".") + 1;
          field := `${Left(field, dot)}date_${Substring(field, dot)}`;
        }
      }
      ELSE
      {
        IF(field NOT LIKE "date_*")
          field := `date_${field}`;
      }
      lowersearchterm := FormatISO8601DateTime(lowerterm);
      uppersearchterm := FormatISO8601DateTime(upperterm);
    }
    ELSE
    {
      lowersearchterm := lowerterm;
      uppersearchterm := upperterm;
    }
  }
  ELSE
    THROW NEW Exception(`Invalid term type '${GetTypeName(TypeID(lowerterm))}' for range query`);

  RETURN [ _type := "range"
         , field := field
         , matchtype := (includelower ? "[" : "{") || (includeupper ? "]" : "}")
         , lowerterm := lowersearchterm
         , upperterm := uppersearchterm
         , boost := 1f
         ];
}

/** Returns a query record that will never match anything
    @long This exists so query operators can optimize themselves into CQNothing.
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQNothing()
{
  RETURN [ _type := "nothing"
         , boost := 1f
         ];
}

/** @short Returns a query record that matches all results that have a value for the specified field
    @param field Field to look at
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQHas(STRING field)
{
  IF (field = "")
    THROW NEW Exception("Query field is required for has query");

  RETURN [ _type := "exists"
         , field := field
         , boost := 1f
         ];
}

/** @short Returns a query record that matches all results
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQAll()
{
  RETURN [ _type := "all"
         , boost := 1f
         ];
}

/** @short Overwrites the boost factor of a query (which defaults to 1.0)
    @param query Query to adjust the boost factor of
    @param boost Boost factor
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQBoost(RECORD query, FLOAT boost)
{
  query.boost := boost;
  RETURN query;
}

/** @short Combine queries using AND
    @param inputqueries Consilio queries to combine
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQAnd(RECORD ARRAY inputqueries)
{
  RETURN CombineSubqueries(inputqueries, TRUE);
}

/** @short Combine queries using OR
    @param inputqueries Consilio queries to combine
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQOr(RECORD ARRAY inputqueries)
{
  RETURN CombineSubqueries(inputqueries, FALSE);
}

RECORD FUNCTION CombineSubqueries(RECORD ARRAY subqueries, BOOLEAN required)
{
  RECORD resultquery :=
      [ _type := "boolean"
      , subqueries := RECORD[]
      , boost := 1f
      ];
  FOREVERY (RECORD query FROM subqueries)
  {
    // If the first input query is a boolean query with the requested requirement, just add the other input queries
    IF (query._type = "boolean")
    {
      // If this subquery is a boolean query with the requested requirement, just add its subqueries directly
      IF (NOT RecordExists(SELECT FROM query.subqueries WHERE COLUMN required != VAR required OR prohibited))
      {
        // If this is the first query, replace the query
        IF (#query = 0)
          resultquery := query;
        ELSE
          resultquery.subqueries := resultquery.subqueries CONCAT query.subqueries;
      }
      ELSE
      {
        // Move every prohibited subquery a level up
        resultquery.subqueries := resultquery.subqueries CONCAT SELECT * FROM query.subqueries WHERE prohibited;
        DELETE FROM query.subqueries WHERE prohibited;
        // If there are any subqueries left, add the remaining boolean query
        IF (RecordExists(query.subqueries))
          INSERT CELL[ query, required, prohibited := FALSE ] INTO resultquery.subqueries AT END;
      }
    }
    ELSE IF(query._type = "nothing")
    {
      IF(required)  //In a serie of ANDs, nothing matches a poison.
        RETURN CQNothing();

      //but for OR queries, just ignore it
    }
    ELSE
    {
      INSERT CELL[ query, required, prohibited := FALSE ] INTO resultquery.subqueries AT END;
    }
  }
  RETURN resultquery;
}

/** @short Negate query
    @param inputquery Consilio query to negate
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQNot(RECORD inputquery)
{
  IF(inputquery._type = "nothing")
    RETURN CQAll();
  ELSE IF(inputquery._type = "all")
    RETURN CQNothing();
  RETURN [ _type := "boolean"
         , subqueries := [ [ query := inputquery
                           , required := FALSE
                           , prohibited := TRUE
                           ]
                         ]
         , boost := 1f
         ];
}

/** @short Parse a user query
    @param userquery User query string
    @cell(string) options.querymode How to combine the toplevel terms, either 'AND' or 'OR' (defaults to 'AND')
    @cell(record array) options.defaultfields Fields to search for terms without explicit field specification
    @cell(string) options.defaultfields.field Field name
    @cell(float) options.defaultfields.boost Boost factor applied when a match is found in this field (defaults to 1.0)
    @cell(boolean) options.defaultfields.stemmed_field Set to true to also use stemming when searching for terms in this field
    @cell(integer) options.thesaurusid If set, use the thesaurus of this index id (legacy Consilio only)
    @cell(boolean) options.synonyms If the catalog synonyms list should be used (defaults to TRUE, Opensearch only)
    @return Consilio query record
*/
PUBLIC RECORD FUNCTION CQParseUserQuery(STRING userquery, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ querymode := "AND"
      , defaultfields := DEFAULT RECORD ARRAY
      , thesaurusid := 0
      , synonyms := TRUE
      , defaultrequire := 0
      ],
      options,
      [ enums := [ querymode := [ "AND", "OR" ] ]
      , optional := [ "defaultrequire" ]
      ]);

  //TODO: This code checks if 'defaultrequire' is still used, can be removed if it's removed from all modules, along with the
  //      option itself and the 'require_*' variables
  IF (GetDTAPStage() = "development" AND GetEnvironmentVariable("WEBHARE_CI") = "" AND CellExists(options, "defaultrequire"))
    THROW NEW Exception("The 'defaultrequire' option is deprecated, use 'querymode' instead");

  RECORD ARRAY thesaurus;
  IF (options.thesaurusid != 0)
    thesaurus := GetIndexThesaurus(options.thesaurusid);

  userquery := TrimWhitespace(userquery);
  IF(userquery = "") //FIXME validate for other weird stuff that should require us to just discard this
    RETURN CQNothing();

  RETURN CELL[ _type := "user"
             , userquery
             , options.querymode
             , options.defaultfields
             , thesaurus
             , options.synonyms
             , boost := 1f
             ];
}

/** @short Builds an aggregation query
    @param field Field to aggregate over
    @param type Aggregation type (`"count"`, `"min"`, `"max"`, `"terms"`, `"top_hits"`, `"cardinality"`)
    @cell options.name Name of the query, to refer to this query (defaults to the used field)
    @cell options.size Nr of items to keep after ordering (only for aggregation types `"terms"` and `"top_hits"`)
    @cell options.orderby Field to order over (only for aggregation types `"terms"` and `"top_hits"`)
    @cell options.orderdesc Whether to reverse the ordering (only for aggregation types `"terms"` and `"top_hits"`)
    @cell options.query Query to run the aggregation over (defaults to matching all documents in the index)
    @cell options.aggregations Subaggregations (returned by #CQAggregate)
    @return Consilio aggregation query record
*/
PUBLIC RECORD FUNCTION CQAggregate(STRING field, STRING type, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ name := ""
      , size := 0
      , orderby := ""
      , orderdesc := TRUE
      , query := DEFAULT RECORD
      , aggregations := DEFAULT RECORD ARRAY
      ], options);

  // Make sure either field or name is given
  IF (field = "" AND type != "count")
    THROW NEW Exception("Field is required for aggregation");
  ELSE IF (type = "count" AND options.name = "")
    THROW NEW Exception("Name option is required for aggregation type 'count'");

  // For top_hits, a size must be given
  IF (type IN [ "terms", "top_hits" ] AND options.size <= 0)
    THROW NEW Exception("A non-zero size option is required for aggregation type 'top_hits'");

  RECORD aggregation :=
      CELL[ _type := type
          , name := options.name ?? field
          , field
          , options.aggregations
          ];
  IF (type IN [ "min", "max", "count", "cardinality" ])
  {
  }
  ELSE IF (type IN [ "terms", "top_hits" ])
  {
    aggregation := CELL[ ...aggregation, options.size, options.orderby, options.orderdesc ];
  }
  ELSE
    THROW NEW Exception(`Invalid aggregation type '${type}'`);

  RECORD res := CELL[ aggregation ];
  IF (RecordExists(options.query))
    INSERT CELL query := options.query INTO res;
  RETURN res;
}

/** @short Add a raw OpenSearch query
    @param query The raw query, eg `[ match_bool_prefix := [ "title" := "rises wi" ]]]`
    @return Consilio wrapped raw Opensearc query record
*/
PUBLIC RECORD FUNCTION CQOpenSearch(RECORD query)
{
  RETURN CELL[ _type := "opensearch", rawquery := query ];
}

RECORD ARRAY FUNCTION Highlight(RECORD ARRAY results, STRING ARRAY fields, STRING class)
{
  FOREVERY(STRING opt FROM fields)
    fields[#opt] := ToUppercase(opt);

  FOREVERY(RECORD res FROM results)
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(res))
    {
      IF(TypeID(cellrec.value)!=TypeID(STRING))
        CONTINUE;

      STRING newval := cellrec.value;
      IF(cellrec.name IN fields)
      {
        // OpenSearch seems to not add the pre tag when the highlight starts at the start of the string or add the post tag
        // when the highlight ends at the end of the string
        INTEGER firstclose := SearchSubstring(newval, "\x1C");
        IF (firstclose >= 0 AND SearchSubstring(newval, "\x1D") < 0)
          newval := "\x1D" || newval;
        INTEGER lastopen := SearchSubstring(newval, "\x1D");
        IF (lastopen >= 0 AND SearchSubstring(newval, "\x1C") < lastopen)
          newval := newval || "\x1C";

        //translate the markers to something that will survive EncodeHTML
        newval := Substitute(newval, "\x1D", '\uF8F0');
        newval := Substitute(newval, "\x1C", '\uF8F1');
        newval := EncodeHTML(newval);
        newval := Substitute(newval, "&#63728;", '<span class="' || EncodeValue(class) || '">');
        newval := Substitute(newval, "&#63729;", '</span>');
      }
      ELSE
      {
        newval := Substitute(newval, "\x1D", '');
        newval := Substitute(newval, "\x1C", '');
      }
      // Remove hyperlink markers
      newval := Substitute(newval, "\x1F", '');
      res := CellUpdate(res, cellrec.name, newval);
    }
    results[#res] := res;
  }
  RETURN results;
}

STRING FUNCTION ValidateIndexTag(STRING indextag)
{
  IF(indextag = "" OR indextag NOT LIKE "?*:?*" OR indextag LIKE "*:*:*")
    THROW NEW Exception(`Invalid indextag '${indextag}'`);

  RETURN indextag;
}

/** @short Get a token to access a consilio search engine's autosuggest API */
PUBLIC STRING FUNCTION GetConsilioRPCToken(STRING indextag, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ autosuggest := FALSE ], options);
  RETURN EncryptForThisServer("consilio:suggest", CELL [ c := GetCurrentDatetime(), t := indextag, ag := options.autosuggest ]);
}

RECORD ARRAY FUNCTION GetContentSourceMatches(INTEGER ARRAY candidateids)
{
  RETURN SELECT catalogid, fsobject
           FROM consilio.contentsources
          WHERE fsobject IN candidateids
                AND contentprovider = "publisher:webhare"
                AND orphansince = DEFAULT DATETIME
                AND tag NOT LIKE "$consilio$deleted$*"
       ORDER BY SearchElement(candidateids, fsobject) DESC; //prefer closest match

}

/** @short Look up the 'best' catalog for a folder/site
    @long Lookup the catalog to use. Prefers catalog that more specifically target this folder and catalogs that contain less other contentsources
    @param folder Folder it to look up. If you're not specifically targetting folders we recommend specifying the site id
    @return Catalog name (as suitable for RunConsilioSearch). Empty if no catalog found */
PUBLIC STRING FUNCTION GetConsilioPublisherCatalog(INTEGER folder)
{
  RECORD ARRAY candidates := GetContentSourceMatches([folder]);
  IF(Length(candidates) = 0)
    candidates := GetContentSourceMatches(GetWHFSTree(folder,0));

  IF(Length(candidates) = 0)
    RETURN "";

  IF(Length(candidates) > 1) //more than 1? eliminate all but the closest match
    DELETE FROM candidates AS c WHERE fsobject != candidates[0].fsobject;

  RECORD ARRAY catalogs := SELECT id, name
                             FROM consilio.catalogs
                            WHERE id IN (SELECT AS INTEGER ARRAY DISTINCT catalogid FROM candidates);

  IF(Length(catalogs) = 0)
    RETURN "";

  IF(Length(catalogs) =  1)
    RETURN catalogs[0].name;

  //Prefer the catalog which most closely matches what we need. resolve ties by taking the lowest catalogid (we need a stable result..)
  INTEGER smallestcatalog := SELECT AS INTEGER catalogid
                               FROM consilio.contentsources
                              WHERE catalogid IN (SELECT AS INTEGER ARRAY id FROM catalogs)
                           GROUP BY catalogid
                           ORDER BY COUNT(*), catalogid;

  RETURN SELECT AS STRING name FROM catalogs WHERE id = smallestcatalog;
}

/** @short Search an index
    @param indextag Index to search (module:tag)
    @param query Search query
    @cell(boolean) options.refresh Refresh the catalog before searching, making sure very recent changes are picked up
    @cell(string) options.language The language to use (legacy Consilio indices only, defaults to the language returned by
        %GetTidLanguage)
    @cell(integer) options.first The first result to return (0-based, defaults to 0)
    @cell(integer) options.count The number of results to return (-1 for all results, defaults to 100)
    @cell(boolean) options.save_searches If the search query should be saved for search reports (defaults to `FALSE`)
    @cell(integer) options.save_searches_site Set an explicit site id to save the query for (by default, Consilio tries to
        determine the site id by checking if the index contains only one publisher content source or by using
        %LookupPublisherUrl on the `restrict_url`)
    @cell(integer) options.summary_length The length of the summary to generate for each result (-1 for default length, 0 to
        prevent summary generation, defaults to -1)
    @cell(string) options.highlightclass The CSS class used to highlight found query words in the `highlightfields`
    @cell(string array) options.highlightfields The fields in which found query words should be highlighted
    @cell(string) options.summaryfield The name of the field to return the summary in (set to emtpy string to not return the
        summary, defaults to `"summary"`)
    @cell(string) options.scorefield The name of the field to return the result score in (set to empty string to not return
        scores, defaults to `""`)
    @cell(record) options.mapping The fields in this record will be returned in the search results and updated with the
        values returned by Consilio (defaults to `DEFAULT RECORD`, which returns all known fields)
    @cell(record) options.aggregation_mapping For aggregation queries, only the aggregation results will be returned, mapped
        using the `mapping` option, not the actual matching documents. By supplying a separate aggregation mapping, the
        aggregation results are returned separately in an `"aggregation"` result field
    @cell(string) options.orderby Field to order over (defaults to `""`, which orders descending by score, can be set to the
        value of the `scorefield` option, doesn't have to be a field in the `mapping` option)
    @cell(boolean) options.orderdesc Whether to reverse the ordering (defaults to `TRUE` when ordering by score or `FALSE`
        when ordering by another field)
    @cell(record array) options.ordering Advanced results ordering, overrides the `orderby` and `orderdesc` options
    @cell(string) options.ordering.orderby Field to order over (required, can be set to the value of the `scorefield` option,
        doesn't have to be a field in the `mapping` option, but it should be an indexed field)
    @cell(boolean) options.ordering.orderdesc Whether to reverse the ordering (defaults to `TRUE` when ordering by score or
        `FALSE` when ordering by another field)
    @cell(string) options.ordering.ordermode Sort mode to use (one of `"min"`, `"max"`, `"sum"`, `"avg"` or `"median"`,
        defaults to `"min"` when sorting ascending or `"max"` when sorting descending)
    @cell(string) options.restrict_url For site searches: Only results with a URL starting with this restrict_url are
        returned
    @cell(string array) options.exclude_urls For site searches: Results with a URL starting with one of these exclude_urls
        are not returned
    @return The search result
    @cell(integer) return.totalcount The total number of results (not necessarily the number of returned results, if `count`
        is set to a value >= 0)
    @cell(record array) return.results The actual results
    @cell(record array) return.aggregation The aggregation results for an aggregation query with a separate aggregation
        mapping (see the `aggregation_mapping` option)
    @cell(string array) return.eventmasks Event masks to listen to for changes to this query
*/
PUBLIC RECORD FUNCTION RunConsilioSearch(STRING indextag, RECORD query, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ language := ""
      , first := 0
      , count := default_consilio_search_count
      , save_searches := FALSE
      , save_searches_site := 0
      , summary_length := -1
      , highlightclass := "consilio--highlight"
      , highlightfields := STRING[]
      , summaryfield := "summary"
      , scorefield := ""
      , mapping := DEFAULT RECORD
      , aggregation_mapping := DEFAULT RECORD
      , orderby := ""
      , orderdesc := FALSE
      , ordering := DEFAULT RECORD ARRAY
      , restrict_url := ""
      , exclude_urls := STRING[]
      , debug := FALSE
      , explain := FALSE
      , refresh := FALSE
      ], options, [ optional := [ "orderdesc" ] ]);

  indextag := ValidateIndexTag(indextag);
  FOREVERY (RECORD ordering FROM options.ordering)
    options.ordering[#ordering] := ValidateOptions(
        [ orderby := ""
        , orderdesc := FALSE
        , ordermode := ""
        ],
        ordering,
        [ title := "ordering"
        , required := [ "orderby" ]
        , optional := [ "orderdesc", "ordermode" ]
        , enums :=
            [ ordermode := [ "min", "max", "sum", "avg", "median" ]
            ]
        ]);

  STRING language := options.language ?? GetTidLanguage();
  IF(NOT RecordExists(query)
      OR (CellExists(query, "query") AND RecordExists(query.query) AND query.query._type = "nothing")
      OR (NOT CellExists(query, "query") AND NOT CellExists(query, "aggregation") AND query._type = "nothing")) //will not return anything
    RETURN [ totalcount := 0
           , results := RECORD[]
           , eventmasks := STRING[]
           ];

  OBJECT search_obj := OpenSearchObject(language, indextag);
  IF(options.refresh)
    OpenConsilioCatalogById(search_obj->catalogid)->Refresh();

  search_obj->highlightfields := options.highlightfields;
  search_obj->save_searches := options.save_searches;
  IF (options.save_searches)
    search_obj->session_site := options.save_searches_site;
  search_obj->summary_length := options.summary_length;
  search_obj->debug := options.debug;
  search_obj->explain := options.explain;
  IF (RecordExists(options.mapping))
  {
    FOREVERY(RECORD cellrec FROM UnpackRecord(options.mapping))
      IF(cellrec.name LIKE "_*")
        THROW NEW Exception("Internal fields may not be requested through mapping"); //TODO perhaps we should allow this? but how to deal with various conflicting settings between this and summaryfield/scorefield ?

    search_obj->empty_result_record := options.mapping;
  }

  search_obj->restrict_url := options.restrict_url;
  search_obj->exclude_urls := options.exclude_urls;

  IF (RecordExists(options.ordering))
    query := CELL[ ...query, options.ordering ];
  ELSE IF (options.orderby != "")
  {
    RECORD ordering := CELL[ options.orderby ];
    IF (CellExists(options, "orderdesc"))
      ordering := CELL[ ...ordering, options.orderdesc ];
    query := CELL[ ...query, ordering := [ ordering ] ];
  }
  IF (CellExists(query, "ordering") AND RecordExists(query.ordering))
  {
    // If orderinging on scorefield, ordering on "_score", otherwise if not already orderinging on "_score", add it for consistency
    INTEGER scoreordering :=
        (SELECT AS INTEGER #ordering + 1
           FROM query.ordering
          WHERE orderby = (options.scorefield ?? "_score")) - 1;
    IF (scoreordering >= 0)
      query.ordering[scoreordering].orderby := "_score";
    ELSE
      INSERT [ orderby := "_score" ] INTO query.ordering AT END;
  }
  IF (CellExists(query, "aggregation"))
  {
    search_obj->aggregation_mapping := options.aggregation_mapping;
  }

  RECORD results := search_obj->__SearchQuery(query, options.first, options.count, options.scorefield != "");
  IF(CellExists(results,'results'))
  {
    //Translate results to the requested format
    //(should probablyhave returned proper results in the first place, but wait until we're ready to deprecate older apis)
    //cant fix it using the mapping, as it's unset before __searchquery
    IF(options.summaryfield = "")
    {
      results.results := SELECT *, DELETE _summary, DELETE summary FROM results.results;
    }
    ELSE
    {
      results.results := SELECT AS RECORD ARRAY CellInsert(CELL[...result, DELETE _summary, DELETE summary], options.summaryfield, options.summary_length != 0 ? result._summary : "")
                             FROM results.results AS result;
    }

    IF(options.scorefield = "")
    {
      results.results := SELECT *, DELETE _score FROM results.results;
    }
    ELSE IF(ToUppercase(options.scorefield) != "_SCORE")
    {
      results.results := SELECT AS RECORD ARRAY CellInsert(CELL[...result, DELETE _score], options.scorefield, result._score)
                              FROM results.results AS result;
    }

    IF(Length(options.highlightfields) != 0)
      results.results := Highlight(results.results, options.highlightfields, options.highlightclass);
  }

  INSERT CELL eventmasks := [ "consilio:index." || search_obj->catalogid ] INTO results;
  RETURN results;
}

/** Get completion suggestions for a text
    @param indextag Index to search (module:tag)
    @param searchtext The text to get suggestions for
    @cell options.count maximum number of suggestions to return (0 for all matches, defaults to 10)
    @return List of suggestions
    @cell(string) return.text The suggestion text
    @cell(integer) return.num The number of documents which match the suggestion
*/
PUBLIC RECORD ARRAY FUNCTION GetConsilioSuggestions(STRING indextag, STRING searchtext, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ count := 10 ], options);
  indextag := ValidateIndexTag(indextag);

  OBJECT suggest_obj := OpenSuggestObject(indextag);

  // Return all terms starting with "bla"
  RETURN SELECT num := suggestions.count //rename, 'count' is an annoying column to select, it clashes with the global AND count(*)
              , text
           FROM suggest_obj->GetSuggestions(searchtext, options.count) AS suggestions;
}

