<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::consilio/lib/internal/dbschema.whlib";

LOADLIB "mod::system/lib/resources.whlib";


PUBLIC CONSTANT STRING ARRAY supported_field_types :=
    [ "boolean", "completion", "datetime", "float", "integer", "integer64", "ipaddress", "keyword", "latlng", "money", "record", "text" ];

OBJECT FUNCTION GetIndexFieldDefinitionNode(STRING name, STRING type)
{
  IF(name NOT LIKE "?*:?*" OR name LIKE "*:*:*")
    THROW NEW Exception(`No such definition '${name}'`);

  STRING ARRAY parts := Tokenize(name, ':');
  OBJECT xmldoc := GetModuleDefinitionXML(parts[0]); //FIXME require validation to succeed ? use lastknown good if so unless on test/dev?
  FOREVERY(OBJECT consilionode FROM xmldoc->documentelement->ListChildren("http://www.webhare.net/xmlns/system/moduledefinition", "consilio"))
    FOREVERY(OBJECT indexnode FROM consilionode->ListChildren("http://www.webhare.net/xmlns/system/moduledefinition", type))
      IF(indexnode->localname = type AND indexnode->GetAttribute("tag") = parts[1])
        RETURN indexnode;

  RETURN DEFAULT OBJECT;
}

CONSTANT RECORD defaultparentstate := [ strict := TRUE
                                      , curdepth := 0
                                      ];

RECORD FUNCTION GetFieldDefinition(STRING name, STRING type, RECORD parentstate)
{
  IF(name LIKE "<index>*") //Pre-5.0 <index> support. Remove at some point...
  {
    name := Substring(name,7);
    type := "index";
  }

  OBJECT node := GetIndexFieldDefinitionNode(name, type);
  IF(NOT ObjectExists(node))
    THROW NEW Exception(`Cannot find ${type} mapping '${name}'`);

  RETURN ParseIndexField(node, Tokenize(name,':')[0], parentstate);
}

/// Read the field definition of a catalog from the moduledefinition
PUBLIC RECORD FUNCTION GetIndexFieldDefinition(STRING name)
{
  OBJECT node := GetIndexFieldDefinitionNode(name, "catalog") ?? GetIndexFieldDefinitionNode(name, "index");
  IF(NOT ObjectExists(node))
    RETURN DEFAULT RECORD; //GetIndexFieldDefinition is used in locations where a fielddefinition is optional - so don't require one

  RETURN ParseIndexField(node, Tokenize(name,':')[0], defaultparentstate);
}

/// Read the field definition of a fieldgroup from the moduledefinition
PUBLIC RECORD FUNCTION GetFieldgroupsFieldDefinition(STRING ARRAY fieldgroups, BOOLEAN strict)
{
  RECORD parsed := CELL[ properties := RECORD[], strict ];
  FOREVERY (STRING fieldgroup FROM fieldgroups)
  {
    RECORD fielddef := GetFieldDefinition(fieldgroup, 'fieldgroup', CELL[ ...defaultparentstate, parsed.strict]);
    IF (RecordExists(fielddef))
    {
      parsed.strict := parsed.strict AND fielddef.strict;
      FOREVERY (RECORD prop FROM fielddef.properties)
        IF (NOT RecordExists(SELECT FROM parsed.properties WHERE name = prop.name))
          INSERT prop INTO parsed.properties AT END;
    }
  }
  RETURN RecordExists(parsed.properties) ? parsed : DEFAULT RECORD;
}

STRING FUNCTION QualifyName(STRING qualification, STRING name)
{
  IF (name != "" AND SearchSubstring(name, "*") = -1 AND name NOT LIKE "*:*")
    name := qualification || ":" || name;

  RETURN name;
}

RECORD FUNCTION ParseIndexField(OBJECT fieldnode, STRING module, RECORD state)
{
  state.curdepth := state.curdepth + 1;
  IF(state.curdepth > 6)
    THROW NEW Exception(`Index is too deep!`);

  IF(fieldnode->HasAttribute("strict"))
    state.strict := ParseXSBoolean(fieldnode->GetAttribute("strict"));

  RECORD ARRAY properties;

  IF(fieldnode->localname="catalog")
    FOREVERY(STRING fieldgroup FROM ParseXSList(fieldnode->GetAttribute("fieldgroups")))
    {
      RECORD subresult := GetFieldDefinition(QualifyName(module, fieldgroup), "fieldgroup", state);
      properties := properties CONCAT subresult.properties;
    }

  FOREVERY(OBJECT subfield FROM fieldnode->ListChildren("*","*"))
  {
    STRING type := subfield->localname;

    IF (type = "customsource")
      CONTINUE;

    IF(type = "addfieldgroup") //inclusion, not a sublevel!
    {
      RECORD subresult := GetFieldDefinition(QualifyName(module, subfield->GetAttribute("ref")), "fieldgroup", state);
      properties := properties CONCAT subresult.properties;

      ////TODO conflict check?
      CONTINUE;
    }

    RECORD field := [ name := subfield->GetAttribute("name")
                    , settings := DEFAULT RECORD
                    , subfields := ParseIndexField(subfield, module, state)
                    , type := type
                    , defaultvalue := GetFieldTypeDefaultValue(type)
                    ];
    IF (subfield->HasAttribute("strict"))
    {
      BOOLEAN strict := ParseXSBoolean(subfield->GetAttribute("strict"));
      IF (strict != state.strict)
        INSERT CELL strict := strict INTO field;
    }
    IF (subfield->HasAttribute("storeonly"))
      INSERT CELL "index" := NOT ParseXSBoolean(subfield->GetAttribute("storeonly")) INTO field.settings;

    SWITCH(type)
    {
      CASE "keyword"
      {
        INTEGER ignore_above := ParseXSInt(subfield->GetAttribute("ignore_above"));
        IF (ignore_above != 0)
          INSERT CELL ignore_above := ignore_above INTO field.settings;
      }
    }

    INSERT field INTO properties AT END;
  }

  IF (NOT RecordExists(properties))
    RETURN DEFAULT RECORD;

  STRING dupename := SELECT AS STRING ANY(name) FROM properties GROUP BY ToUppercase(name) HAVING COUNT(*)>1;
  IF(dupename != "")
    THROW NEW Exception(`Duplicate property name '${dupename}'`);

  RETURN CELL[ properties, state.strict ];
}

// Remove field and all subfields from the list of fields
RECORD ARRAY FUNCTION DontDeleteField(INTEGER fieldid, RECORD ARRAY currentfields)
{
  FOREVERY (RECORD subfield FROM SELECT * FROM currentfields WHERE parent = fieldid)
    currentfields := DontDeleteField(subfield.id, currentfields);
  DELETE FROM currentfields WHERE id = fieldid;
  RETURN currentfields;
}

/// Get the contentsourcefields for a contentsource from the database
PUBLIC RECORD ARRAY FUNCTION GetContentSourceFields(INTEGER contentsourceid)
{
  RETURN
      SELECT name
           , type
           , defaultvalue := ParseDefaultValue(defaultvalue)
           , tokenized
           , suggested
        FROM consilio.contentsourcefields
       WHERE COLUMN contentsourceid = VAR contentsourceid
       ORDER BY ToUppercase(name)
              , id;
}

VARIANT FUNCTION ParseDefaultValue(STRING defaultvalue)
{
  TRY
    RETURN DecodeHSON(defaultvalue);
  CATCH;
  RETURN "";
}

PUBLIC RECORD ARRAY FUNCTION GetContentSourcesMapping(INTEGER ARRAY contentsourceids, RECORD ARRAY basefields)
{
  //TODO: Check for conflicting mappings instead of ignoring subsequent field definitions
  RECORD ARRAY properties := ParseContentSourceMapping(RECORD[], basefields);
  FOREVERY (INTEGER contentsourceid FROM contentsourceids)
    properties := ParseContentSourceMapping(properties, GetContentSourceFields(contentsourceid));
  RETURN properties;
}

RECORD ARRAY FUNCTION ParseContentSourceMapping(RECORD ARRAY properties, RECORD ARRAY fields)
{
  BOOLEAN have_suggested;
  FOREVERY (RECORD field FROM fields)
  {
    IF (field.name LIKE "_*")
    {
      // Overwrite standard field settings, like "body"
      STRING fieldname := Substring(field.name, 1);
      INTEGER idx := (SELECT AS INTEGER #properties + 1 FROM properties WHERE name = fieldname) - 1;
      IF (idx >= 0)
      {
        properties[idx] := CELL
            [ ...properties[idx]
            , type := GetTypeFromFieldDef(field)
            ];
        have_suggested := have_suggested OR (CellExists(field, "suggested") AND field.suggested);
      }
    }
    ELSE IF (NOT RecordExists(SELECT FROM properties WHERE name = field.name))
    {
      STRING type := GetTypeFromFieldDef(field);
      INSERT CELL
          [ type
          , defaultvalue := CellExists(field, "defaultvalue") ? field.defaultvalue : GetFieldTypeDefaultValue(type)
          , field.name
          , settings := DEFAULT RECORD
          , subfields := DEFAULT RECORD
          , strict := TRUE
          ] INTO properties AT END;
      have_suggested := have_suggested OR (CellExists(field, "suggested") AND field.suggested);
    }
  }

  // If there are any suggested fields, add a '_suggested' field with 'completion' type
  IF (have_suggested AND NOT RecordExists(SELECT FROM properties WHERE name = "_suggested"))
    INSERT
        [ name := "_suggested"
        , type := "completion"
        , settings := [ analyzer := "consilio_analyzer" ]
        , subfields := DEFAULT RECORD
        , strict := TRUE
        , defaultvalue := DEFAULT RECORD
        ] INTO properties AT END;

  RETURN properties;
}

STRING FUNCTION GetTypeFromFieldDef(RECORD field)
{
  IF (CellExists(field, "type") AND field.type != "")
  {
    IF (field.type NOT IN supported_field_types)
      THROW NEW Exception(`Unsupported field type '${field.type}'`);
    RETURN field.type;
  }
  IF (field.name LIKE "date_*" OR field.name LIKE "*.date_*")
    RETURN "datetime";
  IF (CellExists(field, "tokenized") AND field.tokenized)
    RETURN "text"; // analyzer will be added by ParseContentSourceMapping, so it will be applied to defaultmappingfields as well

  SWITCH (TypeID(field.defaultvalue))
  {
    CASE TypeID(STRING),    TypeID(STRING ARRAY)    { RETURN "keyword"; }
    CASE TypeID(INTEGER),   TypeID(INTEGER ARRAY)   { RETURN "integer"; }
    CASE TypeID(INTEGER64), TypeID(INTEGER64 ARRAY) { RETURN "integer64"; }
    CASE TypeID(MONEY),     TypeID(MONEY ARRAY)     { RETURN "money"; }
    CASE TypeID(FLOAT),     TypeID(FLOAT ARRAY)     { RETURN "float"; }
    CASE TypeID(BOOLEAN),   TypeID(BOOLEAN ARRAY)   { RETURN "boolean"; }
    CASE TypeID(DATETIME),  TypeID(DATETIME ARRAY)  { RETURN "datetime"; }
  }
  THROW NEW Exception(`Cannot determine type for field ${field.name}`);
}

VARIANT FUNCTION GetFieldTypeDefaultValue(STRING type)
{
  SWITCH (type)
  {
    CASE "boolean"    { RETURN FALSE; }
    CASE "datetime"   { RETURN DEFAULT DATETIME; }
    CASE "float"      { RETURN 0f; }
    CASE "integer"    { RETURN 0; }
    CASE "integer64"  { RETURN 0i64; }
    CASE "money"      { RETURN 0m; }
    CASE "record"     { RETURN DEFAULT RECORD; }
  }
  RETURN "";
}

/** @cell input.properties
    @cell input.strict
    @cell return.properties
    @cell return.dynamic_templates
    */
PUBLIC RECORD FUNCTION PrepareMappingUpdate(RECORD input)
{
  IF (NOT RecordExists(input))
    RETURN DEFAULT RECORD;

  RECORD properties;
  RECORD ARRAY dynamic_templates;

  FOREVERY(RECORD prop FROM input.properties)
  {
    RECORD esfielddata := [ type := prop.type
                          , ...prop.settings
                          ];

    RECORD subfields := PrepareMappingUpdate(prop.subfields);
    IF(RecordExists(subfields))
    {
      IF(prop.type="record")
      {
        //A record has properties - these subfields can individually receive values to index
        INSERT CELL properties := subfields.properties INTO esfielddata;
      }
      ELSE
      {
        //Other types have fields. these cannot index a separate value, they just receive their parent's value but store it differently
        INSERT CELL fields := subfields.properties INTO esfielddata;
      }
    }

    SWITCH(prop.type)
    {
      CASE "record"
      {
        esfielddata.type := "object";
        IF (RecordExists(subfields))
          INSERT CELL dynamic := subfields.dynamic INTO esfielddata;
        ELSE IF (CellExists(prop, "strict") AND prop.strict != input.strict)
          INSERT CELL dynamic := prop.strict ? "strict" : "true" INTO esfielddata;
      }

      // No additional changes
      CASE "keyword", "integer", "boolean" {}

      // Change HareScript type to Elasticsearch type
      CASE "integer64" { esfielddata.type := "long"; }
      CASE "float"     { esfielddata.type := "double"; }
      CASE "datetime"  { esfielddata.type := "date"; }
      CASE "latlng"    { esfielddata.type := "geo_point"; }
      CASE "ipaddress" { esfielddata.type := "ip"; }
      CASE "money"
      {
        // Elasticsearch's 'scaled_float' is stored as a long with fixed decimal factor, but is handled (and returned) as a
        // double (scaled_float is just more efficient in storage than double), which only has 53 bits of precision. To be
        // able to use all 64 bit money values, we'll just index them as long values.
        esfielddata.type := "long";
      }

      CASE "text", "completion"
      {
        // Use the default consilio analyzer
        esfielddata := CELL[ analyzer := "consilio_analyzer", ...esfielddata ];

        // For 'text', also index the orignal, non-transformed, tokenized text
        IF (prop.type = "text")
        {
          IF (NOT CellExists(esfielddata, "fields"))
            INSERT CELL fields := DEFAULT RECORD INTO esfielddata;
          INSERT CELL consilio_original := [ type := "text", analyzer := "consilio_original" ] INTO esfielddata.fields;
        }
      }
      DEFAULT
      {
        THROW NEW Exception(`Unknown field type '${prop.type}'`);
      }
    }

    IF(RecordExists(subfields) AND Length(subfields.dynamic_templates)>0)
    {
      IF(prop.type != "record")
        THROW NEW Exception('Only records may contain wildcarded fields');

      //We need to rename the templates AND regenerate its namebashed hash..
      FOREVERY(RECORD templ FROM subfields.dynamic_templates)
      {
        RECORD template := UnpackRecord(templ)[0].value;
        template.path_match := prop.name || "." || template.path_match;

        INSERT CellInsert(DEFAULT RECORD, `dyntempl_${EncodeUFS(GetSHA1Hash(prop.name))}`, template) INTO dynamic_templates AT END;
      }
    }

    IF(SearchSubstring(prop.name,'*') = -1) //plain field
    {
      properties := CellInsert(properties, prop.name, esfielddata);
    }
    ELSE //wildcard!
    {
      RECORD template :=
          [ path_match := prop.name
          , mapping := esfielddata
          ];

      //Using hash of name to ensure we stay below HSVM_MaxColumnName
      INSERT CellInsert(DEFAULT RECORD, `dyntempl_${EncodeUFS(GetSHA1Hash(prop.name))}`, template) INTO dynamic_templates AT END;
    }
  }
  RETURN CELL[properties, dynamic_templates, dynamic := input.strict ? "strict" : "true"];
}
