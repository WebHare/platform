<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::internet/mime.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/queries.whlib";
LOADLIB "mod::consilio/lib/internal/consilio.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_linkcheck.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib" EXPORT running_in_fetcher, print_defer_connection;
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT SearchOk, SearchError, SearchIndexNotFound, SearchCommandUnsupported, SearchNoAccess, SearchConnectError, SearchSendError, SearchHTTPError, SearchNoTotalError, SearchUnavailable, SearchTimeOutError, SearchInvalidArgument, SearchSleep, SearchRebuildCatalog;
LOADLIB "mod::consilio/lib/internal/elasticsearch/analysis.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


// -----------------------------------------------------------------------------
//
// Public API
//

PUBLIC OBJECT FUNCTION WaitForIndexManager(INTEGER indexmgrid, DATETIME waituntil DEFAULTSTO DEFAULT DATETIME)
{
  waituntil := waituntil ?? MAX_DATETIME;
  RECORD indexmanager := SELECT type FROM consilio.indexmanagers WHERE id = indexmgrid;

  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RETURN WaitForConsilio(indexmgrid, waituntil);
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RETURN WaitForElasticsearch(indexmgrid, waituntil);
      }
    }
  }
  RETURN CreateRejectedPromise(NEW Exception(SearchIndexNotFound));
}


/** @short Configure the indexmanager
    @param param What to configure ("all" or "stopwords")
    @return Result status
*/
PUBLIC STRING FUNCTION ConfigureIndexManager(STRING param)
{
  STRING res;

  // Only Consilio indexmanagers have to be configured
  FOREVERY (INTEGER id FROM SELECT AS INTEGER ARRAY COLUMN id FROM consilio.indexmanagers WHERE type = whconstant_consilio_indexmanager_legacybackend)
  {
    // Configure loglevel too
    BroadcastEvent("consilio:indexmanager.config",
        [ loglevel :=     ReadRegistryKey("consilio.indexmanager.loglevel")
        ]);

    STRING indexmgrres := ConfigureConsilioIndexManager(id, param);
    IF (indexmgrres != SearchOk)
      res := res ?? indexmgrres; // Keep first error code
  }
  res := res ?? SearchOk;

  RETURN res;
}

/** @short Clear the indexmanager status
    @long This call only applies to Consilio indexmanagers and is ignored for
        Elasticsearch indexmanagers (i.e. always returns SearchOk).
    @param indexmgrid The id of the indexmanager
    @return Result status
*/
PUBLIC STRING FUNCTION ClearIndexManagerStatus(INTEGER indexmgrid)
{
  RECORD indexmanager := GetIndexManagers(indexmgrid);

  STRING res := SearchIndexNotFound;
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD response := SendToConsilio(indexmanager.id, 0, "/setstatus", DEFAULT RECORD ARRAY, "POST");
        res := response.status;
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        // Not supported, ignore
        res := SearchOk;
      }
    }
  }

  RETURN res;
}

PUBLIC RECORD FUNCTION GetIndexManagerState(INTEGER indexmgrid)
{
  RECORD result :=
      [ status := SearchOk
      , msg := DEFAULT STRING ARRAY
      ];

  RECORD indexmanager := GetIndexManagers(indexmgrid);
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD response := SendToConsilio(indexmanager.id, 0, "/status", DEFAULT RECORD ARRAY, "POST");
        result.status := response.status;
        IF (response.status = SearchOk)
          result.msg := Tokenize(BlobToString(response.content, 1024 * 1024), "\n");
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        result := GetElasticsearchStatus(indexmanager.id);
      }
    }
  }

  RETURN result;
}

/** @short Get a list of indices from an indexmanager
    @param indexmgrid The id of the indexmanager
    @return The result
    @cell(string) return.status The result status
    @cell(integer array) return.indices The list of index id's known by this
        indexmanager, or DEFAULT INTEGER ARRAY when there are no indices or when
        no indexmanager with the given id exists
*/
PUBLIC RECORD FUNCTION GetIndexManagerIndexList(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ withdeleted := FALSE
      ], options);

  RECORD result :=
      [ status := SearchIndexNotFound
      , indices := DEFAULT RECORD ARRAY
      ];

  RECORD ARRAY indexmanagers := GetIndexManagers(indexmgrid, CELL[ options.withdeleted ]);
  RECORD indexmanager := indexmanagers;
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        // No support for unmanaged indices
        IF (options.indexsuffixes = "")
        {
          RECORD response := SendToConsilio(indexmanager.id, 0, "/indexlist", DEFAULT RECORD ARRAY, "POST");
          result.status := response.status;
          IF (response.status = SearchOk)
          {
            RECORD ARRAY indexlist :=
                SELECT indexid := ToInteger(indexid, 0)
                  FROM ToRecordArray(Tokenize(BlobToString(response.content, -1), "\n"), "indexid");
            result.indices :=
                SELECT DISTINCT indexid
                     , indexname :=   ""
                  FROM indexlist
                 WHERE indexid != 0
              ORDER BY indexid;
          }
        }
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD response := SendToElasticsearch(indexmanager.id, "", "/_cat/indices/?format=json&bytes=b", DEFAULT RECORD, "GET");
        result.status := response.status;
        IF (response.status = SearchOk)
        {
          //Find the indices we were expecting here
          RECORD ARRAY indexlist := RECORD ARRAY(DecodeJSONBlob(response.content));
          //fix counters which are sometiems 0s or strings...
          indexlist := EnforceStructure([[ "docs.count" := 0i64
                                         , "pri.store.size" := 0i64
                                         ]
                                        ], indexlist);

          // Unmanaged indices may have a suffix: <indexname>-<suffix>
          indexlist := SELECT TEMPORARY toks := Tokenize(indexlist."index",'-')
                            , indexname := toks[0]
                            , suffix := Length(toks) > 1 ? toks[1] : ""
                            , health
                            , status
                            , docs := indexlist."docs.count"
                            , size := indexlist."pri.store.size"
                            , indexid := (SELECT AS INTEGER indexid FROM indexmanagers WHERE indexname = toks[0])
                         FROM indexlist;

          indexlist :=
              SELECT health := PickFirst(SELECT AS STRING ARRAY health FROM GroupedValues(indexlist) ORDER BY SearchElement([ "red", "yellow", "green" ], health))
                   , status := PickFirst(SELECT AS STRING ARRAY status FROM GroupedValues(indexlist) ORDER BY SearchElement([ "close", "open" ], status))
                   , docs := Sum(docs)
                   , size := Sum(size)
                   , indexname
                   , indexid := ANY(indexid)
                FROM indexlist
            GROUP BY indexname;

          result.indices := SELECT indexid, indexname FROM indexlist ORDER BY indexid, indexname;
        }
      }
    }
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION GetIndexStats(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ metrics := STRING[ "_all" ]
      ], options,
      [ enums :=
          [ metrics := // https://www.elastic.co/guide/en/elasticsearch/reference/7.17/indices-stats.html#index-stats-api-path-params
              [ "_all", "completion", "docs", "fielddata", "flush", "get", "indexing", "merge", "query_cache", "refresh"
              , "request_cache", "search", "segments", "store", "suggest", "translog", "warmer"
              ]
          ]
      ]);
  RECORD result :=
      [ status := SearchIndexNotFound
      , stats := DEFAULT RECORD
      ];

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager))
   THROW NEW Exception(`No indexmanager configured for index #${indexid}`);

  SWITCH (indexmanager.type)
  {
    CASE whconstant_consilio_indexmanager_legacybackend
    {
      // Not supported, ignore
    }
    CASE whconstant_consilio_indexmanager_opensearch
    {
      RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_stats/" || Detokenize(options.metrics, ","), DEFAULT RECORD, "GET", [ throwonfailure := TRUE ]);
      result.status := response.status;
      IF (response.status = SearchOk)
        result.stats := GetCell(response.result.indices, indexmanager.indexname).total;
    }
  }

  RETURN result;
}

PUBLIC STRING FUNCTION EnsureIndexManagerIndex(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , throwonfailure := TRUE
      , synonyms := STRING[]
      ], options);

  STRING result := SearchOk;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanagers))
   THROW NEW Exception(`No indexmanager configured for index #${indexid}`);

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        // Not supported, ignore
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        IF (indexmanager.indexname = "")
          THROW NEW Exception(`Index #${indexid} has no name`);
        ELSE IF (indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged AND options.suffix != "")
          THROW NEW Exception("Cannot specify a suffix for a non-module index");

        RECORD settings := CELL
              // As long as we don't have replicating OpenSearch instances, set the number of replicas to 0 to make sure all indices have a 'green' health
            [ number_of_replicas := 0
              // Language-specific analysis settings
            , analysis := GetAnalysisForLanguage(indexmanager.lang)
            ];
        // Add the synonyms filter
        INSERT CELL synonym := CELL
            [ type := "synonym_graph"
            , options.synonyms
            ] INTO settings.analysis.filter;

        IF(IsDebugTagEnabled("consilio:changes"))
          LogDebug("consilio:searches", "EnsureIndexManagerIndex", CELL[ indexid, ...indexmanager, settings ]);

        TRY
        {
          RECORD response := SendToElasticsearch(indexmanager.id,
                                                indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""),
                                                "",
                                                CELL[ settings ],
                                                "PUT",
                                                [ throwonfailure := TRUE ]);
          result := response.status;
        }
        CATCH(OBJECT<ElasticSearchException> e)
        {
          IF(RecordExists(e->error) AND e->error.type IN [ "index_already_exists_exception", "resource_already_exists_exception" ])
            result := SearchOk;
          ELSE IF (options.throwonfailure)
            THROW;
          ELSE
            result := SearchHTTPError;
        }
      }
    }
  }

  RETURN result;
}

PUBLIC STRING FUNCTION UpdateIndexManagerIndexSettings(INTEGER indexid, RECORD settings, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  STRING result := SearchOk;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        // Not supported, ignore
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        // Analysis settings cannot be updated on opened indices, so the index has to be closed first and reopened after update
        BOOLEAN close_index := CellExists(settings, "analysis");

        IF(IsDebugTagEnabled("consilio:changes"))
          LogDebug("consilio:changes", "UpdateIndexManagerIndexSettings", CELL[ indexid, ...indexmanager, settings, close_index ]);

        RECORD response;
        IF (close_index)
        {
          response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_close", DEFAULT RECORD, "POST", [ throwonfailure := TRUE ]);
          IF (response.status != SearchOk)
            RETURN response.status;
        }

        // Update the settings
        response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_settings", settings, "PUT", [ throwonfailure := TRUE ]);
        IF (response.status != SearchOk)
          RETURN response.status;

        // Open the index again if needed
        IF (close_index)
        {
          response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_open", DEFAULT RECORD, "POST", [ throwonfailure := TRUE ]);
          IF (response.status != SearchOk)
            RETURN response.status;
        }

        result := response.status;
      }
    }
  }

  RETURN result;
}

PUBLIC STRING FUNCTION EnsureIndexManagerContentSource(INTEGER indexid, INTEGER contentsourceid)
{
  STRING result := SearchOk;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        // Not supported, ignore
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        TRY
        {
          RECORD settings := CELL
              [ properties := GetContentSourcesMapping([ contentsourceid ], defaultmappingfields)
              , strict := TRUE
              ];
          settings := PrepareMappingUpdate(settings);

          IF(IsDebugTagEnabled("consilio:changes"))
            LogDebug("consilio:changes", "EnsureIndexManagerContentSource", CELL[ indexid, ...indexmanager, settings ]);
          RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_mapping", settings, "PUT", [ throwonfailure := TRUE ]);
          result := response.status;
        }
        CATCH (OBJECT<ElasticSearchException> e)
        {
          IF(RecordExists(e->error) AND e->error.type = "illegal_argument_exception" AND e->error.reason LIKE "mapper [*]")
            result := SearchRebuildCatalog; // Cannot update mapping, index must be deleted and re-indexed
          ELSE
            THROW;
        }
      }
    }
  }

  IF (result = SearchOk)
    BroadcastEvent("consilio:contentsourcestatus", [ id := contentsourceid ]);

  RETURN result;
}

PUBLIC RECORD FUNCTION GetIndexManagerMapping(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , throwonfailure := TRUE
      ], options);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager) OR indexmanager.type != whconstant_consilio_indexmanager_opensearch)
    THROW NEW Exception(`Consilio catalog #${indexid} does not support GetIndexManagerMapping`);
  IF (options.suffix != "" AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
    THROW NEW Exception(`Managed Consilio catalog #${indexid} does not support suffixes`);

  STRING finalindexname := indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : "");
  RECORD response := SendToElasticsearch(indexmanager.id, finalindexname, "/_mapping", DEFAULT RECORD, "GET", CELL[options.throwonfailure]);

  RECORD mappings := GetCell(response.result, finalindexname).mappings;
  mappings := EnforceStructure([ dynamic_templates := RECORD[]], mappings);
  RETURN mappings;
}

// For unmanaged Elasticsearch indices only
PUBLIC STRING FUNCTION EnsureIndexManagerMapping(INTEGER indexid, RECORD mapping, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , throwonfailure := FALSE
      ], options);

  STRING result := SearchCommandUnsupported;

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (RecordExists(indexmanager) AND indexmanager.type = whconstant_consilio_indexmanager_opensearch)
  {
    IF (options.suffix != "" AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      THROW NEW Exception(`Managed Consilio catalog #${indexid} does not support suffixes`);
    TRY
    {
      IF(IsDebugTagEnabled("consilio:changes"))
        LogDebug("consilio:changes", "EnsureIndexManagerMapping", CELL[ indexid, ...indexmanager, mapping ]);
      RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_mapping", mapping, "PUT", [throwonfailure := TRUE]);
      result := response.status;
    }
    CATCH (OBJECT<ElasticSearchException> e)
    {
      IF(RecordExists(e->error) AND e->error.type = "illegal_argument_exception" AND e->error.reason LIKE "mapper [*]")
        result := SearchRebuildCatalog; // Cannot update mapping, index must be deleted and re-indexed
      ELSE IF (options.throwonfailure)
        THROW;
      ELSE
        result := SearchHTTPError;
    }
  }
  ELSE
  {
    THROW NEW Exception(`Consilio catalog #${indexid} does not support GetIndexManagerMapping`);
  }
  RETURN result;
}

/** @short Search an index
    @param indexid The id of the index to query; 0 for all indices
    @param query The query to execute
    @param useroptions Search options
    @cell(integer) useroptions.first The first result to return (0-based, defaults to 0)
    @cell(integer) useroptions.count The number of results to return; 0 for no results (but still returning the number of result),
        -1 for all results (defaults to 0)
    @cell(integer) useroptions.summary The length of the summary to generate; 0 for no summary (defaults to 200)
    @cell(boolean) useroptions.highlightfields Highlight matched search terms in these fields
    @cell(string) useroptions.lang The language used for searching (used for various language-specific features)
    @cell(string) useroptions.restrict_to Restrict results to URLs starting with restrict_to
    @cell(record) useroptions.mapping The search result field mapping to use; DEFAULT RECORD for all known fields
    @return Search results
    @cell(string) return.status Return status (eg SearchOk)
    @cell(integer) return.totalcount Number of returned results
    @cell(record array) return.results Results
    @cell(record) return.session Search session
*/
PUBLIC RECORD FUNCTION SearchIndexManager(INTEGER indexid, RECORD query, RECORD useroptions)
{
  RECORD indexoptions := GetAdhocCached( [ indexoptions := indexid ], PTR GetCacheableIndexConfiguration(indexid));
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , summary := 200
      , highlightfields := STRING[]
      , lang := ""
      , restrict_to := ""
      , exclude_urls := STRING[]
      , mapping := indexoptions.defaultmapping
      , session := DEFAULT RECORD
      , addscore := FALSE
      , debug := FALSE
      , throwonfailure := TRUE
      ];

  RECORD options := ValidateOptions(defaultoptions, useroptions);
  IF(options.addscore)
    options.mapping := CELL[...options.mapping, _score := 0f ];

  IF (options.summary != 0 AND NOT CellExists(options.mapping, "_SUMMARY"))
    INSERT CELL _summary := "" INTO options.mapping;

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , results := DEFAULT RECORD ARRAY
      , session := options.session
      ];

  STRING catalog := SELECT AS STRING name FROM consilio.catalogs WHERE id = indexid AND name NOT LIKE "$consilio$deleted$*";
  IF (catalog = "")
    RETURN result;

  DATETIME querystart := GetCurrentDateTime();

  RECORD indexmanager := indexoptions.indexmanagers;
  IF (RecordExists(indexmanager))
  {
    STRING queryuuid := GenerateUFS128BitId();

    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an aggregation query or unmanaged index
    IF (NOT CellExists(query, "aggregation") AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    STRING ARRAY requested_fields := GetRequestedFields(mapping);

    //FIXME Get rid of the broadcasts, just use the logging system ?
    RECORD searchstart := CELL[ event := "searchstart"
                              , queryuuid
                              , options.restrict_to
                              , options.exclude_urls
                              , options.first
                              , options.count
                              , summary_length := options.summary
                              , options.lang
                              , sess := RecordExists(options.session) ? options.session.sessid : ""
                              , options.highlightfields
                              , fields := requested_fields
                              , uuid := queryuuid
                              , now := querystart
                              , catalog
                              , indexmanager := indexmanager.type = whconstant_consilio_indexmanager_legacybackend ? "Consilio" : indexmanager.type = whconstant_consilio_indexmanager_opensearch ? "ElasticSearch" : "#" || indexmanager.type
                              ];

    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD ARRAY vars :=
            [ [ name := "query",  value := __FormatQuery(indexid, query, [ language := options.lang, consilio := TRUE ]) ]
            ];

        // Objectid is always returned first, groupid always returned second
        requested_fields :=
            SELECT AS STRING ARRAY field
              FROM ToRecordArray(requested_fields, "field")
             ORDER BY (SearchElement([ "objectid", "groupid" ], field) + 1) ?? 9999;
        INSERT [ name := "fields", value := Detokenize(requested_fields, ",") ] INTO vars AT END;

        IF (options.first != defaultoptions.first)
          INSERT [ name := "first", value := ToString(options.first) ] INTO vars AT END;
        IF (options.count != defaultoptions.count)
          INSERT [ name := "count", value := ToString(options.count) ] INTO vars AT END;
        IF (options.summary != defaultoptions.summary)
          INSERT [ name := "summary", value := ToString(options.summary) ] INTO vars AT END;
        IF (Length(options.highlightfields) = 0)
          INSERT [ name := "donthighlight", value := "" ] INTO vars AT END;
        IF (options.lang != defaultoptions.lang)
          INSERT [ name := "lang", value := ToUppercase(options.lang) ] INTO vars AT END;
        IF (options.restrict_to != defaultoptions.restrict_to)
          INSERT [ name := "restrict-to", value := options.restrict_to ] INTO vars AT END;
        IF (Length(options.exclude_urls) > 0)
          INSERT [ name := "exclude-urls", value := Detokenize(options.exclude_urls, "\t") ] INTO vars AT END;

        STRING queryvalue := __FormatQuery(indexid, query, [ language := options.lang, consilio := TRUE ]);
        IF(IsDebugTagEnabled("consilio:searches"))
          LogDebug("consilio:searches", "Indexmanager search", CELL[ ...searchstart, query := queryvalue ]);

        BroadcastEvent("consilio:executedquery", CELL[ isstart := TRUE
                                                     , query := queryvalue
                                                     , options.restrict_to
                                                     , options.exclude_urls
                                                     , options.first
                                                     , options.count
                                                     , summary_length := options.summary
                                                     , options.lang
                                                     , sess := RecordExists(options.session) ? options.session.sessid : ""
                                                     , options.highlightfields
                                                     , fields := requested_fields
                                                     , uuid := queryuuid
                                                     , now := querystart
                                                     , catalog
                                                     ]);

        IF(options.debug)
          Print("Final consilio query: " || queryvalue || "\n");

        RECORD response := SendToConsilio(indexmanager.id, indexid, "/search", vars, "POST");

        result.status := response.status;
        IF (result.status = SearchOk)
        {
          result.totalcount := result.totalcount + ToInteger(GetMIMEHeader(response.headers, "Total-Hits"), 0);
          result.results := ReadConsilioResults(response.content, requested_fields, mapping);

          IF (IsDatabaseWritable())
            result.session := SaveQuery(result.session, query, indexid, options.restrict_to, GetCurrentDateTime(), Length(result.results));
        }

        BroadcastEvent("consilio:executedquery", [ isstart := FALSE
                                                 , uuid := queryuuid
                                                 , status := response.status
                                                 , code := CellExists(response, "code") ? response.code : 0
                                                 , numresults := CellExists(response, "results") ? Length(result.results) : 0
                                                 , now := GetCurrentDateTime()
                                                 ]);
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD searchquery := CreateElasticsearchQuery(query);

        INSERT CELL _source := requested_fields INTO searchquery;

        IF (options.first != defaultoptions.first)
          INSERT CELL "from" := options.first INTO searchquery;
        IF (CellExists(searchquery, "aggs"))
          INSERT CELL size := 0 INTO searchquery; // Only interested in aggregation result
        ELSE IF (options.count != defaultoptions.count)
          INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;
        IF (options.summary != 0 OR Length(options.highlightfields) > 0)
        {
          INSERT CELL highlight :=
              [ fields := RECORD[]
              , pre_tags := [ Length(options.highlightfields) > 0 ? "\x1d" : "" ]
              , post_tags := [ Length(options.highlightfields) > 0 ? "\x1c" : "" ]
              ] INTO searchquery;
          // The body is used for summary generation with the given length (with number_of_fragments set to 1)
          IF (options.summary != 0 OR "body" IN options.highlightfields)
            INSERT [ body :=
                       [ number_of_fragments := 1
                       , fragment_size := options.summary < 0 ? defaultoptions.summary : options.summary
                       , no_match_size := options.summary < 0 ? defaultoptions.summary : options.summary
                       ]
                   ] INTO searchquery.highlight.fields AT END;
          // The other highlight fields are returned completely (number_of_fragments set to 0)
          FOREVERY (STRING field FROM options.highlightfields)
            IF (field != "body")
              INSERT CellInsert(DEFAULT RECORD, field, [ number_of_fragments := 0 ]) INTO searchquery.highlight.fields AT END;
        }
        IF (options.restrict_to != defaultoptions.restrict_to)
        {
          RECORD restrict_filter := [ prefix := [ initialfilter := options.restrict_to ] ];
          searchquery.query := AddElasticsearchQueryFilters(searchquery.query, [ restrict_filter ], FALSE);
        }
        IF (Length(options.exclude_urls) > 0)
        {
          RECORD ARRAY exclude_filters;
          FOREVERY (STRING url FROM options.exclude_urls)
            INSERT [ prefix := [ initialfilter := url ] ] INTO exclude_filters AT END;
          searchquery.query := AddElasticsearchQueryFilters(searchquery.query, exclude_filters, TRUE);
        }

        RECORD finalquery := [ method := "GET"
                             , path := "/" || indexmanager.indexname || (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged ? "*" : "") || "/_search"
                             , body := searchquery
                             ];

        IF(IsDebugTagEnabled("consilio:searches"))
          LogDebug("consilio:searches", "OpenSearch search", CELL[ ...searchstart, searchquery := finalquery ]);

        BroadcastEvent("consilio:executedquery", CELL[ isstart := TRUE
                                                     , uuid := queryuuid
                                                     , searchquery := finalquery
                                                     , options.restrict_to
                                                     , options.first
                                                     , options.count
                                                     , summary_length := options.summary
                                                     , sess := RecordExists(options.session) ? options.session.sessid : ""
                                                     , options.highlightfields
                                                     , fields := requested_fields
                                                     , now := querystart
                                                     , catalog
                                                     ]);

        IF(options.debug)
          Print("Final Elasticsearch query: " || EncodeJSON(searchquery) || "\n");

        RECORD response := SendRawJSONToElasticsearch(indexmanager.id, finalquery.method, finalquery.path, finalquery.body, CELL[ options.throwonfailure , enforce := "_search_get" ]);
        IF(options.debug)
          DumpValue(response, "tree");

        result.status := response.status;
        IF (result.status = SearchOk)
        {
          IF (response.result.timed_out)
            result.status := SearchTimeOutError;
          ELSE IF (CellExists(query, "aggregation"))
          {
            result.totalcount := result.totalcount + response.result.hits.total.value;

            // If the main aggregation is a 'count' aggregation, there are no aggregation results
            IF (query.aggregation._type = "count")
            {
              RECORD aggresult := CellInsert(DEFAULT RECORD, query.aggregation.name, response.result.hits.total.value);
              RECORD singleresult := ParseSingleElasticsearchResult(aggresult, mapping);
              IF (RecordExists(singleresult))
                INSERT singleresult INTO result.results AT END;
            }
            ELSE
            {
              // For now, we only have one top-level aggregation per query
              RECORD main_aggregation := UnpackRecord(response.result.aggregations);
              IF (RecordExists(main_aggregation))
              {
                VARIANT aggresult := ReadElasticsearchAggregationResult(query.aggregation, main_aggregation.name, response.result.aggregations);
                IF (IsTypeIDArray(TypeID(aggresult)))
                {
                  FOREVERY (RECORD lineresult FROM aggresult)
                  {
                    RECORD singleresult := ParseSingleElasticsearchResult(lineresult, mapping);
                    IF (RecordExists(singleresult))
                      INSERT singleresult INTO result.results AT END;
                  }
                }
                ELSE
                {
                  RECORD singleresult := ParseSingleElasticsearchResult(aggresult, mapping);
                  IF (RecordExists(singleresult))
                    INSERT singleresult INTO result.results AT END;
                }
              }
            }
          }
          ELSE
          {
            result.totalcount := result.totalcount + response.result.hits.total.value;

            // An array with length 0 is returned as VARIANT ARRAY
            IF (Length(response.result.hits.hits) > 0)
              result.results := result.results CONCAT ReadElasticsearchResults(response.result.hits.hits, requested_fields, mapping);
          }

          result.session := SaveQuery(result.session, query, indexid, options.restrict_to, GetCurrentDateTime(), Length(result.results));
        }

        BroadcastEvent("consilio:executedquery", [ isstart := FALSE
                                                 , uuid := queryuuid
                                                 , status := response.status
                                                 , code := CellExists(response, "code") ? response.code : 0
                                                 , numresults := CellExists(response, "results") ? Length(result.results) : 0
                                                 , now := GetCurrentDateTime()
                                                 ]);
      }
    }

    IF(IsDebugTagEnabled("consilio:searches"))
      LogDebug("consilio:searches", "Search complete",
                                     CELL[ event := "searchdone" //FIXME separate 'done' and 'fail'
                                         , queryuuid
                                         , numresults := result.totalcount
                                         , time_msecs := GetDatetimeDifference(querystart, GetCurrentDateTime()).msecs
                                         ]);
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION QueryIndexManager(INTEGER indexid, RECORD query, RECORD options)
{
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , mapping := DEFAULT RECORD
      , lang := ""
      , suffix := ""
      , managedonly := FALSE
      , indexmanager := 0
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , results := DEFAULT RECORD ARRAY
      ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager", CELL[ indexid, query, options ]);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ managedonly := options.managedonly ]);
  RECORD indexmanager := options.indexmanager = 0
      ? RECORD(indexmanagers)
      : RECORD(SELECT * FROM indexmanagers WHERE id = options.indexmanager);

  IF (RecordExists(indexmanager))
  {
    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an unmanaged index
    IF (indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    STRING ARRAY requested_fields := GetRequestedFields(mapping);

    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD ARRAY vars :=
            [ [ name := "query",  value := __FormatQuery(indexid, query, [ language := options.lang, consilio := TRUE ]) ]
            ];

        // Objectid is always returned first, groupid always returned second
        requested_fields :=
            SELECT AS STRING ARRAY field
              FROM ToRecordArray(requested_fields, "field")
             ORDER BY (SearchElement([ "objectid", "groupid" ], field) + 1) ?? 9999;
        INSERT [ name := "fields", value := Detokenize(requested_fields, ",") ] INTO vars AT END;

        IF (options.first != defaultoptions.first)
          INSERT [ name := "first", value := ToString(options.first) ] INTO vars AT END;
        IF (options.count != defaultoptions.count)
          INSERT [ name := "count", value := ToString(options.count) ] INTO vars AT END;

        RECORD response := SendToConsilio(indexmanager.id, indexid, "/search", vars, "POST");

        result.status := response.status;
        IF (result.status = SearchOk)
        {
          result.totalcount := result.totalcount + ToInteger(GetMIMEHeader(response.headers, "Total-Hits"), 0);
          result.results := ReadConsilioResults(response.content, requested_fields, mapping);
        }
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD searchquery := CreateElasticsearchQuery(query);

        INSERT CELL _source := requested_fields INTO searchquery;

        // Optimization when scoring isn't relevant - https://opensearch.org/docs/latest/opensearch/ux/#sort-results
        INSERT CELL sort := [ "_doc" ] INTO searchquery;

        IF (options.first != defaultoptions.first)
          INSERT CELL "from" := options.first INTO searchquery;
        BOOLEAN scrolling;
        IF (options.count != defaultoptions.count)
        {
          INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;

          // If requesting all results, use the scrolling API
          scrolling := options.count = -1;
        }

        STRING scrollid;
        BOOLEAN search_done;
        INTEGER totalhits;
        WHILE (NOT search_done)
        {
          RECORD response;
          // If we have a scroll id, request the next batch of results
          IF (scrollid != "")
            response := SendToElasticsearch(indexmanager.id, "", "/_search/scroll", [ scroll := "10s", scroll_id := scrollid ], "GET");
          ELSE
          {
            STRING suffix := indexid > 0 AND indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged ? (options.suffix != "" ? "-" || options.suffix : "") : "";
            response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname || suffix : "_all", "/_search" || (scrolling ? "?scroll=10s" : ""), searchquery, "GET");
          }

          result.status := response.status;
          IF (result.status = SearchOk)
          {
            IF (response.result.timed_out)
            {
              result.status := SearchTimeOutError;
              BREAK;
            }
            ELSE
            {
              // If we're not using the scrolling API, we're done, otherwise
              // store the scroll id for retrieval of the next batch of results
              IF (NOT scrolling)
                search_done := TRUE;

              totalhits := response.result.hits.total.value;

              // An array with length 0 is returned as VARIANT ARRAY
              IF (Length(response.result.hits.hits) > 0)
              {
                IF (scrolling)
                  scrollid := response.result._scroll_id;

                result.results := result.results CONCAT ReadElasticsearchResults(response.result.hits.hits, requested_fields, mapping);
              }
              ELSE
              {
                // If a batch doesn't contain results, we're done
                search_done := TRUE;
              }
            }
          }
          ELSE
            BREAK;
        }

        result.totalcount := result.totalcount + totalhits;

        // Clear the last scrolling context, if necessary
        IF (scrollid != "")
          SendToElasticsearch(indexmanager.id, "", "/_search/scroll", [ scroll_id := [ scrollid ] ], "DELETE");
      }
    }
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager done", CELL[ result ]);

  RETURN result;
}

/*
*/
PUBLIC RECORD FUNCTION SuggestIndexManager(INTEGER indexid, STRING query, RECORD options)
{
  RECORD defaultoptions :=
      [ count := 10
      , doccount := "search"
      , prefix := ""
      , restrict_to := ""
      , and_search := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result := [ status := SearchIndexNotFound
                   , suggestions := DEFAULT RECORD ARRAY
                   ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager", CELL[ indexid, query, options ]);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD ARRAY vars :=
            [ [ name := "query", value := query ]
            , [ name := "doccount", value := options.doccount ]
            , [ name := "count", value := ToString(options.count >= 0 ? options.count : defaultoptions.count) ]
            ];
        IF (indexid = -1 AND options.prefix != "")
          INSERT [ name := "prefix", value := options.prefix ] INTO vars AT END;
        ELSE IF (indexid != -1 AND options.restrict_to != "")
          INSERT [ name := "restrict-to", value := options.restrict_to ] INTO vars AT END;
        IF (options.and_search)
          INSERT [ name := "and-search", value := "true" ] INTO vars AT END;

        RECORD response := SendToConsilio(indexmanager.id, indexid, "/suggest", vars, "GET");
        result.status := response.status;
        IF (response.status = SearchOk)
        {
          IF (Length(response.content) > 0)
          {
            STRING content := BlobToString(response.content, Length(response.content));

            // Content consists of lines with word and document count, separated by tab
            STRING ARRAY lines := Tokenize(content, "\n");
            FOREVERY (STRING line FROM lines)
            {
              STRING ARRAY parts := Tokenize(line, "\t");
              IF (parts[0] != "")
                INSERT [ text := parts[0]
                       , count := Length(parts) > 1 ? ToInteger(parts[1], 0) : 0
                       ] INTO result.suggestions AT END;
            }
          }
        }
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        OBJECT tokenizer := NEW TokenStream(query);
        RECORD token := tokenizer->GetNextToken();
        STRING userquery, userword, querystring;
        STRING ARRAY otherwords;
        WHILE (RecordExists(token))
        {
          IF (token.type = TokenTypeWord)
          {
            querystring := token.normalizedtext;
            INSERT querystring INTO otherwords AT END;
            userword := token.text;
            userquery := Left(query, token.startoffset);
          }
          token := tokenizer->GetNextToken();
        }
        INTEGER wordlen := Length(userword);
        INTEGER prefixlen;
        IF (indexid = -1 AND options.prefix != "")
        {
          querystring := options.prefix || "_" || querystring;
          prefixlen := Length(options.prefix) + 1;
        }
        IF (querystring != "")
        {
          RECORD suggestquery :=
              [ _source := [ "_suggested" ]
              , suggest :=
                  [ suggested :=
                      [ prefix := querystring
                      , completion := [ field := "_suggested" ]
                      ]
                  ]
              ];
          // If the and_search option is set, query documents containing the other query words
          IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 1)
          {
            DELETE FROM otherwords AT END-1; // Remove the suggestions query word
            INSERT CELL query :=
                [ bool :=
                    [ must := (SELECT match := [ _suggested := word ] FROM ToRecordArray(otherwords, "word"))
                    ]
                ] INTO suggestquery;
          }
          IF (indexid != -1 AND options.restrict_to != "")
            INSERT "initialfilter" INTO suggestquery._source AT END;

          RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_search", suggestquery, "POST");
          result.status := response.status;
          IF (response.status = SearchOk AND CellExists(response.result, "suggest")) // suggest may not exist if indexmanager should be restarted
          {
            // The suggest results are by matching document, returning only the first matching suggestion, so we'll have to
            // manually go through all suggested terms (the original input) and see which terms match with the query. This has
            // the added benefit of having a method to count the number of matching documents
            IF (Length(response.result.suggest.suggested.options) > 0)
            {
              // These are the documents containing the other query words
              STRING ARRAY otherdocs := Length(response.result.hits.hits) > 0 ? SELECT AS STRING ARRAY _id FROM response.result.hits.hits : STRING[];
              FOREVERY (RECORD suggest FROM response.result.suggest.suggested.options)
              {
                IF (indexid != -1
                    AND options.restrict_to != ""
                    AND suggest._source.initialfilter NOT LIKE options.restrict_to || "*")
                  CONTINUE;
                IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 0 AND suggest._id NOT IN otherdocs)
                  CONTINUE;
                FOREVERY (STRING text FROM suggest._source._suggested.input)
                  IF (text LIKE querystring || "*")
                  {
                    text := userword || Substring(text, prefixlen + wordlen);
                    INTEGER cur :=
                        (SELECT AS INTEGER #suggestions + 1
                           FROM result.suggestions
                          WHERE COLUMN text = VAR text) - 1;
                    IF (cur < 0)
                    {
                      cur := Length(result.suggestions);
                      INSERT [ text := text, count := 0 ] INTO result.suggestions AT cur;
                    }
                    IF (options.doccount != "" AND cur >= 0)
                      result.suggestions[cur].count := result.suggestions[cur].count + 1;
                  }
              }
            }

            INTEGER max := options.count != defaultoptions.count AND options.count >= 0 ? options.count : defaultoptions.count;
            IF (max > 0)
              result.suggestions :=
                  SELECT *
                    FROM result.suggestions
                   ORDER BY COLUMN count DESC
                          , text
                   LIMIT max;
          }
          IF (userquery != "")
            UPDATE result.suggestions
               SET text := userquery || text;
        }
      }
    }
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager done", CELL[ result ]);

  RETURN result;
}

PUBLIC INTEGER FUNCTION GetIndexManagerSize(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ indexmanager := 0
      ], options);

  INTEGER size := -1;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  RECORD indexmanager := options.indexmanager = 0 ? RECORD(indexmanagers) : RECORD(SELECT * FROM indexmanagers WHERE id = options.indexmanager);
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD response := SendToConsilio(indexmanager.id, indexid, "/size", DEFAULT RECORD ARRAY, "POST");
        IF (response.status = SearchOk)
          size := ToInteger(GetMIMEHeader(response.headers, "Index-Size"), -1);
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        STRING suffix := indexmanager.indextype = 1 ? "*" : "";
        RECORD response := SendToElasticsearch(indexmanager.id, "", "/_cat/count/" || indexmanager.indexname || suffix, DEFAULT RECORD, "GET");
        IF (response.status = SearchOk)
        {
          // 0     1         2
          // epoch timestamp count
          RECORD ARRAY indexlist :=
              SELECT TEMPORARY parts := Tokenize(indexrow, " ")
                   , indexsize := Length(parts) > 2 ? ToInteger(parts[2], -1) : -1
                FROM ToRecordArray(Tokenize(BlobToString(response.content), "\n"), "indexrow");

          size := SELECT AS INTEGER indexsize FROM indexlist;
        }
      }
    }
  }

  RETURN size;
}

// @cell objects.objectid
// @cell objects.documentfields
// @cell objects.suggestfields (only used by legacy consilio, opensearch uses the mapping's suggested property)
// @cell objects.suggestprefixes (only used by legacy consilio)
PUBLIC STRING FUNCTION AddIndexManagerObjects(INTEGER indexid,
                                              RECORD contentsource,
                                              STRING groupid,
                                              RECORD ARRAY objects,
                                              RECORD options)
{
  RECORD defaultoptions :=
      [ discardsummaries := FALSE // Set to TRUE to not store the document body for summary generation, Consilio only
      , refresh := FALSE // Set to TRUE to wait until visible for search, Elasticsearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , throwonfailure := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);


  objects := SELECT *
                , indextypes :=             CellExists(objects, "INDEXTYPES") ? objects.indextypes : STRING[]
                , indexversions :=          CellExists(objects, "INDEXVERSIONS") ? objects.indexversions : STRING[]
             FROM objects;

  IF(IsDebugTagEnabled("consilio:changes"))
  {
    LogDebug("consilio:changes", "AddIndexManagerObjects", CELL[ indexid, contentsource, groupid, numobjects := Length(objects), options ]);
    FOREVERY(RECORD obj FROM objects)
      LogDebug("consilio:changes", "AddIndexManagerObjects #" || #obj, obj);
  }

  STRING result;
  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  IF (IsDefaultValue(indexmanagers))
    result := SearchIndexNotFound;
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        IF(NOT RecordExists(contentsource))
          THROW NEW Exception("Module indices are not supported by the legacy backend");

        FOREVERY (RECORD obj FROM objects)
        {
          RECORD ARRAY vars := [ [ name := "groupid",       value := EncodeConsilioFieldValue("groupid",       groupid) ]
                               , [ name := "objectid",      value := EncodeConsilioFieldValue("objectid",      obj.objectid) ]
                               , [ name := "contentsource", value := EncodeConsilioFieldValue("contentsource", contentsource.id) ]
                               , [ name := "indextypes",    value := EncodeConsilioFieldValue("indextypes",    obj.indextypes) ]
                               , [ name := "indexversions", value := EncodeConsilioFieldValue("indexversions", obj.indexversions) ]
                               ];
          // Make name lowercase, as Consilio expects field names to be in lowercase and UnpackRecord returns uppercase field names
          vars := vars CONCAT
              SELECT name := ToLowercase(name)
                   , value := EncodeConsilioFieldValue(ToLowercase(name), value)
                FROM UnpackRecord(obj.documentfields);
          // Don't index empty fields
          DELETE FROM vars WHERE IsDefaultValue(value);

          // Add indexid to the suggest field
          IF (Length(obj.suggestfields) > 0)
          {
            // The first part of the suggestfields field is used as the suggest prefix in the index
            STRING indexprefix := ToString(indexid);
            obj.suggestprefixes := obj.suggestprefixes CONCAT RepeatElement("", Length(obj.suggestfields) - Length(obj.suggestprefixes));

            STRING suggestfield;
            FOREVERY (STRING fld FROM obj.suggestfields)
            {
              IF (fld = "")
                CONTINUE;

              STRING prefix := indexprefix || "_" || obj.suggestprefixes[#fld];
              IF (Right(prefix, 1) != "_")
                prefix := prefix || "_";

              suggestfield := suggestfield || " " || fld || " " || prefix;
            }

            INSERT [ name := "suggestfields", value := TrimWhitespace(suggestfield) ] INTO vars AT END;
          }

          IF (options.discardsummaries)
            INSERT [ name := "-discardsummaries", value := "" ] INTO vars AT END;

          RECORD response := SendToConsilio(indexmanager.id, indexid, "/add", vars, "POST-MULTIPART");
          IF (response.status != SearchOk)
          {
            result := result ?? response.status;
            BREAK;
          }
        }
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD response;
        IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
        {
          FOREVERY (RECORD objgroup FROM SELECT objs := GroupedValues(objects) FROM objects)
          {
            RECORD ARRAY bulkrequests;
            FOREVERY (RECORD obj FROM objgroup.objs)
            {
              // action_and_meta_data
              INSERT [ "index" := [ _id := GetElasticsearchDocumentId(indexid, obj.objectid, options.suffix) ]] INTO bulkrequests AT END;
              // optional_source
              INSERT FixupElasticsearchDocumentFields(obj.documentfields) INTO bulkrequests AT END;
            }

            response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_bulk" || (options.refresh ? "?refresh=wait_for" : ""), [ _bulkrequests := bulkrequests ], "POST", CELL[options.throwonfailure]);
            IF (response.status != SearchOk)
            {
              result := result ?? response.status;
              BREAK;
            }
          }
        }
        ELSE
        {
          STRING ARRAY suggestfields := SELECT AS STRING ARRAY name FROM GetContentSourceFields(contentsource.id) WHERE suggested;

          RECORD ARRAY bulkrequests;
          FOREVERY (RECORD obj FROM objects)
          {
            RECORD document := obj.documentfields;
            INSERT CELL groupid := groupid
                      , objectid := obj.objectid
                      , contentsource := contentsource.id
                      , indextypes := obj.indextypes
                      , indexversions := obj.indexversions
              INTO document;

            IF (Length(suggestfields) > 0)
            {
              STRING ARRAY suggested;
              OBJECT tokenizer := NEW TokenStream("");
              FOREVERY (STRING field FROM suggestfields)
              {
                IF (field LIKE "_*")
                  field := Substring(field, 1);
                IF (field IN obj.suggestfields AND CellExists(document, field))
                  tokenizer->AddText(" " || GetCell(document, field));
              }
              RECORD token := tokenizer->GetNextToken();
              WHILE (RecordExists(token))
              {
                IF (token.type = TokenTypeWord AND token.normalizedtext NOT IN suggested)
                  INSERT token.normalizedtext INTO suggested AT END;
                token := tokenizer->GetNextToken();
              }
              IF (Length(suggested) > 0)
                INSERT CELL _suggested := [ input := suggested ] INTO document;
            }

            // action_and_meta_data
            INSERT [ "index" := [ _id := GetElasticsearchDocumentId(indexid, obj.objectid) ] ] INTO bulkrequests AT END;
            // optional_source
            INSERT FixupElasticsearchDocumentFields(document) INTO bulkrequests AT END;
          }
          response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_bulk" || (options.refresh ? "?refresh=wait_for" : ""), [ _bulkrequests := bulkrequests ], "POST");
          IF (response.status != SearchOk)
            result := result ?? response.status;
        }

        IF (result = "")
        {
          IF(response.result.errors)
          {
            RECORD faileditem := SELECT * FROM response.result.items WHERE CellExists(items."index", "error");
            //FIXME we get an _id back, but we don't calculate them here so how to figure out which object it actually referred to for a proper error?
            THROW NEW Exception(`Failed on document '${faileditem."index"._id}': ${faileditem."index".error.reason} (${faileditem."index".error.type})`);
          }
        }
      }
    }
  }

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "AddIndexManagerObjects done", CELL[ result ]);

  RETURN result ?? SearchOk;
}

/** @short Delete a group from an index
    @param indexid The index to delete the group from (0 for all indices)
    @param contentsourceid The content source to delete the group from (0 for
        all content sources)
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
    @param groupid The group to delete
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerGroup(INTEGER indexid, INTEGER contentsourceid, STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      ], options);

  IF (groupid = "")
    RETURN SearchInvalidArgument;

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerGroup", CELL[ indexid, contentsourceid, groupid, options ]);

  STRING result;
  IF (groupid != "")
  {
    RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
    FOREVERY (RECORD indexmanager FROM indexmanagers)
    {
      SWITCH (indexmanager.type)
      {
        CASE whconstant_consilio_indexmanager_legacybackend
        {
          RECORD ARRAY vars := [ [ name := "groupid", value := groupid ]
                               ];
          IF (contentsourceid != 0)
            INSERT [ name := "contentsource", value := ToString(contentsourceid) ] INTO vars AT END;

          RECORD response := SendToConsilio(indexmanager.id, indexid, "/delete", vars, "POST");
          IF (response.status != SearchOk)
            result := result ?? response.status;
        }
        CASE whconstant_consilio_indexmanager_opensearch
        {
          // No support for groupids in unmanaged indices
          IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
          {
            IF (indexid != 0)
              result := SearchCommandUnsupported;
            CONTINUE;
          }

          RECORD query :=
              [ query :=
                  [ bool :=
                      [ must :=
                            [ [ match := [ groupid := groupid ] ]
                            ]
                      ]
                  ]
              ];
          IF (contentsourceid != 0)
            INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

          RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", `/_delete_by_query${ options.refresh ? "?refresh" : ""}`, query, "POST");
          result := response.status;
        }
      }
    }
    result := result ?? SearchOk;
  }
  ELSE
    result := SearchInvalidArgument;

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerGroup done", CELL[ result ]);

  RETURN result;
}

/** @short Delete an object from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param options @includecelldef #DeleteIndexManagerObjects.options
    @param objectid The object to delete
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObject(INTEGER indexid, INTEGER contentsourceid, STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN DeleteIndexManagerObjects(indexid, contentsourceid, [objectid], options);
}

/** @short Delete multiple objects from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param objectids The objects to delete
    @cell(boolean) options.refresh Set to TRUE to wait until visible for search, Elasticsearch only
    @cell(string) options.suffix Sub-index suffix, for unmanaged indices, Elasticsearch only
    @cell(boolean) options.throwonfailure Throw on failre, Elasticsearch only
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObjects(INTEGER indexid, INTEGER contentsourceid, STRING ARRAY objectids, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD defaultoptions :=
      [ refresh := FALSE // Set to TRUE to wait until visible for search, Elasticsearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , throwonfailure := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  STRING result;

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerObjects", CELL[ indexid, contentsourceid, objectids, options ]);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        FOREVERY (STRING objectid FROM objectids)
        {
          RECORD ARRAY vars := [ [ name := "objectid", value := objectid ]
                               ];
          IF (contentsourceid != 0)
            INSERT [ name := "contentsource", value := ToString(contentsourceid) ] INTO vars AT END;

          RECORD response := SendToConsilio(indexmanager.id, indexid, "/delete", vars, "POST");
          IF (response.status != SearchOk)
          {
            result := result ?? response.status;
            BREAK;
          }
        }
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        // For unmanaged indices, delete by document id
        IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
        {
          IF (indexid = 0 OR contentsourceid != 0)
            result := SearchCommandUnsupported;
          ELSE
          {
            RECORD ARRAY bulkrequests :=
                SELECT "delete" := [ _id := GetElasticsearchDocumentId(indexid, objectid, options.suffix) ]
                  FROM ToRecordArray(objectids, "objectid");

            RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), "/_bulk" || (options.refresh ? "?refresh=wait_for" : ""), [ _bulkrequests := bulkrequests ], "POST", CELL[options.throwonfailure]);
            IF (response.status != SearchOk)
              result := result ?? response.status;
          }
          CONTINUE;
        }

        RECORD query :=
            [ query :=
                [ bool :=
                    [ must := (SELECT match := [ objectid := objectid ] FROM ToRecordArray(objectids, "objectid"))
                    ]
                ]
            ];
        IF (contentsourceid != 0)
          INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

        RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", `/_delete_by_query${ options.refresh ? "?refresh" : ""}`, query, "POST");
        IF (response.status != SearchOk)
          result := response.status;
      }
    }
  }
  result := result ?? SearchOk;

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerObjects done", CELL[ result ]);

  RETURN result;
}

/** @short Delete outdated objects
    @param indexid The index to delete outdated objects from
    @param contentsourceid The content source to delete outdated objects from (0
        for all content sources)
    @param groupid Delete outdated objects for this group only ("" for all groups)
    @param objectid Delete outdated objects for this object only ("" for all objects)
    @param deletebefore Delete all objects that have been indexed before this date
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
    @return The deletion result
    @cell(integer) return.deleted The number of deleted objects
    @cell(string array) return.active The id's of the objects that were matched,
        but not deleted, because they were indexed on or after the given date
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerOutdated(INTEGER indexid,
                                                  INTEGER contentsourceid,
                                                  STRING groupid,
                                                  STRING objectid,
                                                  DATETIME deletebefore,
                                                  RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      ], options);

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerOutdated", EncodeJSON(CELL[ indexid, contentsourceid, groupid, objectid, deletebefore, options ]));

  RECORD result := [ status := SearchInvalidArgument
                   , deleted := 0
                   , active := DEFAULT STRING ARRAY
                   ];
  IF (indexid != 0 AND deletebefore != DEFAULT DATETIME)
  {
    RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
    result.status := IsValueSet(indexmanagers) ? SearchOk : SearchIndexNotFound;
    FOREVERY (RECORD indexmanager FROM indexmanagers)
    {
      SWITCH (indexmanager.type)
      {
        CASE whconstant_consilio_indexmanager_legacybackend
        {
          // All objects in the index with an index date before this task's index date can be removed from the index.
          RECORD ARRAY vars := [ [ name := "last_indexed", value := DateTimeToString(deletebefore) ]
                               ];
          IF (contentsourceid != 0)
            INSERT [ name := "contentsource", value := ToString(contentsourceid) ] INTO vars AT END;
          IF (groupid != "")
            INSERT [ name := "groupid", value := groupid ] INTO vars AT END;
          IF (objectid != "")
            INSERT [ name := "objectid", value := objectid ] INTO vars AT END;

          RECORD response := SendToConsilio(indexmanager.id, indexid, "/deleteoutdated", vars, "POST");

          result.status := result.status ?? response.status;
          IF (result.status = SearchOk)
          {
            IF (result.deleted >= 0)
              result.deleted := ToInteger(GetMIMEHeader(response.headers, "Deleted"), 0);
            result.active :=
                SELECT AS STRING ARRAY LimitUTF8Bytes(objid, VAR MaxLinkLength)
                  FROM ToRecordArray(Tokenize(BlobToString(response.content, -1), "\n"), "objid")
                 WHERE objid != "";
          }
        }
        CASE whconstant_consilio_indexmanager_opensearch
        {
          // No support for outdated documents in unmanaged indices
          IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
            result.status := SearchCommandUnsupported;

          // delete all documents having 'date_indexed' before 'deletebefore'
          RECORD query :=
              [ query :=
                  [ bool :=
                      [ must := DEFAULT RECORD ARRAY
                      , filter :=
                          [ [ range := [ date_indexed := [ lt := FormatISO8601DateTime(deletebefore, "day", "milliseconds") ] ] ]
                          ]
                      ]
                  ]
              ];
          IF (contentsourceid != 0)
            INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;
          IF (groupid != "")
            INSERT [ match := [ groupid := groupid ] ] INTO query.query.bool.must AT END;
          IF (objectid != "")
            INSERT [ match := [ objectid := objectid ] ] INTO query.query.bool.must AT END;

          /* Refresh the index beforoe we start deletion. Works around "version conflict, required seqNo [...]" we noticed
             when running wh consilio:manualindex publisher:whfs - suspecting the delete is trying to delete older versions

             maybe we can set conflicts=proceed but I'm not sure if that will then fail to delete or delete the most recent version*/
          SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_refresh", DEFAULT RECORD, "GET");

          RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, `/_delete_by_query${ options.refresh ? "?refresh" : ""}`, query, "POST");
          result.status := result.status ?? response.status;
          IF (result.status = SearchOk)
          {
            result.deleted := response.result.deleted;

            // Find documents that aren't deleted
            DELETE CELL filter FROM query.query.bool;
            INSERT CELL _source := [ "objectid" ] INTO query;
            response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_search", query, "POST");
            IF (response.status = SearchOk AND Length(response.result.hits.hits) > 0)
            {
              result.active :=
                  SELECT AS STRING ARRAY _source.objectid
                    FROM response.result.hits.hits;
            }
          }
        }
      }
    }
  }

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerOutdated done", EncodeJSON(CELL[ result ]));

  RETURN result;
}

/** Deletes all documents in an index from a specific contentsource
    @param indexmgrid Id of the indexmanager to use
    @param indexid Id of the index
    @param contentsourceid Id of the contentsource whose documents must be removed (set to 0 to delete the entire index)
    @cell options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @return Execution result
    @cell return.status Status
    @cell return.deleted Number of deleted documents
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerContentSource(INTEGER indexmgrid, INTEGER indexid, INTEGER contentsourceid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD result := [ status := SearchUnavailable
                   , deleted := 0
                   ];
  RECORD ARRAY indexmanagers := indexid != 0 ? GetIndexManagersForIndex(indexid, [ withdeleted := TRUE ]) : GetIndexManagers(indexmgrid, [ withdeleted := TRUE ]);
  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerContentSource",
                                  EncodeJSON(CELL[ indexmgrid, indexid, contentsourceid, options ]));

  /* TODO this approach really just returns the *last* deletion status, and may (re)delete multiple indices if already marked
     as deletion. This looping should probably happen in the catalog api */
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    IF ((indexmgrid != 0 AND indexmanager.id != indexmgrid) OR indexid = 0)
      CONTINUE;

    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD ARRAY vars := [ [ name := "indexid", value := ToString(indexid) ]
                             ];
        IF (contentsourceid != 0)
          INSERT [ name := "contentsource", value := ToString(contentsourceid) ] INTO vars AT END;

        RECORD response := SendToConsilio(indexmanager.id, indexid, "/delete", vars, "POST");
        result.status := response.status;
        IF (result.status = SearchOk)
          result.deleted := ToInteger(GetMIMEHeader(response.headers, "Deleted"), 0);
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD indexinfo := SELECT * FROM consilio.catalogs WHERE id = indexid;
        IF (RecordExists(indexinfo) AND indexinfo.type = whconstant_consilio_catalogtype_unmanaged)
        {
          // Delete the specific subindex if suffix is set, otherwise delete all subindices
          RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : "*"), "", DEFAULT RECORD, "DELETE");
          result.status := response.status;
          // Deleting an index doesn't return the number of deleted documents...
        }
        ELSE IF (contentsourceid = 0)
        {
          // No content source specified, delete entire index
          RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "", DEFAULT RECORD, "DELETE");
          result.status := response.status;
          // Deleting an index doesn't return the number of deleted documents...
        }
        ELSE
        {
          RECORD query :=
              [ query :=
                  [ bool :=
                      [ must :=
                            [ [ match := [ contentsource := contentsourceid ] ]
                            ]
                      ]
                  ]
              ];
          // Delete all objects within the content source
          RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", "/_delete_by_query", query, "POST");
          result.status := response.status;
          IF (result.status = SearchOk)
            result.deleted := response.result.deleted;
        }
      }
    }
  }

 IF(IsDebugTagEnabled("consilio:changes"))
   LogDebug("consilio:changes", "DeleteIndexManagerContentSource done", result);

 IF (result.status = SearchOk)
    BroadcastEvent("consilio:contentsourcestatus", [ id := contentsourceid ]);

  RETURN result;
}

/** Deletes all documents in an index from a specific contentsource
    @param indexmgrid Id of the indexmanager to use
    @param indexid Id of the index
    @param indexname Name of the index at the indexmanager
    @cell options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @return Execution result
    @cell return.status Status
    @cell return.deleted Number of deleted documents
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerIndex(INTEGER indexmgrid, INTEGER indexid, STRING indexname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD result := [ status := SearchUnavailable
                   , deleted := 0
                   ];

  RECORD indexmanager := GetIndexManagers(indexmgrid, [ withdeleted := TRUE ]);

  IF(IsDebugTagEnabled("consilio:changes"))
    LogDebug("consilio:changes", "DeleteIndexManagerContentSource",
                                   EncodeJSON(CELL[ indexmgrid, indexid, indexname, options ]));

  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        RECORD ARRAY vars := [ [ name := "indexid", value := ToString(indexid) ]
                             ];

        RECORD response := SendToConsilio(indexmanager.id, indexid, "/delete", vars, "POST");
        result.status := response.status;
        IF (result.status = SearchOk)
          result.deleted := ToInteger(GetMIMEHeader(response.headers, "Deleted"), 0);
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD indexinfo := SELECT * FROM consilio.catalogs WHERE id = indexid;
        IF (RecordExists(indexinfo) AND indexinfo.type = whconstant_consilio_catalogtype_unmanaged)
        {
          // Delete the specific subindex if suffix is set, otherwise delete all subindices
          RECORD response := SendToElasticsearch(indexmanager.id, indexname || (options.suffix != "" ? "-" || options.suffix : "*"), "", DEFAULT RECORD, "DELETE");
          result.status := response.status;
          // Deleting an index doesn't return the number of deleted documents...
        }
        ELSE
        {
          // No content source specified, delete entire index
          RECORD response := SendToElasticsearch(indexmanager.id, indexname, "", DEFAULT RECORD, "DELETE");
          result.status := response.status;
          // Deleting an index doesn't return the number of deleted documents...
        }
      }
    }
  }

 IF(IsDebugTagEnabled("consilio:changes"))
   LogDebug("consilio:changes", "DeleteIndexManagerIndex done", result);

  RETURN result;
}

PUBLIC STRING FUNCTION RefreshIndexManager(INTEGER indexmgrid, INTEGER indexid)
{
  STRING result := SearchOk;
  IF(indexid=0)
    THROW NEW Exception(`Specify the indexid please!`); //it looks like noone was using this, so we can simplify this API further? checking...

  RECORD indexmanager :=/* indexmgrid != 0
      ? GetIndexManagers(indexmgrid)
      : */GetIndexManagersForIndex(indexid);
  IF (RecordExists(indexmanager))
  {
    SWITCH (indexmanager.type)
    {
      CASE whconstant_consilio_indexmanager_legacybackend
      {
        // Not supported, ignore
      }
      CASE whconstant_consilio_indexmanager_opensearch
      {
        RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "", "/_refresh", DEFAULT RECORD, "GET");
        result := response.status;
      }
    }
  }
  RETURN result;
}


// -----------------------------------------------------------------------------
//
// Helper functions
//

/** @short Find an indexmanager
    @param indexmgrid The id of the indexmanager, or -1 for all indexmanagers
    @cell options.managedonly Only consider managed catalogs
    @cell options.withdeleted Also return deleted catalogs/catalogindices
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
RECORD ARRAY FUNCTION GetIndexManagers(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
        [ managedonly := FALSE
        , withdeleted := FALSE
        ], options);

  RETURN
      SELECT indexmanagers.id
           , indexmanagers.type
           , catalog_indexmanagers.indexname
           , indextype := catalogs.type
           , indexid := catalogs.id
           , primary
        FROM consilio.indexmanagers
           , consilio.catalog_indexmanagers
           , consilio.catalogs
       WHERE indexmanagers.id = catalog_indexmanagers.indexmanager
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (indexmgrid = -1 OR indexmanagers.id = indexmgrid)
             AND (options.withdeleted
                ? TRUE
                : (NOT deleted AND catalogs.name NOT LIKE "$consilio$deleted$*"))
    ORDER BY primary DESC;
}

/** @short Find the indexmanager for an index
    @param indexid The id of the index, or 0 for the indexmanagers of all indices
    @cell options.managedonly Only consider managed catalogs
    @cell options.withdeleted Also return deleted catalogs/catalogindices
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
PUBLIC RECORD ARRAY FUNCTION GetIndexManagersForIndex(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ managedonly := FALSE
      , withdeleted := FALSE
      ], options);

  IF (indexid = 0)
    RETURN GetIndexManagers(-1, options);

  RETURN
      SELECT indexmanagers.id
           , indexmanagers.type
           , catalog_indexmanagers.indexname
           , catalogs.lang
           , indextype := catalogs.type
           , primary
        FROM consilio.catalogs
           , consilio.catalog_indexmanagers
           , consilio.indexmanagers
       WHERE catalogs.id = indexid
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND catalog_indexmanagers.indexmanager = indexmanagers.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (options.withdeleted
                ? TRUE
                : (NOT deleted AND catalogs.name NOT LIKE "$consilio$deleted$*"))
    ORDER BY primary DESC;
}

RECORD FUNCTION SaveQuery(RECORD sess, RECORD query, INTEGER idx, STRING restrict, DATETIME searchdate, INTEGER numresults)
{
  IF (NOT RecordExists(sess) OR /*sess.sessid="" OR*/ idx = 0 OR numresults < 0)
    RETURN sess;

  // Format query and truncate to fit into 1024-byte database limit
  STRING querystring := __FormatQuery(idx, query, [ field := "", userquery := TRUE ]); //FIXME language for __FormatQuery
  querystring := LimitUTF8Bytes(querystring, 1024);

  INTEGER site;
  // Check if the siteid is supplied explicitly through the session record
  IF (CellExists(sess, "siteid"))
    site := SELECT AS INTEGER id FROM system.sites WHERE id = sess.siteid;
  IF (site = 0)
  {
    // Try to determine the searched site
    RECORD ARRAY contentsource := SELECT fsobject
                                    FROM consilio.contentsources
                                   WHERE catalogid = idx
                                         AND contentprovider = "publisher:webhare"
                                         AND contentsources.tag NOT LIKE "$consilio$deleted$*";
    IF (Length(contentsource) = 1)
    {
      // Only one site added to index, use it
      site := SELECT AS INTEGER parentsite
                FROM system.fs_objects
               WHERE fs_objects.id = VAR contentsource[0].fsobject
                     AND fs_objects.isfolder = TRUE;
    }
    ELSE
    {
      // Lookup restriction url (LookupPublisherURL always returns a record, 'site' may be 0)
      site := LookupPublisherURL(restrict).site;
    }
  }

  RETURN RunInSeparatePrimary(PTR StoreQuery(sess, querystring, idx, numresults, site));
}

RECORD FUNCTION StoreQuery(RECORD sess, STRING querystring, INTEGER idx, INTEGER numresults, INTEGER site)
{
  GetPrimary()->BeginWork();

  DATETIME now := GetCurrentDateTime();
  RECORD savedsess := SELECT * FROM consilio.query_results WHERE COLUMN sess = VAR sess.sessid;

  // Create a new search session if the session doesn't exists yet, if another
  // query was issued or if the session expired
  IF (NOT RecordExists(savedsess) OR savedsess.query != querystring OR AddTimeToDate(session_timeout * 60 * 1000, savedsess.when) < now)
  {
    // Update session id and insert new session
    sess.sessid := GenerateUFS128BitId();
    INSERT INTO consilio.query_results(query, when, catalogid, pages, sess, results, site, tag)
         VALUES (querystring, now, idx, 0, sess.sessid, numresults, site, sess.tag);
  }
  ELSE
  {
    // Update existing session
    UPDATE consilio.query_results
       SET when := now
         , pages := pages + 1
         , results := numresults
     WHERE COLUMN sess = VAR sess.sessid;
  }

  GetPrimary()->CommitWork();

  RETURN sess;
}

// Create a (flattened) list of requested fields
PUBLIC STRING ARRAY FUNCTION GetRequestedFields(RECORD mapping)
{
  STRING ARRAY fields;
  FOREVERY (RECORD field FROM UnpackRecord(mapping))
  {
    IF (CanCastTypeTo(TypeID(field.value), TypeID(RECORD)) AND RecordExists(field.value))
      FOREVERY (STRING subfield FROM GetRequestedFields(field.value))
        INSERT ToLowercase(field.name) || "." || subfield INTO fields AT END;
    ELSE
      INSERT ToLowercase(field.name) INTO fields AT END;
  }
  RETURN fields;
}

RECORD FUNCTION GetCacheableIndexConfiguration(INTEGER indexid)
{
  // Get the default result fields
  RECORD defaultmapping;
  RECORD ARRAY mapping := GetIndexMapping(indexid);
  FOREVERY (RECORD field FROM mapping)
    IF (NOT CellExists(defaultmapping, field.name))
      defaultmapping := CellInsert(defaultmapping, field.name, field.defaultvalue);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);

  RETURN [ value := CELL [ defaultmapping, indexmanagers ]
         , ttl := 15 * 60 * 1000
         , eventmasks := [ "consilio:contentsourceschanged"
                         , "consilio:indexfields"
                         ]
         ];
}

PUBLIC RECORD ARRAY FUNCTION GetIndexMapping(INTEGER indexid)
{
  RECORD ARRAY fields;
  TRY
  {
    RECORD def;
    STRING ARRAY fieldgroups :=
        SELECT AS STRING ARRAY fieldgroup
          FROM ToRecordArray(Tokenize((SELECT AS STRING COLUMN fieldgroups FROM consilio.catalogs WHERE id = indexid), " "), "fieldgroup")
         WHERE fieldgroup != "";
    IF (Length(fieldgroups) > 0)
      def := GetFieldgroupsFieldDefinition(fieldgroups, TRUE);
    ELSE
      def := GetIndexFieldDefinition(SELECT AS STRING name FROM consilio.catalogs WHERE id = indexid);
    IF (RecordExists(def))
      fields := def.properties;
  }
  CATCH; // No module field definition for this catalog

  INTEGER ARRAY contentsourceids :=
      SELECT AS INTEGER ARRAY id
        FROM consilio.contentsources
       WHERE COLUMN catalogid = VAR indexid
             AND tag NOT LIKE "$consilio$deleted$*";
  fields := GetContentSourcesMapping(contentsourceids, fields);
  /* fields := fields CONCAT
      SELECT fields.name
           , fields.type
           , fields.defaultvalue
           , fields.tokenized
           , fields.suggested
        FROM consilio.contentsourcefields AS fields
           , consilio.contentsources AS sources
       WHERE fields.contentsourceid = sources.id
             AND sources.catalogid = VAR indexid
             AND sources.tag NOT LIKE "$consilio$deleted$*";
  fields :=
      SELECT AS RECORD ARRAY GroupedValues(fields)[0]
        FROM fields
       GROUP BY ToUppercase(name); */
  RETURN fields;
}
