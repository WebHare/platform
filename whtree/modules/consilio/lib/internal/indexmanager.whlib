<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib" EXPORT running_in_fetcher, print_defer_connection;
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT SearchOk, SearchError, SearchIndexNotFound, SearchCommandUnsupported, SearchNoAccess, SearchConnectError, SearchSendError, SearchHTTPError, SearchNoTotalError, SearchUnavailable, SearchTimeOutError, SearchInvalidArgument, SearchSleep, SearchRebuildCatalog;
LOADLIB "mod::consilio/lib/internal/elasticsearch/analysis.whlib";

LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


// -----------------------------------------------------------------------------
//
// Public API
//

PUBLIC OBJECT FUNCTION WaitForIndexManager(INTEGER indexmgrid, DATETIME waituntil DEFAULTSTO DEFAULT DATETIME)
{
  waituntil := waituntil ?? MAX_DATETIME;
  RECORD indexmanager := SELECT FROM consilio.indexmanagers WHERE id = indexmgrid;

  IF (RecordExists(indexmanager))
    RETURN WaitForElasticsearch(indexmgrid, waituntil);

  RETURN CreateRejectedPromise(NEW Exception(SearchIndexNotFound));
}


PUBLIC RECORD FUNCTION GetIndexManagerState(INTEGER indexmgrid)
{
  RECORD result :=
      [ status := SearchOk
      , msg := DEFAULT STRING ARRAY
      ];

  RECORD indexmanager := GetIndexManagers(indexmgrid);
  IF (RecordExists(indexmanager))
    result := GetElasticsearchStatus(indexmanager.id);

  RETURN result;
}

/** @short Get a list of indices from an indexmanager
    @param indexmgrid The id of the indexmanager
    @param options Options
    @return The result
    @cell(string) return.status The result status
    @cell(integer array) return.indices The list of index id's known by this
        indexmanager, or DEFAULT INTEGER ARRAY when there are no indices or when
        no indexmanager with the given id exists
*/
PUBLIC RECORD FUNCTION GetIndexManagerIndexList(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[], options);

  RECORD result :=
      [ status := SearchIndexNotFound
      , indices := DEFAULT RECORD ARRAY
      ];

  RECORD ARRAY indexmanagers := GetIndexManagers(indexmgrid);
  RECORD indexmanager := indexmanagers;
  IF (NOT RecordExists(indexmanager))
    RETURN result;

  RECORD response := SendToElasticsearch(indexmanager.id, "", "/_cat/indices/?format=json&bytes=b", DEFAULT RECORD, "GET");
  result.status := response.status;
  IF (response.status = SearchOk)
  {
    //Find the indices we were expecting here
    RECORD ARRAY indexlist := RECORD ARRAY(DecodeJSONBlob(response.content));
    //fix counters which are sometimes 0s or strings...
    indexlist := EnforceStructure([[ "docs.count" := 0i64
                                   , "pri.store.size" := 0i64
                                   ]
                                  ], indexlist);

    // Unmanaged indices may have a suffix: <indexname>-<suffix>
    indexlist := SELECT TEMPORARY toks := Tokenize(indexlist."index",'-')
                      , indexname := toks[0]
                      , suffix := Length(toks) > 1 ? toks[1] : ""
                      , health
                      , status
                      , docs := indexlist."docs.count"
                      , size := indexlist."pri.store.size"
                      , indexid := (SELECT AS INTEGER indexid FROM indexmanagers WHERE indexname = toks[0])
                   FROM indexlist;

    indexlist :=
        SELECT health := PickFirst(SELECT AS STRING ARRAY health FROM GroupedValues(indexlist) ORDER BY SearchElement([ "red", "yellow", "green" ], health))
             , status := PickFirst(SELECT AS STRING ARRAY status FROM GroupedValues(indexlist) ORDER BY SearchElement([ "close", "open" ], status))
             , docs := Sum(docs)
             , size := Sum(size)
             , indexname
             , indexid := ANY(indexid)
             , suffixes := GroupedValues(suffix)
          FROM indexlist
      GROUP BY indexname;

    result.indices := SELECT indexid, indexname, suffixes FROM indexlist ORDER BY indexid, indexname;
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION GetIndexStats(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ metrics := STRING[ "_all" ]
      ], options,
      [ enums :=
          [ metrics := // https://www.elastic.co/guide/en/elasticsearch/reference/7.17/indices-stats.html#index-stats-api-path-params
              [ "_all", "completion", "docs", "fielddata", "flush", "get", "indexing", "merge", "query_cache", "refresh"
              , "request_cache", "search", "segments", "store", "suggest", "translog", "warmer"
              ]
          ]
      ]);
  RECORD result :=
      [ status := SearchIndexNotFound
      , stats := DEFAULT RECORD
      ];

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager))
   THROW NEW Exception(`No indexmanager configured for index #${indexid}`);

  RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_stats/" || Detokenize(options.metrics, ","), DEFAULT RECORD, "GET");
  result.status := response.status;
  IF (response.status = SearchOk)
    result.stats := GetCell(response.result.indices, indexmanager.indexname).total;

  RETURN result;
}

BOOLEAN FUNCTION IsOutofdateAnalysis(RECORD currentanalysis, RECORD newanalysis)
{
  CONSTANT RECORD structure := [ filter := [ synonym := [ synonyms := STRING[] ]]];
  currentanalysis := EnforceStructure(structure, currentanalysis);
  newanalysis := EnforceStructure(structure, newanalysis);
  RETURN EncodeHSON(currentanalysis) != EncodeHSON(newanalysis);
}

PUBLIC BOOLEAN __did_opensearch_close_and_reopen; //tests currently need this to verify that we didn't unnecessarily close an index.

PUBLIC MACRO EnsureOpenSearchIndexConfiguration(INTEGER indexmanager, STRING indexname, STRING suffix, STRING ARRAY synonyms, STRING lang, RECORD mapping)
{
  RECORD setanalysis := GetAnalysisForLanguage(lang);
  // Add the synonyms filter
  INSERT CELL synonym := CELL
      [ type := "synonym_graph"
      , synonyms
      ] INTO setanalysis.filter;

  STRING fullname := indexname || (suffix != "" ? "-" || suffix : "");
  TRY
  {
    SendToElasticsearch(indexmanager, fullname, "",
         CELL[ settings := [ number_of_replicas := 0 // we don't configure replication on our own indicessettings
                           , analysis := setanalysis
                           ]
             , mappings := mapping
             ], "PUT");
  }
  CATCH(OBJECT<ElasticSearchException> e)
  {
    IF(RecordExists(e->error) AND e->error.type IN [ "index_already_exists_exception", "resource_already_exists_exception" ])
    {
      //Then just update the configuration

      // Analysis settings cannot be updated on opened indices, so the index has to be closed first and reopened after update
      RECORD currentsettings := SendToElasticsearch(indexmanager, fullname, "/_settings", DEFAULT RECORD, "GET").result;
      currentsettings := GetCell(currentsettings, fullname).settings;

      RECORD applysettings;
      IF(NOT CellExists(currentsettings."index",'analysis') OR IsOutofdateAnalysis(currentsettings."index".analysis, setanalysis))
        INSERT CELL analysis := setanalysis INTO applysettings;

      IF(RecordExists(applysettings))
      {
        BOOLEAN close_index := CellExists(applysettings, "analysis");
        IF (close_index)
        {
          __did_opensearch_close_and_reopen := TRUE;
          SendToElasticsearch(indexmanager, fullname, "/_close", DEFAULT RECORD, "POST");
        }

        // Update the settings
        TRY
        {
          SendToElasticsearch(indexmanager, fullname, "/_settings", applysettings, "PUT");
        }
        FINALLY
        {
          // Open the index again if needed. Even if /_settings throws
          IF (close_index)
          {
            TRY
            {
              SendToElasticsearch(indexmanager, fullname, "/_open", DEFAULT RECORD, "POST");
            }
            CATCH(OBJECT f)
            {
              LogHarescriptException(f);
              //And ignore it. not much we can do about a throw here
            }
          }
        }
      }

      SendToElasticsearch(indexmanager, fullname, "/_mapping", mapping, "PUT");
    }
    ELSE
    {
      THROW;
    }
  }
}

PUBLIC RECORD FUNCTION GetIndexManagerMapping(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager))
    THROW NEW Exception(`No such catalog #${indexid}`);
  IF (options.suffix != "" AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
    THROW NEW Exception(`Managed Consilio catalog #${indexid} does not support suffixes`);

  STRING finalindexname := indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : "");
  RECORD response := SendToElasticsearch(indexmanager.id, finalindexname, "/_mapping", DEFAULT RECORD, "GET");

  RECORD mappings := GetCell(response.result, finalindexname).mappings;
  mappings := EnforceStructure([ dynamic_templates := RECORD[]], mappings);
  RETURN mappings;
}

/** @short Search an index
    @param indexid The id of the index to query; 0 for all indices
    @param query The query to execute
    @param useroptions Search options
    @cell(integer) useroptions.first The first result to return (0-based, defaults to 0)
    @cell(integer) useroptions.count The number of results to return; 0 for no results (but still returning the number of result),
        -1 for all results (defaults to 0)
    @cell(integer) useroptions.summary The length of the summary to generate; 0 for no summary (defaults to 200)
    @cell(boolean) useroptions.highlightfields Highlight matched search terms in these fields
    @cell(string) useroptions.lang The language used for searching (used for various language-specific features)
    @cell(string) useroptions.restrict_to Restrict results to URLs starting with restrict_to
    @cell(record) useroptions.mapping The search result field mapping to use; DEFAULT RECORD for all known fields
    @return Search results
    @cell(string) return.status Return status (eg SearchOk)
    @cell(integer) return.totalcount Number of returned results
    @cell(record array) return.results Results
    @cell(record) return.session Search session
*/
PUBLIC RECORD FUNCTION SearchIndexManager(INTEGER indexid, RECORD query, RECORD useroptions, RECORD indexoptions)
{
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , summary := 200
      , highlightfields := STRING[]
      , lang := ""
      , restrict_to := ""
      , exclude_urls := STRING[]
      , mapping := indexoptions.defaultmapping
      , aggregation_mapping := DEFAULT RECORD
      , session := DEFAULT RECORD
      , addscore := FALSE
      , debug := FALSE
      ];

  RECORD options := ValidateOptions(defaultoptions, useroptions);
  IF(options.addscore)
    options.mapping := CELL[...options.mapping, _score := 0f ];

  IF (options.summary != 0 AND NOT CellExists(options.mapping, "_SUMMARY"))
    INSERT CELL _summary := "" INTO options.mapping;

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , results := DEFAULT RECORD ARRAY
      , session := options.session
      ];

  STRING catalog := SELECT AS STRING name FROM consilio.catalogs WHERE id = indexid;
  IF (catalog = "")
    RETURN result;

  DATETIME querystart := GetCurrentDateTime();

  RECORD indexmanager := indexoptions.indexmanagers;
  IF (RecordExists(indexmanager))
  {
    STRING queryuuid := GenerateUFS128BitId();

    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an aggregation query or unmanaged index
    IF (NOT CellExists(query, "aggregation") AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    STRING ARRAY requested_fields := GetRequestedFields(mapping);

    //FIXME Get rid of the broadcasts, just use the logging system ?
    RECORD searchstart := CELL[ event := "searchstart"
                              , queryuuid
                              , options.restrict_to
                              , options.exclude_urls
                              , options.first
                              , options.count
                              , summary_length := options.summary
                              , options.lang
                              , sess := RecordExists(options.session) ? options.session.sessid : ""
                              , options.highlightfields
                              , fields := requested_fields
                              , uuid := queryuuid
                              , now := querystart
                              , catalog
                              ];

    RECORD searchquery := CreateElasticsearchQuery(query);

    INSERT CELL _source := requested_fields INTO searchquery;

    IF (options.first != defaultoptions.first)
      INSERT CELL "from" := options.first INTO searchquery;
    IF (CellExists(searchquery, "aggs") AND NOT RecordExists(options.aggregation_mapping))
      INSERT CELL size := 0 INTO searchquery; // Only interested in aggregation result
    ELSE IF (options.count != defaultoptions.count)
      INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;
    IF (options.summary != 0 OR Length(options.highlightfields) > 0)
    {
      INSERT CELL highlight :=
          [ fields := RECORD[]
          , pre_tags := [ Length(options.highlightfields) > 0 ? "\x1d" : "" ]
          , post_tags := [ Length(options.highlightfields) > 0 ? "\x1c" : "" ]
          ] INTO searchquery;
      // The body is used for summary generation with the given length (with number_of_fragments set to 1)
      IF (options.summary != 0 OR "body" IN options.highlightfields)
        INSERT [ body :=
                   [ number_of_fragments := 1
                   , fragment_size := options.summary < 0 ? defaultoptions.summary : options.summary
                   , no_match_size := options.summary < 0 ? defaultoptions.summary : options.summary
                   ]
               ] INTO searchquery.highlight.fields AT END;
      // The other highlight fields are returned completely (number_of_fragments set to 0)
      FOREVERY (STRING field FROM options.highlightfields)
        IF (field != "body")
          INSERT CellInsert(DEFAULT RECORD, field, [ number_of_fragments := 0 ]) INTO searchquery.highlight.fields AT END;
    }
    IF (options.restrict_to != defaultoptions.restrict_to)
    {
      RECORD restrict_filter := [ prefix := [ initialfilter := options.restrict_to ] ];
      searchquery.query := AddElasticsearchQueryFilters(searchquery.query, [ restrict_filter ], FALSE);
    }
    IF (Length(options.exclude_urls) > 0)
    {
      RECORD ARRAY exclude_filters;
      FOREVERY (STRING url FROM options.exclude_urls)
        INSERT [ prefix := [ initialfilter := url ] ] INTO exclude_filters AT END;
      searchquery.query := AddElasticsearchQueryFilters(searchquery.query, exclude_filters, TRUE);
    }

    RECORD finalquery := [ method := "GET"
                         , path := "/" || indexmanager.indexname || (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged ? "*" : "") || "/_search"
                         , body := searchquery
                         ];

    IF(IsDebugTagEnabled("consilio:searches"))
      LogDebug("consilio:searches", "OpenSearch search", CELL[ ...searchstart, searchquery := finalquery ]);

    BroadcastEvent("consilio:executedquery", CELL[ isstart := TRUE
                                                 , uuid := queryuuid
                                                 , searchquery := finalquery
                                                 , options.restrict_to
                                                 , options.first
                                                 , options.count
                                                 , summary_length := options.summary
                                                 , sess := RecordExists(options.session) ? options.session.sessid : ""
                                                 , options.highlightfields
                                                 , fields := requested_fields
                                                 , now := querystart
                                                 , catalog
                                                 ]);

    IF(options.debug)
      Print(`OpenSearch query:\nGET ${finalquery.path}\n${EncodeJSON(searchquery)}\n`);

    RECORD response := SendRawJSONToElasticsearch(indexmanager.id, finalquery.method, finalquery.path, finalquery.body, CELL[ enforce := "_search_get" ]);
    IF(options.debug)
      DumpValue(response, "tree");

    result.status := response.status;
    IF (result.status = SearchOk)
    {
      IF (response.result.timed_out)
        result.status := SearchTimeOutError;
      ELSE
      {
        IF (CellExists(query, "aggregation"))
        {
          result.totalcount := result.totalcount + response.result.hits.total.value;
          IF (RecordExists(options.aggregation_mapping))
            INSERT CELL aggregation := RECORD[] INTO result;

          // If the main aggregation is a 'count' aggregation, there are no aggregation results
          IF (query.aggregation._type = "count")
          {
            RECORD aggresult := CellInsert(DEFAULT RECORD, query.aggregation.name, response.result.hits.total.value);
            RECORD singleresult := ParseSingleElasticsearchResult(aggresult, options.aggregation_mapping ?? mapping);
            IF (RecordExists(singleresult))
            {
              IF (RecordExists(options.aggregation_mapping))
                INSERT singleresult INTO result.aggregation AT END;
              ELSE
                INSERT singleresult INTO result.results AT END;
            }
          }
          ELSE
          {
            // For now, we only have one top-level aggregation per query
            RECORD main_aggregation := UnpackRecord(response.result.aggregations);
            IF (RecordExists(main_aggregation))
            {
              VARIANT aggresult := ReadElasticsearchAggregationResult(query.aggregation, main_aggregation.name, response.result.aggregations);
              IF (IsTypeIDArray(TypeID(aggresult)))
              {
                FOREVERY (RECORD lineresult FROM aggresult)
                {
                  RECORD singleresult := ParseSingleElasticsearchResult(lineresult, options.aggregation_mapping ?? mapping);
                  IF (RecordExists(singleresult))
                  {
                    IF (RecordExists(options.aggregation_mapping))
                      INSERT singleresult INTO result.aggregation AT END;
                    ELSE
                      INSERT singleresult INTO result.results AT END;
                  }
                }
              }
              ELSE
              {
                RECORD singleresult := ParseSingleElasticsearchResult(aggresult, options.aggregation_mapping ?? mapping);
                IF (RecordExists(singleresult))
                {
                  IF (RecordExists(options.aggregation_mapping))
                    INSERT singleresult INTO result.aggregation AT END;
                  ELSE
                    INSERT singleresult INTO result.results AT END;
                }
              }
            }
          }
        }
        IF (NOT CellExists(query, "aggregation") OR RecordExists(options.aggregation_mapping))
        {
          IF (NOT RecordExists(options.aggregation_mapping))
            result.totalcount := result.totalcount + response.result.hits.total.value;

          // An array with length 0 is returned as VARIANT ARRAY
          IF (Length(response.result.hits.hits) > 0)
            result.results := result.results CONCAT ReadElasticsearchResults(response.result.hits.hits, requested_fields, mapping);
        }
      }
    }

    IF (RecordExists(result.session))
      ModuleLog("consilio:queries", EncodeHSON(CELL[ catalogid := indexid, query, options.restrict_to, result := CELL[ ...result, results := Length(result.results) ], uuid := queryuuid ]));

    BroadcastEvent("consilio:executedquery", [ isstart := FALSE
                                             , uuid := queryuuid
                                             , status := response.status
                                             , code := CellExists(response, "code") ? response.code : 0
                                             , numresults := CellExists(response, "results") ? Length(result.results) : 0
                                             , now := GetCurrentDateTime()
                                             ]);

    IF(IsDebugTagEnabled("consilio:searches"))
      LogDebug("consilio:searches", "Search complete",
                                     CELL[ event := "searchdone" //FIXME separate 'done' and 'fail'
                                         , queryuuid
                                         , numresults := result.totalcount
                                         , time_msecs := GetDatetimeDifference(querystart, GetCurrentDateTime()).msecs
                                         ]);
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION QueryIndexManager(INTEGER indexid, RECORD query, RECORD options)
{
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , mapping := DEFAULT RECORD
      , lang := ""
      , suffix := ""
      , managedonly := FALSE
      , indexmanager := 0
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , results := DEFAULT RECORD ARRAY
      ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager", CELL[ indexid, query, options ]);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ managedonly := options.managedonly ]);
  RECORD indexmanager := options.indexmanager = 0
      ? RECORD(indexmanagers)
      : RECORD(SELECT * FROM indexmanagers WHERE id = options.indexmanager);

  IF (RecordExists(indexmanager))
  {
    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an unmanaged index
    IF (indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    STRING ARRAY requested_fields := GetRequestedFields(mapping);

    RECORD searchquery := CreateElasticsearchQuery(query);

    INSERT CELL _source := requested_fields INTO searchquery;

    // Optimization when scoring isn't relevant - https://opensearch.org/docs/latest/opensearch/ux/#sort-results
    INSERT CELL sort := [ "_doc" ] INTO searchquery;

    IF (options.first != defaultoptions.first)
      INSERT CELL "from" := options.first INTO searchquery;
    BOOLEAN scrolling;
    IF (options.count != defaultoptions.count)
    {
      INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;

      // If requesting all results, use the scrolling API
      scrolling := options.count = -1;
    }

    STRING scrollid;
    BOOLEAN search_done;
    INTEGER totalhits;
    WHILE (NOT search_done)
    {
      RECORD response;
      // If we have a scroll id, request the next batch of results
      IF (scrollid != "")
        response := SendToElasticsearch(indexmanager.id, "", "/_search/scroll", [ scroll := "10s", scroll_id := scrollid ], "GET");
      ELSE
      {
        STRING suffix := indexid > 0 AND indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged ? (options.suffix != "" ? "-" || options.suffix : "") : "";
        response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname || suffix : "_all", "/_search" || (scrolling ? "?scroll=10s" : ""), searchquery, "GET");
      }

      result.status := response.status;
      IF (result.status = SearchOk)
      {
        IF (response.result.timed_out)
        {
          result.status := SearchTimeOutError;
          BREAK;
        }
        ELSE
        {
          // If we're not using the scrolling API, we're done, otherwise
          // store the scroll id for retrieval of the next batch of results
          IF (NOT scrolling)
            search_done := TRUE;

          totalhits := response.result.hits.total.value;

          // An array with length 0 is returned as VARIANT ARRAY
          IF (Length(response.result.hits.hits) > 0)
          {
            IF (scrolling)
              scrollid := response.result._scroll_id;

            result.results := result.results CONCAT ReadElasticsearchResults(response.result.hits.hits, requested_fields, mapping);
          }
          ELSE
          {
            // If a batch doesn't contain results, we're done
            search_done := TRUE;
          }
        }
      }
      ELSE
        BREAK;
    }

    result.totalcount := result.totalcount + totalhits;

    // Clear the last scrolling context, if necessary
    IF (scrollid != "")
      SendToElasticsearch(indexmanager.id, "", "/_search/scroll", [ scroll_id := [ scrollid ] ], "DELETE");
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager done", CELL[ result ]);

  RETURN result;
}

/*
*/
PUBLIC RECORD FUNCTION SuggestIndexManager(INTEGER indexid, STRING query, RECORD options)
{
  RECORD defaultoptions :=
      [ count := 10
      , doccount := "search"
      , prefix := ""
      , restrict_to := ""
      , and_search := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result := [ status := SearchIndexNotFound
                   , suggestions := DEFAULT RECORD ARRAY
                   ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager", CELL[ indexid, query, options ]);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (RecordExists(indexmanager))
  {
    OBJECT tokenizer := NEW TokenStream(query);
    RECORD token := tokenizer->GetNextToken();
    STRING userquery, userword, querystring;
    STRING ARRAY otherwords;
    WHILE (RecordExists(token))
    {
      IF (token.type = TokenTypeWord)
      {
        querystring := token.normalizedtext;
        INSERT querystring INTO otherwords AT END;
        userword := token.text;
        userquery := Left(query, token.startoffset);
      }
      token := tokenizer->GetNextToken();
    }
    INTEGER wordlen := Length(userword);
    INTEGER prefixlen;
    IF (indexid = -1 AND options.prefix != "")
    {
      querystring := options.prefix || "_" || querystring;
      prefixlen := Length(options.prefix) + 1;
    }
    IF (querystring != "")
    {
      RECORD suggestquery :=
          [ _source := [ "_suggested" ]
          , suggest :=
              [ suggested :=
                  [ prefix := querystring
                  , completion := [ field := "_suggested" ]
                  ]
              ]
          ];
      // If the and_search option is set, query documents containing the other query words
      IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 1)
      {
        DELETE FROM otherwords AT END-1; // Remove the suggestions query word
        INSERT CELL query :=
            [ bool :=
                [ must := (SELECT match := [ _suggested := word ] FROM ToRecordArray(otherwords, "word"))
                ]
            ] INTO suggestquery;
      }
      IF (indexid != -1 AND options.restrict_to != "")
        INSERT "initialfilter" INTO suggestquery._source AT END;

      RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_search", suggestquery, "POST");
      result.status := response.status;
      IF (response.status = SearchOk AND CellExists(response.result, "suggest")) // suggest may not exist if indexmanager should be restarted
      {
        // The suggest results are by matching document, returning only the first matching suggestion, so we'll have to
        // manually go through all suggested terms (the original input) and see which terms match with the query. This has
        // the added benefit of having a method to count the number of matching documents
        IF (Length(response.result.suggest.suggested.options) > 0)
        {
          // These are the documents containing the other query words
          STRING ARRAY otherdocs := Length(response.result.hits.hits) > 0 ? SELECT AS STRING ARRAY _id FROM response.result.hits.hits : STRING[];
          FOREVERY (RECORD suggest FROM response.result.suggest.suggested.options)
          {
            IF (indexid != -1
                AND options.restrict_to != ""
                AND suggest._source.initialfilter NOT LIKE options.restrict_to || "*")
              CONTINUE;
            IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 0 AND suggest._id NOT IN otherdocs)
              CONTINUE;
            FOREVERY (STRING text FROM suggest._source._suggested.input)
              IF (text LIKE querystring || "*")
              {
                text := userword || Substring(text, prefixlen + wordlen);
                INTEGER cur :=
                    (SELECT AS INTEGER #suggestions + 1
                       FROM result.suggestions
                      WHERE COLUMN text = VAR text) - 1;
                IF (cur < 0)
                {
                  cur := Length(result.suggestions);
                  INSERT [ text := text, count := 0 ] INTO result.suggestions AT cur;
                }
                IF (options.doccount != "" AND cur >= 0)
                  result.suggestions[cur].count := result.suggestions[cur].count + 1;
              }
          }
        }

        INTEGER max := options.count != defaultoptions.count AND options.count >= 0 ? options.count : defaultoptions.count;
        IF (max > 0)
          result.suggestions :=
              SELECT *
                FROM result.suggestions
               ORDER BY COLUMN count DESC
                      , text
               LIMIT max;
      }
      IF (userquery != "")
        UPDATE result.suggestions
           SET text := userquery || text;
    }
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager done", CELL[ result ]);

  RETURN result;
}

PUBLIC INTEGER FUNCTION GetIndexManagerSize(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ indexmanager := 0
      , indexname := ""
      ], options);

  INTEGER size := -1;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  RECORD indexmanager :=
      SELECT *
        FROM indexmanagers
       WHERE (options.indexmanager = 0 ? TRUE : id = options.indexmanager)
         AND (options.indexname = "" ? TRUE : indexname = options.indexname);

  IF (NOT RecordExists(indexmanager))
    RETURN size;

  STRING suffix := indexmanager.indextype = 1 ? "*" : "";
  RECORD response := SendToElasticsearch(indexmanager.id, "", "/_cat/count/" || indexmanager.indexname || suffix, DEFAULT RECORD, "GET");
  IF (response.status = SearchOk)
  {
    // 0     1         2
    // epoch timestamp count
    RECORD ARRAY indexlist :=
        SELECT TEMPORARY parts := Tokenize(indexrow, " ")
             , indexsize := Length(parts) > 2 ? ToInteger(parts[2], -1) : -1
          FROM ToRecordArray(Tokenize(BlobToString(response.content), "\n"), "indexrow");

    size := SELECT AS INTEGER indexsize FROM indexlist;
  }

  RETURN size;
}

STRING FUNCTION AddRefreshToURLPart(STRING urlpart, VARIANT refresh)
{
  IF (IsDefaultValue(refresh))
    refresh := "false";
  ELSE IF (TypeID(refresh) = TypeID(BOOLEAN))
    refresh := "true";
  ELSE IF (TypeID(refresh) != TypeID(STRING) OR refresh NOT IN [ "force", "wait_for" ])
    THROW NEW Exception(`Unexpected refresh option value ${EncodeJSON(refresh)}`);
  ELSE
    refresh := refresh IN [ "false", "wait_for" ] ? refresh : "true";
  IF (refresh != "false")
    RETURN `${urlpart}${SearchSubString(urlpart, "?") = -1 ? "?" : "&"}refresh=${refresh}`;
  RETURN urlpart;
}

STATIC OBJECTTYPE IndexManagerBulkKeeper
<
  RECORD ARRAY _requests;

  /** Add bulk requests for an OpenSearch indexmanager
      @param indexmanagerid Indexmanager id
      @param indexname Name of the index
      @param requests List of requests to add for this index
      @cell options.suffix Suffix
  */
  PUBLIC MACRO AddOpenSearchRequests(INTEGER indexmanagerid, STRING indexname, RECORD ARRAY requests, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ suffix :=       ""
        ], options);

    RECORD rec := CELL
        [ indexmanagerid
        , finalindexname :=       indexname  || (options.suffix != "" ? "-" || options.suffix : "")
        , requests
        ];

    RECORD pos := RecordLowerBound(this->_requests, rec, [ "INDEXMANAGERID", "FINALINDEXNAME" ]);
    IF (pos.found)
      this->_requests[pos.position].requests := this->_requests[pos.position].requests CONCAT requests;
    ELSE
      INSERT rec INTO this->_requests AT pos.position;
  }

  /** Execute the collected bulk operations
      @cell(boolean) options.refresh Set to TRUE to wait until visible for search, Elasticsearch only
      @return Result code
  */
  PUBLIC STRING FUNCTION Execute(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ refresh :=            FALSE
        ], options,
        [ notypecheck := [ "refresh" ]
        ]);

    STRING retval := SearchOk;
    RECORD ARRAY errors;
    FOREVERY (RECORD rec FROM this->_requests)
    {
      RECORD response := SendToElasticsearch(rec.indexmanagerid, rec.finalindexname, AddRefreshToURLPart("/_bulk", options.refresh), [ _bulkrequests := rec.requests ], "POST");
      IF(response.result.errors)
      {
        RECORD ARRAY itemresponses := SELECT *, operation := CellExists(items,"index") ? items."index" : items."delete"
                                          FROM response.result.items;
        errors := errors CONCAT SELECT * FROM itemresponses WHERE CellExists(operation, "error");
      }
    }

    IF(Length(errors) > 0)
    {
      //FIXME we get an _id back, but we don't calculate them here so how to figure out which object it actually referred to for a proper error?
      //FIXME what if more than one object failed? we should throw more informing errors
      THROW NEW ElasticSearchException(`Failed on document '${errors[0].operation._id}': ${errors[0].operation.error.reason} (${errors[0].operation.error.type})`, DEFAULT OBJECT);
    }
    RETURN retval;
  }
>;

PUBLIC OBJECT FUNCTION GetIndexManagerBulkKeeper()
{
  RETURN NEW IndexManagerBulkKeeper;
}



// @cell objects.objectid
// @cell objects.documentfields
// @cell objects.suggestfields (only used by legacy consilio, opensearch uses the mapping's suggested property)
// @cell objects.suggestprefixes (only used by legacy consilio)
// @cell(object #IndexManagerBulkKeeper) options.bulk Bulk update keeper, use collect updates to perform in a bulk operation
PUBLIC STRING FUNCTION AddIndexManagerObjects(OBJECT catalog,
                                              RECORD contentsource,
                                              STRING groupid,
                                              RECORD ARRAY objects,
                                              RECORD options)
{
  RECORD defaultoptions :=
      [ discardsummaries := FALSE // Set to TRUE to not store the document body for summary generation, Consilio only
      , refresh := FALSE // Set to TRUE to wait until visible for search, Elasticsearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , bulk := DEFAULT OBJECT
      ];
  options := ValidateOptions(defaultoptions, options);


  objects := SELECT *
                , indextypes :=             CellExists(objects, "INDEXTYPES") ? objects.indextypes : STRING[]
                , indexversions :=          CellExists(objects, "INDEXVERSIONS") ? objects.indexversions : STRING[]
             FROM objects;

  INTEGER indexid := catalog->id;

  OBJECT temporarybulk;
  IF(NOT ObjectExists(options.bulk))  //we should always use a bulk submitter to centralize error handling code
    temporarybulk := GetIndexManagerBulkKeeper();

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  IF (IsDefaultValue(indexmanagers))
    THROW NEW Exception(`No indexmanagers found for index #${indexid}`);

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    RECORD response;
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
    {
      FOREVERY (RECORD objgroup FROM SELECT objs := GroupedValues(objects) FROM objects)
      {
        RECORD ARRAY bulkrequests;
        FOREVERY (RECORD obj FROM objgroup.objs)
        {
          // action_and_meta_data
          INSERT [ "index" := [ _id := GetElasticsearchDocumentId(indexid, obj.objectid, options.suffix) ]] INTO bulkrequests AT END;
          // optional_source
          INSERT FixupElasticsearchDocumentFields(obj.documentfields) INTO bulkrequests AT END;
        }

        (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
      }
    }
    ELSE
    {
      STRING ARRAY suggestfields := catalog->__GetSuggestedFields();

      RECORD ARRAY bulkrequests;
      FOREVERY (RECORD obj FROM objects)
      {
        RECORD document := obj.documentfields;
        INSERT CELL groupid := groupid
                  , objectid := obj.objectid
                  , contentsource := contentsource.id
                  , indextypes := obj.indextypes
                  , indexversions := obj.indexversions
          INTO document;

        IF (Length(suggestfields) > 0)
        {
          STRING ARRAY suggested;
          OBJECT tokenizer := NEW TokenStream("");
          FOREVERY (STRING field FROM suggestfields)
          {
            IF (field LIKE "_*")
              field := Substring(field, 1);
            IF (field IN obj.suggestfields AND CellExists(document, field))
            {
              IF(TYPEID(GetCell(document, field)) != TYPEID(STRING))
                THROW NEW Exception(`Suggest expected '${field}' to be of type STRING, got ${GetTypeName(TYPEID(GetCell(document, field)))})`);

              tokenizer->AddText(" " || GetCell(document, field));
            }
          }
          RECORD token := tokenizer->GetNextToken();
          WHILE (RecordExists(token))
          {
            IF (token.type = TokenTypeWord AND token.normalizedtext NOT IN suggested)
              INSERT token.normalizedtext INTO suggested AT END;
            token := tokenizer->GetNextToken();
          }
          IF (Length(suggested) > 0)
            INSERT CELL _suggested := [ input := suggested ] INTO document;
        }

        // action_and_meta_data
        INSERT [ "index" := [ _id := GetElasticsearchDocumentId(indexid, obj.objectid) ] ] INTO bulkrequests AT END;
        // optional_source
        INSERT FixupElasticsearchDocumentFields(document) INTO bulkrequests AT END;
      }

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
    }
  }

  IF(ObjectExists(temporarybulk))
    RETURN temporarybulk->Execute(CELL[ options.refresh ]) ?? SearchOk;

  RETURN SearchOk;
}

/** @short Delete a group from an index
    @param indexid The index to delete the group from (0 for all indices)
    @param contentsourceid The content source to delete the group from (0 for
        all content sources)
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
    @param groupid The group to delete
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerGroup(INTEGER indexid, INTEGER contentsourceid, STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      ], options);

  IF (groupid = "")
    RETURN SearchInvalidArgument;

  STRING result;
  IF (groupid != "")
  {
    RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
    FOREVERY (RECORD indexmanager FROM indexmanagers)
    {
      // No support for groupids in unmanaged indices
      IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
      {
        IF (indexid != 0)
          result := SearchCommandUnsupported;
        CONTINUE;
      }

      RECORD query :=
          [ query :=
              [ bool :=
                  [ must :=
                        [ [ match := [ groupid := groupid ] ]
                        ]
                  ]
              ]
          ];
      IF (contentsourceid != 0)
        INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

      RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", `/_delete_by_query${ options.refresh ? "?refresh" : ""}`, query, "POST");
      result := response.status;
    }
    result := result ?? SearchOk;
  }
  ELSE
    result := SearchInvalidArgument;

  RETURN result;
}

/** @short Delete an object from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param options @includecelldef #DeleteIndexManagerObjects.options
    @param objectid The object to delete
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObject(INTEGER indexid, INTEGER contentsourceid, STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN DeleteIndexManagerObjects(indexid, contentsourceid, [objectid], options);
}

/** @short Delete multiple objects from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param objectids The objects to delete
    @cell(boolean) options.refresh Set to TRUE to wait until visible for search, Elasticsearch only
    @cell(string) options.suffix Sub-index suffix, for unmanaged indices, Elasticsearch only
    @cell(object #IndexManagerBulkKeeper) options.bulk Bulk update keeper, use collect updates to perform in a bulk operation
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObjects(INTEGER indexid, INTEGER contentsourceid, STRING ARRAY objectids, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD defaultoptions :=
      [ refresh := FALSE // Set to TRUE to wait until visible for search, Elasticsearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      , bulk := DEFAULT OBJECT
      ];
  options := ValidateOptions(defaultoptions, options);

  STRING result;

  OBJECT temporarybulk;
  IF(NOT ObjectExists(options.bulk))  //we should always use a bulk submitter to centralize error handling code
    temporarybulk := GetIndexManagerBulkKeeper();

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    // For unmanaged indices, delete by document id
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
    {
      IF (indexid = 0 OR contentsourceid != 0)
        THROW NEW Exception(`DeleteIndexManagerObjects with indexid = 0 OR contentsourceid != 0 not supported for unmanaged indices`);

      RECORD ARRAY bulkrequests :=
          SELECT "delete" := [ _id := GetElasticsearchDocumentId(indexid, objectid, options.suffix) ]
            FROM ToRecordArray(objectids, "objectid");

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
      CONTINUE;
    }

    IF (indexid != 0)
    {
      RECORD ARRAY bulkrequests :=
          SELECT "delete" := [ _id := GetElasticsearchDocumentId(indexid, objectid, "") ]
            FROM ToRecordArray(objectids, "objectid");

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests);
    }
    ELSE
    {
      RECORD query :=
          [ query :=
              [ bool :=
                  [ must := RECORD[]
                  , should := (SELECT match := [ objectid := objectid ] FROM ToRecordArray(objectids, "objectid"))
                  , minimum_should_match := 1
                  ]
              ]
          ];
      IF (contentsourceid != 0)
        INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

      RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", AddRefreshToURLPart(`/_delete_by_query`, options.refresh), query, "POST");
      IF (response.status != SearchOk)
        result := response.status;
    }
  }

  IF(ObjectExists(temporarybulk))
    RETURN result ?? temporarybulk->Execute(CELL[ options.refresh ]) ?? SearchOk;

  RETURN result ?? SearchOk;
}

/** @short Delete outdated objects
    @param indexid The index to delete outdated objects from
    @param contentsourceid The content source to delete outdated objects from (0
        for all content sources)
    @param groupid Delete outdated objects for this group only ("" for all groups)
    @param objectid Delete outdated objects for this object only ("" for all objects)
    @param deletebefore Delete all objects that have been indexed before this date
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
    @return The deletion result
    @cell(integer) return.deleted The number of deleted objects
    @cell(string array) return.active The id's of the objects that were matched,
        but not deleted, because they were indexed on or after the given date
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerOutdated(INTEGER indexid,
                                                  INTEGER contentsourceid,
                                                  STRING groupid,
                                                  STRING objectid,
                                                  DATETIME deletebefore,
                                                  RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      ], options);

  RECORD result := [ status := SearchInvalidArgument
                   , deleted := 0
                   , active := DEFAULT STRING ARRAY
                   ];
  IF (indexid != 0 AND deletebefore != DEFAULT DATETIME)
  {
    RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
    result.status := IsValueSet(indexmanagers) ? SearchOk : SearchIndexNotFound;
    FOREVERY (RECORD indexmanager FROM indexmanagers)
    {
      // No support for outdated documents in unmanaged indices
      IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
        result.status := SearchCommandUnsupported;

      // delete all documents having 'date_indexed' before 'deletebefore'
      RECORD query :=
          [ query :=
              [ bool :=
                  [ must := DEFAULT RECORD ARRAY
                  , filter :=
                      [ [ range := [ date_indexed := [ lt := FormatISO8601DateTime(deletebefore, "day", "milliseconds") ] ] ]
                      ]
                  ]
              ]
          ];
      IF (contentsourceid != 0)
        INSERT [ match := [ contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;
      IF (groupid != "")
        INSERT [ match := [ groupid := groupid ] ] INTO query.query.bool.must AT END;
      IF (objectid != "")
        INSERT [ match := [ objectid := objectid ] ] INTO query.query.bool.must AT END;

      /* Refresh the index beforoe we start deletion. Works around "version conflict, required seqNo [...]" we noticed
         when running wh consilio:manualindex publisher:whfs - suspecting the delete is trying to delete older versions

         maybe we can set conflicts=proceed but I'm not sure if that will then fail to delete or delete the most recent version*/
      SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_refresh", DEFAULT RECORD, "GET");

      RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, `/_delete_by_query${ options.refresh ? "?refresh" : ""}`, query, "POST");
      result.status := result.status ?? response.status;
      IF (result.status = SearchOk)
      {
        result.deleted := response.result.deleted;

        // Find documents that aren't deleted
        DELETE CELL filter FROM query.query.bool;
        INSERT CELL _source := [ "objectid" ] INTO query;
        response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_search", query, "POST");
        IF (response.status = SearchOk AND Length(response.result.hits.hits) > 0)
        {
          result.active :=
              SELECT AS STRING ARRAY _source.objectid
                FROM response.result.hits.hits;
        }
      }
    }
  }

  RETURN result;
}

/** Refreshes all attached indices of a catalog, so all pendinging updates
    and deletes are visible afterwards
    @param catalogid Id of the catalog to red
    @return Execution result status
*/
PUBLIC STRING FUNCTION RefreshAttachedIndices(INTEGER catalogid)
{
  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(catalogid, [ excludereadonly := TRUE ]);
  STRING result := SearchOk;

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "/_refresh", DEFAULT RECORD, "GET");
    IF (response.status != SearchOk)
      result := response.status;
  }
  RETURN result;
}

/** Deletes all documents in an index from a specific contentsource
    @param indexmgrid Id of the indexmanager to use
    @param indexid Id of the index
    @param contentsourceid Id of the contentsource whose documents must be removed (set to 0 to delete the entire index)
    @cell options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @return Execution result
    @cell return.status Status
    @cell return.deleted Number of deleted documents
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerContentSource(INTEGER indexmgrid, INTEGER indexid, INTEGER contentsourceid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD result := [ status := SearchUnavailable
                   , deleted := 0
                   ];
  RECORD ARRAY indexmanagers := indexid != 0 ? GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ])
                                             : GetIndexManagers(indexmgrid, [ excludereadonly := TRUE ]);

  /* TODO this approach really just returns the *last* deletion status, and may (re)delete multiple indices if already marked
     as deletion. This looping should probably happen in the catalog api */
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    IF ((indexmgrid != 0 AND indexmanager.id != indexmgrid) OR indexid = 0)
      CONTINUE;

    RECORD indexinfo := SELECT * FROM consilio.catalogs WHERE id = indexid;
    IF (RecordExists(indexinfo) AND indexinfo.type = whconstant_consilio_catalogtype_unmanaged)
    {
      // Delete the specific subindex if suffix is set, otherwise delete all subindices
      RECORD response := SendRawJSONToElasticsearch(indexmanager.id, "DELETE", indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : "*"), DEFAULT RECORD, [ expectstatus := [200,404] ]);
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
    ELSE IF (contentsourceid = 0)
    {
      // No content source specified, delete entire index
      RECORD response := SendToElasticsearch(indexmanager.id, indexmanager.indexname, "", DEFAULT RECORD, "DELETE");
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
    ELSE
    {
      RECORD query :=
          [ query :=
              [ bool :=
                  [ must :=
                        [ [ match := [ contentsource := contentsourceid ] ]
                        ]
                  ]
              ]
          ];
      // Delete all objects within the content source
      RECORD response := SendToElasticsearch(indexmanager.id, indexid != 0 ? indexmanager.indexname : "_all", "/_delete_by_query", query, "POST");
      result.status := response.status;
      IF (result.status = SearchOk)
        result.deleted := response.result.deleted;
    }
  }

 IF (result.status = SearchOk)
    BroadcastEvent("consilio:contentsourcestatus", [ id := contentsourceid ]);

  RETURN result;
}

/** Deletes all documents in an index from a specific contentsource
    @param indexmgrid Id of the indexmanager to use
    @param indexid Id of the index
    @param indexname Name of the index at the indexmanager
    @cell options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @return Execution result
    @cell return.status Status
    @cell return.deleted Number of deleted documents
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerIndex(INTEGER indexmgrid, INTEGER indexid, STRING indexname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD result := [ status := SearchUnavailable
                   , deleted := 0
                   ];

  RECORD indexmanager := GetIndexManagers(indexmgrid);

  IF (RecordExists(indexmanager))
  {
    RECORD indexinfo := SELECT * FROM consilio.catalogs WHERE id = indexid;
    IF (RecordExists(indexinfo) AND indexinfo.type = whconstant_consilio_catalogtype_unmanaged)
    {
      // Delete the specific subindex if suffix is set, otherwise delete all subindices
      RECORD response := SendToElasticsearch(indexmanager.id, indexname || (options.suffix != "" ? "-" || options.suffix : "*"), "", DEFAULT RECORD, "DELETE");
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
    ELSE
    {
      // No content source specified, delete entire index
      RECORD response := SendToElasticsearch(indexmanager.id, indexname, "", DEFAULT RECORD, "DELETE");
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
  }

  RETURN result;
}

// -----------------------------------------------------------------------------
//
// Helper functions
//

/** @short Find an indexmanager
    @param indexmgrid The id of the indexmanager, or -1 for all indexmanagers
    @cell options.managedonly Only consider managed catalogs
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
RECORD ARRAY FUNCTION GetIndexManagers(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
        [ managedonly := FALSE
        , excludereadonly := FALSE
        ], options);

  RETURN
      SELECT indexmanagers.id
           , catalog_indexmanagers.indexname
           , indextype := catalogs.type
           , indexid := catalogs.id
           , primary := catalog_indexmanagers.searchpriority > 0 //we should obsolete this but probably the entire GetIndexManagers API
        FROM consilio.indexmanagers
           , consilio.catalog_indexmanagers
           , consilio.catalogs
       WHERE indexmanagers.id = catalog_indexmanagers.indexmanager
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (indexmgrid = -1 OR indexmanagers.id = indexmgrid)
             AND (options.excludereadonly ? catalog_indexmanagers.readonly = FALSE : TRUE)
    ORDER BY catalog_indexmanagers.searchpriority DESC;
}

/** @short Find the indexmanager for an index
    @param indexid The id of the index, or 0 for the indexmanagers of all indices
    @cell options.managedonly Only consider managed catalogs
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
PUBLIC RECORD ARRAY FUNCTION GetIndexManagersForIndex(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ managedonly := FALSE
      , excludereadonly := FALSE
      ], options);

  IF (indexid = 0)
    RETURN GetIndexManagers(-1, options);

  RETURN
      SELECT indexmanagers.id
           , catalog_indexmanagers.indexname
           , catalogs.lang
           , indextype := catalogs.type
           , primary := catalog_indexmanagers.searchpriority > 0 //we should obsolete this but probably the entire GetIndexManagers API
        FROM consilio.catalogs
           , consilio.catalog_indexmanagers
           , consilio.indexmanagers
       WHERE catalogs.id = indexid
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND catalog_indexmanagers.indexmanager = indexmanagers.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (options.excludereadonly ? catalog_indexmanagers.readonly = FALSE : TRUE)
    ORDER BY catalog_indexmanagers.searchpriority DESC;
}

// Create a (flattened) list of requested fields
PUBLIC STRING ARRAY FUNCTION GetRequestedFields(RECORD mapping)
{
  STRING ARRAY fields;
  FOREVERY (RECORD field FROM UnpackRecord(mapping))
  {
    IF (CanCastTypeTo(TypeID(field.value), TypeID(RECORD)) AND RecordExists(field.value))
      FOREVERY (STRING subfield FROM GetRequestedFields(field.value))
        INSERT ToLowercase(field.name) || "." || subfield INTO fields AT END;
    ELSE
      INSERT ToLowercase(field.name) INTO fields AT END;
  }
  RETURN fields;
}
