<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib" EXPORT running_in_fetcher, print_defer_connection;
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT SearchOk, SearchError, SearchIndexNotFound, SearchCommandUnsupported, SearchNoAccess, SearchConnectError, SearchSendError, SearchHTTPError, SearchNoTotalError, SearchUnavailable, SearchTimeOutError, SearchInvalidArgument, SearchSleep, SearchRebuildCatalog;
LOADLIB "mod::consilio/lib/internal/opensearch/analysis.whlib";

LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


// -----------------------------------------------------------------------------
//
// Public API
//

/** @short Get a list of indices from an indexmanager
    @param indexmgrid The id of the indexmanager
    @param options Options
    @return The result
    @cell(string) return.status The result status
    @cell(integer array) return.indices The list of index id's known by this
        indexmanager, or DEFAULT INTEGER ARRAY when there are no indices or when
        no indexmanager with the given id exists
*/
PUBLIC RECORD ARRAY FUNCTION GetIndexManagerIndexList(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[], options);

  RECORD ARRAY indexlist := ListOpenSearchIndices(indexmgrid);
  RECORD ARRAY indexmanagers := GetIndexManagers(indexmgrid);

  // Unmanaged indices may have a suffix: <indexname>-<suffix>
  indexlist := SELECT TEMPORARY toks := Tokenize(indexname,'-')
                    , indexname := toks[0]
                    , suffix := Length(toks) > 1 ? toks[1] : ""
                    , health
                    , status
                    , docs
                    , size
                    , indexid := (SELECT AS INTEGER indexid FROM indexmanagers WHERE indexname = toks[0])
                 FROM indexlist;

  indexlist :=
      SELECT health := PickFirst(SELECT AS STRING ARRAY health FROM GroupedValues(indexlist) ORDER BY SearchElement([ "red", "yellow", "green" ], health))
           , status := PickFirst(SELECT AS STRING ARRAY status FROM GroupedValues(indexlist) ORDER BY SearchElement([ "close", "open" ], status))
           , docs := Sum(docs)
           , size := Sum(size)
           , indexname
           , indexid := ANY(indexid)
           , suffixes := GroupedValues(suffix)
        FROM indexlist
    GROUP BY indexname;

  RETURN SELECT indexid, indexname, suffixes FROM indexlist ORDER BY indexid, indexname;
}

PUBLIC RECORD FUNCTION GetIndexStats(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ metrics := STRING[ "_all" ]
      ], options,
      [ enums :=
          [ metrics := // https://www.elastic.co/guide/en/elasticsearch/reference/7.17/indices-stats.html#index-stats-api-path-params
              [ "_all", "completion", "docs", "fielddata", "flush", "get", "indexing", "merge", "query_cache", "refresh"
              , "request_cache", "search", "segments", "store", "suggest", "translog", "warmer"
              ]
          ]
      ]);
  RECORD result :=
      [ status := SearchIndexNotFound
      , stats := DEFAULT RECORD
      ];

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager))
   THROW NEW Exception(`No indexmanager configured for index #${indexid}`);

  RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "GET", indexmanager.indexname || "/_stats/" || Detokenize(options.metrics, ","), DEFAULT RECORD);
  result.status := response.status;
  IF (response.status = SearchOk)
    result.stats := GetCell(response.result.indices, indexmanager.indexname).total;

  RETURN result;
}

BOOLEAN FUNCTION IsOutofdateAnalysis(RECORD currentanalysis, RECORD newanalysis)
{
  CONSTANT RECORD structure := [ filter := [ synonym := [ synonyms := STRING[] ]]];
  currentanalysis := EnforceStructure(structure, currentanalysis);
  newanalysis := EnforceStructure(structure, newanalysis);

  //There's no way to delete existing filters, so really all we can do is check if any filter is missing or misconfigured
  FOREVERY(RECORD filter FROM UnpackRecord(newanalysis.filter))
  {
    IF(NOT CellExists(currentanalysis.filter, filter.name))
      RETURN TRUE; //filter is missing, go through close+reopen

    IF(EncodeHSON(GetCell(currentanalysis.filter, filter.name)) != EncodeHSON(filter.value))
      RETURN TRUE; //filter is misconfigured, go through close+reopen
  }

  //We're done with filters, assume the rest is ok (until more open/close issues or missed comparions are found)
  RETURN FALSE;
}

PUBLIC BOOLEAN __did_opensearch_close_and_reopen; //tests currently need this to verify that we didn't unnecessarily close an index.

PUBLIC MACRO EnsureOpenSearchIndexConfiguration(INTEGER indexmanager, STRING indexname, STRING suffix, STRING ARRAY synonyms, STRING lang, RECORD mapping)
{
  RECORD setanalysis := GetAnalysisForLanguage(lang);
  // Add the synonyms filter
  INSERT CELL synonym := CELL
      [ type := "synonym_graph"
      , synonyms
      ] INTO setanalysis.filter;

  STRING fullname := indexname || (suffix != "" ? "-" || suffix : "");
  TRY
  {
    SendRawJSONToOpenSearch(indexmanager, "PUT", fullname,
         CELL[ settings := [ number_of_replicas := 0 // we don't configure replication on our own indicessettings
                           , analysis := setanalysis
                           ]
             , mappings := mapping
             ]);
  }
  CATCH(OBJECT<OpenSearchException> e)
  {
    IF(RecordExists(e->error) AND e->error.type IN [ "index_already_exists_exception", "resource_already_exists_exception" ])
    {
      //Then just update the configuration

      // Analysis settings cannot be updated on opened indices, so the index has to be closed first and reopened after update
      RECORD currentsettings := SendRawJSONToOpenSearch(indexmanager, "GET", fullname || "/_settings", DEFAULT RECORD).result;
      currentsettings := GetCell(currentsettings, fullname).settings;

      RECORD applysettings;
      IF(NOT CellExists(currentsettings."index",'analysis') OR IsOutofdateAnalysis(currentsettings."index".analysis, setanalysis))
        INSERT CELL analysis := setanalysis INTO applysettings;

      IF(RecordExists(applysettings))
      {
        BOOLEAN close_index := CellExists(applysettings, "analysis");
        IF (close_index)
        {
          __did_opensearch_close_and_reopen := TRUE;
          SendRawJSONToOpenSearch(indexmanager, "POST", fullname || "/_close", DEFAULT RECORD);
        }

        // Update the settings
        TRY
        {
          SendRawJSONToOpenSearch(indexmanager, "PUT", fullname || "/_settings", applysettings);
        }
        FINALLY
        {
          // Open the index again if needed. Even if /_settings throws
          IF (close_index)
          {
            TRY
            {
              SendRawJSONToOpenSearch(indexmanager, "POST", fullname || "/_open", DEFAULT RECORD);
            }
            CATCH(OBJECT f)
            {
              LogHarescriptException(f);
              //And ignore it. not much we can do about a throw here
            }
          }
        }
      }

      SendRawJSONToOpenSearch(indexmanager, "PUT", fullname || "/_mapping", mapping);
    }
    ELSE
    {
      THROW;
    }
  }
}

PUBLIC RECORD FUNCTION GetIndexManagerMapping(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, OpenSearch only
      ], options);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (NOT RecordExists(indexmanager))
    THROW NEW Exception(`No such catalog #${indexid}`);
  IF (options.suffix != "" AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
    THROW NEW Exception(`Managed Consilio catalog #${indexid} does not support suffixes`);

  STRING finalindexname := indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : "");
  RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "GET", finalindexname || "/_mapping", DEFAULT RECORD);

  RECORD mappings := GetCell(response.result, finalindexname).mappings;
  mappings := EnforceStructure([ dynamic_templates := RECORD[]], mappings);
  RETURN mappings;
}

/** @short Search an index
    @param indexid The id of the index to query; 0 for all indices
    @param query The query to execute
    @param useroptions Search options
    @cell(integer) useroptions.first The first result to return (0-based, defaults to 0)
    @cell(integer) useroptions.count The number of results to return; 0 for no results (but still returning the number of result),
        -1 for all results (defaults to 0)
    @cell(integer) useroptions.summary The length of the summary to generate; 0 for no summary (defaults to 200)
    @cell(boolean) useroptions.highlightfields Highlight matched search terms in these fields
    @cell(string) useroptions.lang The language used for searching (used for various language-specific features)
    @cell(string) useroptions.restrict_to Restrict results to URLs starting with restrict_to
    @cell(record) useroptions.mapping The search result field mapping to use
    @param indexoptions Index options @includecelldef __GetIndexManagerOptions.return
    @return Search results
    @cell(string) return.status Return status (eg SearchOk)
    @cell(integer) return.totalcount Number of returned results
    @cell(record array) return.results Results
    @cell(record) return.session Search session
*/
PUBLIC RECORD FUNCTION SearchIndexManager(INTEGER indexid, RECORD query, RECORD useroptions, RECORD indexoptions)
{
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , summary := 200
      , highlightfields := STRING[]
      , highlightparts := [ "body" ]
      , highlighttype := "unified"
      , lang := ""
      , restrict_to := ""
      , exclude_urls := STRING[]
      , mapping := indexoptions.defaultmapping
      , aggregation_mapping := DEFAULT RECORD
      , session := DEFAULT RECORD
      , debug := FALSE
      , explain := FALSE
      , totaltotrack := default_track_total_hits
      , timeout := opensearch_read_timeout
      ];

  RECORD options := ValidateOptions(defaultoptions, useroptions,
      [ enums :=
          [ highlighttype := [ "unified", "plain" ]
          ]
      ]);
  IF(options.explain)
    options.mapping := CELL[...options.mapping, _explanation := DEFAULT RECORD ];

  IF (options.summary != 0 AND NOT CellExists(options.mapping, "_SUMMARY"))
    INSERT CELL _summary := "summary" INTO options.mapping;
  ELSE IF (CellExists(options.mapping, "_summary") AND options.mapping._summary = "") // Summary generation explicitly switched off
  {
    IF (Length(options.highlightparts) = 0)
      options.summary := 0;
    DELETE CELL _summary FROM options.mapping;
  }

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , totalexact := TRUE
      , results := DEFAULT RECORD ARRAY
      , session := options.session
      ];

  STRING catalog := SELECT AS STRING name FROM consilio.catalogs WHERE id = indexid;
  IF (catalog = "")
    RETURN result;

  DATETIME querystart := GetCurrentDateTime();

  RECORD indexmanager := indexoptions.indexmanagers;
  IF (NOT RecordExists(indexmanager))
    THROW NEW OpenSearchException(`No indices attached to catalog '${catalog}'`, DEFAULT OBJECT, "");

  IF (RecordExists(indexmanager))
  {
    STRING queryuuid := GenerateUFS128BitId();

    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an aggregation query or unmanaged index
    IF (NOT CellExists(query, "aggregation") AND indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    RECORD searchquery := CreateOpenSearchQuery(query, mapping, indexoptions);

    //FIXME Get rid of the broadcasts, just use the logging system ?
    RECORD searchstart := CELL[ event := "searchstart"
                              , queryuuid
                              , options.restrict_to
                              , options.exclude_urls
                              , options.first
                              , options.count
                              , summary_length := options.summary
                              , options.lang
                              , sess := RecordExists(options.session) ? options.session.sessid : ""
                              , options.highlightfields
                              , fields := searchquery._source
                              , uuid := queryuuid
                              , now := querystart
                              , catalog
                              ];

    IF (options.explain)
      INSERT CELL explain := TRUE INTO searchquery;
    IF (options.totaltotrack != defaultoptions.totaltotrack)
    {
      IF (options.totaltotrack > 0)
        INSERT CELL track_total_hits := options.totaltotrack INTO searchquery;
      ELSE
        INSERT CELL track_total_hits := options.totaltotrack < 0 INTO searchquery; // -1: always track accurately, 0: don't track at all
    }
    IF (options.first != defaultoptions.first)
      INSERT CELL "from" := options.first INTO searchquery;
    IF (CellExists(searchquery, "aggs") AND NOT RecordExists(options.aggregation_mapping))
      INSERT CELL size := 0 INTO searchquery; // Only interested in aggregation result
    ELSE
      INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;
    IF (options.summary != 0 OR Length(options.highlightfields) > 0)
    {
      RECORD highlightoptions := CELL
          [ highlightfields := ArrayUnion(options.highlightfields, options.highlightparts) // make sure all part fields are highlighted
          , options.highlightparts
          , options.highlighttype
          , options.summary
          , defaultsummary := defaultoptions.summary
          , addparthighlighting := options.summary != 0 AND Length(options.highlightfields) = 0
          , path := ""
          ];
      // Add highlighting recursively to the query (nested queries may have their own highlighting)
      RECORD highlight := AddQueryHighlighting(searchquery, highlightoptions);
      // Add the highlighting for the root query (AddQueryHighlighting returns the fields that are already highlighted on a lower level)
      searchquery := AddFieldHighlighting(highlight.query, CELL[ ...highlightoptions, highlight.highlightfields ]).query;
    }
    IF (options.restrict_to != defaultoptions.restrict_to)
    {
      RECORD restrict_filter := [ prefix := [ objecturl := options.restrict_to ] ];
      searchquery.query := AddOpenSearchQueryFilters(searchquery.query, [ restrict_filter ], FALSE);
    }
    IF (Length(options.exclude_urls) > 0)
    {
      RECORD ARRAY exclude_filters;
      FOREVERY (STRING url FROM options.exclude_urls)
        INSERT [ prefix := [ objecturl := url ] ] INTO exclude_filters AT END;
      searchquery.query := AddOpenSearchQueryFilters(searchquery.query, exclude_filters, TRUE);
    }

    // A composite aggregation should be paginated when all terms are requested, as we don't know the number of terms beforehand
    STRING paginated_composite_agg;
    IF (CellExists(searchquery, "aggs") AND RecordExists(searchquery.aggs))
    {
      // The aggregation is a record containing one cell with the actual aggregation, named after the aggregated field
      RECORD agg := UnpackRecord(searchquery.aggs)[0];
      paginated_composite_agg := CellExists(agg.value, "composite") AND agg.value.composite.size < 0 ? agg.name : "";
      // Set the page size to 100
      IF (paginated_composite_agg != "")
      {
        agg.value.composite.size := 100;
        searchquery.aggs := CellUpdate(searchquery.aggs, paginated_composite_agg, agg.value);
      }
    }

    BOOLEAN search_done;
    RECORD after_key;
    WHILE (NOT search_done)
    {
      IF (paginated_composite_agg != "" AND RecordExists(after_key))
      {
        RECORD agg := GetCell(searchquery.aggs, paginated_composite_agg);
        agg.composite := CELL[ ...agg.composite, after := after_key ];
        searchquery.aggs := CellUpdate(searchquery.aggs, paginated_composite_agg, agg);
      }

      RECORD finalquery := [ method := "GET"
                           , path := "/" || indexmanager.indexname || indexmanager.suffix || "/_search"
                           , body := searchquery
                           ];

      IF(IsDebugTagEnabled("consilio:searches"))
        LogDebug("consilio:searches", "OpenSearch search", CELL[ ...searchstart, searchquery := finalquery ]);


      IF(options.debug)
        Print(`OpenSearch query:\nGET ${finalquery.path}\n${EncodeJSON(searchquery)}\n`);

      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, finalquery.method, finalquery.path, finalquery.body, CELL[ enforce := "_search_get", options.explain, options.timeout, expectstatus := [200,404] ]);
      IF(response.code = 404) //index isn't there yet
        THROW NEW SearchUnavailableException(`Search unavailable, status code 404`);
      IF(options.debug)
        DumpValue(response, "tree");

      result.status := response.status;
      IF (result.status = SearchOk)
      {
        IF (response.result.timed_out)
        {
          result.status := SearchTimeOutError;
          search_done := TRUE;
        }
        ELSE
        {
          IF (CellExists(query, "aggregation"))
          {
            result.totalcount := response.result.hits.total.value;
            result.totalexact := response.result.hits.total.relation = "eq";
            IF (RecordExists(options.aggregation_mapping))
              INSERT CELL aggregation := RECORD[] INTO result;

            // If the main aggregation is a 'count' aggregation, there are no aggregation results
            IF (query.aggregation._type = "count")
            {
              RECORD aggresult := CellInsert(DEFAULT RECORD, query.aggregation.name, response.result.hits.total.value);
              RECORD singleresult := ParseSingleOpenSearchResult(aggresult, options.aggregation_mapping ?? mapping);
              IF (RecordExists(singleresult))
              {
                IF (RecordExists(options.aggregation_mapping))
                  INSERT singleresult INTO result.aggregation AT END;
                ELSE
                  INSERT singleresult INTO result.results AT END;
              }
            }
            ELSE
            {
              // For now, we only have one top-level aggregation per query
              RECORD main_aggregation := UnpackRecord(response.result.aggregations);
              INTEGER numresults;
              IF (RecordExists(main_aggregation))
              {
                VARIANT aggresult := ReadOpenSearchAggregationResult(query.aggregation, main_aggregation.name, response.result.aggregations);
                IF (IsTypeIDArray(TypeID(aggresult)))
                {
                  numresults := Length(aggresult);
                  FOREVERY (RECORD lineresult FROM aggresult)
                  {
                    RECORD singleresult := ParseSingleOpenSearchResult(lineresult, options.aggregation_mapping ?? mapping);
                    IF (RecordExists(singleresult))
                    {
                      IF (RecordExists(options.aggregation_mapping))
                        INSERT singleresult INTO result.aggregation AT END;
                      ELSE
                        INSERT singleresult INTO result.results AT END;
                    }
                  }
                }
                ELSE
                {
                  RECORD singleresult := ParseSingleOpenSearchResult(aggresult, options.aggregation_mapping ?? mapping);
                  IF (RecordExists(singleresult))
                  {
                    numresults := 1;
                    IF (RecordExists(options.aggregation_mapping))
                      INSERT singleresult INTO result.aggregation AT END;
                    ELSE
                      INSERT singleresult INTO result.results AT END;
                  }
                }
              }
              // If this is a paginated composite aggregation, retrieve the new after key (if there are no results, there is
              // no after_key)
              IF (paginated_composite_agg != "")
              {
                // If we received less results than requested, we're already done
                IF (numresults < 1000)
                  after_key := DEFAULT RECORD;
                ELSE
                  after_key := CellExists(main_aggregation.value, "after_key") ? main_aggregation.value.after_key : DEFAULT RECORD;
              }
            }

            // If we're not paginating or if there is no after key (i.e. there are no more results to retrieve), we're done
            IF (paginated_composite_agg = "" OR NOT RecordExists(after_key))
              search_done := TRUE;
          }
          IF (NOT CellExists(query, "aggregation") OR RecordExists(options.aggregation_mapping))
          {
            IF (NOT RecordExists(options.aggregation_mapping))
            {
              result.totalcount := response.result.hits.total.value;
              result.totalexact := response.result.hits.total.relation = "eq";
              search_done := TRUE;
            }

            // An array with length 0 is returned as VARIANT ARRAY
            IF (Length(response.result.hits.hits) > 0)
              result.results := result.results CONCAT ReadOpenSearchResults(response.result.hits.hits, searchquery, mapping, options);
          }
        }
      }

      IF (RecordExists(result.session))
        LogToJSONLog("consilio:queries", CELL[ catalogid := indexid, query, options.restrict_to, result := CELL[ ...result, results := Length(result.results) ], uuid := queryuuid ]);
    }

    IF(IsDebugTagEnabled("consilio:searches"))
      LogDebug("consilio:searches", "Search complete",
                                     CELL[ event := "searchdone" //FIXME separate 'done' and 'fail'
                                         , queryuuid
                                         , numresults := result.totalcount
                                         , time_msecs := GetDatetimeDifference(querystart, GetCurrentDateTime()).msecs
                                         ]);
  }

  RETURN result;
}

// Recursively add a highlight record to nested queries
// @param searchquery An Opensearch query, not a WebHare CQ query
// @cell options.highlightfields The fields in which to highlight matches (both fields that should be summarized and fields
//     that should be returned completely)
// @cell options.highlightparts The fields for which a summary with match highlighting should be returned
// @cell options.summary The length of generated summaries (0 for no summary, -1 for default)
// @cell options.defaultsummary The default length of generated summaries
// @cell options.addparthighlighting If summaries should be generated for the highlightparts fields
// @cell options.path The current nested query path
// @cell return.query The query with added highlight records
// @cell return.highlightfields Remaining fields to be highlighted (fields already highlighted in nested queries are not returned)
RECORD FUNCTION AddQueryHighlighting(RECORD searchquery, RECORD options)
{
  IF (CellExists(searchquery, "query") AND RecordExists(searchquery.query))
  {
    // Unwrap the 'query' field of the top-level searchquery and nested queries
    RECORD highlight := AddQueryHighlighting(searchquery.query, options);
    searchquery.query := highlight.query;
    options.highlightfields := highlight.highlightfields;
  }
  ELSE IF (CellExists(searchquery, "bool"))
  {
    // Recurse into boolean query clauses
    FOREVERY (STRING requirement FROM [ "must", "must_not", "should" ])
      IF (CellExists(searchquery.bool, requirement))
      {
        RECORD ARRAY subqueries := GetCell(searchquery.bool, requirement);
        FOREVERY (RECORD subquery FROM subqueries)
        {
          RECORD highlight := AddQueryHighlighting(subquery, options);
          subqueries[#subquery] := highlight.query;
          options.highlightfields := highlight.highlightfields;
        }
        searchquery.bool := CellUpdate(searchquery.bool, requirement, subqueries);
      }
  }
  ELSE IF (CellExists(searchquery, "nested"))
  {
    // Recurse into the query, collecting used highlight fields from deeper nested queries
    RECORD highlight := AddQueryHighlighting(searchquery.nested.query, options);
    searchquery.nested.query := highlight.query;
    options.highlightfields := highlight.highlightfields;
    // Add highlighting to inner hits
    highlight := AddFieldHighlighting(searchquery.nested.inner_hits, CELL[ ...options, searchquery.nested.path ]);
    searchquery.nested.inner_hits := highlight.query;
    options.highlightfields := highlight.highlightfields;
  }

  RETURN CELL[ query := searchquery, options.highlightfields ];
}

// This function does the actual adding of the highlight record, returning the augmented query and remaining highlightfields
RECORD FUNCTION AddFieldHighlighting(RECORD searchquery, RECORD options)
{
  STRING ARRAY highlightfields := options.path != "" ? SELECT AS STRING ARRAY field FROM ToRecordArray(options.highlightfields, "field") WHERE field LIKE options.path || ".*" : options.highlightfields;
  options.highlightfields := ArrayDelete(options.highlightfields, highlightfields);
  IF (options.addparthighlighting OR Length(highlightfields) > 0)
  {
    INSERT CELL highlight :=
        [ fields := RECORD[]
        , pre_tags := [ Length(highlightfields) > 0 ? "\x1d" : "" ]
        , post_tags := [ Length(highlightfields) > 0 ? "\x1c" : "" ]
        // We cannot use encoder := "html", as it only encodes fragments with matches
        ] INTO searchquery;
    // The 'highlightparts' fields are used for summary generation with the given length (with number_of_fragments set to 1)
    IF (options.addparthighlighting OR ArraysIntersect(highlightfields, options.highlightparts))
    {
      FOREVERY (STRING field FROM ArrayIntersection(highlightfields, options.highlightparts) ?? options.highlightparts)
        INSERT CellInsert(DEFAULT RECORD, field, [ number_of_fragments := 1
                                                 , fragment_size := options.summary < 0 ? options.defaultsummary : options.summary
                                                 , no_match_size := options.summary < 0 ? options.defaultsummary : options.summary
                                                 , type := options.highlighttype
                                                 ])
          INTO searchquery.highlight.fields AT END;
    }
    // The other highlight fields are returned completely (number_of_fragments set to 0)
    FOREVERY (STRING field FROM ArrayDelete(highlightfields, options.highlightparts))
      IF (field NOT IN options.highlightparts)
        INSERT CellInsert(DEFAULT RECORD, field, [ number_of_fragments := 0 ]) INTO searchquery.highlight.fields AT END;
  }
  RETURN CELL[ query := searchquery, options.highlightfields ];
}

PUBLIC RECORD FUNCTION QueryIndexManager(INTEGER indexid, RECORD query, RECORD options)
{
  RECORD defaultoptions :=
      [ first := 0
      , count := 0
      , mapping := DEFAULT RECORD
      , lang := ""
      , suffix := ""
      , managedonly := FALSE
      , indexmanager := 0
      , totaltotrack := 10000
        /* If 'acceptmissingindex' is set, we'll consider a 404 (no such index) to be equivalent to "no results". This is
           useful for eg. analysis code which will deal with in-progress indices at a later stage */
      , acceptmissingindex := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result :=
      [ status := SearchIndexNotFound
      , totalcount := 0
      , totalexact := TRUE
      , results := DEFAULT RECORD ARRAY
      ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager", CELL[ indexid, query, options ]);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ managedonly := options.managedonly ]);
  RECORD indexmanager := options.indexmanager = 0
      ? RECORD(indexmanagers)
      : RECORD(SELECT * FROM indexmanagers WHERE id = options.indexmanager);

  IF (RecordExists(indexmanager))
  {
    RECORD mapping := options.mapping;
    // Make sure at least objectid and groupid are returned, if this is not an unmanaged index
    IF (indexmanager.indextype != whconstant_consilio_catalogtype_unmanaged)
      mapping := CELL[ objectid := "", groupid := "", ...mapping ];
    RECORD searchquery := CreateOpenSearchQuery(query, mapping, DEFAULT RECORD);

    // Optimization when scoring isn't relevant - https://opensearch.org/docs/latest/opensearch/ux/#sort-results
    INSERT CELL sort := [ "_doc" ] INTO searchquery;
    IF (options.first != defaultoptions.first)
      INSERT CELL "from" := options.first INTO searchquery;
    IF (options.totaltotrack != defaultoptions.totaltotrack)
    {
      IF (options.totaltotrack > 0)
        INSERT CELL track_total_hits := options.totaltotrack INTO searchquery;
      ELSE
        INSERT CELL track_total_hits := options.totaltotrack < 0 INTO searchquery; // -1: always track accurately, 0: don't track at all
    }
    BOOLEAN scrolling;
    IF (options.count != defaultoptions.count)
    {
      INSERT CELL size := options.count >= 0 ? options.count : 10000 INTO searchquery;

      // If requesting all results, use the scrolling API
      scrolling := options.count = -1;
    }

    STRING scrollid;
    BOOLEAN search_done;
    INTEGER totalhits;
    WHILE (NOT search_done)
    {
      RECORD response;
      // If we have a scroll id, request the next batch of results
      IF (scrollid != "")
        response := SendRawJSONToOpenSearch(indexmanager.id, "GET", "/_search/scroll", [ scroll := "10s", scroll_id := scrollid ]);
      ELSE
      {
        STRING suffix := indexid > 0 AND indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged ? (options.suffix != "" ? "-" || options.suffix : "") : "";
        response := SendRawJSONToOpenSearch(indexmanager.id, "GET", (indexid != 0 ? indexmanager.indexname || suffix : "_all") || "/_search" || (scrolling ? "?scroll=10s" : "")
                                              , searchquery
                                              , [ expectstatus := options.acceptmissingindex ? [ 200, 404 ] : [ 200 ] ]);
        IF(response.code = 404) //Index (not yet) present
          RETURN CELL[ ...result, status := SearchOk ];
      }

      result.status := response.status;
      IF (result.status = SearchOk)
      {
        IF (response.result.timed_out)
        {
          result.status := SearchTimeOutError;
          BREAK;
        }
        ELSE
        {
          // If we're not using the scrolling API, we're done, otherwise
          // store the scroll id for retrieval of the next batch of results
          IF (NOT scrolling)
            search_done := TRUE;

          // Only need to read the total count once - scrollid is empty when not scrolling or when receiving the first result
          IF (scrollid = "")
          {
            result.totalcount := response.result.hits.total.value;
            result.totalexact := response.result.hits.total.relation = "eq";
          }

          // An array with length 0 is returned as VARIANT ARRAY
          IF (Length(response.result.hits.hits) > 0)
          {
            IF (scrolling)
              scrollid := response.result._scroll_id;

            result.results := result.results CONCAT ReadOpenSearchResults(response.result.hits.hits, searchquery, mapping, options);
          }
          ELSE
          {
            // If a batch doesn't contain results, we're done
            search_done := TRUE;
          }
        }
      }
      ELSE
        BREAK;
    }

    // Clear the last scrolling context, if necessary
    IF (scrollid != "")
      SendRawJSONToOpenSearch(indexmanager.id, "DELETE", "/_search/scroll", [ scroll_id := [ scrollid ] ]);
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "QueryIndexManager done", CELL[ result ]);

  RETURN result;
}

/*
*/
PUBLIC RECORD FUNCTION SuggestIndexManager(INTEGER indexid, STRING query, RECORD options)
{
  RECORD defaultoptions :=
      [ count := 10
      , doccount := "search"
      , prefix := ""
      , restrict_to := ""
      , exclude_urls := STRING[]
      , and_search := FALSE
      , debug := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  RECORD result := [ status := SearchIndexNotFound
                   , suggestions := DEFAULT RECORD ARRAY
                   ];

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager", CELL[ indexid, query, options ]);

  RECORD indexmanager := GetIndexManagersForIndex(indexid);
  IF (RecordExists(indexmanager))
  {
    OBJECT tokenizer := NEW TokenStream(query);
    RECORD token := tokenizer->GetNextToken();
    STRING userquery, userword, querystring;
    STRING ARRAY otherwords;
    WHILE (RecordExists(token))
    {
      IF (token.type = TokenTypeWord)
      {
        querystring := token.normalizedtext;
        INSERT querystring INTO otherwords AT END;
        userword := token.text;
        userquery := Left(query, token.startoffset);
      }
      token := tokenizer->GetNextToken();
    }
    INTEGER wordlen := Length(userword);
    INTEGER prefixlen;
    IF (indexid = -1 AND options.prefix != "")
    {
      querystring := options.prefix || "_" || querystring;
      prefixlen := Length(options.prefix) + 1;
    }
    IF (querystring != "")
    {
      RECORD suggestquery :=
          [ _source := [ "_suggested" ]
          , suggest :=
              [ suggested :=
                  [ prefix := querystring
                  , completion := [ field := "_suggested" ]
                  ]
              ]
          ];
      // If the and_search option is set, query documents containing the other query words
      IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 1)
      {
        DELETE FROM otherwords AT END-1; // Remove the suggestions query word
        INSERT CELL query :=
            [ bool :=
                [ must := (SELECT match := [ _suggested := word ] FROM ToRecordArray(otherwords, "word"))
                ]
            ] INTO suggestquery;
      }
      IF (indexid != -1 AND (options.restrict_to != "" OR Length(options.exclude_urls) != 0))
        INSERT "objecturl" INTO suggestquery._source AT END;

      IF(options.debug)
        Print(`OpenSearch query:\nGET /${indexmanager.indexname}\n${EncodeJSON(suggestquery)}\n`);
      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "GET", indexmanager.indexname || "/_search", suggestquery);
      IF(options.debug)
        DumpValue(response, "tree");

      result.status := response.status;
      IF (response.status = SearchOk AND CellExists(response.result, "suggest")) // suggest may not exist if indexmanager should be restarted
      {
        // The suggest results are by matching document, returning only the first matching suggestion, so we'll have to
        // manually go through all suggested terms (the original input) and see which terms match with the query. This has
        // the added benefit of having a method to count the number of matching documents
        IF (Length(response.result.suggest.suggested.options) > 0)
        {
          // These are the documents containing the other query words
          STRING ARRAY otherdocs := Length(response.result.hits.hits) > 0 ? SELECT AS STRING ARRAY _id FROM response.result.hits.hits : STRING[];
          FOREVERY (RECORD suggest FROM response.result.suggest.suggested.options)
          {
            IF (indexid != -1
                AND options.restrict_to != ""
                AND suggest._source.objecturl NOT LIKE options.restrict_to || "*")
              CONTINUE;
            IF (indexid != -1
                AND Length(options.exclude_urls) > 0)
            {
              BOOLEAN exclude;
              FOREVERY(STRING excludeurl FROM options.exclude_urls)
                IF(suggest._source.objecturl LIKE excludeurl || "*")
                {
                  exclude := TRUE;
                  BREAK;
                }
              IF(exclude)
                CONTINUE;
            }
            IF (options.and_search AND options.doccount = "search" AND Length(otherwords) > 0 AND suggest._id NOT IN otherdocs)
              CONTINUE;
            FOREVERY (STRING text FROM suggest._source._suggested.input)
              IF (text LIKE querystring || "*")
              {
                text := userword || Substring(text, prefixlen + wordlen);
                INTEGER cur :=
                    (SELECT AS INTEGER #suggestions + 1
                       FROM result.suggestions
                      WHERE COLUMN text = VAR text) - 1;
                IF (cur < 0)
                {
                  cur := Length(result.suggestions);
                  INSERT [ text := text, count := 0 ] INTO result.suggestions AT cur;
                }
                IF (options.doccount != "" AND cur >= 0)
                  result.suggestions[cur].count := result.suggestions[cur].count + 1;
              }
          }
        }

        INTEGER max := options.count != defaultoptions.count AND options.count >= 0 ? options.count : defaultoptions.count;
        IF (max > 0)
          result.suggestions :=
              SELECT *
                FROM result.suggestions
               ORDER BY COLUMN count DESC
                      , text
               LIMIT max;
      }
      IF (userquery != "")
        UPDATE result.suggestions
           SET text := userquery || text;
    }
  }

  IF(IsDebugTagEnabled("consilio:searches"))
    LogDebug("consilio:searches", "SuggestIndexManager done", CELL[ result ]);

  RETURN result;
}

/// @return Size, or -1 when no indexmanager configured, or -2 when index not found on indexmanager
PUBLIC INTEGER FUNCTION GetIndexManagerSize(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ indexmanager := 0
      , indexname := ""
      ], options);

  INTEGER size := -1;

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid);
  RECORD indexmanager :=
      SELECT *
        FROM indexmanagers
       WHERE (options.indexmanager = 0 ? TRUE : id = options.indexmanager)
         AND (options.indexname = "" ? TRUE : indexname = options.indexname);

  IF (NOT RecordExists(indexmanager))
    RETURN size;

  STRING suffix := indexmanager.indextype = 1 ? "*" : "";
  TRY
  {
    RECORD count := EnforceStructure([ [ count := 0 ] ], SendRawJSONToOpenSearch(indexmanager.id, "GET", "/_cat/count/" || indexmanager.indexname || suffix || "?format=json", DEFAULT RECORD).result);
    size := count.count;
  }
  CATCH (OBJECT e)
  {
    IF(NOT RecordExists(e->error) OR e->error.type != "index_not_found_exception")
      THROW;
    size := -2;
  }

  RETURN size;
}

STATIC OBJECTTYPE IndexManagerBulkKeeper
<
  RECORD ARRAY _requests;

  /** Add bulk requests for an OpenSearch indexmanager
      @param indexmanagerid Indexmanager id
      @param indexname Name of the index
      @param requests List of requests to add for this index
      @cell options.suffix Suffix
  */
  PUBLIC MACRO AddOpenSearchRequests(INTEGER indexmanagerid, STRING indexname, RECORD ARRAY requests, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(Length(requests) = 0)
      RETURN; //a caller was probably grouping and sending us an empty group

    options := ValidateOptions(
        [ suffix :=       ""
        ], options);

    RECORD rec := CELL
        [ indexmanagerid
        , finalindexname :=       indexname  || (options.suffix != "" ? "-" || options.suffix : "")
        , requests
        ];

    RECORD pos := RecordLowerBound(this->_requests, rec, [ "INDEXMANAGERID", "FINALINDEXNAME" ]);
    IF (pos.found)
      this->_requests[pos.position].requests := this->_requests[pos.position].requests CONCAT requests;
    ELSE
      INSERT rec INTO this->_requests AT pos.position;
  }

  /** Execute the collected bulk operations
      @cell(boolean) options.refresh Set to TRUE to wait until visible for search, OpenSearch only
      @return Result code
  */
  PUBLIC STRING FUNCTION Execute(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(
        [ refresh :=            FALSE
        , timeout := opensearch_write_timeout
        ], options,
        [ notypecheck := [ "refresh" ]
        ]);

    STRING retval := SearchOk;
    RECORD ARRAY errors;
    FOREVERY (RECORD rec FROM this->_requests)
    {
      STRING url := rec.finalindexname || "/_bulk";
      RECORD response := SendRawJSONToOpenSearch(rec.indexmanagerid, "POST", url, [ bulkrequests := rec.requests ], CELL[ ndjson := TRUE, options.refresh, options.timeout ]);
      IF(response.result.errors)
      {
        RECORD ARRAY itemresponses := SELECT *, operation := CellExists(items,"index") ? items."index" : items."delete"
                                          FROM response.result.items;
        errors := errors CONCAT SELECT * FROM itemresponses WHERE CellExists(operation, "error");
      }
    }

    IF(Length(errors) > 0)
    {
      //FIXME we get an _id back, but we don't calculate them here so how to figure out which object it actually referred to for a proper error?
      //FIXME what if more than one object failed? we should throw more informing errors
      THROW NEW OpenSearchException(`Failed on document '${errors[0].operation._id}': ${errors[0].operation.error.reason} (${errors[0].operation.error.type})`, DEFAULT OBJECT, "");
    }
    RETURN retval;
  }
>;

PUBLIC OBJECT FUNCTION GetIndexManagerBulkKeeper()
{
  RETURN NEW IndexManagerBulkKeeper;
}



// @cell objects.objectid
// @cell objects.documentfields
// @cell objects.suggestfields (only used by legacy consilio, opensearch uses the mapping's suggested property)
// @cell objects.suggestprefixes (only used by legacy consilio)
// @cell objects._id The OpenSearch document id (if not supplied, generate a hashed id based on indexid, objectid and suffix)
// @cell(object #IndexManagerBulkKeeper) options.bulk Bulk update keeper, use collect updates to perform in a bulk operation
PUBLIC MACRO AddIndexManagerObjects(OBJECT catalog, RECORD contentsource, STRING groupid, RECORD ARRAY objects, RECORD options)
{
  RECORD defaultoptions :=
      [ refresh := FALSE // Set to TRUE to wait until visible for search, OpenSearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, OpenSearch only
      , bulk := DEFAULT OBJECT
      , debug := FALSE
      , timeout := opensearch_write_timeout
      ];
  options := ValidateOptions(defaultoptions, options);

  INTEGER indexid := catalog->id;

  OBJECT temporarybulk;
  IF(NOT ObjectExists(options.bulk))  //we should always use a bulk submitter to centralize error handling code
    temporarybulk := GetIndexManagerBulkKeeper();

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  IF (IsDefaultValue(indexmanagers))
    THROW NEW Exception(`No indexmanagers found for index #${indexid}`);

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    RECORD response;
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
    {
      RECORD ARRAY bulkrequests;
      FOREVERY (RECORD obj FROM objects)
      {
        // action_and_meta_data
        INSERT [ "index" := [ _id := CellExists(obj, "_id") AND obj._id != "" ? obj._id : GetOpenSearchDocumentId(indexid, obj.objectid, options.suffix) ]] INTO bulkrequests AT END;
        // optional_source
        INSERT FixupOpenSearchDocumentFields(obj.documentfields) INTO bulkrequests AT END;

        IF(options.debug)
          Print(`Prepared to add: ${EncodeJSON(bulkrequests[END-1])}\n`);
      }

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
    }
    ELSE
    {
      STRING ARRAY suggestfields := catalog->__GetSuggestedFields();

      RECORD ARRAY bulkrequests;
      FOREVERY (RECORD obj FROM objects)
      {
        RECORD document := obj.documentfields;
        INSERT CELL groupid := groupid
                  , objectid := obj.objectid
                  , _contentsource := contentsource.id
          INTO document;

        IF (Length(suggestfields) > 0)
        {
          STRING ARRAY suggested;
          OBJECT tokenizer := NEW TokenStream("");
          FOREVERY (STRING field FROM suggestfields)
          {
            IF (field LIKE "_*")
              field := Substring(field, 1);
            IF (field IN obj.suggestfields AND CellExists(document, field))
            {
              IF(TYPEID(GetCell(document, field)) != TYPEID(STRING))
                THROW NEW Exception(`Suggest expected '${field}' to be of type STRING, got ${GetTypeName(TYPEID(GetCell(document, field)))})`);

              tokenizer->AddText(" " || GetCell(document, field));
            }
          }
          RECORD token := tokenizer->GetNextToken();
          WHILE (RecordExists(token))
          {
            IF (token.type = TokenTypeWord AND token.normalizedtext NOT IN suggested)
              INSERT token.normalizedtext INTO suggested AT END;
            token := tokenizer->GetNextToken();
          }
          IF (Length(suggested) > 0)
            INSERT CELL _suggested := [ input := suggested ] INTO document;
        }

        // action_and_meta_data
        INSERT [ "index" := [ _id := CellExists(obj, "_id") AND obj._id != "" ? obj._id : GetOpenSearchDocumentId(indexid, obj.objectid) ] ] INTO bulkrequests AT END;
        // optional_source
        INSERT FixupOpenSearchDocumentFields(document) INTO bulkrequests AT END;

        IF(options.debug)
          Print(`Prepared to add: ${EncodeJSON(bulkrequests[END-1])}\n`);
      }

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
    }
  }

  IF(ObjectExists(temporarybulk))
    temporarybulk->Execute(CELL[ options.refresh, options.timeout ]);
}

/** @short Delete a group from an index
    @param indexid The index to delete the group from (0 for all indices)
    @param contentsourceid The content source to delete the group from (0 for
        all content sources)
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
    @param groupid The group to delete
*/
PUBLIC MACRO DeleteIndexManagerGroup(INTEGER indexid, INTEGER contentsourceid, STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      ], options);

  IF (groupid = "")
    THROW NEW Exception(`No groupids specified`);
  IF (indexid = 0)
    THROW NEW Exception(`No catalog specified`);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    // No support for groupids in unmanaged indices
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
      THROW NEW Exception(`Cannot DeleteIndexManagerGroup on an unmanaged index`);

    RECORD query :=
        [ query :=
            [ bool :=
                [ must :=
                      [ [ match := [ groupid := groupid ] ]
                      ]
                ]
            ]
        ];
    IF (contentsourceid != 0)
      INSERT [ match := [ _contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

    SendRawJSONToOpenSearch(indexmanager.id, "POST", (indexid != 0 ? indexmanager.indexname : "_all") || `/_delete_by_query`, query, CELL[options.refresh]);
  }
}

/** @short Delete an object from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param options @includecelldef #DeleteIndexManagerObjects.options
    @param objectid The object to delete
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObject(INTEGER indexid, INTEGER contentsourceid, STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RETURN DeleteIndexManagerObjects(indexid, contentsourceid, [objectid], options);
}

/** @short Delete multiple objects from an index
    @param indexid The index to delete the object from (0 for all indices)
    @param contentsourceid Content source to delete the object from
    @param objectids The objects to delete
    @cell(boolean) options.refresh Set to TRUE to wait until visible for search, OpenSearch only
    @cell(string) options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @cell(object #IndexManagerBulkKeeper) options.bulk Bulk update keeper, use collect updates to perform in a bulk operation
    @cell(boolean) options.raw_ids The supplied objectids are OpenSearch document ids (`_id`)
    @return If the deletion was successful for all affected indexmanagers
*/
PUBLIC STRING FUNCTION DeleteIndexManagerObjects(INTEGER indexid, INTEGER contentsourceid, STRING ARRAY objectids, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD defaultoptions :=
      [ refresh := FALSE // Set to TRUE to wait until visible for search, OpenSearch only
      , suffix := "" // Sub-index suffix, for unmanaged indices, OpenSearch only
      , bulk := DEFAULT OBJECT
      , raw_ids := FALSE
      ];
  options := ValidateOptions(defaultoptions, options);

  STRING result;

  OBJECT temporarybulk;
  IF(NOT ObjectExists(options.bulk))  //we should always use a bulk submitter to centralize error handling code
    temporarybulk := GetIndexManagerBulkKeeper();

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    // For unmanaged indices, delete by document id
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
    {
      IF (indexid = 0 OR contentsourceid != 0)
        THROW NEW Exception(`DeleteIndexManagerObjects with indexid = 0 OR contentsourceid != 0 not supported for unmanaged indices`);

      RECORD ARRAY bulkrequests :=
          SELECT "delete" := [ _id := options.raw_ids ? objectid : GetOpenSearchDocumentId(indexid, objectid, options.suffix) ]
            FROM ToRecordArray(objectids, "objectid");

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests, CELL[ options.suffix ]);
      CONTINUE;
    }

    IF (indexid != 0)
    {
      RECORD ARRAY bulkrequests :=
          SELECT "delete" := [ _id := options.raw_ids ? objectid : GetOpenSearchDocumentId(indexid, objectid, "") ]
            FROM ToRecordArray(objectids, "objectid");

      (temporarybulk ?? options.bulk)->AddOpenSearchRequests(indexmanager.id, indexmanager.indexname, bulkrequests);
    }
    ELSE
    {
      RECORD query :=
          [ query :=
              [ bool :=
                  [ must := RECORD[]
                  , should := (SELECT match := [ objectid := objectid ] FROM ToRecordArray(objectids, "objectid"))
                  , minimum_should_match := 1
                  ]
              ]
          ];
      IF (contentsourceid != 0)
        INSERT [ match := [ _contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "POST", `${(indexid != 0 ? indexmanager.indexname : "_all")}/_delete_by_query`, query, CELL[ options.refresh ]);
      IF (response.status != SearchOk)
        result := response.status;
    }
  }

  IF(ObjectExists(temporarybulk))
    RETURN result ?? temporarybulk->Execute(CELL[ options.refresh ]) ?? SearchOk;

  RETURN result ?? SearchOk;
}

/** @short Delete outdated objects
    @param indexid The index to delete outdated objects from
    @param contentsourceid The content source to delete outdated objects from (0
        for all content sources)
    @param groupid Delete outdated objects for this group only ("" for all groups)
    @param objectid Delete outdated objects for this object only ("" for all objects)
    @param deletebefore Delete all objects that have been indexed before this date
    @cell options.refresh Refresh all shards involved in the delete by query once the request completes (opensearch only)
*/
PUBLIC MACRO DeleteIndexManagerOutdated(INTEGER indexid, INTEGER contentsourceid, DATETIME deletebefore)
{
  IF (indexid = 0 OR deletebefore = DEFAULT DATETIME)
    THROW NEW Exception(`Invalid arguments`);

  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ]);
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    // No support for outdated documents in unmanaged indices
    IF (indexmanager.indextype = whconstant_consilio_catalogtype_unmanaged)
      THROW NEW Exception(`DeleteIndexManagerOutdated not supported on unmanaged catalogs`);

    // delete all documents having '_indexed' before 'deletebefore'
    RECORD query :=
        [ query :=
            [ bool :=
                [ must := DEFAULT RECORD ARRAY
                , filter :=
                    [ [ range := [ _indexed := [ lt := FormatISO8601DateTime(deletebefore, "day", "milliseconds") ] ] ]
                    ]
                ]
            ]
        ];
    IF (contentsourceid != 0)
      INSERT [ match := [ _contentsource := contentsourceid ] ] INTO query.query.bool.must AT END;

    /* If a conflict occurs it's a parallel insert/update, so the doc isn't outdated. We can skip those, thus conflicts=proceed */
    SendRawJSONToOpenSearch(indexmanager.id, "POST", indexmanager.indexname || `/_delete_by_query?conflicts=proceed`, query);
  }
}

/** Refreshes all attached indices of a catalog, so all pendinging updates
    and deletes are visible afterwards
    @param catalogid Id of the catalog to red
    @return Execution result status
*/
PUBLIC STRING FUNCTION RefreshAttachedIndices(INTEGER catalogid)
{
  RECORD ARRAY indexmanagers := GetIndexManagersForIndex(catalogid, [ excludereadonly := TRUE ]);
  STRING result := SearchOk;

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "GET", (indexmanager.indexname || indexmanager.suffix) || "/_refresh", DEFAULT RECORD);
    IF (response.status != SearchOk)
      result := response.status;
  }
  RETURN result;
}

/** Deletes all documents in an index from a specific contentsource
    @param indexmgrid Id of the indexmanager to use
    @param indexid Id of the index
    @param contentsourceid Id of the contentsource whose documents must be removed (set to 0 to delete the entire index)
    @cell options.suffix Sub-index suffix, for unmanaged indices, OpenSearch only
    @return Execution result
    @cell return.status Status
    @cell return.deleted Number of deleted documents
*/
PUBLIC RECORD FUNCTION DeleteIndexManagerContentSource(INTEGER indexmgrid, INTEGER indexid, INTEGER contentsourceid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, OpenSearch only
      , timeout := opensearch_write_timeout
      ], options);

  RECORD result := [ status := SearchUnavailable
                   , deleted := 0
                   ];
  RECORD ARRAY indexmanagers := indexid != 0 ? GetIndexManagersForIndex(indexid, [ excludereadonly := TRUE ])
                                             : GetIndexManagers(indexmgrid, [ excludereadonly := TRUE ]);

  /* TODO this approach really just returns the *last* deletion status, and may (re)delete multiple indices if already marked
     as deletion. This looping should probably happen in the catalog api */
  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    IF ((indexmgrid != 0 AND indexmanager.id != indexmgrid) OR indexid = 0)
      CONTINUE;

    RECORD indexinfo := SELECT * FROM consilio.catalogs WHERE id = indexid;
    IF (RecordExists(indexinfo) AND indexinfo.type = whconstant_consilio_catalogtype_unmanaged)
    {
      // Delete the specific subindex if suffix is set, otherwise delete all subindices
      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "DELETE", indexmanager.indexname || (options.suffix != "" ? "-" || options.suffix : ""), DEFAULT RECORD, CELL[ expectstatus := [200,404], options.timeout ]);
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
    ELSE IF (contentsourceid = 0)
    {
      // No content source specified, delete entire index
      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "DELETE", indexmanager.indexname, DEFAULT RECORD);
      result.status := response.status;
      // Deleting an index doesn't return the number of deleted documents...
    }
    ELSE
    {
      RECORD query :=
          [ query :=
              [ bool :=
                  [ must :=
                        [ [ match := [ _contentsource := contentsourceid ] ]
                        ]
                  ]
              ]
          ];
      // Delete all objects within the content source
      RECORD response := SendRawJSONToOpenSearch(indexmanager.id, "POST", (indexid != 0 ? indexmanager.indexname : "_all") || "/_delete_by_query", query);
      result.status := response.status;
      IF (result.status = SearchOk)
        result.deleted := response.result.deleted;
    }
  }

 IF (result.status = SearchOk)
    BroadcastEvent("consilio:contentsourcestatus", [ id := contentsourceid ]);

  RETURN result;
}

// -----------------------------------------------------------------------------
//
// Helper functions
//

/** @short Find an indexmanager
    @param indexmgrid The id of the indexmanager, or -1 for all indexmanagers
    @cell options.managedonly Only consider managed catalogs
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
RECORD ARRAY FUNCTION GetIndexManagers(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
        [ managedonly := FALSE
        , excludereadonly := FALSE
        ], options);

  RETURN
      SELECT indexmanagers.id
           , catalog_indexmanagers.indexname
           , indextype := catalogs.type
           , indexid := catalogs.id
           , primary := catalog_indexmanagers.searchpriority > 0 //we should obsolete this but probably the entire GetIndexManagers API
           , catalogs.suffix
        FROM consilio.indexmanagers
           , consilio.catalog_indexmanagers
           , consilio.catalogs
       WHERE indexmanagers.id = catalog_indexmanagers.indexmanager
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (indexmgrid = -1 OR indexmanagers.id = indexmgrid)
             AND (options.excludereadonly ? catalog_indexmanagers.readonly = FALSE : TRUE)
    ORDER BY catalog_indexmanagers.searchpriority DESC;
}

/** @short Find the indexmanager for an index
    @param indexid The id of the index, or 0 for the indexmanagers of all indices
    @cell options.managedonly Only consider managed catalogs
    @return The indexmanager(s)
    @cell(integer) return.id The indexmanager id
    @cell(integer) return.type The indexmanager type (currently either 1 for
        Consilio or 2 for Opensearch)
*/
PUBLIC RECORD ARRAY FUNCTION GetIndexManagersForIndex(INTEGER indexid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ managedonly := FALSE
      , excludereadonly := FALSE
      ], options);

  IF (indexid = 0)
    RETURN GetIndexManagers(-1, options);

  RETURN
      SELECT indexmanagers.id
           , catalog_indexmanagers.indexname
           , catalogs.lang
           , indextype := catalogs.type
           , primary := catalog_indexmanagers.searchpriority > 0 //we should obsolete this but probably the entire GetIndexManagers API
           , catalogs.suffix
        FROM consilio.catalogs
           , consilio.catalog_indexmanagers
           , consilio.indexmanagers
       WHERE catalogs.id = indexid
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND catalog_indexmanagers.indexmanager = indexmanagers.id
             AND (options.managedonly ? catalogs.type = whconstant_consilio_catalogtype_managed : TRUE)
             AND (options.excludereadonly ? catalog_indexmanagers.readonly = FALSE : TRUE)
    ORDER BY catalog_indexmanagers.searchpriority DESC;
}
