<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::float.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_queue.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


CONSTANT RECORD ARRAY defaultfields :=
[ [ field := "title",       boost := 10,  stemmed_field := TRUE ]
, [ field := "keywords",    boost := 50, stemmed_field := FALSE ]
, [ field := "description", boost := 10,  stemmed_field := FALSE ]
, [ field := "body",        boost := 1,  stemmed_field := TRUE ]
];

MACRO UpdateRequestDebugSetting(OBJECT browser)
{
  //the setting can change while running, so always recheck
  IF(IsDebugTagEnabled("consilio:traffic"))
  {
    IF(Length(browser->pvt_traffichooks) = 0)
      LogRPCForWebbrowser("consilio:traffic", "", browser);
  }
  ELSE
  {
    browser->pvt_traffichooks := MACRO PTR[];
  }
}

PUBLIC OBJECTTYPE ElasticsearchException EXTEND Exception
<
  PUBLIC RECORD error;

  MACRO NEW(STRING what, OBJECT browser)
  : Exception(what)
  {
    IF (Objectexists(browser)
        AND (browser->GetHTTPStatusCode() < 200 OR browser->GetHTTPStatusCode() > 200)
        AND browser->mimetype = "application/json")
    {
      RECORD decoded := DecodeJSONBLOB(browser->content);
      IF(CellExists(decoded,'error') AND TypeID(decoded.error) = TypeID(RECORD))
      {
        IF(CellExists(decoded.error,'root_cause'))
        {
          this->error := EnforceStructure([ "index" := ""
                                          , "index_uuid" := ""
                                          , "reason" := ""
                                          , "type" := ""
                                          ], decoded.error.root_cause);

          IF(this->error.reason != "")
            this->what := this->what || " (" || this->error.reason || ")";
          RETURN;
        }
        this->error := EnforceStructure([ "index" := ""
                                        , "index_uuid" := ""
                                        , "reason" := ""
                                        , "type" := ""
                                        ], decoded.error);

        IF(this->error.reason != "")
          this->what := this->what || " (" || this->error.reason || ")";
        RETURN;
      }
    }

    IF(Objectexists(browser) AND browser->GetHTTPStatusCode() != 0)
      this->what := this->what || " (" || browser->GetHTTPStatusText() || ")";
  }
>;


PUBLIC STRING FUNCTION GetBuiltinOpensearchAddress()
{
  RETURN `http://${GetEnvironmentVariable("WEBHARE_OPENSEARCH_BINDHOST") ?? "127.0.0.1"}:${GetWebhareConfiguration().baseport + whconstant_consilio_osportoffset}/`;
}

PUBLIC ASYNC FUNCTION WaitForElasticsearch(INTEGER indexmgrid, DATETIME waituntil)
{
  RETURN AWAIT CreatePromise(PTR ConnectElasticsearch(indexmgrid, #1, #2, waituntil));
}

ASYNC MACRO ConnectElasticsearch(INTEGER indexmgrid, FUNCTION PTR resolve, FUNCTION PTR reject, DATETIME waituntil)
{
  WHILE (GetCurrentDateTime() < waituntil)
  {
    RECORD indexmanager;
    IF (indexmanagerconnections->Has(indexmgrid))
    {
      indexmanager := indexmanagerconnections->Lookup(indexmgrid);
    }
    ELSE
    {
      RECORD indexmgr := SELECT * FROM consilio.indexmanagers WHERE id = indexmgrid;
      IF (NOT RecordExists(indexmgr) OR (NOT IsValidPlainHTTPUrl(indexmgr.address) AND indexmgr.address != "builtin-opensearch"))
      {
        reject(NEW Exception(SearchInvalidArgument));
        RETURN;
      }

      indexmanager := [ address := indexmgr.address
                      , browser := DEFAULT OBJECT
                      , clusterstatus := ""
                      ];

      IF (indexmanager.address = "builtin-opensearch")
        indexmanager.address := GetBuiltinOpensearchAddress();

      // Make sure the address doesn't end with a slash
      IF (indexmanager.address LIKE "*/")
        indexmanager.address := Left(indexmanager.address, Length(indexmanager.address) - 1);
    }
    IF (NOT ObjectExists(indexmanager.browser))
    {
      indexmanager.browser := NEW WebBrowser();
      indexmanager.browser->timeout := opensearch_read_timeout;
    }

    UpdateRequestDebugSetting(indexmanager.browser);
    IF (indexmanager.clusterstatus NOT IN [ "yellow", "green" ])
    {
      FetcherDebug(ConsilioDebugInfo, "Connecting to Elasticsearch");
      // Wait for the cluster to reach 'yellow' status
      IF (NOT indexmanager.browser->SendRawRequest("GET", `${indexmanager.address}/_cluster/health?wait_for_status=yellow&timeout=${opensearch_read_timeout}ms`, [ [ field := "Content-Type", value := "application/json" ] ], DEFAULT BLOB))
      {
        INTEGER statuscode := indexmanager.browser->GetHTTPStatusCode();
        IF (statuscode = 401)
        {
          FetcherDebug(ConsilioDebugInfo, `Authentication error while connecting to Elasticsearch ${indexmgrid} on ${indexmanager.address}`);
          reject(NEW ElasticsearchException(SearchNoAccess, indexmanager.browser));
          RETURN;
        }

        FetcherDebug(ConsilioDebugInfo, `Could not connect to Elasticsearch ${indexmgrid} on ${indexmanager.address}`);
      }
      ELSE
      {
        RECORD status := DecodeJSONBlob(indexmanager.browser->content);
        indexmanager.clusterstatus := status.status;
        indexmanagerconnections->Add(indexmgrid, indexmanager);
        FetcherDebug(ConsilioDebugInfo, `Elasticsearch ${indexmgrid} cluster status: ${indexmanager.clusterstatus}`);
      }
    }
    IF (indexmanager.clusterstatus IN [ "yellow", "green" ])
    {
      resolve(SearchOk);
      RETURN;
    }

    // Wait before trying again
    AWAIT CreateSleepPromise(1000);
  }
  reject(NEW Exception(SearchTimeOutError));
}

PUBLIC RECORD FUNCTION SendRawJSONToElasticsearch(INTEGER indexmgrid, STRING method, STRING suburl, RECORD requestbody, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ ndjson := FALSE
                              , timeout := ToUppercase(method) IN ["HEAD","GET"] ? opensearch_read_timeout : opensearch_write_timeout
                              , enforce := ""
                              , expectstatus := [ 200 ]
                              , explain := FALSE
                              ], options,
                              [ enums := [ enforce := [ "", "_search_get" ] ]
                              ]);

  //TODO remove this up when we trust our APIs well enough
  IF(ToUppercase(method) NOT IN ["HEAD","GET"])
  {
    STRING findindexname := suburl LIKE "/*" ? Tokenize(suburl,'/')[1] : suburl;
    RECORD ARRAY attachedindexinfo := SELECT * FROM consilio.catalog_indexmanagers WHERE indexmanager = indexmgrid AND indexname = findindexname;
    IF(Length(attachedindexinfo) = 1 AND attachedindexinfo[0].readonly)
      THROW NEW Exception(`Attempting to write to readonly index '${findindexname}': ${method} ${suburl}`);
  }

  WaitForPromise(WaitForElasticsearch(indexmgrid, AddTimeToDate(opensearch_firstconnect_timeout, GetCurrentDateTime())));

  INTEGER statuscode;
  RECORD indexmanager;
  WHILE (TRUE) // Repeat until succesfully sent
  {
    // If WaitForElasticsearch returned SearchOk, the indexmanager is present in indexmanagerconnections
    indexmanager := indexmanagerconnections->Lookup(indexmgrid);
    IF (NOT ObjectExists(indexmanager.browser))
    {
      IF (running_in_fetcher AND print_defer_connection)
        Print("Defer:connection\n");

      THROW NEW ElasticsearchException("Connection failed", DEFAULT OBJECT);
    }

    STRING url := indexmanager.address || (suburl LIKE "/*" ? "" : "/") || suburl;
    BLOB body;
    IF (options.ndjson)
    {
      // For _bulk requests, convert the request records to NDJSON
      body := StringToBlob(Detokenize((SELECT AS STRING ARRAY EncodeJSON(bulkrequests) FROM requestbody.bulkrequests), "\n") || "\n");
    }
    ELSE IF (RecordExists(requestbody))
    {
      // Other requests are just JSON-encoded
      body := EncodeJSONBlob(requestbody);
    }
    RECORD ARRAY headers;
    IF (Length(body) > 0)
      INSERT [ field := "Content-Type", value := options.ndjson ? "application/x-ndjson" : "application/json" ] INTO headers AT END;

    UpdateRequestDebugSetting(indexmanager.browser);
    indexmanager.browser->timeout := options.timeout;
    BOOLEAN success := indexmanager.browser->SendRawRequest(method, url, headers, body);

    statuscode := indexmanager.browser->GetHTTPStatusCode();
    IF (statuscode NOT IN options.expectstatus)
    {
      IF (indexmanager.browser->GetSocketError() = -9) // timeout
      {
        FetcherDebug(ConsilioDebugAll, "Connection probably timed out, trying to reconnect...");
        WaitForPromise(WaitForElasticsearch(indexmgrid, AddTimeToDate(options.timeout, GetCurrentDateTime())));
        FetcherDebug(ConsilioDebugAll, "Reconnected, trying request again");
        // Don't break, try to send request again with new connection
      }
      ELSE
      {
        THROW NEW ElasticsearchException("Unexpected response code " || statuscode, indexmanager.browser);
      }
    }
    ELSE
    {
      // Got 2xx response code, everything is alright
      BREAK;
    }
  }

  VARIANT decoded := DEFAULT RECORD;
  IF (ToLowercase(indexmanager.browser->contenttype) LIKE "application/json*")
  {
    IF (options.enforce != "")
      decoded := DecodeIncomingJSON(indexmanager.browser->content, options.enforce, CELL[ options.explain ]);
    ELSE
      decoded := DecodeJSONBlob(indexmanager.browser->content);
  }

  RETURN
      [ status  := statuscode = 404 ? SearchIndexNotFound
                 : statuscode = 401 ? SearchNoAccess
                 : statuscode < 200 OR statuscode > 299 ? SearchHTTPError
                 : SearchOk
      , code    := indexmanager.browser->GetSocketError() ?? statuscode
      , content := indexmanager.browser->content
      , headers := indexmanager.browser->responseheaders
      , result  := decoded
      ];
}

PUBLIC RECORD FUNCTION GetElasticsearchStatus(INTEGER indexmgrid)
{
  RECORD result :=
      [ status := SearchOk
      , msg := DEFAULT STRING ARRAY
      ];

  // Get file system status (containing total and available disk space)
  RECORD fs_stats := SendRawJSONToElasticsearch(indexmgrid, "GET", "/_nodes/stats/fs", DEFAULT RECORD);
  IF (fs_stats.status != SearchOk)
    RETURN CELL[ ...result, status := fs_stats.status ];

  // Get cluster settings (containing disk thresholds)
  RECORD settings := GetElasticsearchSettings(indexmgrid, TRUE);
  IF (NOT RecordExists(settings))
    RETURN CELL[ ...result, status := SearchHTTPError ];

  // The nodes are named; we'll just use the first (and, at least for now, only) node
  RECORD node := UnpackRecord(fs_stats.result.nodes)[0].value;
  // Disk sizes are returned as floats, presumably to support disk sizes > 2^63 bytes. We'll cross that bridge when we get
  // there...
  INTEGER64 available_bytes := INTEGER64(node.fs.total.available_in_bytes);
  INTEGER64 total_bytes := INTEGER64(node.fs.total.total_in_bytes);

  INSERT `disk.available=${available_bytes}` INTO result.msg AT END;
  INSERT `disk.total=${total_bytes}` INTO result.msg AT END;

  // Read cluster disk settings
  IF (settings."cluster.routing.allocation.disk.threshold_enabled" != "false")
  {
    INTEGER64 low_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.low", total_bytes);
    INTEGER64 high_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.high", total_bytes);
    INTEGER64 flood_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.flood_stage", total_bytes);
    IF (available_bytes < flood_bytes AND CellExists(settings,"cluster.routing.allocation.disk.watermark.flood"))
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=flood=${settings."cluster.routing.allocation.disk.watermark.flood"}` INTO result.msg AT END;
    }
    ELSE IF (available_bytes < high_bytes)
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=high=${settings."cluster.routing.allocation.disk.watermark.high"}` INTO result.msg AT END;
    }
    ELSE IF (available_bytes < low_bytes)
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=low=${settings."cluster.routing.allocation.disk.watermark.low"}` INTO result.msg AT END;
    }
    ELSE
    {
      INSERT `indexstatus=1` INTO result.msg AT END;
      INSERT "disk.watermark=ok" INTO result.msg AT END;
    }
  }
  ELSE
  {
    INSERT `indexstatus=1` INTO result.msg AT END;
    INSERT "disk.watermark=false" INTO result.msg AT END;
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION GetElasticsearchSettings(INTEGER indexmgrid, BOOLEAN include_defaults, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ timeout := opensearch_read_timeout ], options);
  STRING command := "/_cluster/settings?flat_settings=true";
  IF (include_defaults)
    command := command || "&include_defaults=true";

  RECORD settings := SendRawJSONToElasticsearch(indexmgrid, "GET", command, DEFAULT RECORD);
  IF (settings.status != SearchOk)
    RETURN DEFAULT RECORD;

  /*
    https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html#_order_of_precedence

    The order of precedence for cluster settings is:

    1. transient cluster settings
    2. persistent cluster settings
    3. settings in the elasticsearch.yml configuration file.
  */
  IF (include_defaults)
    RETURN CELL
      [ ...settings.result.defaults
      , ...settings.result.persistent
      , ...settings.result.transient
      ];
  RETURN CELL
    [ ...settings.result.persistent
    , ...settings.result.transient
    ];
}

// To set low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := "85%" ]
// To clear low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := DEFAULT RECORD ] (encoded as "null")
PUBLIC RECORD FUNCTION SetElasticsearchSettings(INTEGER indexmgrid, RECORD settings, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ transient := FALSE ], options);
  RECORD request;
  IF (options.transient)
    request := [ transient := settings ];
  ELSE
    request := [ persistent := settings ];
  RETURN SendRawJSONToElasticsearch(indexmgrid, "PUT", "/_cluster/settings", request);
}

INTEGER64 FUNCTION ReadWatermark(STRING input, INTEGER64 total_bytes)
{
  IF (input LIKE "*%")
  {
    // The percentage of the disk that is used
    INTEGER percentage := ToInteger(Left(input, Length(input) - 1), 0);
    IF (percentage <= 0)
      RETURN -1;
    // Note: this will only work with disk sizes < 2^63 / 100
    RETURN total_bytes - (total_bytes * percentage / 100);
  }
  ELSE
  {
    // The absolute number of free bytes
    INTEGER64 bytes := ParseElasticsearchBytes(input);
    IF (bytes < 0)
      RETURN -1;
    RETURN bytes;
  }
}

PUBLIC INTEGER64 FUNCTION ParseElasticsearchBytes(STRING readable_bytes)
{
  readable_bytes := ToLowercase(readable_bytes);
  INTEGER64 factor := 1;
  IF (readable_bytes LIKE "*kb")
    factor := 1024;
  ELSE IF (readable_bytes LIKE "*mb")
    factor := 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*gb")
    factor := 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*tb")
    factor := 1024 * 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*pb")
    factor := 1024 * 1024 * 1024 * 1024 * 1024;
  IF (readable_bytes LIKE "*b")
  {
    INTEGER64 value := ToInteger64(Left(readable_bytes, Length(readable_bytes) - (factor > 1 ? 2 : 1)), -1);
    IF (value >= 0)
      RETURN value * factor;
  }
  RETURN -1;
}

PUBLIC BOOLEAN FUNCTION IsOpenSearchIndexPresent(INTEGER indexmgrid, STRING indexname)
{
  //Getting just the index isn't enough. It will already stop 404-ing before you can write..
  RECORD stats := SendRawJSONToElasticsearch(indexmgrid, "GET", indexname || "/_stats", DEFAULT RECORD, [ expectstatus := [200,404] ]);
  RETURN stats.code = 200 AND stats.result._shards.successful >= 1;
}

PUBLIC STRING FUNCTION GetElasticsearchDocumentId(INTEGER indexid, STRING objectid, STRING suffix DEFAULTSTO "")
{
  RETURN EncodeUFS(GetMD5Hash(indexid || (suffix != "" ? "-" || suffix : "") || "/" || objectid));
}

// recursively walk through the query, return the 'userquery' values from all 'user' queries
PUBLIC STRING ARRAY FUNCTION ExtractUserQueries(RECORD query)
{
  IF (CellExists(query, "query"))
    query := query.query;
  RETURN ExtractUserQueriesRecursive(query);
}

STRING ARRAY FUNCTION ExtractUserQueriesRecursive(RECORD query)
{
  IF (NOT CellExists(query, "_type"))
    RETURN STRING[];
  IF (query._type = "user")
    RETURN STRING[ query.userquery ];
  ELSE IF (query._type = "boolean")
  {
    STRING ARRAY queries;
    FOREVERY (RECORD subquery FROM query.subqueries)
      queries := queries CONCAT ExtractUserQueriesRecursive(subquery.query);
    RETURN queries;
  }
  RETURN STRING[];
}

// input is either a single query, or a record containing a query and filters or an aggregation and possibly a query
PUBLIC RECORD FUNCTION CreateElasticsearchQuery(RECORD input, RECORD indexoptions)
{
  RECORD result :=
      [ query := DEFAULT RECORD
      , aggs := DEFAULT RECORD
      , sort := DEFAULT VARIANT ARRAY
      ];

  IF (CellExists(input, "aggregation"))
  {
    result.aggs := CreateElasticsearchAggregationRecursive(input.aggregation);
    DELETE CELL aggregation FROM input;
  }

  IF (CellExists(input, "ordering"))
  {
    result.sort := CreateElastisearchSort(input.ordering);
    DELETE CELL ordering FROM input;
  }

  RECORD query := input;
  IF (CellExists(query, "query"))
    query := query.query;

  IF (RecordExists(UnpackRecord(query))) // query may be an empty record at this point
  {
    result.query := CreateElasticsearchQueryRecursive(query, indexoptions);

    IF (CellExists(input, "filters"))
    {
      RECORD ARRAY filters;
      FOREVERY (RECORD filter FROM input.filters)
      {
        BOOLEAN isdatefilter := TYPEID(filter.lowerterm) = TYPEID(DATETIME);
        RECORD range := DEFAULT RECORD;
        IF (NOT IsDefaultValue(filter.lowerterm))
        {
          IF (filter.includelower)
            INSERT CELL gte := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
          ELSE
            INSERT CELL gt := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
        }
        IF (NOT IsDefaultValue(filter.upperterm))
        {
          IF (filter.includeupper)
            INSERT CELL lte := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
          ELSE
            INSERT CELL lt := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
        }
        INSERT [ range := CellInsert(DEFAULT RECORD, filter.field, range) ] INTO filters AT END;
      }
      IF (Length(filters) > 0)
        result.query := AddElasticsearchQueryFilters(result.query, filters, FALSE);
    }
  }

  IF (NOT RecordExists(result.query))
    DELETE CELL query FROM result;
  IF (NOT RecordExists(result.aggs))
    DELETE CELL aggs FROM result;
  IF (Length(result.sort) = 0)
    DELETE CELL sort FROM result;
  RETURN result;
}

PUBLIC RECORD FUNCTION AddElasticsearchQueryFilters(RECORD query, RECORD ARRAY filters, BOOLEAN not_filter)
{
  IF (RecordExists(query) AND NOT CellExists(query, "bool"))
    query := [ bool := [ must := [ RECORD(query) ] ] ];

  IF (not_filter)
  {
    IF (RecordExists(query))
    {
      IF(NOT CellExists(query.bool, "must_not"))
        INSERT CELL must_not := DEFAULT RECORD ARRAY INTO query.bool;
      query.bool.must_not := query.bool.must_not CONCAT filters;
    }
    ELSE
    {
      query := [ bool := [ must_not := filters ]];
    }
  }
  ELSE
  {
    /* if we receive a  query: bool: should:  query
       and add a filter...
       opensearch will start returning results matching that filter even if they don't match the should!
       but the 'should' is there to support OR queries

       this broke restrict_url queries. so explicitly wrap the existing should in a must - don't add a filter on the same level */
    IF(RecordExists(query))
    {
      query := [ bool := [ must := [ RECORD(query) ]
                         , filter := filters
                         ]
               ];
    }
    ELSE
    {
      query := [ bool := [ filter := filters ]];
    }
  }

  RETURN query;
}

RECORD FUNCTION LookupFieldInMapping(RECORD ARRAY expectedmapping, STRING fieldname)
{
  RECORD field;
  FOREVERY(STRING tok FROM Tokenize(fieldname,'.'))
  {
    field := SELECT * FROM expectedmapping WHERE name = tok;
    IF(NOT RecordExists(field))
    {
      field := SELECT * FROM expectedmapping WHERE tok LIKE name;
      IF(RecordExists(field))
        THROW NEW Exception(`Field '${fieldname}' is not indexed because it's only matched by wildcards '${field.name}'`);
    }

    IF(NOT RecordExists(field))
      THROW NEW Exception(`No such field '${fieldname}'`);

    expectedmapping := field.properties;
  }
  RETURN field;
}

//ADDME: Take field mapping into account (e.g. whether to use a match (text) or term (keyword) query)
RECORD FUNCTION CreateElasticsearchQueryRecursive(RECORD query, RECORD indexoptions)
{
  IF (NOT CellExists(query, "_type"))
    THROW NEW Exception(`Invalid query record: ${AnyToString(query, "tree")}`);

  RECORD result;
  SWITCH (query._type)
  {
    CASE "all"
    {
      result := [ match_all := CELL[] ];
    }
    CASE "nothing"
    {
      RETURN DEFAULT RECORD;
    }
    CASE "boolean"
    {
      RECORD booleanquery;
      RECORD ARRAY queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query, indexoptions)
            FROM query.subqueries
           WHERE required;
      IF (Length(queries) > 0)
        INSERT CELL must := queries INTO booleanquery;
      queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query, indexoptions)
            FROM query.subqueries
           WHERE prohibited;
      IF (Length(queries) > 0)
        INSERT CELL must_not := queries INTO booleanquery;
      queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query, indexoptions)
            FROM query.subqueries
           WHERE NOT required AND NOT prohibited;
      IF (Length(queries) > 0)
        INSERT CELL should := queries INTO booleanquery;

      IF (RecordExists(booleanquery))
        result := [ bool := booleanquery ];
    }
    CASE "term"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
      result :=
          [ bool :=
              [ should :=
                  [ [ match := CellInsert(DEFAULT RECORD, query.field, [ query := term, analyzer := "consilio_analyzer" ]) ]
                  , [ match := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", [ query := term, analyzer := "consilio_original" ]) ]
                  ]
              ]
          ];
    }
    CASE "match"
    {
      IF(RecordExists(indexoptions))
      {
        RECORD ARRAY fields := SELECT AS RECORD ARRAY LookupFieldInMapping(indexoptions.expectedmapping, field) FROM ToRecordArray(query.fields,'field');
      }

      IF (Length(query.fields) = 1)
        result :=
            [ match := CellInsert(DEFAULT RECORD, query.fields[0], query.text) ];
      ELSE IF (Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result :=
            [ multi_match :=
                [ query := query.text
                , type := "best_fields"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
      }
    }
    CASE "literal"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
      result :=
          [ bool :=
              [ should :=
                  [ [ term := CellInsert(DEFAULT RECORD, query.field, term) ]
                  , [ term := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", term) ]
                  ]
              ]
          ];
    }
    CASE "phrase"
    {
      IF (CellExists(query, "fields") AND Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result :=
            [ multi_match :=
                [ query := Detokenize(query.words, " ")
                , type := "phrase"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
        IF (query.slop != 0)
          INSERT CELL slop := query.slop INTO result.multi_match;
      }
      ELSE
      {
        // This is a multi-field phrase query with one field
        IF (CellExists(query, "fields"))
        {
          INSERT CELL field := query.fields[0] INTO query;
          IF (Length(query.boosts) > 0)
            query.boost := query.boost * query.boosts[0];
        }
        result :=
            [ match_phrase := CellInsert(DEFAULT RECORD, query.field, Detokenize(query.words, " ")) ];
        IF (query.slop != 0)
        {
          // Convert [ match_phrase := [ my_field := "my_value" ] ] into
          // [ match_phrase := [ my_field := [ query := "my_value", slop := my_slop ] ] ]
          RECORD slop_query :=
              [ query := GetCell(result.match_phrase, query.field)
              , slop := query.slop
              ];
          result.match_phrase := CellInsert(CellDelete(result.match_phrase, query.field), query.field, slop_query);
        }
      }
    }
    CASE "date", "range"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := "", lowerterm := "", upperterm := "";
      IF (query.matchtype IN [ "<", "<=", ">=", ">" ])
      {
        term := query.term;
        IF (TypeID(term) = TypeID(MONEY))
          term := __HS_GetRawMoney(term);
      }
      ELSE IF (query.matchtype IN [ "[]", "{]", "[}", "{}" ])
      {
        lowerterm := query.lowerterm;
        IF (TypeID(lowerterm) = TypeID(MONEY))
          lowerterm := __HS_GetRawMoney(lowerterm);
        upperterm := query.upperterm;
        IF (TypeID(upperterm) = TypeID(MONEY))
          upperterm := __HS_GetRawMoney(upperterm);
      }

      RECORD rangequery;
      SWITCH (query.matchtype)
      {
        CASE "<"  { rangequery := [ lt := term ]; }
        CASE "<=" { rangequery := [ lte := term ]; }
        CASE ">=" { rangequery := [ gte := term ]; }
        CASE ">"  { rangequery := [ gt := term ]; }
        CASE "[]" { rangequery := [ gte := lowerterm, lte := upperterm ]; }
        CASE "{]" { rangequery := [ gt := lowerterm, lte := upperterm ]; }
        CASE "[}" { rangequery := [ gte := lowerterm, lt := upperterm ]; }
        CASE "{}" { rangequery := [ gt := lowerterm, lt := upperterm ]; }
      }
      IF (query.boost != 1)
        INSERT CELL boost := query.boost INTO rangequery;

      // Return result directly, as we've already applied boost factor
      RETURN
          [ range := CellInsert(DEFAULT RECORD, query.field, rangequery) ];
    }
    CASE "exists"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      RETURN [ exists := [ field := query.field ] ];
    }
    CASE "user"
    {
      //older users may not have actually set stemmed_field. TODO queries.whlib does a CellExists so should we merge our enforcing with theirs?
      RECORD ARRAY fields := EnforceStructure([[ stemmed_field := FALSE ]], query.defaultfields ?? defaultfields);
      RETURN
          [ simple_query_string :=
              [ query := query.userquery
              , fields := (SELECT AS STRING ARRAY field || (CellExists(fields, "boost") ? FormatBoost(boost) : "") FROM fields) CONCAT (SELECT AS STRING ARRAY field || ".consilio_original" FROM fields WHERE stemmed_field)
              , default_operator := query.querymode
              , analyzer := query.synonyms ? "consilio_search" : "consilio_analyzer"
              ]
          ];
    }
    CASE "opensearch"
    {
      RETURN query.rawquery;
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown query type '" || query._type || "'");
    }
  }
  IF (query.boost != 1)
  {
    result :=
        [ function_score :=
            [ boost := query.boost
            , query := result
            ]
        ];
  }
  RETURN result;
}

STRING FUNCTION FormatBoost(FLOAT boost)
{
  IF (boost = 1)
    RETURN "";
  STRING formatted := FormatFloat(boost * 100000, 0);
  formatted := Left(formatted, Length(formatted) - 5) || "." || Substring(formatted, Length(formatted) - 5);
  WHILE (Right(formatted, 1) = "0")
    formatted := Left(formatted, Length(formatted) - 1);
  IF (Right(formatted, 1) = ".")
    formatted := Left(formatted, Length(formatted) - 1);
  IF (Left(formatted, 1) = ".")
    formatted := "0" || formatted;
  RETURN "^" || formatted;
}

VARIANT ARRAY FUNCTION CreateElastisearchSort(RECORD ARRAY ordering)
{
  VARIANT ARRAY sort;
  IF (RecordExists(ordering))
  {
    // The 'sort' field is an array of strings and objects
    FOREVERY (RECORD orderfield FROM ordering)
    {
      IF (CellExists(orderfield, "orderdesc"))
      {
        IF (CellExists(orderfield, "ordermode"))
        {
          // When both orderdesc and ordermode are given, insert an object with an object property
          // { "myfield": { "order": "asc", "mode": "min" } }
          INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ "order" := orderfield.orderdesc ? "desc" : "asc", "mode" := orderfield.ordermode ]) INTO sort AT END;
        }
        ELSE
        {
          // When only orderdesc is given, insert on object with a string property
          // { "myfield": "asc" }
          INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, orderfield.orderdesc ? "desc" : "asc") INTO sort AT END;
        }
      }
      ELSE IF (CellExists(orderfield, "ordermode"))
      {
        // When only ordermode is given, insert an object with an object property
        // { "myfield": { "mode": "min" } }
        INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ mode := orderfield.ordermode ]) INTO sort AT END;
      }
      ELSE
      {
        // When only the field is given, insert the field name
        // "myfield"
        INSERT orderfield.orderby INTO sort AT END;
      }
    }
  }
  RETURN sort;
}

RECORD FUNCTION CreateElasticsearchAggregationRecursive(RECORD aggregation)
{
  IF (NOT CellExists(aggregation, "_type"))
    THROW NEW Exception(`Invalid aggregation record: ${AnyToString(aggregation, "tree")}`);

  RECORD result;
  SWITCH (aggregation._type)
  {
    CASE "count"
    {
      RETURN DEFAULT RECORD;
    }
    CASE "min", "max", "cardinality"
    {
      result := CellInsert(DEFAULT RECORD, aggregation._type, CELL[ aggregation.field ]);
    }
    CASE "terms"
    {
      result :=
          [ terms :=
              CELL[ aggregation.field
                  , aggregation.size
                  ]
          ];
      IF (aggregation.orderby != "")
        INSERT CELL "order" := CellInsert(DEFAULT RECORD, aggregation.orderby, aggregation.orderdesc ? "desc" : "asc") INTO result.terms;
    }
    CASE "top_hits"
    {
      result :=
          [ top_hits :=
              CELL[ docvalue_fields := STRING[ aggregation.field ]
                  , _source := aggregation.field
                  , aggregation.size
                  ]
          ];
      IF (aggregation.orderby != "")
      {
        INSERT CELL sort := CellInsert(DEFAULT RECORD, aggregation.orderby, [ "order" := aggregation.orderdesc ? "desc" : "asc" ]) INTO result.top_hits;
        INSERT aggregation.orderby INTO result.top_hits.docvalue_fields AT END;
      }
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown aggregation type '" || aggregation._type || "'");
    }
  }

  IF (CellExists(aggregation, "aggregations") AND RecordExists(aggregation.aggregations))
  {
    INSERT CELL aggs := DEFAULT RECORD INTO result;
    FOREVERY (RECORD agg FROM aggregation.aggregations)
      result.aggs := CELL[ ...result.aggs, ...CreateElasticsearchAggregationRecursive(agg.aggregation) ];
  }

  RETURN CellInsert(DEFAULT RECORD, aggregation.name, result);
}

// Encode DEFAULT DATETIMEs as null (DEFAULT RECORD) and MONEYs as INTEGER64s
PUBLIC RECORD FUNCTION FixupElasticsearchDocumentFields(RECORD document)
{
  IF (NOT RecordExists(document))
    RETURN document;
  FOREVERY (RECORD field FROM UnpackRecord(document))
  {
    // Don't index empty fields
    IF (IsDefaultValue(field.value))
      document := CellDelete(document, field.name);
    // Convert DEFAULT DATETIMEs
    ELSE IF (TypeID(field.value) = TypeID(DATETIME ARRAY) AND DEFAULT DATETIME IN field.value)
      document := CellInsert(CellDelete(document, field.name), field.name, ConvertDefaultDatetime(field.value));
    // Convert MONEYs
    ELSE IF (TypeID(field.value) = TypeID(MONEY))
      document := CellInsert(CellDelete(document, field.name), field.name, __HS_GetRawMoney(field.value));
    ELSE IF (TypeID(field.value) = TypeID(MONEY ARRAY))
      document := CellInsert(CellDelete(document, field.name), field.name, SELECT AS INTEGER64 ARRAY __HS_GetRawMoney(value) FROM ToRecordArray(field.value, "value"));
    // Recurse into RECORDs
    ELSE IF (TypeID(field.value) = TypeID(RECORD))
      document := CellUpdate(document, field.name, FixupElasticsearchDocumentFields(field.value));
    // Recurse into RECORD ARRAYs
    ELSE IF (TypeID(field.value) = TypeID(RECORD ARRAY))
      document := CellUpdate(document, field.name, SELECT AS RECORD ARRAY FixupElasticsearchDocumentFields(value) FROM field.value);
  }
  RETURN document;
}

VARIANT ARRAY FUNCTION ConvertDefaultDatetime(DATETIME ARRAY dates)
{
  VARIANT ARRAY converted;
  FOREVERY (DATETIME date FROM dates)
    IF (date != DEFAULT DATETIME)
      INSERT date INTO converted AT END;
    ELSE
      INSERT DEFAULT RECORD INTO converted AT END;
  RETURN converted;
}

PUBLIC VARIANT FUNCTION ReadElasticsearchAggregationResult(RECORD query_aggregation, STRING aggregation_name, RECORD result)
{
  // The 'count' is handled separately, as it's not really an aggregation
  IF (query_aggregation._type = "count")
  {
    IF (CellExists(result, "doc_count"))
      RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result.doc_count);
    THROW NEW Exception(`Unhandled 'count' aggregation: ${AnyToString(CELL[ query_aggregation, result ], "tree")}`);
  }

  RECORD result_aggregation := GetCell(result, aggregation_name);
  SWITCH (query_aggregation._type)
  {
    CASE "min", "max", "cardinality"
    {
      IF (query_aggregation.name LIKE "date_*" OR query_aggregation.name LIKE "*.date_*")
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, MakeDateFromText(result_aggregation.value_as_string));
      ELSE
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result_aggregation.value);
    }
    CASE "terms"
    {
      RECORD ARRAY lineresults;
      IF (Length(result_aggregation.buckets) > 0)
      {
        FOREVERY (RECORD bucket FROM result_aggregation.buckets)
        {
          RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, bucket."key");

          IF (CellExists(query_aggregation, "aggregations"))
          {
            FOREVERY (RECORD agg FROM query_aggregation.aggregations)
            {
              VARIANT aggresult := ReadElasticsearchAggregationResult(agg.aggregation, agg.aggregation.name, bucket);
              IF (IsTypeIDArray(TypeID(aggresult)))
                lineresult := CellInsert(lineresult, agg.aggregation.name, aggresult);
              ELSE
                lineresult := CellInsert(lineresult, agg.aggregation.name, GetCell(aggresult, agg.aggregation.name));
            }
          }

          INSERT lineresult INTO lineresults AT END;
        }
      }
      RETURN lineresults;
    }
    CASE "top_hits"
    {
      RECORD ARRAY lineresults;
      FOREVERY (RECORD hit FROM result_aggregation.hits.hits)
      {
        RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, GetCell(hit.fields, query_aggregation.field)[0]);
        IF (query_aggregation.orderby != "")
        {
          IF (query_aggregation.orderby LIKE "date_*" OR query_aggregation.orderby LIKE "*.date_*")
            lineresult := CellInsert(lineresult, query_aggregation.orderby, MakeDateFromText(GetCell(hit.fields, query_aggregation.orderby)[0]));
          ELSE
            lineresult := CellInsert(lineresult, query_aggregation.orderby, GetCell(hit.fields, query_aggregation.orderby)[0]);
        }
        INSERT lineresult INTO lineresults AT END;
      }
      RETURN lineresults;
    }
  }
  THROW NEW Exception("Unknown aggregation type '" || query_aggregation._type || "'");
}

PUBLIC RECORD ARRAY FUNCTION ReadElasticsearchResults(RECORD ARRAY hits, STRING ARRAY requested_fields, RECORD mapping)
{
  RECORD sourcemapping := CELL[...mapping, DELETE _score, DELETE _summary, DELETE _explanation, DELETE _suggested ];
  RECORD ARRAY results;
  FOREVERY (RECORD hit FROM hits)
  {
    RECORD sourcehit := hit._source;
    RECORD internalfields;

    IF(CellExists(mapping, '_score'))
      INSERT CELL _score := hit._score INTO internalfields;

    IF(CellExists(mapping, '_summary'))
    {
      IF(CellExists(hit, "highlight") AND CellExists(hit.highlight, "body"))
        INSERT CELL _summary := hit.highlight.body[0] INTO internalfields;
      ELSE IF(CellExists(hit._source,"_summary"))
        INSERT CELL _summary := hit._source._summary INTO internalfields;
      ELSE
        INSERT CELL _summary := "" INTO internalfields;
    }

    IF(CellExists(mapping, '_explanation'))
      INSERT CELL _explanation := hit._explanation INTO internalfields;

    //We're not properly recording the mapping for _suggested and it might go away in the future anyway.. so just copy or mock it
    IF(CellExists(mapping, '_suggested'))
      IF(CellExists(sourcehit,'_suggested'))
        INSERT CELL _suggested := sourcehit._suggested INTO internalfields;
      ELSE
        INSERT CELL _suggested := DEFAULT RECORD INTO internalfields;

    IF (CellExists(hit, "highlight"))
      FOREVERY(RECORD mappedfield FROM UnpackRecord(sourcemapping))
      {
        //TODO does this work properly with subfields? or do we need to look for flattened versions
        IF(CellExists(hit.highlight, mappedfield.name))
        {
          sourcehit := CellDelete(sourcehit, mappedfield.name);
          sourcehit := CellInsert(sourcehit, mappedfield.name, GetCell(hit.highlight, mappedfield.name)[0]);
        }
      }

    RECORD singleresult := ParseSingleElasticsearchResult(sourcehit, sourcemapping);
    INSERT CELL[...singleresult, ...internalfields] INTO results AT END;
  }
  RETURN results;
}

PUBLIC RECORD FUNCTION ParseSingleElasticsearchResult(RECORD lineresult, RECORD mapping)
{
  RETURN FixupElasticsearchResultFields(lineresult, mapping);
}

// Elasticsearch doesn't have an array type, but instead accept multiple values for the same field. If there is only one value,
// it's not returned as an array, so this function convert single values into arrays where expected.
// This function also converts INTEGER64s back to MONEYs where necessary
RECORD FUNCTION FixupElasticsearchResultFields(RECORD lineresult, RECORD mapping)
{
  RECORD outputline := CELL[];
  STRING ARRAY seenfields;
  RECORD ARRAY unpackedmapping := UnpackRecord(mapping);

  FOREVERY (RECORD field FROM UnpackRecord(lineresult))
  {
    VARIANT fieldmapping;
    IF (CellExists(mapping, field.name))
    {
      fieldmapping := GetCell(mapping, field.name);
      INSERT field.name INTO seenfields AT END;
    }
    ELSE //Find a matching wildcard (eg ds_* to match ds_text)
    {
      RECORD mywildcard := SELECT * FROM unpackedmapping WHERE field.name LIKE COLUMN name;
      IF(NOT RecordExists(mywildcard))
        CONTINUE;

      fieldmapping := mywildcard.value;
    }

    VARIANT outputfield := field.value;

    //If we expect an array in outputfield but didn't get any, upgrade outputfield to an array
    IF (IsTypeIDArray(TypeID(fieldmapping)) AND NOT IsTypeIDArray(TypeID(outputfield)))
    {
      VARIANT value := GetTypeDefaultArray(TypeID(outputfield));
      INSERT field.value INTO value AT END;
      outputfield := value;
    }

    IF (TypeID(fieldmapping) = TypeID(RECORD))
    {
      outputfield := FixupElasticsearchResultFields(outputfield, fieldmapping);
    }
    ELSE IF (TypeID(fieldmapping) = TypeID(RECORD ARRAY))
    {
      outputfield := SELECT AS RECORD ARRAY FixupElasticsearchResultFields(row, PickFirst(fieldmapping)) FROM outputfield AS row;
    }
    ELSE
    {
      //Non-record fields can often be safely enforced. But we store moneys multiplied by 10^5 so enforce can't fix those for us
      IF (TypeID(outputfield) = TypeID(STRING) AND TypeID(fieldmapping) = TypeID(MONEY))
        outputfield := ReadMoneyValue(outputfield);
      ELSE IF (TypeID(outputfield) = TypeID(STRING ARRAY) AND TypeID(fieldmapping) = TypeID(MONEY ARRAY))
        outputfield := SELECT AS MONEY ARRAY ReadMoneyValue(value) FROM ToRecordArray(outputfield, "value");
      ELSE
        outputfield := EnforceStructure(fieldmapping, outputfield);
    }
    outputline := CellInsert(outputline, field.name, outputfield);
  }

  FOREVERY(RECORD field FROM unpackedmapping)
    IF(SearchSubstring(field.name,'*') = -1 AND field.name NOT IN seenfields)
      outputline := CellInsert(outputline, field.name, field.value); //insert fallback value to complete the output mapping

  RETURN outputline;
}

MONEY FUNCTION ReadMoneyValue(STRING value)
{
  IF (value LIKE "*.0")
    value := Left(value, Length(value) - 2);
  RETURN __HS_SetRawMoney(ToInteger64(value, 0));
}

RECORD FUNCTION DecodeIncomingJSON(BLOB content, STRING type, RECORD options)
{
  RECORD decoded := DecodeJSONBlob(content, DEFAULT RECORD, [ alltostring := TRUE ]);
  SWITCH (type)
  {
    CASE "_search_get"
    {
      RECORD hit :=
          [ _index := ""
          , _id := ""
          , _score := 0f
          , _source := DEFAULT RECORD
          ];
      IF (options.explain)
        INSERT CELL _explanation := DEFAULT RECORD INTO hit;
      decoded := EnforceStructure(
          [ took := 0
          , timed_out := FALSE
          , aggregations := DEFAULT RECORD
          , hits :=
              [ total := [ value := 0, relation := "" ]
              , max_score := 0f
              , hits := [ hit ]
              ]
          ], decoded);
    }
  }
  RETURN decoded;
}

PUBLIC RECORD ARRAY FUNCTION ListOpenSearchIndices(INTEGER indexmanager)
{
  RECORD ARRAY indices := EnforceStructure([[ "uuid" := ""
                                            , "docs.count" := 0
                                            , "pri.store.size" := 0i64
                                            , "index" := ""
                                            , "health" := ""
                                           ]], SendRawJSONToElasticsearch(indexmanager, "GET", '/_cat/indices?format=json&bytes=b', DEFAULT RECORD).result);
  RETURN SELECT uuid
              , docs := indices."docs.count"
              , size := indices."pri.store.size"
              , indexname := indices."index"
              , health
              , status
           FROM indices;
}

PUBLIC RECORD ARRAY FUNCTION ListOpenSearchIndexSuffixes(INTEGER indexmanager, STRING forindexname)
{
  RECORD ARRAY indexlist := ListOpenSearchIndices(indexmanager);

  // Unmanaged indices may have a suffix: <indexname>-<suffix>
  indexlist := SELECT TEMPORARY toks := Tokenize(indexname,'-')
                    , indexname := toks[0]
                    , suffix := Length(toks) > 1 ? toks[1] : ""
                    , health
                    , status
                    , docs
                    , size
                 FROM indexlist
                WHERE indexname LIKE VAR forindexname || "-*"
                      OR indexname = VAR forindexname;

  RETURN SELECT suffix FROM indexlist; //TODO more columns..
}

PUBLIC RECORD FUNCTION GetOpenSearchCurrentMapping(INTEGER indexmanagermapping, STRING indexname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, Elasticsearch only
      ], options);

  RECORD response := SendRawJSONToElasticsearch(indexmanagermapping, "GET", indexname || "/_mapping", DEFAULT RECORD);

  RECORD mappings := GetCell(response.result, indexname).mappings;
  mappings := EnforceStructure([ dynamic_templates := RECORD[]], mappings);
  RETURN mappings;
}

PUBLIC RECORD ARRAY FUNCTION VerifyOpensearchMapping(INTEGER indexmanager, STRING indexname, STRING suffix, RECORD ARRAY expectedmapping)
{
  IF(suffix != "") ABORT("TODO implement suffixs upported");
  RECORD res := GetOpenSearchCurrentMapping(indexmanager, indexname);
  RETURN CompareMappings(res, expectedmapping, "");
}
