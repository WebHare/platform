<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internet/urls.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/queries.whlib";
LOADLIB "mod::consilio/lib/internal/cqmatch.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_queue.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


MACRO UpdateRequestDebugSetting(OBJECT browser)
{
  //the setting can change while running, so always recheck
  IF(IsDebugTagEnabled("consilio:traffic"))
  {
    IF(Length(browser->pvt_traffichooks) = 0)
      LogRPCForWebbrowser("consilio:traffic", "", browser);
  }
  ELSE
  {
    browser->pvt_traffichooks := MACRO PTR[];
  }
}

PUBLIC OBJECTTYPE ElasticsearchException EXTEND Exception
<
  PUBLIC RECORD error;

  MACRO NEW(STRING what, OBJECT browser)
  : Exception(what)
  {
    IF (Objectexists(browser)
        AND (browser->GetHTTPStatusCode() < 200 OR browser->GetHTTPStatusCode() > 200)
        AND browser->mimetype = "application/json")
    {
      RECORD decoded := DecodeJSONBLOB(browser->content);
      IF(CellExists(decoded,'error') AND TypeID(decoded.error) = TypeID(RECORD))
      {
        IF(CellExists(decoded.error,'root_cause'))
        {
          this->error := EnforceStructure([ "index" := ""
                                          , "index_uuid" := ""
                                          , "reason" := ""
                                          , "type" := ""
                                          ], decoded.error.root_cause);

          IF(this->error.reason != "")
            this->what := this->what || " (" || this->error.reason || ")";
          RETURN;
        }
        this->error := EnforceStructure([ "index" := ""
                                        , "index_uuid" := ""
                                        , "reason" := ""
                                        , "type" := ""
                                        ], decoded.error);

        IF(this->error.reason != "")
          this->what := this->what || " (" || this->error.reason || ")";
        RETURN;
      }
    }

    IF(Objectexists(browser) AND browser->GetHTTPStatusCode() != 0)
      this->what := this->what || " (" || browser->GetHTTPStatusText() || ")";
  }
>;


PUBLIC STRING FUNCTION GetElasticsearchAddress()
{
  RETURN `http://${GetEnvironmentVariable("WEBHARE_ELASTICSEARCH_BINDHOST") ?? "127.0.0.1"}:${GetWebhareConfiguration().baseport + whconstant_consilio_osportoffset}`;
}

PUBLIC ASYNC FUNCTION WaitForElasticsearch(INTEGER indexmgrid, DATETIME waituntil)
{
  RETURN AWAIT CreatePromise(PTR ConnectElasticsearch(indexmgrid, #1, #2, waituntil));
}

ASYNC MACRO ConnectElasticsearch(INTEGER indexmgrid, FUNCTION PTR resolve, FUNCTION PTR reject, DATETIME waituntil)
{
  WHILE (GetCurrentDateTime() < waituntil)
  {
    RECORD indexmanager;
    IF (indexmanagerconnections->Has(indexmgrid))
    {
      indexmanager := indexmanagerconnections->Lookup(indexmgrid);
    }
    ELSE
    {
      RECORD indexmgr := SELECT * FROM consilio.indexmanagers WHERE id = indexmgrid;
      IF (NOT RecordExists(indexmgr) OR (NOT IsValidPlainHTTPUrl(indexmgr.address) AND indexmgr.address != "builtin-opensearch"))
      {
        reject(NEW Exception(SearchInvalidArgument));
        RETURN;
      }

      indexmanager := [ address := indexmgr.address
                      , browser := DEFAULT OBJECT
                      , clusterstatus := ""
                      ];

      IF (indexmanager.address = "builtin-opensearch")
        indexmanager.address := GetElasticsearchAddress();

      // Make sure the address doesn't end with a slash
      IF (indexmanager.address LIKE "*/")
        indexmanager.address := Left(indexmanager.address, Length(indexmanager.address) - 1);
    }
    IF (NOT ObjectExists(indexmanager.browser))
    {
      indexmanager.browser := NEW WebBrowser();
      indexmanager.browser->timeout := elastic_timeout * 1000;
    }

    UpdateRequestDebugSetting(indexmanager.browser);
    IF (indexmanager.clusterstatus NOT IN [ "yellow", "green" ])
    {
      FetcherDebug(ConsilioDebugInfo, "Connecting to Elasticsearch");
      // Wait for the cluster to reach 'yellow' status
      IF (NOT indexmanager.browser->SendRawRequest("GET", `${indexmanager.address}/_cluster/health?wait_for_status=yellow&timeout=${elastic_timeout}ms`, [ [ field := "Content-Type", value := "application/json" ] ], DEFAULT BLOB))
      {
        INTEGER statuscode := indexmanager.browser->GetHTTPStatusCode();
        IF (statuscode = 401)
        {
          FetcherDebug(ConsilioDebugInfo, `Authentication error while connecting to Elasticsearch ${indexmgrid} on ${indexmanager.address}`);
          reject(NEW ElasticsearchException(SearchNoAccess, indexmanager.browser));
          RETURN;
        }

        FetcherDebug(ConsilioDebugInfo, `Could not connect to Elasticsearch ${indexmgrid} on ${indexmanager.address}`);
      }
      ELSE
      {
        RECORD status := DecodeJSONBlob(indexmanager.browser->content);
        indexmanager.clusterstatus := status.status;
        indexmanagerconnections->Add(indexmgrid, indexmanager);
        FetcherDebug(ConsilioDebugInfo, `Elasticsearch ${indexmgrid} cluster status: ${indexmanager.clusterstatus}`);
      }
    }
    IF (indexmanager.clusterstatus IN [ "yellow", "green" ])
    {
      resolve(SearchOk);
      RETURN;
    }

    // Wait before trying again
    AWAIT CreateSleepPromise(1000);
  }
  reject(NEW Exception(SearchTimeOutError));
}


PUBLIC RECORD FUNCTION SendToElasticsearch(INTEGER indexmgrid, STRING indexname, STRING command, RECORD request, STRING method, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ throwonfailure := FALSE
                             , timeout := elastic_timeout * 1000
                             ], options);

  STRING url := (indexname != "" ? "/" || EncodeURL(indexname) : "") || command;
  RECORD body := request;
  BOOLEAN ndjson := CellExists(request, "_bulkrequests");
  IF (ndjson)
  {
    // For _bulk requests, convert the request records to NDJSON
    body := [ bulkrequests := request._bulkrequests ];
  }

  RETURN SendRawJSONToElasticsearch(indexmgrid, method, url, body, CELL[ ndjson, options.throwonfailure, options.timeout ]);
}

PUBLIC RECORD FUNCTION SendRawJSONToElasticsearch(INTEGER indexmgrid, STRING method, STRING suburl, RECORD requestbody, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ ndjson := FALSE
                              , throwonfailure := TRUE //if you use the RAW api, you're a new caller and should be expecting THROWs instead of adding new error paths
                              , timeout := elastic_timeout * 1000
                              , enforce := ""
                              ], options,
                              [ enums := [ enforce := [ "", "_search_get" ] ]
                              ]);

  //TODO remove this up when we trust our APIs well enough
  IF(ToUppercase(method) NOT IN ["HEAD","GET"])
  {
    STRING findindexname := suburl LIKE "/*" ? Tokenize(suburl,'/')[1] : suburl;
    RECORD ARRAY attachedindexinfo := SELECT * FROM consilio.catalog_indexmanagers WHERE indexmanager = indexmgrid AND indexname = findindexname;
    IF(Length(attachedindexinfo) = 1 AND attachedindexinfo[0].readonly)
      THROW NEW Exception(`Attempting to write to readonly index '${findindexname}': ${method} ${suburl}`);
  }

  WaitForPromise(WaitForElasticsearch(indexmgrid, AddTimeToDate(options.timeout, GetCurrentDateTime())));

  INTEGER statuscode;
  RECORD indexmanager;
  WHILE (TRUE) // Repeat until succesfully sent
  {
    // If WaitForElasticsearch returned SearchOk, the indexmanager is present in indexmanagerconnections
    indexmanager := indexmanagerconnections->Lookup(indexmgrid);
    IF (NOT ObjectExists(indexmanager.browser))
    {
      IF (running_in_fetcher AND print_defer_connection)
        Print("Defer:connection\n");
      IF(options.throwonfailure)
        THROW NEW ElasticsearchException("Connection failed", DEFAULT OBJECT);
      RETURN [ status := SearchConnectError ];
    }

    STRING url := indexmanager.address || (suburl LIKE "/*" ? "" : "/") || suburl;
    BLOB body;
    IF (options.ndjson)
    {
      // For _bulk requests, convert the request records to NDJSON
      body := StringToBlob(Detokenize((SELECT AS STRING ARRAY EncodeJSON(bulkrequests) FROM requestbody.bulkrequests), "\n") || "\n");
    }
    ELSE IF (RecordExists(requestbody))
    {
      // Other requests are just JSON-encoded
      body := EncodeJSONBlob(requestbody);
    }
    RECORD ARRAY headers;
    IF (Length(body) > 0)
      INSERT [ field := "Content-Type", value := options.ndjson ? "application/x-ndjson" : "application/json" ] INTO headers AT END;

    UpdateRequestDebugSetting(indexmanager.browser);
    indexmanager.browser->timeout := options.timeout;
    BOOLEAN success := indexmanager.browser->SendRawRequest(method, url, headers, body);

    statuscode := indexmanager.browser->GetHTTPStatusCode();
    IF (NOT success)
    {
      IF (indexmanager.browser->GetSocketError() = -9) // timeout
      {
        FetcherDebug(ConsilioDebugAll, "Connection probably timed out, trying to reconnect...");
        WaitForPromise(WaitForElasticsearch(indexmgrid, AddTimeToDate(options.timeout, GetCurrentDateTime())));
        FetcherDebug(ConsilioDebugAll, "Reconnected, trying request again");
        // Don't break, try to send request again with new connection
      }
      ELSE
      {
        // Got an unexpected code, but we'll let it slide
        OBJECT exc := NEW ElasticsearchException("Unexpected response code " || statuscode, indexmanager.browser);
        IF(options.throwonfailure)
          THROW exc;
        FetcherDebug(ConsilioDebugInfo, exc->what);
        BREAK;
      }
    }
    ELSE
    {
      // Got 2xx response code, everything is alright
      BREAK;
    }
  }

  VARIANT decoded := DEFAULT RECORD;
  IF (ToLowercase(indexmanager.browser->contenttype) LIKE "application/json*")
  {
    IF (options.enforce != "")
      decoded := DecodeIncomingJSON(indexmanager.browser->content, options.enforce);
    ELSE
      decoded := DecodeJSONBlob(indexmanager.browser->content);
  }

  RETURN
      [ status  := statuscode = 404 ? SearchIndexNotFound
                 : statuscode = 401 ? SearchNoAccess
                 : statuscode < 200 OR statuscode > 299 ? SearchHTTPError
                 : SearchOk
      , code    := indexmanager.browser->GetSocketError() ?? statuscode
      , content := indexmanager.browser->content
      , headers := indexmanager.browser->responseheaders
      , result  := decoded
      ];
}

PUBLIC RECORD FUNCTION GetElasticsearchStatus(INTEGER indexmgrid)
{
  RECORD result :=
      [ status := SearchOk
      , msg := DEFAULT STRING ARRAY
      ];

  // Get file system status (containing total and available disk space)
  RECORD fs_stats := SendToElasticsearch(indexmgrid, "", "/_nodes/stats/fs", DEFAULT RECORD, "GET");
  IF (fs_stats.status != SearchOk)
    RETURN CELL[ ...result, status := fs_stats.status ];

  // Get cluster settings (containing disk thresholds)
  RECORD settings := GetElasticsearchSettings(indexmgrid, TRUE);
  IF (NOT RecordExists(settings))
    RETURN CELL[ ...result, status := SearchHTTPError ];

  // The nodes are named; we'll just use the first (and, at least for now, only) node
  RECORD node := UnpackRecord(fs_stats.result.nodes)[0].value;
  // Disk sizes are returned as floats, presumably to support disk sizes > 2^63 bytes. We'll cross that bridge when we get
  // there...
  INTEGER64 available_bytes := INTEGER64(node.fs.total.available_in_bytes);
  INTEGER64 total_bytes := INTEGER64(node.fs.total.total_in_bytes);

  INSERT `disk.available=${available_bytes}` INTO result.msg AT END;
  INSERT `disk.total=${total_bytes}` INTO result.msg AT END;

  // Read cluster disk settings
  IF (settings."cluster.routing.allocation.disk.threshold_enabled" != "false")
  {
    INTEGER64 low_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.low", total_bytes);
    INTEGER64 high_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.high", total_bytes);
    INTEGER64 flood_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.flood_stage", total_bytes);
    IF (available_bytes < flood_bytes AND CellExists(settings,"cluster.routing.allocation.disk.watermark.flood"))
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=flood=${settings."cluster.routing.allocation.disk.watermark.flood"}` INTO result.msg AT END;
    }
    ELSE IF (available_bytes < high_bytes)
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=high=${settings."cluster.routing.allocation.disk.watermark.high"}` INTO result.msg AT END;
    }
    ELSE IF (available_bytes < low_bytes)
    {
      INSERT `indexstatus=0` INTO result.msg AT END;
      INSERT `disk.watermark=low=${settings."cluster.routing.allocation.disk.watermark.low"}` INTO result.msg AT END;
    }
    ELSE
    {
      INSERT `indexstatus=1` INTO result.msg AT END;
      INSERT "disk.watermark=ok" INTO result.msg AT END;
    }
  }
  ELSE
  {
    INSERT `indexstatus=1` INTO result.msg AT END;
    INSERT "disk.watermark=false" INTO result.msg AT END;
  }

  RETURN result;
}

PUBLIC RECORD FUNCTION GetElasticsearchSettings(INTEGER indexmgrid, BOOLEAN include_defaults, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ timeout := elastic_timeout * 1000 ], options);
  STRING command := "/_cluster/settings?flat_settings=true";
  IF (include_defaults)
    command := command || "&include_defaults=true";

  RECORD settings := SendToElasticsearch(indexmgrid, "", command, DEFAULT RECORD, "GET", options);
  IF (settings.status != SearchOk)
    RETURN DEFAULT RECORD;

  /*
    https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html#_order_of_precedence

    The order of precedence for cluster settings is:

    1. transient cluster settings
    2. persistent cluster settings
    3. settings in the elasticsearch.yml configuration file.
  */
  IF (include_defaults)
    RETURN CELL
      [ ...settings.result.defaults
      , ...settings.result.persistent
      , ...settings.result.transient
      ];
  RETURN CELL
    [ ...settings.result.persistent
    , ...settings.result.transient
    ];
}

// To set low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := "85%" ]
// To clear low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := DEFAULT RECORD ] (encoded as "null")
PUBLIC RECORD FUNCTION SetElasticsearchSettings(INTEGER indexmgrid, RECORD settings, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ transient := FALSE ], options);
  RECORD request;
  IF (options.transient)
    request := [ transient := settings ];
  ELSE
    request := [ persistent := settings ];
  RETURN SendToElasticsearch(indexmgrid, "", "/_cluster/settings", request, "PUT");
}

INTEGER64 FUNCTION ReadWatermark(STRING input, INTEGER64 total_bytes)
{
  IF (input LIKE "*%")
  {
    // The percentage of the disk that is used
    INTEGER percentage := ToInteger(Left(input, Length(input) - 1), 0);
    IF (percentage <= 0)
      RETURN -1;
    // Note: this will only work with disk sizes < 2^63 / 100
    RETURN total_bytes - (total_bytes * percentage / 100);
  }
  ELSE
  {
    // The absolute number of free bytes
    INTEGER64 bytes := ParseElasticsearchBytes(input);
    IF (bytes < 0)
      RETURN -1;
    RETURN bytes;
  }
}

PUBLIC INTEGER64 FUNCTION ParseElasticsearchBytes(STRING readable_bytes)
{
  readable_bytes := ToLowercase(readable_bytes);
  INTEGER factor := 1;
  IF (readable_bytes LIKE "*kb")
    factor := 1024;
  ELSE IF (readable_bytes LIKE "*mb")
    factor := 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*gb")
    factor := 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*tb")
    factor := 1024 * 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*pb")
    factor := 1024 * 1024 * 1024 * 1024 * 1024;
  IF (readable_bytes LIKE "*b")
  {
    INTEGER64 value := ToInteger64(Left(readable_bytes, Length(readable_bytes) - (factor > 1 ? 2 : 1)), -1);
    IF (value >= 0)
      RETURN value * factor;
  }
  RETURN -1;
}

PUBLIC BOOLEAN FUNCTION ElasticsearchMappingExists(INTEGER indexmgrid, INTEGER indexid, STRING type)
{
  RETURN GetAdhocCached(CELL[ type ], PTR ElasticsearchMappingExists_Uncached(indexmgrid, indexid, type));
}

RECORD FUNCTION ElasticsearchMappingExists_Uncached(INTEGER indexmgrid, INTEGER indexid, STRING type)
{
  RECORD response := SendToElasticsearch(indexmgrid, ToString(indexid), "/_mapping/" || type, DEFAULT RECORD, "GET");
  RETURN [ value := response.status = SearchOk
         , eventmasks := [ "consilio:contentsourcestatus" ]
         ];
}

PUBLIC STRING FUNCTION GetElasticsearchDocumentId(INTEGER indexid, STRING objectid, STRING suffix DEFAULTSTO "")
{
  RETURN EncodeUFS(GetMD5Hash(indexid || (suffix != "" ? "-" || suffix : "") || "/" || objectid));
}

// input is either a single query, or a record containing a query and filters or an aggregation and possibly a query
PUBLIC RECORD FUNCTION CreateElasticsearchQuery(RECORD input)
{
  IF (CellExists(input, "aggregation"))
  {
    RECORD result :=
        [ aggs := CreateElasticsearchAggregationRecursive(input.aggregation)
        ];
    // The 'count' aggregation isn't sent to Elasticsearch as an actual aggregation
    IF (NOT RecordExists(result.aggs))
      DELETE CELL aggs FROM result;

    IF (CellExists(input, "query"))
      INSERT CELL query := CreateElasticsearchQueryRecursive(input.query) INTO result;

    RETURN result;
  }

  RECORD result :=
      [ query := DEFAULT RECORD
      ];

  RECORD query := input;
  IF (CellExists(query, "query"))
    query := query.query;

  IF (CellExists(input, "ordering"))
  {
    IF (RecordExists(input.ordering))
    {
      // The 'sort' field is an array of strings and objects
      VARIANT ARRAY sort;
      FOREVERY (RECORD orderfield FROM input.ordering)
      {
        IF (CellExists(orderfield, "orderdesc"))
        {
          IF (CellExists(orderfield, "ordermode"))
          {
            // When both orderdesc and ordermode are given, insert an object with an object property
            // { "myfield": { "order": "asc", "mode": "min" } }
            INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ "order" := orderfield.orderdesc ? "desc" : "asc", "mode" := orderfield.ordermode ]) INTO sort AT END;
          }
          ELSE
          {
            // When only orderdesc is given, insert on object with a string property
            // { "myfield": "asc" }
            INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, orderfield.orderdesc ? "desc" : "asc") INTO sort AT END;
          }
        }
        ELSE IF (CellExists(orderfield, "ordermode"))
        {
          // When only ordermode is given, insert an object with an object property
          // { "myfield": { "mode": "min" } }
          INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ mode := orderfield.ordermode ]) INTO sort AT END;
        }
        ELSE
        {
          // When only the field is given, insert the field name
          // "myfield"
          INSERT orderfield.orderby INTO sort AT END;
        }
      }
      result := CELL[ ...result, sort ];
    }
    DELETE CELL ordering FROM input;
  }

  result.query := CreateElasticsearchQueryRecursive(query);

  IF (CellExists(input, "filters"))
  {
    RECORD ARRAY filters;
    FOREVERY (RECORD filter FROM input.filters)
    {
      BOOLEAN isdatefilter := filter.field LIKE "date_*" OR filter.field LIKE "*.date_*";
      RECORD range := DEFAULT RECORD;
      IF (NOT IsDefaultValue(filter.lowerterm))
      {
        IF (filter.includelower)
          INSERT CELL gte := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
        ELSE
          INSERT CELL gt := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
      }
      IF (NOT IsDefaultValue(filter.upperterm))
      {
        IF (filter.includeupper)
          INSERT CELL lte := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
        ELSE
          INSERT CELL lt := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
      }
      INSERT [ range := CellInsert(DEFAULT RECORD, filter.field, range) ] INTO filters AT END;
    }
    IF (Length(filters) > 0)
      result.query := AddElasticsearchQueryFilters(result.query, filters, FALSE);
  }
  RETURN result;
}

PUBLIC RECORD FUNCTION AddElasticsearchQueryFilters(RECORD query, RECORD ARRAY filters, BOOLEAN not_filter)
{
  IF (NOT RecordExists(query))
    query := [ bool := DEFAULT RECORD ];
  ELSE IF (NOT CellExists(query, "bool"))
    query := [ bool := [ must := [ RECORD(query) ] ] ];

  IF (not_filter)
  {
    IF (NOT CellExists(query.bool, "must_not"))
      INSERT CELL must_not := DEFAULT RECORD ARRAY INTO query.bool;
    query.bool.must_not := query.bool.must_not CONCAT filters;
  }
  ELSE
  {
    /* if we receive a  query: bool: should:  query
       and add a filter...
       opensearch will start returning results matching that filter even if they don't match the should!
       but the 'should' is there to support OR queries

       this broke restrict_url queries. so explicitly wrap the existing should in a must - don't add a filter on the same level */

    query := [ bool := [ must := [ RECORD(query) ]
                       , filter := filters
                       ]
             ];
  }

  RETURN query;
}

//ADDME: Take field mapping into account (e.g. whether to use a match (text) or term (keyword) query)
RECORD FUNCTION CreateElasticsearchQueryRecursive(RECORD query)
{
  IF (NOT CellExists(query, "_type"))
    THROW NEW Exception(`Invalid query record: ${AnyToString(query, "tree")}`);
  IF (query._type = "__delayed_cqmatch") //delayed cqmatch until we know the actual index type
    query := __CQMatch(query.__delayed_cqmatch.field, query.__delayed_cqmatch.matchtype, query.__delayed_cqmatch.value, CELL[...query.__delayed_cqmatch.options, __opensearch := TRUE ]);

  RECORD result;
  SWITCH (query._type)
  {
    CASE "all"
    {
      result := [ match_all := CELL[] ];
    }
    CASE "nothing"
    {
      RETURN DEFAULT RECORD;
    }
    CASE "boolean"
    {
      RECORD booleanquery;
      RECORD ARRAY queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query)
            FROM query.subqueries
           WHERE required;
      IF (Length(queries) > 0)
        INSERT CELL must := queries INTO booleanquery;
      queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query)
            FROM query.subqueries
           WHERE prohibited;
      IF (Length(queries) > 0)
        INSERT CELL must_not := queries INTO booleanquery;
      queries :=
          SELECT AS RECORD ARRAY CreateElasticsearchQueryRecursive(subqueries.query)
            FROM query.subqueries
           WHERE NOT required AND NOT prohibited;
      IF (Length(queries) > 0)
        INSERT CELL should := queries INTO booleanquery;

      IF (RecordExists(booleanquery))
        result := [ bool := booleanquery ];
    }
    CASE "term"
    {
      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
      result :=
          [ bool :=
              [ should :=
                  [ [ match := CellInsert(DEFAULT RECORD, query.field, [ query := term, analyzer := "consilio_analyzer" ]) ]
                  , [ match := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", [ query := term, analyzer := "consilio_original" ]) ]
                   //FIXME this is needed to get publisher search  to work but i think we're incorrectly using the analyzer here? - https://gitlab.webhare.com/webharebv/codekloppers/-/issues/550#note_137298
                  , [ match := CellInsert(DEFAULT RECORD, query.field, term) ]
                  ]
              ]
          ];
    }
    CASE "match"
    {
      IF (Length(query.fields) = 1)
        result :=
            [ match := CellInsert(DEFAULT RECORD, query.fields[0], query.text) ];
      ELSE IF (Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY __FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result :=
            [ multi_match :=
                [ query := query.text
                , type := "best_fields"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
      }
    }
    CASE "literal"
    {
      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
      result :=
          [ bool :=
              [ should :=
                  [ [ term := CellInsert(DEFAULT RECORD, query.field, term) ]
                  , [ term := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", term) ]
                  ]
              ]
          ];
    }
    CASE "phrase"
    {
      IF (CellExists(query, "fields") AND Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY __FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result :=
            [ multi_match :=
                [ query := Detokenize(query.words, " ")
                , type := "phrase"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
        IF (query.slop != 0)
          INSERT CELL slop := query.slop INTO result.multi_match;
      }
      ELSE
      {
        // This is a multi-field phrase query with one field
        IF (CellExists(query, "fields"))
        {
          INSERT CELL field := query.fields[0] INTO query;
          IF (Length(query.boosts) > 0)
            query.boost := query.boost * query.boosts[0];
        }
        result :=
            [ match_phrase := CellInsert(DEFAULT RECORD, query.field, Detokenize(query.words, " ")) ];
        IF (query.slop != 0)
        {
          // Convert [ match_phrase := [ my_field := "my_value" ] ] into
          // [ match_phrase := [ my_field := [ query := "my_value", slop := my_slop ] ] ]
          RECORD slop_query :=
              [ query := GetCell(result.match_phrase, query.field)
              , slop := query.slop
              ];
          result.match_phrase := CellInsert(CellDelete(result.match_phrase, query.field), query.field, slop_query);
        }
      }
    }
    CASE "date", "range"
    {
      // Convert MONEYs
      VARIANT term := "", lowerterm := "", upperterm := "";
      IF (query.matchtype IN [ "<", "<=", ">=", ">" ])
      {
        term := query.term;
        IF (TypeID(term) = TypeID(MONEY))
          term := __HS_GetRawMoney(term);
      }
      ELSE IF (query.matchtype IN [ "[]", "{]", "[}", "{}" ])
      {
        lowerterm := query.lowerterm;
        IF (TypeID(lowerterm) = TypeID(MONEY))
          lowerterm := __HS_GetRawMoney(lowerterm);
        upperterm := query.upperterm;
        IF (TypeID(upperterm) = TypeID(MONEY))
          upperterm := __HS_GetRawMoney(upperterm);
      }

      RECORD rangequery;
      SWITCH (query.matchtype)
      {
        CASE "<"  { rangequery := [ lt := term ]; }
        CASE "<=" { rangequery := [ lte := term ]; }
        CASE ">=" { rangequery := [ gte := term ]; }
        CASE ">"  { rangequery := [ gt := term ]; }
        CASE "[]" { rangequery := [ gte := lowerterm, lte := upperterm ]; }
        CASE "{]" { rangequery := [ gt := lowerterm, lte := upperterm ]; }
        CASE "[}" { rangequery := [ gte := lowerterm, lt := upperterm ]; }
        CASE "{}" { rangequery := [ gt := lowerterm, lt := upperterm ]; }
      }
      IF (query.boost != 1)
        INSERT CELL boost := query.boost INTO rangequery;

      // Return result directly, as we've already applied boost factor
      RETURN
          [ range := CellInsert(DEFAULT RECORD, query.field, rangequery) ];
    }
    CASE "exists"
    {
      RETURN [ exists := [ field := query.field ] ];
    }
    CASE "user"
    {
      //older users may not have actually set stemmed_field. TODO queries.whlib does a CellExists so should we merge our enforcing with theirs?
      RECORD ARRAY fields := EnforceStructure([[ stemmed_field := FALSE ]], query.defaultfields ?? defaultfields);
      RETURN
          [ simple_query_string :=
              [ query := query.userquery
              , fields := (SELECT AS STRING ARRAY field || __FormatBoost(boost) FROM fields) CONCAT (SELECT AS STRING ARRAY field || ".consilio_original" || __FormatBoost(boost) FROM fields WHERE stemmed_field)
              , default_operator := query.defaultrequire = require_required ? "AND" : "OR"
              , analyzer := query.synonyms ? "consilio_search" : "consilio_analyzer"
              ]
          ];
    }
    CASE "opensearch"
    {
      RETURN query.rawquery;
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown query type '" || query._type || "'");
    }
  }
  IF (query.boost != 1)
  {
    result :=
        [ function_score :=
            [ boost := query.boost
            , query := result
            ]
        ];
  }
  RETURN result;
}

RECORD FUNCTION CreateElasticsearchAggregationRecursive(RECORD aggregation)
{
  IF (NOT CellExists(aggregation, "_type"))
    THROW NEW Exception(`Invalid aggregation record: ${AnyToString(aggregation, "tree")}`);

  RECORD result;
  SWITCH (aggregation._type)
  {
    CASE "count"
    {
      RETURN DEFAULT RECORD;
    }
    CASE "min", "max"
    {
      result := CellInsert(DEFAULT RECORD, aggregation._type, CELL[ aggregation.field ]);
    }
    CASE "terms"
    {
      result :=
          [ terms :=
              CELL[ aggregation.field
                  , aggregation.size
                  ]
          ];
      IF (aggregation.orderby != "")
        INSERT CELL "order" := CellInsert(DEFAULT RECORD, aggregation.orderby, aggregation.orderdesc ? "desc" : "asc") INTO result.terms;
    }
    CASE "top_hits"
    {
      result :=
          [ top_hits :=
              CELL[ docvalue_fields := STRING[ aggregation.field ]
                  , _source := aggregation.field
                  , aggregation.size
                  ]
          ];
      IF (aggregation.orderby != "")
      {
        INSERT CELL sort := CellInsert(DEFAULT RECORD, aggregation.orderby, [ "order" := aggregation.orderdesc ? "desc" : "asc" ]) INTO result.top_hits;
        INSERT aggregation.orderby INTO result.top_hits.docvalue_fields AT END;
      }
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown aggregation type '" || aggregation._type || "'");
    }
  }

  IF (CellExists(aggregation, "aggregations") AND RecordExists(aggregation.aggregations))
  {
    INSERT CELL aggs := DEFAULT RECORD INTO result;
    FOREVERY (RECORD agg FROM aggregation.aggregations)
      result.aggs := CELL[ ...result.aggs, ...CreateElasticsearchAggregationRecursive(agg.aggregation) ];
  }

  RETURN CellInsert(DEFAULT RECORD, aggregation.name, result);
}

// Encode DEFAULT DATETIMEs as null (DEFAULT RECORD) and MONEYs as INTEGER64s
PUBLIC RECORD FUNCTION FixupElasticsearchDocumentFields(RECORD document)
{
  IF (NOT RecordExists(document))
    RETURN document;
  FOREVERY (RECORD field FROM UnpackRecord(document))
  {
    // Don't index empty fields
    IF (IsDefaultValue(field.value))
      document := CellDelete(document, field.name);
    // Convert DEFAULT DATETIMEs
    ELSE IF (TypeID(field.value) = TypeID(DATETIME ARRAY) AND DEFAULT DATETIME IN field.value)
      document := CellInsert(CellDelete(document, field.name), field.name, ConvertDefaultDatetime(field.value));
    // Convert MONEYs
    ELSE IF (TypeID(field.value) = TypeID(MONEY))
      document := CellInsert(CellDelete(document, field.name), field.name, __HS_GetRawMoney(field.value));
    ELSE IF (TypeID(field.value) = TypeID(MONEY ARRAY))
      document := CellInsert(CellDelete(document, field.name), field.name, SELECT AS INTEGER64 ARRAY __HS_GetRawMoney(value) FROM ToRecordArray(field.value, "value"));
    // Recurse into RECORDs
    ELSE IF (TypeID(field.value) = TypeID(RECORD))
      document := CellUpdate(document, field.name, FixupElasticsearchDocumentFields(field.value));
    // Recurse into RECORD ARRAYs
    ELSE IF (TypeID(field.value) = TypeID(RECORD ARRAY))
      document := CellUpdate(document, field.name, SELECT AS RECORD ARRAY FixupElasticsearchDocumentFields(value) FROM field.value);
  }
  RETURN document;
}

VARIANT ARRAY FUNCTION ConvertDefaultDatetime(DATETIME ARRAY dates)
{
  VARIANT ARRAY converted;
  FOREVERY (DATETIME date FROM dates)
    IF (date != DEFAULT DATETIME)
      INSERT date INTO converted AT END;
    ELSE
      INSERT DEFAULT RECORD INTO converted AT END;
  RETURN converted;
}

PUBLIC VARIANT FUNCTION ReadElasticsearchAggregationResult(RECORD query_aggregation, STRING aggregation_name, RECORD result)
{
  // The 'count' is handled separately, as it's not really an aggregation
  IF (query_aggregation._type = "count")
  {
    IF (CellExists(result, "doc_count"))
      RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result.doc_count);
    THROW NEW Exception(`Unhandled 'count' aggregation: ${AnyToString(CELL[ query_aggregation, result ], "tree")}`);
  }

  RECORD result_aggregation := GetCell(result, aggregation_name);
  SWITCH (query_aggregation._type)
  {
    CASE "min", "max"
    {
      IF (query_aggregation.name LIKE "date_*" OR query_aggregation.name LIKE "*.date_*")
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, MakeDateFromText(result_aggregation.value_as_string));
      ELSE
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result_aggregation.value);
    }
    CASE "terms"
    {
      RECORD ARRAY lineresults;
      IF (Length(result_aggregation.buckets) > 0)
      {
        FOREVERY (RECORD bucket FROM result_aggregation.buckets)
        {
          RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, bucket."key");

          IF (CellExists(query_aggregation, "aggregations"))
          {
            FOREVERY (RECORD agg FROM query_aggregation.aggregations)
            {
              VARIANT aggresult := ReadElasticsearchAggregationResult(agg.aggregation, agg.aggregation.name, bucket);
              IF (IsTypeIDArray(TypeID(aggresult)))
                lineresult := CellInsert(lineresult, agg.aggregation.name, aggresult);
              ELSE
                lineresult := CellInsert(lineresult, agg.aggregation.name, GetCell(aggresult, agg.aggregation.name));
            }
          }

          INSERT lineresult INTO lineresults AT END;
        }
      }
      RETURN lineresults;
    }
    CASE "top_hits"
    {
      RECORD ARRAY lineresults;
      FOREVERY (RECORD hit FROM result_aggregation.hits.hits)
      {
        RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, GetCell(hit.fields, query_aggregation.field)[0]);
        IF (query_aggregation.orderby != "")
        {
          IF (query_aggregation.orderby LIKE "date_*" OR query_aggregation.orderby LIKE "*.date_*")
            lineresult := CellInsert(lineresult, query_aggregation.orderby, MakeDateFromText(GetCell(hit.fields, query_aggregation.orderby)[0]));
          ELSE
            lineresult := CellInsert(lineresult, query_aggregation.orderby, GetCell(hit.fields, query_aggregation.orderby)[0]);
        }
        INSERT lineresult INTO lineresults AT END;
      }
      RETURN lineresults;
    }
  }
  THROW NEW Exception("Unknown aggregation type '" || query_aggregation._type || "'");
}

PUBLIC RECORD ARRAY FUNCTION ReadElasticsearchResults(RECORD ARRAY hits, STRING ARRAY requested_fields, RECORD mapping)
{
  RECORD ARRAY results;
  FOREVERY (RECORD hit FROM hits)
  {
    RECORD lineresult;
    FOREVERY (STRING fld FROM requested_fields)
    {
      IF (fld = "indexid")
        lineresult := CellInsert(lineresult, "indexid", GetAdhocCached(CELL[ hit._index ], PTR GetIndexIdUncached(hit._index)));
      ELSE IF (fld = "_score")
        lineresult := CellInsert(lineresult, "_score", hit._score);
      ELSE IF (fld = "_summary" AND CellExists(hit, "highlight") AND CellExists(hit.highlight, "body"))
        lineresult := CellInsert(lineresult, fld, hit.highlight.body[0]);
      ELSE IF (CellExists(hit, "highlight") AND CellExists(hit.highlight, fld))
        lineresult := CellInsert(lineresult, fld, GetCell(hit.highlight, fld)[0]);
      ELSE
        lineresult := ReadResultField(lineresult, hit._source, fld);
    }

    RECORD singleresult := ParseSingleElasticsearchResult(lineresult, mapping);
    IF (RecordExists(singleresult))
      INSERT singleresult INTO results AT END;
  }
  RETURN results;
}

RECORD FUNCTION GetIndexIdUncached(STRING indexid)
{
  INTEGER value :=
      SELECT AS INTEGER catalogid
        FROM consilio.catalog_indexmanagers
       WHERE indexname != ""
             AND (indexname = indexid OR indexid LIKE indexname || "-*");
  RETURN CELL
      [ value
      , eventmasks := [ "consilio:indiceschanged" ]
      ];
}

RECORD FUNCTION ReadResultField(RECORD lineresult, RECORD hit, STRING fld)
{
  // Check if a record subfield was requested
  STRING subfld;
  IF (NOT CellExists(hit, fld) AND fld LIKE "*.*") //FIXME this is a hack to support the pre-dec-2020 record situation. should we be studying 'mapping' to figure out the real format ?
  {
    subfld := Substring(fld, SearchSubstring(fld, ".") + 1);
    fld := Left(fld, SearchSubstring(fld, "."));
  }
  IF (CellExists(hit, fld))
  {
    IF (subfld != "")
    {
      // Get the current record (array)
      VARIANT value := CellExists(lineresult, fld) ? GetCell(lineresult, fld) : GetTypeDefaultValue(TypeID(GetCell(hit, fld)));
      IF (TypeID(value) = TypeID(RECORD ARRAY))
      {
        // Process each record within the array separately
        FOREVERY (RECORD subhit FROM GetCell(hit, fld))
        {
          // Add a default record if necessary
          IF (Length(value) <= #subhit)
            INSERT DEFAULT RECORD INTO value AT END;
          // Read the subfield result
          value[#subhit] := ReadResultField(value[#subhit], subhit, subfld);
        }
      }
      ELSE
      {
        // Read the subfield result
        value := ReadResultField(value, GetCell(hit, fld), subfld);
      }
      // Replace or add the new value
      lineresult := CellExists(lineresult, fld) ? CellUpdate(lineresult, fld, value) : CellInsert(lineresult, fld, value);
    }
    ELSE
      lineresult := CellInsert(lineresult, fld, GetCell(hit, fld));
  }
  RETURN lineresult;
}

PUBLIC RECORD FUNCTION ParseSingleElasticsearchResult(RECORD lineresult, RECORD mapping)
{
  RETURN EnforceStructure(mapping, FixupElasticsearchResultFields(lineresult, mapping));
}

// Elasticsearch doesn't have an array type, but instead accept multiple values for the same field. If there is only one value,
// it's not returned as an array, so this function convert single values into arrays where expected.
// This function also converts INTEGER64s back to MONEYs where necessary
RECORD FUNCTION FixupElasticsearchResultFields(RECORD lineresult, RECORD mapping)
{
  FOREVERY (RECORD field FROM UnpackRecord(lineresult))
  {
    IF (NOT CellExists(mapping, field.name))
      CONTINUE;
    VARIANT fieldmapping := GetCell(mapping, field.name);
    BOOLEAN valuechanged;
    IF (IsTypeIDArray(TypeID(fieldmapping)) AND NOT IsTypeIDArray(TypeID(field.value)))
    {
      VARIANT value := GetTypeDefaultArray(TypeID(field.value));
      INSERT field.value INTO value AT END;
      field := CELL[ ...field, value ];
      valuechanged := TRUE;
    }
    IF (TypeID(field.value) = TypeID(RECORD))
      field.value := FixupElasticsearchResultFields(field.value, fieldmapping);
    ELSE IF (TypeID(field.value) = TypeID(RECORD ARRAY))
      field.value := SELECT AS RECORD ARRAY FixupElasticsearchResultFields(value, PickFirst(fieldmapping)) FROM field.value;
    ELSE IF (TypeID(field.value) = TypeID(STRING) AND TypeID(fieldmapping) = TypeID(MONEY))
      field := CELL[ ...field, value := __HS_SetRawMoney(ToInteger64(field.value, 0)) ];
    ELSE IF (TypeID(field.value) = TypeID(STRING ARRAY) AND TypeID(fieldmapping) = TypeID(MONEY ARRAY))
      field := CELL[ ...field, value := SELECT AS MONEY ARRAY __HS_SetRawMoney(ToInteger64(value, 0)) FROM ToRecordArray(field.value, "value") ];
    ELSE IF (NOT valuechanged)
      CONTINUE;
    lineresult := CellInsert(CellDelete(lineresult, field.name), field.name, field.value);
  }
  RETURN lineresult;
}

RECORD FUNCTION DecodeIncomingJSON(BLOB content, STRING type)
{
  RECORD decoded := DecodeJSONBlob(content, DEFAULT RECORD, [ alltostring := TRUE ]);
  SWITCH (type)
  {
    CASE "_search_get"
    {
      decoded := EnforceStructure(
          [ took := 0
          , timed_out := FALSE
          , hits :=
              [ total := [ value := 0, relation := "" ]
              , max_score := 0f
              , hits :=
                  [ [ _index := ""
                    , _id := ""
                    , _score := 0f
                    , _source := DEFAULT RECORD
                    ]
                  ]
              ]
          ], decoded);
    }
  }
  RETURN decoded;
}

PUBLIC RECORD ARRAY FUNCTION ListOpenSearchIndexSuffixes(INTEGER indexmanager, STRING forindexname)
{
  RECORD response := SendToElasticsearch(indexmanager, "", "/_cat/indices/?format=json&bytes=b", DEFAULT RECORD, "GET", [throwonfailure := TRUE]);
  RECORD ARRAY indexlist := RECORD ARRAY(DecodeJSONBlob(response.content));

  // Unmanaged indices may have a suffix: <indexname>-<suffix>
  indexlist := SELECT TEMPORARY toks := Tokenize(indexlist."index",'-')
                    , indexname := toks[0]
                    , suffix := Length(toks) > 1 ? toks[1] : ""
                    , health
                    , status
                    , docs := ToInteger(indexlist."docs.count", 0)
                    , size := ToInteger(indexlist."pri.store.size", 0)
                 FROM indexlist
                WHERE indexlist."index" LIKE VAR forindexname || "-*"
                      OR indexlist."index" = VAR forindexname;

  RETURN SELECT suffix FROM indexlist; //TODO more columns..
}
