<?wh

LOADLIB "wh::adhoccache.whlib";
LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::float.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::internal/any.whlib";
LOADLIB "wh::internet/fetch.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


CONSTANT RECORD ARRAY defaultfields :=
[ [ field := "title",       boost := 10,  stemmed_field := TRUE ]
, [ field := "keywords",    boost := 50, stemmed_field := FALSE ]
, [ field := "description", boost := 10,  stemmed_field := FALSE ]
, [ field := "body",        boost := 1,  stemmed_field := TRUE ]
];

PUBLIC STATIC OBJECTTYPE SearchUnavailableException EXTEND Exception
<
>;


PUBLIC OBJECTTYPE OpenSearchException EXTEND Exception
<
  PUBLIC RECORD error;

  MACRO NEW(STRING what, OBJECT fetchresponse, STRING text)
  : Exception(what)
  {
    IF (Objectexists(fetchresponse)
        AND (fetchresponse->status < 200 OR fetchresponse->status > 200)
        AND Tokenize(fetchresponse->headers->get("content-type"),';')[0] = "application/json")
    {
      RECORD decoded := DecodeJSON(text);
      IF(CellExists(decoded,'error') AND TypeID(decoded.error) = TypeID(RECORD))
      {
        IF(CellExists(decoded.error,'root_cause'))
        {
          this->error := EnforceStructure([ "index" := ""
                                          , "index_uuid" := ""
                                          , "reason" := ""
                                          , "type" := ""
                                          ], decoded.error.root_cause);

          IF(this->error.reason != "")
            this->what := this->what || " (" || this->error.reason || ")";

          RETURN;
        }
        this->error := EnforceStructure([ "index" := ""
                                        , "index_uuid" := ""
                                        , "reason" := ""
                                        , "type" := ""
                                        ], decoded.error);

        IF(this->error.reason != "")
          this->what := this->what || " (" || this->error.reason || ")";
        RETURN;
      }
    }

    IF(Objectexists(fetchresponse))
      this->what := this->what || " (" || fetchresponse->status || " " || fetchresponse->statustext || ")";
  }
>;


PUBLIC STRING FUNCTION GetBuiltinOpensearchAddress()
{
  RETURN `http://${GetEnvironmentVariable("WEBHARE_OPENSEARCH_BINDHOST") ?? "127.0.0.1"}:${GetWebhareConfiguration().baseport + whconstant_consilio_osportoffset}/`;
}

RECORD FUNCTION GetCacheableIndexMgrDescription(INTEGER id)
{
  RECORD info := (SELECT * FROM consilio.indexmanagers WHERE indexmanagers.id = VAR id);
  RETURN [ value := info
         , ttl := 5 * 1000 //FIXME eventmasks when an indexmangaer is modifiedm then we can increase this TTL a lot!
         ];
}

RECORD FUNCTION DescribeIndexManager(INTEGER id)
{
  RETURN GetAdhocCached(CELL[indexmanager := id], PTR GetCacheableIndexMgrDescription(id));
}

PUBLIC RECORD FUNCTION SendRawJSONToOpenSearch(INTEGER indexmgrid, STRING method, STRING suburl, RECORD requestbody, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions( [ ndjson := FALSE
                              , timeout := ToUppercase(method) IN ["HEAD","GET"] ? opensearch_read_timeout : opensearch_write_timeout
                              , firstconnect_timeout := opensearch_firstconnect_timeout
                              , enforce := ""
                              , expectstatus := [ 200 ]
                              , explain := FALSE
                              , refresh := FALSE
                              ], options,
                              [ enums := [ enforce := [ "", "_search_get" ] ]
                              ]);

  //TODO remove this up when we trust our APIs well enough. Or better: use cached data so we can validate this without SQL overhead
  IF(ToUppercase(method) NOT IN ["HEAD","GET"])
  {
    STRING findindexname := suburl LIKE "/*" ? Tokenize(suburl,'/')[1] : suburl;
    RECORD ARRAY attachedindexinfo := SELECT * FROM consilio.catalog_indexmanagers WHERE indexmanager = indexmgrid AND indexname = findindexname;
    IF(Length(attachedindexinfo) = 1 AND attachedindexinfo[0].readonly)
      THROW NEW Exception(`Attempting to write to readonly index '${findindexname}': ${method} ${suburl}`);
  }
  ELSE IF(RecordExists(requestbody)) //we're assuming this will be a POST search. fetch() will not let us GET with a body
  {
    method := "POST";
  }

  RECORD indexmanager := DescribeIndexManager(indexmgrid);
  STRING url := indexmanager.address = "builtin-opensearch" ? GetBuiltinOpensearchAddress() : indexmanager.address;
  IF(url NOT LIKE "*/")
    url := url || "/";
  IF(suburl LIKE "/*")
    url := url || Substring(suburl,1);
  ELSE
    url := url || suburl;

  IF(options.refresh)
    url := UpdateURLVariables(url, [ refresh := "true" ]);

  RECORD fetchoptions := CELL[ headers := CELL[]
                             , method
                             ];

  RECORD unpacked := UnpackURL(url);
  IF(unpacked.user != "") //fetch doesn't support user/pass in URLs
  {
    INSERT CELL "Authorization" := "Basic " || EncodeBase64(unpacked.user || ":" || unpacked.password) INTO fetchoptions.headers;
    unpacked.user := "";
    unpacked.password := "";
    url := RepackURL(unpacked);
  }

  STRING body;
  IF (options.ndjson)
  {
    // For _bulk requests, convert the request records to NDJSON
    body := Detokenize((SELECT AS STRING ARRAY EncodeJSON(bulkrequests) FROM requestbody.bulkrequests), "\n") || "\n";
  }
  ELSE IF (RecordExists(requestbody))
  {
    // Other requests are just JSON-encoded
    body := EncodeJSON(requestbody);
  }

  OBJECT response;
  STRING text;
  STRING cause := " on " || method || " " || url;

  TRY
  {
    //FIXME   IF(IsDebugTagEnabled("consilio:traffic")) ..
    IF (Length(body) > 0)
    {
      INSERT CELL "Content-Type" := options.ndjson ? "application/x-ndjson" : "application/json" INTO fetchoptions.headers;
      INSERT CELL body := body INTO fetchoptions;
    }

    IF(IsDebugTagEnabled("consilio:traffic")) //TODO prevent huge bodies from being submitted ?
      LogDebug("consilio:traffic", "OUT: " || method || " " || url, fetchoptions);

    response := FetchSync(url, fetchoptions, [ timeout := options.timeout ]);
    text := response->text();

    IF(IsDebugTagEnabled("consilio:traffic")) //TODO prevent huge bodies from being submitted ?
      LogDebug("consilio:traffic", "IN: " || method || " " || url, CELL[response->status, text]);
  }
  CATCH(OBJECT e)
  {
    IF (running_in_fetcher AND print_defer_connection) {
      Sleep(1000); //ugly hack to reduce logspam when looping on an unavailable search engine
      Print("Defer:connection\n");
    }

    THROW NEW SearchUnavailableException(`Search unavailable (${e->what}) ${cause}`);
  }

  IF (response->status NOT IN options.expectstatus)
    IF(response->status IN [502,503]) //still starting up
      THROW NEW SearchUnavailableException(`Search unavailable, status code ${response->status} ${cause}`);
    ELSE
      THROW NEW OpenSearchException(`Unexpected response code ${response->status} ${cause}`, response, text);

  VARIANT decoded := DEFAULT RECORD;
  IF (response->headers->Get("Content-Type") LIKE "application/json*")
  {
    IF (options.enforce != "")
      decoded := DecodeIncomingJSON(response->text(), options.enforce, CELL[ options.explain ]);
    ELSE
      decoded := response->json();
  }

  RETURN
      [ status  := response->status = 404 ? SearchIndexNotFound
                 : response->status = 401 ? SearchNoAccess
                 : response->status < 200 OR response->status > 299 ? SearchHTTPError
                 : SearchOk
      , code    := response->status
      , result  := decoded
      ];
}

PUBLIC RECORD FUNCTION GetOpensearchStatus(INTEGER indexmgrid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ timeout := opensearch_read_timeout
                             , firstconnect_timeout := opensearch_read_timeout
                             ], options);

  RECORD result :=
      [ msg := STRING[]
      ];

  // Get file system status (containing total and available disk space) and cluster settings (containing disk thresholds). Both calls will throw if no 200 Ok is received
  RECORD stats := SendRawJSONToOpenSearch(indexmgrid, "GET", "/_nodes/stats", DEFAULT RECORD, options);

  // The nodes are named; we'll just use the first (and, at least for now, only) node
  stats := UnpackRecord(stats.result.nodes)[0].value;

  /* TODO Monitor breakers tripping ? that's the clearest sign of trouble but we need a way to reset it then: eg
       +BREAKERS: RECORD
        +FIELDDATA: RECORD
         +ESTIMATED_SIZE: '0b'
         +ESTIMATED_SIZE_IN_BYTES: 0
         +LIMIT_SIZE: '140mb'
         +LIMIT_SIZE_IN_BYTES: 146800640
         +OVERHEAD: 1.03000000000000000000
         +TRIPPED: 0
  */

  stats := EnforceStructure(CELL[ fs := [ total := [ available_in_bytes := 0i64
                                                   , total_in_bytes := 0i64
                                                   ]
                                        ]
                                , jvm := [ mem := [ heap_used_percent := 0 ] ]
                                ], stats);

  INTEGER64 total_bytes :=stats.fs.total.total_in_bytes;
  INTEGER64 available_bytes :=stats.fs.total.available_in_bytes;
  INTEGER indexstatus;
  STRING watermark;

  // Read cluster disk settings
  RECORD settings := GetOpenSearchSettings(indexmgrid, TRUE, options);
  IF (settings."cluster.routing.allocation.disk.threshold_enabled" != "false")
  {
    INTEGER64 low_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.low", total_bytes);
    INTEGER64 high_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.high", total_bytes);
    INTEGER64 flood_bytes := ReadWatermark(settings."cluster.routing.allocation.disk.watermark.flood_stage", total_bytes);
    IF (available_bytes < flood_bytes AND CellExists(settings,"cluster.routing.allocation.disk.watermark.flood"))
    {
      watermark := `flood=${settings."cluster.routing.allocation.disk.watermark.flood"}`;
    }
    ELSE IF (available_bytes < high_bytes)
    {
      watermark := `high=${settings."cluster.routing.allocation.disk.watermark.high"}`;
    }
    ELSE IF (available_bytes < low_bytes)
    {
      watermark := `low=${settings."cluster.routing.allocation.disk.watermark.low"}`;
    }
    ELSE
    {
      indexstatus := 1;
      watermark := "ok";
    }
  }
  ELSE
  {
    indexstatus := 1;
    watermark := "false";
  }

  RETURN CELL [ disk_available := available_bytes
              , disk_total := total_bytes
              , disk_watermark := watermark
              , jvm_heap_used_percent := stats.jvm.mem.heap_used_percent
              , indexstatus
              ];
}

PUBLIC RECORD FUNCTION GetOpenSearchSettings(INTEGER indexmgrid, BOOLEAN include_defaults, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ timeout := opensearch_read_timeout
                             , firstconnect_timeout := opensearch_read_timeout //let's not be too patient
                             ], options);
  STRING command := "/_cluster/settings?flat_settings=true";
  IF (include_defaults)
    command := command || "&include_defaults=true";

  RECORD settings := SendRawJSONToOpenSearch(indexmgrid, "GET", command, DEFAULT RECORD, CELL[ options.timeout, options.firstconnect_timeout ]);
  IF (settings.status != SearchOk)
    RETURN DEFAULT RECORD;

  /*
    https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html#_order_of_precedence

    The order of precedence for cluster settings is:

    1. transient cluster settings
    2. persistent cluster settings
    3. settings in the elasticsearch.yml configuration file.
  */
  IF (include_defaults)
    RETURN CELL
      [ ...settings.result.defaults
      , ...settings.result.persistent
      , ...settings.result.transient
      ];
  RETURN CELL
    [ ...settings.result.persistent
    , ...settings.result.transient
    ];
}

// To set low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := "85%" ]
// To clear low watermark threshold
// [ "cluster.routing.allocation.disk.watermark.low" := DEFAULT RECORD ] (encoded as "null")
PUBLIC RECORD FUNCTION SetOpenSearchSettings(INTEGER indexmgrid, RECORD settings)
{
  RECORD request := [ persistent := settings ];
  RETURN SendRawJSONToOpenSearch(indexmgrid, "PUT", "/_cluster/settings", request);
}

INTEGER64 FUNCTION ReadWatermark(STRING input, INTEGER64 total_bytes)
{
  IF (input LIKE "*%")
  {
    // The percentage of the disk that is used
    INTEGER percentage := ToInteger(Left(input, Length(input) - 1), 0);
    IF (percentage <= 0)
      RETURN -1;
    // Note: this will only work with disk sizes < 2^63 / 100
    RETURN total_bytes - (total_bytes * percentage / 100);
  }
  ELSE
  {
    // The absolute number of free bytes
    INTEGER64 bytes := ParseOpenSearchBytes(input);
    IF (bytes < 0)
      RETURN -1;
    RETURN bytes;
  }
}

PUBLIC INTEGER64 FUNCTION ParseOpenSearchBytes(STRING readable_bytes)
{
  readable_bytes := ToLowercase(readable_bytes);
  INTEGER64 factor := 1;
  IF (readable_bytes LIKE "*kb")
    factor := 1024;
  ELSE IF (readable_bytes LIKE "*mb")
    factor := 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*gb")
    factor := 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*tb")
    factor := 1024 * 1024 * 1024 * 1024;
  ELSE IF (readable_bytes LIKE "*pb")
    factor := 1024 * 1024 * 1024 * 1024 * 1024;
  IF (readable_bytes LIKE "*b")
  {
    INTEGER64 value := ToInteger64(Left(readable_bytes, Length(readable_bytes) - (factor > 1 ? 2 : 1)), -1);
    IF (value >= 0)
      RETURN value * factor;
  }
  RETURN -1;
}

PUBLIC BOOLEAN FUNCTION IsOpenSearchIndexPresent(INTEGER indexmgrid, STRING indexname)
{
  //Getting just the index isn't enough. It will already stop 404-ing before you can write..
  RECORD stats := SendRawJSONToOpenSearch(indexmgrid, "GET", indexname || "/_stats", DEFAULT RECORD, [ expectstatus := [200,404] ]);
  RETURN stats.code = 200 AND stats.result._shards.successful >= 1;
}

PUBLIC STRING FUNCTION GetOpenSearchDocumentId(INTEGER catalogid, STRING objectid, STRING suffix DEFAULTSTO "")
{
  RETURN EncodeUFS(GetMD5Hash(catalogid || (suffix != "" ? "-" || suffix : "") || "/" || objectid));
}

// recursively walk through the query, return the 'userquery' values from all 'user' queries
PUBLIC STRING ARRAY FUNCTION ExtractUserQueries(RECORD query)
{
  IF (CellExists(query, "query"))
    query := query.query;
  RETURN ExtractUserQueriesRecursive(query);
}

STRING ARRAY FUNCTION ExtractUserQueriesRecursive(RECORD query)
{
  IF (NOT CellExists(query, "_type"))
    RETURN STRING[];
  IF (query._type = "user")
    RETURN STRING[ query.userquery ];
  ELSE IF (query._type = "boolean")
  {
    STRING ARRAY queries;
    FOREVERY (RECORD subquery FROM query.subqueries)
      queries := queries CONCAT ExtractUserQueriesRecursive(subquery.query);
    RETURN queries;
  }
  RETURN STRING[];
}

// Create a (flattened) list of requested fields
PUBLIC STRING ARRAY FUNCTION GetRequestedFields(RECORD mapping)
{
  STRING ARRAY fields;
  FOREVERY (RECORD field FROM UnpackRecord(mapping))
  {
    IF (CanCastTypeTo(TypeID(field.value), TypeID(RECORD)) AND RecordExists(field.value))
      FOREVERY (STRING subfield FROM GetRequestedFields(field.value))
        INSERT ToLowercase(field.name) || "." || subfield INTO fields AT END;
    ELSE IF (field.name NOT LIKE "_SCORE.*") // Don't request our additional fields
      INSERT ToLowercase(field.name) INTO fields AT END;
  }
  RETURN fields;
}

// input is either a single query, or a record containing a query and filters or an aggregation and possibly a query
PUBLIC RECORD FUNCTION CreateOpenSearchQuery(RECORD input, RECORD mapping, RECORD indexoptions)
{
  RECORD result :=
      [ query := DEFAULT RECORD
      , aggs := DEFAULT RECORD
      , sort := VARIANT[]
      , _source := GetRequestedFields(mapping)
      ];

  IF (CellExists(input, "aggregation"))
  {
    result.aggs := CreateOpenSearchAggregationRecursive(input.aggregation);
    DELETE CELL aggregation FROM input;
  }

  IF (CellExists(input, "ordering"))
  {
    result.sort := CreateElastisearchSort(input.ordering);
    DELETE CELL ordering FROM input;
  }

  RECORD query := input;
  IF (CellExists(query, "query"))
    query := query.query;

  IF (RecordExists(UnpackRecord(query))) // query may be an empty record at this point
  {
    RECORD created := CreateOpenSearchQueryRecursive(CELL[ ...result, query ], indexoptions);
    result.query := created.query;
    result._source := created._source;

    IF (CellExists(input, "filters"))
    {
      RECORD ARRAY filters;
      FOREVERY (RECORD filter FROM input.filters)
      {
        BOOLEAN isdatefilter := TYPEID(filter.lowerterm) = TYPEID(DATETIME);
        RECORD range := DEFAULT RECORD;
        IF (NOT IsDefaultValue(filter.lowerterm))
        {
          IF (filter.includelower)
            INSERT CELL gte := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
          ELSE
            INSERT CELL gt := isdatefilter ? FormatISO8601DateTime(filter.lowerterm, "day", "milliseconds") : filter.lowerterm INTO range;
        }
        IF (NOT IsDefaultValue(filter.upperterm))
        {
          IF (filter.includeupper)
            INSERT CELL lte := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
          ELSE
            INSERT CELL lt := isdatefilter ? FormatISO8601DateTime(filter.upperterm, "day", "milliseconds") : filter.upperterm INTO range;
        }
        INSERT [ range := CellInsert(DEFAULT RECORD, filter.field, range) ] INTO filters AT END;
      }
      IF (Length(filters) > 0)
        result.query := AddOpenSearchQueryFilters(result.query, filters, FALSE);
    }
  }

  IF (NOT RecordExists(result.query))
    DELETE CELL query FROM result;
  IF (NOT RecordExists(result.aggs))
    DELETE CELL aggs FROM result;
  IF (Length(result.sort) = 0)
    DELETE CELL sort FROM result;
  IF (Length(result._source) = 0)
    result := CELL[ ...result, _source := FALSE ];
  RETURN result;
}

PUBLIC RECORD FUNCTION AddOpenSearchQueryFilters(RECORD query, RECORD ARRAY filters, BOOLEAN not_filter)
{
  IF (RecordExists(query) AND NOT CellExists(query, "bool"))
    query := [ bool := [ must := [ RECORD(query) ] ] ];

  IF (not_filter)
  {
    IF (RecordExists(query))
    {
      IF(NOT CellExists(query.bool, "must_not"))
        INSERT CELL must_not := DEFAULT RECORD ARRAY INTO query.bool;
      query.bool.must_not := query.bool.must_not CONCAT filters;
    }
    ELSE
    {
      query := [ bool := [ must_not := filters ]];
    }
  }
  ELSE
  {
    /* if we receive a  query: bool: should:  query
       and add a filter...
       opensearch will start returning results matching that filter even if they don't match the should!
       but the 'should' is there to support OR queries

       this broke restrict_url queries. so explicitly wrap the existing should in a must - don't add a filter on the same level */
    IF(RecordExists(query))
    {
      query := [ bool := [ must := [ RECORD(query) ]
                         , filter := filters
                         ]
               ];
    }
    ELSE
    {
      query := [ bool := [ filter := filters ]];
    }
  }

  RETURN query;
}

RECORD FUNCTION LookupFieldInMapping(RECORD ARRAY expectedmapping, STRING fieldname)
{
  RECORD field;
  FOREVERY(STRING tok FROM Tokenize(fieldname,'.'))
  {
    field := SELECT * FROM expectedmapping WHERE name = tok;
    IF(NOT RecordExists(field))
    {
      field := SELECT * FROM expectedmapping WHERE tok LIKE name;
      IF(RecordExists(field))
        THROW NEW Exception(`Field '${fieldname}' is not indexed because it's only matched by wildcards '${field.name}'`);
    }

    IF(NOT RecordExists(field))
      THROW NEW Exception(`No such field '${fieldname}'`);

    expectedmapping := field.properties;
  }
  RETURN field;
}

//ADDME: Take field mapping into account (e.g. whether to use a match (text) or term (keyword) query)
RECORD FUNCTION CreateOpenSearchQueryRecursive(RECORD result, RECORD indexoptions)
{
  RECORD query := result.query;
  IF (NOT CellExists(query, "_type"))
    THROW NEW Exception(`Invalid query record: ${AnyToString(query, "tree")}`);

  SWITCH (query._type)
  {
    CASE "all"
    {
      result.query := [ match_all := CELL[] ];
    }
    CASE "nothing"
    {
      RETURN CELL[ ...result, query :=  DEFAULT RECORD ];
    }
    CASE "boolean"
    {
      RECORD booleanquery;
      RECORD ARRAY subqueries :=
          SELECT *
               , must := required
               , must_not := prohibited
               , should := NOT required AND NOT prohibited
            FROM query.subqueries;
      FOREVERY (STRING requirement FROM [ "must", "must_not", "should" ])
      {
        RECORD ARRAY queries :=
            SELECT AS RECORD ARRAY CreateOpenSearchQueryRecursive(CELL[ ...result, subqueries.query ], indexoptions)
              FROM subqueries
             WHERE GetCell(subqueries, requirement);
        IF (Length(queries) > 0)
        {
          booleanquery := CellInsert(booleanquery, requirement, SELECT AS RECORD ARRAY queries.query FROM queries);
          FOREVERY (RECORD subquery FROM queries)
            result._source := ArrayIntersection(result._source, subquery._source);
        }
      }

      IF (RecordExists(booleanquery))
        result.query := [ bool := booleanquery ];
    }
    CASE "term"
    {
      RECORD fieldmapping;
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        fieldmapping := LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      IF (RecordExists(fieldmapping) AND fieldmapping.type = "keyword")
      {
        result.query := [ term := CellInsert(DEFAULT RECORD, query.field, term) ];
      }
      ELSE
      {
        // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
        result.query :=
            [ bool :=
                [ should :=
                    [ [ match := CellInsert(DEFAULT RECORD, query.field, [ query := term, analyzer := "consilio_analyzer" ]) ]
                    , [ match := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", [ query := term, analyzer := "consilio_original" ]) ]
                    ]
                ]
            ];
      }
    }
    CASE "terms"
    {
      RECORD fieldmapping;
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        fieldmapping := LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }
      // Term queries aren't really supported on text fields
      // If we don't know the field type, assume it's ok
      IF (RecordExists(fieldmapping) AND fieldmapping.type = "text")
        THROW NEW Exception(`A 'terms' query cannot be performed on '${RecordExists(fieldmapping) ? fieldmapping.type : "unknown"}' field '${query.field}'`);

      // Convert MONEYs
      VARIANT terms := query.terms;
      IF (TypeID(terms) = TypeID(MONEY ARRAY))
        terms := SELECT AS INTEGER64 ARRAY __HS_GetRawMoney(term) FROM ToRecordArray(terms, "term");

      result.query := [ terms := CellInsert(DEFAULT RECORD, query.field, terms) ];
    }
    CASE "match"
    {
      IF(RecordExists(indexoptions))
      {
        RECORD ARRAY fields := SELECT AS RECORD ARRAY LookupFieldInMapping(indexoptions.expectedmapping, field) FROM ToRecordArray(query.fields,'field');
      }

      IF (Length(query.fields) = 1)
        result.query :=
            [ match := CellInsert(DEFAULT RECORD, query.fields[0], query.text) ];
      ELSE IF (Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result.query :=
            [ multi_match :=
                [ query := query.text
                , type := "best_fields"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
      }
    }
    CASE "literal"
    {
      RECORD fieldmapping;
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        fieldmapping := LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := query.term;
      IF (TypeID(term) = TypeID(MONEY))
        term := __HS_GetRawMoney(term);
      IF (RecordExists(fieldmapping) AND fieldmapping.type = "keyword")
      {
        result.query := [ term := CellInsert(DEFAULT RECORD, query.field, term) ];
      }
      ELSE
      {
        // Search through both the query field (ascii-folded, stemmed, etc) and the original field (only tokenized)
        result.query :=
            [ bool :=
                [ should :=
                    [ [ term := CellInsert(DEFAULT RECORD, query.field, term) ]
                    , [ term := CellInsert(DEFAULT RECORD, query.field || ".consilio_original", term) ]
                    ]
                ]
            ];
      }
    }
    CASE "phrase"
    {
      IF (CellExists(query, "fields") AND Length(query.fields) > 1)
      {
        STRING ARRAY boosts :=
            SELECT AS STRING ARRAY FormatBoost(boost)
              FROM ToRecordArray(query.boosts ?? [ 1f ], "boost");
        result.query :=
            [ multi_match :=
                [ query := Detokenize(query.words, " ")
                , type := "phrase"
                , fields :=
                    (SELECT AS STRING ARRAY field || boosts[#fields % Length(boosts)]
                       FROM ToRecordArray(query.fields, "field") AS fields)
                ]
            ];
        IF (query.slop != 0)
          INSERT CELL slop := query.slop INTO result.query.multi_match;
      }
      ELSE
      {
        // This is a multi-field phrase query with one field
        IF (CellExists(query, "fields"))
        {
          INSERT CELL field := query.fields[0] INTO query;
          IF (Length(query.boosts) > 0)
            query.boost := query.boost * query.boosts[0];
        }
        result.query :=
            [ match_phrase := CellInsert(DEFAULT RECORD, query.field, Detokenize(query.words, " ")) ];
        IF (query.slop != 0)
        {
          // Convert [ match_phrase := [ my_field := "my_value" ] ] into
          // [ match_phrase := [ my_field := [ query := "my_value", slop := my_slop ] ] ]
          RECORD slop_query :=
              [ query := GetCell(result.match_phrase, query.field)
              , slop := query.slop
              ];
          result.query.match_phrase := CellInsert(CellDelete(result.query.match_phrase, query.field), query.field, slop_query);
        }
      }
    }
    CASE "date", "range"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      // Convert MONEYs
      VARIANT term := "", lowerterm := "", upperterm := "";
      IF (query.matchtype IN [ "<", "<=", ">=", ">" ])
      {
        term := query.term;
        IF (TypeID(term) = TypeID(MONEY))
          term := __HS_GetRawMoney(term);
      }
      ELSE IF (query.matchtype IN [ "[]", "{]", "[}", "{}" ])
      {
        lowerterm := query.lowerterm;
        IF (TypeID(lowerterm) = TypeID(MONEY))
          lowerterm := __HS_GetRawMoney(lowerterm);
        upperterm := query.upperterm;
        IF (TypeID(upperterm) = TypeID(MONEY))
          upperterm := __HS_GetRawMoney(upperterm);
      }

      RECORD rangequery;
      SWITCH (query.matchtype)
      {
        CASE "<"  { rangequery := [ lt := term ]; }
        CASE "<=" { rangequery := [ lte := term ]; }
        CASE ">=" { rangequery := [ gte := term ]; }
        CASE ">"  { rangequery := [ gt := term ]; }
        CASE "[]" { rangequery := [ gte := lowerterm, lte := upperterm ]; }
        CASE "{]" { rangequery := [ gt := lowerterm, lte := upperterm ]; }
        CASE "[}" { rangequery := [ gte := lowerterm, lt := upperterm ]; }
        CASE "{}" { rangequery := [ gt := lowerterm, lt := upperterm ]; }
      }
      IF (query.boost != 1)
        INSERT CELL boost := query.boost INTO rangequery;

      // Return result directly, as we've already applied boost factor
      RETURN CELL[ ...result, query := [ range := CellInsert(DEFAULT RECORD, query.field, rangequery) ] ];
    }
    CASE "exists"
    {
      IF(RecordExists(indexoptions)) //QueryindexManager doesn't pass this info
      {
        LookupFieldInMapping(indexoptions.expectedmapping, query.field);
      }

      RETURN CELL[ ...result, query := [ exists := [ field := query.field ] ] ];
    }
    CASE "user"
    {
      //older users may not have actually set stemmed_field. TODO queries.whlib does a CellExists so should we merge our enforcing with theirs?
      RECORD ARRAY fields := EnforceStructure([[ stemmed_field := FALSE ]], query.defaultfields ?? defaultfields);
      result.query :=
          [ simple_query_string :=
              [ query := query.userquery
              , fields := (SELECT AS STRING ARRAY field || (CellExists(fields, "boost") ? FormatBoost(boost) : "") FROM fields) CONCAT (SELECT AS STRING ARRAY field || ".consilio_original" FROM fields WHERE stemmed_field)
              , default_operator := query.querymode
              , analyzer := query.synonyms ? "consilio_search" : "consilio_analyzer"
              ]
          ];
    }
    CASE "nested"
    {
      result := CreateOpenSearchQueryRecursive(CELL[ ...result, query := query.subquery ], indexoptions);
      RECORD inner_hits := [ name := query.field ];
      IF (query.returnnonmatching)
      {
        // Returning all nested records, don't request any source fields for the inner hits
        INSERT CELL _source := FALSE INTO inner_hits;
      }
      ELSE
      {
        // If only the matching nested records are returned, add the subfields within the query's path to the inner hits
        // source and remove them from the global source
        INSERT CELL _source := SELECT AS STRING ARRAY field FROM ToRecordArray(result._source, "field") WHERE field LIKE query.field || ".*" INTO inner_hits;
        result._source := ArrayDelete(result._source, inner_hits._source);
      }
      IF (query.first > 0)
        INSERT CELL "from" := query.first INTO inner_hits;
      INSERT CELL size := query.count >= 0 AND query.count <= 100 - query.first ? query.count : 100 INTO inner_hits; // Maximum window size (from+size) of inner hits is 100
      IF (query.orderby != "")
      {
        STRING orderfield := query.orderby = query.scorefield ? "_score" : query.field || "." || query.orderby;
        IF (CellExists(query, "orderdesc"))
          INSERT CELL sort := [ CellInsert(DEFAULT RECORD, orderfield, query.orderdesc ? "desc" : "asc") ] INTO inner_hits;
        ELSE
          INSERT CELL sort := [ orderfield ] INTO inner_hits;
      }
      result.query :=
          [ nested := CELL
              [ path := query.field
              , query := result.query
              , inner_hits
              ]
          ];
    }
    CASE "opensearch"
    {
      RETURN CELL[ ...result, query := query.rawquery ];
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown query type '" || query._type || "'");
    }
  }
  IF (query.boost != 1)
  {
    result.query :=
        [ function_score := CELL
            [ query.boost
            , result.query
            ]
        ];
  }
  RETURN result;
}

STRING FUNCTION FormatBoost(FLOAT boost)
{
  IF (boost = 1)
    RETURN "";
  STRING formatted := FormatFloat(boost * 100000, 0);
  formatted := Left(formatted, Length(formatted) - 5) || "." || Substring(formatted, Length(formatted) - 5);
  WHILE (Right(formatted, 1) = "0")
    formatted := Left(formatted, Length(formatted) - 1);
  IF (Right(formatted, 1) = ".")
    formatted := Left(formatted, Length(formatted) - 1);
  IF (Left(formatted, 1) = ".")
    formatted := "0" || formatted;
  RETURN "^" || formatted;
}

VARIANT ARRAY FUNCTION CreateElastisearchSort(RECORD ARRAY ordering)
{
  VARIANT ARRAY sort;
  IF (RecordExists(ordering))
  {
    // The 'sort' field is an array of strings and objects
    FOREVERY (RECORD orderfield FROM ordering)
    {
      IF (CellExists(orderfield, "orderdesc"))
      {
        IF (CellExists(orderfield, "ordermode"))
        {
          // When both orderdesc and ordermode are given, insert an object with an object property
          // { "myfield": { "order": "asc", "mode": "min" } }
          INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ "order" := orderfield.orderdesc ? "desc" : "asc", "mode" := orderfield.ordermode ]) INTO sort AT END;
        }
        ELSE
        {
          // When only orderdesc is given, insert on object with a string property
          // { "myfield": "asc" }
          INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, orderfield.orderdesc ? "desc" : "asc") INTO sort AT END;
        }
      }
      ELSE IF (CellExists(orderfield, "ordermode"))
      {
        // When only ordermode is given, insert an object with an object property
        // { "myfield": { "mode": "min" } }
        INSERT CellInsert(DEFAULT RECORD, orderfield.orderby, [ mode := orderfield.ordermode ]) INTO sort AT END;
      }
      ELSE
      {
        // When only the field is given, insert the field name
        // "myfield"
        INSERT orderfield.orderby INTO sort AT END;
      }
    }
  }
  RETURN sort;
}

RECORD FUNCTION CreateOpenSearchAggregationRecursive(RECORD aggregation)
{
  IF (NOT CellExists(aggregation, "_type"))
    THROW NEW Exception(`Invalid aggregation record: ${AnyToString(aggregation, "tree")}`);

  RECORD result;
  SWITCH (aggregation._type)
  {
    CASE "count"
    {
      RETURN DEFAULT RECORD;
    }
    CASE "min", "max", "cardinality"
    {
      result := CellInsert(DEFAULT RECORD, aggregation._type, CELL[ aggregation.field ]);
    }
    CASE "terms"
    {
      result :=
          [ terms := CELL
              [ aggregation.field
              , size := aggregation.size >= 0 ? aggregation.size : 10000
              , "order" := [ _key := aggregation.orderdesc ? "desc" : "asc" ]
              ]
          ];
    }
    CASE "top_hits"
    {
      result :=
          [ top_hits :=
              CELL[ docvalue_fields := STRING[ aggregation.field ]
                  , _source := aggregation.field
                  , aggregation.size
                  ]
          ];
      IF (aggregation.orderby != "")
      {
        INSERT CELL sort := CellInsert(DEFAULT RECORD, aggregation.orderby, [ "order" := aggregation.orderdesc ? "desc" : "asc" ]) INTO result.top_hits;
        INSERT aggregation.orderby INTO result.top_hits.docvalue_fields AT END;
      }
    }
    DEFAULT
    {
      THROW NEW Exception("Unknown aggregation type '" || aggregation._type || "'");
    }
  }

  IF (CellExists(aggregation, "aggregations") AND RecordExists(aggregation.aggregations))
  {
    INSERT CELL aggs := DEFAULT RECORD INTO result;
    FOREVERY (RECORD agg FROM aggregation.aggregations)
      result.aggs := CELL[ ...result.aggs, ...CreateOpenSearchAggregationRecursive(agg.aggregation) ];
  }

  RETURN CellInsert(DEFAULT RECORD, aggregation.name, result);
}

// Encode DEFAULT DATETIMEs as null (DEFAULT RECORD) and MONEYs as INTEGER64s
PUBLIC RECORD FUNCTION FixupOpenSearchDocumentFields(RECORD document)
{
  IF (NOT RecordExists(document))
    RETURN document;
  FOREVERY (RECORD field FROM UnpackRecord(document))
  {
    // Don't index empty fields
    IF (IsDefaultValue(field.value))
      document := CellDelete(document, field.name);
    // Convert DEFAULT DATETIMEs
    ELSE IF (TypeID(field.value) = TypeID(DATETIME ARRAY) AND DEFAULT DATETIME IN field.value)
      document := CellInsert(CellDelete(document, field.name), field.name, ConvertDefaultDatetime(field.value));
    // Convert MONEYs
    ELSE IF (TypeID(field.value) = TypeID(MONEY))
      document := CellInsert(CellDelete(document, field.name), field.name, __HS_GetRawMoney(field.value));
    ELSE IF (TypeID(field.value) = TypeID(MONEY ARRAY))
      document := CellInsert(CellDelete(document, field.name), field.name, SELECT AS INTEGER64 ARRAY __HS_GetRawMoney(value) FROM ToRecordArray(field.value, "value"));
    // Recurse into RECORDs
    ELSE IF (TypeID(field.value) = TypeID(RECORD))
      document := CellUpdate(document, field.name, FixupOpenSearchDocumentFields(field.value));
    // Recurse into RECORD ARRAYs
    ELSE IF (TypeID(field.value) = TypeID(RECORD ARRAY))
      document := CellUpdate(document, field.name, SELECT AS RECORD ARRAY FixupOpenSearchDocumentFields(value) FROM field.value);
  }
  RETURN document;
}

// Convert DEFAULT DATETIME to DEFAULT RECORD so it's sent as 'null'
VARIANT ARRAY FUNCTION ConvertDefaultDatetime(DATETIME ARRAY dates)
{
  VARIANT ARRAY converted;
  FOREVERY (DATETIME date FROM dates)
    IF (date != DEFAULT DATETIME)
      INSERT date INTO converted AT END;
    ELSE
      INSERT DEFAULT RECORD INTO converted AT END;
  RETURN converted;
}

PUBLIC VARIANT FUNCTION ReadOpenSearchAggregationResult(RECORD query_aggregation, STRING aggregation_name, RECORD result)
{
  // The 'count' is handled separately, as it's not really an aggregation
  IF (query_aggregation._type = "count")
  {
    IF (CellExists(result, "doc_count"))
      RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result.doc_count);
    THROW NEW Exception(`Unhandled 'count' aggregation: ${AnyToString(CELL[ query_aggregation, result ], "tree")}`);
  }

  RECORD result_aggregation := GetCell(result, aggregation_name);
  SWITCH (query_aggregation._type)
  {
    CASE "min", "max", "cardinality"
    {
      IF (query_aggregation.name LIKE "date_*" OR query_aggregation.name LIKE "*.date_*")
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, MakeDateFromText(result_aggregation.value_as_string));
      ELSE
        RETURN CellInsert(DEFAULT RECORD, query_aggregation.name, result_aggregation.value);
    }
    CASE "terms"
    {
      RECORD ARRAY lineresults;
      IF (Length(result_aggregation.buckets) > 0)
      {
        FOREVERY (RECORD bucket FROM result_aggregation.buckets)
        {
          RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, bucket."key");
          IF (query_aggregation.countfield != "")
            lineresult := CellInsert(lineresult, query_aggregation.countfield, bucket.doc_count);

          IF (CellExists(query_aggregation, "aggregations"))
          {
            FOREVERY (RECORD agg FROM query_aggregation.aggregations)
            {
              VARIANT aggresult := ReadOpenSearchAggregationResult(agg.aggregation, agg.aggregation.name, bucket);
              IF (IsTypeIDArray(TypeID(aggresult)))
                lineresult := CellInsert(lineresult, agg.aggregation.name, aggresult);
              ELSE
                lineresult := CellInsert(lineresult, agg.aggregation.name, GetCell(aggresult, agg.aggregation.name));
            }
          }

          INSERT lineresult INTO lineresults AT END;
        }
      }
      RETURN lineresults;
    }
    CASE "top_hits"
    {
      RECORD ARRAY lineresults;
      FOREVERY (RECORD hit FROM result_aggregation.hits.hits)
      {
        RECORD lineresult := CellInsert(DEFAULT RECORD, query_aggregation.name, GetCell(hit.fields, query_aggregation.field)[0]);
        IF (query_aggregation.orderby != "")
        {
          IF (query_aggregation.orderby LIKE "date_*" OR query_aggregation.orderby LIKE "*.date_*")
            lineresult := CellInsert(lineresult, query_aggregation.orderby, MakeDateFromText(GetCell(hit.fields, query_aggregation.orderby)[0]));
          ELSE
            lineresult := CellInsert(lineresult, query_aggregation.orderby, GetCell(hit.fields, query_aggregation.orderby)[0]);
        }
        INSERT lineresult INTO lineresults AT END;
      }
      RETURN lineresults;
    }
  }
  THROW NEW Exception("Unknown aggregation type '" || query_aggregation._type || "'");
}

PUBLIC RECORD ARRAY FUNCTION ReadOpenSearchResults(RECORD ARRAY hits, RECORD searchquery, RECORD mapping, RECORD options)
{
  options := ValidateOptions([ highlightfields := STRING[], highlightparts := STRING[] ], options, [ passthrough := TRUE ]);

  RECORD sourcemapping := mapping;
  // Don't return internal fields in the parsed _source
  FOREVERY (RECORD field FROM UnpackRecord(sourcemapping))
    IF (__MatchesAnyMask(field.name, [ "_EXPLANATION", "_SCORE", "_SUGGESTED", "_SUMMARY", "_SCORE.*", "_SUMMARY.*", "_TOTALCOUNT.*" ]))
      sourcemapping := CellDelete(sourcemapping, field.name);

  RECORD ARRAY results;
  FOREVERY (RECORD hit FROM hits)
  {
    // Source may not exist within inner hits
    RECORD sourcehit := CellExists(hit, "_source") ? hit._source : DEFAULT RECORD;
    RECORD internalfields;

    IF(CellExists(mapping, '_score'))
      internalfields := CellInsert(internalfields, mapping._score, hit._score);

    IF(CellExists(mapping, '_summary'))
      internalfields := AddSummary(internalfields, hit, options.highlightparts, mapping._summary);

    IF(CellExists(mapping, '_explanation'))
      INSERT CELL _explanation := hit._explanation INTO internalfields;

    //We're not properly recording the mapping for _suggested and it might go away in the future anyway.. so just copy or mock it
    IF(CellExists(mapping, '_suggested'))
      IF(CellExists(sourcehit,'_suggested'))
        INSERT CELL _suggested := sourcehit._suggested INTO internalfields;
      ELSE
        INSERT CELL _suggested := DEFAULT RECORD INTO internalfields;

    IF (CellExists(hit, "highlight"))
      FOREVERY(RECORD mappedfield FROM UnpackRecord(sourcemapping))
      {
        //TODO does this work properly with subfields? or do we need to look for flattened versions
        IF(CellExists(hit.highlight, mappedfield.name))
        {
          sourcehit := CellDelete(sourcehit, mappedfield.name);
          sourcehit := CellInsert(sourcehit, mappedfield.name, GetCell(hit.highlight, mappedfield.name)[0]);
        }
      }

    // Read inner hit sources recursively into the sourcehit (for nested queries)
    IF (CellExists(hit, "inner_hits"))
    {
      RECORD innersource := ReadInnerHits(hit, mapping, options);
      IF (RecordExists(innersource.value))
        sourcehit := CellInsert(sourcehit, innersource.field, innersource.value);
      IF (RecordExists(innersource.internalvalue))
        internalfields := CellInsert(internalfields, innersource.field, innersource.internalvalue);
      IF (CellExists(mapping, "_totalcount." || innersource.path))
      {
        internalfields := CellInsert(internalfields, GetCell(mapping, "_totalcount." || innersource.path), innersource.total.value);
        internalfields := CellInsert(internalfields, GetCell(mapping, "_totalcount." || innersource.path) || ".exact", innersource.total.relation = "eq");
      }
    }

    RECORD singleresult := ParseSingleOpenSearchResult(sourcehit, sourcemapping);
    INSERT CombineFields(singleresult, internalfields) INTO results AT END;
  }
  RETURN results;
}

// Add the highlighted parts to the fields record in the summaryfield cell
RECORD FUNCTION AddSummary(RECORD fields, RECORD hit, STRING ARRAY highlightparts, STRING summaryfield)
{
  STRING ARRAY summaries;
  IF (CellExists(hit, "highlight"))
    FOREVERY (STRING field FROM highlightparts)
      IF (CellExists(hit.highlight, field))
        summaries := summaries CONCAT GetCell(hit.highlight, field);
  RETURN CellInsert(fields, summaryfield, Detokenize(summaries, " "));
}

// Recursively combine records (kind of like MakeUpdatedRecord, but with adding new fields from updatedata)
RECORD FUNCTION CombineFields(RECORD result, RECORD internalfields)
{
  FOREVERY (RECORD field FROM UnpackRecord(internalfields))
  {
    IF (CellExists(result, field.name))
    {
      IF (TypeID(field.value) = TypeID(RECORD ARRAY))
      {
        VARIANT resultvalue := GetCell(result, field.name);
        IF (TypeID(resultvalue) = TypeID(RECORD ARRAY) AND Length(resultvalue) = Length(field.value))
          field.value :=
              SELECT AS RECORD ARRAY CombineFields(resultvalue[#value], value)
                FROM field.value;
      }
      result := CellInsert(CellDelete(result, field.name), field.name, field.value);
    }
    ELSE
      result := CellInsert(result, field.name, field.value);
  }
  RETURN result;
}

// Read nested inner hits recursively, return source fields in value and generated fields (score, summary, totalcount) in
// internalvalue
RECORD FUNCTION ReadInnerHits(RECORD hit, RECORD mapping, RECORD options)
{
  // The 'inner_hits' record contains one cell named after the field we're reading hits for
  STRING path := SELECT AS STRING COLUMN name FROM UnpackRecord(hit.inner_hits);
  STRING field := Tokenize(path, ".")[END-1];
  hit := GetCell(hit.inner_hits, path);
  RECORD total := EnforceStructure([ value := 0, relation := ""], hit.hits.total);
  RECORD ARRAY value, internalvalue;
  IF (Length(hit.hits.hits) > 0)
  {
    RECORD ARRAY innerhits := hit.hits.hits;
    FOREVERY (RECORD innerhit FROM innerhits)
    {
      RECORD internalresult;
      IF (CellExists(mapping, "_score." || path))
        internalresult := CellInsert(internalresult, GetCell(mapping, "_score." || path), ToFloat(innerhit._score, 0f));
      IF (CellExists(mapping, "_summary." || path))
        internalresult := AddSummary(internalresult, innerhit, options.highlightparts, GetCell(mapping, "_summary." || path));

      RECORD result;
      // There are direct source fields for this hit
      IF (CellExists(innerhit, "_source"))
        result := innerhit._source;
      // There are inner hits for this hit
      IF (CellExists(innerhit, "inner_hits"))
      {
        RECORD innerresult := ReadInnerHits(innerhit, mapping, options);
        IF (RecordExists(innerresult.value))
          result := CellInsert(result, innerresult.field, innerresult.value);
        IF (RecordExists(innerresult.internalvalue))
          internalresult := CellInsert(internalresult, innerresult.field, innerresult.internalvalue);
        IF (CellExists(mapping, "_totalcount." || innerresult.path))
        {
          internalresult := CellInsert(internalresult, GetCell(mapping, "_totalcount." || innerresult.path), innerresult.total.value);
          internalresult := CellInsert(internalresult, GetCell(mapping, "_totalcount." || innerresult.path) || ".exact", innerresult.total.relation = "eq");
        }
      }
      IF (RecordExists(result))
      {
        // Replace fields with highlighted content
        IF (CellExists(innerhit, "highlight"))
          FOREVERY(RECORD resultfield FROM UnpackRecord(result))
          {
            //TODO does this work properly with subfields? or do we need to look for flattened versions
            IF (CellExists(innerhit.highlight, path || "." || resultfield.name))
            {
              result := CellDelete(result, resultfield.name);
              result := CellInsert(result, resultfield.name, GetCell(innerhit.highlight, path || "." || resultfield.name)[0]);
            }
          }

        INSERT result INTO value AT END;
      }
      IF (RecordExists(internalresult))
        INSERT internalresult INTO internalvalue AT END;
    }
  }
  RETURN CELL[ field, value, internalvalue, path, total ];
}

PUBLIC RECORD FUNCTION ParseSingleOpenSearchResult(RECORD lineresult, RECORD mapping)
{
  RETURN FixupOpenSearchResultFields(lineresult, mapping);
}

// OpenSearch doesn't have an array type, but instead accept multiple values for the same field. If there is only one value,
// it's not returned as an array, so this function convert single values into arrays where expected.
// This function also converts INTEGER64s back to MONEYs where necessary
RECORD FUNCTION FixupOpenSearchResultFields(RECORD lineresult, RECORD mapping)
{
  RECORD outputline := CELL[];
  STRING ARRAY seenfields;
  RECORD ARRAY unpackedmapping := UnpackRecord(mapping);

  FOREVERY (RECORD field FROM UnpackRecord(lineresult))
  {
    VARIANT fieldmapping;
    IF (CellExists(mapping, field.name))
    {
      fieldmapping := GetCell(mapping, field.name);
      INSERT field.name INTO seenfields AT END;
    }
    ELSE //Find a matching wildcard (eg ds_* to match ds_text)
    {
      RECORD mywildcard := SELECT * FROM unpackedmapping WHERE field.name LIKE COLUMN name;
      IF(NOT RecordExists(mywildcard))
        CONTINUE;

      fieldmapping := mywildcard.value;
    }

    VARIANT outputfield := field.value;

    //If we expect an array in outputfield but didn't get any, upgrade outputfield to an array
    IF (IsTypeIDArray(TypeID(fieldmapping)) AND NOT IsTypeIDArray(TypeID(outputfield)))
    {
      VARIANT value := GetTypeDefaultArray(TypeID(outputfield));
      IF (NOT IsDefaultValue(field.value))
        INSERT field.value INTO value AT END;
      outputfield := value;
    }

    IF (TypeID(fieldmapping) = TypeID(RECORD))
    {
      outputfield := FixupOpenSearchResultFields(outputfield, fieldmapping);
    }
    ELSE IF (TypeID(fieldmapping) = TypeID(RECORD ARRAY))
    {
      outputfield := SELECT AS RECORD ARRAY FixupOpenSearchResultFields(row, PickFirst(fieldmapping)) FROM outputfield AS row;
    }
    ELSE
    {
      //Non-record fields can often be safely enforced. But we store moneys multiplied by 10^5 so enforce can't fix those for us
      IF (TypeID(outputfield) = TypeID(STRING) AND TypeID(fieldmapping) = TypeID(MONEY))
        outputfield := ReadMoneyValue(outputfield);
      ELSE IF (TypeID(outputfield) = TypeID(STRING ARRAY) AND TypeID(fieldmapping) = TypeID(MONEY ARRAY))
        outputfield := SELECT AS MONEY ARRAY ReadMoneyValue(value) FROM ToRecordArray(outputfield, "value");
      ELSE
        outputfield := EnforceStructure(fieldmapping, outputfield);
    }
    outputline := CellInsert(outputline, field.name, outputfield);
  }

  FOREVERY(RECORD field FROM unpackedmapping)
    IF(SearchSubstring(field.name,'*') = -1 AND field.name NOT IN seenfields)
    {
      //insert fallback value to complete the output mapping
      IF (IsTypeIDArray(TypeID(field.value)))
        outputline := CellInsert(outputline, field.name, GetTypeDefaultValue(TypeID(field.value)));
      ELSE
        outputline := CellInsert(outputline, field.name, field.value);
    }

  RETURN outputline;
}

MONEY FUNCTION ReadMoneyValue(STRING value)
{
  IF (value LIKE "*.0")
    value := Left(value, Length(value) - 2);
  RETURN __HS_SetRawMoney(ToInteger64(value, 0));
}

RECORD FUNCTION DecodeIncomingJSON(STRING content, STRING type, RECORD options)
{
  RECORD decoded := DecodeJSON(content, DEFAULT RECORD, [ alltostring := TRUE ]);
  SWITCH (type)
  {
    CASE "_search_get"
    {
      RECORD hit :=
          [ _index := ""
          , _id := ""
          , _score := 0f
          , _source := DEFAULT RECORD
          ];
      IF (options.explain)
        INSERT CELL _explanation := DEFAULT RECORD INTO hit;
      decoded := EnforceStructure(
          [ took := 0
          , timed_out := FALSE
          , aggregations := DEFAULT RECORD
          , hits :=
              [ total := [ value := 0, relation := "" ]
              , max_score := 0f
              , hits := [ hit ]
              ]
          ], decoded);
    }
  }
  RETURN decoded;
}

PUBLIC RECORD ARRAY FUNCTION ListOpenSearchIndices(INTEGER indexmanager)
{
  RECORD ARRAY indices := EnforceStructure([[ "uuid" := ""
                                            , "docs.count" := 0
                                            , "pri.store.size" := 0i64
                                            , "pri" := 0
                                            , "index" := ""
                                            , "health" := ""
                                           ]], SendRawJSONToOpenSearch(indexmanager, "GET", '/_cat/indices?format=json&bytes=b', DEFAULT RECORD).result);
  RETURN SELECT uuid
              , docs := indices."docs.count"
              , size := indices."pri.store.size"
              , shards := pri
              , indexname := indices."index"
              , health
              , status
           FROM indices;
}

PUBLIC RECORD ARRAY FUNCTION ListOpenSearchIndexSuffixes(INTEGER indexmanager, STRING forindexname)
{
  RECORD ARRAY indexlist := ListOpenSearchIndices(indexmanager);

  // Unmanaged indices may have a suffix: <indexname>-<suffix>
  indexlist := SELECT TEMPORARY toks := Tokenize(indexname,'-')
                    , indexname := toks[0]
                    , suffix := Length(toks) > 1 ? toks[1] : ""
                    , health
                    , status
                    , docs
                    , size
                 FROM indexlist
                WHERE indexname LIKE VAR forindexname || "-*"
                      OR indexname = VAR forindexname;

  RETURN SELECT suffix FROM indexlist; //TODO more columns..
}

PUBLIC RECORD FUNCTION GetOpenSearchCurrentMapping(INTEGER indexmanagermapping, STRING indexname, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ suffix := "" // Sub-index suffix, for unmanaged indices, OpenSearch only
      ], options);

  RECORD response := SendRawJSONToOpenSearch(indexmanagermapping, "GET", indexname || "/_mapping", DEFAULT RECORD);

  RECORD mappings := GetCell(response.result, indexname).mappings;
  mappings := EnforceStructure([ dynamic_templates := RECORD[]], mappings);
  RETURN mappings;
}

PUBLIC RECORD ARRAY FUNCTION VerifyOpensearchMapping(INTEGER indexmanager, STRING indexname, STRING suffix, RECORD ARRAY expectedmapping)
{
  IF(suffix != "") ABORT("TODO implement suffixs upported");
  RECORD res := GetOpenSearchCurrentMapping(indexmanager, indexname);
  RETURN CompareMappings(res, expectedmapping, "");
}
