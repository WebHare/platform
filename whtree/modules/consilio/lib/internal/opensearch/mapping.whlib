<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::javascript.whlib";
LOADLIB "wh::xml/xsd.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/internal/contentsources.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";

LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


RECORD FUNCTION GetIndexFieldDefinitionNode(STRING name, STRING type)
{
  IF(name NOT LIKE "?*:?*" OR name LIKE "*:*:*")
    THROW NEW Exception(`No such definition '${name}'`);

  STRING ARRAY parts := Tokenize(name, ':');
  OBJECT xmldoc := GetModuleDefinitionXML(parts[0]); //FIXME require validation to succeed ? use lastknown good if so unless on test/dev?
  FOREVERY(OBJECT consilionode FROM xmldoc->documentelement->ListChildren("http://www.webhare.net/xmlns/system/moduledefinition", "consilio"))
    FOREVERY(OBJECT indexnode FROM consilionode->ListChildren("http://www.webhare.net/xmlns/system/moduledefinition", type))
      IF(indexnode->localname = type AND indexnode->GetAttribute("tag") = parts[1])
        RETURN CELL[ line := indexnode->linenum
                   , resourcename := GetModuleDefinitionXMLResourceName(parts[0])
                   , node := indexnode
                   ];

  RETURN DEFAULT RECORD;
}

CONSTANT RECORD defaultparentstate := [ curdepth := 0
                                      ];

RECORD ARRAY FUNCTION GetFieldDefinition(STRING name, STRING type, RECORD parentstate)
{
  IF(name LIKE "<index>*") //Pre-5.0 <index> support. Remove at some point...
  {
    name := Substring(name,7);
    type := "index";
  }

  RECORD node := GetIndexFieldDefinitionNode(name, type);
  IF(NOT RecordExists(node))
    THROW NEW Exception(`Cannot find ${type} mapping '${name}'`);

  RETURN ParseIndexField(node, Tokenize(name,':')[0], parentstate);
}

/// Read the field definition of a fieldgroup from the moduledefinition
PUBLIC RECORD ARRAY FUNCTION GetFieldgroupsFieldDefinition(STRING ARRAY fieldgroups)
{
  RECORD ARRAY properties;
  FOREVERY (STRING fieldgroup FROM fieldgroups)
  {
    RECORD ARRAY fielddefproperties := GetFieldDefinition(fieldgroup, 'fieldgroup', CELL[ ...defaultparentstate ]);
    FOREVERY (RECORD prop FROM fielddefproperties)
    {
      IF (RecordExists(SELECT FROM properties WHERE ToUppercase(name) = ToUppercase(prop.name)))
        THROW NEW Exception(`Duplicate property name '${prop.name}'`);

      INSERT prop INTO properties AT END;
    }
  }
  RETURN properties;
}

STRING FUNCTION QualifyName(STRING qualification, STRING name)
{
  IF (name != "" AND SearchSubstring(name, "*") = -1 AND name NOT LIKE "*:*")
    name := qualification || ":" || name;

  RETURN name;
}

RECORD ARRAY FUNCTION ParseIndexField(RECORD field, STRING module, RECORD state)
{
  state.curdepth := state.curdepth + 1;
  IF(state.curdepth > 6)
    THROW NEW Exception(`Index is too deep!`);

  RECORD ARRAY properties;
  FOREVERY(OBJECT subfield FROM field.node->ListChildren("*","*"))
  {
    STRING type := subfield->localname;

    IF (type = "customsource")
      CONTINUE;

    IF(type = "addfieldgroup") //inclusion, not a sublevel!
    {
      RECORD ARRAY subresult := GetFieldDefinition(QualifyName(module, subfield->GetAttribute("ref")), "fieldgroup", state);
      properties := properties CONCAT subresult;

      ////TODO conflict check?
      CONTINUE;
    }

    RECORD fielddef := CELL[ name := subfield->GetAttribute("name")
                           , settings := DEFAULT RECORD
                           , suggested := ParseXSBoolean(subfield->GetAttribute("suggested"))
                           , properties := ParseIndexField(CELL[...field, node := subfield], module, state)
                           , type := type
                           , defaultvalue := GetFieldTypeDefaultValue(type)
                           , definedby := `${field.resourcename}:${subfield->linenum}`
                           ];

    IF (subfield->HasAttribute("storeonly"))
      INSERT CELL "index" := NOT ParseXSBoolean(subfield->GetAttribute("storeonly")) INTO fielddef.settings;

    SWITCH(type)
    {
      CASE "text"
      {
        STRING index_options := subfield->GetAttribute("index_options");
        // Defaults to "offsets", which isn't the default for OpenSearch, so adding it here explicitly
        INSERT CELL index_options := index_options ?? "offsets" INTO fielddef.settings;
      }
      CASE "keyword"
      {
        INTEGER ignore_above := ParseXSInt(subfield->GetAttribute("ignore_above"));
        IF (ignore_above != 0)
          INSERT CELL ignore_above := ignore_above INTO fielddef.settings;
      }
      CASE "nested"
      {
        INSERT CELL include_in_parent := ParseXSBoolean(subfield->GetAttribute("include_in_parent")) INTO fielddef.settings;
        INSERT CELL include_in_root := ParseXSBoolean(subfield->GetAttribute("include_in_root")) INTO fielddef.settings;
      }
    }

    INSERT fielddef INTO properties AT END;
  }

  STRING dupename := SELECT AS STRING ANY(name) FROM properties GROUP BY ToUppercase(name) HAVING COUNT(*)>1;
  IF(dupename != "")
    THROW NEW Exception(`Duplicate property name '${dupename}'`);

  RETURN properties;
}

RECORD ARRAY FUNCTION MakeTree(RECORD ARRAY inprops)
{
  RECORD ARRAY treefields := SELECT * FROM inprops WHERE name NOT LIKE "*.*";
  FOREVERY(STRING recordfield FROM SELECT AS STRING ARRAY DISTINCT Tokenize(name,'.')[0] FROM inprops WHERE name LIKE "*.*")
  {
    INSERT [ name := recordfield
           , type := "record"
           , settings := DEFAULT RECORD
           , properties := MakeTree(SELECT *, name := Substring(name, Length(recordfield) + 1) FROM inprops WHERE name LIKE recordfield || ".*")
           , definedby := "GetContentSourcesMapping implicit record"
           ] INTO treefields AT END;
  }

  RETURN treefields;
}

RECORD ARRAY FUNCTION GetContentSourcesMapping(RECORD ARRAY contentsources, STRING catalogtag, RECORD ARRAY basefields)
{
  //TODO: Check for conflicting mappings instead of ignoring subsequent field definitions
  RECORD ARRAY properties := ParseContentSourceMapping(RECORD[], basefields); //TODO Seems dupe with the ParseContentSourceMapping call below but the _body hack probably needs some fixing before combining both

  RECORD ARRAY fields; //gather all fields together so we can do one pass of _suggested generation

  FOREVERY (RECORD contentsource FROM contentsources)
    fields := fields CONCAT GetContentSourceFieldMapping(catalogtag, contentsource);

  properties := EnforceStructure([[ suggested := FALSE ]], properties);
  properties := ParseContentSourceMapping(properties, fields);

  properties := MakeTree(properties);
  RETURN properties;
}

RECORD ARRAY FUNCTION ParseContentSourceMapping(RECORD ARRAY properties, RECORD ARRAY fields)
{
  BOOLEAN have_suggested;

  FOREVERY (RECORD field FROM fields)
  {
    IF (field.name = "_body") //overwrite body settings. FIXME  can't we handle that explicitly?
    {
      STRING fieldname := Substring(field.name, 1);
      INTEGER idx := (SELECT AS INTEGER #properties + 1 FROM properties WHERE name = fieldname) - 1;
      IF (idx >= 0)
      {
        properties[idx] := CELL
            [ ...properties[idx]
            , type := GetTypeFromFieldDef(field)
            ];

        IF(field.suggested)
          properties[idx].suggested := TRUE;

        //set the default for contentsource fields we also set for module mappings..
        IF (properties[idx].type = "text")
          properties[idx].settings := [ index_options := "offsets" ];
      }
    }
    ELSE IF (NOT RecordExists(SELECT FROM properties WHERE name = field.name))
    {
      STRING type := GetTypeFromFieldDef(field);
      INSERT CELL
          [ type
          , defaultvalue := CellExists(field, "defaultvalue") ? field.defaultvalue : GetFieldTypeDefaultValue(type)
          , field.name
            //set the default for contentsource fields we also set for module mappings..
          , settings := type = "text" ? [ index_options := "offsets" ] : DEFAULT RECORD
          , properties := type IN [ "record", "nested" ] ? ParseContentSourceMapping(RECORD[], field.properties) : RECORD[]
          , field.definedby
          , suggested := CellExists(field,"suggested") ? field.suggested : FALSE
          ] INTO properties AT END;
    }
  }
  RETURN properties;
}

STRING FUNCTION GetTypeFromFieldDef(RECORD field)
{
  IF (CellExists(field, "type") AND field.type != "")
  {
    IF (field.type NOT IN supported_field_types)
      THROW NEW Exception(`Unsupported field type '${field.type}'`);
    RETURN field.type;
  }

  IF (CellExists(field, "tokenized") AND field.tokenized)
    RETURN "text"; // analyzer will be added by ParseContentSourceMapping, so it will be applied to defaultmappingfields as well

  SWITCH (TypeID(field.defaultvalue))
  {
    CASE TypeID(STRING),    TypeID(STRING ARRAY)    { RETURN "keyword"; }
    CASE TypeID(INTEGER),   TypeID(INTEGER ARRAY)   { RETURN "integer"; }
    CASE TypeID(INTEGER64), TypeID(INTEGER64 ARRAY) { RETURN "integer64"; }
    CASE TypeID(MONEY),     TypeID(MONEY ARRAY)     { RETURN "money"; }
    CASE TypeID(FLOAT),     TypeID(FLOAT ARRAY)     { RETURN "float"; }
    CASE TypeID(BOOLEAN),   TypeID(BOOLEAN ARRAY)   { RETURN "boolean"; }
    CASE TypeID(DATETIME),  TypeID(DATETIME ARRAY)  { RETURN "datetime"; }
    CASE TypeId(RECORD)                             { RETURN "record"; }
  }
  THROW NEW Exception(`Cannot determine type for field ${field.name}`);
}

VARIANT FUNCTION GetFieldTypeDefaultValue(STRING type)
{
  SWITCH (type)
  {
    CASE "boolean"    { RETURN FALSE; }
    CASE "datetime"   { RETURN DEFAULT DATETIME; }
    CASE "float"      { RETURN 0f; }
    CASE "integer"    { RETURN 0; }
    CASE "integer64"  { RETURN 0i64; }
    CASE "money"      { RETURN 0m; }
    CASE "record"     { RETURN DEFAULT RECORD; }
    CASE "nested"     { RETURN DEFAULT RECORD; }
  }
  RETURN "";
}

STRING FUNCTION GetOpensearchTypeForConsilioType(STRING intype)
{
  SWITCH(intype)
  {
    CASE "keyword", "integer", "boolean", "text", "completion" { RETURN intype; }
    CASE "record"    { RETURN "object"; }
    CASE "nested"    { RETURN "nested"; }
    CASE "integer64" { RETURN "long"; }
    CASE "float"     { RETURN "double"; }
    CASE "datetime"  { RETURN "date"; }
    CASE "latlng"    { RETURN "geo_point"; }
    CASE "ipaddress" { RETURN "ip"; }
    CASE "money"
    {
      // OpenSearch's 'scaled_float' is stored as a long with fixed decimal factor, but is handled (and returned) as a
      // double (scaled_float is just more efficient in storage than double), which only has 53 bits of precision. To be
      // able to use all 64 bit money values, we'll just index them as long values.
      RETURN "long";
    }
    DEFAULT
    {
      THROW NEW Exception(`Unknown field type '${intype}'`);
    }
  }
}

/** @cell input.properties
    @cell return.properties
*/
PUBLIC RECORD FUNCTION PrepareMappingUpdate(RECORD ARRAY input_properties)
{
  RECORD properties := CELL[];
  BOOLEAN strict := TRUE; //initial true until we find a wildcard

  FOREVERY(RECORD prop FROM input_properties)
  {
    IF(prop.type = "ignore")
      CONTINUE;

    RECORD esfielddata := [ type := prop.type
                          , ...prop.settings
                          ];

    RECORD subfields := PrepareMappingUpdate(prop.properties);
    IF(RecordExists(subfields))
    {
      IF(prop.type IN ["record", "nested"])
      {
        //A record has properties - these subfields can individually receive values to index
        INSERT CELL properties := subfields.properties INTO esfielddata;
        INSERT CELL dynamic := subfields.dynamic INTO esfielddata;
      }
      ELSE
      {
        //Other types have fields. these cannot index a separate value, they just receive their parent's value but store it differently
        INSERT CELL fields := subfields.properties INTO esfielddata;
      }
    }

    esfielddata.type := GetOpensearchTypeForConsilioType(prop.type);

    IF(prop.type IN [ "text", "completion" ])
    {
      // Use the default consilio analyzer
      esfielddata := CELL[ analyzer := "consilio_analyzer", ...esfielddata ];

      // For 'text', also index the orignal, non-transformed, tokenized text
      IF (prop.type = "text")
      {
        IF (NOT CellExists(esfielddata, "fields"))
          INSERT CELL fields := DEFAULT RECORD INTO esfielddata;
        INSERT CELL consilio_original := [ type := "text", analyzer := "consilio_original" ] INTO esfielddata.fields;

        // Add offset information to the index, for faster summary generation/result highlighting supporting larger document
        // fields
        IF (NOT CellExists(esfielddata, "index_options"))
          INSERT CELL index_options := "offsets" INTO esfielddata;
      }
    }

    //We used to generate dynamic_templates at various levels, but now we simply keep dynamic to 'false' to add to _source but otherwise ignore wildcards
    IF(SearchSubstring(prop.name,'*') = -1) //plain field
    {
      IF(CellExists(properties,prop.name))
      {
        STRING ARRAY locations := SELECT AS STRING ARRAY DISTINCT definedby FROM input_properties WHERE name = prop.name;
        THROW NEW Exception(`Duplicate field mapping definition for '${prop.name}' (definedby: ${Detokenize(locations,', ')}`);
      }

      properties := CellInsert(properties, prop.name, esfielddata);
    }
    ELSE //wildcard!
    {
      strict := FALSE;
    }
  }

  //https://www.elastic.co/guide/en/elasticsearch/reference/current/dynamic.html
  RETURN CELL[ properties
             , dynamic := strict ? "strict" : "false" //strict: reject all unknown props. false: save in _source but do not index
             ];
}

PUBLIC RECORD FUNCTION CalculateExpectedConfiguration(STRING ARRAY fieldgroups, BOOLEAN managed, STRING catalogtag, RECORD ARRAY contentsources, STRING lang)
{
  /* We need to optimize consilio:site contentsources, a catalog can have hundreds of them but they'll all have the same field definition
     for now we'll just look at the first. ideally we'd get rid of intermediate consilio:custom and contentsources would either declare XML
     (and then we know we only need to check one) or they'd indicate that their mapping is truly dynamic (and there shouldn't be hundreds of those */
  IF(managed AND RecordExists(SELECT FROM contentsources WHERE contentprovider = whconstant_consilio_contentprovider_site))
  {
    INSERT "consilio:sitecontent" INTO fieldgroups AT END;
    DELETE FROM contentsources WHERE contentprovider = whconstant_consilio_contentprovider_site;
  }

  RECORD ARRAY fields := GetFieldgroupsFieldDefinition(GetSortedSet(fieldgroups));

  IF(managed)
  {
    RECORD ARRAY basefields := SELECT *, definedby := "defaultmappingfields" FROM defaultmappingfields;
    fields := fields CONCAT GetContentSourcesMapping(contentsources, catalogtag, basefields);
  }

  IF(catalogtag = "platform:pxl") //TODO make configurable and use for consilio:whfs too... but let's not bother until we port the fieldmaps to YML and this management code to TS
    fields := CallJS("@mod-platform/js/logging/accesslog.ts#addPxlFieldMappings", fields);

  // If there are any suggested fields, add a '_suggested' field with 'completion' type (TODO support 'deeper' suggested fields)
  STRING ARRAY suggestedfields := (SELECT AS STRING ARRAY name FROM fields WHERE suggested);
  IF(Length(suggestedfields) > 0)
  {
    INSERT
        [ name := "_suggested"
        , type := "completion"
        , settings := [ analyzer := "consilio_analyzer" ]
        , properties := RECORD[]
        //, strict := TRUE
        , defaultvalue := DEFAULT RECORD
        , definedby := "CalculateExpectedConfiguration implicit completion field"
        //Putting this here, maybe we'll have multiple suggested fields in the future. Prefix with __ because 'maybe'
        , __suggestedfields := suggestedfields
        ] INTO fields AT END;
  }

  RETURN CELL[ fields, lang ];
}

PUBLIC RECORD FUNCTION BuildInternalMetadataFromConfiguration(RECORD config)
{
  RETURN CELL[ config.fields
             , config.lang
             , lastupdate := GetCurrentDatetime()
             ];

}

PUBLIC RECORD ARRAY FUNCTION CompareMappings(RECORD res, RECORD ARRAY exp, STRING currentprefix)
{
  RECORD ARRAY current;
  IF(RecordExists(res) AND CellExists(res,'properties'))
    current := UnpackRecord(res.properties); //mapping as reported by opensearch

  RECORD ARRAY mismatches;
  FOREVERY(RECORD row FROM exp)
  {
    STRING field := currentprefix || row.name;

    IF(Right(row.name,1) = '*') //we're requesting a wildcard here...
    {
      //Matches all fields matching the pattern
      DELETE FROM current WHERE ToUppercase(current.name) LIKE ToUppercase(row.name);
      //TODO we should probably be checking the dynamic templates whether they agree with the field definition(s)
      CONTINUE;
    }

    IF(row.type = "ignore")
    {
      DELETE FROM current WHERE ToUppercase(current.name) LIKE ToUppercase(row.name);
      CONTINUE; //we won't report it as superfluous but will otherwise ignore it
    }

    RECORD match := SELECT * FROM current WHERE Touppercase(current.name) = ToUppercase(row.name);
    IF(NOT RecordExists(match))
    {
      INSERT CELL [ field, row.definedby, issue := "missing", message := `Not present in current mapping` ] INTO mismatches AT END;
    }
    ELSE
    {
      //dumpvalue(cell[match,row],'tree');
      STRING expectfieldtype := GetOpensearchTypeForConsilioType(row.type);
      STRING currentfieldtype := CellExists(match.value, "type") ? match.value.type : CellExists(match.value, "properties") ? "object" : "";

      IF(expectfieldtype != currentfieldtype)
      {
        INSERT CELL [ field, row.definedby, issue := "typemismatch", message := `Expected type '${expectfieldtype}' but mapped as '${currentfieldtype}'`] INTO mismatches AT END;
      }
      ELSE IF (row.type = "text")
      {
        STRING expectindexoptions := CellExists(row, "settings") AND CellExists(row.settings, "index_options") ? row.settings.index_options : "offsets";
        STRING currentindexoptions := CellExists(match.value, "index_options") ? match.value.index_options : "";
        IF (expectindexoptions != currentindexoptions)
          INSERT CELL [ field, row.definedby, issue := "parammismatch", message := `Expected param 'index_options' with value '${expectindexoptions}' but got '${currentindexoptions}'`] INTO mismatches AT END;
      }
      ELSE IF (row.type = "keyword")
      {
        INTEGER expectignoreabove := CellExists(row, "settings") AND CellExists(row.settings, "ignore_above") ? row.settings.ignore_above : 0;
        INTEGER currentignoreabove := CellExists(match.value, "ignore_above") ? match.value.ignore_above : 0;
        IF (expectignoreabove != currentignoreabove)
          INSERT CELL [ field, row.definedby, issue := "parammismatch", message := `Expected param 'ignore_above' with value '${expectignoreabove}' but got '${currentignoreabove}'`] INTO mismatches AT END;
      }
      ELSE IF (row.type = "nested")
      {
        FOREVERY (STRING setting FROM [ "include_in_parent", "include_in_root"])
        {
          BOOLEAN expectinclude := CellExists(row, "settings") AND CellExists(row.settings, setting) AND GetCell(row.settings, setting);
          BOOLEAN currentinclude := CellExists(match.value, setting) AND GetCell(match.value, setting);
          IF (expectinclude != currentinclude)
            INSERT CELL [ field, row.definedby, issue := "parammismatch", message := `Expected param '${setting}' with value '${expectinclude ? "true": "false"}' but got '${currentinclude ? "true": "false"}'`] INTO mismatches AT END;
        }
      }
      //TODO compare analyzer settings, compare the subfields generated by the analyzers
      DELETE FROM current WHERE current.name = match.name;
    }

    IF(row.type IN [ "record", "nested" ]) //deeper types to compare
    {
      mismatches := mismatches CONCAT CompareMappings(RecordExists(match) ? match.value : DEFAULT RECORD, row.properties, field || '.');
    }
  }

  FOREVERY(RECORD superfluous FROM current)
  {
    STRING field := currentprefix || ToLowercase(superfluous.name);
    INSERT CELL [ field, definedby := "", issue := "superfluous", message := `Not expected in current mapping` ] INTO mismatches AT END;
    IF(CellExists(superfluous.value, 'properties'))
      mismatches := mismatches CONCAT CompareMappings(superfluous.value, RECORD[], field || '.');
  }
  RETURN mismatches;
}
