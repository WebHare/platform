<?wh

LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";

PUBLIC RECORD ARRAY FUNCTION GetRequiredCatalogs(BOOLEAN ignoreerrors, STRING catalogmask) //consilio:update needs to show errors, catalog.whlib parsers don't
{
  //Figure out which catalogs to create..
  RECORD ARRAY wantcatalogs;
  FOREVERY(RECORD catalognode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "catalog"))
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${catalognode.module}:${catalognode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(catalognode.node->Getattribute("priority"))
                          , definedby := "<catalog> " || catalognode.resource || ":" || catalognode.node->linenum
                          , sourcemodule := catalognode.module
                          , contentsources := RECORD[]
                          , managed := NOT catalognode.node->HasAttribute("managed") OR ParseXSBoolean(catalognode.node->GetAttribute("managed"))
                          , suffixed := ParseXSBoolean(catalognode.node->GetAttribute("suffixed"))
                          , fieldgroups := ParseAndQualifyXMLList(catalognode.module, catalognode.node->GetAttribute("fieldgroups"))
                          , lang := catalognode.node->GetAttribute("lang")
                          ];

    IF(catalog.tag NOT LIKE catalogmask)
      CONTINUE;

    STRING ongetsources := MakeAbsoluteResourcePath(catalognode.resource, catalognode.node->GetAttribute("ongetsources"));
    IF(ongetsources != "")
    {
      TRY
      {
        catalog.contentsources := EnforceStructure([[ definedby := "<catalog ongetsources> " || ongetsources
                                                    , fsobject := 0
                                                    , contentobject := ""
                                                    , tag := ""
                                                   ]], MakeFunctionPtr(ongetsources, TYPEID(RECORD ARRAY), [TYPEID(STRING)])(catalog.tag));
      }
      CATCH(OBJECT e)
      {
        IF(NOT ignoreerrors)
        {
          LogHarescriptException(e);
          Print(`ongetsources failed for catalog '${catalog.tag}': ${e->what}\n`);
        }
        CONTINUE; //don't update the catalog then..
      }
    }

    FOREVERY(OBJECT customsource FROM catalognode.node->ListElements(catalognode.node->namespaceuri, "customsource"))
    {
      INSERT [[ definedby :=  "<customsource> " || catalognode.resource || ":" || customsource->linenum
              , fsobject := 0
              , contentobject := MakeAbsoluteResourcePath(catalognode.resource, customsource->GetAttribute("contentobject"))
              , tag := `${catalognode.module}:${customsource->GetAttribute("tag")}`
              ]
             ] INTO catalog.contentsources AT END;
    }

    INSERT catalog INTO wantcatalogs AT END;
  }

  RECORD siteprofs := GetCachedSiteProfiles();
  FOREVERY (RECORD addtocatalog FROM siteprofs.addtocatalogs)
  {
    IF(addtocatalog.catalog NOT LIKE catalogmask)
      CONTINUE; //out of scope

    INTEGER matchcatalog := (SELECT AS INTEGER #wantcatalogs + 1 FROM wantcatalogs WHERE wantcatalogs.tag = addtocatalog.catalog)-1;
    IF(matchcatalog = -1)
    {
      //TODO make sure the error goes somewhere recorded/validateable/reportable
      IF(NOT ignoreerrors)
        PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to undefined catalog '${addtocatalog.catalog}'\n`);
      CONTINUE;
    }

    INSERT CELL definedby := "<addtocatalog> " || addtocatalog.siteprofile || ":" || addtocatalog.line INTO addtocatalog;
    FOREVERY(INTEGER siteid FROM GetSiteSettingIDs(addtocatalog))
    {
      OBJECT site := OpenSite(siteid);
      IF(NOT ObjectExists(site))
        CONTINUE; //race, just deleted ?

      INTEGER ARRAY addfolders;
      OBJECT target := site->OpenByPath(addtocatalog.folder, [ allowinitialslash := TRUE ]);
      IF(NOT ObjectExists(target) OR NOT target->isfolder)
      {
        IF(NOT ignoreerrors)
          PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to nonexisting folder '${addtocatalog.folder}' in site '${site->name}'\n`);
        CONTINUE;
      }

      IF(addtocatalog.foldertype != "") {
        OBJECT targettype := OpenWHFSType(addtocatalog.foldertype);
        IF(NOT ObjectExists(targettype)) {
          IF(NOT ignoreerrors)
            PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to nonexisting type '${addtocatalog.foldertype}'\n`);
          CONTINUE;
        }
        addfolders := SELECT AS INTEGER ARRAY id FROM system.fs_objects
                       WHERE type = targettype->id
                             AND isfolder = TRUE
                             AND parentsite = site->id
                             AND ToUppercase(fullpath) LIKE ToUppercase(target->fullpath) || "*";
      } ELSE {
        addfolders := INTEGER[target->id];
      }

      FOREVERY(INTEGER folder FROM addfolders)
        INSERT CELL[ ...addtocatalog
                  , fsobject := folder
                  , contentobject := ""
                  , tag := ""
                  ] INTO wantcatalogs[matchcatalog].contentsources AT END;
    }
  }

  RETURN wantcatalogs;
}
