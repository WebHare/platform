<?wh

LOADLIB "wh::adhoccache.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/modules/defreader.whlib";


PUBLIC CONSTANT STRING ARRAY supported_field_types :=
    [ "boolean", "completion", "datetime", "float", "integer", "integer64", "ipaddress", "keyword", "latlng", "money", "record", "nested", "text" ];

/** @short Get all content providers as offered by all modules
    @return All available content providers
    @cell return.name The content provider name
    @cell return.tid Tid for the content provider title
    @cell return.settings Name of the provider's settings screen
    @cell return.createcontentprovider A function which returns a content provider object
*/
PUBLIC RECORD ARRAY FUNCTION GetContentProviders()
{
  RECORD ARRAY contentproviders := GetAdHocCached([ type := "contentproviders" ], PTR GetContentProviders_Uncached);
  RETURN SELECT name
              , title
              , icon
              , createcontentprovider := PTR MakeObject(contentproviderobject)
           FROM contentproviders;
}

RECORD FUNCTION GetContentProviders_Uncached()
{
  RECORD ARRAY contentproviders;
  FOREVERY (RECORD module FROM GetWebHareModules())
  {
    FOREVERY (RECORD cp FROM module.contentproviders)
    {
      INSERT [ name := cp.name
             , title := cp.title
             , icon := cp.icon
             , contentproviderobject := cp.contentproviderobject
             ] INTO contentproviders AT END;
    }
  }
  RETURN [ value := contentproviders
         , ttl := 6 * 60 * 60 * 1000 // Can be cached until next cache/soft reset, but provide some number now
         ];
}

/** Construct the provider for this source
    @return Contentprovider object
*/
PUBLIC OBJECT FUNCTION OpenContentSourceProvider(STRING catalogtag, RECORD contentsource)
{
  RECORD cprec := SELECT * FROM GetContentProviders() WHERE name = contentsource.contentprovider;
  IF (NOT RecordExists(cprec))
    THROW NEW Exception(`Content provider '${contentsource.contentprovider}' not found for content source #${contentsource.id}`);

  OBJECT cpobj := cprec.createcontentprovider();

  // Decode the source-specific data
  RECORD source := contentsource;
  RECORD csdata := DecodeHSON(source.__data);
  DELETE CELL data FROM source;
  INSERT CELL data := csdata INTO source;

  // Add the contentlinksonly flag (in the future this might be made configurable)
  INSERT CELL contentlinksonly := ReadRegistryKey("consilio.linkchecker.contentlinksonly") INTO source;

  source := CELL[ ...source
                , contentobject := CellExists(csdata,'contentobject') ? csdata.library || "#" || csdata.contentobject : ""
                , contentsourceid := contentsource.id
                , contentsourcetag := contentsource.tag
                , catalogtag := catalogtag
                ];
  cpobj->Init(source);
  RETURN cpobj;
}

RECORD ARRAY FUNCTION ParseFieldMapping(RECORD ARRAY mapping, STRING definedby)
{
  RECORD ARRAY fields;
  FOREVERY(RECORD field FROM mapping)
  {
    field := ValidateOptions([ name := ""
                             , value := ""
                             , type := ""
                             , tokenized := FALSE
                             , suggested := FALSE
                             , properties := RECORD[]
                             ], field, [ title := `fields[${#field}]`
                                       , notypecheck := ["value"]
                                       , optional := ["tokenized"]
                                       , required := ["name"]
                                       ]);

    IF(field.name LIKE "*.*")
      THROW NEW Exception(`Incorrect attempt to setup a twolevel arrayfield (field '${field.name}'), place submembers into 'properties'`);

    IF (field.type != "" AND field.type NOT IN supported_field_types)
      THROW NEW Exception(`Unsupported field type '${field.type}'`);

    field.properties := ParseFieldMapping(field.properties, definedby);

    VARIANT defaultvalue;
    IF(CellExists(field, "value"))
      defaultvalue := field.value;
    ELSE
      defaultvalue := "";

    IF(NOT CellExists(field,'tokenized'))
      INSERT CELL tokenized := CellExists(field, "value") AND TypeID(field.value) = TypeID(STRING) INTO field;

    INSERT CELL defaultvalue := defaultvalue INTO field;
    INSERT CELL definedby := definedby INTO field;
    DELETE CELL value FROM field;
    INSERT field INTO fields AT END;
  }
  RETURN fields;
}

PUBLIC RECORD ARRAY FUNCTION GetContentSourceFieldMapping(STRING catalogtag, RECORD contentsource)
{
  OBJECT prov := OpenContentSourceProvider(catalogtag, contentsource);
  RECORD ARRAY fields;
  TRY
    fields := ParseFieldMapping(prov->GetMapping(), contentsource.definedby);
  FINALLY
    prov->Close();

  RETURN fields;
}
