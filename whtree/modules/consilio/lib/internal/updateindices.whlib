<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";

LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

RECORD ARRAY FUNCTION GetRequiredCatalogs()
{
  //Figure out which catalogs to create..
  RECORD ARRAY wantcatalogs;
  FOREVERY(RECORD catalognode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "catalog"))
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${catalognode.module}:${catalognode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(catalognode.node->Getattribute("priority"))
                          , definedby := "<catalog> " || catalognode.resource || ":" || catalognode.node->linenum
                          , sourcemodule := catalognode.module
                          , contentsources := RECORD[]
                          , managed := NOT catalognode.node->HasAttribute("managed") OR ParseXSBoolean(catalognode.node->GetAttribute("managed"))
                          , suffixed := ParseXSBoolean(catalognode.node->GetAttribute("suffixed"))
                          , fieldgroups := ParseAndQualifyXMLList(catalognode.module, catalognode.node->GetAttribute("fieldgroups"))
                          , lang := catalognode.node->GetAttribute("lang")
                          ];

    STRING ongetsources := MakeAbsoluteResourcePath(catalognode.resource, catalognode.node->GetAttribute("ongetsources"));
    IF(ongetsources != "")
      catalog.contentsources := EnforceStructure([[ definedby := "<catalog ongetsources> " || ongetsources
                                                  , fsobject := 0
                                                  , contentobject := ""
                                                  , tag := ""
                                                 ]], MakeFunctionPtr(ongetsources, TYPEID(RECORD ARRAY), INTEGER[])());

    FOREVERY(OBJECT customsource FROM catalognode.node->ListElements(catalognode.node->namespaceuri, "customsource"))
    {
      INSERT [[ definedby :=  "<customsource> " || catalognode.resource || ":" || customsource->linenum
              , fsobject := 0
              , contentobject := MakeAbsoluteResourcePath(catalognode.resource, customsource->GetAttribute("contentobject"))
              , tag := `${catalognode.module}:${customsource->GetAttribute("tag")}`
              ]
             ] INTO catalog.contentsources AT END;
    }

    INSERT catalog INTO wantcatalogs AT END;
  }

  FOREVERY(RECORD indexnode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "index")) //support for <index> should be dropped ASAP
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${indexnode.module}:${indexnode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(indexnode.node->Getattribute("priority"))
                          , definedby := "<index> " || indexnode.resource || ":" || indexnode.node->linenum
                          , sourcemodule := indexnode.module
                          , contentsources := RECORD[]
                          , managed := FALSE
                          , suffixed := TRUE
                          , fieldgroups := [ `<index>${indexnode.module}:${indexnode.node->GetAttribute("tag")}` ]
                          , lang := ""
                          ];

    INSERT catalog INTO wantcatalogs AT END;
  }

  RECORD siteprofs := GetCachedSiteProfiles();
  FOREVERY (RECORD addtocatalog FROM siteprofs.addtocatalogs)
  {
    INTEGER matchcatalog := (SELECT AS INTEGER #wantcatalogs + 1 FROM wantcatalogs WHERE wantcatalogs.tag = addtocatalog.catalog)-1;
    IF(matchcatalog = -1)
    {
      //TODO make sure the error goes somewhere recorded/validateable/reportable
      PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to undefined catalog '${addtocatalog.catalog}'\n`);
      CONTINUE;
    }

    INSERT CELL definedby := "<addtocatalog> " || addtocatalog.siteprofile || ":" || addtocatalog.line INTO addtocatalog;
    FOREVERY(INTEGER siteid FROM GetSiteSettingIDs(addtocatalog))
    {
      OBJECT site := OpenSite(siteid);
      IF(NOT ObjectExists(site))
        CONTINUE; //race, just deleted ?

      OBJECT target := site->OpenByPath(addtocatalog.folder, [ allowinitialslash := TRUE ]);
      IF(NOT ObjectExists(target) OR NOT target->isfolder)
      {
        PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to nonexisting folder '${addtocatalog.folder}' in site '${site->name}'\n`);
        CONTINUE;
      }
      INSERT CELL[ ...addtocatalog
                 , fsobject := target->id
                 , contentobject := ""
                 , tag := ""
                 ] INTO wantcatalogs[matchcatalog].contentsources AT END;
    }
  }

  RETURN wantcatalogs;
}

MACRO UpdateManagedCatalog(OBJECT catalog, RECORD want)
{
  RECORD ARRAY currentsources := catalog->ListContentSources();
  FOREVERY(RECORD source FROM want.contentsources)
  {
    INTEGER matchpos := (SELECT AS INTEGER #currentsources + 1
                           FROM currentsources
                          WHERE contentprovider = (source.contentobject != "" ? "consilio:custom" : "publisher:webhare")
                                AND fsobject = source.fsobject
                                AND ToUppercase(tag) = ToUppercase(source.tag)) - 1;

    IF(matchpos >= 0)
    {
      STRING expect_library, expect_contentobject;
      IF(source.contentobject != "")
      {
        expect_library := Tokenize(source.contentobject,'#')[0];
        expect_contentobject := Tokenize(source.contentobject,'#')[1];
      }

      OBJECT contentsource := catalog->OpenContentSourceById(currentsources[matchpos].id);
      IF(currentsources[matchpos].definedby != source.definedby
         OR currentsources[matchpos].contentobject != source.contentobject)
      {
        contentsource->UpdateContentSource(CELL
            [ source.definedby
            , settings := CELL[library := expect_library, contentobject := expect_contentobject]
            , tag := source.tag
            ]);
      }

      IF(currentsources[matchpos].isorphan)
        contentsource->__ReactivateContentSource();

      contentsource->__OpenProvider()->UpdateContentSourceFields();

      DELETE FROM currentsources AT matchpos; //remove from cleanup list
      CONTINUE;
    }

    TRY
    {
      IF(source.contentobject = "")
        catalog->AddPublisherContentSource(source.fsobject, CELL[ source.definedby ]);
      ELSE
        catalog->AddCustomContentSource(source.tag, source.contentobject, CELL[ source.definedby ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2,`Failed to add catalog from ${source.definedby}: ${e->what}\n`);
      CONTINUE;
    }
  }

  //mark unreferred catalogs as orphan
  FOREVERY(RECORD makeorphansource FROM SELECT * FROM currentsources WHERE NOT isorphan)
    catalog->OpenContentSourceById(makeorphansource.id)->__MarkAsOrphan();
}

MACRO UpdateModuleCatalogs(RECORD options)
{
  OBJECT trans := GetPrimary();
  IF (NOT trans->ColumnExists("consilio", "indexmanagers", "id"))
    RETURN; //consilio is not initialized yet!

  RECORD ARRAY wantcatalogs := SELECT *
                                    , catalog := DEFAULT OBJECT
                                 FROM GetRequiredCatalogs()
                                WHERE ToUppercase(tag) LIKE ToUppercase(options.catalogmask);

  BOOLEAN havedefaultindexmanager := RecordExists(SELECT FROM ListIndexManagers() WHERE isdefault);

  trans->BeginWork();
  FOREVERY(RECORD want FROM wantcatalogs)
  {
    OBJECT catalog := OpenConsilioCatalog(want.tag);
    IF(NOT ObjectExists(catalog))
    {
      IF(want.managed AND NOT havedefaultindexmanager)
        CONTINUE; //we cannot create catalogs if the defaultindexmanager doesn't exist (yet)

       catalog := CreateConsilioCatalog(want.tag, CELL[ want.managed, want.lang, want.suffixed ]);
    }
    wantcatalogs[#want].catalog := catalog;
    IF(catalog->managed != want.managed)
    {
      PrintTo(2, `Catalog '${want.tag} is incorrectly ${catalog->managed ? "" : "not "}managed, it probably needs to be recreated\n`);
      CONTINUE;
    }

    TRY
    {
      //UpdateCatalog will not do unneeded changes but *will* reverify and update the mapping based on fieldgroups and contentsources.
      catalog->UpdateCatalog( CELL[ want.definedby, want.lang, want.suffixed, want.fieldgroups ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2, `Failed to update catalog '${want.tag}: ${e->what}\n`);
      CONTINUE;
    }

    IF(want.managed)
      UpdateManagedCatalog(catalog, want);
  }
  trans->CommitWork();

  FOREVERY(RECORD want FROM wantcatalogs)
  {
    IF(want.managed AND ObjectExists(want.catalog) AND want.catalog->managed)
    {
      want.catalog->ApplyConfiguration(); //ensure any config is fresh/uptodate

      IF(NOT want.catalog->suffixed)
        FOREVERY(RECORD opensearch FROM SELECT * FROM want.catalog->ListAttachedIndices() WHERE type = "opensearch")
        {
          RECORD res := GetOpenSearchCurrentMapping(opensearch.indexmanager, opensearch.indexname);
          RECORD ARRAY exp := want.catalog->GetExpectedMapping();
          FOREVERY(RECORD issue FROM CompareMappings(res,exp,""))
          {
            //Not sure about printing to 2... once we have a way to fix/snooze/perma--ignore such issues ?
            Print(`Catalog ${want.catalog->tag} index ${opensearch.indexname}: field '${issue.field}': ${issue.message}\n`);
          }
        }
    }
  }
}

PUBLIC MACRO FixConsilioIndices(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ reportmissing := FALSE
      , catalogmask := "*"
      ], options);

  OBJECT lock := OpenLockManager()->LockMutex("consilio:updateindices");
  TRY
  {
    UpdateModuleCatalogs(options);
  }
  FINALLY
  {
    lock->Release();
  }

  // Broadcast indexfields event to reset cached module index fields (publisher search)
  BroadcastEvent("consilio:indexfields", DEFAULT RECORD);//TODO is this still needed? but UpdateConsilioIndices, now removed, broadcasted it
}
