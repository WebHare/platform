<?wh

LOADLIB "wh::ipc.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";

LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


RECORD ARRAY FUNCTION GetRequiredCatalogs()
{
  //Figure out which catalogs to create..
  RECORD ARRAY wantcatalogs;
  FOREVERY(RECORD catalognode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "catalog"))
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${catalognode.module}:${catalognode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(catalognode.node->Getattribute("priority"))
                          , definedby := "<catalog> " || catalognode.resource || ":" || catalognode.node->linenum
                          , sourcemodule := catalognode.module
                          , contentsources := RECORD[]
                          , managed := NOT catalognode.node->HasAttribute("managed") OR ParseXSBoolean(catalognode.node->GetAttribute("managed"))
                          , suffixed := ParseXSBoolean(catalognode.node->GetAttribute("suffixed"))
                          , fieldgroups := ParseAndQualifyXMLList(catalognode.module, catalognode.node->GetAttribute("fieldgroups"))
                          , lang := catalognode.node->GetAttribute("lang")
                          ];

    STRING ongetsources := MakeAbsoluteResourcePath(catalognode.resource, catalognode.node->GetAttribute("ongetsources"));
    IF(ongetsources != "")
      catalog.contentsources := EnforceStructure([[ definedby := "<catalog ongetsources> " || ongetsources
                                                  , fsobject := 0
                                                  , contentobject := ""
                                                  , tag := ""
                                                 ]], MakeFunctionPtr(ongetsources, TYPEID(RECORD ARRAY), INTEGER[])());

    FOREVERY(OBJECT customsource FROM catalognode.node->ListElements(catalognode.node->namespaceuri, "customsource"))
    {
      INSERT [[ definedby :=  "<customsource> " || catalognode.resource || ":" || customsource->linenum
              , fsobject := 0
              , contentobject := MakeAbsoluteResourcePath(catalognode.resource, customsource->GetAttribute("contentobject"))
              , tag := `${catalognode.module}:${customsource->GetAttribute("tag")}`
              ]
             ] INTO catalog.contentsources AT END;
    }

    INSERT catalog INTO wantcatalogs AT END;
  }

  FOREVERY(RECORD indexnode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "index")) //support for <index> should be dropped ASAP
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${indexnode.module}:${indexnode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(indexnode.node->Getattribute("priority"))
                          , definedby := "<index> " || indexnode.resource || ":" || indexnode.node->linenum
                          , sourcemodule := indexnode.module
                          , contentsources := RECORD[]
                          , managed := FALSE
                          , suffixed := TRUE
                          , fieldgroups := [ `<index>${indexnode.module}:${indexnode.node->GetAttribute("tag")}` ]
                          , lang := ""
                          ];

    INSERT catalog INTO wantcatalogs AT END;
  }

  RECORD siteprofs := GetCachedSiteProfiles();
  FOREVERY (RECORD addtocatalog FROM siteprofs.addtocatalogs)
  {
    INTEGER matchcatalog := (SELECT AS INTEGER #wantcatalogs + 1 FROM wantcatalogs WHERE wantcatalogs.tag = addtocatalog.catalog)-1;
    IF(matchcatalog = -1)
    {
      //TODO make sure the error goes somewhere recorded/validateable/reportable
      PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to undefined catalog '${addtocatalog.catalog}'\n`);
      CONTINUE;
    }

    INSERT CELL definedby := "<addtocatalog> " || addtocatalog.siteprofile || ":" || addtocatalog.line INTO addtocatalog;
    FOREVERY(INTEGER siteid FROM GetSiteSettingIDs(addtocatalog))
    {
      OBJECT site := OpenSite(siteid);
      IF(NOT ObjectExists(site))
        CONTINUE; //race, just deleted ?

      OBJECT target := site->OpenByPath(addtocatalog.folder, [ allowinitialslash := TRUE ]);
      IF(NOT ObjectExists(target) OR NOT target->isfolder)
      {
        PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to nonexisting folder '${addtocatalog.folder}' in site '${site->name}'\n`);
        CONTINUE;
      }
      INSERT CELL[ ...addtocatalog
                 , fsobject := target->id
                 , contentobject := ""
                 , tag := ""
                 ] INTO wantcatalogs[matchcatalog].contentsources AT END;
    }
  }

  RETURN wantcatalogs;
}

MACRO UpdateManagedCatalog(OBJECT catalog, RECORD want, RECORD options)
{
  RECORD ARRAY currentsources := catalog->ListContentSources();
  FOREVERY(RECORD source FROM want.contentsources)
  {
    INTEGER matchpos := (SELECT AS INTEGER #currentsources + 1
                           FROM currentsources
                          WHERE contentprovider = (source.contentobject != "" ? "consilio:custom" : VAR whconstant_consilio_contentprovider_site)
                                AND fsobject = source.fsobject
                                AND ToUppercase(tag) = ToUppercase(source.tag)) - 1;

    IF(matchpos >= 0)
    {
      STRING expect_library, expect_contentobject;
      IF(source.contentobject != "")
      {
        expect_library := Tokenize(source.contentobject,'#')[0];
        expect_contentobject := Tokenize(source.contentobject,'#')[1];
      }

      OBJECT contentsource := catalog->OpenContentSourceById(currentsources[matchpos].id);
      IF(currentsources[matchpos].definedby != source.definedby
         OR currentsources[matchpos].contentobject != source.contentobject)
      {
        contentsource->UpdateContentSource(CELL
            [ source.definedby
            , settings := CELL[library := expect_library, contentobject := expect_contentobject]
            , tag := source.tag
            ]);
      }

      IF(currentsources[matchpos].isorphan)
        contentsource->__ReactivateContentSource();

      DELETE FROM currentsources AT matchpos; //remove from cleanup list
      CONTINUE;
    }

    TRY
    {
      IF(source.contentobject = "")
        catalog->AddFolderToCatalog(source.fsobject, CELL[ source.definedby ]);
      ELSE
        catalog->AddCustomContentSource(source.tag, source.contentobject, CELL[ source.definedby ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2,`Failed to add catalog from ${source.definedby}: ${e->what}\n`);
      CONTINUE;
    }
  }

  //mark unreferred catalogs as orphan
  FOREVERY(RECORD makeorphansource FROM SELECT * FROM currentsources WHERE NOT isorphan)
    catalog->OpenContentSourceById(makeorphansource.id)->__MarkAsOrphan();
}

BOOLEAN FUNCTION AttemptZap(OBJECT catalog)
{
  IF(NOT catalog->managed)
    RETURN FALSE;

  RECORD ARRAY indices := catalog->ListAttachedIndices();
  IF(Length(indices) != 1 OR NOT indices[0].isbuiltin)
    RETURN FALSE;

  Print(`Reattaching blank index for catalog '${catalog->tag}'\n`);

  GetPrimary()->BeginWork();
  catalog->DetachIndex(indices[0].id);
  catalog->AttachIndex(indices[0].indexmanager);
  GetPrimary()->CommitWork();

  TRY
  {
    catalog->ApplyConfiguration();
  }
  CATCH(OBJECT e)
  {
    PrintTo(2, `Failed to reconfigure recreated indices for catalog '${catalog->tag}': ${e->what}\n`);
  }

  RETURN TRUE;
}

MACRO UpdateModuleCatalogs(RECORD options)
{
  OBJECT trans := GetPrimary();
  IF (NOT trans->ColumnExists("consilio", "indexmanagers", "id"))
    RETURN; //consilio is not initialized yet!

  RECORD ARRAY wantcatalogs := SELECT *
                                    , catalog := DEFAULT OBJECT
                                 FROM GetRequiredCatalogs()
                                WHERE ToUppercase(tag) LIKE ToUppercase(options.catalogmask);

  BOOLEAN havedefaultindexmanager := RecordExists(SELECT FROM ListIndexManagers() WHERE isdefault);

  trans->BeginWork();
  FOREVERY(RECORD want FROM wantcatalogs)
  {
    OBJECT catalog := OpenConsilioCatalog(want.tag);
    IF(NOT ObjectExists(catalog))
    {
      IF(want.managed AND NOT havedefaultindexmanager)
        CONTINUE; //we cannot create catalogs if the defaultindexmanager doesn't exist (yet)

       catalog := CreateConsilioCatalog(want.tag, CELL[ want.managed, want.lang, want.suffixed ]);
    }
    wantcatalogs[#want].catalog := catalog;
    IF(catalog->managed != want.managed)
    {
      PrintTo(2, `Catalog '${want.tag} is incorrectly ${catalog->managed ? "" : "not "}managed, it probably needs to be recreated\n`);
      CONTINUE;
    }

    TRY
    {
      //UpdateCatalog will not do unneeded changes but *will* reverify and update the mapping based on fieldgroups and contentsources.
      catalog->UpdateCatalog( CELL[ want.definedby, want.lang, want.suffixed, want.fieldgroups ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2, `Failed to update catalog '${want.tag}': ${e->what}\n`);
      CONTINUE;
    }

    IF(want.managed)
      UpdateManagedCatalog(catalog, want, options);
  }
  trans->CommitWork();

  FOREVERY(RECORD want FROM wantcatalogs)
  {
    IF(want.managed AND ObjectExists(want.catalog) AND want.catalog->managed)
    {
      RECORD ARRAY indices := want.catalog->ListAttachedIndices();
      IF(Length(indices) = 0)
      {
        Print(`Managed catalog '${want.tag}' has no attached index yet, adding one\n`);
        trans->BeginWork();
        want.catalog->AttachIndex(0);
        want.catalog->ReindexCatalog();
        trans->CommitWork();
      }

      TRY
      {
        // zapbroken can autodestroy 'fix' anything broken, but shouldn't we be first comparing whether the index needs changes before blindly applying mappings everywhere ? (and then get rid of this double-try?)
        want.catalog->ApplyConfiguration(); //ensure any config is fresh/uptodate
      }
      CATCH(OBJECT e)
      {
        LogHarescriptException(e);
        PrintTo(2, `Failed to reconfigure catalog '${want.tag}': ${e->what}\n`);

        IF(options.zapbroken)
          AttemptZap(want.catalog);
      }

      IF(NOT want.catalog->suffixed)
        FOREVERY(RECORD opensearch FROM SELECT * FROM want.catalog->ListAttachedIndices())
        {
          RECORD res := GetOpenSearchCurrentMapping(opensearch.indexmanager, opensearch.indexname);
          RECORD ARRAY exp := want.catalog->GetExpectedMapping();
          RECORD ARRAY issues := CompareMappings(res,exp,"");
          IF(options.zapanymismatch AND AttemptZap(want.catalog))
            BREAK;

          FOREVERY(RECORD issue FROM issues)
          {
            //Not sure about printing to 2... once we have a way to fix/snooze/perma--ignore such issues ?
            Print(`Catalog ${want.catalog->tag} index ${opensearch.indexname}: field '${issue.field}': ${issue.message} (${issue.definedby})\n`);
          }
        }
    }
  }
}

PUBLIC MACRO FixConsilioIndices(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ reportmissing := FALSE
      , catalogmask := "*"
      , zapbroken := FALSE
      , zapanymismatch := FALSE
      ], options);

  OBJECT lock := OpenLockManager()->LockMutex("consilio:updateindices");
  TRY
  {
    UpdateModuleCatalogs(options);
  }
  FINALLY
  {
    lock->Release();
  }

  // Broadcast indexfields event to reset cached module index fields (publisher search)
  BroadcastEvent("consilio:indexfields", DEFAULT RECORD);//TODO is this still needed? but UpdateConsilioIndices, now removed, broadcasted it
}
