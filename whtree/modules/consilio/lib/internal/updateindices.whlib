<?wh

LOADLIB "wh::ipc.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch/mapping.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/finishhandler.whlib";

LOADLIB "mod::publisher/lib/siteapi.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/reader.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/resources.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

MACRO ObsoleteCatalogs(RECORD options)
{
  STRING ARRAY obsoletecatalogs;
  FOREVERY(RECORD catalognode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "obsoletecatalog"))
  {
    STRING catalogname := ToLowercase(`${catalognode.module}:${catalognode.node->GetAttribute("tag")}`);
    INSERT ToUppercase(catalogname) INTO obsoletecatalogs AT END;
  }

  RECORD ARRAY tocleanup := SELECT id, name
                              FROM consilio.catalogs
                              WHERE ToUppercase(name) LIKE ToUppercase(options.catalogmask)
                                    AND ToUppercase(name) IN obsoletecatalogs;
;
  IF(Length(tocleanup) > 0)
  {
    GetPrimary()->BeginWork();
    DELETE FROM consilio.catalogs WHERE id IN (SELECT AS INTEGER ARRAY id FROM tocleanup);
    GetConsilioFinishHandler()->ScheduleCleanup();
    GetPrimary()->CommitWork();
  }
}

RECORD ARRAY FUNCTION GetRequiredCatalogs()
{
  //Figure out which catalogs to create..
  RECORD ARRAY wantcatalogs;
  FOREVERY(RECORD catalognode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "catalog"))
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${catalognode.module}:${catalognode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(catalognode.node->Getattribute("priority"))
                          , definedby := "<catalog> " || catalognode.resource || ":" || catalognode.node->linenum
                          , sourcemodule := catalognode.module
                          , contentsources := RECORD[]
                          , managed := NOT catalognode.node->HasAttribute("managed") OR ParseXSBoolean(catalognode.node->GetAttribute("managed"))
                          , suffixed := ParseXSBoolean(catalognode.node->GetAttribute("suffixed"))
                          , fieldgroups := ParseAndQualifyXMLList(catalognode.module, catalognode.node->GetAttribute("fieldgroups"))
                          , lang := catalognode.node->GetAttribute("lang")
                          ];

    STRING ongetsources := MakeAbsoluteResourcePath(catalognode.resource, catalognode.node->GetAttribute("ongetsources"));
    IF(ongetsources != "")
    {
      TRY
      {
        catalog.contentsources := EnforceStructure([[ definedby := "<catalog ongetsources> " || ongetsources
                                                    , fsobject := 0
                                                    , contentobject := ""
                                                    , tag := ""
                                                   ]], MakeFunctionPtr(ongetsources, TYPEID(RECORD ARRAY), [TYPEID(STRING)])(catalog.tag));
      }
      CATCH(OBJECT e)
      {
        LogHarescriptException(e);
        Print(`ongetsources failed for catalog '${catalog.tag}': ${e->what}\n`);
        CONTINUE; //don't update the catalog then..
      }
    }

    FOREVERY(OBJECT customsource FROM catalognode.node->ListElements(catalognode.node->namespaceuri, "customsource"))
    {
      INSERT [[ definedby :=  "<customsource> " || catalognode.resource || ":" || customsource->linenum
              , fsobject := 0
              , contentobject := MakeAbsoluteResourcePath(catalognode.resource, customsource->GetAttribute("contentobject"))
              , tag := `${catalognode.module}:${customsource->GetAttribute("tag")}`
              ]
             ] INTO catalog.contentsources AT END;
    }

    INSERT catalog INTO wantcatalogs AT END;
  }

  FOREVERY(RECORD indexnode FROM GetCustomModuleSettings("http://www.webhare.net/xmlns/system/moduledefinition", "index")) //support for <index> should be dropped ASAP
  {
    RECORD catalog := CELL[ tag := ToLowercase(`${indexnode.module}:${indexnode.node->GetAttribute("tag")}`)
                          , priority := ParseXSInt(indexnode.node->Getattribute("priority"))
                          , definedby := "<index> " || indexnode.resource || ":" || indexnode.node->linenum
                          , sourcemodule := indexnode.module
                          , contentsources := RECORD[]
                          , managed := FALSE
                          , suffixed := TRUE
                          , fieldgroups := [ `<index>${indexnode.module}:${indexnode.node->GetAttribute("tag")}` ]
                          , lang := ""
                          ];

    INSERT catalog INTO wantcatalogs AT END;
  }

  RECORD siteprofs := GetCachedSiteProfiles();
  FOREVERY (RECORD addtocatalog FROM siteprofs.addtocatalogs)
  {
    INTEGER matchcatalog := (SELECT AS INTEGER #wantcatalogs + 1 FROM wantcatalogs WHERE wantcatalogs.tag = addtocatalog.catalog)-1;
    IF(matchcatalog = -1)
    {
      //TODO make sure the error goes somewhere recorded/validateable/reportable
      PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to undefined catalog '${addtocatalog.catalog}'\n`);
      CONTINUE;
    }

    INSERT CELL definedby := "<addtocatalog> " || addtocatalog.siteprofile || ":" || addtocatalog.line INTO addtocatalog;
    FOREVERY(INTEGER siteid FROM GetSiteSettingIDs(addtocatalog))
    {
      OBJECT site := OpenSite(siteid);
      IF(NOT ObjectExists(site))
        CONTINUE; //race, just deleted ?

      OBJECT target := site->OpenByPath(addtocatalog.folder, [ allowinitialslash := TRUE ]);
      IF(NOT ObjectExists(target) OR NOT target->isfolder)
      {
        PrintTo(2,`<addtocatalog> on ${addtocatalog.siteprofile}:${addtocatalog.line} refers to nonexisting folder '${addtocatalog.folder}' in site '${site->name}'\n`);
        CONTINUE;
      }
      INSERT CELL[ ...addtocatalog
                 , fsobject := target->id
                 , contentobject := ""
                 , tag := ""
                 ] INTO wantcatalogs[matchcatalog].contentsources AT END;
    }
  }

  RETURN wantcatalogs;
}

MACRO UpdateManagedCatalog(OBJECT catalog, RECORD want, RECORD options)
{
  RECORD ARRAY currentsources := catalog->ListContentSources([__withdata := TRUE]);
  FOREVERY(RECORD source FROM want.contentsources)
  {
    INTEGER matchpos := (SELECT AS INTEGER #currentsources + 1
                           FROM currentsources
                          WHERE contentprovider = (source.contentobject != "" ? "consilio:custom" : VAR whconstant_consilio_contentprovider_site)
                                AND fsobject = source.fsobject
                                AND ToUppercase(tag) = ToUppercase(source.tag)) - 1;

    IF(matchpos >= 0)
    {
      STRING expect_library, expect_contentobject;
      IF(source.contentobject != "")
      {
        expect_library := Tokenize(source.contentobject,'#')[0];
        expect_contentobject := Tokenize(source.contentobject,'#')[1];
      }

      OBJECT contentsource := catalog->OpenContentSourceById(currentsources[matchpos].id);
      BOOLEAN mismatch;
      IF(currentsources[matchpos].definedby != source.definedby OR currentsources[matchpos].contentobject != source.contentobject)
        mismatch := TRUE;

      IF(expect_library != "")
      {
        IF(currentsources[matchpos].__data = "")
          mismatch := TRUE;
        ELSE
        {
          RECORD cursettings := EnforceStructure(CELL[library := "", contentobject := ""], DecodeHSON(currentsources[matchpos].__data));
          IF(cursettings.library != expect_library OR cursettings.contentobject != expect_contentobject)
            mismatch := TRUE;
        }
      }

      IF(mismatch)
      {
        contentsource->UpdateContentSource(CELL
            [ source.definedby
            , settings := CELL[library := expect_library, contentobject := expect_contentobject]
            , tag := source.tag
            ]);
      }

      IF(currentsources[matchpos].isorphan)
        contentsource->__ReactivateContentSource();

      DELETE FROM currentsources AT matchpos; //remove from cleanup list
      CONTINUE;
    }

    TRY
    {
      IF(source.contentobject = "")
        catalog->AddFolderToCatalog(source.fsobject, CELL[ source.definedby ]);
      ELSE
        catalog->AddCustomContentSource(source.tag, source.contentobject, CELL[ source.definedby ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2,`Failed to add catalog from ${source.definedby}: ${e->what}\n`);
      CONTINUE;
    }
  }

  //mark unreferred catalogs as orphan
  FOREVERY(RECORD makeorphansource FROM SELECT * FROM currentsources WHERE NOT isorphan)
    catalog->OpenContentSourceById(makeorphansource.id)->__MarkAsOrphan();
}

BOOLEAN FUNCTION AttemptZap(OBJECT catalog)
{
  Print(`Deleting attached indices for catalog '${catalog->tag}'\n`);
  FOREVERY(RECORD indexrec FROM catalog->ListAttachedIndices())
    IF(NOT indexrec.readonly)
      SendRawJSONToElasticSearch(indexrec.indexmanager, "DELETE", indexrec.indexname || catalog->suffixmask, DEFAULT RECORD);

  TRY
  {
    catalog->ApplyConfiguration();
  }
  CATCH(OBJECT e)
  {
    PrintTo(2, `Failed to reconfigure recreated indices for catalog '${catalog->tag}': ${e->what}\n`);
  }

  RETURN TRUE;
}

MACRO UpdateModuleCatalogs(RECORD options)
{
  OBJECT trans := GetPrimary();

  RECORD ARRAY wantcatalogs := SELECT *
                                    , catalog := DEFAULT OBJECT
                                 FROM GetRequiredCatalogs()
                                WHERE ToUppercase(tag) LIKE ToUppercase(options.catalogmask);

  BOOLEAN havedefaultindexmanager := RecordExists(SELECT FROM ListIndexManagers() WHERE isdefault);

  trans->BeginWork();
  FOREVERY(RECORD want FROM wantcatalogs)
  {
    OBJECT catalog := OpenConsilioCatalog(want.tag);
    IF(NOT ObjectExists(catalog))
    {
      IF(want.managed AND NOT havedefaultindexmanager)
        CONTINUE; //we cannot create catalogs if the defaultindexmanager doesn't exist (yet)

       catalog := CreateConsilioCatalog(want.tag, CELL[ want.managed, want.lang, want.suffixed ]);
    }
    wantcatalogs[#want].catalog := catalog;
    IF(catalog->managed != want.managed)
    {
      PrintTo(2, `Catalog '${want.tag}' is incorrectly ${catalog->managed ? "" : "not "}managed, it probably needs to be recreated\n`);
      CONTINUE;
    }

    //Setup contentsources first so UpdateCatalog can immediately apply the proper mapping
    IF(want.managed)
      UpdateManagedCatalog(catalog, want, options);

    TRY
    {
      //UpdateCatalog will not do unneeded changes but *will* reverify and update the mapping based on fieldgroups and contentsources.
      catalog->UpdateCatalog( CELL[ want.definedby, want.lang, want.suffixed, want.fieldgroups ]);
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2, `Failed to update catalog '${want.tag}': ${e->what}\n`);
      CONTINUE;
    }
  }
  trans->CommitWork();

  FOREVERY(RECORD want FROM wantcatalogs)
  {
    IF(NOT ObjectExists(want.catalog))
     CONTINUE;

    IF(want.managed AND want.catalog->managed) //If we are supposed to manage the catalog, we'll restore indices if needed
    {
      RECORD ARRAY indices := want.catalog->ListAttachedIndices();
      //only add indices for managed catalogs that have something to index. cleanupindices will cleanup catalogs that lost all sources
      IF(Length(indices) = 0 AND Length(want.catalog->ListContentSources()) > 0)
      {
        Print(`Managed catalog '${want.tag}' has no attached index yet, adding one\n`);
        trans->BeginWork();
        want.catalog->AttachIndex(0);
        want.catalog->ReindexCatalog();
        trans->CommitWork();
      }
    }

    TRY
    {
      // zapbroken can autodestroy 'fix' anything broken, but shouldn't we be first comparing whether the index needs changes before blindly applying mappings everywhere ? (and then get rid of this double-try?)
      want.catalog->ApplyConfiguration(); //ensure any config is fresh/uptodate
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      PrintTo(2, `Failed to reconfigure catalog '${want.tag}': ${e->what}\n`);

      IF(options.zapbroken)
        AttemptZap(want.catalog);
    }

    IF(want.managed AND want.catalog->managed)
      FOREVERY(RECORD opensearch FROM SELECT * FROM want.catalog->ListAttachedIndices())
        FOREVERY(STRING suffix FROM want.catalog->__ListSuffixes())
        {
          STRING fullname := opensearch.indexname || (suffix != "" ? "-" || suffix : "");

          RECORD res;
          TRY
          {
            res := GetOpenSearchCurrentMapping(opensearch.indexmanager, fullname);
          }
          CATCH(OBJECT e)
          {
            Print(`Catalog ${want.catalog->tag} index ${fullname}: GetOpenSearchCurrentMapping failed: ${e->what}\n`);
            CONTINUE;
          }

          RECORD ARRAY exp := want.catalog->GetExpectedMapping();
          RECORD ARRAY issues := CompareMappings(res,exp,"");

          IF (IsDefaultValue(issues))
            CONTINUE;

          IF(options.zapanymismatch AND AttemptZap(want.catalog))
            BREAK;

          FOREVERY(RECORD issue FROM issues)
          {
            //Not sure about printing to 2... once we have a way to fix/snooze/perma--ignore such issues ?
            Print(`Catalog ${want.catalog->tag} index ${fullname}: field '${issue.field}': ${issue.message} (${issue.definedby})\n`);
          }
        }
      }
}

PUBLIC MACRO FixConsilioIndices(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ reportmissing := FALSE
      , catalogmask := "*"
      , zapbroken := FALSE
      , zapanymismatch := FALSE
      ], options);

  IF (NOT GetPrimary()->ColumnExists("consilio", "indexmanagers", "id"))
    RETURN; //consilio is not initialized yet!

  OBJECT lock := OpenLockManager()->LockMutex("consilio:updateindices");
  TRY
  {
    ObsoleteCatalogs(options);
    UpdateModuleCatalogs(options);
  }
  FINALLY
  {
    lock->Release();
  }

  // Broadcast indexfields event to reset cached module index fields (publisher search)
  BroadcastEvent("consilio:indexfields", DEFAULT RECORD);//TODO is this still needed? but UpdateConsilioIndices, now removed, broadcasted it
}
