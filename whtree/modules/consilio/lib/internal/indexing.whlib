<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";

LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/queuemgmt.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";

INTEGER waitindex;

/** Wait for a contentsource to finish indexing
    @param contentsourceid Id of the contentsource
    @cell(boolean) options.verbose Whether to print progress messages
    @cell(datetime) options.deadline Deadline to wait for
*/
PUBLIC MACRO DoWaitForContentSourceDone(INTEGER contentsourceid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions([ verbose := FALSE
                             , deadline := MAX_DATETIME
                             ], options);

  RECORD contentsource := SELECT * FROM consilio.contentsources WHERE id = contentsourceid AND contentsources.tag NOT LIKE "$consilio$deleted$*";
  IF(NOT RecordExists(contentsource))
    THROW NEW Exception(`WaitContentSourceDone: No such content source #${contentsourceid}`);

  STRING describesource := `content source #${contentsourceid} (tag '${contentsource.tag}', type '${contentsource.contentprovider}', fsobject ${contentsource.fsobject})`;
  IF(contentsource.status = contentsourcestatus_disabled)
    THROW NEW Exception(`Cannot wait for disabled ${describesource}`); //'cannot wait for disabled contentsource ...'

  OBJECT eventmgr := NEW EventManager;
  waitindex := waitindex + 1;
  TRY
  {
    eventmgr->RegisterInterest("consilio:contentsource." || contentsourceid);

    INTEGER addsecs := 1;

    DATETIME currentwaitlimit := AddTimeToDate(1000,GetCurrentDatetime());

    INTEGER timeoutcount;
    BOOLEAN warnedwait;
    WHILE (TRUE)
    {
      RECORD status := __ConsilioGetQueueManagerStatus([ "contentsources", "queue" ]);
      IF(NOT RecordExists(status))
        THROW NEW Exception("Did not receive a status from the queue mgr");

      //Check if any items are there for our source, unconnected but affecting our index, or affecting something global
      IF(NOT RecordExists(SELECT FROM status.deduped WHERE (deduped.contentsourceid = contentsourceid)
                                                           OR (deduped.contentsourceid = 0 AND indexid = contentsource.catalogid)
                                                           OR (indexid=0)))
        BREAK;

      RECORD event := eventmgr->ReceiveEvent(currentwaitlimit);
      IF(event.status = "timeout")
      {
        IF(GetCurrentDatetime() >= options.deadline)
          THROW NEW Exception(`Index checking for ${describesource} isn't completing`);

        IF(GetCurrentDatetime() >= currentwaitlimit)
        {
          IF(options.verbose)
          {
            Print(`Index checking for ${describesource} isn't complete, still waiting... (wait #${waitindex})\n`);
            IF(NOT warnedwait)
              dumpvalue(GetStackTrace(), 'boxed');
            warnedwait := TRUE;
          }
          addsecs := addsecs < 5 ? addsecs + 1 : addsecs;
          currentwaitlimit := AddTimeToDate(addsecs * 1000,GetCurrentDatetime());

          timeoutcount := timeoutcount + 1;
          IF (timeoutcount % 10 = 0 AND options.verbose)
            DumpValue(status, "tree");
        }
      }
    }
    IF(warnedwait)
      Print("it's complete\n"); //make sure we don't think we were still waiting and that THAT's the issue..
  }
  FINALLY
  {
    eventmgr->Close();
  }

  //Check for errors
  INTEGER contentsourcestatus  := SELECT AS INTEGER status FROM consilio.contentsources WHERE id = contentsourceid;
  IF(contentsourcestatus != contentsourcestatus_idle)
  {
    STRING status := contentsourcestatus >= -1 AND contentsourcestatus <= 4
                          ? ["disabled","idle","being updated","being rebuild","unavailable","error"][contentsourcestatus + 1]
                          : "unknown";

    STRING err := `Unexpected status '${status}' (${contentsourcestatus}) after waiting for ${describesource}`;
    RECORD ARRAY relevanterrors := SELECT * FROM __ConsilioGetErrors().errors WHERE errors.contentsourceid = VAR contentsourceid;

    Print(err||"\n");
    DumpValue(relevanterrors, [ name := "", format := 'boxed' ]);
    LogDebug("consilio:dowaitforcontentsource", err, CELL[ contentsource, relevanterrors ]);
    ABORT(err);
  }
}
