<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/contentproviders/contentprovider.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";
LOADLIB "mod::consilio/lib/internal/fetcher_queue.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::tollium/lib/towl.whlib";

CONSTANT INTEGER restart_contentprovider_after := 500;
RECORD ARRAY cached_providers; // Cache opened providers
RECORD ARRAY contentproviders; // List of content providers


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Process commands
//

// Check the state of the Consilio index
PUBLIC RECORD FUNCTION CheckIndexState()
{
  FetcherDebug(ConsilioDebugInfo, "Processing CHECKINDEXSTATE");

  // Send a CheckIndex for each index which does not have an "ok" status or that aren't present in the Consilio index
  RECORD ARRAY outdated_sources :=
      SELECT indexid := catalogid
           , id
           , last_indexed
           , status
        FROM consilio.contentsources
       WHERE (status > 0)
             AND tag NOT LIKE "$consilio$deleted$*"; //or not even there!

  RETURN
      [ tocheck := outdated_sources
      , success := TRUE
      ];
}

// Check one index or all indexes
PUBLIC RECORD FUNCTION CheckIndex(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ noindexmodify := FALSE
      ], options);

  RECORD result :=
      [ error := DEFAULT RECORD
      , source := DEFAULT RECORD
      , tocheck_sources := DEFAULT RECORD ARRAY
      , tocleanup := DEFAULT RECORD
      , todelete := DEFAULT RECORD ARRAY
      , tocheck_groups := DEFAULT RECORD ARRAY
      ];

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  RECORD catalogdata :=
      SELECT catalogs.id
           , catalog_indexmanagers.indexmanager
           , catalogs.type
        FROM consilio.catalogs
           , consilio.catalog_indexmanagers
       WHERE catalogs.id = data.indexid
             AND catalog_indexmanagers.catalogid = catalogs.id;

  IF (NOT RecordExists(catalogdata))
    RETURN result; // Index gone, nothing to do

  IF (catalogdata.type = whconstant_consilio_catalogtype_unmanaged)
    RETURN result; // Unmanaged index, nothing to do

  IF (data.contentsourceid = 0)
  {
    GetPrimary()->BeginWork();
    UPDATE consilio.contentsources
       SET status := contentsourcestatus_rebuilding
         , last_indexed := VAR data.commanddate
     WHERE status >= contentsourcestatus_idle
           AND catalogid = VAR data.indexid
           AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    GetPrimary()->CommitWork();
    LogDebug("consilio:fetcher","CheckIndexState", `Committed setting ${data.indexid != 0 ? `contentsources in index ${data.indexid}` : `all contentsources`} to rebuild`);

    RECORD ARRAY sources := SELECT DISTINCT contentsources.id
                                 , indexid := catalogs.id
                                 , catalog_indexmanagers.indexmanager
                              FROM consilio.contentsources
                                 , consilio.catalogs
                                 , consilio.catalog_indexmanagers
                             WHERE contentsources.catalogid = catalogs.id
                                   AND catalog_indexmanagers.catalogid = catalogs.id
                                   AND (VAR data.indexid = 0
                                       OR catalogs.id = VAR data.indexid)
                                   AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    INTEGER ARRAY indexmanagers;
    FOREVERY (RECORD source FROM sources)
    {
      BroadcastEvent("consilio:contentsource." || source.id, DEFAULT RECORD);
      IF (source.indexmanager NOT IN indexmanagers)
        INSERT source.indexmanager INTO indexmanagers AT END;
    }

    // When rebuilding an index, clean out all documents from removed contentsources
    RemoveUnknownContentSourceObjects(data.indexid, SELECT AS INTEGER ARRAY id FROM sources);

    result.tocheck_sources := sources;
    RETURN result;
  }

  // Get the content source to check
  RECORD source := SELECT contentsources.*
                        , indexid := catalogs.id
                        , catalogs.loglevel
                        , catalogtag := catalogs.name
                     FROM consilio.contentsources
                        , consilio.catalogs
                    WHERE contentsources.catalogid = catalogs.id
                          AND contentsources.id = VAR data.contentsourceid
                          AND contentsources.tag NOT LIKE "$consilio$deleted$*";

  IF (NOT RecordExists(source))
  {
    result.error :=
        [ message := "Content source " || data.contentsourceid || " does not exist"
        , level := 1
        ];
    result.tocleanup :=
        [ indexid := data.indexid
        , contentsourceid := data.contentsourceid
        , active := TRUE
        , dontdelete := FALSE
        ];
    RETURN result;
  }
  IF (source.status < 0)
  {
    result.error :=
        [ message := "Not checking inactive content source " || source.id || " in index " || data.indexid
        , level := 1
        ];
    result.tocleanup :=
        [ indexid := data.indexid
        , contentsourceid := data.contentsourceid
        , active := TRUE
        , dontdelete := FALSE
        ];
    RETURN result;
  }
  result.source := source;

  FetcherDebug(ConsilioDebugInfo, "Checking content source " || source.id || " in index " || data.indexid, source.loglevel);

  OBJECT catalog := OpenConsilioCatalogById(data.indexid);
  IF(NOT ObjectExists(catalog))
    RETURN CELL [ ...result, error := [ message := `Catalog #${data.indexid} no longer exists`, level := 1] ];

  catalog->WaitReady(MAX_DATETIME, [ forconfiguration := TRUE, forstorage := TRUE ]);  //TODO timeout? ideally we wouldn't even be queued, or we would be requeued later when the index is available

  // Update status for single content source checks (TODO shouldn't whoever triggered CheckIndex not have set contentsourcestatus_rebuilding to ensure it will actually take place ?)
  {
    GetPrimary()->BeginWork();

    UPDATE consilio.contentsources
       SET status := contentsourcestatus_rebuilding
         , last_indexed := VAR data.commanddate
     WHERE id = source.id
           AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    GetPrimary()->CommitWork();
    LogDebug("consilio:fetcher","CheckIndexState", `Committed setting contentsource #${data.contentsourceid} to rebuild`);
  }

  // Broadcast event that the status has changed
  BroadcastEvent("consilio:contentsource." || source.id, DEFAULT RECORD);

  // Instantiate a content provider
  OBJECT provider;
  TRY
  {
    provider := GetContentProviderForSource(source);
  }
  CATCH(OBJECT<LibraryVersionConflictException> e)
  {
    //If we get here, we will never be able to load this source. We'll need to abort ourselves FIXME but we also need to ensure the instruction is requeud
    TerminateScript();
  }
  CATCH (OBJECT e)
  {
    GetPrimary()->BeginWork();
    UPDATE consilio.contentsources
       SET status := contentsourcestatus_error
     WHERE id = VAR data.contentsourceid
           AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    GetPrimary()->CommitWork();
    LogDebug("consilio:fetcher","CheckIndexState", `Committed setting contentsource #${data.contentsourceid} to error`, CELL[e->what,e->trace]);

    BroadcastEvent("consilio:contentsource." || data.contentsourceid, DEFAULT RECORD);

    result.error :=
        [ message := e->what
        , level := 2
        ];
    RETURN result;
  }

  // First, send a 'CleanupIndex' action for the index, to update the index status when we are done
  result.tocleanup :=
      [ indexid := data.indexid
      , contentsourceid := data.contentsourceid
      , active := FALSE
      , dontdelete := TRUE
      ];

  // Get all existing groups, then remove all the ones that are not returned.
  RECORD ARRAY existing_groups :=
      SELECT id
           , referenced := FALSE
        FROM GetExistingContentSourceGroups(data.contentsourceid);

  FetcherDebug(ConsilioDebugInfo, "Checking index for cs " || data.contentsourceid || ", existing groups: " || LENGTH(existing_groups), source.loglevel);

  // Try to list all groups in the content source
  RECORD ARRAY groups;
  TRY
  {
    groups := provider->ListGroups(data.commanddate);
  }
  CATCH (OBJECT<ConsilioIgnoredException> e)
  {
    // Not an error we need to store
    FetcherDebug(e->loglevel, e->what, source.loglevel);
    RETURN result;
  }
  CATCH (OBJECT<HareScriptErrorException> e)
  {
    LogHarescriptException(e, [ info :=
                                  [ context :=          "consilio:fetcher"
                                  , contentsourceid :=  data.contentsourceid
                                  , indexid :=          data.indexid
                                  ]
                              ]);

    GetPrimary()->BeginWork();
    UPDATE consilio.contentsources
       SET status := contentsourcestatus_error
     WHERE id = VAR data.contentsourceid
           AND contentsources.tag NOT LIKE "$consilio$deleted$*";
    GetPrimary()->CommitWork();

    LogDebug("consilio:fetcher","CheckIndexState", `Committed setting contentsource #${data.contentsourceid} to error`, CELL[e->what,e->trace]);
    BroadcastEvent("consilio:contentsource." || data.contentsourceid, DEFAULT RECORD);

    result.error :=
        [ message := e->what
        , level := 2
        ];
    RETURN result;
  }
  CATCH (OBJECT e)
  {
    LogHarescriptException(e, [ info :=
                                  [ context :=          "consilio:fetcher"
                                  , contentsourceid :=  data.contentsourceid
                                  , indexid :=          data.indexid
                                  ]
                              ]);

    GetPrimary()->BeginWork();
    UPDATE consilio.contentsources
       SET status := contentsourcestatus_error
     WHERE id = VAR data.contentsourceid
           AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    GetPrimary()->CommitWork();
    LogDebug("consilio:fetcher","CheckIndexState", `Committed setting contentsource #${data.contentsourceid} to error`, CELL[e->what,e->trace]);

    result.error :=
        [ message := e->what
        , level := 2
        ];
    RETURN result;
  }

  // Mark all returned groups
  FOREVERY (RECORD rec FROM groups)
  {
    RECORD pos := RecordLowerBound(existing_groups, [ id := rec.id ], [ "ID" ]);
    IF (pos.found)
      existing_groups[pos.position].referenced := TRUE;
  }

  // Remove all referenced groups
  DELETE FROM existing_groups WHERE referenced;

  FetcherDebug(ConsilioDebugInfo, "Deleting unreferenced groups: " || LENGTH(existing_groups), source.loglevel);

  // Send a 'deletegroup' action for every group that isn't referenced anymore
  result.todelete := existing_groups;

  // Send a "CheckGroup" action for each group
  result.tocheck_groups := groups;

  RETURN result;
}

/** @short Check a given group
    @param data The command data
    @cell(string) data.action "CHECKGROUP", "FASTCHECKGROUP", "DEACTIVATEGROUP" (for debugging purposes only)
    @cell(datetime) data.commanddate The timestamp of the command
    @cell(integer) data.indexid The index to check the group in, 0 for all indices or deactivation
    @cell(integer) data.contentsourceid The content source to check the group in, 0 for all relevant sources (publisher
        content only) or deactivation
    @cell(string) data.groupid The groupid of the group to check
    @param options Options
    @cell(boolean) options.deactivate If deactivating the group
    @cell(boolean) options.rebuild If rebuilding the index (or just checking)
    @cell(boolean) options.refresh Wait for index refresh after indexing (Elasticsearch only)
    @cell(boolean) options.noindexmodify Don't actually modify the index
    @cell(boolean) options.printprogress Print progress information (for Fetcher/QueueManager)
    @cell(boolean) options.debugobjects Debug print the existing objects
*/
PUBLIC MACRO CheckGroup(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ refresh := FALSE
      , noindexmodify := FALSE
      , printprogress := FALSE
      , debugobjects := FALSE
      ], options);

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  IF(data.contentsourceid = 0)
    THROW NEW Exception(`A contentsourceid is required for CheckGroup`);

  RECORD source := GetContentSource(data.contentsourceid);
  // Instantiatie a content provider for the source
  OBJECT provider  := GetContentProviderForSource(source);

  //Check which versions currently exist.
  RECORD query :=
    CELL[ query := [ bool := [ must := [[ term :=  [ "groupid" := data.groupid ]]
                                       ,[ term :=  [ "_contentsource" := source.id ]]
                                       ,[ range := [ "_indexed" := [ lt := data.commanddate ]]]
                                       ]
                   ]         ]
        , _source := FALSE
        , version := TRUE
        , size := 10000 //TODO maybe we should reintroduce a hardcoded limit to objects in a group again, but much higher than the default 500 we once had
        ];

  //TODO should foreground index actions pass the current version during indexing so they can retry if they collide with a background update for the same group?

  RECORD ARRAY current, indexmanagers := GetIndexManagersForIndex(source.catalogid);
  IF(Length(indexmanagers) = 0)
    RETURN; //no index cares

  FOREVERY (RECORD indexmanager FROM indexmanagers)
  {
    RECORD result := SendRawJSONToElasticsearch(indexmanager.id, "POST", indexmanager.indexname || "/_search", query);
    current := current CONCAT SELECT _version, _id FROM result.result.hits.hits;
    BREAK; //FIXME as soon as we actually support multiple indices, we should track documents/version per index
  }

  OBJECT catalog := OpenConsilioCatalogById(source.indexid);
  OBJECT bulk := GetIndexManagerBulkKeeper();

  // Get a list of object ids from the provider within the group
  // This is the initial list of objects to fetch; new objects will be added as they are encountered while fetching
  RECORD ARRAY objects := EnforceStructure([[ data := DEFAULT RECORD ]], provider->ListObjects3(data.commanddate, data.groupid));

  RECORD ARRAY toadd;

  FOREVERY(RECORD obj FROM objects)
  {
    IF(options.debugobjects)
      Print(`Fetching object, group: ${data.groupid}, object: ${obj.id} (${#obj}/${Length(objects)})\n`);

    // Fetch and index the object, new objects within the group are returned
    RECORD cmdresult := FetchObject(source, provider, data.groupid, obj.id, obj.data, data.commanddate);
    IF(NOT RecordExists(cmdresult))
      CONTINUE;

    INSERT CELL objectid := obj.id INTO cmdresult;
    INSERT cmdresult INTO toadd AT END;

    IF (options.printprogress)
    {
      // Send sign of life to UrlManager
      Print("PageDone\n");
    }
  }

  IF (NOT options.noindexmodify)
  {
    // Send page to the IndexManager for each index
    DATETIME uploadstart := GetCurrentDatetime();
    FetcherDebug(ConsilioDebugAll, "Sending indexed documents to IndexManager", source.loglevel);
    AddIndexManagerObjects(catalog,
                           source,
                           data.groupid,
                           (SELECT objectid
                                 , documentfields := fields
                                 , suggestfields
                                 , suggestprefixes
                                 , _id := toadd.documentid
                              FROM toadd), CELL
                           [ bulk
                           ]);

    RECORD ARRAY bulkrequests := SELECT "delete" := [ _id := _id ] FROM current WHERE _id NOT IN (SELECT AS STRING ARRAY documentid FROM toadd);
    bulk->AddOpenSearchRequests(indexmanagers[0].id, indexmanagers[0].indexname, bulkrequests);
    bulk->Execute(CELL[options.refresh]);
  }
}

PUBLIC MACRO DeactivateGroup(STRING groupid)
{
  BOOLEAN is_publisher_document := ToInteger(groupid, 0) > 0;
  IF(NOT is_publisher_document)
    THROW NEW Exception(`DeactivateGroup is only supported for publisher documents (ie consilio:site contentsources)`);

  // Now delete any earlier versions
  RECORD query := CELL[ query := [ term := [ "groupid" := groupid
                                           ]
                                 ]
                      ];

  FOREVERY (RECORD indexmanager FROM ListIndexManagers())
    SendRawJSONToElasticsearch(indexmanager.id, "POST", "/_all/_delete_by_query", query);
}

// Delete an entire group from the index
PUBLIC RECORD FUNCTION DeleteGroup(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ noindexmodify := FALSE
      , refresh := FALSE
      ], options);

  RECORD result :=
      [ error := DEFAULT RECORD
      ];

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  // Check for a groupid
  IF (data.groupid = "")
  {
    result.error :=
        [ message := "No group to delete"
        , level := 0
        ];
    RETURN result;
  }

  INTEGER loglevel := -1;
  IF (data.contentsourceid != 0)
  {
    RECORD source := GetContentSource(data.contentsourceid);
    IF (RecordExists(source))
      loglevel := source.loglevel;
  }

  FetcherDebug(ConsilioDebugInfo, "Deleting group \"" || EncodeJava(data.groupid) || "\", from contentsource " || data.contentsourceid, loglevel);

  // If no indexid is given, delete the group from all indexes
  IF (NOT options.noindexmodify)
    DeleteIndexManagerGroup(data.indexid, data.contentsourceid, data.groupid, [ refresh := options.refresh ]);

  RETURN result;
}

// Explicitly add a single object to the index
PUBLIC MACRO CheckObject(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ noindexmodify := FALSE
      , refresh := FALSE
      ], options);

  RECORD result :=
      [ error := DEFAULT RECORD
      ];

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  // Check for a valid content source
  IF (data.contentsourceid = 0)
    THROW NEW Exception(`Content source unknown for groupid \"" || EncodeJava(data.groupid) || "\"`);

  RECORD source := GetContentSource(data.contentsourceid);
  IF (NOT RecordExists(source))
    THROW NEW Exception("No valid content source to add object");


  // Get the provider for the source
  OBJECT provider := GetContentProviderForSource(source);

  // Fetch and index the object unconditionally
  RECORD cmdresult := FetchObject(source, provider, data.groupid, data.objectid, DEFAULT RECORD, data.commanddate);
  IF (NOT RecordExists(cmdresult))
    RETURN; //nothing to do

  IF (options.noindexmodify)
    RETURN; //nothing to do

  // Send page to the IndexManager for each index
  DATETIME uploadstart := GetCurrentDatetime();
  FetcherDebug(ConsilioDebugAll, "Sending indexed document to IndexManager", source.loglevel);
  OBJECT catalog := OpenConsilioCatalogById(provider->indexid);
  AddIndexManagerObjects(catalog,
                         source,
                         data.groupid,
                         [ [ objectid := data.objectid
                           , documentfields := cmdresult.fields
                           , _id := cmdresult.documentid
                           , suggestfields := cmdresult.suggestfields
                           , suggestprefixes := cmdresult.suggestprefixes
                           ]
                         ],
                         [ refresh := options.refresh
                         ]);

  FetcherDebug(ConsilioDebugAll, "Upload indexed took "|| GetMsecsDifference(uploadstart, GetCurrentDatetime()) || "ms", source.loglevel);
}



// Delete a single object from the index
PUBLIC RECORD FUNCTION DeleteObject(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ noindexmodify := FALSE
      , refresh := FALSE
      ], options);

  RECORD result :=
      [ error := DEFAULT RECORD
      ];

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  // Check for a groupid
  IF (data.objectid = "")
  {
    result.error :=
        [ message := "No object to delete"
        , level := 0
        ];
    RETURN result;
  }

  INTEGER loglevel := (SELECT AS INTEGER catalogs.loglevel + 1 FROM consilio.catalogs WHERE id = data.indexid) - 1;

  FetcherDebug(ConsilioDebugInfo, "Deleting object \"" || EncodeJava(data.objectid) || "\", from index " || data.indexid, loglevel);

  // If no indexid is given, delete the group from all indexes
  IF (NOT options.noindexmodify)
  {
    STRING deleteresult := DeleteIndexManagerObject(data.indexid, 0, data.objectid, CELL[ options.refresh ]);
    IF (deleteresult != SearchOk)
      FetcherDebug(ConsilioDebugInfo, "Could not fully delete object \"" || EncodeJava(data.objectid) || "\": " || deleteresult);
  }

  RETURN result;
}

// Clean up the index
PUBLIC RECORD FUNCTION CleanupIndex(RECORD data, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ noindexmodify := FALSE
      ], options);

  RECORD result :=
      [ error := DEFAULT RECORD
      ];

  FetcherDebug(ConsilioDebugInfo, "Processing " || GetCommandFromQueueData(data));

  IF (data.indexid = 0)
  {
    result.error :=
        [ message := "No index to clean up"
        , level := 0
        ];
    RETURN result;
  }

  OpenConsilioCatalogById(data.indexid)->WaitReady(MAX_DATETIME, [ forstorage := TRUE ]);

  // Make sure all modifications are visible after cleanup
  RefreshAttachedIndices(data.indexid);

  INTEGER loglevel := (SELECT AS INTEGER catalogs.loglevel + 1 FROM consilio.catalogs WHERE id = data.indexid) - 1;
  IF(data.active AND NOT data.dontdelete)
  {
    FetcherDebug(ConsilioDebugInfo, "Removing orphan index " || data.indexid || ", deleting all documents", loglevel);
    IF (NOT options.noindexmodify)
    {
      // All objects in the index with an index date before this task's index date can be removed from the index.
      DeleteIndexManagerOutdated(data.indexid, data.contentsourceid, data.commanddate);
    }
  }

  GetPrimary()->BeginWork();

  INTEGER oldstatus := SELECT AS INTEGER status FROM consilio.contentsources WHERE id = VAR data.contentsourceid AND contentsources.tag NOT LIKE "$consilio$deleted$*";

  UPDATE consilio.contentsources
     SET status := contentsourcestatus_idle
   WHERE status > contentsourcestatus_idle
         AND id = VAR data.contentsourceid
         AND contentsources.tag NOT LIKE "$consilio$deleted$*";

  GetPrimary()->CommitWork();
  LogDebug("consilio:fetcher","CheckIndexState", `Committed setting ${data.indexid != 0 ? `contentsources in index ${data.indexid}` : `all contentsources`} to idle (was ${oldstatus})`);
  BroadcastEvent("consilio:contentsource." || data.contentsourceid, DEFAULT RECORD);

  IF (NOT RecordExists(SELECT FROM consilio.contentsources WHERE catalogid = VAR data.indexid AND status != 0))
  {
    BroadcastEvent("consilio:index." || data.indexid, DEFAULT RECORD);
    ShowTowlNotification("consilio:notifications.catalog_uptodate",
                         [ users_with_rights :=
                               [ [ rightname := "system:sysop"
                                 ]
                               ]
                         ],
                         [ titleparams := [ ToString(oldstatus) ]
                         , descriptionparams :=
                               [ (SELECT AS STRING name FROM consilio.catalogs WHERE id = data.indexid)
                               , ToString(oldstatus)
                               ]
                         , icon := "consilio:consilio"
                         , priority := TowlPriorityLow
                         , applicationmessage := [ app := "system:sysmgmt"
                                                 , apptarget := [ applet := "consilio:catalogs" ]
                                                 , messagedata := DEFAULT RECORD
                                                 , reuse_instance := TRUE
                                                 ]
                         ]);
  }
  RETURN result;
}

PUBLIC MACRO ClearCaches(STRING eventname, RECORD data)
{
  FetcherDebug(ConsilioDebugInfo, "Clearing fetcher provider cache");
  RECORD ARRAY old_providers := cached_providers;
  cached_providers := DEFAULT RECORD ARRAY;

  FOREVERY (RECORD rec FROM old_providers)
    rec.obj->Close();
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Consilio helper functions
//

// Get all content sources
RECORD ARRAY FUNCTION GetAllContentSources()
{
  RETURN SELECT contentsources.*
              , indexid := catalogs.id
              , catalogs.loglevel
           FROM consilio.contentsources
              , consilio.catalogs
          WHERE contentsources.status >= 0
                AND contentsources.catalogid = catalogs.id
                AND contentsources.tag NOT LIKE "$consilio$deleted$*";
}

// Get the content source with the given id
RECORD FUNCTION GetContentSource(INTEGER contentsourceid)
{
  RETURN SELECT contentsources.*
              , indexid := catalogs.id
              , catalogs.loglevel
           FROM consilio.contentsources
              , consilio.catalogs
          WHERE contentsources.id = contentsourceid
                AND contentsources.catalogid = catalogs.id
                //AND contentsources.status >= 0 //if a specific ID is selected, this is an explicit CheckGroup and we should ignore the status field
                AND contentsources.tag NOT LIKE "$consilio$deleted$*";
}

// Get all content sources for a given index
RECORD ARRAY FUNCTION GetContentSourcesForIndex(INTEGER indexid)
{
  RETURN SELECT contentsources.*
              , indexid := catalogs.id
              , catalogs.loglevel
           FROM consilio.contentsources
              , consilio.catalogs
          WHERE contentsources.catalogid = VAR indexid
                AND contentsources.catalogid = catalogs.id
                AND contentsources.status >= 0
                AND contentsources.tag NOT LIKE "$consilio$deleted$*";
}

// Instantiate a content provider for the given source
OBJECT FUNCTION GetContentProviderForSource(RECORD source)
{
  IF (NOT RecordExists(source))
    THROW NEW Exception("Source does not exist");

  FetcherDebug(ConsilioDebugAll, "Initializing content source " || source.id || " in index " || source.indexid || " using content provider '" || source.contentprovider || "'", source.loglevel);

  OBJECT provider := SELECT AS OBJECT obj FROM cached_providers WHERE cached_providers.id = source.id;
  IF(ObjectExists(provider) AND provider->donetasks > restart_contentprovider_after)
  {
    provider->Close();
    DELETE FROM cached_providers WHERE cached_providers.id = source.id;
    provider := DEFAULT OBJECT;
  }
  IF(NOT ObjectExists(provider))
  {
    OBJECT catalog := OpenConsilioCatalogById(source.indexid);
    OBJECT contentsource := catalog->OpenContentSourceById(source.id);
    provider := contentsource->__OpenProvider();
    INSERT INTO cached_providers(id, obj) VALUES(source.id, provider) AT END;
  }
  provider->loglevel := source.loglevel;
  provider->donetasks := provider->donetasks + 1;
  RETURN provider;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Fetching helper functions
//

/** Returns the list of content sources that contain a specific group
    @param indexid Constrain by this index (0 to ignore)
    @param groupid Group to search
    @return List of content sources that contain this group
*/
INTEGER ARRAY FUNCTION GetContentSourcesWithGroup(STRING groupid)
{
  RECORD query := CELL[ query := [ term := [ "groupid" := groupid ] ]
                      , fields := [ "_contentsource" ]
                      , _source := FALSE
                      ];

  INTEGER ARRAY contentsourceids;
  FOREVERY(RECORD indexmanager FROM ListIndexManagers())
  {
    RECORD response := SendRawJSONToElasticsearch(indexmanager.id, "POST", "/_all/_search", query);
    FOREVERY(RECORD hit FROM response.result.hits.hits)
      FOREVERY(INTEGER csource FROM EnforceStructure([ _contentsource := INTEGER[] ], hit.fields)._contentsource)
        IF(csource > 0 AND csource NOT IN contentsourceids)
          INSERT csource INTO contentsourceids AT END;
  }
  RETURN contentsourceids;
}


/** Returns the list of content source record that may be responsible for a group
    @param indexid
    @param contentsourceid
    @param groupid
    @param is_publisher_document
    @return List of candidate content sources (if empty, the error has already been issued)
*/
RECORD FUNCTION GetCandidateContentSources(INTEGER indexid, INTEGER contentsourceid, STRING groupid, BOOLEAN is_publisher_document)
{
  RECORD result :=
      [ error := DEFAULT RECORD
      , sources := DEFAULT RECORD ARRAY
      ];

  BOOLEAN ignore_nosources;

  // Get a list of current content sources to add the group to
  IF (contentsourceid != 0 OR NOT is_publisher_document)
  {
    // If no contentsourceid is given, the groupid should be a non-zero integer (i.e. a WebHare fs_object id)
    IF (contentsourceid = 0)
    {
      result.error :=
          [ message := "Content source unknown for groupid \"" || EncodeJava(groupid) || "\""
          , level := 2
          ];
      RETURN result;
    }
    // We have an explicit content source
    RECORD source := GetContentSource(contentsourceid);
    IF (RecordExists(source))
      INSERT source INTO result.sources AT END;
  }
  ELSE
  {
    // The contentsourceid is 0 and the groupid is a non-zero integer
    RECORD ARRAY candidates;
    IF (indexid != 0)
      // Get all content sources for the given index
      candidates := GetContentSourcesForIndex(indexid);
    ELSE
    {
      // Get all content sources, not an error when we find none (republish, just checking if there are any publisher sources that contain it)
      candidates := GetAllContentSources();
      ignore_nosources := TRUE;
    }

    // Determine which contentsources pick up this fs_object
    INTEGER fs_object := ToInteger(groupid, -1);
    INTEGER ARRAY path;
    WHILE (fs_object > 0)
    {
      INSERT fs_object INTO path AT 0;
      fs_object := SELECT AS INTEGER parent FROM system.fs_objects WHERE id = fs_object;
    }

    // Also include the contentsources that already have this group
    INTEGER ARRAY mustinclude := GetContentSourcesWithGroup(groupid);

    FOREVERY (RECORD rec FROM candidates)
    {
      IF (rec.contentprovider != whconstant_consilio_contentprovider_site)
        CONTINUE;

      IF (rec.id IN mustinclude)
        INSERT rec INTO result.sources AT END;
      ELSE
      {
        IF (rec.fsobject NOT IN path)
          CONTINUE;

        INSERT rec INTO result.sources AT END;
      }
    }

    // No content source was specified, so we're adding a WebHare fs_object for which only publisher content sources are needed
    result.sources := SELECT * FROM result.sources WHERE contentprovider = VAR whconstant_consilio_contentprovider_site;
  }

  // Do we have any content sources for adding the group?
  IF (Length(result.sources) = 0 AND NOT ignore_nosources)
  {
    result.error :=
        [ message := "No relevant content sources to check group \"" || EncodeJava(groupid) || "\" for content source " || contentsourceid || " in index " || indexid
        , level := 2
        ];
  }

  RETURN result;
}



/** Get the list of groups for a content source
    @param contentsourceid ID of the content source
    @return Groups
    @cell(string) return.id Group id
*/
RECORD ARRAY FUNCTION GetExistingContentSourceGroups(INTEGER contentsourceid)
{
  RECORD query := CQMatch("_contentsource", "=", ToString(contentsourceid));

  INTEGER indexid := SELECT AS INTEGER COLUMN catalogid FROM consilio.contentsources WHERE id = contentsourceid;

  RECORD ARRAY results;
  FOREVERY (RECORD indexmanager FROM GetIndexManagersForIndex(indexid))
  {
    // Don't retrieve all results first (using count := -1), to avoid creating unneccessary scrolling contexts
    RECORD result := QueryIndexManager(indexid, query, [ count := fetcher_search_window, mapping := [ groupid := "" ], indexmanager := indexmanager.id, acceptmissingindex := TRUE ]);
    IF (result.totalcount > fetcher_search_window)
      result := QueryIndexManager(indexid, query, [ count := -1, mapping := [ groupid := "" ], indexmanager := indexmanager.id ]);

    results := results CONCAT result.results;
  }

  RETURN
      SELECT DISTINCT id := groupid
        FROM results;
}

/** Removes all documents in an index that are not from one of the valid contentsources
    @param indexid ID of the index
    @param validcontentsourceids Ids of the contentsources that are valid for this index
*/
MACRO RemoveUnknownContentSourceObjects(INTEGER indexid, INTEGER ARRAY validcontentsourceids)
{
  // Only a CQNot doesn't work
  RECORD query := CQAnd([ CQAll(), CQNot(CQMatch("_contentsource", "IN", validcontentsourceids)) ]);

  RECORD ARRAY results;
  FOREVERY (RECORD indexmanager FROM GetIndexManagersForIndex(indexid))
  {
    // Don't retrieve all results first (using count := -1), to avoid creating unneccessary scrolling contexts
    RECORD result := QueryIndexManager(indexid, query, [ count := fetcher_search_window, mapping := [ _contentsource := 0 ], acceptmissingindex := TRUE ]);
    IF (result.totalcount > fetcher_search_window)
      result := QueryIndexManager(indexid, query, [ count := -1, mapping := [ _contentsource := 0 ] ]);

    results := results CONCAT result.results;
  }

  INTEGER ARRAY contentsources := SELECT AS INTEGER ARRAY DISTINCT _contentsource FROM results WHERE _contentsource != 0;
  FOREVERY (INTEGER contentsource FROM contentsources)
    DeleteIndexManagerContentSource(0, indexid, contentsource);
}

/** @return Returns the indexed document or a DEFAULT RECORD if we had no content to index */
RECORD FUNCTION FetchObject(RECORD contentsource, OBJECT contentprovider, STRING groupid, STRING objectid, RECORD objectdata, DATETIME commanddate)
{
  TRY
  {
    // Let the content provider fetch the object. Errors will be thrown, not found returns an empty record.
    RECORD objectrec := objectdata ?? contentprovider->FetchObject(commanddate, groupid, objectid);
    IF (NOT RecordExists(objectrec))
      THROW NEW Exception(`FetchObject did not return data - it should have returned a ConsilioIgnoredException`);

    FetcherDebug(ConsilioDebugInfo, "Replacing object \"" || EncodeJava(objectid) || "\"", contentsource.loglevel);

    RECORD document_fields := CellExists(objectrec, "document_fields") ? objectrec.document_fields : DEFAULT RECORD;
    STRING body := CellExists(objectrec, "document_body") ? objectrec.document_body : "";

    // Legacy suggestfields and suggestprefix are supplied through document fields
    STRING ARRAY doc_suggestfields, doc_suggestprefix;
    IF (CellExists(document_fields, "suggestfields") AND document_fields.suggestfields != "")
    {
      doc_suggestfields := Tokenize(document_fields.suggestfields, " ");
      IF (CellExists(document_fields, "suggestprefix") AND document_fields.suggestprefix != "")
        doc_suggestprefix := Tokenize(document_fields.suggestprefix, " ");
    }

    // Remove reserved fields from the document fields
    FOREVERY (STRING field FROM [ "groupid", "objectid"
                                , "_contentsource", "_indexed", "_indexdate" //NOTE _indexdate is removed for new ones but may still appear in existing indices
                                , "suggestfields", "suggestprefix"
                                , "body" ])
      IF (CellExists(document_fields, field))
        document_fields := CellDelete(document_fields, field);

    STRING result;
    IF (NOT RecordExists(document_fields) AND body = "")
      RETURN DEFAULT RECORD;

    RECORD document :=
        [ _indexed := commanddate
        ];

    // Add special field "body"
    IF (body != "")
      INSERT CELL body := objectrec.document_body INTO document;

    // Add the document fields to the IndexManager variables
    FOREVERY (RECORD field FROM UnpackRecord(document_fields))
      document := CellInsert(document, field.name, field.value);

    // Add suggest parameters
    RECORD ARRAY suggestfields :=
        SELECT field := name LIKE "_*" ? Substring(name, 1) : name
             , prefix := CellExists(mapping, "suggestprefix") ? suggestprefix : ""
          FROM contentprovider->GetMapping() AS mapping
         WHERE CellExists(mapping, "suggested") ? suggested : FALSE;
    IF (NOT RecordExists(suggestfields))
    {
      INTEGER numprefixes := Length(doc_suggestprefix);
      suggestfields :=
          SELECT field := name LIKE "_*" ? Substring(name, 1) : name
               , prefix := numprefixes > 0 ? (doc_suggestprefix[#fields % numprefixes]) : ""
            FROM ToRecordArray(doc_suggestfields, "name") AS fields;
    }

    RETURN
        [ fields := document
        , suggestfields := Length(suggestfields) > 0 ? (SELECT AS STRING ARRAY field FROM suggestfields) : DEFAULT STRING ARRAY
        , suggestprefixes := Length(suggestfields) > 0 ? (SELECT AS STRING ARRAY prefix FROM suggestfields) : DEFAULT STRING ARRAY
        , documentid := GetElasticsearchDocumentId(contentsource.indexid, objectid)
        ];
  }
  CATCH (OBJECT< ConsilioIgnoredException > e)
  {
    // Not an error we need to store
    FetcherDebug(e->loglevel, e->what, contentsource.loglevel);
    RETURN DEFAULT RECORD;
  }

}
