<?wh
/** @topic consilio/api
*/

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::regex.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::xml/xsd.whlib";

LOADLIB "mod::publisher/lib/publisher.whlib";

LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager_state.whlib";
LOADLIB "mod::consilio/lib/internal/catalogdefparser.whlib";
LOADLIB "mod::consilio/lib/internal/contentsources.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib" EXPORT fetcher_trusted_ip;
LOADLIB "mod::consilio/lib/internal/fetcher_queue.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/finishhandler.whlib";
LOADLIB "mod::consilio/lib/internal/indexing.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch/analysis.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch/mapping.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/tasks.whlib";


CONSTANT RECORD default_contentsource_options := CELL[ enabled := TRUE
                                                     ];

PUBLIC STRING FUNCTION __BuildFieldgroups(STRING ARRAY fieldgroups)
{
  //TODO validate whether these groups exist so we give Errors Early ?
  IF(Length(fieldgroups) = 0)
    RETURN "";
  RETURN Detokenize(GetSortedSet(fieldgroups),' ');
}

//Name validation: our API integration currently needs to be able to fix an indexname into 64 characters, so we'll allocate 40 chars for the index name.. 64 - 40 - 1 = 23 remaining for the suffix.. let's give it 16 and have headroom left...

/** Is this a valid indexname for use in Consilio?
    @param name Name to check
    @return TRUE if the name is a valid indexname
*/
PUBLIC BOOLEAN FUNCTION IsValidConsilioIndexName(STRING name)
{
  //We want to reserve '-' to detect suffixes, reserve names starting with _ and . for internal/dashboard stuff, and just limit names further to be on the safe side
  RETURN NEW Regex("^[a-z][_a-z0-9]*$")->Test(name) AND Length(name) <= 40 AND name NOT LIKE "*_";
}

/** Is this a valid suffix for use in Consilio?
    @param suffix Suffix to check
    @return TRUE if the suffix is a valid suffix
*/
PUBLIC BOOLEAN FUNCTION IsValidConsilioIndexSuffix(STRING suffix)
{
  //We'll try to be safe, but accept things that look like dates (2022-05).
  //48 is an estimate of what appeared to be reasonable
  RETURN NEW Regex("^[a-z0-9]+[-_a-z0-9]+$")->Test(suffix) AND Length(suffix) < 16 AND Right(suffix,1) NOT IN ["_","-"];
}

/** @short List configured index managers
    @return List of index managers
    @cell(integer) return.id ID of the indexmanager
    @cell(boolean) return.isbuiltin Whether this is a builtin indexmanager
    @cell(boolean) return.isdefault Whether this is the default builtin indexmanager
    @cell(string) return.name Name of the indexmanager
    @cell(string) return.url URL to connect to the server */
PUBLIC RECORD ARRAY FUNCTION ListIndexManagers()
{
  RETURN SELECT id
              , isbuiltin := address = "builtin-opensearch"
              , isdefault := address = "builtin-opensearch"
              , name
              , url := address = "builtin-opensearch" ? GetBuiltinOpensearchAddress() : address
           FROM consilio.indexmanagers;
}

/** Content source object
    @public
*/
STATIC OBJECTTYPE ContentSource
<
  RECORD contentsource;
  OBJECT __catalog;

  /// @type(integer) Id of this contentsource
  PUBLIC PROPERTY id(this->contentsource.id, -);

  /// @type(string) Tag of this contentsource
  PUBLIC PROPERTY tag(this->contentsource.tag, -);

  /// @type(boolean) True if this source is enabled (automatically indexing)
  PUBLIC PROPERTY enabled(GetEnabled, -);

  /// @type(string) Contentprovidertype (generally consilio:site or consilio:custom)
  PUBLIC PROPERTY __contentprovider(this->contentsource.contentprovider, -); //hiding this API because 'consilio:custom' might stop being a thing in the future

  /// @type(integer) Base object for this content source
  PUBLIC PROPERTY fsobject(this->contentsource.fsobject, -);

  /// @type(object) Parent catalog
  PUBLIC PROPERTY catalog(this->__catalog, -);

  MACRO NEW(OBJECT catalog, RECORD contentsource)
  {
    this->__catalog := catalog;
    this->contentsource := contentsource;
  }

  BOOLEAN FUNCTION GetEnabled()
  {
    RETURN this->contentsource.status != -1;
  }

  /// Marks this content source as an orphan
  PUBLIC MACRO __MarkAsOrphan()
  {
    UPDATE consilio.contentsources
           SET orphansince := GetCurrentDatetime()
           WHERE id = this->contentsource.id
                AND orphansince = DEFAULT DATETIME;

    GetConsilioFinishHandler()->ScheduleCleanup(); //remove stale indices ASAP
  }

  /// Reactivate this content source
  PUBLIC MACRO __ReactivateContentSource()
  {
    UPDATE consilio.contentsources
           SET orphansince := DEFAULT DATETIME
           WHERE id = this->contentsource.id;

    //FIXME schedule recheck on this countent source
    //GetConsilioFinishHandler()->ScheduleCleanup(); //remove stale indices ASAP
  }

  /** Construct the provider for this source
      @return Contentprovider object
  */
  PUBLIC OBJECT FUNCTION __OpenProvider() //this is unsafe as a public API, we'll keep it or some whitebox testing but we should be 'hiding' this in the contentsource API
  {
    RECORD cprec := SELECT * FROM GetContentProviders() WHERE name = this->contentsource.contentprovider;
    IF (NOT RecordExists(cprec))
      THROW NEW Exception(`Content provider '${this->contentsource.contentprovider}' not found for content source #${this->contentsource.id}`);

    OBJECT cpobj := cprec.createcontentprovider();

    // Decode the source-specific data
    RECORD source := this->contentsource;
    RECORD csdata := DecodeHSON(source.data);
    DELETE CELL data FROM source;
    INSERT CELL data := csdata INTO source;

    // Add the contentlinksonly flag (in the future this might be made configurable)
    INSERT CELL contentlinksonly := ReadRegistryKey("consilio.linkchecker.contentlinksonly") INTO source;

    source := CELL[ ...source
                  , contentsourceid := this->contentsource.id
                  , contentsourcetag := this->contentsource.tag
                  , catalogtag := this->catalog->tag
                  ];
    cpobj->Init(source);
    RETURN cpobj;
  }

  /** Update content source settings
      @param settings Settings to apply
      @cell(string) settings.definedby Definition location */
  PUBLIC MACRO UpdateContentSource(RECORD settings)
  {
    settings := ValidateOptions([ definedby := ""
                                , settings := DEFAULT RECORD
                                , tag := ""
                                , enabled := FALSE
                                ], settings, [ optional := [ "definedby", "tag", "enabled" ]
                                             , title := "settings"
                                             ]);

    //If 'settings' is set we'll be merging it with the current data. but this whole settings thing is ugly and should
    //probably be made transparant/flat... but we use it for contentobject which should preferably go away at all and
    //be taken from moduledefs
    IF(RecordExists(settings.settings))
    {
      RECORD newsettings := settings.settings;
      STRING cursettings := SELECT AS STRING data FROM consilio.contentsources WHERE id = this->id;
      IF(cursettings != "")
        newsettings := CELL[ ...DecodeHSON(cursettings), ...newsettings];
      settings := CELL[ ...settings, data := EncodeHSON(newsettings), DELETE settings ];
    }
    ELSE
    {
      DELETE CELL settings FROM settings;
    }

    IF(CellExists(settings,'tag'))
    {
      STRING curprovider := SELECT AS STRING contentprovider FROM consilio.contentsources WHERE id = this->id;
      IF(curprovider = whconstant_consilio_contentprovider_site AND settings.tag != "")
        THROW NEW Exception(`A site contentsource may not have a tag`);
      IF(curprovider = "consilio:custom" AND settings.tag = "")
        THROW NEW Exception(`A consilio:custom contentsource must have a tag`);

      IF(settings.tag != ""
        AND RecordExists(SELECT FROM consilio.contentsources WHERE ToUppercase(COLUMN tag) = ToUppercase(settings.tag) AND id != this->id))
      {
        THROW NEW Exception(`A contentsource with tag '${settings.tag}' already exists (note: tags must currently be globally unique!)`);
      }
    }

    IF(CellExists(settings,'enabled'))
    {
      IF(settings.enabled AND NOT this->enabled)
        settings := CELL[ ...settings, status := 0 ];
      ELSE IF(NOT settings.enabled AND this->enabled)
        settings := CELL[ ...settings, status := -1 ];

      DELETE CELL enabled FROM settings;
    }

    UPDATE consilio.contentsources SET RECORD settings WHERE id = this->id;
    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    //quick&dirty metadata update
    this->contentsource := RECORD(SELECT * FROM consilio.contentsources WHERE id = this->id) ?? this->contentsource;
  }

  RECORD FUNCTION GetBaseDebugInfo()
  {
    RETURN CELL[ catalog := this->catalog->tag
               , catalogid := this->catalog->id
               , contentsource := this->tag ?? "fsobj #" || this->fsobject
               , contentsourceid := this->id
               , trace := ArraySlice(GetStackTrace(),2)
               ];
  }

  /** Reindex this entire content source
      @long Reindex all groups. The reindexing takes place in the background
  */
  PUBLIC MACRO ReindexContentSource(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions([ rebuild := FALSE ], options);

    STRING command := "CHECKINDEX "|| this->catalog->id || " " || this->id;
    IF(IsDebugTagEnabled("consilio:queues"))
      LogDebug("consilio", "ContentSource::ReindexContentSource", CELL[...this->GetBaseDebugInfo() ]);
    SendQueueManagerData(GetQueueDataFromCommand(command));
  }

  /** List groups in the catalog
      @param options Options
      @return List of groups
      @cell(string) return.id Group id
  */
  PUBLIC RECORD ARRAY FUNCTION ListGroups(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[], options);

    OBJECT provider;
    TRY
    {
      provider := this->__OpenProvider();
      RECORD ARRAY groups := SELECT groupid := id FROM provider->ListGroups(DEFAULT DATETIME);
      RETURN groups;
    }
    FINALLY
    {
      provider->Close();
    }
  }

  /** Reindex a group
      @long Reindex a specific group
      @param groupid Group to reindex
      @cell(boolean) options.foreground Reindex in the foreground
      @cell(boolean) options.refresh Refresh after indexing (if not set refreshes only if indexing in the foreground)
  */
  PUBLIC MACRO ReindexGroup(STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , rebuild := FALSE
                                , refresh := FALSE
                                ], options, [ optional := [ "refresh" ]
                                            ]);

    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.foreground;

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "CHECKGROUP"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , indexid := this->catalog->id
              ];

      //TODO have a lowerlevel call 'checkgroup' thatis invoked on the content source and directly does listgroups3... as CheckGroup is reexecuting api.whlib to get the catalog
      MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#CheckGroup")(data,
                      [ refresh := refresh
                      ]);
    }
    ELSE
    {
      STRING command := "FASTCHECKGROUP " || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::ReindexGroup", CELL[ ...this->GetBaseDebugInfo(), groupid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /** Delete a group
      @param groupid Group to delete
      @cell(boolean) options.foreground Delete in the foreground
      @cell(boolean) options.refresh Refresh after delete (if not set refreshes only if deleting in the foreground)
  */
  PUBLIC MACRO DeleteGroup(STRING groupid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , refresh := FALSE
                                ], options, [ optional := [ "refresh" ]]);

    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.foreground;

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "DELETEGROUP"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , indexid := this->catalog->id
              ];

      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#DeleteGroup")(data, [ refresh := refresh ]);
      IF (RecordExists(result.error))
        THROW NEW Exception(result.error.message);
    }
    ELSE
    {
      STRING command := "DELETEGROUP " || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::DeleteGroup", CELL[ ...this->GetBaseDebugInfo(), groupid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /** Reindex an object
      @long Reindex a specific object in a specific group
      @param groupid Group to reindex the object in
      @param objectid Object to reindex
      @cell(boolean) options.foreground Reindex in the foreground
      @cell(boolean) options.refresh Refresh after indexing (if not set refreshes only if indexing in the foreground)
  */
  PUBLIC MACRO ReindexObject(STRING groupid, STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , refresh := FALSE
                                ], options, [ optional := [ "refresh" ]]);

    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.foreground;

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "CHECKOBJECT"
              , commanddate := GetCurrentDateTime()
              , contentsourceid := this->id
              , groupid
              , objectid
              , indexid := this->catalog->id
              ];

      //TODO have a lowerlevel call 'checkgroup' thatis invoked on the content source and directly does listgroups3... as CheckGroup is reexecuting api.whlib to get the catalog
      MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#CheckObject")(data, [ refresh := refresh ]);
    }
    ELSE
    {
      STRING command := ("CHECKOBJECT ") || this->catalog->id || " " || this->id || " " || EncodeJSON(groupid) || " " || EncodeJSON(objectid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::ReindexObject", CELL[ ...this->GetBaseDebugInfo(), groupid, objectid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /** Delete an object
      @param objectid Object id of the object to delete
      @cell(boolean) options.foreground Delete in the foreground
      @cell(boolean) options.refresh Refresh after deleting (if not set refreshes only if deleting in the foreground) */
  PUBLIC MACRO DeleteObject(STRING objectid, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , refresh := FALSE
                                ], options, [ optional := [ "refresh" ]]);

    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.foreground;

    IF(options.foreground)
    {
      RECORD data :=
          CELL[ action := "DELETEOBJECT"
              , commanddate := GetCurrentDateTime()
              , objectid
              , indexid := this->catalog->id
              ];

      RECORD result := MakeFunctionPtr("mod::consilio/lib/internal/fetcher_commands.whlib#DeleteObject")(data, [ refresh := refresh ]);
      IF (Length(result.errors) > 0)
        THROW NEW Exception(result.errors[0].message);
    }
    ELSE
    {
      STRING command := "DELETEOBJECT " || this->catalog->id || " " || EncodeJSON(objectid);
      IF(IsDebugTagEnabled("consilio:queues"))
        LogDebug("consilio", "ContentSource::DeleteObject", CELL[ ...this->GetBaseDebugInfo(), objectid ]);
      SendQueueManagerData(GetQueueDataFromCommand(command));
    }
  }

  /** Execute multiple reindex actions
      @long This allows catalogs to combine multiple actions (once support is available). If this action fails halfway
            through it may be unpredictable which actions succeeded and which failed.
      @param actions Actions to execute
      @cell(string) actions.action Action to take. Either `reindex` or `delete`
      @cell(string) actions.groupid Group ID. Required unless deleting a specific object
      @cell(string) actions.objectid Explicit object ID, leave empty to reindex/delete the whole group
      @cell(boolean) options.foreground Run in the foreground, wait for index to be refreshed
      @cell(boolean) options.refresh Refresh after the actions (if not set refreshes only if running in the foreground)
  */
  PUBLIC MACRO UpdateMultiple(RECORD ARRAY actions, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ foreground := FALSE
                                , rebuild := FALSE
                                , refresh := FALSE
                                ], options, [ optional := [ "refresh" ]]);

    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.foreground;

    actions := SELECT AS RECORD ARRAY ValidateOptions([ action := ""
                                                      , groupid := ""
                                                      , objectid := ""
                                                      ], actions, [ required := [ "action" ]
                                                                  , enums := [ action := [ "reindex", "delete" ]]
                                                                  , title := `actions[${#actions}]`
                                                                  ]) FROM actions;

    STRING ARRAY objectids_to_delete;
    FOREVERY(RECORD act FROM actions)
    {
      IF(act.action = "reindex")
      {
        IF(act.groupid = "")
          THROW NEW Exception(`Reindex action #${#act} require a groupid`);

        IF(act.objectid = "")
          this->ReindexGroup(act.groupid, CELL[...options, refresh := FALSE ]);
        ELSE
          this->ReindexObject(act.groupid, act.objectid, CELL[ ...options, DELETE rebuild, refresh := FALSE ]); //ReindexObject is currently always a rebuild
      }
      ELSE IF(act.action = "delete")
      {
        IF(act.objectid != "")
          INSERT act.objectid INTO objectids_to_delete AT END;
        ELSE IF(act.groupid != "")
          this->DeleteGroup(act.groupid, CELL[ ...options, DELETE rebuild, refresh := FALSE ] );
        ELSE
          THROW NEW Exception(`Delete action #${#act} requires either a groupid or an objectid`);
      }
    }

    IF(Length(objectids_to_delete) > 0)
      this->catalog->DeleteObjects(objectids_to_delete, CELL[ options.foreground, refresh := FALSE ]);

    IF(refresh)
      this->catalog->Refresh();
  }

  /// Delete this content source
  PUBLIC MACRO DeleteSelf()
  {
    UPDATE consilio.contentsources
       SET tag := "$consilio$deleted$" || id
     WHERE id = this->id;

    this->contentsource.id := 0; //to be safe
    GetConsilioFinishHandler()->ScheduleCleanup(); //remove deleted contentsources async
  }

  /** Wait for catalog being completey done
      @param options @includecelldef #DoWaitForContentSourceDone.options
  */
  PUBLIC MACRO WaitForIndexingDone(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    DoWaitForContentSourceDone(this->id, options);
    this->catalog->Refresh();
  }

  /** Get the path this source refers to
      @return WHFS path of the WHFS source object
  */
  PUBLIC STRING FUNCTION GetWHFSPath()
  {
    IF(this->contentsource.fsobject = 0)
      RETURN "";

    RETURN SELECT AS STRING whfspath FROM system.fs_objects WHERE id = this->contentsource.fsobject;
  }

>;

/** Catalog object
    @public
*/
STATIC OBJECTTYPE ConsilioCatalog
<
  RECORD catalog;

  //suffixes that we have ensured to exist
  STRING ARRAY ensuredsuffixes;

  /// @type(integer) Id of this catalog
  PUBLIC PROPERTY id(this->catalog.id,-);

  /// @type(string) Tag of this catalog
  PUBLIC PROPERTY tag(this->catalog.name,-);

  /// @type(string) Catalog title
  PUBLIC PROPERTY title(this->catalog.description,-);

  /// @type(integer) Catalog indexing priority (0 is default, higher priorities get indexed earlier)
  PUBLIC PROPERTY priority(this->catalog.priority,-);

  /// @type(string) Language of this catalog
  PUBLIC PROPERTY lang(this->catalog.lang,-);

  /// @type(boolean) Is this a managed catalog?
  PUBLIC PROPERTY managed(GetManaged,-);

  /// @type(boolean) Is this catalogs suffixed?
  PUBLIC PROPERTY suffixed(GetSuffixed,-);

  /// @type(string) The suffix mask used (eg "-*")
  PUBLIC PROPERTY suffixmask(this->catalog.suffix, -);

  /// @type(string) Where was this catalog defined?
  PUBLIC PROPERTY definedby(this->catalog.definedby,-);

  /// @type(string array) Enabled fieldgroups
  PUBLIC PROPERTY fieldgroups(GetFieldgroups,-);

  MACRO NEW(RECORD catalog)
  {
    this->catalog := catalog;
  }

  /** List of indices for this catalog. First returned record is the primary index
      @return List of attached indices
      @cell(integer) return.id ID (for update and delete)
      @cell(string) return.indexname Name of the index on the indexmanager
      @cell(integer) return.indexmanager Id of the indexmanager
      @cell(integer) return.searchpriority The 'priority' with which to use this indexmanager for searching. Higher priorities get used before lower priorities, priorities zero and lower are ignored for searches.
      @cell(boolean) return.readonly If true, the attached index is readonly
      @cell(boolean) return.isbuiltin If true, the indexmanager is builtin
  */
  PUBLIC RECORD ARRAY FUNCTION ListAttachedIndices()
  {
    RETURN
        SELECT catalog_indexmanagers.id
             , catalog_indexmanagers.indexname
             , catalog_indexmanagers.searchpriority
             , catalog_indexmanagers.readonly
             , indexmanager :=        indexmanagers.id
             , isbuiltin := indexmanagers.address IN ["builtin","builtin-opensearch"]
          FROM consilio.indexmanagers
             , consilio.catalog_indexmanagers
         WHERE catalog_indexmanagers.catalogid = this->catalog.id
               AND indexmanagers.id = catalog_indexmanagers.indexmanager
     ORDER BY searchpriority DESC, catalog_indexmanagers.id;
  }

  PUBLIC BOOLEAN FUNCTION IsReadyForStorage()
  {
    //IsReadyForStorage() is and old API from when configuration was still sync, so wait for reconfigure too
    RETURN this->WaitReady(DEFAULT DATETIME, [ forstorage := TRUE, forconfiguration := TRUE ]);
  }

  // return -1 for never ready, 0 for not ready, 1 for ready
  INTEGER FUNCTION CheckReady(RECORD checkoptions)
  {
    BOOLEAN isready := TRUE;
    TRY
    {
      RECORD ARRAY indices := SELECT * FROM this->ListAttachedIndices() WHERE NOT readonly;
      IF(Length(indices) = 0 AND checkoptions.forstorage)
        RETURN -1; //we need at least one writable index. if there are none, abort immediately

      IF(checkoptions.forconfiguration) //just ensure consilio:update is ready
      {
        IF(NOT WaitForTimedTask("consilio:update", DEFAULT DATETIME, CELL[ allowmissing := TRUE, checkoptions.debug ]))
          RETURN 0; //task not done / or not even installed yet
      }

      //A suffixed index will create the indices on demand, so ready for storage as long as we're attached
      IF(NOT this->suffixed)
        FOREVERY(RECORD indice FROM indices)
          IF(NOT IsOpenSearchIndexPresent(indice.indexmanager, indice.indexname)) //TODO also verify mapping/settings are truly applied
            RETURN 0;
    }
    CATCH(OBJECT<SearchUnavailableException> e)
    {
      //If we can't talk yet to the server, we're not readdy (IsOpenSearchIndexPresent is too low level to determine the proper response to no-opensaerch)
      RETURN 0;
    }

    RETURN 1;
  }

  /** Wait until the index is ready for storage
      @param deadline Deadline, set to DEFAULT DATETIME for nonblocking wait.
      @param options.forstorage Wait for storage to be ready. If the index is readonly, WaitReady will return immediately, even if the deadline wasn't hit yet
      @param options.forconfiguration Wait for configuration to be applied.
      @return True if index is ready */
  PUBLIC BOOLEAN FUNCTION WaitReady(DATETIME deadline, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ forstorage := FALSE, forconfiguration := FALSE, debug := FALSE ], options);

    IF(options.forconfiguration) //just ensure consilio:update is ready
    {
      OBJECT primary := GetPrimaryWebHareTransactionObject();
      IF(ObjectExists(primary) AND primary->IsWorkOpen())
        THROW NEW Exception(`WaitReady forconfiguration cannot be used with open work`); //as we can't observe the consilo:update task status then
    }

    WHILE(TRUE)
    {
      INTEGER status := this->CheckReady(options);
      IF(status = -1)
        RETURN FALSE; //abort immediately, ignore deadline.
      IF(status = 1)
        RETURN TRUE;

      IF(GetCurrentDatetime() > deadline)
        RETURN FALSE;

      Sleep(250);
    }
  }

  STRING ARRAY FUNCTION GetFieldgroups()
  {
    RETURN ParseXSList(this->catalog.fieldgroups);
  }

  PUBLIC RECORD ARRAY FUNCTION GetExpectedMapping()
  {
    IF(Length(this->catalog.internalmetadata) = 0)
      RETURN RECORD[];

    RECORD data := DecodeHSONBlob(this->catalog.internalmetadata);
    RETURN data.fields;
  }

  PUBLIC STRING ARRAY FUNCTION __GetSuggestedFields() //FIXME - Not sure if we need to keep this API - AddIndexManagerObjects can probably just walk the mapping
  {
    RECORD _sug := SELECT * FROM this->GetExpectedMapping() WHERE name = "_suggested";
    RETURN RecordExists(_sug) AND CellExists(_sug,'__suggestedfields') ? _sug.__suggestedfields : STRING[];
  }

  BOOLEAN FUNCTION GetManaged()
  {
    RETURN this->catalog.type = whconstant_consilio_catalogtype_managed;
  }

  BOOLEAN FUNCTION GetSuffixed()
  {
    RETURN this->catalog.suffix != "";
  }

  /** Describe how the catalog is stored. Useful for debugging
      @return Storage info, will not contain linefeeds but should be considered free form (so we can extend/modify it later) */
  PUBLIC STRING FUNCTION GetStorageInfo()
  {
    STRING ARRAY storage;
    FOREVERY(RECORD attachedindex FROM this->ListAttachedIndices())
    {
      STRING indexname := attachedindex.indexname;
      IF(attachedindex.readonly)
        indexname := `${indexname}(r/o)`;

      INSERT indexname INTO storage AT END;
    }

    IF(Length(storage) >= 1)
      RETURN `${this->tag} => (${Detokenize(storage,', ')})`;
    ELSE
      RETURN `${this->tag} => (unattached)`;
  }

  /// Explicitly refresh. You'll sometimes need this to ensure visibility of recent index changes
  PUBLIC MACRO Refresh()
  {
    //TODO cache these ids... they won't change that often..
    //TODO suffixes? or just always attach a wildcard? or should the caller ghive us the suffix(es) to  refresh?
    RefreshAttachedIndices(this->id);
  }

  /** Attach an index (backing store) to a catalog. Creation may not apply until you've waited for reconfiguration (WaitReady with forconfiguration := TRUE)
      @parmm indexmanager Index manager to use. Use 0 for the builtin index manager
      @cell(string) options.indexname Index name
      @cell(boolean) options.readonly Do not write to or apply mappings to this index
      @return ID of the newly attached index*/
  PUBLIC INTEGER FUNCTION AttachIndex(INTEGER indexmanager, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions(CELL[ indexname := ""
                                   , readonly := FALSE
                                   ], options);
    RECORD usemgr := SELECT * FROM ListIndexManagers() WHERE VAR indexmanager = 0 ? isdefault : id = VAR indexmanager;
    IF(NOT RecordExists(usemgr))
      THROW NEW Exception(indexmanager != 0 ? `No such indexmanager #${indexmanager}` : "No default indexmanager configured");

    IF(options.indexname = "")
    {
      IF(usemgr.isbuiltin)
        options.indexname := GenerateConsilioIndexName();
      ELSE
        THROW NEW Exception(`An indexname is required when using an external indexmanager`);
    }

    //OpenSearch requires lowercasen names;
    IF(options.indexname != ToLowercase(options.indexname))
      THROW NEW Exception(`An indexname must be lowercase`);
    IF(NOT IsValidConsilioIndexName(options.indexname))
      THROW NEW Exception(`Invalid indexname '${options.indexname}'`);

    INTEGER newid := MakeAutonumber(consilio.catalog_indexmanagers, "id");
    INSERT CELL[ id := newid
               , catalogid :=    this->id
               , indexmanager := usemgr.id
               , options.indexname
               , options.readonly
               , searchpriority := Length(SELECT FROM consilio.catalog_indexmanagers WHERE catalogid = this->id) = 0 ? 100 : 0
               ] INTO consilio.catalog_indexmanagers;

    //This will ensure the index is setup after Commit (it's unsafe to create it right away, cleanupindices might 'disagree' - and this *does* happen during eg. CI)
    //Note that a suffixed index creates indices on demand so we don't need to update anything
    IF(NOT options.readonly AND NOT this->suffixed)
      GetConsilioFinishHandler()->ScheduleUpdate();

    RETURN newid;
  }

  PUBLIC MACRO DetachIndex(INTEGER indexid)
  {
    RECORD todelete := SELECT * FROM consilio.catalog_indexmanagers WHERE id = indexid AND catalogid = this->id;
    IF(NOT RecordExists(todelete))
      THROW NEW Exception(`No such attached index #${indexid}`);

    DELETE FROM consilio.catalog_indexmanagers
     WHERE id = VAR indexid;

    GetConsilioFinishHandler()->ScheduleCleanup(); //remove stale indices ASAP (TODO only for builtin indexmanagers?)
  }

  /** Update catalog settings. Note thate some settings will not apply until you've waited for reconfiguration (WaitReady with forconfiguration := TRUE)
      @param settings Settings to apply.
      @cell(string) settings.definedby Definition location
  */
  PUBLIC MACRO UpdateCatalog(RECORD settings)
  {
    settings := ValidateOptions([ definedby := ""
                                , lang := ""
                                , fieldgroups := STRING[]
                                , suffixed := TRUE
                                , title := ""
                                , priority := 0
                                ], settings, [ optional := ["*"]
                                             , title := "settings"
                                             ]);

    //TODO shouldn't we lock other properties like fieldgroups in case a catalogconfig is available, to prevent battles with consilio:update ? or explicitly only set some props at creation?
    RECORD catalogconfig := SELECT * FROM GetRequiredCatalogs(TRUE, "*") WHERE tag = this->tag;

    // If the catalog language changes, the catalog has to be rebuilt
    IF(RecordExists(catalogconfig))
    {
      IF(CellExists(settings, 'lang'))
        THROW NEW Exception(`Catalog ${this->tag} is configured in the moduledefinition, you cannot update its language`);
      INSERT CELL lang := catalogconfig.lang INTO settings; //enforce this setting
    }

    BOOLEAN language_changed := CellExists(settings, "lang") AND settings.lang != this->lang;

    RECORD cursettings := SELECT * FROM consilio.catalogs WHERE id = this->id;
    IF(NOT RecordExists(cursettings))
      THROW NEW Exception(`Catalog ${this->tag} (#${this->id}) is no longer present in the database`);

    STRING applylanguage := CellExists(settings,"lang") ? settings.lang : this->lang;
    IF(CellExists(settings, 'title'))
    {
      settings := CELL[ ...settings
                      , description := settings.title
                      , DELETE title
                      ];
     }

    IF(CellExists(settings, 'suffixed'))
    {
      IF(settings.suffixed AND this->managed)
        THROW NEW Exception(`A managed index can't be set to suffixed`);

      settings := CELL[ ...settings
                      , DELETE suffixed
                      , suffix := settings.suffixed ? whconstant_consilio_default_suffix_mask : ""
                      ];
    }

    // Determine final fieldgroups
    STRING ARRAY applyfieldgroups;
    IF(RecordExists(catalogconfig))
    {
      IF(CellExists(settings, 'fieldgroups'))
        THROW NEW Exception(`Catalog ${this->tag} is configured in the moduledefinition, you cannot update its fieldgroups`);
      INSERT CELL fieldgroups := catalogconfig.fieldgroups INTO settings; //enforce this setting
    }

    IF(CellExists(settings, 'fieldgroups'))
    {
      STRING newval := __BuildFieldgroups(settings.fieldgroups);
      applyfieldgroups := settings.fieldgroups;
      DELETE CELL fieldgroups FROM settings;

      IF(newval != this->catalog.fieldgroups) //a change
        INSERT CELL fieldgroups := newval INTO settings;
    }
    ELSE
    {
      applyfieldgroups := ParseXSList(cursettings.fieldgroups);
    }

    // Load currently applicable metadta
    RECORD internalmetadata;
    IF(Length(cursettings.internalmetadata) != 0)
      internalmetadata := DecodeHSONBlob(cursettings.internalmetadata);

    internalmetadata := EnforceStructure(CELL[ lastupdate := DEFAULT DATETIME
                                             , fields := RECORD[]
                                             , lang := "?" //mark that we never stored the language yet
                                             ], internalmetadata);

    RECORD ARRAY contentsources;
    IF(this->managed)
      contentsources := this->ListContentSources([__withdata := TRUE]);

    RECORD config := CalculateExpectedConfiguration(applyfieldgroups, this->managed, this->tag, contentsources, applylanguage);
    BOOLEAN fieldschanged := EncodeHSON(config.fields) != EncodeHSON(internalmetadata.fields);
    BOOLEAN languagechanged := config.lang != internalmetadata.lang;
    BOOLEAN scheduleupdate := fieldschanged OR (languagechanged AND internalmetadata.lang != "?"); //ignore changing ? to a language for update, as this may just be a 5.0x->5.03 upgrade

    IF(fieldschanged OR languagechanged)
    {
      internalmetadata := BuildInternalMetadataFromConfiguration(config);
      INSERT CELL internalmetadata := EncodeHSONBlob(internalmetadata) INTO settings;
    }

    IF(Length(UnpackRecord(settings)) = 0)
      RETURN; //no change

    UPDATE consilio.catalogs SET RECORD settings WHERE id = this->id;

    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    this->catalog := SELECT * FROM consilio.catalogs WHERE id = this->id;

    IF(scheduleupdate)
      GetConsilioFinishHandler()->ScheduleUpdate();

    this->ensuredsuffixes := STRING[]; //better recheck everything after a catalog update
  }

  /// Delete this catalog
  PUBLIC MACRO DeleteSelf()
  {
    DELETE FROM consilio.catalogs WHERE id = this->id;

    GetPrimary()->BroadCastOnCommit("consilio:indiceschanged", DEFAULT RECORD);
    this->catalog.id := 0; //to be safe

    GetConsilioFinishHandler()->ScheduleCleanup(); //remove stale indices ASAP
  }

  /** List the contentsources in this catalog
      @return List of contentsources
      @cell(integer) return.id Id of the contentsource
      @cell(string) return.contentprovider Content provider type
      @cell(string) return.contentobject Content objecttype implement with this source
      @cell(string) return.tag Tag of the contentsource
      @cell(string) return.title Title of the contentsource
      @cell(integer) return.fsobject Associated filesystem object
      @cell(boolean) return.isorphan Whether the contentsource is an orphan
  */
  PUBLIC RECORD ARRAY FUNCTION ListContentSources(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);

    options := ValidateOptions([ __withdeleted := FALSE, __withdata := FALSE ], options);
    RECORD ARRAY sources :=
        SELECT TEMPORARY settings := (data = "" ? DEFAULT RECORD : DecodeHSON(data))
             , __data := options.__withdata ? data : ""
             , id
             , contentprovider
                                //TODO lookup contentobject from moduledefs where possible, bad experiences with db-stored HS references
             , contentobject := CellExists(settings, 'contentobject') AND settings.contentobject != "" ? settings.library || "#" || settings.contentobject : ""
             , tag
             , title
             , fsobject
             , isorphan := orphansince != DEFAULT DATETIME
             , isdeleted := tag LIKE "$consilio$deleted$*" //flagged as deleted
                            OR (contentprovider = VAR whconstant_consilio_contentprovider_site  //contentsource whose target folder is deleted
                                AND fsobject = 0
                                AND NOT CellExists(settings,"folder") //AND has been converted by setcontentsourcefsobjects.whscr
                               )
             , definedby
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id;

    IF (NOT options.__withdeleted)
      sources := SELECT *, DELETE isdeleted FROM sources WHERE NOT isdeleted;
    IF (NOT options.__withdata)
      sources := SELECT *, DELETE __data FROM sources;

    RETURN sources;
  }

  MACRO EnsureSuffixCreated(STRING suffix)
  {
    IF(suffix = "" OR NOT IsValidConsilioIndexSuffix(suffix))
      THROW NEW Exception(`Invalid suffix name '${suffix}'`);

    this->EnsureIndexSettings([suffix]);
    IF(suffix NOT IN this->ensuredsuffixes)
      INSERT suffix INTO this->ensuredsuffixes AT END;
  }

  MACRO EnsureIndexSettings(STRING ARRAY suffixes)
  {
    RECORD ARRAY newmapping := this->GetExpectedMapping();
    RECORD finalupdate := PrepareMappingUpdate(newmapping);
    STRING ARRAY synonyms := SELECT AS STRING ARRAY Detokenize(words, ", ") FROM this->GetSynonyms();

    FOREVERY(RECORD opensearch FROM SELECT * FROM this->ListAttachedIndices() WHERE NOT readonly)
      FOREVERY(STRING suffix FROM suffixes)
      {
        IF(suffix != "" AND NOT IsValidConsilioIndexSuffix(suffix))
          THROW NEW Exception(`Invalid suffix name '${suffix}'`);
        EnsureOpenSearchIndexConfiguration(opensearch.indexmanager, opensearch.indexname, suffix, synonyms, this->catalog.lang, finalupdate);
      }
  }

  PUBLIC STRING ARRAY FUNCTION __ListSuffixes()
  {
    STRING ARRAY updatesuffixes := SELECT AS STRING ARRAY suffix FROM this->ListSuffixes();
    IF(NOT this->suffixed AND "" NOT IN updatesuffixes)
      INSERT "" INTO updatesuffixes AT END; //on an empty unsuffixed catalog, even unmanaged, create and configure the root index
    RETURN updatesuffixes;
  }

  /** @short Make sure configuration is applied and, if unsuffixed, the root index exists
      @cell(string array) options.suffixes Update the configuration of the specified suffixes only, and ensure they exist
  */
  PUBLIC MACRO ApplyConfiguration(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    OBJECT lock := OpenLockManager()->LockMutex("consilio:updatecatalog." || this->id);
    TRY
    {
      //TODO? allow us to explicitly specify suffixes to ensure/reconfigure
      options := ValidateOptions(CELL[ suffixes := STRING[] ], options, [ optional := ["suffixes" ]]);

      STRING ARRAY updatesuffixes := CellExists(options, 'suffixes') ? options.suffixes : this->__ListSuffixes();

      this->EnsureIndexSettings(updatesuffixes);
      this->ensuredsuffixes := ArrayUnion(this->ensuredsuffixes, updatesuffixes);
    }
    FINALLY
    {
      lock->Release();
    }
  }

  /** @short Get the catalog's synonyms list
      @return The grouped synonyms
      @cell(integer) wordgroupid Word group id
      @cell(string array) words The words within this group
  */
  PUBLIC RECORD ARRAY FUNCTION GetSynonyms()
  {
    RETURN
        SELECT wordgroupid := wordgroup
             , words := GroupedValues(word)
          FROM consilio.thesaurus
         WHERE catalogid = this->id
         GROUP BY wordgroup;

  }

  /** @short Update the catalog's synonyms list
      @param words The grouped synonyums
      @includecelldef #GetSynonyms.return
  */
  PUBLIC MACRO SetSynonyms(RECORD ARRAY words)
  {
    INTEGER ARRAY updated;
    BOOLEAN anychanges;
    STRING ARRAY stopwords := CellExists(stopwordlists, this->lang) ? GetCell(stopwordlists, this->lang) : STRING[];
    FOREVERY (RECORD row FROM words)
    {
      // Check the words for stopwords
      IF (Length(stopwords) > 0)
      {
        FOREVERY (STRING word FROM row.words)
        {
          // Just split words on space, interpunction is allowed in synonyms
          FOREVERY (STRING tocheck FROM Tokenize(word, " "))
          {
            IF (tocheck = "")
              CONTINUE;
            //FIXME: ToLowercase doesn't properly lowercase accented letters!
            IF (ToLowercase(tocheck) IN stopwords)
              THROW NEW Exception(`Stopwords are not allowed in synonyms (found '${tocheck}'${ tocheck != word ? ` in '${word}'` : ""})`);
          }
        }
      }

      INTEGER wordgroupid := CellExists(row, "wordgroupid")
          ? row.wordgroupid
          : (SELECT AS INTEGER Max(wordgroup) FROM consilio.thesaurus) + 1;
      INSERT wordgroupid INTO updated AT END;

      RECORD ARRAY oldwordgroup := SELECT id, word FROM consilio.thesaurus WHERE wordgroup = wordgroupid;
      STRING ARRAY newwordgroup := row.words;

      // Delete old words that are not in the new words group
      FOREVERY (RECORD todelete FROM oldwordgroup)
        IF (todelete.word NOT IN newwordgroup)
        {
          DELETE FROM consilio.thesaurus WHERE id = todelete.id;
          anychanges := TRUE;
        }

      // Add new words that are not in the old words group
      STRING ARRAY toadd := ArrayDelete(newwordgroup, SELECT AS STRING ARRAY word FROM oldwordgroup);
      FOREVERY (STRING word FROM toadd)
      {
        INSERT INTO consilio.thesaurus(catalogid, word, wordgroup)
               VALUES(this->id, word, wordgroupid);
        anychanges := TRUE;
      }
    }
    IF (RecordExists(SELECT FROM consilio.thesaurus WHERE catalogid = this->id AND wordgroup NOT IN updated))
    {
      DELETE FROM consilio.thesaurus WHERE catalogid = this->id AND wordgroup NOT IN updated;
      anychanges := TRUE;
    }

    IF(anychanges)
      GetConsilioFinishHandler()->ScheduleUpdate();
  }

  RECORD FUNCTION GetBaseDebugInfo()
  {
    RETURN CELL[ catalog := this->tag
               , catalogid := this->id
               , trace := ArraySlice(GetStackTrace(),2)
               ];
  }

  /** @short Add objects to this catalog
      @param objects The objects to add
      @cell(string) objects._id Optional OpenSearch document id, unique within the index
      @cell(string) objects.objectid Unique objectid. Reusing this will replace the document in the index+suffix combo
      @cell(record) objects.documentfields Document fields
      @cell(string) options.suffix Use this parameter to create a subindex with this suffix
      @cell(boolean) options.synchronous Wait for the added documents to become visible
      @cell(integer) options.chunktimeout Timeout per chunk, defaults to opensearch_write_timeout (5 minutes)
  */
  PUBLIC MACRO AddObjects(RECORD ARRAY objects, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(this->managed)
      THROW NEW Exception(`Managed catalogs do not support manual document management`);

    options := ValidateOptions( [ suffix := ""
                                , chunksize := 128
                                , synchronous := FALSE
                                , debug := FALSE
                                , chunktimeout := opensearch_write_timeout
                                ], options);
    //are these still relevant? only used by legacy consilio
    // @cell objects.suggestfields
    // @cell objects.suggestprefixes

    IF(options.suffix != "" AND NOT this->suffixed)
      THROW NEW Exception(`Cannot AddObjects to a suffix on a non-suffixed catalog`);

    IF(options.suffix != "" AND options.suffix NOT IN this->ensuredsuffixes)
      this->EnsureSuffixCreated(options.suffix);

    objects := SELECT _id := CellExists(objects, "_id") ? _id : "", objectid, documentfields FROM objects;
    FOREVERY (RECORD chunk FROM SELECT docs := GroupedValues(objects) FROM objects GROUP BY #objects / options.chunksize)
    {
      AddIndexManagerObjects(this, DEFAULT RECORD, "", chunk.docs, CELL[ options.suffix, refresh := options.synchronous, options.debug, timeout := options.chunktimeout ]);
    }
  }

  /** @short Delete objects from this catalog
      @param objectids Delete objects with these objectids in the index+suffix combo
      @cell(string) options.suffix Use this parameter to create a subindex with this suffix
      @cell(boolean) options.foreground Delete in the foreground, wait for index to be refreshed
      @cell(boolean) options.refresh Refresh after deleting (if not set refreshes only if deleting in the foreground)
      @cell(boolean) options.raw_ids The supplied objectids are OpenSearch document ids (`_id`)
  */
  PUBLIC MACRO DeleteObjects(STRING ARRAY objectids, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    options := ValidateOptions( [ suffix := ""
                                , chunksize := 128
                                , synchronous := FALSE //legacy, remove as soon as all callers are updated
                                , foreground := FALSE
                                , refresh := FALSE
                                , raw_ids := FALSE
                                ], options, [ optional := ["refresh"] ]);

    //TODO support background running? we're always running in the foreground now..
    BOOLEAN refresh := CellExists(options,'refresh') ? options.refresh : options.synchronous OR options.foreground;

    FOR (INTEGER curchunk := 0; curchunk < Length(objectids); curchunk := curchunk + options.chunksize)
    {
      STRING ARRAY chunk := ArraySlice(objectids, curchunk, options.chunksize);
      DeleteIndexManagerObjects(this->id, 0, chunk, CELL[ options.suffix, refresh, options.raw_ids ]);
    }
  }

  /** @short Delete a suffix from the index manager
      @param suffix Suffix to delete. Empty to delete an unsuffixed unmanaged index (which can then be recreated using ApplyConfiguration)
  */
  PUBLIC MACRO DeleteSuffix(STRING suffix)
  {
    OBJECT lock := OpenLockManager()->LockMutex("consilio:updatecatalog." || this->id);
    TRY
    {
      IF(this->managed)
        THROW NEW Exception(`Managed catalogs do not support manual document management`);
      IF(suffix != "" AND NOT this->suffixed)
        THROW NEW Exception(`Cannot DeleteSuffix on a non-suffixed catalog unless specifying an empty suffix`);
      IF(suffix = "" AND this->suffixed)
        THROW NEW Exception(`A suffixed catalog requires you to specify a suffix`);

      //FIXME multiindex support.
      RECORD res := DeleteIndexManagerContentSource(this->ListAttachedIndices()[0].indexmanager, this->id, 0, CELL[ suffix ]);
      IF(res.status != SearchOk AND res.status != "indexnotfound") //it's fine if the index is already deleted (this can happen because we currently mark indices as deleted but DeleteIndexManagerContentSource still attempts to delete them again)
        THROW NEW Exception(`Unable to DeleteIndex: ${res.status}`);

      IF(suffix IN this->ensuredsuffixes)
        DELETE FROM this->ensuredsuffixes AT SearchElement(this->ensuredsuffixes, suffix);
    }
    FINALLY
    {
      lock->Release();
    }
  }

  /** @short List suffixes created in this index
      @return The suffixes
      @cell(string) return.suffix Suffix name. Can be empty for the main index */
  PUBLIC RECORD ARRAY FUNCTION ListSuffixes()
  {
    RECORD indexmgr := this->ListAttachedIndices();
    IF(NOT RecordExists(indexmgr))
      RETURN RECORD[]; //TODO or should we throw ?

    RETURN ListOpenSearchIndexSuffixes(indexmgr.indexmanager, indexmgr.indexname);
  }

  OBJECT FUNCTION CreateContentSource(RECORD csourcesettings)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);

    INTEGER srcid := MakeAutonumber(consilio.contentsources, "id");
    csourcesettings := CELL[ id := srcid
                           , catalogid := this->catalog.id
                           , csourcesettings.definedby
                           , ...csourcesettings
                           , data := EncodeHSON(CellExists(csourcesettings,'data') ? csourcesettings.data : DEFAULT RECORD)
                           , status := csourcesettings.enabled ? contentsourcestatus_idle : contentsourcestatus_disabled
                           , DELETE enabled
                           ];

    INSERT csourcesettings INTO consilio.contentsources;

    OBJECT contentsource := this->OpenContentSourceById(srcid);
    GetConsilioFinishHandler()->RequestReindexContentSource(contentsource);

    this->UpdateCatalog(DEFAULT RECORD);

    IF(Length(this->ListContentSources()) = 1 AND Length(this->ListAttachedIndices())=0) //it's the first source and no storage yet, so create it
      this->AttachIndex(0);

    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    GetConsilioFinishHandler()->ScheduleUpdate();

    RETURN contentsource;
  }

  /** Add a publisher content source
      @param targetfolder Folder to index
      @cell options.definedby Use to describe who added this custom content source was added
      @rreutn Newly created content source
  */
  PUBLIC OBJECT FUNCTION AddFolderToCatalog(INTEGER targetfolder, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);

    options :=  ValidateOptions(
        CELL[ ...default_contentsource_options
            , definedby :=            "AddFolderToCatalog from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
            ], options);

    FOREVERY (RECORD contentsource FROM
        SELECT id, fsobject
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id
               AND contentprovider = VAR whconstant_consilio_contentprovider_site
               AND tag NOT LIKE "$consilio$deleted$*")
    {
      IF ((contentsource.fsobject = targetfolder) OR IsFolderAncestorOf(contentsource.fsobject, targetfolder)) // targetfolder is already covered by searchroot
      {
        STRING path := SELECT AS STRING whfspath FROM system.fs_objects WHERE id = targetfolder;
        THROW NEW Exception(`A contentsource containing folder #${targetfolder} (${path}) already exists in catalog '${this->tag}'`);
      }
      ELSE IF (IsFolderAncestorOf(targetfolder, contentsource.fsobject)) // folderid contains searchroot
      {
        UPDATE consilio.contentsources SET tag := "$consilio$deleted$" || id || ":" || tag WHERE id = contentsource.fsobject; // remove contained folder (FIXME sure? what if the siteprl is configured to just recreate this situation? )
      }
    }

    RETURN this->CreateContentSource(CELL[ ...options
                                          , contentprovider := whconstant_consilio_contentprovider_site
                                          , fsobject := targetfolder
                                          ]);
  }

  /** Add a new custom content source to a index
      @param tag Tag of the new content source
      @param contentsourceobject Library and name of object that handles indexing (lib#name)
      @cell options.definedby Use to describe who added this custom content source was added
      @cell options.contentcheckinterval Interval between rechecks (defaults to -1, no recheck)
      @cell options.folder Associated folder
      @cell options.title Title for the content source
  */
  PUBLIC OBJECT FUNCTION AddCustomContentSource(STRING tag, STRING contentsourceobject, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);

    IF(tag="" OR tag NOT LIKE "?*:?*" OR tag LIKE "*:*:*")
      THROW NEW Exception(`Invalid content source tag '${tag}'`);

    options :=  ValidateOptions(
        CELL[ ...default_contentsource_options
            , definedby :=            "AddCustomContentSource from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
            , contentcheckinterval := -1
            , title := ""
            ], options);

    IF (RecordExists(SELECT FROM consilio.contentsources WHERE ToUppercase(COLUMN tag) = ToUppercase(VAR tag)))
      THROW NEW Exception(`A contentsource with tag '${tag}' already exists (note: tags must currently be globally unique!)`);

    STRING ARRAY parts := Tokenize(contentsourceobject, "#");
    RECORD settings :=
        [ library :=              parts[0]
        , contentobject :=        parts[1]
        , contentcheckinterval := options.contentcheckinterval
        , lastcontentscheck :=    ""
        ];

    RETURN this->CreateContentSource(CELL[ ...options
                                          , contentprovider := "consilio:custom"
                                          , tag
                                          , data := settings
                                          , DELETE contentcheckinterval
                                          ]);
  }

  /** @short Open catalog by tag
      @param tag Tag of the contentsource
      @return(object #ContentSource) The content source object
  */
  PUBLIC OBJECT FUNCTION OpenContentSource(STRING tag)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);
    IF(tag = "")
      THROW NEW Exception(`Missing tag for contentsource to open`);

    RECORD match :=
        SELECT *
          FROM consilio.contentsources
         WHERE catalogid = this->catalog.id
               AND ToUppercase(contentsources.tag) = ToUppercase(VAR tag);
    IF(RecordExists(match))
      RETURN NEW ContentSource(this, match);
    ELSE
      RETURN DEFAULT OBJECT;
  }

  /** @short Open catalog by id
      @param id Id of the contentsource
      @return(object #ContentSource) The content source object
  */
  PUBLIC OBJECT FUNCTION OpenContentSourceById(INTEGER id)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`Unmanaged catalogs do not support content sources`);

    RECORD match := SELECT * FROM consilio.contentsources WHERE contentsources.id = VAR id AND tag NOT LIKE "$consilio$deleted$*";
    IF(RecordExists(match))
      RETURN NEW ContentSource(this, match);
    ELSE
      RETURN DEFAULT OBJECT;
  }

  /** @short Reindex the catalog
      @long Reindexes all sources in the catalog and cleans up any objects belonging to nonexisting sources */
  PUBLIC MACRO ReindexCatalog(RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF(NOT this->managed)
      THROW NEW Exception(`ReindexCatalog rebuilds using content sources, but unmanaged catalogs do not support these`);

    options := ValidateOptions([ rebuild := FALSE ], options);

    STRING command := "CHECKINDEX " || this->id;
    IF(IsDebugTagEnabled("consilio:queues"))
      LogDebug("consilio", "ManagedCatalog::ReindexCatalog", CELL[...this->GetBaseDebugInfo() ]);
    SendQueueManagerData(GetQueueDataFromCommand(command));
  }
>;

/** @short List all Consilio catalogs
    @param options Options
    @return List of catalogs
    @cell(integer) return.id Catalog id
    @cell(string) return.tag Catalog tag
    @cell(string) return.description Description
    @cell(string) return.definedby Where this catalog was defined/created
    @cell(string) return.lang Catalog language
    @cell(boolean) return.managed True if this is managed catalog (supports contentsources)
    @cell(string) return.suffixmask Wildcard mask for related suffixes, if any
*/
PUBLIC RECORD ARRAY FUNCTION ListConsilioCatalogs(RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[], options);
  RECORD ARRAY catalogs :=
      SELECT id
           , tag := name
           , managed := type = whconstant_consilio_catalogtype_managed
           , suffixmask := suffix
           , description
           , lang
           , definedby
        FROM consilio.catalogs;

  RETURN catalogs;
}

/** @short Open catalog by tag
    @param tag Catalog tag
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION OpenConsilioCatalog(STRING tag)
{
  RECORD match :=
      SELECT * FROM consilio.catalogs
       WHERE ToUppercase(name) = ToUppercase(tag);

  IF(RecordExists(match))
    RETURN NEW ConsilioCatalog(match);
  ELSE
    RETURN DEFAULT OBJECT;
}

/** @short Open catalog by id
    @param id Catalog id
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION OpenConsilioCatalogById(INTEGER id)
{
  RECORD match :=
      SELECT * FROM consilio.catalogs
       WHERE catalogs.id = VAR id;

  IF(RecordExists(match))
    RETURN NEW ConsilioCatalog(match);
  ELSE
    RETURN DEFAULT OBJECT;
}

/** @short Open content source by id
    @param id Content source id
    @return(object #ContentSource) The content source object
*/
PUBLIC OBJECT FUNCTION OpenContentSourceById(INTEGER id)
{
  INTEGER catalogid :=
      SELECT AS INTEGER contentsources.catalogid
        FROM consilio.contentsources
       WHERE contentsources.id = VAR id
             AND tag NOT LIKE "$consilio$deleted$*";
  OBJECT catalog := OpenConsilioCatalogById(catalogid);
  RETURN ObjectExists(catalog) ? catalog->OpenContentSourceById(id) : DEFAULT OBJECT;
}

/** @short Create a new Consilio catalog.
    @param tag The name of the catalog (this name should be unique)
    @param options Options
    @cell options.title An optional description for the catalog
    @cell options.priority (-9 to 9, 0 is the default)
    @cell(boolean) options.managed Create a managed catalog where consilio manages attached indices and content. Defaults to TRUE
    @cell(boolean) options.suffixed Create a suffixed catalog
    @return(object #Catalog) Catalog object
*/
PUBLIC OBJECT FUNCTION CreateConsilioCatalog(STRING tag, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF(tag="" OR tag NOT LIKE "?*:?*" OR tag LIKE "*:*:*")
    THROW NEW Exception(`Invalid catalog tag '${tag}'`);

  // Index name should be unique
  IF (RecordExists(SELECT FROM consilio.catalogs WHERE ToUppercase(name) = ToUppercase(tag)))
    THROW NEW Exception(`Catalog with tag '${tag}' already exists`);

  options := ValidateOptions( [ loglevel := 0
                              , priority := 0
                              , title := ""
                              , definedby := "CreateConsilioCatalog from " || GetStackTrace()[1].filename || "#" || ToLowercase(GetStackTrace()[1].func)
                              , fieldgroups := STRING[]
                              , managed := TRUE // FIXME should have been FALSE - correct that in the JS API
                              , suffixed := FALSE
                              , lang := ""
                              ], options, [ optional := [ "fieldgroups", "lang" ]]);

  INTEGER indexid := MakeAutoNumber(consilio.catalogs, "id");

  IF(options.suffixed AND options.managed)
    THROW NEW Exception(`A managed index can't be set to suffixed`);

  STRING lang;
  STRING ARRAY fieldgroups;

  RECORD catalogconfig := SELECT * FROM GetRequiredCatalogs(TRUE, "*") WHERE COLUMN tag = VAR tag;
  IF(RecordExists(catalogconfig))
  {
    IF(CellExists(options, 'fieldgroups'))
      THROW NEW Exception(`Catalog ${tag} is configured in the moduledefinition, you cannot update its fieldgroups`);
    IF(CellExists(options, 'lang'))
      THROW NEW Exception(`Catalog ${tag} is configured in the moduledefinition, you cannot update its language`);
  }

  IF(CellExists(options,'fieldgroups'))
    fieldgroups := options.fieldgroups;
  ELSE IF(NOT CellExists(options,'fieldgroups') AND RecordExists(catalogconfig))
    fieldgroups := catalogconfig.fieldgroups;

  IF(CellExists(options,'lang'))
    lang := options.lang;
  ELSE IF(NOT CellExists(options,'lang') AND RecordExists(catalogconfig))
    lang := catalogconfig.lang;

  // Prepare configuration
  RECORD config := CalculateExpectedConfiguration(fieldgroups, options.managed, tag, RECORD[], lang); //no contentsource ids yet
  RECORD internalmetadata := BuildInternalMetadataFromConfiguration(config);

  INSERT CELL[ id := indexid
             , name := tag
             , description := options.title
             , options.loglevel
             , options.priority
             , options.definedby
             , type := options.managed ? whconstant_consilio_catalogtype_managed
                                       : whconstant_consilio_catalogtype_unmanaged
             , suffix := options.suffixed ? whconstant_consilio_default_suffix_mask : ""
             , fieldgroups := __BuildFieldgroups(fieldgroups)
             , lang
             , internalmetadata := EncodeHSONBlob(internalmetadata)
             ] INTO consilio.catalogs;

  IF(options.managed) //creating a managed catalog will require us to attach and configure it:
    GetConsilioFinishHandler()->ScheduleUpdate();

  GetPrimary()->BroadCastOnCommit("consilio:indiceschanged", DEFAULT RECORD);

  OBJECT catalog := OpenConsilioCatalogById(indexid);
  RETURN catalog;
}
