<?wh
/** @private Internal library implementing indexing of external URLs */

LOADLIB "wh::datetime.whlib";
LOADLIB "mod::consilio/lib/contentproviders/contentprovider.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

// Content provider for external content (general spidering of websites)
PUBLIC OBJECTTYPE ExternalContentProvider EXTEND ConsilioContentProvider
< STRING rooturl;
  STRING http_username;
  STRING http_password;
  STRING ARRAY objects;

  STRING FUNCTION GetGroupId()
  {
    RETURN "external:" || this->contentsourceid;
  }

  /*  @param contentsource The content source record which contains the configuration for the content provider
      @cell contentsource.data(record) Initialization data
      @cell contentsource.data.url(string) URL to spider
      @cell contentsource.data.http_username(string) User name to use if the output url is login-protected (optional)
      @cell contentsource.data.http_password(string) Password to use if the output url is login-protected (optional)
  */
  UPDATE PUBLIC MACRO Init(RECORD contentsource)
  {
    ConsilioContentProvider::Init(contentsource);

    // Set root URL
    this->rooturl := CellExists(contentsource.data, "url") ? contentsource.data.url : "";

    // HTTP login data
    this->http_username := CellExists(contentsource.data, "http_username") ? contentsource.data.http_username : "";
    this->http_password := this->http_username != "" AND CellExists(contentsource.data, "http_password") ? contentsource.data.http_password : "";

    this->DebugLog(ConsilioDebugInfo, "Initialized with root URL " || this->rooturl);
    IF (this->http_username != "")
      this->DebugLog(ConsilioDebugInfo, "Initialized with http login '" || this->http_username || "'/'" || this->http_password || "'");

    IF (this->rooturl = "")
      THROW NEW Exception("Tried to initialize without URL");
  }

  UPDATE PUBLIC STRING FUNCTION GetIdentifier()
  {
    RETURN this->rooturl != "" ? this->rooturl : this->GetGroupId();
  }

  UPDATE PUBLIC STRING FUNCTION GetContentSourceTitle()
  {
    RETURN this->rooturl;
  }

  UPDATE PUBLIC RECORD FUNCTION GetEmptySearchRecord()
  {
    RECORD emptyrec := ConsilioContentProvider::GetEmptySearchRecord();
    INSERT CELL filetype := "" INTO emptyrec;
    INSERT CELL date_modified := DEFAULT DATETIME INTO emptyrec;
    INSERT CELL size := 0 INTO emptyrec;
    RETURN emptyrec;
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION ListGroups(DATETIME commanddate)
  {
    // We don't have 'groups', so only returning one group with some non-empty id
    this->DebugLog(ConsilioDebugInfo, "ListGroups: Returning group id " || this->GetGroupId());
    RETURN [ [ id := this->GetGroupId() ] ];
  }

  UPDATE PUBLIC RECORD ARRAY FUNCTION ListObjects(DATETIME commanddate, STRING groupid)
  {
    IF (groupid != this->GetGroupId())
      THROW NEW Exception("Not fetching pages for content source " || groupid);

    // Reset internal objects cache
    this->objects := DEFAULT STRING ARRAY;

    // Only returning the main URL for now, subsequent URL's will be returned by FetchObject
    this->DebugLog(ConsilioDebugInfo, "ListObjects: Returning url " || this->rooturl);
    RETURN [ [ id := this->rooturl ] ];
  }

  UPDATE PUBLIC RECORD FUNCTION FetchObject(DATETIME commanddate, STRING groupid, STRING objectid, RECORD options)
  {
    //ADDME: This check fails if explicitly fetching the same object multiple times using CheckObject
    IF (objectid IN this->objects)
    {
      this->DebugLog(ConsilioDebugSkipped, "already fetched URL " || objectid);
      THROW NEW ConsilioIgnoredException(ConsilioDebugSkipped, "Not fetching '" || objectid || "': already fetched");
    }
    ELSE IF (Length(this->objects) >= this->maxgroupobjects)
    {
      this->DebugLog(ConsilioDebugSkipped, "superfluous URL " || objectid || " (already fetched " || Length(this->objects) || " pages)");
      THROW NEW Exception("Not fetching '" || objectid || "': too many pages");
    }
    this->DebugLog(ConsilioDebugInfo, "Fetching URL '" || objectid || "'");

    // Fetch the page
    RECORD page := this->FetchAndParseUrl(TRUE, objectid, [ username := this->http_username, password := this->http_password ]);

    RECORD fields; // Left empty if page may not be indexed
    STRING body; // Left empty if page may not be indexed
    IF (page.parsed_page.index_page) //should we index this page?
    {
      // Make a document record
      this->DebugLog(ConsilioDebugAll, "Received " || Length(page.parsed_page.text) || " bytes of body text");
      fields := [ size := ToString(Length(page.fetched_page.content))
                ];
      IF (page.parsed_page.title != "")
        INSERT CELL title := page.parsed_page.title INTO fields;
      IF (page.parsed_page.keywords != "")
        INSERT CELL keywords := page.parsed_page.keywords INTO fields;
      IF (page.parsed_page.description != "")
        INSERT CELL description := page.parsed_page.description INTO fields;
      IF (page.parsed_page.type_ext != "")
        INSERT CELL filetype := page.parsed_page.type_ext INTO fields;

      // Modification date/time
      DATETIME lastmodified;
      RECORD lastmodheader := SELECT * FROM page.fetched_page.headers WHERE ToUppercase(field) = "LAST-MODIFIED";
      IF (RecordExists(lastmodheader)) // This might be static content, see if we have a timestamp
        lastmodified := MakeDateFromText(lastmodheader.value);
      IF (NOT page.fetched_page.nocache OR page.parsed_page.isdynamic) // Don't remember modification date for dynamic pages, forces Fetcher to refetch them
        INSERT CELL date_modified := lastmodified != DEFAULT DATETIME ? lastmodified : commanddate INTO fields;

      // Extra fields
      FOREVERY(RECORD fld FROM page.parsed_page.extrafields)
      {
        IF(NOT CellExists(fields, fld.name))
          fields := CellInsert(fields, fld.name, fld.value);
      }

      // Use parsed text as document body
      body := page.parsed_page.text;
    }

    // Add this object to the list of fetched objects
    INSERT objectid INTO this->objects AT END;

    IF (NOT page.parsed_page.follow_links)
      page.parsed_page.links := DEFAULT RECORD ARRAY;

    RETURN [ document_fields := fields
           , document_body := body
           , objects := this->FilterObjects(page.parsed_page.links, objectid, this->rooturl, this->rooturl || "*")
           , links := page.parsed_page.links
           ];
  }
>;

PUBLIC OBJECTTYPE External EXTEND TolliumScreenBase
<
  PUBLIC PROPERTY settings(GetSettings, SetSettings);

  RECORD FUNCTION GetSettings()
  {
    RETURN this->mysettings->value;
  }

  MACRO SetSettings(RECORD settings)
  {
    // Insert lastcontentscheck if it does not exist yet
    IF (NOT CellExists(settings, "lastcontentscheck"))
      INSERT CELL lastcontentscheck := "" INTO settings;

    // Convert saved DATETIME value
    DATETIME lastcontentscheck := StringToDateTime(settings.lastcontentscheck);
    this->lastcontentscheck->value := lastcontentscheck != DEFAULT DATETIME ? this->tolliumuser->FormatDateTime(lastcontentscheck, "minutes", TRUE, FALSE) : GetTid("consilio:contentproviders.external.never");

    this->mysettings->value := settings;
  }
>;
