<?wh
/** @topic consilio/api */
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";

CONSTANT STRING ARRAY validchangefreqs := ["always", "hourly", "daily", "weekly", "monthly", "yearly", "never"];
CONSTANT RECORD basecontext := [ forconsilio := FALSE
                               , forsitemap := FALSE
                               ];

RECORD set_typedetails;

/** Base object for pagelist providers
    @long Pagelist providers offer an optimized way to inform Consilio and Publisher about the subpages generated by a page
          without necessarily setting up the full dynamic page */
PUBLIC STATIC OBJECTTYPE PagelistProviderBase
<
  BOOLEAN isdynamic;

  /** @short Instantiate the pagelist provider
  */
  MACRO NEW()
  {
    this->isdynamic := set_typedetails.isdynamic;
  }

  PUBLIC RECORD ARRAY FUNCTION GetSitemapLinks(RECORD fileinfo)
  {
    RETURN [[ link := fileinfo.link
            , title := fileinfo.title
            , modificationdate := this->isdynamic ? DEFAULT DATETIME : fileinfo.modificationdate
            , priority := 0.0
            , changefreq := ""
            , consiliofields := DEFAULT RECORD
           ]];
  }

  /** Gather relevant links for the sitemap or consilio
      @param fileinfo File for which to generate links
      @cell(integer) fileinfo.id File id
      @cell(integer) fileinfo.type File type
      @cell(string) fileinfo.link Link to first file page
      @cell(string) fileinfo.subpageurl Base url for statically created follow up pages
      @cell(datetime) fileinfo.modificationdate Modification date (in whfs)
      @param context Context for this request
      @cell(boolean) context.forconsilio We're gathering information for consilio
      @cell(boolean) context.forsitemap We're gathering information for a sitemap
      @return List of links (including the first page if it should be in the sitemap)
      @cell(string) return.link Absolute link for sitemap
      @cell(string) return.title Title for this file (used for indexing by Consilio)
      @cell(record) return.consiliofields Additional fields (used for indexing by Consilio)
      @cell(datetime) return.modificationdate Last modification,  DEFAULT DATETIME if unknown
      @cell(money) return.priority Indexing priority, 0.0 .. 1.0 (set to 0 if unknown)
      @cell(string) return.changefreq Change frequency: always, hourly, daily, weekly, monthly, yearly, never. Leave empty if unknown */
  PUBLIC RECORD ARRAY FUNCTION GetPages(RECORD fileinfo, RECORD context)
  {
    //fallback to legacy handler
    RETURN this->GetSitemapLinks(fileinfo);
  }

  /** Gather relevant links for the sitemap or consilio for multiple files of the same type
      @param fileinfos Files for which to generate links @includecelldef #GetPages.fileinfo
      @param context Context for this request @includecelldef #GetPages.fileinfo
      @return List of links for the files @includecelldef #GetPages.return
      @cell(integer) return.fileid ID of the WHFS file
      @cell(integer) return.filetype Type of the WHFS file
  */
  PUBLIC RECORD ARRAY FUNCTION GetPagesForMultiple(RECORD ARRAY fileinfos, RECORD context)
  {
    RECORD ARRAY alllinks;
    FOREVERY(RECORD file FROM fileinfos)
      alllinks := alllinks CONCAT SELECT *
                                       , fileid := file.id
                                       , filetype := file.type
                                    FROM this->GetPages(file, context);
    RETURN alllinks;
  }
>;

PUBLIC STRING FUNCTION __GetSubpageBaseUrl(RECORD typeinfo, RECORD fileinfo)
{
  //We mostly replicate the GetFileSubpageURL algorithm here
  STRING usefilename := fileinfo.name;
  IF(TestFlagFromPublished(fileinfo.published, PublishedFlag_StripExtension))
    usefilename := GetBasenameFromPath(usefilename);

  IF(typeinfo.fstype.ispublishedassubdir)
  {
    //An indexlink goes to file.url, others to a file.name/subpage
    IF(fileinfo.isindex)
    {
       //we're supposed to check against GetWebserverDefaultPage(fileinfo.outputweb)... but setting the output extension to .shtml is deprecated anyway so try to get away with this..
      IF(ToLowercase(usefilename) = whconstant_webserver_indexbasename || ".html")
        usefilename := "^" || usefilename;
      RETURN ResolveToAbsoluteURL(fileinfo.objecturl, EncodeURL(usefilename) || "/");
    }
    ELSE
      RETURN fileinfo.objecturl;
  }
  ELSE
  {
    RETURN ResolveToAbsoluteURL(fileinfo.objecturl, "^" || EncodeURL(usefilename) || "/");
  }

}

RECORD ARRAY FUNCTION GenerateSitemapCandidates(RECORD basefolder, INTEGER ARRAY limitobjects)
{
  RECORD ARRAY allfiles := SELECT id, name, title, type, link, objecturl, published, modificationdate
                                , isindex := id = basefolder.indexdoc
                             FROM system.fs_objects
                            WHERE parent = basefolder.id
                                  AND isfolder = FALSE
                                  AND publish = TRUE
                                  AND (Length(limitobjects) > 0 ? id IN limitobjects : TRUE)
                                  AND type NOT IN [18,19]; //18 = external link, 19 = internal

  RECORD ARRAY subfolders := SELECT id, indexdoc
                               FROM system.fs_objects
                              WHERE parent = basefolder.id
                                    AND isfolder;

  FOREVERY(RECORD folder FROM subfolders)
    allfiles := allfiles CONCAT GenerateSitemapCandidates(folder, limitobjects);

  RETURN allfiles;
}

PUBLIC OBJECT FUNCTION __MakePagelistProvider(STRING objtype, RECORD typeinfo)
{
  RECORD save_typedetails := set_typedetails;
  TRY
  {
    set_typedetails := typeinfo;
    RETURN objtype != "" ? MakeObject(objtype) : NEW PagelistProviderBase;
  }
  FINALLY
  {
    set_typedetails := save_typedetails;
  }
}

RECORD ARRAY FUNCTION GatherPages(INTEGER startfolder, INTEGER ARRAY limitobjects, RECORD context)
{
  RECORD basefolder := SELECT id, indexdoc
                         FROM system.fs_objects
                        WHERE id = startfolder;
  IF(NOT RecordExists(basefolder))
    RETURN RECORD[];

  RECORD ARRAY pertype := SELECT type, files := GroupedValues(candidates)
                            FROM GenerateSitemapCandidates(basefolder, limitobjects) AS candidates
                        GROUP BY type;

  RECORD ARRAY finallinks;
  FOREVERY(RECORD typegroup FROM pertype)
  {
    OBJECT pagelistprovider;
    RECORD typeinfo := typegroup.type = 0 ? LookupContentTypeByName("http://www.webhare.net/xmlns/publisher/unknownfile")
                                          : LookupContentTypeById(typegroup.type);
    IF(NOT RecordExists(typeinfo) OR NOT RecordExists(typeinfo.filetype))
      CONTINUE;

    pagelistprovider := __MakePagelistProvider(typeinfo.filetype.pagelistprovider, [ isdynamic := RecordExists(typeinfo.filetype.dynamicexecution) ]);

    RECORD ARRAY files := SELECT *
                               , subpagebaseurl := __GetSubpageBaseUrl(typeinfo, files)
                               , DELETE published
                               , DELETE name
                               , DELETE objecturl
                               , DELETE isindex
                            FROM typegroup.files;

    finallinks := finallinks CONCAT pagelistprovider->GetPagesForMultiple(files, context);
  }

  RETURN finallinks;
}

/** @short Get the sitemap links for files in a folder, recursively
    @param startfolder Starting point
    @cell(integer array) options.limitobjects Limit sitemap links to the specified objects.
    @return List of links (including the first page if it should be in the sitemap)
    @cell(string) return.link Absolute link for sitemap
    @cell(datetime) return.modificationdate Last modification,  DEFAULT DATETIME if unknown
    @cell(money) return.priority Indexing priority, 0.0 .. 1.0 (set to 0 if unknown)
    @cell(string) return.changefreq Change frequency: always, hourly, daily, weekly, monthly, yearly, never. Leave empty if unknown
    @cell(integer) return.fileid ID of the WHFS file
    @cell(integer) return.filetype Type of the WHFS file
*/
PUBLIC RECORD ARRAY FUNCTION GenerateSitemapLinks(INTEGER startfolder, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ limitobjects := INTEGER[] ], options, [ optional := ["limitobjects"] ]); //none yet. but they will come

  INTEGER ARRAY limitobjects;
  IF(CellExists(options,'limitobjects'))
  {
    IF(Length(options.limitobjects) = 0)
      RETURN RECORD[];

    limitobjects := options.limitobjects;
  }

  RECORD ARRAY finallinks := GatherPages(startfolder, limitobjects, CELL[ ...basecontext, forsitemap := TRUE ]);

  //Sanitize
  finallinks := EnforceStructure([[ changefreq := ""
                                  , link := ""
                                  , priority := 0m
                                 ]], finallinks);

  finallinks := SELECT changefreq := changefreq IN validchangefreqs ? changefreq : ""
                     , link := Tokenize(link,'#')[0]
                     , modificationdate := DATETIME(modificationdate)
                     , priority := MONEY(priority < 0 OR priority > 1 ? 0m : priority)
                     , fileid
                     , filetype
                  FROM finallinks;

  finallinks := SELECT AS RECORD ARRAY Any(finallinks) FROM finallinks GROUP BY link;

  RETURN finallinks;
}

/** @short Get the consilio pages for a file
    @param fileid ID of the file we're querying
    @cell(integer array) options.limitobjects Limit sitemap links to the specified objects.
    @return List of pages
    @cell(string) return.link Absolute link for the page, may include a hash
    @cell(string) return.title Title for this file (used for indexing by Consilio)
    @cell(datetime) return.modificationdate Last modification,  DEFAULT DATETIME if unknown
    @cell(money) return.priority Indexing priority, 0.0 .. 1.0 (set to 0 if unknown)
    @cell(string) return.changefreq Change frequency: always, hourly, daily, weekly, monthly, yearly, never. Leave empty if unknown
    @cell(integer) return.fileid ID of the WHFS file
    @cell(integer) return.filetype Type of the WHFS file

    @return List of links for the files @includecelldef #PageListProviderBase::GetMultipleSitemapLinks.return */
PUBLIC RECORD ARRAY FUNCTION GetConsilioPagesForFile(INTEGER fileid, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[], options);

  RECORD ARRAY finallinks := GatherPages((SELECT AS INTEGER parent FROM system.fs_objects WHERE id = fileid), [fileid], CELL[ ...basecontext, forsitemap := TRUE ]);

  //Sanitize
  finallinks := EnforceStructure([[ changefreq := ""
                                  , link := ""
                                  , priority := 0m
                                  , consiliofields := DEFAULT RECORD
                                 ]], finallinks);

  finallinks := SELECT changefreq := changefreq IN validchangefreqs ? changefreq : ""
                     , link
                     , title
                     , modificationdate := DATETIME(modificationdate)
                     , priority := MONEY(priority < 0 OR priority > 1 ? 0m : priority)
                     , consiliofields
                  FROM finallinks;

  RETURN finallinks;
}
