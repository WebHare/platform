<?wh
/** @topic consilio/api */
LOADLIB "wh::files.whlib";
LOADLIB "wh::internet/urls.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/internal/siteprofiles/cache.whlib";

CONSTANT STRING ARRAY validchangefreqs := ["always", "hourly", "daily", "weekly", "monthly", "yearly", "never"];

/** Base object for pagelist providers
    @long Pagelist providers offer an optimized way to inform Consilio and Publisher about the subpages generated by a page
          without necessarily setting up the full dynamic page */
PUBLIC STATIC OBJECTTYPE PagelistProviderBase
<
  BOOLEAN isdynamic;

  /** @short Instantiate the pagelist provider
      @param filetypeinfo Describes the filetype for which we're invoked
      @cell(boolean) filetypeinfo.isdynamic True if this file type has <dynamicexecution>
  */
  MACRO NEW(RECORD filetypeinfo)
  {
    this->isdynamic := filetypeinfo.isdynamic;
  }

  /** Gather relevant links for the sitemap
      @param fileinfo File for which to generate links
      @cell(integer) fileinfo.id File id
      @cell(integer) fileinfo.type File type
      @cell(string) fileinfo.link Link to first file page
      @cell(string) fileinfo.subpageurl Base url for statically created follow up pages
      @cell(datetime) fileinfo.modificationdate Modification date (in whfs)
      @return List of links (including the first page if it should be in the sitemap)
      @cell(string) return.link Absolute link for sitemap
      @cell(string) return.title Title for this file (used for indexing by Consilio)
      @cell(record) return.consiliofields Additional fields (used for indexing by Consilio)
      @cell(datetime) return.modificationdate Last modification,  DEFAULT DATETIME if unknown
      @cell(money) return.priority Indexing priority, 0.0 .. 1.0 (set to 0 if unknown)
      @cell(string) return.changefreq Change frequency: always, hourly, daily, weekly, monthly, yearly, never. Leave empty if unknown */
  PUBLIC RECORD ARRAY FUNCTION GetSitemapLinks(RECORD fileinfo)
  {
    RETURN [[ link := fileinfo.link
            , title := fileinfo.title
            , modificationdate := this->isdynamic ? DEFAULT DATETIME : fileinfo.modificationdate
            , priority := 0.0
            , changefreq := ""
            , consiliofields := DEFAULT RECORD
           ]];
  }

  /** Gather relevant links for the sitemap
      @param fileinfos Files for which to generate links @includecelldef #GetSitemapLinks.fileinfo
      @return List of links for the files @includecelldef #GetSitemapLinks.return
      @cell(integer) return.fileid ID of the WHFS file
      @cell(integer) return.filetype Type of the WHFS file
  */
  PUBLIC RECORD ARRAY FUNCTION GetMultipleSitemapLinks(RECORD ARRAY fileinfos)
  {
    RECORD ARRAY alllinks;
    FOREVERY(RECORD file FROM fileinfos)
      alllinks := alllinks CONCAT SELECT *
                                       , fileid := file.id
                                       , filetype := file.type
                                    FROM this->GetSitemapLinks(file);
    RETURN alllinks;
  }
>;

PUBLIC STRING FUNCTION __GetSubpageBaseUrl(RECORD typeinfo, RECORD fileinfo)
{
  //We mostly replicate the GetFileSubpageURL algorithm here
  STRING usefilename := fileinfo.name;
  IF(TestFlagFromPublished(fileinfo.published, PublishedFlag_StripExtension))
    usefilename := GetBasenameFromPath(usefilename);

  IF(typeinfo.fstype.ispublishedassubdir)
  {
    //An indexlink goes to file.url, others to a file.name/subpage
    IF(fileinfo.isindex)
    {
       //we're supposed to check against GetWebserverDefaultPage(fileinfo.outputweb)... but setting the output extension to .shtml is deprecated anyway so try to get away with this..
      IF(ToLowercase(usefilename) = whconstant_webserver_indexbasename || ".html")
        usefilename := "^" || usefilename;
      RETURN ResolveToAbsoluteURL(fileinfo.objecturl, EncodeURL(usefilename) || "/");
    }
    ELSE
      RETURN fileinfo.objecturl;
  }
  ELSE
  {
    RETURN ResolveToAbsoluteURL(fileinfo.objecturl, "^" || EncodeURL(usefilename) || "/");
  }

}

RECORD ARRAY FUNCTION GenerateSitemapCandidates(RECORD basefolder, INTEGER ARRAY limitobjects)
{
  RECORD ARRAY allfiles := SELECT id, name, title, type, link, objecturl, published, modificationdate
                                , isindex := id = basefolder.indexdoc
                             FROM system.fs_objects
                            WHERE parent = basefolder.id
                                  AND isfolder = FALSE
                                  AND publish = TRUE
                                  AND (Length(limitobjects) > 0 ? id IN limitobjects : TRUE)
                                  AND type NOT IN [18,19]; //18 = external link, 19 = internal

  RECORD ARRAY subfolders := SELECT id, indexdoc
                               FROM system.fs_objects
                              WHERE parent = basefolder.id
                                    AND isfolder;

  FOREVERY(RECORD folder FROM subfolders)
    allfiles := allfiles CONCAT GenerateSitemapCandidates(folder, limitobjects);

  RETURN allfiles;
}

/** @short Get the sitemap links for files in a folder, recursively
    @param startfolder Starting point
    @cell(integer array) options.limitobjects Limit sitemap links to the specified objects.
    @return List of links for the files @includecelldef #PageListProviderBase::GetMultipleSitemapLinks.return */
PUBLIC RECORD ARRAY FUNCTION GenerateSitemapLinks(INTEGER startfolder, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(CELL[ limitobjects := INTEGER[] ], options, [ optional := ["limitobjects"] ]); //none yet. but they will come

  INTEGER ARRAY limitobjects;
  IF(CellExists(options,'limitobjects'))
  {
    IF(Length(options.limitobjects) = 0)
      RETURN RECORD[];

    limitobjects := options.limitobjects;
  }

  RECORD basefolder := SELECT id, indexdoc
                         FROM system.fs_objects
                        WHERE id = startfolder;
  IF(NOT RecordExists(basefolder))
    RETURN RECORD[];

  RECORD ARRAY pertype := SELECT type, files := GroupedValues(candidates)
                            FROM GenerateSitemapCandidates(basefolder, limitobjects) AS candidates
                        GROUP BY type;

  RECORD ARRAY finallinks;
  FOREVERY(RECORD typegroup FROM pertype)
  {
    OBJECT pagelistprovider;
    RECORD typeinfo := typegroup.type = 0 ? LookupContentTypeByName("http://www.webhare.net/xmlns/publisher/unknownfile")
                                          : LookupContentTypeById(typegroup.type);
    IF(NOT RecordExists(typeinfo) OR NOT RecordExists(typeinfo.filetype))
      CONTINUE;

    RECORD typedetails := [ isdynamic := RecordExists(typeinfo.filetype.dynamicexecution) ];
    pagelistprovider := typeinfo.filetype.pagelistprovider != "" ? MakeObject(typeinfo.filetype.pagelistprovider, typedetails)
                                                                 : NEW PagelistProviderBase(typedetails);

    RECORD ARRAY files := SELECT *
                               , subpagebaseurl := __GetSubpageBaseUrl(typeinfo, files)
                               , DELETE published
                               , DELETE name
                               , DELETE objecturl
                               , DELETE isindex
                            FROM typegroup.files;

    finallinks := finallinks CONCAT pagelistprovider->GetMultipleSitemapLinks(files);
  }

  //Sanitize
  finallinks := SELECT changefreq := changefreq IN validchangefreqs ? changefreq : ""
                     , link := STRING(link)
                     , title
                     , modificationdate := DATETIME(modificationdate)
                     , priority := MONEY(priority < 0 OR priority > 1 ? 0m : priority)
                     , fileid
                     , filetype
                     , consiliofields := CellExists(finallinks, 'consiliofields') ? finallinks.consiliofields : DEFAULT RECORD
                  FROM finallinks;

  RETURN finallinks;
}
