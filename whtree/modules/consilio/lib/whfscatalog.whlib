<?wh
/** @topic consilio/api
*/

// This is an API to the consilio:whfs catalog.

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";

LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


OBJECT publisher_fsobjects_source;

INTEGER ARRAY FUNCTION GetIndexedWHFSObjectsForFolder(INTEGER folderid)
{
  RECORD query := CQMatch("whfstree", "=", ToString(folderid));
  RETURN SELECT AS INTEGER ARRAY DISTINCT whfsid
           FROM RunConsilioSearch(whconstant_consilio_catalog_whfs, query, [ count := -1, mapping := [ whfsid := 0 ] ]).results;
}

//Foregound WHFS (re)index. Exposing this because frontend apps need a way to ensure their just commited change is indexed as fast as possible, and visible to them

/** @short Reindex one or more WHFS changes
    @param to_reindex List of objects to reindex
    @cell(integer) to_reindex.id WHFS object id
    @cell(boolean) to_reindex.isfolder Set this flag to indicate the object is a folder
    @cell(boolean) to_reindex.isdelete Set this flag to indicate the object is deleted or recycled
    @cell(boolean) options.refresh Refresh the indices after updating (defaults to TRUE)
*/
PUBLIC MACRO ReindexWHFSChanges(RECORD ARRAY to_reindex, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  RECORD ARRAY results;
  options := ValidateOptions([ __eventid := "", __debug := FALSE, __progress := FALSE, refresh := TRUE ], options);

  IF(NOT ObjectExists(publisher_fsobjects_source))
  {
    OBJECT catalog := OpenConsilioCatalog(whconstant_consilio_catalog_whfs);
    IF(NOT ObjectExists(catalog))
      THROW NEW Exception(`Publisher index '${whconstant_consilio_catalog_whfs}' not available`);

    publisher_fsobjects_source := catalog->OpenContentSource("consilio:whfsobjects");
    IF(NOT ObjectExists(publisher_fsobjects_source))
      THROW NEW Exception(`Content source 'consilio:whfsobjects' not available`);
  }

  INTEGER ARRAY to_update, to_delete;
  FOREVERY (RECORD obj FROM to_reindex)
  {
    IF (obj.isfolder)
    {
      // This will re-index the folder object contents recursively
      FOREVERY (INTEGER subobjid FROM GetIndexedWHFSObjectsForFolder(obj.id))
      {
        IF (subobjid = 0)
          CONTINUE;
        // Reindexing an inactive group will delete it from content sources no longer responsible for it
        IF (obj.isdelete)
          INSERT subobjid INTO to_delete AT END;
        ELSE
          INSERT subobjid INTO to_update AT END;
      }
    }

    // This will re-index the folder or file object itself
    IF (obj.isdelete)
      INSERT obj.id INTO to_delete AT END;
    ELSE
      INSERT obj.id INTO to_update AT END;
  }

  to_update := GetSortedSet(to_update);
  to_delete := GetSortedSet(to_delete);

  IF (options.__debug)
    Print(`To update: ${EncodeJSON(to_update)}\nTo delete: ${EncodeJSON(to_delete)}\n`);

  DATETIME now := GetCurrentDateTime();
  FOREVERY (INTEGER objid FROM to_delete)
  {
    publisher_fsobjects_source->DeleteGroup("fsobj_" || objid, [ foreground := TRUE ]);
    IF(options.__progress)
      Print(`Deleting ${#objid+1}/${Length(to_delete)}: #${objid}\r`);
  }
  IF(options.__progress AND Length(to_delete) > 0)
    Print(`\n`);

  FOREVERY (INTEGER objid FROM to_update)
  {
    publisher_fsobjects_source->ReindexGroup("fsobj_" || objid, [ foreground := TRUE ]);
    IF(options.__progress)
      Print(`Updating ${#objid+1}/${Length(to_update)}: #${objid}\r`);
  }

  // Sort the results: first the requested ids in the order they're supplied, then other ids sorted ascending
  INTEGER ARRAY orgids := SELECT AS INTEGER ARRAY id FROM to_reindex;
  results := SELECT * FROM results ORDER BY SearchElement(orgids, objid) + 1 ?? objid;

  IF(options.__progress AND Length(to_update) > 0)
    Print(`\n`);

  // If anything was deleted or updated, refresh the index to make sure the results are available
  IF (options.refresh AND Length(to_delete) + Length(to_update) > 0)
  {
    IF (options.__progress)
      Print("Refreshing index...");
    publisher_fsobjects_source->catalog->Refresh();
    IF (options.__progress)
      Print("\n");
  }

  IF(options.__eventid != "")
    BroadcastEvent(`system:whfs.index.response.${options.__eventid}`, [ deleted := to_delete, updated := to_update ]);
}

