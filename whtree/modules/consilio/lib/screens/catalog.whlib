<?wh

LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";
LOADLIB "wh::dbase/dynquery.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::util/langspecific.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/search.whlib";
LOADLIB "mod::consilio/lib/internal/contentsources.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/queuemgmt.whlib";
LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::consilio/lib/internal/stats.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch/analysis.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";


// Maximum number of characters to display on one line in search result field values
INTEGER maxfieldlength := 80;

// Maximum number of results to show initially
INTEGER searchlimit := 100;

// Fields that are not indexed, but do get returned with search results
STRING ARRAY resultfieldnames := [ "id", "_score", "_summary" ];

CONSTANT RECORD baserow := [ catalog := FALSE
                           , standardcatalog := FALSE
                           , isupdateorrebuild := FALSE
                           , lang := ""
                           ];

STRING FUNCTION GetStatusIcon(INTEGER status)
{
  SWITCH (status)
  {
    CASE -1 // Catalog is temporarily disabled
    {
      RETURN "tollium:status/negative";
    }
    CASE 0 // Catalog is idle
    {
      RETURN "tollium:status/checked";
    }
    CASE 1 // Catalog is being updated
    {
      RETURN "tollium:status/neutral";
    }
    CASE 2 // Catalog is being rebuilt
    {
      RETURN "tollium:tools/tools";
    }
    CASE 3 // Catalog is unavailable
    {
      RETURN "tollium:status/neutral";
    }
    CASE 4 // Error
    {
      RETURN "tollium:status/error";
    }
    DEFAULT
    {
      RETURN "";
    }
  }
}
STRING FUNCTION GetStatusHint(INTEGER status)
{
  SWITCH (status)
  {
    CASE -1 // Catalog is temporarily disabled
    {
      RETURN GetTid("consilio:catalogstatus.disabled");
    }
    CASE 0 // Catalog is idle
    {
      RETURN GetTid("consilio:catalogstatus.idle");
    }
    CASE 1 // Catalog is being checked
    {
      RETURN GetTid("consilio:catalogstatus.beingupdated");
    }
    CASE 2 // Catalog should be checked
    {
      RETURN GetTid("consilio:catalogstatus.beingrebuilt");
    }
    CASE 3 // Catalog is unavailable
    {
      RETURN GetTid("consilio:catalogstatus.unavailable");
    }
    CASE 4 // Error
    {
      RETURN GetTid("consilio:catalogstatus.error");
    }
    DEFAULT
    {
      RETURN "";
    }
  }
}

RECORD FUNCTION GetErrorIconAndHint(BOOLEAN have_error)
{
  RETURN have_error
      ? [ icon := "tollium:status/error"
        , hint := GetTid("consilio:catalogerrors.errors")
        , haserrors := TRUE
        ]
      : [ icon := ""//tollium:status/checked"
        , hint := GetTid("consilio:catalogerrors.none")
        , haserrors := FALSE
        ];
}

PUBLIC RECORD FUNCTION GetConsilioStatus()
{
  OpenPrimary();

  RECORD status := [ indexsizes := GatherIndexManagersSizes()
                   , lasterrors := RECORD[]
                   ];

  RECORD r := __ConsilioGetErrors();
  IF(RecordExists(r))
    status.lasterrors := r.errors;

  RETURN status;
}


PUBLIC STATIC OBJECTTYPE Catalogs EXTEND TolliumScreenBase
<
  RECORD ARRAY contentproviders;
  RECORD laststatus;

  MACRO Init(RECORD data)
  {
    this->contentproviders := SELECT *
                                   , title := GetTid(title)
                                FROM GetContentProviders();

    this->RefreshActionVisibility();
    this->PollConsilioStatus();

    IF (CellExists(data, "calltype") AND data.calltype = "direct")
    {
      IF (CellExists(data.message, "catalog"))
        ^catalogs->value := [ "catalog_" || data.message.catalog ];
      ELSE IF (CellExists(data.message, "source"))
        ^catalogs->value := [ "source_" || data.message.source.id ];

      IF (CellExists(data.message, "action"))
      {
        SWITCH (data.message.action)
        {
          CASE "options"
          {
            this->DoOptions();
          }
          CASE "blacklist"
          {
            this->DoBlacklist();
          }
          CASE "properties"
          {
            IF (LENGTH(^catalogs->selection) = 1)
            {
              IF (^catalogs->selection[0].catalog)
                this->DoEditCatalog();
              ELSE IF (^catalogs->selection[0].contentsource)
                this->DoEditContentSource();
            }
          }
          CASE "errors"
          {
            IF (LENGTH(^catalogs->selection) = 1
                AND ^catalogs->selection[0].contentsource)
              this->DoShowErrors();
          }
          CASE "rebuild"
          {
            this->DoRebuildCatalog(); // Will rebuild content source if selected
          }
        }
      }
      ^buttons->visible := FALSE; // Hide default form buttons when called directly
    }
    ELSE
    {
      ^exit->enabled := FALSE; // Hide 'Exit' menu item when called from within another app
    }
  }

  MACRO DoRefresh()
  {
    ^catalogs->Invalidate();
  }

  MACRO DoOptions()
  {
    this->LoadScreen(".options")->RunModal();
  }

  MACRO DoBlacklist()
  {
    this->LoadScreen(".blacklist")->RunModal();
  }

  MACRO DoAddContentSource()
  {
    INTEGER newcontentsource := this->RunScreen("#contentsourceeditor" , [ catalog := ^catalogs->selection.id ]);
    IF(newcontentsource != 0)
      ^catalogs->selection := SELECT * FROM ^catalogs->rows WHERE contentsource = TRUE AND id = newcontentsource;
  }

  MACRO DoEditContentSource()
  {
    this->RunScreen("#contentsourceeditor", [ catalog := ^catalogs->selection.catalogid, contentsource := ^catalogs->selection.id ]);
  }

  MACRO DoEditCatalog()
  {
    IF (RecordExists(^catalogs->selection) AND ^catalogs->selection.catalog)
    {
      INTEGER oldlevel := ^catalogs->selection.loglevel;
      this->RunScreen("#catalogeditor", ^catalogs->selection);
    }
  }

  MACRO DoShowFieldMapping()
  {
    this->RunScreen("#fieldmapping", [ catalog := ^catalogs->selection.id ]);
  }

  MACRO DoDelete()
  {
    RECORD ARRAY killcatalogs := SELECT * FROM ^catalogs->selection WHERE catalog;
    RECORD ARRAY killsources := SELECT * FROM ^catalogs->selection WHERE contentsource;

    IF(Length(killcatalogs) = 0 AND Length(killsources) = 1)
    {
      IF(this->RunSimpleScreen("verify", GetTid("consilio:catalog.messages.confirmdeletecontentsource", killsources[0].title ?? killsources[0].tag)) != "yes")
        RETURN;
    }
    ELSE IF(Length(killcatalogs) = 1 AND Length(killsources) = 0)
    {
      IF(this->RunSimpleScreen("verify", GetTid("consilio:catalog.messages.confirmdeletecatalog", killcatalogs[0].title ?? killcatalogs[0].tag)) != "yes")
        RETURN;
    }
    ELSE
    {
      IF(this->RunSimpleScreen("verify", GetTid("consilio:catalog.messages.confirmdeleteselection")) != "yes")
        RETURN;
    }

    OBJECT work := this->BeginWork();
    FOREVERY (RECORD catalog FROM killcatalogs)
      OpenConsilioCatalogById(catalog.id)->DeleteSelf();
    //remove cascades from our deletion list
    DELETE FROM killsources WHERE parent IN (SELECT AS INTEGER ARRAY id FROM killcatalogs);
    FOREVERY (RECORD catalog FROM SELECT id := parent, sources := GroupedValues(killsources) FROM killsources GROUP BY parent)
    {
      OBJECT obj := OpenConsilioCatalogById(catalog.id);
      FOREVERY (RECORD source FROM catalog.sources)
        obj->OpenContentSourceById(source.id)->DeleteSelf();
    }
    GetPrimary()->BroadcastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    work->Finish();
  }

  MACRO DoPreviewCatalog()
  {
    IF (RecordExists(^catalogs->selection) AND ^catalogs->selection.previewable)
    {
      OBJECT dlg := this->LoadScreen(".catalogpreview", ^catalogs->selection);
      dlg->RunModal();
    }
  }

  MACRO DoMarkCatalogAsComplete()
  {
    GetPrimary()->BeginWork();
    UPDATE consilio.contentsources SET status := 0 WHERE id = ^catalogs->selection.id;
    GetPrimary()->CommitWork();
    ^catalogs->Invalidate();
    //TODO remove from queue, but for now you'll just have to restart the queue
  }

  MACRO DoRebuildCatalog()
  {
    IF (this->RunSimpleScreen("confirm", this->GetTid(".confirmrebuildcatalog", ^catalogs->selection.title ?? ^catalogs->selection.tag)) != "yes")
      RETURN;

    OBJECT catalog := OpenConsilioCatalogById(^catalogs->selection.catalogid);
    IF (^catalogs->selection.contentsource)
      catalog->OpenContentSourceById(^catalogs->selection.id)->ReindexContentSource();
    ELSE FOREVERY(RECORD csource FROM catalog->ListContentSources())
      catalog->OpenContentSourceById(csource.id)->ReindexContentSource();
  }

  MACRO DoCatalogThesaurus()
  {
    IF (RecordExists(^catalogs->selection))
    {
      this->LoadScreen(".thesaurus", [ indexid := ^catalogs->selection.id ])->RunModal();
    }
  }

  MACRO DoShowErrors()
  {
    RECORD ARRAY lasterrors := __ConsilioGetErrors().errors;

    INTEGER contentsourceid := ^catalogs->selection.contentsourceid;

    OBJECT screen := this->LoadScreen(".contentsourceerrors",
        [ contentsourceid :=    contentsourceid
        , errors :=
             (SELECT *
                FROM lasterrors
               WHERE COLUMN contentsourceid = VAR contentsourceid)
        ]);

    screen->RunModal();
    ^catalogs->Invalidate();
  }

  MACRO DoExit()
  {
    this->tolliumresult := "close";
  }

  MACRO RefreshActionVisibility()
  {
    this->frame->flags.issysop := this->tolliumuser->HasRight("system:sysop");
    this->frame->flags.ismanager := this->tolliumuser->HasRightOnAny("consilio:manage");
    this->frame->flags.iseditor := this->tolliumuser->HasRightOnAny("consilio:metadata");

    // Adding, editing, deleting, rebuilding catalogs and content sources
    ^addcontentsource_menu->visible := this->frame->flags.ismanager;
    ^edititem_menu->visible := this->frame->flags.ismanager;
    ^deleteitem_menu->visible := this->frame->flags.ismanager;
    ^rebuildcatalog_menu->visible := this->frame->flags.ismanager;
    ^showerrors_menu->visible := this->frame->flags.ismanager;

    ^edititem_contextmenu->visible := this->frame->flags.ismanager;
    ^rebuildcatalog_contextmenu->visible := this->frame->flags.ismanager;
    ^showerrors_contextmenu->visible := this->frame->flags.ismanager;

    ^addmenu_button->visible := this->frame->flags.ismanager;
    ^edititem_button->visible := this->frame->flags.ismanager;
    ^deleteitem_button->visible := this->frame->flags.ismanager;
    ^checkcatalog_button->visible := this->frame->flags.ismanager;

    // Editing catalog properties
    ^catalogthesaurus_menu->visible := this->frame->flags.iseditor;
    ^catalogthesaurus_contextmenu->visible := this->frame->flags.iseditor;
  }

  ASYNC MACRO PollConsilioStatus()
  {
    this->laststatus := AWAIT AsyncCallFunctionFromJob(Resolve("#GetConsilioStatus"));
    ^catalogs->Invalidate();
    RegisterTimedCallback(AddTimeToDate(5000, GetCurrentDateTime()), PTR this->PollConsilioStatus);
  }

  RECORD ARRAY FUNCTION OnGetCatalogs()
  {
    // Use a work to prevent flushes in the database after each select
    OBJECT work := this->BeginUnvalidatedWork();

    RECORD ARRAY sources := SELECT contentsources.*
                                 , iconname := ""
                                 , module := ""
                                 , failed := TRUE
                                 , catalogtag := catalogs.name
                              FROM consilio.contentsources, consilio.catalogs
                             WHERE contentsources.catalogid = catalogs.id
                                   AND contentsources.tag NOT LIKE "$consilio$deleted$*";

    RECORD ARRAY fsobjects := SELECT id, whfspath
                                FROM system.fs_objects
                               WHERE id IN (SELECT AS INTEGER ARRAY fsobject FROM sources WHERE fsobject != 0);

    RECORD ARRAY rows;
    RECORD ARRAY lasterrors;
    IF(RecordExists(this->laststatus))
      lasterrors := this->laststatus.lasterrors;

    BOOLEAN access_all := this->tolliumuser->HasRightOn("consilio:read", 0);
    RECORD ARRAY accessible_indices := SELECT *
                                         FROM ListConsilioCatalogs()
                                        WHERE access_all OR this->tolliumuser->HasRightOn("consilio:read", id)
                                     ORDER BY ToUppercase(tag), id;

    accessible_indices := EnrichCatalogsWithStats(accessible_indices, RecordExists(this->laststatus) ? this->laststatus.indexsizes : RECORD[]);

    FOREVERY (RECORD catalog FROM accessible_indices)
    {
      RECORD ARRAY catalogsources := SELECT *
                                          , rowkey := "source_" || id
                                          , icon := catalog.id < 0 ? ^catalogs->GetIcon("consilio:consilio") : iconname != "" ? ^catalogs->GetIcon(iconname) : 0
                                          , tag := (contentprovider = VAR whconstant_consilio_contentprovider_site ? (SELECT AS STRING whfspath FROM fsobjects WHERE fsobjects.id = sources.fsobject) : tag) ?? title
                                          , title
                                          , size := -1
                                          , statushint := GetStatusHint(status)
                                          , expanded := FALSE
                                          , catalog := FALSE
                                          , parent := catalogid
                                          , contentsource := TRUE
                                          , hascontents := FALSE
                                          , isupdateorrebuild := status = contentsourcestatus_rebuilding
                                          , level := 1
                                          , srcinactive := status < 0
                                          , errorrec := GetErrorIconAndHint(RecordExists(SELECT FROM lasterrors WHERE contentsourceid = sources.id))
                                          , error := 0
                                          , errorhint := ""
                                          , haserrors := FALSE
                                          , catalogid
                                          , contentsourceid := id
                                          , definedby := definedby
                                       FROM sources
                                      WHERE catalogid = catalog.id
                                      ORDER BY (status < 0), failed // Show active sources first, then failed sources
                                             , ToUppercase(title)
                                             , id;
      UPDATE catalogsources
         SET status := ^catalogs->GetIcon(GetStatusIcon(status))
           , error := ^catalogs->GetIcon(errorrec.icon)
           , errorhint := errorrec.hint
           , haserrors := errorrec.haserrors;

      BOOLEAN inactive := catalog.managed AND Length(SELECT FROM catalogsources WHERE NOT srcinactive)=0;

       INSERT
         CELL[...baserow
             , id := catalog.id
             , catalogid := catalog.id
             , rowkey := "catalog_" || catalog.id
             , title := catalog.description
             , catalog.tag
             , catalog.lang
             , size := catalog.docs
             , status := 0
             , previewable := catalog.id > 0 AND NOT inactive
             , editable := catalog.id > 0 AND NOT inactive AND this->tolliumuser->HasRightOn("consilio:metadata", catalog.id)
             , manageable := this->tolliumuser->HasRightOn("consilio:manage", catalog.id)
             , inactive := inactive
             , readonly := catalog.id < 0
             , style := catalog.id < 0 ? "readonly" : inactive ? "inactive" : ""
             , statushint := ""
             , error := 0
             , errorhint := ""
             , haserrors := FALSE
             , expanded := NOT inactive //FIXME: Not working?
             , catalog := TRUE
             , standardcatalog := catalog.managed
             , parent := 0
             , contentsource := FALSE
             , hascontents := Length(catalogsources) > 0
             , subnodes := this->tolliumuser->HasRightOn("consilio:manage", catalog.id)
                 ? (SELECT AS RECORD ARRAY
                     CELL[ ...baserow
                         , ...src
                         , previewable := catalog.id < 0 AND NOT VAR inactive
                         , editable := TRUE
                         , manageable := TRUE
                         , inactive := inactive OR srcinactive
                         , readonly := catalog.id < 0
                         , style := catalog.id < 0 ? "readonly" : (inactive OR srcinactive OR orphansince != DEFAULT DATETIME) ? "inactive" : ""
                         ] FROM catalogsources AS src)
                 : RECORD[]
             , contentsourceid := 0
             , definedby := catalog.definedby
             ] INTO rows AT END;
    }
    work->Cancel();

    RETURN rows;
  }
>;

PUBLIC OBJECTTYPE Options EXTEND TolliumScreenBase
<
  MACRO Init()
  {
    this->queuemanager->ReadFromRegistry();
    this->enablelinkchecker->value := ReadRegistryKey("consilio.linkchecker.enabled");
  }

  BOOLEAN FUNCTION Submit()
  {
    STRING command;
    OBJECT work := this->BeginWork();
    IF (work->HasFailed())
      RETURN work->Cancel();

    this->queuemanager->WriteToRegistry();
    WriteRegistryKey("consilio.linkchecker.enabled", this->enablelinkchecker->value);

    BOOLEAN finished := work->Finish();

    RETURN finished;
  }
>;

PUBLIC STATIC OBJECTTYPE Blacklist EXTEND TolliumScreenBase <
  MACRO EditPattern(RECORD row) {
    this->RunScreen("#blacklistpattern", row);
  }
  MACRO DeletePattern(RECORD row) {
    IF (this->RunSimpleScreen("confirm", GetTid("consilio:catalog.messages.confirmpatterndelete", ^blacklist->selection.pattern)) != "yes")
      RETURN;

    OBJECT work := this->BeginWork();
    DELETE FROM consilio.blacklist WHERE id = ^blacklist->value;
    GetPrimary()->BroadcastOnCommit("consilio:blacklistchanged", DEFAULT RECORD);
    work->Finish();
  }

  RECORD ARRAY FUNCTION GetBlacklistRows() {
    RETURN SELECT *
                , rowkey := id
                , noindex_icon := noindex ? 1 : 0
                , nolinkcheck_to_icon := nolinkcheck_to ? 1 : 0
              FROM consilio.blacklist;
  }
>;

PUBLIC STATIC OBJECTTYPE BlacklistPattern EXTEND TolliumScreenBase <
  INTEGER patternid;

  MACRO Init(RECORD data) {
    IF (RecordExists(data)) {
      this->frame->title := GetTid("consilio:catalog.blacklistpattern.title-edit");
      this->patternid := data.id;
      ^pattern->value := data.pattern;

      STRING ARRAY options;
      IF (data.noindex)
        INSERT "noindex" INTO options AT END;
      IF (data.nolinkcheck_to)
        INSERT "nolinkcheck_to" INTO options AT END;
      ^options->value := options;
    } ELSE {
      this->frame->title := GetTid("consilio:catalog.blacklistpattern.title-new");
    }
  }

  INTEGER FUNCTION Submit() {
    OBJECT work := this->BeginWork();
    IF (RecordExists(SELECT FROM consilio.blacklist WHERE pattern = ^pattern->value AND id != this->patternid))
      work->AddErrorFor(^pattern, this->GetTid(".duplicate-pattern"));

    INTEGER updatedid := this->patternid;

    IF (NOT work->HasFailed()) {
      IF (this->patternid != 0) {
        // Editing
        UPDATE consilio.blacklist
           SET pattern := ^pattern->value
             , noindex := "noindex" IN ^options->value
             , nolinkcheck_to := "nolinkcheck_to" IN ^options->value
         WHERE id = this->patternid;
      } ELSE {
        // Adding
        updatedid := MakeAutonumber(consilio.blacklist, "id");
        INSERT INTO consilio.blacklist(id, pattern, noindex, nolinkcheck_to)
               VALUES(updatedid, ^pattern->value, "noindex" IN ^options->value, "nolinkcheck_to" IN ^options->value);
      }
    }
    GetPrimary()->BroadcastOnCommit("consilio:blacklistchanged", DEFAULT RECORD);
    RETURN work->Finish() ? updatedid : 0;
  }
>;

PUBLIC OBJECTTYPE CatalogEditor EXTEND TolliumScreenBase
<
  OBJECT catalog;
  INTEGER catalogid;
  RECORD ARRAY catalogsizes;
  STRING ARRAY org_indexmanagers;

  MACRO Init(RECORD data)
  {
    IF (RecordExists(data))
    {
      this->catalogid := data.id;
      this->catalog := OpenConsilioCatalogById(this->catalogid);
      RECORD catalog := SELECT * FROM consilio.catalogs WHERE id = this->catalogid;
      this->id->value := ToString(this->catalogid);
      ^name->value := catalog.name;
      this->description->value := catalog.description;
      this->debuglevel->value := catalog.loglevel;
      this->frame->title := GetTid("consilio:catalog.catalogeditor.title-edit", catalog.name);
      this->priority->value := catalog.priority;
      ^type->value := catalog.type;
      ^fieldgroups->value := catalog.fieldgroups;
    }
    ELSE
    {
      this->id->visible := FALSE;
      this->debuglevel->visible := FALSE;
      this->frame->title := GetTid("consilio:catalog.catalogeditor.title-new");
      ^fieldgroups->visible := FALSE;
    }
    ^attachedindices->AddAction(this->GetTid(".refreshsizes"), PTR this->DoRefreshSizes, [ requireselection := FALSE ]);
    this->GotInterval();
  }

  RECORD ARRAY FUNCTION GetAttachedIndices()
  {
    RECORD ARRAY indexmanagers := ListIndexManagers();
    RECORD ARRAY rows :=
        SELECT rowkey := id
             , indexmanager_name := (SELECT AS STRING name FROM indexmanagers WHERE indexmanagers.id = attached.indexmanager)
             , indexname
             , primary := searchpriority > 0
             , sizekey := `${id}:${indexname}`
          FROM this->catalog->ListAttachedIndices() AS attached;

    RETURN JoinArrays(rows, "sizekey", this->catalogsizes, [ size := -1 ], [ rightouterjoin := TRUE ]);
  }

  ASYNC MACRO GotInterval()
  {
    AWAIT CreateSleepPromise(1);
    this->RefreshCatalogSizes();
  }

  MACRO RefreshCatalogSizes()
  {
    IF (this->catalogid != 0)
    {
      RECORD ARRAY catalogsizes;
      FOREVERY (RECORD row FROM ^attachedindices->rows)
      {
        INSERT CELL
            [ row.sizekey
            , size :=         GetIndexManagerSize(this->catalogid, CELL[ indexmanager := row.rowkey, row.indexname ])
            ] INTO catalogsizes AT END;
      }
      this->catalogsizes := catalogsizes;
    }
    ^attachedindices->Invalidate();
  }

  MACRO GotIndexManagerRowEdit(RECORD data)
  {
    INTEGER sel := this->RunScreen("#editcatalogindex", CELL[ this->catalog, id := RecordExists(data) ? data.rowkey : 0 ]);
    IF(sel != 0)
    {
      ^attachedindices->Invalidate();
      ^attachedindices->value := sel;
    }
  }

  MACRO GotIndexManagerRowDelete(RECORD data)
  {
    IF(this->RunSimpleScreen("confirm", this->GetTid(".confirmdeleteindex")) != "yes")
      RETURN;

    OBJECT work := this->BeginUnvalidatedWork();
    this->catalog->DetachIndex(data.rowkey);
    work->Finish();
    ^attachedindices->Invalidate();
  }

  RECORD ARRAY FUNCTION MapIndexManagerRows(RECORD ARRAY rows)
  {
    rows := SELECT *, DELETE indexmanager_name, DELETE indexmanager_type FROM rows;
    rows := JoinArrays(rows, "indexmanager", this->catalogsizes, [ size := 0 ], [ rightouterjoin := TRUE ]);
    RETURN EnrichWithTable(rows, "indexmanager", consilio.indexmanagers,
        [ indexmanager_name :=    "name"
        , indexmanager_type :=    "type"
        ]);
  }

  INTEGER FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();

    IF (NOT work->HasFailed())
    {
      IF (RecordExists(SELECT FROM consilio.catalogs
                        WHERE ToUppercase(name) = ToUppercase(^name->value)
                              AND id != this->catalogid))
      {
        work->AddErrorFor(^name, GetTid("consilio:catalog.messages.catalognameexists", ^name->value));
      }
    }

    RECORD catalog :=
        [ name := ^name->value
        , description := ^description->value
        , loglevel := ^debuglevel->value
        , priority := ^priority->value
        , type := ^type->value
        ];

    INTEGER newcatalogid;
    //FIXME should go through APIs
    IF(this->catalogid = 0)
    {
      newcatalogid := MakeAutonumber(consilio.catalogs, "id");
      INSERT CELL [ ...catalog, id := newcatalogid ] INTO consilio.catalogs;
    }
    ELSE
    {
      UPDATE consilio.catalogs SET RECORD catalog WHERE id = this->catalogid;
    }

    BOOLEAN need_rebuild;
    IF (NOT work->HasFailed())
    {
      //nothing to update right now ?
      //OpenConsilioCatalogById(this->catalogid ?? newcatalogid)->UpdateCatalog(
      //    [ indexmanagers :=    (SELECT indexmanager, indexname, primary FROM ^indexmanagers->value)
      //    ]);
    }

    GetPrimary()->BroadCastOnCommit("consilio:indiceschanged", DEFAULT RECORD);

    IF(NOT work->Finish())
      RETURN 0;

    BroadcastEvent("consilio:contentsourceschanged", DEFAULT RECORD);
    RETURN newcatalogid ?? this->catalogid;
  }

  MACRO DoRefreshSizes()
  {
    this->RefreshCatalogSizes();
  }
>;

PUBLIC STATIC OBJECTTYPE EditCatalogIndex EXTEND TolliumScreenBase
<
  OBJECT catalog;
  INTEGER indexid;

  MACRO Init(RECORD data)
  {
    this->catalog := data.catalog;

    ^indexmanager->options := SELECT rowkey := id, title := name, tolliumselected := isdefault, isbuiltin
                                FROM ListIndexManagers()
                            ORDER BY ToUppercase(name);

    RECORD indexinfo;
    IF(data.id != 0)
    {
      indexinfo := SELECT * FROM this->catalog->ListAttachedIndices() WHERE id = data.id;
      IF(NOT RecordExists(indexinfo))
        THROW NEW Exception(`Index #${data.id} no longer exists?`);

      this->indexid := data.id;
      ^indexmanager->value := indexinfo.indexmanager;
      ^indexname->value := indexinfo.indexname;
      ^searchpriority->value := indexinfo.searchpriority;

      //no edit support yet
      ^indexmanager->enabled := FALSE;
      ^indexname->enabled := FALSE;
      ^searchpriority->enabled := FALSE;
    }
    ELSE //Adding
    {
      ^searchpriority->visible := FALSE; //can't set this (yet?)
    }
    this->OnGotIndexManagerChange();
  }

  MACRO OnGotIndexManagerChange()
  {
    ^indexname->required := NOT ^indexmanager->selection.isbuiltin;
    ^indexname->placeholder := ^indexmanager->selection.isbuiltin ? `c_123456789… (${this->GetTid(".autogenerated")})` : '';
  }

  INTEGER FUNCTION Submit()
  {
    IF(this->indexid != 0)
      RETURN this->indexid; //not supporting edit yet

    OBJECT work := this->BeginWork();

    //we can always relax restrictions.. but for now we specifically allow only one __ and no - (and just forbid most things just in case)
    STRING indexname := ToLowercase(^indexname->value);
    IF(indexname != "" AND NOT IsValidConsilioIndexName(indexname))
      work->AddErrorFor(^indexname, this->GetTid(".invalidindexname"));

    IF(work->HasFailed()) {
      work->Finish();
      RETURN 0;
    }

    INTEGER newindexid := this->catalog->AttachIndex(^indexmanager->value, CELL[indexname]);
    RETURN work->Finish() ? newindexid : 0;
  }
>;


//inspect a single item in consilio
PUBLIC BOOLEAN FUNCTION RunConsilioInspectDialog(OBJECT parent, STRING catalogname, STRING tag, STRING objectid)
{
  INTEGER catalogid := (SELECT AS INTEGER id FROM consilio.catalogs WHERE name = whconstant_consilio_catalog_whfs);
  RECORD res := GetPreviewResults(parent->contexts->user, catalogid, 0, 1, CQMatch("objectid", "=", objectid));
  //FIXME if totalcount > 1, forward to CatalogPreview
  IF(res.totalcount = 0)
    RETURN FALSE;

  parent->contexts->screen->RunScreen("mod::consilio/screens/catalog.xml#catalogpreviewitem", res.results[0]);
  RETURN TRUE;
}

RECORD FUNCTION GetPreviewResults(OBJECT user, INTEGER catalogid, INTEGER contentsourceid, INTEGER maxresults, RECORD query)
{
  RECORD idxoptions := __GetIndexManagerOptions(catalogid);
  RECORD options := [ count := maxresults
                    , mapping := CELL[ ...idxoptions.defaultmapping
                                     , _indexed := DEFAULT DATETIME
                                     , _contentsource := 0
                                     , _score := "_score"
                                     ]
                    ];
  RETURN SearchIndexManager(catalogid, query ?? CQAll(), options, idxoptions);
}

PUBLIC STATIC OBJECTTYPE CatalogPreview EXTEND TolliumScreenBase
< INTEGER catalog_id;
  STRING catalog_name;
  RECORD ARRAY consiliorecords;
  INTEGER contentsourceid;

  MACRO Init(RECORD catalog)
  {
    IF (catalog.catalog)
    {
      this->catalog_name := catalog.tag;
      //the ?? hack is needed for dashboard query view... we should probably just log the index ids
      this->catalog_id := catalog.id ?? (SELECT AS INTEGER id FROM consilio.catalogs WHERE ToUppercase(name) = ToUppercase(catalog.tag));

      this->frame->title := GetTid("consilio:catalog.catalogpreview.title", this->catalog_name);
      this->^query->value := CellExists(catalog,'query') ? catalog.query : '';
    }

    OBJECT catalogobj := OpenConsilioCatalog(catalog.tag);
    IF (RecordExists(SELECT FROM catalogobj->GetExpectedMapping() AS mapping WHERE CellExists(mapping, "suggested") ? mapping.suggested : FALSE))
      ^consilio_autosuggest->SetSearchCatalog(this->catalog_name);
  }

  MACRO DoSearch(BOOLEAN showall DEFAULTSTO FALSE)
  {
    this->^resultsinfo->visible := FALSE;

    DATETIME starttime := GetCurrentDateTime();
    INTEGER numresults := showall ? -1 : searchlimit;
    RECORD search;
    TRY
    {
      VARIANT query := DecodeJSON(^query->value);
      IF (TYPEID(query) = TYPEID(RECORD) AND RecordExists(query))
        query := CQOpenSearch(query);
      ELSE
        query := CQParseUserQuery(^query->value);
      search := GetPreviewResults(this->tolliumuser, this->catalog_id, this->contentsourceid, numresults, query);
    }
    CATCH (OBJECT<SearchException> error)
    {
      Print("Search exception: " || error->what || "\n");
      this->RunSimpleScreen("warning", GetTid("consilio:catalog.messages.searcherror", GetErrorMessage(error->errorcode)));
      this->^status->value := GetTid("consilio:catalog.catalogpreview.error");
      this->^results->rows := DEFAULT RECORD ARRAY;
      RETURN;
    }
    CATCH (OBJECT e)
    {
      Print("Search exception: " || e->what || "\n");
      this->RunSimpleScreen("warning", GetTid("consilio:catalog.messages.searcherror", e->what));
      this->^status->value := GetTid("consilio:catalog.catalogpreview.error");
      this->^results->rows := DEFAULT RECORD ARRAY;
      RETURN;
    }

    DATETIME endtime := GetCurrentDateTime();
    INTEGER searchtime := GetMSecsDifference(starttime, endtime);

    IF (search.totalcount > searchlimit AND NOT showall)
    {
      this->^resultsinfo->visible := TRUE;
      this->^resultsmessage->htmlvalue := GetTid("consilio:catalog.catalogpreview.toomanyresults", this->tolliumuser->FormatMoney(searchlimit, 0, TRUE)) || ' <a href="preview:showallresults">' || GetTid("consilio:catalog.catalogpreview.clickallresults", this->tolliumuser->FormatMoney(search.totalcount, 0, TRUE)) || '</a>';
    }

    this->consiliorecords := SELECT *
                                  , id := #results + 1
                               FROM search.results;

    this->^status->value := GetTid("consilio:catalog.catalogpreview.numresults", this->tolliumuser->FormatMoney(Length(search.results), 0, TRUE), this->tolliumuser->FormatMoney(searchtime, 0, TRUE));
    this->^results->rows := SELECT rowkey := id
                                , id
                                , url := objectid
                                , score := this->tolliumuser->FormatFloat(_score, 5)
                                , indexid := this->catalog_id
                                , objectid
                             FROM this->consiliorecords;
    this->^results->empty := GetTid("consilio:catalog.catalogpreview.noresults");
  }

  MACRO DoViewItem()
  {
    RECORD result := SELECT *
                       FROM this->consiliorecords
                      WHERE id = this->^results->value;
    IF (RecordExists(result))
      this->LoadScreen(".catalogpreviewitem", result)->RunModal();
  }

  MACRO OnMessageClick(STRING href)
  {
    IF (href LIKE "preview:*")
    {
      href := Right(href, Length(href) - 8);
      IF (href = "showallresults")
        this->DoSearch(TRUE);
    }
  }
>;

PUBLIC STATIC OBJECTTYPE CatalogPreviewItem EXTEND TolliumScreenBase
<
  RECORD ARRAY allfieldrows;

  MACRO Init(RECORD result)
  {
    RECORD ARRAY allfieldrows;
    RECORD ARRAY allresultrows;

    // Show all Consilio fields
    FOREVERY (RECORD field FROM SELECT * FROM UnpackRecord(result) ORDER BY name)
    {
      RECORD ARRAY fieldrows := this->GenerateFieldRows(field, 0);
      IF (NOT RecordExists(fieldrows))
        CONTINUE;
      IF (fieldrows[0].name IN resultfieldnames)
        allresultrows := allresultrows CONCAT fieldrows;
      ELSE
        allfieldrows := allfieldrows CONCAT fieldrows;
    }

    IF (Length(allfieldrows) > 0)
    {
      BOOLEAN isempty := NOT RecordExists(SELECT FROM allfieldrows WHERE NOT COLUMN isempty);
      this->allfieldrows := this->allfieldrows CONCAT
          [ CELL[ name := "", collapsedvalue := "", value := "", link := "", isempty ]
          , CELL[ name := this->GetTid(".otherfields"), collapsedvalue := "", value := "", link := "", isempty, style := "heading" ]
          , ...allfieldrows
          ];
    }
    IF (Length(allresultrows) > 0)
    {
      BOOLEAN isempty := NOT RecordExists(SELECT FROM allresultrows WHERE NOT COLUMN isempty);
      this->allfieldrows := this->allfieldrows CONCAT
          [ CELL[ name := "", collapsedvalue := "", value := "", link := "", isempty ]
          , CELL[ name := this->GetTid(".resultfields"), collapsedvalue := "", value := "", link := "", isempty, style := "heading" ]
          , ...allresultrows
          ];
    }
    IF (RecordExists(this->allfieldrows))
      DELETE FROM this->allfieldrows AT 0;
    this->allfieldrows := SELECT *, rowkey := #allfieldrows + 1 FROM this->allfieldrows;

    this->OnShowEmptyChange();
  }

  RECORD ARRAY FUNCTION GenerateFieldRows(RECORD field, INTEGER level)
  {
    STRING value;
    STRING collapsedvalue;
    RECORD ARRAY subnodes;
    IF (TypeID(field.value) = TypeID(RECORD))
    {
      RECORD ARRAY subfields := UnpackRecord(field.value);
      value := this->GetTid(".recordvalue", ToString(Length(subfields)));
      FOREVERY (RECORD subfield FROM SELECT * FROM subfields ORDER BY name)
        subnodes := subnodes CONCAT this->GenerateFieldRows(subfield, level + 1);
    }
    ELSE IF (TypeID(field.value) = TypeID(RECORD ARRAY))
    {
      value := this->GetTid(".arrayvalue", ToString(Length(field.value)));
      FOREVERY (RECORD subvalue FROM field.value)
        subnodes := subnodes CONCAT this->GenerateFieldRows(subvalue, level + 1);
    }
    ELSE IF (IsTypeIDArray(TypeID(field.value)))
    {
      value := this->GetTid(".arrayvalue", ToString(Length(field.value)));
      subnodes :=
          SELECT TEMPORARY formattedvalue := this->FormatFieldValue(subvalue)
               , name := `#${#subvalues}`
               , collapsedvalue := ""
               , value := formattedvalue
               , link := formattedvalue LIKE "http://*" OR formattedvalue LIKE "https://*" ? formattedvalue : ""
               , isempty := FALSE
               , level := level + 1
            FROM ToRecordArray(field.value, "subvalue") AS subvalues;
      collapsedvalue := value;
      IF (Length(field.value) > 0 AND TypeID(field.value) != TypeID(RECORD ARRAY))
      {
        collapsedvalue := collapsedvalue || ": " || Detokenize((SELECT AS STRING ARRAY COLUMN value FROM subnodes WHERE #subnodes < 5), "; ");
        IF (Length(subnodes) > 5)
          collapsedvalue := collapsedvalue || ", …";
      }
    }
    ELSE
      value := this->FormatFieldValue(field.value);

    STRING link;
    IF (field.name = "SUMMARY")
    {
      IF (value = "")
        RETURN RECORD[];
    }
    ELSE IF (field.name = "GROUPID")
    {
      // If the groupid value is a positive integer, it is a WebHare file id, link it to the publisher
      // INTEGER groupid := ToInteger(value, 0);
      // IF (groupid > 0)
      //   link := PTR RunPublisherFileManager(this, groupid);
    }
    ELSE IF (field.name = "SIZE" AND CanCastTypeTo(TypeID(field.value), TypeID(INTEGER64)))
    {
      // If the field name is "size", assume the value contains a number of bytes, format it
      value := this->tolliumuser->FormatFileSize(field.value, 2, TRUE);
    }
    ELSE IF (value LIKE "http://*" OR value LIKE "https://*")
    {
      // If the field value contains a URL, make it clickable
      link := value;
    }

    RETURN [ CELL
        [ name := ToLowercase(field.name)
        , collapsedvalue := collapsedvalue ?? value
        , value
        , link
        , isempty := IsDefaultValue(field.value) OR (RecordExists(subnodes) AND NOT RecordExists(SELECT FROM subnodes WHERE NOT isempty))
        , expandable := RecordExists(subnodes)
        , expanded := TypeID(field.value) = TypeID(RECORD) AND RecordExists(subnodes)
        , level
        ] ] CONCAT subnodes;
  }

  STRING FUNCTION FormatFieldValue(VARIANT value)
  {
    SWITCH (TypeID(value))
    {
      CASE TypeID(INTEGER), TypeID(INTEGER64)
      {
        RETURN ToString(value);
      }
      CASE TypeID(DATETIME)
      {
        RETURN value != DEFAULT DATETIME ? this->tolliumuser->FormatDateTime(value, "milliseconds", FALSE, TRUE) || " UTC" : "";
      }
      CASE TypeID(MONEY)
      {
        RETURN this->tolliumuser->FormatMoney(value, 5, FALSE);
      }
      CASE TypeID(FLOAT)
      {
        RETURN this->tolliumuser->FormatFloat(value, -1);
      }
      CASE TypeID(STRING)
      {
        RETURN value;
      }
      CASE TypeID(BOOLEAN)
      {
        RETURN value ? "true" : "false";
      }
    }
    RETURN EncodeJSON(value);
  }

  STRING FUNCTION RemoveHighlighting(STRING text)
  {
    text := Substitute(text, "\x1D", '');
    text := Substitute(text, "\x1C", '');

    RETURN text;
  }

  MACRO OnShowEmptyChange()
  {
    ^fields->rows := SELECT * FROM this->allfieldrows WHERE this->^showempty->value OR NOT isempty;
  }
>;

PUBLIC STATIC OBJECTTYPE ContentSourceEditor EXTEND TolliumScreenBase
<
  OBJECT catalog;
  OBJECT contentsource;

  MACRO Init(RECORD data)
  {
    data := ValidateOptions([ catalog := 0, contentsource := 0 ], data, [ required := ["catalog"]]);
    this->catalog := OpenConsilioCatalogById(data.catalog);

    STRING cptype := whconstant_consilio_contentprovider_site;
    IF(data.contentsource != 0)
    {
      this->contentsource := this->catalog->OpenContentSourceById(data.contentsource);
      IF(NOT ObjectExists(this->contentsource))
        THROW NEW Exception(`Unable to open contentsource #${data.contentsource}`);

      cptype := this->contentsource->__contentprovider;
    }

    //NOTE: we didn't clear out the contentprovider infrastructure because it already exists anyway, but we might still
    //      freeze them in their current state and remove extensibility anyway?
    RECORD contentprovider := SELECT * FROM GetContentProviders() WHERE name = cptype;
    IF(NOT RecordExists(contentprovider))
      THROW NEW Exception(`Unable to describe contentproviders of type '${cptype}'`);

    ^contentsourcetype->value := GetTid(contentprovider.title);
    ^folder->visible := cptype = whconstant_consilio_contentprovider_site;
    ^folder->enabled := ^folder->visible;
    ^contentcheckinterval->placeholder := ToString(default_contentcheckinterval);

    IF (data.contentsource != 0)
    {
      //For now we'll keep lowlevel options out of the API.
      RECORD dbsettings := SELECT * FROM consilio.contentsources WHERE id = this->contentsource->id;
      ^folder->value := this->contentsource->fsobject;
      ^id->value := ToString(this->contentsource->id);
      ^tag->value := dbsettings.tag;
      ^disablesource->value := dbsettings.status < 0;

      this->frame->title := GetTid("consilio:catalog.contentsourceeditor.title-edit");
    }
    ELSE
    {
      ^id->visible := FALSE;
      ^lastcontentscheck->visible := FALSE;

      this->frame->title := GetTid("consilio:catalog.contentsourceeditor.title-new");
    }
  }

  INTEGER FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    OBJECT finalsource := this->contentsource;

    IF(NOT ObjectExists(finalsource))
      finalsource := this->catalog->AddFolderToCatalog(^folder->value, [ definedby := this->contexts->user->login ]);

    //TODO - api ?
    UPDATE consilio.contentsources
           SET status := ^disablesource->value ? contentsourcestatus_disabled : status = contentsourcestatus_disabled ? contentsourcestatus_idle : status //flip status to -1 to disable, 0 to re-enable and otherwise leave alone
             , fsobject := ^folder->value
         WHERE id = finalsource->id;

    GetPrimary()->BroadCastOnCommit("consilio:contentsourceschanged", DEFAULT RECORD);
    IF(ObjectExists(this->contentsource)) //we were editing
      finalsource->ReindexContentSource(); //FIXME postpone until after commit! an update API should do that for us

    RETURN work->Finish() ? finalsource->id : 0;
  }
>;

PUBLIC STATIC OBJECTTYPE Thesaurus EXTEND TolliumScreenBase
< OBJECT catalog;
  RECORD ARRAY wordgroups;

  PUBLIC PROPERTY lang(this->catalog->lang, -);

  MACRO Init(RECORD data)
  {
    this->catalog := OpenConsilioCatalogById(data.indexid);
    this->frame->title := GetTid("consilio:catalog.thesaurus.title", this->catalog->tag);
    ^words->value := /* SELECT *, rowkey := wordgroup FROM  */this->catalog->GetSynonyms();
  }

  MACRO DoSearchWords()
  {
    /*ADDME: How to filter in an arrayedit?
    IF (Length(^words->rows) = 0)
      RETURN;

    IF (match <= 0)
      this->RunSimpleScreen("warning", GetTid("consilio:catalog.messages.wordnotfound", ^search->value));
    */
  }

  RECORD ARRAY FUNCTION MapWordGroups(RECORD ARRAY wordgroups)
  {
    RETURN
        SELECT TEMPORARY sorted_words :=
                   (SELECT AS STRING ARRAY w
                      FROM ToRecordArray(words, "w")
                     ORDER BY w)
             , *
             , wordgroup := Detokenize(sorted_words, ", ")
          FROM wordgroups;
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginWork();
    this->catalog->SetSynonyms(^words->value);
    RETURN work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE ThesaurusWords EXTEND TolliumRowEditScreenBase
<
  PUBLIC PROPERTY curwords(this->^wordgroup->value, -);

  UPDATE MACRO Init(RECORD data)
  {
    TolliumRowEditScreenBase::Init(data);

    IF (RecordExists(data.row))
      ^words->value := ToRecordArray(data.row.words, "word");
  }

  RECORD ARRAY FUNCTION MapWords(RECORD ARRAY words)
  {
    RETURN SELECT * FROM words ORDER BY word;
  }

  MACRO OnWordsChange()
  {
    this->UpdateWordGroup(SELECT AS STRING ARRAY word FROM ^words->value);
  }

  MACRO UpdateWordGroup(STRING ARRAY words)
  {
    ^wordgroup->options := SELECT rowkey := word , title := "" FROM ToRecordArray(words, "word");
    ^wordgroup->value := SELECT AS STRING ARRAY rowkey FROM ^wordgroup->options;
  }
>;

PUBLIC STATIC OBJECTTYPE ThesaurusWord EXTEND TolliumRowEditScreenBase
<
  STRING initialword;
  STRING ARRAY stopwords;

  UPDATE MACRO Init(RECORD data)
  {
    TolliumRowEditScreenBase::Init(data);
    IF (RecordExists(data.row))
      this->initialword := data.row.word;
    this->stopwords := CellExists(stopwordlists, this->tolliumparent->tolliumparent->lang) ? GetCell(stopwordlists, this->tolliumparent->tolliumparent->lang) : STRING[];
  }

  UPDATE BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();
    ^word->value := NormalizeText(^word->value, "en");
    FOREVERY (STRING tocheck FROM Tokenize(^word->value, " "))
      IF (tocheck != "" AND tocheck IN this->stopwords)
        work->AddError(GetTid("consilio:catalog.messages.stopwordsnotallowed", tocheck));
    IF (^word->value != this->initialword AND ^word->value IN this->tolliumparent->curwords)
      work->AddError(GetTid("consilio:catalog.messages.wordalreadyonlist", ^word->value));
    RETURN work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE ContentSourceErrors EXTEND TolliumScreenBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  INTEGER contentsourceid;

  // ---------------------------------------------------------------------------
  //
  // Init
  //

  MACRO Init(RECORD data)
  {
    this->contentsourceid := data.contentsourceid;
    ^errors->rows :=
        SELECT error :=         what != "" ? what : error
             , errorloc :=      error
             , what :=          what
             , linetext :=      ""
             , coltext :=       ""
             , func :=          ""
             , expanded :=      FALSE
             , trace :=         this->DecodeTrace(trace)
             , subnodes :=
                   SELECT filename
                        , what :=       errors.what
                        , errorloc :=   errors.error
                        , line
                        , col
                        , func
                        , error :=      filename
                        , linetext :=   ToString(line)
                        , coltext :=    ToString(col)
                        , expanded :=   FALSE
                     FROM this->DecodeTrace(trace)
          FROM data.errors;
    IF (RecordExists(^errors->rows))
      ^errors->selection := ^errors->rows[0];
  }


  RECORD ARRAY FUNCTION DecodeTrace(STRING ARRAY trace)
  {
    RECORD ARRAY result;

    FOREVERY (STRING t FROM trace)
    {
      // Parse format: <file>(<line>,<col>)[ (<func>) ]
      STRING ARRAY parts := Tokenize(t, "(");

      RECORD rec :=
          [ filename := TrimWhitespace(parts[0])
          , line :=     1
          , col :=      1
          , func :=     ""
          ];

      IF (LENGTH(parts) >= 2)
      {
        STRING ARRAY posparts := Tokenize(Tokenize(parts[1], ")")[0] || ",", ",");
        rec.line := ToInteger(posparts[0], 1);
        rec.col := ToInteger(posparts[1], 1);
      }

      IF (LENGTH(parts) >= 3)
        rec.func := Tokenize(parts[2], ")")[0];

      INSERT rec INTO result AT END;
    }
    RETURN result;
  }

  // ---------------------------------------------------------------------------
  //
  // Actions
  //

  MACRO DoClear()
  {
    IF (this->RunSimpleScreen("verify", GetTid("consilio:catalog.messages.confirmclearerrors")) = "yes")
    {
      __ConsilioClearErrors(this->contentsourceid);
      this->tolliumresult := "cancel";
    }
  }
>;

RECORD ARRAY FUNCTION GetMappingAsTree(RECORD ARRAY mapping)
{
  RETURN SELECT name
              , type
              , definedby
              , subnodes := GetMappingAsTree(properties)
              , expanded := TRUE
              , valuetype := Substitute(GetTypeName(TypeID(defaultvalue)), " ARRAY", "[]")
           FROM mapping;
}

PUBLIC STATIC OBJECTTYPE FieldMapping EXTEND TolliumScreenBase
<
  MACRO Init(RECORD data)
  {
    RECORD ARRAY mapping := OpenConsilioCatalogById(data.catalog)->GetExpectedMapping();
    ^fieldmapping->rows := GetMappingAsTree(mapping);
  }

>;
