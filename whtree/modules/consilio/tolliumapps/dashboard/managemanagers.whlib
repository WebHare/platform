<?wh

LOADLIB "mod::consilio/lib/internal/support.whlib";
LOADLIB "mod::consilio/lib/internal/dbschema.whlib";
LOADLIB "mod::consilio/lib/internal/opensearch.whlib";

LOADLIB "mod::system/lib/database.whlib";

LOADLIB "mod::tollium/lib/screenbase.whlib";

CONSTANT STRING
    default_watermark_low := "85%",
    default_watermark_high := "90%",
    default_watermark_flood := "95%";

PUBLIC STATIC OBJECTTYPE IndexManagers EXTEND TolliumScreenBase
<
  MACRO Init(RECORD data)
  {
    ^mgrs->AddAction(this->GetTid(".runtimesettings"), PTR this->ManageRuntimeSettings);
  }
  RECORD ARRAY FUNCTION OnGetMgrs()
  {
    RETURN SELECT rowkey := id
                , name
                , address := address LIKE "builtin*" ? `<${this->GetTid(".address-builtin")}>` : address
             FROM consilio.indexmanagers;
  }
  MACRO OnEditMgr(RECORD row)
  {
    this->RunScreen("#editindexmanager", [ id := RecordExists(row) ? row.rowkey : 0 ]);
  }
  MACRO ManageRuntimeSettings()
  {
    this->RunScreen("#runtimesettings", [ id := ^mgrs->value ]);
  }
  MACRO OnDeleteMgr(RECORD row)
  {
    IF(this->RunSimpleScreen("confirm", this->GetTid(".confirmdeleteindexmanager")) != "yes")
      RETURN;

    OBJECT work := this->BeginWork([ validate := OBJECT[] ]);
    DELETE FROM consilio.indexmanagers WHERE id = row.rowkey;
    GetPrimary()->BroadcastOnCommit("system:apprunner.internal.rescan", DEFAULT RECORD);
    work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE EditIndexManager EXTEND TolliumScreenBase
<
  INTEGER id;
  BOOLEAN builtinaddress;
  RECORD currentconfig;

  MACRO Init(RECORD data)
  {
    this->id := data.id;
    RECORD indexmgr;
    IF(this->id != 0)
    {
      indexmgr := SELECT * FROM consilio.indexmanagers WHERE id = data.id;
      IF(NOT RecordExists(indexmgr))
        THROW NEW Exception(`Cannot load current indexmanager settings`);

      this->builtinaddress := indexmgr.address = "builtin-opensearch";
    }

    //only show configuration for builtin server
    ^configuration->visible := this->builtinaddress;
    ^initialmemorypool->visible := this->builtinaddress;
    ^maximummemorypool->visible := this->builtinaddress;
    ^warnheapusage->visible := this->builtinaddress;
    ^initialmemorypool->placeholder := ToString(default_opensearch_configuration.initialmemorypool);
    ^maximummemorypool->placeholder := ToString(default_opensearch_configuration.maximummemorypool);
    ^warnheapusage->placeholder := ToString(default_opensearch_configuration.warnheapusage);

    IF(data.id != 0)
    {
      ^indexmgr->value := indexmgr;
      IF (this->builtinaddress)
      {
        ^address->enabled := FALSE;
        ^address->value := `<${this->GetTid(".address-builtin")}>`;
      }

      IF(indexmgr.configuration != "")
      {
        RECORD config := DecodeHSON(indexmgr.configuration);
        IF(CellExists(config, 'initialmemorypool'))
          ^initialmemorypool->value := config.initialmemorypool;
        IF(CellExists(config, 'maximummemorypool'))
          ^maximummemorypool->value := config.maximummemorypool;
        IF(CellExists(config, 'warnheapusage'))
          ^warnheapusage->value := config.warnheapusage;
      }

      //we only watch the values that will trigger a restart (due to being on the cmdline to opensearch)
      this->currentconfig := CELL[ initialmemorypool := ^initialmemorypool->value
                                 , maximummemorypool := ^maximummemorypool->value
                                 ];
    }

    //require address if we've already got a builtin version of this one
    ^address->required := RecordExists(SELECT FROM consilio.indexmanagers WHERE id != this->id AND address = "builtin-opensearch");
  }
  BOOLEAN FUNCTION Submit()
  {
    RECORD toset := ^indexmgr->value;
    IF(^configuration->visible)
    {
      RECORD config;
      IF(^initialmemorypool->value > 0)
        INSERT CELL initialmemorypool := ^initialmemorypool->value INTO config;
      IF(^maximummemorypool->value > 0)
        INSERT CELL maximummemorypool := ^maximummemorypool->value INTO config;
      IF(^warnheapusage->value > 0)
        INSERT CELL warnheapusage := ^warnheapusage->value INTO config;

      IF(^initialmemorypool->value != this->currentconfig.initialmemorypool
         OR ^maximummemorypool->value != this->currentconfig.maximummemorypool)
      {
        IF(this->RunSimpleScreen("verify", this->GetTid(".willrestart")) != "yes")
          RETURN FALSE;
      }

      INSERT CELL configuration := RecordExists(config) ? EncodeHSON(config) : "" INTO toset;
    }

    OBJECT work := this->BeginWork();

    IF (NOT work->HasFailed())
    {
      IF(this->builtinaddress)
        toset.address := "builtin-opensearch";

      INTEGER indexmgrid := this->id;
      IF(indexmgrid != 0)
        UPDATE consilio.indexmanagers SET RECORD toset WHERE id = indexmgrid;
      ELSE
      {
        indexmgrid := MakeAutonumber(consilio.indexmanagers, "id");
        INSERT CELL[ ...toset, id := indexmgrid ] INTO consilio.indexmanagers;
      }
    }

    GetPrimary()->BroadcastOnCommit("system:apprunner.internal.rescan", DEFAULT RECORD);
    RETURN work->Finish();
  }
>;

PUBLIC STATIC OBJECTTYPE RuntimeSettings EXTEND TolliumScreenBase
<
  INTEGER id;
  RECORD cursettings;

  MACRO Init(RECORD data)
  {
    ^watermark_low->placeholder := default_watermark_low;
    ^watermark_high->placeholder := default_watermark_high;
    ^watermark_flood->placeholder := default_watermark_flood;

    // Read OpenSearch configuration (TODO shouldn't block on this in case it's down - perhaps split off runtime settings into a separate dialog?)
    TRY
    {
      this->id := data.id;
      this->cursettings := GetOpenSearchSettings(data.id, FALSE);
    }
    CATCH(OBJECT e)
    {
      this->RunSimpleScreen("error", this->GetTid(".cannotretrievesettings", e->what));
      this->tolliumresult := "cancel";
      RETURN;
    }
    ^threshold_enabled->value := NOT CellExists(this->cursettings, "cluster.routing.allocation.disk.threshold_enabled") OR this->cursettings."cluster.routing.allocation.disk.threshold_enabled" != "false";
    ^watermark_low->value := CellExists(this->cursettings, "cluster.routing.allocation.disk.watermark.low") ? this->cursettings."cluster.routing.allocation.disk.watermark.low" : "";
    ^watermark_high->value := CellExists(this->cursettings, "cluster.routing.allocation.disk.watermark.high") ? this->cursettings."cluster.routing.allocation.disk.watermark.high" : "";
    ^watermark_flood->value := CellExists(this->cursettings, "cluster.routing.allocation.disk.watermark.flood_stage") ? this->cursettings."cluster.routing.allocation.disk.watermark.flood_stage" : "";
  }
  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();
    // The watermark values should all be either percentages or absolute byte values
    RECORD ARRAY watermarks :=
        [ CELL[ ^watermark_low->value ]
        , CELL[ ^watermark_high->value ]
        , CELL[ ^watermark_flood->value ]
        ];
    // Count the number of percentages (default value is a percentage)
    INTEGER num_percent := SELECT AS INTEGER Count(*) FROM watermarks WHERE value = "" OR value LIKE "*%";
    // The number of percentages should be either 0 or 3
    IF (num_percent = 0)
    {
      // Check for valid byte values
      INTEGER64 low_bytes := ParseOpenSearchBytes(^watermark_low->value);
      IF (low_bytes < 0)
        work->AddErrorFor(^watermark_low, this->GetTid(".messages.invalidbytevalue", ^watermark_low->errorlabel ?? ^watermark_low->title, ^watermark_low->value));
      INTEGER64 high_bytes := ParseOpenSearchBytes(^watermark_high->value);
      IF (high_bytes < 0)
        work->AddErrorFor(^watermark_high, this->GetTid(".messages.invalidbytevalue", ^watermark_high->errorlabel ?? ^watermark_high->title, ^watermark_high->value));
      INTEGER64 flood_bytes := ParseOpenSearchBytes(^watermark_flood->value);
      IF (flood_bytes < 0)
        work->AddErrorFor(^watermark_flood, this->GetTid(".messages.invalidbytevalue", ^watermark_flood->errorlabel ?? ^watermark_flood->title, ^watermark_flood->value));

      // Check if low >= high >= flood (absolute values count free disk space)
      IF (NOT work->HasFailed())
      {
        IF (high_bytes > low_bytes)
          work->AddErrorFor(^watermark_high, this->GetTid(".messages.valuetoohigh", ^watermark_high->errorlabel ?? ^watermark_high->title, ^watermark_low->errorlabel ?? ^watermark_low->title));
        IF (flood_bytes > high_bytes)
          work->AddErrorFor(^watermark_flood, this->GetTid(".messages.valuetoohigh", ^watermark_flood->errorlabel ?? ^watermark_flood->title, ^watermark_high->errorlabel ?? ^watermark_high->title));
      }
    }
    ELSE IF (num_percent = 3)
    {
      // Check for valid percentages
      STRING low_value := ^watermark_low->value ?? default_watermark_low;
      INTEGER low_percent := ToInteger(Left(low_value, Length(low_value) - 1), 0);
      IF (low_percent <= 0 OR low_percent >= 100)
        work->AddErrorFor(^watermark_low, this->GetTid(".messages.invalidpercentage", ^watermark_low->errorlabel ?? ^watermark_low->title, ^watermark_low->value));
      STRING high_value := ^watermark_high->value ?? default_watermark_high;
      INTEGER high_percent := ToInteger(Left(high_value, Length(high_value) - 1), 0);
      IF (high_percent <= 0 OR high_percent >= 100)
        work->AddErrorFor(^watermark_high, this->GetTid(".messages.invalidpercentage", ^watermark_high->errorlabel ?? ^watermark_high->title, ^watermark_high->value));
      STRING flood_value := ^watermark_flood->value ?? default_watermark_flood;
      INTEGER flood_percent := ToInteger(Left(flood_value, Length(flood_value) - 1), 0);
      IF (flood_percent <= 0 OR flood_percent >= 100)
        work->AddErrorFor(^watermark_flood, this->GetTid(".messages.invalidpercentage", ^watermark_flood->errorlabel ?? ^watermark_flood->title, ^watermark_flood->value));

      // Check if low <= high <= flood (percentages count used disk space)
      IF (NOT work->HasFailed())
      {
        IF (high_percent < low_percent)
          work->AddErrorFor(^watermark_high, this->GetTid(".messages.valuetoolow", ^watermark_high->errorlabel ?? ^watermark_high->title, ^watermark_low->errorlabel ?? ^watermark_low->title));
        IF (flood_percent < high_percent)
          work->AddErrorFor(^watermark_flood, this->GetTid(".messages.valuetoolow", ^watermark_flood->errorlabel ?? ^watermark_flood->title, ^watermark_high->errorlabel ?? ^watermark_high->title));
      }
    }
    ELSE
      work->AddError(this->GetTid(".messages.inconsistentwatermarks"));

    IF (NOT work->HasFailed())
    {
      /* Remove any archived settings, they block PUT _settings changes
      https://www.elastic.co/guide/en/elasticsearch/reference/current/archived-settings.html
      */
      RECORD newsettings := [ "archived.*" := DEFAULT RECORD ];
      IF (^threshold_enabled->value)
      {
        IF (CellExists(this->cursettings, "cluster.routing.allocation.disk.threshold_enabled")
            AND this->cursettings."cluster.routing.allocation.disk.threshold_enabled" = "false")
          INSERT CELL "cluster.routing.allocation.disk.threshold_enabled" := DEFAULT RECORD/*null*/ INTO newsettings;

        STRING new_low_value := ^watermark_low->value != default_watermark_low ? ^watermark_low->value : "";
        IF (new_low_value != "")
          INSERT CELL "cluster.routing.allocation.disk.watermark.low" := new_low_value INTO newsettings;
        ELSE
          INSERT CELL "cluster.routing.allocation.disk.watermark.low" := DEFAULT RECORD/*null*/ INTO newsettings;
        STRING new_high_value := ^watermark_high->value != default_watermark_high ? ^watermark_high->value : "";
        IF (new_high_value != "")
          INSERT CELL "cluster.routing.allocation.disk.watermark.high" := new_high_value INTO newsettings;
        ELSE
          INSERT CELL "cluster.routing.allocation.disk.watermark.high" := DEFAULT RECORD/*null*/ INTO newsettings;
        STRING new_flood_value := ^watermark_flood->value != default_watermark_flood ? ^watermark_flood->value : "";
        IF (new_flood_value != "")
          INSERT CELL "cluster.routing.allocation.disk.watermark.flood_stage" := new_flood_value INTO newsettings;
        ELSE
          INSERT CELL "cluster.routing.allocation.disk.watermark.flood_stage" := DEFAULT RECORD/*null*/ INTO newsettings;
      }
      ELSE
      {
        // If the threshold is currently enabled (the default settings are used or the threshold is set)
        IF (NOT CellExists(this->cursettings, "cluster.routing.allocation.disk.threshold_enabled")
            OR this->cursettings."cluster.routing.allocation.disk.threshold_enabled" != "false")
          INSERT CELL "cluster.routing.allocation.disk.threshold_enabled" := "false" INTO newsettings;
      }

      IF (RecordExists(newsettings))
      {
        RECORD result := SetOpenSearchSettings(this->id, newsettings);
        IF (result.status != SearchOk)
        {
          STRING error := CellExists(result,"result") AND CellExists(result.result, "error") ? result.result.error.reason : result.status;
          work->AddError(this->GetTid(".messages.savesettingserror", error));
        }
      }
    }

    RETURN work->Finish();
  }
>;
