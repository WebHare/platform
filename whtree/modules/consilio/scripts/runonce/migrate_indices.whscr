<?wh

LOADLIB "mod::consilio/lib/internal/support.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/internal/modulemanager.whlib";
LOADLIB "mod::system/lib/internal/dbase/postgresql.whlib";
LOADLIB "mod::system/lib/internal/dbase/updatecommands.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";


// Local schema so the obsolete indices table can be removed from dbschema.whlib
SCHEMA
  < TABLE
    < INTEGER "id" NULL := 0
    , STRING "name"
    , INTEGER "indexmanager" // obsoleted in moduledefinition
    , STRING "description"
    , STRING "definedby"
    , INTEGER "loglevel"
    , INTEGER "priority"
    , INTEGER "type"
    , STRING "indexname" // obsoleted in moduledefinition
    , STRING "fieldgroups"
    , STRING "lang"
    ; KEY id
    > catalogs
  , TABLE
    < INTEGER "id" NULL := 0
    , STRING "address"
    ; KEY id
    > indexmanagers
  , TABLE
    < INTEGER "id" NULL := 0
    , INTEGER "catalogid" NULL := 0
    , INTEGER "indexmanager" NULL := 0
    , STRING "indexname"
    , INTEGER "searchpriority"
    > catalog_indexmanagers
  , TABLE
    < INTEGER "id" NULL := 0
    , STRING "contentprovider"
    , STRING "data"
    , INTEGER "indexid" NULL := 0 // obsoleted in moduledefinition
    , INTEGER "catalogid" NULL := 0
    , STRING "tag"
    , STRING "title"
    , INTEGER "status"
    , DATETIME "last_indexed"
    , DATETIME "orphansince"
    , STRING "definedby"
    , INTEGER "fsobject" NULL := 0
    ; KEY id
    > contentsources
  , TABLE
    < INTEGER "id" NULL := 0
    , INTEGER "indexid" NULL := 0 // obsoleted in moduledefinition
    , INTEGER "catalogid" NULL := 0
    , INTEGER "wordgroup"
    , STRING "word"
    ; KEY id
    > thesaurus
  > consilio;

OBJECT trans := OpenPrimary();
consilio := BindTransactionToSchema(trans->id, "consilio"); //we can do this already, BindTransactionToSchema does not validate anything on the DB

IF (trans->ColumnExists("consilio", "indexmanagers", "id") AND RecordExists(SELECT FROM consilio.indexmanagers WHERE address = "builtin"))
{
  Print("Deleting legacy Consilio index manager\n"); //updateindices will restore and attach new indices
  trans->BeginWork();
  DELETE FROM consilio.indexmanagers WHERE address = "builtin"; //remove any legacy indexmanager
  trans->CommitWork();
}

IF (trans->ColumnExists("consilio", "catalog_indexmanagers", "id"))
{
  //Prepare for the indexmanager != 0 constraint. We messed this up on V1 of the migration
  trans->BeginWork();
  DELETE FROM consilio.catalog_indexmanagers WHERE indexmanager = 0;
  trans->CommitWork();
}

// Nothing to do if already migrated or nothing to migrate
IF (NOT (trans->ColumnExists("consilio", "catalogs", "id") OR NOT trans->ColumnExists("consilio", "indices", "id")))
{
  /* https://gitlab.webhare.com/webharebv/codekloppers/-/issues/546 - we're not fixing everything at the first run after
     a table rename so an update message will leak. */
  Print("Migrating Consilio indices to catalogs - ignore any upcoming 'Non eq defaults' error, it will be automatically fixed later\n");
  trans->BeginWork();

  // Rename the existing 'indices' table to 'catalogs'
  trans->__ExecSQL(`ALTER TABLE consilio.indices RENAME TO catalogs`);

  // Read the database schema from the moduledefinition
  ClearAllSchemaCaches();
  RECORD dbschema := GetModuleDatabaseSchema("consilio");

  FOREVERY (RECORD dbtable FROM dbschema.tables)
  {
    // Remove the not nullable constraints from columns referencing the not as of yet existing catalogs
    UPDATE dbschema.tables[#dbtable].cols
       SET nullable := TRUE
     WHERE references_schema = "consilio" AND references_table = "catalogs";
     // We don't want the obsolete 'indexmanager', 'indexname' and 'indexid' columns to be dropped just yet
    DELETE FROM dbschema.tables[#dbtable].obsoletecols WHERE name IN [ "indexmanager", "indexname", "indexid" ];
  }

  // Update the database
  RECORD result := GeneratePostgreSQLDependentSQLCommands([ dbschema ],trans);
  ExecuteSQLUpdates(result.commands);

  // Link to the index' index manager, if any
  FOREVERY (RECORD indexrec FROM SELECT * FROM consilio.catalogs)
    IF (indexrec.indexmanager != 0)
      INSERT CELL
          [ catalogid := indexrec.id
          , indexmanager := indexrec.indexmanager
          , indexname := indexrec.indexname ?? GenerateConsilioIndexName() //in case for some reason indexname conversion didn't run
          , searchpriority := 100
          ] INTO consilio.catalog_indexmanagers;

  // Set references
  UPDATE consilio.contentsources SET catalogid := indexid;
  UPDATE consilio.thesaurus SET catalogid := indexid;

  trans->CommitWork();
}

trans->BeginWork();

IF (trans->ColumnExists("consilio", "contentsources", "id"))
{
  // Fixup contentsources. Harmless to always try as long as the tables exist
  UPDATE consilio.contentsources SET contentprovider := VAR whconstant_consilio_contentprovider_site WHERE contentprovider = "publisher:webhare";
}

trans->CommitWork();
