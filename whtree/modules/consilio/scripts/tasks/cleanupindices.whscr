<?wh

LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";


OBJECT trans := OpenPrimary();
INTEGER ARRAY updated_contentsources;
BOOLEAN changes;
BOOLEAN debug := "--debug" IN GetConsoleArguments();

// Delete indices from the index managers that are no longer referred
FOREVERY(RECORD indexmanager FROM SELECT * FROM ListIndexManagers() WHERE isbuiltin)
{
  //We garbage collect indexmanagers we fully control ourselves
  RECORD result := GetIndexmanagerIndexList(indexmanager.id);
  IF (debug)
    Print(`Checking index manager ${indexmanager.id}: ${result.status}\n`);
  IF (result.status != SearchOk)
    CONTINUE;

  STRING ARRAY expected_indices := SELECT AS STRING ARRAY indexname
                                     FROM consilio.catalog_indexmanagers
                                    WHERE catalog_indexmanagers.indexmanager = VAR indexmanager.id
                                 ORDER BY indexname;

  DELETE FROM result.indices WHERE BinaryFind(expected_indices, indexname) != -1;
  FOREVERY(RECORD toremove FROM result.indices)
  {
    IF(toremove.indexname NOT LIKE "c_*")  //definately not autocreated by us... let's leave it for the sysop to figure out
    {
      Print(`Index '${toremove.indexname}' appears to be unattached\n`);
      CONTINUE;
    }
    FOREVERY(STRING suffix FROM toremove.suffixes)
    {
      STRING msg := `Deleting unattached index '${toremove.indexname}' with suffix '${suffix}'`;
      LogDebug("consilio:cleanupindices", msg, CELL[ action := "delete", toremove.indexname, suffix ]);
      IF(debug)
        Print(msg || "\n");

      SendToElasticsearch(indexmanager.id, toremove.indexname || (suffix != "" ? "-" || suffix : "*"), "", DEFAULT RECORD, "DELETE");
    }
  }
}

RECORD ARRAY catalogs := ListConsilioCatalogs();
FOREVERY (RECORD cat FROM catalogs)
{
  IF (debug)
    Print(`Checking catalog '${cat.tag}' (${cat.id})\n`);

  // Open the catalog
  OBJECT catalog := OpenConsilioCatalogById(cat.id);
  IF(NOT ObjectExists(catalog) OR NOT catalog->managed)
    CONTINUE; //already gone..

  // Check the catalog's content sources
  RECORD ARRAY sources := catalog->ListContentSources([ __withdeleted := TRUE ]);
  FOREVERY (RECORD src FROM sources)
  {
    IF (debug)
      Print(`  Checking content source '${src.tag}' (${src.id})${src.isdeleted ? " deleted" : src.isorphan ? " orphaned" : ""}\n`);
    IF (src.isdeleted)
    {
      // This content source is marked for deletion, delete it from the index manager, then from the database
      RECORD result := DeleteIndexManagerContentSource(0, cat.id, src.id);
      IF (debug)
        Print(`  Deleted content source: ${result.status}\n`);
      IF (result.status = SearchOk)
      {
        trans->BeginWork();
        DELETE FROM consilio.contentsources WHERE id = src.id;
        trans->CommitWork();
      }
      CONTINUE;
    }
    IF (src.isorphan)
      CONTINUE;

    // Update content source fields and titles
    trans->BeginWork();
    OBJECT source := catalog->OpenContentSourceById(src.id);
    TRY
    {
      //FIXME do we want/need this? who supplies GetContentSourceTitle, does it usefully change all the time?
      OBJECT provider := source->__OpenProvider();
      STRING title := provider->GetContentSourceTitle();
      IF (title != src.title)
        UPDATE consilio.contentsources SET title := VAR title WHERE id = src.id;
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      //TODO what to do? log, scream, go into error mode?
    }
    trans->CommitWork();
  }
}

IF (Length(updated_contentsources) > 0) //ADDME also fire something on eg priority change ?
{
  FOREVERY (INTEGER srcid FROM updated_contentsources)
  {
    BroadcastEvent("consilio:contentsource." || srcid, DEFAULT RECORD);
    OpenContentSourceById(srcid)->ReindexContentSource([ rebuild := TRUE ]);
  }
  changes := TRUE;
}

IF (changes)
{
  BroadcastEvent("consilio:contentsourceschanged", DEFAULT RECORD);
}
