<?wh

LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";


OBJECT trans := OpenPrimary();
INTEGER ARRAY updated_contentsources;
BOOLEAN changes;
BOOLEAN debug := "--debug" IN GetConsoleArguments();

// Delete indices from the index managers that are no longer referred
FOREVERY(RECORD indexmanager FROM SELECT * FROM ListIndexManagers() WHERE isbuiltin)
{
  //We garbage collect indexmanagers we fully control ourselves
  RECORD ARRAY indices;
  TRY
  {
    indices := GetIndexmanagerIndexList(indexmanager.id);
  }
  CATCH(OBJECT<SearchUnavailableException> e)
  {
    //we got unlucky in timing or this WebHare is catching up delayed tasks but still booting
    Print(`Indexmanager #${indexmanager.id} unavailable, skipping cleanup\n`);
    CONTINUE;
  }

  IF (debug)
    Print(`Checking index manager ${indexmanager.id}: ${Length(indices)} indices\n`);

  STRING ARRAY expected_indices := SELECT AS STRING ARRAY indexname
                                     FROM consilio.catalog_indexmanagers
                                    WHERE catalog_indexmanagers.indexmanager = VAR indexmanager.id
                                 ORDER BY indexname;

  DELETE FROM indices WHERE BinaryFind(expected_indices, indexname) != -1;
  FOREVERY(RECORD toremove FROM indices)
  {
    IF(toremove.indexname NOT LIKE "c_*")  //definately not autocreated by us... let's leave it for the sysop to figure out
    {
      Print(`Index '${toremove.indexname}' appears to be unattached\n`);
      CONTINUE;
    }
    FOREVERY(STRING suffix FROM toremove.suffixes)
    {
      STRING msg := `Deleting unattached index '${toremove.indexname}' with suffix '${suffix}'`;
      LogDebug("consilio:cleanupindices", msg, CELL[ action := "delete", toremove.indexname, suffix ]);
      IF(debug)
        Print(msg || "\n");

      SendRawJSONToElasticSearch(indexmanager.id,  "DELETE", toremove.indexname || (suffix != "" ? "-" || suffix : "*"), DEFAULT RECORD);
    }
  }
}

RECORD ARRAY catalogs := ListConsilioCatalogs();
FOREVERY (RECORD cat FROM catalogs)
{
  IF (debug)
    Print(`Checking catalog '${cat.tag}' (${cat.id})\n`);

  // Open the catalog
  OBJECT catalog := OpenConsilioCatalogById(cat.id);
  IF(NOT ObjectExists(catalog) OR NOT catalog->managed)
    CONTINUE; //already gone..

  // Check the catalog's content sources
  RECORD ARRAY sources := catalog->ListContentSources([ __withdeleted := TRUE ]);

  IF(Length(SELECT FROM sources WHERE NOT isdeleted) = 0)
  {
    trans->BeginWork();

    //Detach all indices if there is no more content anyway
    RECORD ARRAY indices := catalog->ListAttachedIndices();
    FOREVERY(RECORD indexrec FROM indices)
      catalog->DetachIndex(indexrec.id);

    //Zap all contentsources - no need to slowly delete if we can just drop the index
    IF(Length(sources) > 0)
      DELETE FROM consilio.contentsources WHERE contentsources.catalogid = catalog->id;

    trans->CommitWork();

    //Now actually delete them. if we were to crash after the commit before completing, the next cleanupindices will pick it up
    FOREVERY(RECORD indexrec FROM indices)
      SendRawJSONToElasticSearch(indexrec.indexmanager,  "DELETE", indexrec.indexname || catalog->suffixmask, DEFAULT RECORD);

    CONTINUE;
  }

  FOREVERY (RECORD src FROM sources)
  {
    IF (debug)
    {
      STRING reference := src.tag != "" ? `${src.tag} (#${src.id})` : `#${src.id}`;
      Print(`  Checking content source ${reference}${src.isdeleted ? " deleted" : src.isorphan ? " orphaned" : ""}\n`);
    }
    IF (src.isdeleted)
    {
      // This content source is marked for deletion, delete it from the index manager, then from the database
      RECORD result := DeleteIndexManagerContentSource(0, cat.id, src.id);
      IF (debug)
        Print(`  Deleted content source: ${result.status}\n`);
      IF (result.status = SearchOk)
      {
        trans->BeginWork();
        DELETE FROM consilio.contentsources WHERE id = src.id;
        trans->CommitWork();
      }
      CONTINUE;
    }
    IF (src.isorphan)
      CONTINUE;

    // Update content source fields and titles
    trans->BeginWork();
    OBJECT source := catalog->OpenContentSourceById(src.id);
    TRY
    {
      //FIXME do we want/need this? who supplies GetContentSourceTitle, does it usefully change all the time?
      OBJECT provider := source->__OpenProvider();
      STRING title := provider->GetContentSourceTitle();
      IF (title != src.title)
        UPDATE consilio.contentsources SET title := VAR title WHERE id = src.id;
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      //TODO what to do? log, scream, go into error mode?
    }
    trans->CommitWork();
  }
}

IF (Length(updated_contentsources) > 0) //ADDME also fire something on eg priority change ?
{
  FOREVERY (INTEGER srcid FROM updated_contentsources)
  {
    BroadcastEvent("consilio:contentsource." || srcid, DEFAULT RECORD);
    OpenContentSourceById(srcid)->ReindexContentSource();
  }
  changes := TRUE;
}

IF (changes)
{
  BroadcastEvent("consilio:contentsourceschanged", DEFAULT RECORD);
}
