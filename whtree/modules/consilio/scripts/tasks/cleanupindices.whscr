<?wh

LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::consilio/lib/api.whlib";
LOADLIB "mod::consilio/lib/catalogs.whlib";
LOADLIB "mod::consilio/lib/database.whlib";
LOADLIB "mod::consilio/lib/contentproviders/contentprovider.whlib";
LOADLIB "mod::consilio/lib/internal/indexmanager.whlib";
LOADLIB "mod::consilio/lib/internal/elasticsearch.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/logging.whlib";


OBJECT trans := OpenPrimary();
INTEGER ARRAY updated_contentsources;
BOOLEAN changes;
BOOLEAN debug := "--debug" IN GetConsoleArguments();

// Delete indices from the index managers that are no longer referred to or are marked for deletion
RECORD old_indexmgr := SELECT id, name FROM consilio.indexmanagers WHERE address = "builtin";
IF(RecordExists(old_indexmgr)) //For these we keep the old loop
{
  RECORD result := GetIndexmanagerIndexList(old_indexmgr.id);
  IF (debug)
    Print(`Checking index manager ${old_indexmgr.id}: ${result.status}\n`);
  IF (result.status = SearchOk)
  {
    FOREVERY (RECORD indexrec FROM result.indices)
    {
      // Get the list of all catalogs + catalog indices for the indexid+indexname pair
      RECORD ARRAY cats :=
          SELECT catalogs.id
               , catalogs.name
               , catalogindexid :=        catalog_indexmanagers.id
            FROM consilio.catalogs
               , consilio.catalog_indexmanagers
           WHERE catalogs.id = indexrec.indexid
             AND catalog_indexmanagers.catalogid = catalogs.id
             AND catalog_indexmanagers.indexmanager = VAR old_indexmgr.id
             AND (indexrec.indexname = "" ? TRUE : indexname = indexrec.indexname);

      BOOLEAN none_found := IsDefaultValue(cats);
      BOOLEAN any_active := RecordExists(cats);

      IF (none_found)
      {
        STRING status := SearchOk;
        IF (NOT any_active)
        {
          result := DeleteIndexManagerIndex(old_indexmgr.id, indexrec.indexid, indexrec.indexname);
          IF (debug)
            Print(`  Deleted index ${indexrec.indexid} (name: ${EncodeJSON(indexrec.indexname)}) from index manager ${old_indexmgr.name}: ${result.status}\n`);
          status := result.status;
        }
        IF (result.status IN [ SearchOk, SearchIndexNotFound ])
        {
        }
        ELSE
        {
          PrintTo(2, `  Failed deleting index ${indexrec.indexid} (name: ${EncodeJSON(indexrec.indexname)}) from index manager ${old_indexmgr.name}: ${result.status}\n`);
          SetConsoleExitCode(1);
        }
      }
    }
  }
}

FOREVERY(RECORD indexmanager FROM SELECT * FROM ListIndexManagers() WHERE type = "opensearch" AND isbuiltin)
{
  //We garbage collect indexmanagers we fully control ourselves
  RECORD result := GetIndexmanagerIndexList(indexmanager.id);
  IF (debug)
    Print(`Checking index manager ${indexmanager.id}: ${result.status}\n`);
  IF (result.status != SearchOk)
    CONTINUE;

  STRING ARRAY expected_indices := SELECT AS STRING ARRAY indexname
                                     FROM consilio.catalog_indexmanagers
                                    WHERE catalog_indexmanagers.indexmanager = VAR indexmanager.id
                                 ORDER BY indexname;

  DELETE FROM result.indices WHERE BinaryFind(expected_indices, indexname) != -1;
  FOREVERY(RECORD toremove FROM result.indices)
  {
    IF(toremove.indexname NOT LIKE "c_*")  //definately not autocreated by us... let's leave it for the sysop to figure out
    {
      Print(`Index '${toremove.indexname}' appears to be unattached\n`);
      CONTINUE;
    }
    FOREVERY(STRING suffix FROM toremove.suffixes)
    {
      STRING msg := `Deleting unattached index '${toremove.indexname}' with suffix '${suffix}'`;
      LogDebug("consilio:cleanupindices", msg, CELL[ action := "delete", toremove.indexname, suffix ]);
      IF(debug)
        Print(msg || "\n");

      SendToElasticsearch(indexmanager.id, toremove.indexname || (suffix != "" ? "-" || suffix : "*"), "", DEFAULT RECORD, "DELETE", [ throwonfailure := TRUE ]);
    }
  }
}

RECORD ARRAY catalogs := ListConsilioCatalogs();
FOREVERY (RECORD cat FROM catalogs)
{
  IF (debug)
    Print(`Checking catalog '${cat.tag}' (${cat.id})\n`);

  // Open the catalog
  OBJECT catalog := OpenConsilioCatalogById(cat.id);
  IF(NOT ObjectExists(catalog) OR NOT catalog->managed)
    CONTINUE; //already gone..

  // Check the catalog's content sources
  RECORD ARRAY sources := catalog->ListContentSources([ __withdeleted := TRUE ]);
  FOREVERY (RECORD src FROM sources)
  {
    IF (debug)
      Print(`  Checking content source '${src.tag}' (${src.id})${src.isdeleted ? " deleted" : src.isorphan ? " orphaned" : ""}\n`);
    IF (src.isdeleted)
    {
      // This content source is marked for deletion, delete it from the index manager, then from the database
      RECORD result := DeleteIndexManagerContentSource(0, cat.id, src.id);
      IF (debug)
        Print(`  Deleted content source: ${result.status}\n`);
      IF (result.status = SearchOk)
      {
        trans->BeginWork();
        DELETE FROM consilio.contentsources WHERE id = src.id;
        trans->CommitWork();
      }
      CONTINUE;
    }
    IF (src.isorphan)
      CONTINUE;

    // Update content source fields and titles
    trans->BeginWork();
    OBJECT source := catalog->OpenContentSourceById(src.id);
    TRY
    {
      OBJECT provider := source->__OpenProvider();
      IF (provider->UpdateContentSourceFields().anychanges)
        INSERT src.id INTO updated_contentsources AT END;

      STRING title := provider->GetContentSourceTitle();
      IF (title != src.title)
        UPDATE consilio.contentsources SET title := VAR title WHERE id = src.id;
    }
    CATCH(OBJECT e)
    {
      LogHarescriptException(e);
      //TODO what to do? log, scream, go into error mode?
    }
    trans->CommitWork();
  }
}

IF (Length(updated_contentsources) > 0) //ADDME also fire something on eg priority change ?
{
  FOREVERY (INTEGER srcid FROM updated_contentsources)
  {
    BroadcastEvent("consilio:contentsource." || srcid, DEFAULT RECORD);
    OpenContentSourceById(srcid)->ReindexContentSource([ rebuild := TRUE ]);
  }
  changes := TRUE;
}

IF (changes)
{
  BroadcastEvent("consilio:contentsourceschanged", DEFAULT RECORD);
}
