<?wh

LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::publisher/lib/control.whlib";
LOADLIB "mod::publisher/lib/publisher.whlib";
LOADLIB "mod::publisher/lib/internal/tollium-helpers.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/services.whlib";
LOADLIB "mod::system/lib/webserver.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::system/lib/webserver/websocket.whlib";
LOADLIB "mod::system/lib/internal/whfs/support.whlib";


OBJECT assetpackcontroller;
STRING ARRAY bundlewatchlist;
OBJECT handler;
INTEGER watchfile;
BOOLEAN ispreview;
INTEGER resourcecb;
STRING ARRAY resourcelist;

OpenPrimary();

handler := CreateWebSocketHandler();
handler->ondata := PTR OnData;

SendPacket([ type := "greeting"
           , version := GetWebhareVersionNumber()
           ]);

RegisterMultiEventCallback("system:webhareservice.platform:assetpacks.start", PTR GotAssetpackControlRestart);
RegisterMultiEventCallback("platform:assetpackcontrol.update", PTR OnAssetPackChange);

handler->Run();

/// Returns the outputtag for the URL-name of an assetpack
STRING FUNCTION UnmapBundleUuid(STRING inuuid)
{
  IF(inuuid LIKE "*.*")
  {
    INTEGER dotpos := SearchSubstring(inuuid, '.');
    inuuid := Left(inuuid, dotpos) || ':' || Substring(inuuid, dotpos + 1);
  }
  RETURN inuuid;
}

// Assetpack controller died
MACRO GotLinkClose()
{
  assetpackcontroller := DEFAULT OBJECT;
  SendPacket([ type := "assetpack-missing" ]);
}

// Asset pack controller sent restart event, it is in the air again. Re-register assetpack watches with the new manager
MACRO GotAssetpackControlRestart(STRING event, RECORD ARRAY data)
{
  IF (ObjectExists(assetpackcontroller))
  {
    assetpackcontroller->CloseService();
    assetpackcontroller := DEFAULT OBJECT;
  }

  FOREVERY(STRING bundleuuid FROM bundlewatchlist)
    WatchAssetPack(bundleuuid);
}

MACRO SendPacket(RECORD data)
{
  handler->SendData(EncodeJSON(data, DEFAULT RECORD, [ typed := TRUE ]));
}

MACRO OnData(STRING datapacket)
{
  RECORD data := DecodeJSON(datapacket);
  SWITCH (data.type)
  {
    CASE "watchassetpack"
    {
      STRING bundleuuid := UnmapBundleUuid(data.uuid);
      IF(bundleuuid NOT IN bundlewatchlist)
      {
        INSERT bundleuuid INTO bundlewatchlist AT END;
        WatchAssetPack(bundleuuid);
      }
      RETURN;
    }
    CASE "watchurl"
    {
      WatchURL(data.url);
      RETURN;
    }
    CASE "watchresources"
    {
      WatchResources(STRING ARRAY(data.resources));
      RETURN;
    }
    CASE "recompileassetpack"
    {
      FOREVERY(STRING uuid FROM data.uuids)
        RecompileAssetpack(UnmapBundleUuid(uuid));
      RETURN;
    }
    CASE "republishfile"
    {
      RepublishFile(data.url);
      RETURN;
    }
  }
  ABORT(data);
}

BOOLEAN FUNCTION RequireAssetPackControlLink()
{
  IF (NOT ObjectExists(assetpackcontroller))
  {
    TRY
    {
      assetpackcontroller := WaitForPromise(OpenWebHareService("platform:assetpacks", [ arguments := VARIANT[ GetWebVariable("source") ]]));
      ScheduleCallbackOnServiceClose(assetpackcontroller, PTR GotLinkClose);
    }
    CATCH
      RETURN FALSE;
  }
  RETURN TRUE;
}

MACRO WatchAssetPack(STRING uuid)
{
  IF (RequireAssetPackControlLink())
    assetpackcontroller->WatchAssetPack(uuid);

  SendAssetPackStatus();
}

MACRO WatchResources(STRING ARRAY resources)
{
  resourcelist := resources;
  IF (resourcecb = 0)
    resourcecb := RegisterMultiEventCallback("system:modulefolder.mod::*", PTR OnResourceChange);
}

MACRO OnResourceChange(STRING event, RECORD ARRAY data)
{
  FOREVERY (RECORD rec FROM data)
    IF (CellExists(rec, "resourcename") AND TypeID(rec.resourcename) = TypeID(STRING) AND rec.resourcename IN resourcelist)
    {
      IF (resourcecb != 0)
      {
        UnregisterCallback(resourcecb);
        resourcecb := 0;
        SendPacket([ type := "resource-change" ]);
      }
    }
}

MACRO WatchURL(STRING url)
{
  RECORD res := LookupPublisherURL(url);
  IF (RecordExists(res) AND res.file != 0)
  {
    watchfile := res.file;
    ispreview := res.ispreview;
    IF(NOT ispreview)
    {
      RegisterMultiEventCallback("system:whfs.folder." || res.folder, PTR OnFolderChange);
      RegisterMultiEventCallback("publisher:publish.folder." || res.folder, PTR OnFolderChange);
    }
  }

  SendFileStatus();
}

MACRO RepublishFile(STRING url)
{
  RECORD res := LookupPublisherURL(url);
  IF (RecordExists(res) AND res.file != 0)
  {
    GetPrimary()->BeginWork();
    ScheduleFileRepublish(res.file);
    GetPrimary()->CommitWork();
  }

  SendFileStatus();
}


MACRO RecompileAssetpack(STRING uuid)
{
  IF (NOT RequireAssetPackControlLink())
    RETURN;
  WaitForPromise(assetpackcontroller->RecompileBundle(uuid));
}

MACRO OnAssetPackChange(STRING event, RECORD ARRAY events)
{
  SendAssetPackStatus();
}

MACRO SendAssetPackStatus()
{
  IF (NOT RequireAssetPackControlLink())
    RETURN;

  RECORD ARRAY packs;
  FOREVERY(STRING bundleuuid FROM bundlewatchlist) {
     TRY {
      RECORD status := WaitForPromise(assetpackcontroller->GetBundleStatus(bundleuuid));
      IF (NOT RecordExists(status))
        INSERT CELL [ outputtag := bundleuuid, getstatuserror := "missing" ] INTO packs AT END;
      ELSE
        INSERT CELL [ getstatuserror := "", ...status] INTO packs AT END;
     } CATCH(OBJECT e) {
      INSERT CELL[ outputtag := bundleuuid, getstatuserror := e->what ] INTO packs AT END;
     }
  }

  SendPacket(CELL[ type := "assetpacks", packs ]);
}

MACRO OnFolderChange(STRING event, RECORD ARRAY events)
{
  BOOLEAN changed;
  FOREVERY (RECORD eventdata FROM events)
  {
    IF (LENGTH(eventdata.events) != 0)
      changed := TRUE;

    RECORD pos := RecordLowerBound(eventdata.files, [ file := watchfile ], [ "FILE" ]);
    IF (pos.found)
      changed := TRUE;
  }

  IF (changed)
    SendFileStatus();
}

MACRO SendFileStatus()
{
  RECORD fileinfo :=
      SELECT *
        FROM system.fs_objects
       WHERE id = watchfile;

  IF (NOT RecordExists(fileinfo) OR NOT fileinfo.isactive)
  {
    SendPacket( [ type := "file"
                , hasfile := watchfile != 0
                , isdeleted := TRUE
                , ispublishing := FALSE
                , haserrors := FALSE
                , errors := ""
                , ispreview := ispreview
                ]);
    RETURN;
  }

  BOOLEAN haserrors, haswarnings;
  STRING message;
  IF(NOT ispreview)
  {
    INTEGER errorcode := GetErrorFromPublished(fileinfo.published);
    IF(errorcode>100)
    {
      haserrors := TRUE;
      message := GetPublicationErrorMsg(fileinfo.published, fileinfo.errordata); //ADDME Gettid-dy me!
    }
    ELSE IF(TestFlagFromPublished(fileinfo.published, 400000)) //warnings
    {
      haswarnings := TRUE;
      RECORD errorinfo := OpenWHFSType("http://www.webhare.net/xmlns/publisher/errorinfo")->GetInstanceData(watchfile);
      STRING ARRAY warnings := SELECT AS STRING ARRAY param1 FROM errorinfo.messages;
      message := Detokenize(warnings,'\n');
    }

    // error was an ABORT or Harescript error?
    IF(errorcode IN [101,102])
    {
      STRING detailtext;
      RECORD errorinfo := OpenWHFSType("http://www.webhare.net/xmlns/publisher/errorinfo")->GetInstanceData(watchfile);

      IF(Length(errorinfo.messages)>0)
      {
        detailtext := "Error/warning messages:\n";
        FOREVERY(RECORD msg FROM errorinfo.messages)
        {
          IF(msg.type NOT IN [0,1]) //only get true warnings/errors
            CONTINUE;
          detailtext := detailtext || msg.filename || " (" || msg.line || "," || msg.col || "):" || GetHareScriptMessageText(msg.type=0, msg.code, msg.param1, msg.param2) || "\n";
        }
      }
      IF(Length(errorinfo.trace)>0)
      {
        IF(detailtext!="")
          detailtext := detailtext || "\nError trace:\n";
        FOREVERY(RECORD msg FROM errorinfo.trace)
        {
          detailtext := detailtext || msg.filename || " " || msg.func || " (" || msg.line || "," || msg.col || ")\n";
        }
      }

      message := message || "\n" || detailtext;
    }
  }

  SendPacket( [ type := "file"
              , hasfile := watchfile != 0
              , isdeleted := FALSE
              , ispublishing := IsQueuedForPublication(fileinfo.published)
              , haserrors := haserrors
              , haswarnings := haswarnings
              , message := message
              , ispreview := ispreview
              ]);
}
