<?wh

/** This library contains the code for manipulating modules on the server.
*/

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::filetypes/archiving.whlib";
LOADLIB "wh::xml/dom.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/internal/resourcemanager.whlib";
LOADLIB "mod::system/lib/internal/moduledefparser.whlib";
LOADLIB "mod::system/lib/internal/whcore_interface.whlib";
LOADLIB "mod::system/lib/internal/moduleimexport.whlib";

LOADLIB "mod::devkit/lib/internal/deploy/git.whlib";




STRING FUNCTION RemoveFirstPathElement(STRING fullpath)
{
  INTEGER pos := SearchSubstring(fullpath, "/");
  IF (pos = 0) // Compensate for '/modulename/blabla', just in case
  {
    fullpath := SubString(fullpath, pos + 1);
    pos := SearchSubstring(fullpath, "/");
  }
  IF (pos = -1)
    RETURN "";
  RETURN SubString(fullpath, pos + 1);
}


/** Returns revision information for all modules in source control
    @return List of modules
    @cell return.
*/
PUBLIC RECORD ARRAY FUNCTION GetRevisionOfAllModulesDev()
{
  RECORD ARRAY results;

  RECORD ARRAY potentialfolders;
  FOREVERY (STRING modulesdir FROM GetWebHareConfiguration().moduledirs)
  {
    FOREVERY (RECORD rec FROM SELECT * FROM ReadDiskDirectory(modulesdir, "*") WHERE type = 1)
    {
      IF (RecordExists(GetDiskFileProperties(MergePath(rec.path, "moduledefinition.xml"))))
        INSERT rec INTO potentialfolders AT END;
      ELSE //assume it to be a subdir with modules
        potentialfolders := potentialfolders CONCAT SELECT * FROM ReadDiskDirectory(rec.path, "*") WHERE type = 1;
    }
  }
  FOREVERY(RECORD potential FROM potentialfolders)
  {
    RECORD mod := GetRevisionOfGitModule(potential.path);
    IF(RecordExists(mod))
      INSERT mod INTO results AT END;
  }

  RETURN results;
}

/** Get revision information for a single module
    @return Module data, if found
*/
PUBLIC RECORD FUNCTION GetRevisionOfSingleModuleDev(STRING modulename)
{
  RETURN GetRevisionOfGitModule(GetModuleInstallationRoot(modulename));
}


/** Return list of modules within a GIT repo root
    @param modulepath Repo root
    @cell return.name Module name
    @cell return.type Source control type (always "git")
    @cell return.revision SHA of the HEAD for the current repo
    @cell return.localremoterevision Current view of the the SHA of the branch HEAD at the remote origin
    @cell return.repository_url URL of the remote
    @cell return.branch Name of the current branch (eg. "master")
    @cell return.files List of modified files
    @cell return.files.fullpath
    @cell return.files.status One of "changed" / "problematic" /  "deleted" / "added";
    @cell return.commit List of most recent commits
    @cell return.commit.id SHA of the commit
    @cell return.commit.date Date of the commit
*/
RECORD FUNCTION GetRevisionOfGitModule(STRING modulepath)
{
  IF (NOT RecordExists(GetDiskFileProperties(MergePath(modulepath, "moduledefinition.xml"))))
    RETURN DEFAULT RECORD;
  IF (NOT RecordExists(GetDiskFileProperties(MergePath(modulepath, ".git"))))
    RETURN DEFAULT RECORD;

  IF (modulepath NOT LIKE "*/")
    modulepath := modulepath || "/";

  STRING name := GetNameFromPath(Left(modulepath, LENGTH(modulepath) - 1));
  RECORD data := AnalyzeGITModuleDir(modulepath, TRUE, FALSE);

  IF(NOT RecordExists(data))
    RETURN DEFAULT RECORD;

  RETURN CELL[ name :=   name
             , type :=   "git"
             , ...data
             ];
}

RECORD FUNCTION CreateModuleManifest(STRING module, STRING modulepath, STRING login, STRING fullname, RECORD ARRAY filehashes, FUNCTION PTR testinclude, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  options := ValidateOptions(
      [ ignoremodifications :=  FALSE
      ], options);

  DATETIME now := GetCurrentDateTime();

  BLOB existing_manifest_data;

  IF (NOT options.ignoremodifications)
    existing_manifest_data := GetDiskResource(MergePath(modulepath, "history/manifest.xml"), [ allowmissing := TRUE ]);

  OBJECT doc;
  OBJECT xml_history;
  OBJECT xml_files;

  RECORD ARRAY files;

  IF (LENGTH(existing_manifest_data) != 0)
  {
    doc := MakeXMLDocument(existing_manifest_data);

    OBJECT query := doc->CreateXPathQuery();
    query->RegisterNamespace("mnf", xmlns_module_manifest);

    OBJECT ARRAY histories := query->ExecuteQuery("//mnf:manifest/mnf:history")->GetCurrentElements();
    IF (LENGTH(histories) > 0)
      xml_history := histories[0];

    OBJECT ARRAY fileses := query->ExecuteQuery("//mnf:manifest/mnf:sourcefiles")->GetCurrentElements();
    IF (LENGTH(fileses) > 0)
      xml_files := fileses[0];
  }
  ELSE
  {
    OBJECT domimpl := NEW XMLDomImplementation;
    doc := domimpl->CreateDocument("http://www.webhare.net/module-manifest/", "manifest", DEFAULT OBJECT);
    doc->documentelement->SetAttributeNS("http://www.w3.org/2000/xmlns/", "xmlns", "http://www.webhare.net/module-manifest/");
  }

  IF (NOT ObjectExists(xml_files))
  {
    xml_files := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "sourcefiles");
    doc->documentelement->AppendChild(xml_files);
  }
  ELSE
  {
    WHILE (ObjectExists(xml_files->firstchild))
      xml_files->RemoveChild(xml_files->firstchild);
  }

  FOREVERY (RECORD hash FROM SELECT * FROM filehashes ORDER BY path)
  {
    OBJECT file := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "file");
    file->SetAttribute("path", RemoveFirstPathElement(hash.path));
    file->SetAttribute("sha1hash", ToLowercase(EncodeBase16(hash.sha1hash)));
    xml_files->AppendChild(file);
  }

  IF (NOT ObjectExists(xml_history))
  {
    xml_history := doc->CreateElementNS("http://www.webhare.net/module-manifest/", "history");
    doc->documentelement->AppendChild(xml_history);
  }

  BOOLEAN first_changeset := LENGTH(xml_history->childnodes->GetCurrentElements()) = 0;

  OBJECT xml_changeset := doc->CreateElementNS(xmlns_module_manifest, "changeset");
  xml_history->AppendChild(xml_changeset);

  xml_changeset->SetAttribute("date", FormatISO8601DateTime(now, "", "", "", TRUE));
  xml_changeset->SetAttribute("server", GetServerName());

  IF (login != "")
    xml_changeset->SetAttribute("userlogin", login);
  IF (fullname != "")
    xml_changeset->SetAttribute("userfullname", fullname);

  // Add modified files & source of modified files if present
  OBJECT xml_modifications := doc->CreateElementNS(xmlns_module_manifest, "modifications");
  xml_changeset->AppendChild(xml_modifications);

  // Add list of incorporated commits
  OBJECT xml_commits := doc->CreateElementNS(xmlns_module_manifest, "commits");
  xml_changeset->AppendChild(xml_commits);

  BOOLEAN is_git;
  STRING revision;

  IF (NOT first_changeset)
  {
    xml_changeset->SetAttribute("source", "download");
  }
  ELSE
  {
    xml_changeset->SetAttribute("source", "local");

    RECORD gitdirdata := GetDiskFileProperties(MergePath(modulepath, ".git"));

    IF (RecordExists(gitdirdata))
    {
      RECORD md := AnalyzeGITModuleDir(modulepath, TRUE, TRUE);
      IF (RecordExists(md))
      {
        is_git := TRUE;

        xml_changeset->SetAttribute("source", "git");
        xml_changeset->SetAttribute("sourcerepositoryurl", md.repository_url || "\t" || md.branch);
        xml_changeset->SetAttribute("sourcerepositoryuuid", md.repository_url);
        xml_changeset->SetAttribute("sourcerevision", md.revision);
        xml_changeset->SetAttribute("sourcelocalremoterevision", md.localremoterevision);

        FOREVERY (RECORD rec FROM md.files)
        {
          INTEGER spos := SearchLastSubString(rec.fullpath, "/");
          IF (testinclude != DEFAULT FUNCTION PTR AND NOT testinclude(
                Left(rec.fullpath, spos + 1),
                [ name := SubString(rec.fullpath, spos + 1)
                ]))
            CONTINUE;

          OBJECT xml_file := doc->CreateElementNS(xmlns_module_manifest, "file");
          xml_modifications->AppendChild(xml_file);

          xml_file->SetAttribute("path", rec.fullpath);
          // xml_file->SetAttribute("status", rec.status);
        }

        FOREVERY (RECORD rec FROM md.commits)
        {
          OBJECT xml_commit := doc->CreateElementNS(xmlns_module_manifest, "commit");
          xml_commits->AppendChild(xml_commit);

          xml_commit->SetAttribute("id", rec.id);
          xml_commit->SetAttribute("date", FormatISO8601DateTime(rec.date, "", "milliseconds"));
        }
      }
    }
  }

  IF (NOT is_git AND NOT options.ignoremodifications)
  {
    RECORD mods := GetModuleModifiedFiles(module, modulepath, TRUE); //FIXME why do we need this? do we? shouldn't we just require git?

    RECORD ARRAY modified_files;
    IF (mods.success)
    {
      FOREVERY (RECORD mod FROM mods.files)
      {
        INTEGER spos := SearchLastSubString(mod.path, "/");
        IF (testinclude != DEFAULT FUNCTION PTR AND NOT testinclude(
              Left(mod.path, spos),
              [ name := SubString(mod.path, spos + 1)
              ]))
          CONTINUE;

        INSERT mod INTO modified_files AT END;
      }
    }

    IF (LENGTH(modified_files) != 0)
    {
      OBJECT archive := CreateNewArchive("zip");
      FOREVERY (RECORD mod FROM modified_files)
      {
        IF (mod.status != "added")
          archive->AddFile(mod.path, mod.source_data, mod.source_modtime);

        OBJECT xml_file := doc->CreateElementNS(xmlns_module_manifest, "file");
        xml_modifications->AppendChild(xml_file);

        xml_file->SetAttribute("path", mod.path);
        xml_file->SetAttribute("status", mod.status);
      }

      STRING archivename := "source-" || FormatISO8601DateTime(now, "", "milliseconds", "", FALSE) || ".zip";
      STRING sourcepath := "history/" || archivename;

      INSERT [ fullpath := sourcepath, data := archive->MakeBlob(), modtime := now ] INTO files AT END;

      xml_modifications->SetAttribute("originalsarchive", sourcepath);
      archive->Close();
    }
  }

  doc->NormalizeDocument();

  INSERT [ fullpath := "history/manifest.xml", data := doc->GetDocumentBlob(FALSE), modtime := now ] INTO files AT END;

  RETURN
      [ manifest :=  ParseModuleManifest(doc)
      , files :=     files
      ];
}

// Creates module archives
PUBLIC STATIC OBJECTTYPE DevModuleArchiver
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  STRING pvt_archivetype;

  STRING ARRAY pvt_defaultnopackagemasks;
  STRING ARRAY pvt_defaultnopackagepathmasks;

  /// Mask of files not to package, in uppercase
  STRING ARRAY pvt_nopackagemasks;
  /// Mask of paths not to package, in uppercase
  STRING ARRAY pvt_nopackagepathmasks;

  BOOLEAN pvt_disablechecks;

  STRING pvt_archivecomment;

  STRING pvt_userlogin;

  STRING pvt_userfullname;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /// Contenttype of generated archive, allowed: "application/x-gzip", "application/zip"
  PROPERTY archivetype(pvt_archivetype, pvt_archivetype);

  /// List of mask of files that will be ignored
  PROPERTY defaultnopackagemasks(pvt_defaultnopackagemasks, pvt_defaultnopackagemasks);

  /// If TRUE, disable checks for conflicts, packagingdownload.
  PROPERTY disablechecks(pvt_disablechecks, pvt_disablechecks);

  /// Comment to put in the archive
  PROPERTY archivecomment(pvt_archivecomment, pvt_archivecomment);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    this->pvt_archivetype := "zip";
    this->pvt_defaultnopackagemasks := [ "CVS", ".svn", ".git", ".DS_Store" ];
    this->pvt_defaultnopackagepathmasks :=
        [ "tests", "history/source.zip", "history/manifest.xml", "web/resources/tests", "include/tests", "screens/tests"
        , "tsconfig.json", ".vscode", ".nova"
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  /** Return contents of a directory, auto-filters '.' and '..'.
      @param dir Directory
      @param mask Mask
      @return
      @cell return.name Entry name
      @cell return.type 0 = file, 1 = dir
      @cell return.modified Modtime
  */
  RECORD ARRAY FUNCTION GetDirectory(STRING dir, STRING mask)
  {
    RECORD ARRAY entries := ReadDiskDirectory(dir, mask);

    RETURN
        SELECT name
             , type
             , modified
          FROM entries;
  }

  /** Check filenames for strange stuff. Throw on stuff that really may not be there.
      @param entry File Entry
      @cell entry.name
      @cell entry.type
      @cell entry.modified
      @return Whether to include the file
  */
  BOOLEAN FUNCTION TestIncludeFile(STRING path, RECORD entry)
  {
    // Check for packaging excludes
    FOREVERY(STRING nopackage FROM this->pvt_nopackagemasks) // Already uppercase
      IF (ToUppercase(entry.name) LIKE nopackage)
        RETURN FALSE;

    STRING ufullpath := ToUppercase(path||entry.name);
    FOREVERY(STRING nopackage FROM this->pvt_nopackagepathmasks) // Already uppercase
      IF (ufullpath LIKE nopackage OR ufullpath LIKE nopackage||"/*")
        RETURN FALSE;

    RETURN TRUE;
  }

  /** Recursively add files and folders to the archive
      @param archive
      @param initialdir Folder with the module to pack
      @param curdir Current folder within the module
      @param modulename Name of the module
  */
  RECORD ARRAY FUNCTION RecurseAddFiles(OBJECT archive, STRING initialdir, STRING curdir, STRING modulename)
  {
    RECORD ARRAY entries := this->GetDirectory(initialdir || curdir, "*");
    RECORD ARRAY hashes;
    FOREVERY (RECORD entry FROM entries)
    {
      IF (NOT this->TestIncludeFile(curdir, entry))
        CONTINUE;

      STRING storename := modulename || "/" || curdir || entry.name;

      IF(entry.type=0)//file
      {
        BLOB diskfile := GetDiskResource(initialdir || curdir || entry.name);

        IF(ToUppercase(entry.name) NOT LIKE "*.PDF")
        {
          STRING header := BlobToString(diskfile,8000);
          IF(SearchSubstring(header, '\0') < 0) //looks like text (like git buffer_is_binary check the first 8000 bytes for a NUL)
            IF(SearchSubstring(header,'\r\n') >= 0) //then convert CRLF to LF if present
              diskfile := StringToBlob(Substitute(BlobToString(diskfile), '\r\n', '\n'));
        }

        INSERT
            [ path :=       storename
            , sha1hash :=   GetHashForBlob(diskfile, "SHA-1")
            ] INTO hashes AT END;

        archive->AddFile(storename, diskfile, entry.modified);
      }
      ELSE IF(entry.type=1) //dir
      {
        archive->AddFolder(storename, entry.modified);
        hashes := hashes CONCAT this->RecurseAddFiles(archive, initialdir, curdir || entry.name || "/", modulename);
      }
    }
    RETURN hashes;
  }

  /** Create an archive from a module
      @param path Path to module data
      @param module Name of the module
      @param moduleinfo Module info
      @return
      @cell(blob) return.data Archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest Manifest data
  */
  RECORD FUNCTION CreateArchiveFromInfo(STRING path, STRING module, RECORD moduleinfo)
  {
    // Calculate the nopackage masks
    this->pvt_nopackagemasks :=
        SELECT AS STRING ARRAY DISTINCT ToUppercase(mask)
          FROM ToRecordArray(this->pvt_defaultnopackagemasks CONCAT moduleinfo.packagingnopackmask, "MASK");

    this->pvt_nopackagepathmasks :=
        SELECT AS STRING ARRAY DISTINCT ToUppercase(mask)
          FROM ToRecordArray(this->pvt_defaultnopackagepathmasks CONCAT moduleinfo.packagingnopackpathmask, "MASK");

    // Create the archive, set comment and add the files
    OBJECT archive := CreateNewArchive(this->pvt_archivetype);
    archive->archivecomment := this->pvt_archivecomment;

    RECORD ARRAY hashes := this->RecurseAddFiles(archive, path, "", module);

    IF (NOT RecordExists(SELECT FROM archive->entries WHERE fullpath = MergePath(module, "history")))
      archive->AddFolder(MergePath(module, "history"), GetCurrentDateTime());

    RECORD manifestdata := CreateModuleManifest(module, path, this->pvt_userlogin, this->pvt_userfullname, hashes, PTR this->TestIncludeFile);
    FOREVERY (RECORD file FROM manifestdata.files)
      archive->AddFile(MergePath(module, file.fullpath), file.data, file.modtime);

    // Get the data, close the archive and we're done
    BLOB data := archive->MakeBlob();
    archive->Close();

    RETURN
        [ data :=           data
        , fullversion :=    GetFullModuleVersion(moduleinfo, manifestdata.manifest)
        , manifest :=       manifestdata.manifest
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Private public API
  //

  PUBLIC RECORD ARRAY FUNCTION __GetSystemModuleManifestFiles(STRING path, STRING module)
  {
    this->pvt_nopackagemasks := STRING[];
    this->pvt_nopackagepathmasks := [ "HISTORY/SOURCE.ZIP", "HISTORY/MANIFEST.XML" ];

    // Create the source archive
    OBJECT archive := CreateNewArchive("zip");
    RECORD ARRAY hashes := this->RecurseAddFiles(archive, path, "", module);

    IF (NOT RecordExists(SELECT FROM archive->entries WHERE fullpath = MergePath(module, "history")))
      archive->AddFolder(MergePath(module, "history"), GetCurrentDateTime());

    RECORD manifestdata := CreateModuleManifest(module, path, this->pvt_userlogin, this->pvt_userfullname, hashes, PTR this->TestIncludeFile, [ ignoremodifications := TRUE ]);
    FOREVERY (RECORD file FROM manifestdata.files)
      archive->AddFile(MergePath(module, file.fullpath), file.data, file.modtime);

    // Get the data, close the archive and we're done
    BLOB data := archive->MakeBlob();
    archive->Close();

    RETURN manifestdata.files CONCAT
        [ [ data :=       data
          , fullpath :=   "history/source.zip"
          , modtime :=    manifestdata.files[0].modtime
          ]
        ];
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Set data about the current user (included in generated archives)
      @param login Login name
      @param fullname Full name
  */
  PUBLIC MACRO SetUserData(STRING login, STRING fullname)
  {
    this->pvt_userlogin := login;
    this->pvt_userfullname := fullname;
  }

  /** Create an archive of a module
      @param module Name of the module
      @return
      @cell(blob) return.data Module archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest
  */
  PUBLIC RECORD FUNCTION CreateArchive(STRING module)
  {
    RECORD moduleinfo := SELECT * FROM GetWebHareModules() WHERE name = module;

    IF (NOT RecordExists(moduleinfo))
      THROW NEW Exception(`No such module: ${module}`);

    IF (NOT this->pvt_disablechecks AND NOT moduleinfo.packagingdownload)
      THROW NEW Exception(`Module '${module}' may not be packaged`);

    RETURN this->CreateArchiveFromInfo(GetModuleInstallationRoot(module), module, moduleinfo);
  }


  /** Create an archive of a historic module version
      @param path Path of the module
      @param module Name of the module
      @return
      @cell(blob) return.data Module archive blob
      @cell(string) return.fullversion
      @cell(record) return.manifest
  */
  PUBLIC RECORD FUNCTION CreateArchiveFromVersion(STRING path, STRING module)
  {
    IF (path NOT LIKE "*/")
      path := path || "/";

    BLOB moduledefdata := GetDiskResource(path || "moduledefinition.xml");
    RECORD moduledef := ParseModuleDefinition(module, MakeXMLDocument(moduledefdata));

    RETURN this->CreateArchiveFromInfo(path, module, moduledef);
  }
>;



PUBLIC RECORD FUNCTION AnalyzeGITModuleDir(STRING modulepath, BOOLEAN with_commits, BOOLEAN with_fetch)
{
  RECORD result :=
      [ revision :=                   ""
      , localremoterevision :=        ""
      , repository_url :=             ""
      , files :=                      DEFAULT RECORD ARRAY
      , branch :=                     ""
      , commits :=                    DEFAULT RECORD ARRAY
      ];

  //make sure we're up to date
  IF(with_fetch)
    ExecuteDevGitCommand(modulepath, ["fetch"]);

  RECORD status := DescribeGitRepo(modulepath, FALSE); //TODO don't grab commits if not requested
  IF (status.status != "ok")
    RETURN DEFAULT RECORD;

  TRY
  {
    result.revision := status.head_oid;
    result.localremoterevision := status.origin_oid;
    result.repository_url := status.remote_url;
    result.branch := status.branch;

    FOREVERY (RECORD file FROM RECORD ARRAY(status.paths))
    {
      INSERT
          [ fullpath :=   file.path
          // , status :=     Detokenize(file.status, " ")
          // , repostatus := ""
          ] INTO result.files AT END;
    }

    IF (with_commits)
      result.commits := RECORD ARRAY(status.commits);

    RETURN result;
  }
  CATCH (OBJECT e)
  {
    RETURN DEFAULT RECORD;
  }
}
