<?wh
LOADLIB "wh::float.whlib";
LOADLIB "wh::money.whlib";
LOADLIB "wh::util/geo.whlib" EXPORT ConvertFromLatLng, ConvertToLatLng;

/*
RD to WGS84 conversion functionality is based on rd2wgs by Ejo Schrama <schrama@geo.tudelft.nl>, more information at
http://ejos.blogspot.com/2005/11/rd2wgs-and-semi-automatic-code.html, download from ftp://ocean.lr.tudelft.nl/ejo/rd2wgs

Overlay clustering and pixel distance calculation are based on the artice "Introduction to Marker Clustering With Google
Maps", located at http://www.appelsiini.net/2008/11/introduction-to-marker-clustering-with-google-maps

Base64 encoding/decoding of INTEGER and FLOAT values is based on the algorithm as outlined in "Encoding Polyline Algorithm
Format", located at http://code.google.com/apis/maps/documentation/polylinealgorithm.html
*/


// Restrict a value to the range [-range,+range]
FLOAT FUNCTION RestrictTo(FLOAT value, FLOAT range)
{
  // Modulate the value by twice the range
  FLOAT mod := 2 * range;
  value := FMod(value, mod);

  // If the the new value is outside the requested range, move it into the range
  IF (value > range)
    value := value - mod;
  ELSE IF (value < -range)
    value := value + mod;

  RETURN value;
}

// Compare two floats for equality within a certain margin
BOOLEAN FUNCTION EqualFloat(FLOAT a, FLOAT b)
{
  // We assume two floats are the same if they don't differ in the first six decimals (which in terms of degrees latitude
  // and longitude corresponds to about 11 centimeters)
  RETURN Abs(a - b) < 0.000001;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Base Google Maps objects used by support functions (and exported again by maps-v3.whlib)
//

/** The Google GLatLng object in HareScript.
    See http://code.google.com/apis/maps/documentation/reference.html#GLatLng
*/
PUBLIC OBJECTTYPE GLatLng
< FLOAT pvt_lat;
  FLOAT pvt_lng;

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.lat
  */
  PUBLIC PROPERTY lat(pvt_lat, -);
  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.lng
  */
  PUBLIC PROPERTY lng(pvt_lng, -);

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.GLatLng
  */
  MACRO NEW (FLOAT lat, FLOAT lng, BOOLEAN unbounded DEFAULTSTO FALSE)
  {
    IF (NOT unbounded)
    {
      // Restrict latitude to [-90,+90]
      lat := RestrictTo(lat, 90);
      // Restrict longitude to [-180,+180]
      lng := RestrictTo(lng, 180);
    }

    this->pvt_lat := lat;
    this->pvt_lng := lng;
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.latRadians
  */
  PUBLIC FLOAT FUNCTION LatRadians()
  {
    RETURN DegreesToRadians(this->lat);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.lngRadians
  */
  PUBLIC FLOAT FUNCTION LngRadians()
  {
    RETURN DegreesToRadians(this->lng);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.equals
  */
  PUBLIC BOOLEAN FUNCTION Equals(OBJECT other)
  {
    RETURN ObjectExists(other) AND EqualFloat(this->lat, other->lat) AND EqualFloat(this->lng, this->lng);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.distanceFrom
  */
  PUBLIC FLOAT FUNCTION DistanceFrom(OBJECT other, FLOAT radius DEFAULTSTO 6378.137)
  {
    IF (NOT ObjectExists(other))
      RETURN 0;

    RETURN GetLatLngDistance([ lat := this->lat, lng := this->lng ], [ lat := other->lat, lng := other->lng ], CELL[radius]);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLng.toUrlValue
  */
  PUBLIC STRING FUNCTION ToUrlValue(INTEGER precision DEFAULTSTO 6)
  {
    RETURN FormatFloat(this->lat, precision) || "," || FormatFloat(this->lng, precision);
  }

  /** HareScript extension: Creates a [ FLOAT lat, FLOAT lng ] record for this GLatLng object.
  */
  PUBLIC RECORD FUNCTION ToRecord()
  {
    RETURN [ lat := this->pvt_lat
           , lng := this->pvt_lng
           ];
  }
>;

/** The Google GLatLngBounds object in HareScript.
    See http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds
*/
PUBLIC OBJECTTYPE GLatLngBounds
< FLOAT sw_lat;
  FLOAT sw_lng;
  FLOAT ne_lat;
  FLOAT ne_lng;

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.GLatLngBounds
  */
  MACRO NEW (OBJECT sw, OBJECT ne)
  {
    IF (ObjectExists(sw))
    {
      this->sw_lat := sw->lat;
      this->sw_lng := sw->lng;
    }
    IF (ObjectExists(ne))
    {
      this->ne_lat := ne->lat;
      this->ne_lng := ne->lng;
    }

    // Restrict latitudes to [-90,+90]
    this->sw_lat := RestrictTo(this->sw_lat, 90);
    this->ne_lat := RestrictTo(this->ne_lat, 90);
    // Restrict longitudes to [-180,+180]
    this->sw_lng := RestrictTo(this->sw_lng, 180);
    this->ne_lng := RestrictTo(this->ne_lng, 180);

    // If the south point is located north of the north point, switch the points vertically
    IF (this->sw_lat > this->ne_lat)
    {
      FLOAT lat := this->sw_lat;
      this->sw_lat := this->ne_lat;
      this->ne_lat := lat;
    }

    // If the west point is located east of the east point, subtract 360 degrees to move it to the west side of the west point
    // (creating a point from coordinates normalizes the coordinates again)
    IF (this->sw_lng > this->ne_lng)
      this->sw_lng := this->sw_lng - 360;
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.equals
  */
  PUBLIC BOOLEAN FUNCTION Equals(OBJECT other)
  {
    RETURN ObjectExists(other)
      AND this->GetSouthWest()->Equals(other->GetSouthWest())
      AND this->GetNorthEast()->Equals(other->GetNorthEast());
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.containsLatLng
  */
  PUBLIC BOOLEAN FUNCTION ContainsLatLng(OBJECT latlng)
  {
    IF (NOT ObjectExists(latlng))
      RETURN FALSE;

    // If our west point is located east of the east point, subtract 360 degrees from the point's longitude
    FLOAT pointlng := latlng->lng;
    IF (this->sw_lng < -180)
      pointlng := pointlng - 360;

    RETURN latlng->lat >= this->sw_lat AND latlng->lat <= this->ne_lat
      AND pointlng >= this->sw_lng AND pointlng <= this->ne_lng;
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.intersects
  */
  PUBLIC BOOLEAN FUNCTION Intersects(OBJECT other)
  {
    return false;//ADDME: Implement
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.containsBounds
  */
  PUBLIC BOOLEAN FUNCTION ContainsBounds(OBJECT other)
  {
    IF (NOT ObjectExists(other))
      RETURN FALSE;

    RETURN this->ContainsLatLng(other->GetSouthWest())
      AND this->ContainsLatLng(other->GetNorthEast());
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.extend
  */
  PUBLIC MACRO Extend_(OBJECT latlng)
  {
    // Check if we already contain this point
    IF (this->ContainsLatLng(latlng))
      RETURN;

    //ADDME: Implement
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.getSouthWest
  */
  PUBLIC OBJECT FUNCTION GetSouthWest()
  {
    RETURN NEW GLatLng(this->sw_lat, this->sw_lng);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.getNorthEast
  */
  PUBLIC OBJECT FUNCTION GetNorthEast()
  {
    RETURN NEW GLatLng(this->ne_lat, this->ne_lng);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.toSpan
  */
  PUBLIC OBJECT FUNCTION ToSpan()
  {
    RETURN NEW GLatLng((this->ne_lat - this->sw_lat), (this->ne_lng - this->sw_lng));
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.isFullLat
  */
  PUBLIC BOOLEAN FUNCTION IsFullLat()
  {
    RETURN EqualFloat(this->sw_lat, -90) AND EqualFloat(this->ne_lat, 90);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.isFullLng
  */
  PUBLIC BOOLEAN FUNCTION IsFullLng()
  {
    RETURN EqualFloat(this->sw_lng, -180) AND EqualFloat(this->ne_lng, 180);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.isEmpty
  */
  PUBLIC BOOLEAN FUNCTION IsEmpty()
  {
    RETURN EqualFloat(this->sw_lat, this->ne_lat) AND EqualFloat(this->sw_lng, this->ne_lng);
  }

  /** http://code.google.com/apis/maps/documentation/reference.html#GLatLngBounds.getCenter
  */
  PUBLIC OBJECT FUNCTION GetCenter()
  {
    RETURN NEW GLatLng((this->sw_lat + this->ne_lat) / 2, (this->sw_lng + this->ne_lng) / 2);
  }

  /** HareScript extension: Creates a [ RECORD sw, RECORD ne ] record containing two [ FLOAT lat, FLOAT lng ] records for
      the south-west and north-east corners of this GLatLngBounds object.
      @see GLatLng->ToRecord
  */
  PUBLIC RECORD FUNCTION ToRecord()
  {
    RETURN [ sw := this->GetSouthWest()->ToRecord()
           , ne := this->GetNorthEast()->ToRecord()
           ];
  }
>;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Base64 encoding/decoding helper functions
//

STRING FUNCTION EncodeBase64Money(MONEY value)
{
  INTEGER intval := MoneyToInteger(value * 100000) BITLSHIFT 1;
  IF (intval < 0)
    intval := BITNEG intval;
  RETURN EncodeBase64Integer(intval);
}

// only for positive integers!
STRING FUNCTION EncodeBase64Integer(INTEGER value)
{
  STRING encoded;
  WHILE (value > 0 OR encoded = "")
  {
    INTEGER chunk := value BITAND 0x1F;
    value := value BITRSHIFT 5;
    IF (value > 0)
      chunk := chunk BITOR 0x20;
    encoded := encoded || ByteToString(chunk + 63);
  }
  RETURN encoded;
}

MONEY ARRAY FUNCTION DecodeBase64Moneys(STRING value)
{
  MONEY ARRAY decodeds;
  INTEGER ARRAY intvals := DecodeBase64Integers(value);
  FOREVERY (INTEGER intval FROM intvals)
  {
    IF (intval BITAND 0x1 > 0)
      intval := BITNEG intval;
    INSERT ((intval BITRSHIFT 1) / 100000M) INTO decodeds AT END;
  }
  RETURN decodeds;
}

INTEGER ARRAY FUNCTION DecodeBase64Integers(STRING value)
{
  INTEGER ARRAY decodeds;
  INTEGER decoded;
  INTEGER bytecount;
  FOR (INTEGER i := 0; i < Length(value); i := i + 1)
  {
    INTEGER v := GetByteValue(Substring(value, i, 1)) - 63;
    decoded := decoded BITOR ((v BITAND 0x1F) BITLSHIFT (5 * bytecount));
    bytecount := bytecount + 1;
    IF (v BITAND 0x20 = 0)
    {
      INSERT decoded INTO decodeds AT END;
      decoded := 0;
      bytecount := 0;
    }
  }
  RETURN decodeds;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// HareScript type conversion functions
//

/** @short Convert a coordinates string to a GLatLng object
    @param coordinates A coordinate string in the format "langitude,latitude"
    @return A GLatLng object, or a default object if the string could not be parsed
    @see LatLngToString
*/
PUBLIC OBJECT FUNCTION StringToLatLngObject(STRING coordinates)
{
  STRING ARRAY parts := Tokenize(coordinates, ',');
  IF (Length(parts) != 2)
    RETURN DEFAULT OBJECT;

  STRING part := TrimWhitespace(parts[0]);
  IF (Left(part, 1) = "+")
    part := Right(part, Length(part) - 1);
  FLOAT lat := ToFloat(part, 0);
  IF (lat = 0 AND ToFloat(part, 1) = 1)
    RETURN DEFAULT OBJECT;

  part := TrimWhitespace(parts[1]);
  IF (Left(part, 1) = "+")
    part := Right(part, Length(part) - 1);
  FLOAT lng := ToFloat(part, 0);
  IF (lng = 0 AND ToFloat(part, 1) = 1)
    RETURN DEFAULT OBJECT;

  RETURN NEW GLatLng(lat, lng);
}

/** @short Convert a GLatLng object to a coordinate string
    @param latlng A GLatLng object
    @return A coordinate string in the format "latitude,longitude", or an empty string if a default object was specified
    @see StringToLatLng
*/
PUBLIC STRING FUNCTION LatLngObjectToString(OBJECT latlng)
{
  RETURN ObjectExists(latlng) ? latlng->ToUrlValue() : "";
}

PUBLIC STRING FUNCTION EncodeLatLng(OBJECT latlng)
{
  IF (NOT ObjectExists(latlng))
    RETURN "";

  // Round the lat & lng to 5 decimals
  RETURN EncodeBase64Money(FloatToMoney(latlng->lat + 0.000005)) ||
         EncodeBase64Money(FloatToMoney(latlng->lng + 0.000005));
}

PUBLIC OBJECT FUNCTION DecodeLatLng(STRING encoded)
{
  MONEY ARRAY parts := DecodeBase64Moneys(encoded);
  IF (Length(parts) != 2)
    RETURN DEFAULT OBJECT;

  RETURN NEW GLatLng(parts[0], parts[1]);
}

PUBLIC STRING FUNCTION EncodeLatLngs(OBJECT ARRAY latlngs)
{
  RECORD ARRAY rounded;

  RECORD last;
  STRING encoded;

  /* Round the coordinates to moneys before calculating differences,
     to avoid accumulating rounding errors
  */
  FOREVERY (OBJECT latlng FROM latlngs)
  {
    RECORD curr :=
        [ lat := FloatToMoney(latlng->lat + 0.000005)
        , lng := FloatToMoney(latlng->lng + 0.000005)
        ];

    IF (#latlng = 0)
      encoded := encoded || EncodeBase64Money(curr.lat) || EncodeBase64Money(curr.lng);
    ELSE
      encoded := encoded || EncodeBase64Money(curr.lat - last.lat) || EncodeBase64Money(curr.lng - last.lng);

    last := curr;
  }

  RETURN encoded;
}

PUBLIC OBJECT ARRAY FUNCTION DecodeLatLngs(STRING encoded)
{
  OBJECT ARRAY latlngs;
  MONEY ARRAY parts := DecodeBase64Moneys(encoded);
  MONEY lat, lng;
  FOR (INTEGER i := 0; i < Length(parts) - 1; i := i + 2)
  {
    lat := lat + parts[i];
    lng := lng + parts[i + 1];
    INSERT NEW GLatLng(lat, lng) INTO latlngs AT END;
  }
  RETURN latlngs;
}

PUBLIC RECORD ARRAY FUNCTION DecodeLatLngsToRecords(STRING encoded)
{
  RECORD ARRAY latlngs;
  MONEY ARRAY parts := DecodeBase64Moneys(encoded);
  MONEY lat, lng;
  FOR (INTEGER i := 0; i < Length(parts) - 1; i := i + 2)
  {
    lat := lat + parts[i];
    lng := lng + parts[i + 1];
    INSERT [ lat := lat, lng := lng ] INTO latlngs AT END;
  }
  RETURN latlngs;
}

PUBLIC STRING FUNCTION EncodeLevels(INTEGER ARRAY levels)
{
  STRING encoded;
  FOREVERY (INTEGER level FROM levels)
    encoded := encoded || EncodeBase64Integer(level);
  RETURN encoded;
}

PUBLIC INTEGER ARRAY FUNCTION DecodeLevels(STRING encoded)
{
  RETURN DecodeBase64Integers(encoded);
}

/** @short Convert a coordinates record to a GLatLng object
    @param coordinates A [ FLOAT lat, FLOAT lng ] record
    @return A GLatLng object, or a default object if an invalid record was specified
    @see LatLngToRecord
*/
PUBLIC OBJECT FUNCTION RecordToLatLng(RECORD coordinates)
{
  IF (NOT RecordExists(coordinates)
    OR NOT CellExists(coordinates, "lat") OR NOT CellExists(coordinates, "lng"))
    RETURN DEFAULT OBJECT;

  RETURN NEW GLatLng(coordinates.lat, coordinates.lng);
}

/** @short Convert a GLatLng object to a coordinates record
    @param latlng A GLatLng object
    @return A [ FLOAT lat, FLOAT lng ] record, or a default record if a default object was specified
    @see RecordToLatLng
*/
PUBLIC RECORD FUNCTION LatLngToRecord(OBJECT latlng)
{
  RETURN ObjectExists(latlng) ? latlng->ToRecord() : DEFAULT RECORD;
}

/** @short Convert a coordinates string to a GLatLngBounds object
    @param coordinates A coordinates string in the format "langitude,latitude;latitude,longitude"
    @return A GLatLngBounds object, or a default object if the string could not be parsed
    @see BoundsToString
*/
PUBLIC OBJECT FUNCTION StringToBounds(STRING coordinates)
{
  STRING ARRAY parts := Tokenize(coordinates, ';');
  IF (Length(parts) != 2)
    RETURN DEFAULT OBJECT;

  OBJECT sw := StringToLatLngObject(parts[0]);
  IF (NOT ObjectExists(sw))
    RETURN DEFAULT OBJECT;

  OBJECT ne := StringToLatLngObject(parts[1]);
  IF (NOT ObjectExists(ne))
    RETURN DEFAULT OBJECT;

  RETURN NEW GLatLngBounds(sw, ne);
}

/** @short Convert a GLatLngBounds object to a coordinates string
    @param bounds A GLatLngBounds object
    @return A coordinates string in the format "latitude,longitude;latitude,longitude", or an empty string if a default
            object was specified
    @see StringToBounds
*/
PUBLIC STRING FUNCTION BoundsToString(OBJECT bounds)
{
  RETURN ObjectExists(bounds) ? bounds->GetSouthWest()->ToUrlValue() || ";" || bounds->GetNorthEast()->ToUrlValue() : "";
}

/** @short Convert a coordinates record to a GLatLngBounds object
    @param coordinates A [ RECORD sw, RECORD ne ] record
    @return A GLatLngBounds object, or a default object if an invalid record was specified
    @see BoundsToRecord
*/
PUBLIC OBJECT FUNCTION RecordToBounds(RECORD coordinates)
{
  IF (NOT RecordExists(coordinates)
    OR NOT CellExists(coordinates, "sw") OR NOT CellExists(coordinates, "ne"))
    RETURN DEFAULT OBJECT;

  OBJECT sw := RecordToLatLng(coordinates.sw);
  IF (NOT ObjectExists(sw))
    RETURN DEFAULT OBJECT;

  OBJECT ne := RecordToLatLng(coordinates.ne);
  IF (NOT ObjectExists(ne))
    RETURN DEFAULT OBJECT;

  RETURN NEW GLatLngBounds(sw, ne);
}

/** @short Convert a GLatLngBounds object to a coordinates record
    @param bounds A GLatLngBounds object
    @return A [ RECORD sw, RECORD ne ] record, or a default record if a default object was specified
    @see RecordToBounds
*/
PUBLIC RECORD FUNCTION BoundsToRecord(OBJECT bounds)
{
  RETURN ObjectExists(bounds) ? bounds->ToRecord() : DEFAULT RECORD;
}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Overlay clustering
//

/** @short Calculate the number of pixels between two coordinates for a given zoom level
    @param lat1 Latitude of the first point
    @param lng1 Longitude of the first point
    @param lat2 Latitude of the second point
    @param lng2 Longitude of the second point
    @param zoom The zoom level for which to calculate the pixel distance
    @result The (approximate) number of pixels between the two points
*/
PUBLIC INTEGER FUNCTION PixelDistance(FLOAT lat1, FLOAT lng1, FLOAT lat2, FLOAT lng2, INTEGER zoom)
{
  RECORD p1 := ConvertFromLatLng([ lat := lat1, lng := lng1 ], "gm_pixels");
  RECORD p2 := ConvertFromLatLng([ lat := lat2, lng := lng2 ], "gm_pixels");

  RETURN PixelDistanceInternal(p1, p2, zoom);
}

INTEGER FUNCTION PixelDistanceInternal(RECORD p1, RECORD p2, INTEGER zoom)
{
  RETURN FloatToInteger(Floor(Sqrt(Pow(p1.x - p2.x, 2) + Pow(p1.y - p2.y, 2)) + 0.5)) BITRSHIFT (21 - zoom);
}
