<?wh
/*
  This is a HareScript port of the twitter-text.js library. For now it
  implements just enough to be able to offer the extraction functions:
    ExtractEntitiesWithIndices
    ExtractMentions
    ExtractMentionsWithIndices
    ExtractMentionsOrListsWithIndices
    ExtractReplies
    ExtractUrls
    ExtractUrlsWithIndices
    ExtractHashtags
    ExtractHashtagsWithIndices
    ExtractCashtags
    ExtractCashtagsWithIndices

  In addition, the following function is added, which shortens a URL for display
  purposes:
    GetDisplayUrl

  Usage (the API is exposed as twttr->txt, just like it's exposed in JavaScript as twttr.txt):
    LOADLIB "mod::socialite/lib/twitter-text.whlib";
    RECORD ARRAY entities := twttr->txt->ExtractEntitiesWithIndices("some text");
*/
/*!
 * twitter-text-js 1.9.4
 *
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this work except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 */
LOADLIB "wh::regex.whlib";
LOADLIB "wh::util/algorithms.whlib";

PUBLIC OBJECT twttr;

// Print and test all regular expressions and terminate
BOOLEAN test_regex;// := TRUE;

// Create a cell if it doesn't exist, update it if it does
RECORD FUNCTION CellCreate(RECORD rec, STRING cellname, VARIANT value)
{
  IF (CellExists(rec, cellname))
    rec := CellDelete(rec, cellname);
  RETURN CellInsert(rec, cellname, value);
}

// Make sure the cell exists and has a value
RECORD FUNCTION CellEnsure(RECORD rec, STRING cellname, VARIANT defaultvalue)
{
  IF (CellExists(rec, cellname))
    RETURN CellUpdate(rec, cellname, GetCell(rec, cellname) ?? defaultvalue);
  RETURN CellInsert(rec, cellname, defaultvalue);
}

// Sort using a comparator function
RECORD ARRAY FUNCTION Sort(RECORD ARRAY input, FUNCTION PTR compare)
{
  IF (compare = DEFAULT FUNCTION PTR)
    RETURN input;
  RECORD ARRAY output;
  FOREVERY (RECORD rec FROM input)
    INSERT rec INTO output AT LowerBound(output, rec, compare).position;
  RETURN output;
}

// Pass context to callback functions by reference, so the data can be updated
OBJECTTYPE CallbackContext
< PUBLIC RECORD data;
  MACRO NEW(RECORD data)
  {
    this->data := data;
  }
>;

OBJECT Supplant_regex;
Supplant_regex := NEW JSRegEx("#\\{(\\w+)\\}", "g");

OBJECTTYPE TwttrObject
<
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT pvt_txt;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY txt(pvt_txt, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    this->pvt_txt := NEW TwttrTxtObject;
  }
>;

OBJECTTYPE TwttrTxtObject
<
  // ---------------------------------------------------------------------------
  //
  // Public variables
  //

  PUBLIC RECORD regexen;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    STRING ARRAY UNICODE_SPACES :=
      [ UCToString(0x0020) // White_Space # Zs       SPACE
      , UCToString(0x0085) // White_Space # Cc       <control-0085>
      , UCToString(0x00A0) // White_Space # Zs       NO-BREAK SPACE
      , UCToString(0x1680) // White_Space # Zs       OGHAM SPACE MARK
      , UCToString(0x180E) // White_Space # Zs       MONGOLIAN VOWEL SEPARATOR
      , UCToString(0x2028) // White_Space # Zl       LINE SEPARATOR
      , UCToString(0x2029) // White_Space # Zp       PARAGRAPH SEPARATOR
      , UCToString(0x202F) // White_Space # Zs       NARROW NO-BREAK SPACE
      , UCToString(0x205F) // White_Space # Zs       MEDIUM MATHEMATICAL SPACE
      , UCToString(0x3000) // White_Space # Zs       IDEOGRAPHIC SPACE
      ];
    UNICODE_SPACES := this->AddCharsToCharClass(UNICODE_SPACES, "\u0009", "\u000D"); // White_Space # Cc   [5] <control-0009>..<control-000D>
    UNICODE_SPACES := this->AddCharsToCharClass(UNICODE_SPACES, "\u2000", "\u200A"); // White_Space # Zs  [11] EN QUAD..HAIR SPACE

    STRING ARRAY INVALID_CHARS :=
      [ UCToString(0xFFFE)
      , UCToString(0xFEFF) // BOM
      // Not allowed by boost::regex, gives "Invalid UTF-8 sequence" error
      // , UCToString(0xFFFF) // Special
      ];
    INVALID_CHARS := this->AddCharsToCharClass(INVALID_CHARS, "\u202A", "\u202E"); // Directional change

    INSERT CELL spaces_group := this->RegexSupplant(Detokenize(UNICODE_SPACES, "")) INTO this->regexen;
    INSERT CELL spaces := this->RegexSupplant("[" || Detokenize(UNICODE_SPACES, "") || "]") INTO this->regexen;
    INSERT CELL invalid_chars_group := this->RegexSupplant(Detokenize(INVALID_CHARS, "")) INTO this->regexen;
    /* B-Lex: Moved - to start of regex, this string is also used in a character class, and
       Harescript uses C++11 regex which doesn't support escaping - within classes
    */
    INSERT CELL punct := NEW JSRegEx("\\-\\!'#%&'\\(\\)\\*\\+,\\\\\\.\\/:;<=>\\?@\\[\\]\\^_\\{\\|\\}~\\$") INTO this->regexen;
    INSERT CELL rtl_chars := NEW JSRegEx("[\u0600-\u06FF]|[\u0750-\u077F]|[\u0590-\u05FF]|[\uFE70-\uFEFF]", "mg") INTO this->regexen;
    INSERT CELL non_bmp_code_pairs := NEW JSRegEx("[\uD800-\uDBFF][\uDC00-\uDFFF]", "mg") INTO this->regexen;

    STRING ARRAY nonlatinhashtagchars;
    // Cyrillic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0400", "\u04FF"); // Cyrillic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0500", "\u0527"); // Cyrillic Supplement
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u2DE0", "\u2DFF"); // Cyrillic Extended A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uA640", "\uA69F"); // Cyrillic Extended B
    // Hebrew
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0591", "\u05BF"); // Hebrew
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C1", "\u05C2");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C4", "\u05C5");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C7", "\u05C7");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05D0", "\u05EA");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05F0", "\u05F4");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB12", "\uFB28"); // Hebrew Presentation Forms
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB2A", "\uFB36");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB38", "\uFB3C");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB3E", "\uFB3E");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB40", "\uFB41");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB43", "\uFB44");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB46", "\uFB4F");
    // Arabic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0610", "\u061A"); // Arabic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0620", "\u065F");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u066E", "\u06D3");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06D5", "\u06DC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06DE", "\u06E8");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06EA", "\u06EF");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06FA", "\u06FC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06FF", "\u06FF");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0750", "\u077F"); // Arabic Supplement
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08A0", "\u08A0"); // Arabic Extended A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08A2", "\u08AC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08E4", "\u08FE");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB50", "\uFBB1"); // Arabic Pres. Forms A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFBD3", "\uFD3D");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFD50", "\uFD8F");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFD92", "\uFDC7");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFDF0", "\uFDFB");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFE70", "\uFE74"); // Arabic Pres. Forms B
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFE76", "\uFEFC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u200C", "\u200C"); // Zero-Width Non-Joiner
    // Thai
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0E01", "\u0E3A");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0E40", "\u0E4E");
    // Hangul (Korean)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u1100", "\u11FF"); // Hangul Jamo
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3130", "\u3185"); // Hangul Compatibility Jamo
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uA960", "\uA97F"); // Hangul Jamo Extended-A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uAC00", "\uD7AF"); // Hangul Syllables
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD7B0", "\uD7FF"); // Hangul Jamo Extended-B
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFFA1", "\uFFDC"); // half-width Hangul
    // Japanese and Chinese
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u30A1", "\u30FA"); // Katakana (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u30FC", "\u30FE"); // Katakana Chouon and iteration marks (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF66", "\uFF9F"); // Katakana (half-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF70", "\uFF70"); // Katakana Chouon (half-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF10", "\uFF19"); // \
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF21", "\uFF3A"); //  - Latin (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF41", "\uFF5A"); // /
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3041", "\u3096"); // Hiragana
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3099", "\u309E"); // Hiragana voicing and iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3400", "\u4DBF"); // Kanji (CJK Extension A)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u4E00", "\u9FFF"); // Kanji (Unified)
    // Converted to UTF-16 surrogate pairs for HareScript
    // -- Disabled as it breaks the Regex.
    //nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD840\uDC00", "\uD869\uDEDF"); // Kanji (CJK Extension B)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD869\uDF00", "\uD86D\uDF3F"); // Kanji (CJK Extension C)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD86D\uDF40", "\uD86E\uDC1F"); // Kanji (CJK Extension D)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD87E\uDC00", "\uD87E\uDE1F"); // Kanji (CJK supplement)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3003", "\u3003"); // Kanji iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3005", "\u3005"); // Kanji iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u303B", "\u303B"); // Han iteration mark
    INSERT CELL nonlatinhashtagchars := this->RegexSupplant(Detokenize(nonlatinhashtagchars, "")) INTO this->regexen;

    STRING ARRAY latinaccentchars;
    // Latin accented characters (subtracted 0xD7 from the range, it's a confusable multiplication sign. Looks like "x")
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00C0", "\u00D6");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00D8", "\u00DE");
    // Split the range on \u00DF as a continuous range seems to trigger an "Invalid character class name, collating name, or
    // character range" exception from boost regex.
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00DF", "\u00F6");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00F8", "\u00FF");
    // Latin Extended A and B
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0100", "\u024F");
    // assorted IPA Extensions
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0253", "\u0254");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0256", "\u0257");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0259", "\u0259");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u025B", "\u025B");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0263", "\u0263");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0268", "\u0268");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u026F", "\u026F");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0272", "\u0272");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0289", "\u0289");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u028B", "\u028B");
    // Okina for Hawaiian (it *is* a letter character)
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u02BB", "\u02BB");
    // Combining diacritics
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0300", "\u036F");
    // Latin Extended Additional
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u1E00", "\u1EFF");
    INSERT CELL latinaccentchars := this->RegexSupplant(Detokenize(latinaccentchars, "")) INTO this->regexen;

    // A hashtag must contain characters, numbers and underscores, but not all numbers.
    INSERT CELL hashsigns := NEW JSRegEx("[#＃]") INTO this->regexen;
    INSERT CELL hashtagalpha := this->RegexSupplant(NEW JSRegEx("[a-z_#{latinAccentChars}#{nonLatinHashtagChars}]", "i")) INTO this->regexen;
    INSERT CELL hashtagalphanumeric := this->RegexSupplant(NEW JSRegEx("[a-z0-9_#{latinAccentChars}#{nonLatinHashtagChars}]", "i")) INTO this->regexen;
    INSERT CELL endhashtagmatch := this->RegexSupplant(NEW JSRegEx("^(?:#{hashSigns}|:\\/\\/)")) INTO this->regexen;
    INSERT CELL hashtagboundary := this->RegexSupplant(NEW JSRegEx("(?:^|$|[^&a-z0-9_#{latinAccentChars}#{nonLatinHashtagChars}])")) INTO this->regexen;
    INSERT CELL validhashtag := this->RegexSupplant(NEW JSRegEx("(#{hashtagBoundary})(#{hashSigns})(#{hashtagAlphaNumeric}*#{hashtagAlpha}#{hashtagAlphaNumeric}*)", "gi")) INTO this->regexen;

    // Mention related regex collection
    INSERT CELL validmentionprecedingchars := NEW JSRegEx("(?:^|[^a-zA-Z0-9_!#$%&*@＠]|(?:rt|RT|rT|Rt):?)") INTO this->regexen;
    INSERT CELL atsigns := NEW JSRegEx("[@＠]") INTO this->regexen;
    INSERT CELL validmentionorlist := this->RegexSupplant(
      '(#{validMentionPrecedingChars})' ||  // $1: Preceding character
      '(#{atSigns})' ||                     // $2: At mark
      '([a-zA-Z0-9_]{1,20})' ||             // $3: Screen name
      '(\\/[a-zA-Z][a-zA-Z0-9_\\-]{0,24})?' // $4: List (optional)
    , 'g') INTO this->regexen;
    INSERT CELL validreply := this->RegexSupplant(NEW JSRegEx("^(?:#{spaces})*#{atSigns}([a-zA-Z0-9_]{1,20})")) INTO this->regexen;
    INSERT CELL endmentionmatch := this->RegexSupplant(NEW JSRegEx("^(?:#{atSigns}|[#{latinAccentChars}]|:\\/\\/)")) INTO this->regexen;

    // URL related regex collection
    INSERT CELL validurlprecedingchars := this->RegexSupplant(NEW JSRegEx("(?:[^A-Za-z0-9@＠$#＃#{invalid_chars_group}]|^)")) INTO this->regexen;
    INSERT CELL invalidurlwithoutprotocolprecedingchars := NEW JSRegEx("[-_.\\/]$") INTO this->regexen;
    INSERT CELL invaliddomainchars := this->StringSupplant("#{punct}#{spaces_group}#{invalid_chars_group}", this->regexen) INTO this->regexen;
    INSERT CELL validdomainchars := this->RegexSupplant(NEW JSRegEx("[^#{invalidDomainChars}]")) INTO this->regexen;
    INSERT CELL validsubdomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validDomainChars}(?:[_-]|#{validDomainChars})*)?#{validDomainChars}\\.)")) INTO this->regexen;
    INSERT CELL validdomainname := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validDomainChars}(?:-|#{validDomainChars})*)?#{validDomainChars}\\.)")) INTO this->regexen;
    INSERT CELL validgtld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:' ||
      '삼성|닷컴|닷넷|香格里拉|餐厅|食品|飞利浦|電訊盈科|集团|通販|购物|谷歌|诺基亚|联通|网络|网站|网店|网址|组织机构|移动|珠宝|点看|游戏|淡马锡|机构|書籍|时尚|新闻|' ||
      '政府|政务|招聘|手表|手机|我爱你|慈善|微博|广东|工行|家電|娱乐|天主教|大拿|大众汽车|在线|嘉里大酒店|嘉里|商标|商店|商城|公益|公司|八卦|健康|信息|佛山|企业|' ||
      '中文网|中信|世界|ポイント|ファッション|セール|ストア|コム|グーグル|クラウド|みんな|คอม|संगठन|नेट|कॉम|همراه|موقع|موبايلي|كوم|' ||
      'كاثوليك|عرب|شبكة|بيتك|بازار|العليان|ارامكو|اتصالات|ابوظبي|קום|сайт|рус|орг|онлайн|москва|ком|' ||
      'католик|дети|zuerich|zone|zippo|zip|zero|zara|zappos|yun|youtube|you|yokohama|yoga|yodobashi|' ||
      'yandex|yamaxun|yahoo|yachts|xyz|xxx|xperia|xin|xihuan|xfinity|xerox|xbox|wtf|wtc|wow|world|' ||
      'works|work|woodside|wolterskluwer|wme|winners|wine|windows|win|williamhill|wiki|wien|whoswho|' ||
      'weir|weibo|wedding|wed|website|weber|webcam|weatherchannel|weather|watches|watch|warman|' ||
      'wanggou|wang|walter|walmart|wales|vuelos|voyage|voto|voting|vote|volvo|volkswagen|vodka|' ||
      'vlaanderen|vivo|viva|vistaprint|vista|vision|visa|virgin|vip|vin|villas|viking|vig|video|' ||
      'viajes|vet|versicherung|vermögensberatung|vermögensberater|verisign|ventures|vegas|vanguard|' ||
      'vana|vacations|ups|uol|uno|university|unicom|uconnect|ubs|ubank|tvs|tushu|tunes|tui|tube|trv|' ||
      'trust|travelersinsurance|travelers|travelchannel|travel|training|trading|trade|toys|toyota|' ||
      'town|tours|total|toshiba|toray|top|tools|tokyo|today|tmall|tkmaxx|tjx|tjmaxx|tirol|tires|tips|' ||
      'tiffany|tienda|tickets|tiaa|theatre|theater|thd|teva|tennis|temasek|telefonica|telecity|tel|' ||
      'technology|tech|team|tdk|tci|taxi|tax|tattoo|tatar|tatamotors|target|taobao|talk|taipei|tab|' ||
      'systems|symantec|sydney|swiss|swiftcover|swatch|suzuki|surgery|surf|support|supply|supplies|' ||
      'sucks|style|study|studio|stream|store|storage|stockholm|stcgroup|stc|statoil|statefarm|' ||
      'statebank|starhub|star|staples|stada|srt|srl|spreadbetting|spot|sport|spiegel|space|soy|sony|' ||
      'song|solutions|solar|sohu|software|softbank|social|soccer|sncf|smile|smart|sling|skype|sky|' ||
      'skin|ski|site|singles|sina|silk|shriram|showtime|show|shouji|shopping|shop|shoes|shiksha|shia|' ||
      'shell|shaw|sharp|shangrila|sfr|sexy|sex|sew|seven|ses|services|sener|select|seek|security|' ||
      'secure|seat|search|scot|scor|scjohnson|science|schwarz|schule|school|scholarships|schmidt|' ||
      'schaeffler|scb|sca|sbs|sbi|saxo|save|sas|sarl|sapo|sap|sanofi|sandvikcoromant|sandvik|samsung|' ||
      'samsclub|salon|sale|sakura|safety|safe|saarland|ryukyu|rwe|run|ruhr|rugby|rsvp|room|rogers|' ||
      'rodeo|rocks|rocher|rmit|rip|rio|ril|rightathome|ricoh|richardli|rich|rexroth|reviews|review|' ||
      'restaurant|rest|republican|report|repair|rentals|rent|ren|reliance|reit|reisen|reise|rehab|' ||
      'redumbrella|redstone|red|recipes|realty|realtor|realestate|read|raid|radio|racing|qvc|quest|' ||
      'quebec|qpon|pwc|pub|prudential|pru|protection|property|properties|promo|progressive|prof|' ||
      'productions|prod|pro|prime|press|praxi|pramerica|post|porn|politie|poker|pohl|pnc|plus|' ||
      'plumbing|playstation|play|place|pizza|pioneer|pink|ping|pin|pid|pictures|pictet|pics|piaget|' ||
      'physio|photos|photography|photo|phone|philips|phd|pharmacy|pfizer|pet|pccw|pay|passagens|' ||
      'party|parts|partners|pars|paris|panerai|panasonic|pamperedchef|page|ovh|ott|otsuka|osaka|' ||
      'origins|orientexpress|organic|org|orange|oracle|open|ooo|onyourside|online|onl|ong|one|omega|' ||
      'ollo|oldnavy|olayangroup|olayan|okinawa|office|off|observer|obi|nyc|ntt|nrw|nra|nowtv|nowruz|' ||
      'now|norton|northwesternmutual|nokia|nissay|nissan|ninja|nikon|nike|nico|nhk|ngo|nfl|nexus|' ||
      'nextdirect|next|news|newholland|new|neustar|network|netflix|netbank|net|nec|nba|navy|natura|' ||
      'nationwide|name|nagoya|nadex|nab|mutuelle|mutual|museum|mtr|mtpc|mtn|msd|movistar|movie|mov|' ||
      'motorcycles|moto|moscow|mortgage|mormon|mopar|montblanc|monster|money|monash|mom|moi|moe|moda|' ||
      'mobily|mobile|mobi|mma|mls|mlb|mitsubishi|mit|mint|mini|mil|microsoft|miami|metlife|merckmsd|' ||
      'meo|menu|men|memorial|meme|melbourne|meet|media|med|mckinsey|mcdonalds|mcd|mba|mattel|' ||
      'maserati|marshalls|marriott|markets|marketing|market|map|mango|management|man|makeup|maison|' ||
      'maif|madrid|macys|luxury|luxe|lupin|lundbeck|ltda|ltd|lplfinancial|lpl|love|lotto|lotte|' ||
      'london|lol|loft|locus|locker|loans|loan|llp|llc|lixil|living|live|lipsy|link|linde|lincoln|' ||
      'limo|limited|lilly|like|lighting|lifestyle|lifeinsurance|life|lidl|liaison|lgbt|lexus|lego|' ||
      'legal|lefrak|leclerc|lease|lds|lawyer|law|latrobe|latino|lat|lasalle|lanxess|landrover|land|' ||
      'lancome|lancia|lancaster|lamer|lamborghini|ladbrokes|lacaixa|kyoto|kuokgroup|kred|krd|kpn|' ||
      'kpmg|kosher|komatsu|koeln|kiwi|kitchen|kindle|kinder|kim|kia|kfh|kerryproperties|' ||
      'kerrylogistics|kerryhotels|kddi|kaufen|juniper|juegos|jprs|jpmorgan|joy|jot|joburg|jobs|jnj|' ||
      'jmp|jll|jlc|jio|jewelry|jetzt|jeep|jcp|jcb|java|jaguar|iwc|iveco|itv|itau|istanbul|ist|' ||
      'ismaili|iselect|irish|ipiranga|investments|intuit|international|intel|int|insure|insurance|' ||
      'institute|ink|ing|info|infiniti|industries|inc|immobilien|immo|imdb|imamat|ikano|iinet|ifm|' ||
      'ieee|icu|ice|icbc|ibm|hyundai|hyatt|hughes|htc|hsbc|how|house|hotmail|hotels|hoteles|hot|' ||
      'hosting|host|hospital|horse|honeywell|honda|homesense|homes|homegoods|homedepot|holiday|' ||
      'holdings|hockey|hkt|hiv|hitachi|hisamitsu|hiphop|hgtv|hermes|here|helsinki|help|healthcare|' ||
      'health|hdfcbank|hdfc|hbo|haus|hangout|hamburg|hair|guru|guitars|guide|guge|gucci|guardian|' ||
      'group|grocery|gripe|green|gratis|graphics|grainger|gov|got|gop|google|goog|goodyear|goodhands|' ||
      'goo|golf|goldpoint|gold|godaddy|gmx|gmo|gmbh|gmail|globo|global|gle|glass|glade|giving|gives|' ||
      'gifts|gift|ggee|george|genting|gent|gea|gdn|gbiz|gay|garden|gap|games|game|gallup|gallo|' ||
      'gallery|gal|fyi|futbol|furniture|fund|fun|fujixerox|fujitsu|ftr|frontier|frontdoor|frogans|' ||
      'frl|fresenius|free|fox|foundation|forum|forsale|forex|ford|football|foodnetwork|food|foo|fly|' ||
      'flsmidth|flowers|florist|flir|flights|flickr|fitness|fit|fishing|fish|firmdale|firestone|fire|' ||
      'financial|finance|final|film|fido|fidelity|fiat|ferrero|ferrari|feedback|fedex|fast|fashion|' ||
      'farmers|farm|fans|fan|family|faith|fairwinds|fail|fage|extraspace|express|exposed|expert|' ||
      'exchange|everbank|events|eus|eurovision|etisalat|esurance|estate|esq|erni|ericsson|equipment|' ||
      'epson|epost|enterprises|engineering|engineer|energy|emerck|email|education|edu|edeka|eco|eat|' ||
      'earth|dvr|dvag|durban|dupont|duns|dunlop|duck|dubai|dtv|drive|download|dot|doosan|domains|' ||
      'doha|dog|dodge|doctor|docs|dnp|diy|dish|discover|discount|directory|direct|digital|diet|' ||
      'diamonds|dhl|dev|design|desi|dentist|dental|democrat|delta|deloitte|dell|delivery|degree|' ||
      'deals|dealer|deal|dds|dclk|day|datsun|dating|date|data|dance|dad|dabur|cyou|cymru|cuisinella|' ||
      'csc|cruises|cruise|crs|crown|cricket|creditunion|creditcard|credit|cpa|courses|coupons|coupon|' ||
      'country|corsica|coop|cool|cookingchannel|cooking|contractors|contact|consulting|construction|' ||
      'condos|comsec|computer|compare|company|community|commbank|comcast|com|cologne|college|coffee|' ||
      'codes|coach|clubmed|club|cloud|clothing|clinique|clinic|click|cleaning|claims|cityeats|city|' ||
      'citic|citi|citadel|cisco|circle|cipriani|church|chrysler|chrome|christmas|chloe|chintai|cheap|' ||
      'chat|chase|charity|channel|chanel|cfd|cfa|cern|ceo|center|ceb|cbs|cbre|cbn|cba|catholic|' ||
      'catering|cat|casino|cash|caseih|case|casa|cartier|cars|careers|career|care|cards|caravan|car|' ||
      'capitalone|capital|capetown|canon|cancerresearch|camp|camera|cam|calvinklein|call|cal|cafe|' ||
      'cab|bzh|buzz|buy|business|builders|build|bugatti|budapest|brussels|brother|broker|broadway|' ||
      'bridgestone|bradesco|box|boutique|bot|boston|bostik|bosch|boots|booking|book|boo|bond|bom|' ||
      'bofa|boehringer|boats|bnpparibas|bnl|bmw|bms|blue|bloomberg|blog|blockbuster|blanco|' ||
      'blackfriday|black|biz|bio|bingo|bing|bike|bid|bible|bharti|bet|bestbuy|best|berlin|bentley|' ||
      'beer|beauty|beats|bcn|bcg|bbva|bbt|bbc|bayern|bauhaus|basketball|baseball|bargains|barefoot|' ||
      'barclays|barclaycard|barcelona|bar|bank|band|bananarepublic|banamex|baidu|baby|azure|axa|aws|' ||
      'avianca|autos|auto|author|auspost|audio|audible|audi|auction|attorney|athleta|associates|asia|' ||
      'asda|arte|art|arpa|army|archi|aramco|arab|aquarelle|apple|app|apartments|aol|anz|anquan|' ||
      'android|analytics|amsterdam|amica|amfam|amex|americanfamily|americanexpress|alstom|alsace|' ||
      'ally|allstate|allfinanz|alipay|alibaba|alfaromeo|akdn|airtel|airforce|airbus|aigo|aig|agency|' ||
      'agakhan|africa|afl|afamilycompany|aetna|aero|aeg|adult|ads|adac|actor|active|aco|accountants|' ||
      'accountant|accenture|academy|abudhabi|abogado|able|abc|abbvie|abbott|abb|abarth|aarp|aaa|' ||
      'onion' ||
      ')(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validcctld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:' ||
      '한국|香港|澳門|新加坡|台灣|台湾|中國|中国|გე|ລາວ|ไทย|ලංකා|ഭാരതം|ಭಾರತ|భారత్|சிங்கப்பூர்|இலங்கை|இந்தியா|ଭାରତ|' ||
      'ભારત|ਭਾਰਤ|ভাৰত|ভারত|বাংলা|भारोत|भारतम्|भारत|ڀارت|پاکستان|موريتانيا|مليسيا|مصر|قطر|فلسطين|عمان|' ||
      'عراق|سورية|سودان|تونس|بھارت|بارت|ایران|امارات|المغرب|السعودية|الجزائر|البحرين|الاردن|հայ|қаз|' ||
      'укр|срб|рф|мон|мкд|ею|бел|бг|ευ|ελ|zw|zm|za|yt|ye|ws|wf|vu|vn|vi|vg|ve|vc|va|uz|uy|us|um|uk|' ||
      'ug|ua|tz|tw|tv|tt|tr|tp|to|tn|tm|tl|tk|tj|th|tg|tf|td|tc|sz|sy|sx|sv|su|st|ss|sr|so|sn|sm|sl|' ||
      'sk|sj|si|sh|sg|se|sd|sc|sb|sa|rw|ru|rs|ro|re|qa|py|pw|pt|ps|pr|pn|pm|pl|pk|ph|pg|pf|pe|pa|om|' ||
      'nz|nu|nr|np|no|nl|ni|ng|nf|ne|nc|na|mz|my|mx|mw|mv|mu|mt|ms|mr|mq|mp|mo|mn|mm|ml|mk|mh|mg|mf|' ||
      'me|md|mc|ma|ly|lv|lu|lt|ls|lr|lk|li|lc|lb|la|kz|ky|kw|kr|kp|kn|km|ki|kh|kg|ke|jp|jo|jm|je|it|' ||
      'is|ir|iq|io|in|im|il|ie|id|hu|ht|hr|hn|hm|hk|gy|gw|gu|gt|gs|gr|gq|gp|gn|gm|gl|gi|gh|gg|gf|ge|' ||
      'gd|gb|ga|fr|fo|fm|fk|fj|fi|eu|et|es|er|eh|eg|ee|ec|dz|do|dm|dk|dj|de|cz|cy|cx|cw|cv|cu|cr|co|' ||
      'cn|cm|cl|ck|ci|ch|cg|cf|cd|cc|ca|bz|by|bw|bv|bt|bs|br|bq|bo|bn|bm|bl|bj|bi|bh|bg|bf|be|bd|bb|' ||
      'ba|az|ax|aw|au|at|as|ar|aq|ao|an|am|al|ai|ag|af|ae|ad|ac' ||
      ')(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validpunycode := this->RegexSupplant(NEW JSRegEx("(?:xn--[0-9a-z]+)")) INTO this->regexen;
    INSERT CELL validspecialcctld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:co|tv)(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validdomain := this->RegexSupplant(NEW JSRegEx("(?:#{validSubdomain}*#{validDomainName}(?:#{validGTLD}|#{validCCTLD}|#{validPunycode}))")) INTO this->regexen;
    INSERT CELL validasciidomain := this->RegexSupplant(NEW JSRegEx("(?:(?:[\\-a-z0-9#{latinAccentChars}]+)\\.)+(?:#{validGTLD}|#{validCCTLD}|#{validPunycode})", "gi")) INTO this->regexen;
    INSERT CELL invalidshortdomain := this->RegexSupplant(NEW JSRegEx("^#{validDomainName}#{validCCTLD}$", "i")) INTO this->regexen;
    INSERT CELL validspecialshortdomain := this->RegexSupplant(NEW JSRegEx("^#{validDomainName}#{validSpecialCCTLD}$", "i")) INTO this->regexen;

    INSERT CELL validportnumber := this->RegexSupplant(NEW JSRegEx("[0-9]+")) INTO this->regexen;

    INSERT CELL validgeneralurlpathchars := this->RegexSupplant(NEW JSRegEx("[a-z0-9!\\*';:=\\+,\\.\\$\\/%#\\[\\]\\-_~@|&#{latinAccentChars}]", "i")) INTO this->regexen;
    // Allow URL paths to contain up to two nested levels of balanced parens
    //  1. Used in Wikipedia URLs like /Primer_(film)
    //  2. Used in IIS sessions like /S(dfd346)/
    //  3. Used in Rdio URLs like /track/We_Up_(Album_Version_(Edited))/
    INSERT CELL validurlbalancedparens := this->RegexSupplant(
      '\\('                                   ||
        '(?:'                                 ||
          '#{validGeneralUrlPathChars}+'      ||
          '|'                                 ||
          // allow one nested level of balanced parentheses
          '(?:'                               ||
            '#{validGeneralUrlPathChars}*'    ||
            '\\('                             ||
              '#{validGeneralUrlPathChars}+'  ||
            '\\)'                             ||
            '#{validGeneralUrlPathChars}*'    ||
          ')'                                 ||
        ')'                                   ||
      '\\)'
    , 'i') INTO this->regexen;
    // Valid end-of-path chracters (so /foo. does not gobble the period).
    // 1. Allow =&# for empty URL parameters and other URL-join artifacts
    INSERT CELL validurlpathendingchars := this->RegexSupplant(NEW JSRegEx("[\\+\\-a-z0-9=_#\\/#{latinAccentChars}]|(?:#{validUrlBalancedParens})", "i")) INTO this->regexen;
    // Allow @ in a url, but only in the middle. Catch things like http://example.com/@user/
    INSERT CELL validurlpath := this->RegexSupplant('(?:' ||
      '(?:' ||
        '#{validGeneralUrlPathChars}*' ||
          '(?:#{validUrlBalancedParens}#{validGeneralUrlPathChars}*)*' ||
          '#{validUrlPathEndingChars}'||
        ')|(?:@#{validGeneralUrlPathChars}+\\/)'||
      ')', 'i') INTO this->regexen;

    INSERT CELL validurlquerychars := NEW JSRegEx("[a-z0-9!?\\*'@\\(\\);:&=\\+\\$\\/%#\\[\\]\\-_\\.,~|]", "i") INTO this->regexen;
    INSERT CELL validurlqueryendingchars := NEW JSRegEx("[a-z0-9_&=#\\/]", "i") INTO this->regexen;
    INSERT CELL extracturl := this->RegexSupplant(
      '('                                                            || // $1 total match
        '(#{validUrlPrecedingChars})'                                || // $2 Preceeding chracter
        '('                                                          || // $3 URL
          '(https?:\\/\\/)?'                                         || // $4 Protocol (optional)
          '(#{validDomain})'                                         || // $5 Domain(s)
          '(?::(#{validPortNumber}))?'                               || // $6 Port number (optional)
          '(\\/#{validUrlPath}*)?'                                   || // $7 URL Path
          '(\\?#{validUrlQueryChars}*#{validUrlQueryEndingChars})?'  || // $8 Query String
        ')'                                                          ||
      ')'
    , 'gi') INTO this->regexen;

    INSERT CELL validtcourl := NEW JSRegEx("^https?:\\/\\/t\\.co\\/[a-z0-9]+", "i") INTO this->regexen;
    INSERT CELL urlhasprotocol := NEW JSRegEx("^https?:\\/\\/", "i") INTO this->regexen;
    INSERT CELL urlhashttps := NEW JSRegEx("^https:\\/\\/", "i") INTO this->regexen;

    // cashtag related regex
    INSERT CELL cashtag := NEW JSRegEx("[a-z]{1,6}(?:[._][a-z]{1,2})?", "i") INTO this->regexen;
    INSERT CELL validcashtag := this->RegexSupplant('(^|#{spaces})(\\$)(#{cashtag})(?=$|\\s|[#{punct}])', 'gi') INTO this->regexen;

    // These URL validation pattern strings are based on the ABNF from RFC 3986
    INSERT CELL validateurlunreserved := NEW JSRegEx("[a-z0-9\\-._~]", "i") INTO this->regexen;
    INSERT CELL validateurlpctencoded := NEW JSRegEx("(?:%[0-9a-f]{2})", "i") INTO this->regexen;
    INSERT CELL validateurlsubdelims := NEW JSRegEx("[!$&'()*+,;=]", "i") INTO this->regexen;
    INSERT CELL validateurlpchar := this->RegexSupplant('(?:' ||
      '#{validateUrlUnreserved}|' ||
      '#{validateUrlPctEncoded}|' ||
      '#{validateUrlSubDelims}|' ||
      '[:|@]' ||
    ')', 'i') INTO this->regexen;

    INSERT CELL validateurlscheme := NEW JSRegEx("(?:[a-z][a-z0-9+\\-.]*)", "i") INTO this->regexen;
    INSERT CELL validateurluserinfo := this->RegexSupplant('(?:' ||
      '#{validateUrlUnreserved}|' ||
      '#{validateUrlPctEncoded}|' ||
      '#{validateUrlSubDelims}|' ||
      ':' ||
    ')*', 'i') INTO this->regexen;

    INSERT CELL validateurldecoctet := NEW JSRegEx("(?:[0-9]|(?:[1-9][0-9])|(?:1[0-9]{2})|(?:2[0-4][0-9])|(?:25[0-5]))", "i") INTO this->regexen;
    INSERT CELL validateurlipv4 := this->RegexSupplant(NEW JSRegEx("(?:#{validateUrlDecOctet}(?:\\.#{validateUrlDecOctet}){3})", "i")) INTO this->regexen;

    // Punting on real IPv6 validation for now
    INSERT CELL validateurlipv6 := NEW JSRegEx("(?:\\[[a-f0-9:\\.]+\\])", "i") INTO this->regexen;

    // Also punting on IPvFuture for now
    INSERT CELL validateurlip := this->RegexSupplant('(?:' ||
      '#{validateUrlIpv4}|' ||
      '#{validateUrlIpv6}' ||
    ')', 'i') INTO this->regexen;

    // This is more strict than the rfc specifies
    INSERT CELL validateurlsubdomainsegment := NEW JSRegEx("(?:[a-z0-9](?:[a-z0-9_\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomainsegment := NEW JSRegEx("(?:[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomaintld := NEW JSRegEx("(?:[a-z](?:[a-z0-9\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validateUrlSubDomainSegment}\\.)*(?:#{validateUrlDomainSegment}\\.)#{validateUrlDomainTld})", "i")) INTO this->regexen;

    INSERT CELL validateurlhost := this->RegexSupplant('(?:' ||
      '#{validateUrlIp}|' ||
      '#{validateUrlDomain}' ||
    ')', 'i') INTO this->regexen;

    // Unencoded internationalized domains - this doesn't check for invalid UTF-8 sequences
    INSERT CELL validateurlunicodesubdomainsegment := NEW JSRegEx("(?:(?:[a-z0-9]|[^\u0000-\u007F])(?:(?:[a-z0-9_\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomainsegment := NEW JSRegEx("(?:(?:[a-z0-9]|[^\u0000-\u007F])(?:(?:[a-z0-9\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomaintld := NEW JSRegEx("(?:(?:[a-z]|[^\u0000-\u007F])(?:(?:[a-z0-9\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validateUrlUnicodeSubDomainSegment}\\.)*(?:#{validateUrlUnicodeDomainSegment}\\.)#{validateUrlUnicodeDomainTld})", "i")) INTO this->regexen;

    INSERT CELL validateurlunicodehost := this->RegexSupplant('(?:' ||
      '#{validateUrlIp}|' ||
      '#{validateUrlUnicodeDomain}' ||
    ')', 'i') INTO this->regexen;

    INSERT CELL validateurlport := NEW JSRegEx("[0-9]{1,5}") INTO this->regexen;

    INSERT CELL validateurlunicodeauthority := this->RegexSupplant(
      '(?:(#{validateUrlUserinfo})@)?'  || // $1 userinfo
      '(#{validateUrlUnicodeHost})'     || // $2 host
      '(?::(#{validateUrlPort}))?'         //$3 port
    , "i") INTO this->regexen;

    INSERT CELL validateurlauthority := this->RegexSupplant(
      '(?:(#{validateUrlUserinfo})@)?' || // $1 userinfo
      '(#{validateUrlHost})'           || // $2 host
      '(?::(#{validateUrlPort}))?'        // $3 port
    , "i") INTO this->regexen;

    INSERT CELL validateurlpath := this->RegexSupplant(NEW JSRegEx("(\\/#{validateUrlPchar}*)*", "i")) INTO this->regexen;
    INSERT CELL validateurlquery := this->RegexSupplant(NEW JSRegEx("(#{validateUrlPchar}|\\/|\\?)*", "i")) INTO this->regexen;
    INSERT CELL validateurlfragment := this->RegexSupplant(NEW JSRegEx("(#{validateUrlPchar}|\\/|\\?)*", "i")) INTO this->regexen;

    // Modified version of RFC 3986 Appendix B
    INSERT CELL validateurlunencoded := this->RegexSupplant(
      '^'                               || // Full URL
      '(?:'                             ||
        '([^:/?#]+):\\/\\/'             || // $1 Scheme
      ')?'                              ||
      '([^/?#]*)'                       || // $2 Authority
      '([^?#]*)'                        || // $3 Path
      '(?:'                             ||
        '\\?([^#]*)'                    || // $4 Query
      ')?'                              ||
      '(?:'                             ||
        '#(.*)'                         || // $5 Fragment
      ')?$'
    , "i") INTO this->regexen;

    // Print and test all regular expressions and terminate
    IF (test_regex)
    {
      FOREVERY (RECORD r FROM UnpackRecord(this->regexen))
      {
        Print(r.name || "\n");
        IF (TypeID(r.value) = TypeID(OBJECT))
        {
          Print("RegExp: '" || EncodeJava(r.value->source) || "'");
          r.value->Test("");
        }
        ELSE
        {
          Print("String: '" || EncodeJava(r.value) || "'");
          (NEW JSRegEx(r.value))->Test("");
        }
        Print("\n\n");
      }
      TerminateScript();
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  // Builds a RegExp
  PUBLIC OBJECT FUNCTION RegexSupplant(VARIANT regex, STRING flags DEFAULTSTO "")
  {
    STRING pattern;
    IF (TypeID(regex) = TypeID(OBJECT))
    {
      IF (regex->global AND flags NOT LIKE "*g*")
        flags := flags || "g";
      IF (regex->ignorecase AND flags NOT LIKE "*i*")
        flags := flags || "i";
      IF (regex->multiline AND flags NOT LIKE "*m*")
        flags := flags || "m";

      pattern := regex->source;
    }
    ELSE IF (TypeID(regex) = TypeID(STRING))
      pattern := regex;
    ELSE
      THROW NEW Exception("Expected regular expresseion object or pattern");

    RETURN NEW JSRegEx(Supplant_regex->ReplaceCallback(pattern, PTR this->RegexSupplant_Callback), flags);
  }

  // simple string interpolation
  PUBLIC STRING FUNCTION StringSupplant(STRING str, RECORD values_)
  {
    RETURN Supplant_regex->ReplaceCallback(str, PTR this->StringSupplant_Callback(values_, #1, #2, #3, #4));
  }

  PUBLIC STRING ARRAY FUNCTION AddCharsToCharClass(STRING ARRAY charclass, STRING start, STRING end_)
  {
    STRING s := start;
    IF (end_ != start)
      s := s || "-" || end_;
    INSERT s INTO charclass AT END;
    RETURN charclass;
  }

  PUBLIC RECORD ARRAY FUNCTION RemoveOverlappingEntities(RECORD ARRAY entities)
  {
    entities := Sort(entities, PTR this->CompareEntities);

    RECORD prev;
    RECORD ARRAY result;
    FOREVERY (RECORD entity FROM entities)
    {
      IF (#entity = 0 OR entity.indices[0] >= prev.indices[1])
      {
        prev := entity;
        INSERT entity INTO result AT END;
      }
    }
    RETURN result;
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractEntitiesWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD ARRAY entities := this->ExtractUrlsWithIndices(text, options)
                             CONCAT
                             this->ExtractMentionsOrListsWithIndices(text)
                             CONCAT
                             this->ExtractHashtagsWithIndices(text, [ checkurloverlap := FALSE ])
                             CONCAT
                             this->ExtractCashtagsWithIndices(text);

    IF (Length(entities) = 0)
      RETURN DEFAULT RECORD ARRAY;

    entities := this->RemoveOverlappingEntities(entities);
    RETURN entities;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractMentions(STRING text)
  {
    RETURN SELECT AS STRING ARRAY screenname
             FROM this->ExtractMentionsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractMentionsWithIndices(STRING text)
  {
    RETURN SELECT screenname
                , indices
             FROM this->ExtractMentionsOrListsWithIndices(text) AS mentionsorlists
            WHERE CellExists(mentionsorlists, "listslug") ? listslug = "" : TRUE;
  }

  /**
   * Extract list or user mentions.
   * (Presence of listSlug indicates a list)
   */
  PUBLIC RECORD ARRAY FUNCTION ExtractMentionsOrListsWithIndices(STRING text)
  {
    IF (text = "" OR NOT this->regexen.atsigns->Test(text))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ possiblenames := DEFAULT RECORD ARRAY ]);

    this->regexen.validmentionorlist->ReplaceCallback(text, PTR this->ExtractMentionsOrListsWithIndices_Callback(context, #1, #2, #3, #4));

    RETURN context->data.possiblenames;
  }

  PUBLIC STRING FUNCTION ExtractReplies(STRING text)
  {
    IF (text = "")
      RETURN "";

    OBJECT context := NEW CallbackContext([ possiblescreenname := "" ]);

    this->regexen.validreply->ReplaceCallback(text, PTR this->ExtractReplies_Callback(context, #1, #2, #3, #4));

    RETURN context->data.possiblescreenname;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractUrls(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RETURN SELECT AS STRING ARRAY url
             FROM this->ExtractUrlsWithIndices(text, options);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractUrlsWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF (NOT RecordExists(options))
      options := [ extracturlswithoutprotocol := TRUE ];
    IF (text = "" OR (options.extracturlswithoutprotocol ? text NOT LIKE "*.*" : text NOT LIKE "*:*"))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ lasturl := DEFAULT RECORD
                                          , startposition := 0
                                          , asciiendposition := 0
                                          , path := ""
                                          , urls := DEFAULT RECORD ARRAY
                                          ]);

    RECORD ARRAY matches := this->regexen.extracturl->Exec(text);
    INTEGER prevstart := -1, prevlen := -1;
    WHILE (RecordExists(matches))
    {
      IF (matches[0].start = prevstart AND matches[0].len = prevlen)
        BREAK; // No more forward progress, bail out
      prevstart := matches[0].start;
      prevlen := matches[0].len;

      STRING before := matches[2].value
           , url := matches[3].value
           , protocol := matches[4].value
           , domain := matches[5].value
           , path := matches[7].value;
      INTEGER endposition := this->regexen.extracturl->lastindex;
      context->data.startposition := endposition - Length(url);

      // Retrieve the next match so we can just CONTINUE to the next match
      matches := this->regexen.extracturl->Exec(text);

      // if protocol is missing and domain contains non-ASCII characters,
      // extract ASCII-only domains.
      IF (protocol = "")
      {
        IF (NOT options.extracturlswithoutprotocol
            OR this->regexen.invalidurlwithoutprotocolprecedingchars->Test(before))
          CONTINUE;
        context->data.lasturl := DEFAULT RECORD;
        context->data.asciiendposition := 0;
        context->data.path := path;
        this->regexen.validasciidomain->ReplaceCallback(domain, PTR this->ExtractUrlsWithIndices_Callback(context, #1, #2, #3, #4));

        // no ASCII-only domain found. Skip the entire URL.
        IF (NOT RecordExists(context->data.lasturl))
          CONTINUE;

        // lastUrl only contains domain. Need to add path and query if they exist.
        IF (path != "")
        {
          context->data.lasturl.url := Substitute(url, domain, context->data.lasturl.url);
          context->data.lasturl.indices[1] := endposition;
        }
      }
      ELSE
      {
        // In the case of t.co URLs, don't allow additional path characters.
        RECORD lastmatch := this->regexen.validtcourl->Exec(url);
        IF (RecordExists(lastmatch))
        {
          url := lastmatch.value;
          endposition := context->data.startposition + Length(url);
        }
        INSERT [ url := url
               , display_url := this->GetDisplayUrl(url)
               , indices := [ INTEGER(context->data.startposition), endposition ]
               ] INTO context->data.urls AT END;
      }
    }

    RETURN context->data.urls;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractHashtags(STRING text)
  {
    RETURN SELECT AS STRING ARRAY hashtag
             FROM this->ExtractHashtagsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractHashtagsWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF (NOT RecordExists(options))
      options := [ checkurloverlap := TRUE ];

    IF (text = "" OR NOT this->regexen.hashsigns->Test(text))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ tags := DEFAULT RECORD ARRAY ]);

    this->regexen.validhashtag->ReplaceCallback(text, PTR this->ExtractHashtagsWithIndices_Callback(context, #1, #2, #3, #4));

    IF (options.checkurloverlap)
    {
      // also extract URL entities
      RECORD ARRAY urls := this->ExtractUrlsWithIndices(text);
      IF (Length(urls) > 0)
      {
        RECORD ARRAY entities := context->data.tags CONCAT urls;
        // remove overlap
        entities := this->RemoveOverlappingEntities(entities);
        // only push back hashtags
        context->data.tags := SELECT * FROM entities
                               WHERE CellExists(entities, "hashtag") ? hashtag != "" : FALSE; // workaround not optimizable warning
      }
    }

    RETURN context->data.tags;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractCashtags(STRING text)
  {
    RETURN SELECT AS STRING ARRAY cashtag
             FROM this->ExtractCashtagsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractCashtagsWithIndices(STRING text)
  {
    IF (text = "" OR SearchSubstring(text, "$") = -1)
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ tags := DEFAULT RECORD ARRAY ]);

    this->regexen.validcashtag->ReplaceCallback(text, PTR this->ExtractCashtagsWithIndices_Callback(context, #1, #2, #3, #4));

    RETURN context->data.tags;
  }

  // WebHare addition: This function mimics Twitter's display_url generation (which unfortunately isn't provided by twitter-text)
  PUBLIC STRING FUNCTION GetDisplayUrl(STRING url)
  {
    // Strip protocol
    INTEGER hoststart := SearchSubstring(url, "://");
    IF (hoststart >= 0)
      url := Substring(url, hoststart + 3);

    // Strip leading "www."
    IF (url LIKE "www.*")
      url := Substring(url, 4);

    // Limit to 30 characters
    BOOLEAN toolong := UCLength(url) > 30;
    IF (toolong)
      url := UCLeft(url, 30);

    // Strip trailing "/"
    IF (url LIKE "*/")
      url := Left(url, Length(url) - 1);

    // If characters were removed (except trailing slash), add an ellipsis
    IF (toolong)
      url := url || "\u2026";

    RETURN url;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING FUNCTION RegexSupplant_Callback(STRING match, STRING ARRAY names, INTEGER pos, STRING input)
  {
    STRING newregex;
    IF (CellExists(this->regexen, names[0]))
    {
      VARIANT value := GetCell(this->regexen, names[0]);
      IF (TypeID(value) = TypeID(STRING))
        newregex := value;
      ELSE IF (TypeID(value) = TypeID(OBJECT))
        newregex := value->source;
    }
    ELSE
      THROW NEW Exception("Referenced regex '" || names[0] || "' not found");
    RETURN newregex;
  }

  STRING FUNCTION StringSupplant_Callback(RECORD values_, STRING match, STRING ARRAY names, INTEGER pos, STRING input)
  {
    IF (CellExists(values_, names[0]))
    {
      VARIANT value := GetCell(values_, names[0]);
      IF (TypeID(value) = TypeID(STRING))
        RETURN value;
      ELSE IF (TypeID(value) = TypeID(OBJECT))
        RETURN value->source;
    }
    ELSE
      THROW NEW Exception("Referenced string '" || names[0] || "' not found");
    RETURN "";
  }

  MACRO ExtractMentionsOrListsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING atsign := params[1];
    STRING screenname := params[2];
    STRING slashlistname := params[3];

    STRING after := Substring(chunk, offset_ + Length(match));
    IF (NOT this->regexen.endmentionmatch->Test(after))
    {
      INTEGER startposition := offset_ + Length(before);
      INTEGER endposition := startposition + Length(screenname) + Length(slashlistname) + 1;
      INSERT [ screenname := screenname
             , listslug := slashlistname
             , indices := [ startposition, endposition ]
             ] INTO context->data.possiblenames AT END;
    }
  }

  MACRO ExtractReplies_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER pos, STRING input)
  {
    STRING possiblescreenname := params[0];

    STRING rightcontext := Substring(input, pos + Length(match));
    IF (this->regexen.endmentionmatch->Test(rightcontext))
      possiblescreenname := "";

    context->data.possiblescreenname := possiblescreenname;
  }

  MACRO ExtractUrlsWithIndices_Callback(OBJECT context, STRING asciidomain, STRING ARRAY params, INTEGER pos, STRING input)
  {
    INTEGER asciistartposition := SearchSubstring(input, asciidomain, context->data.asciiendposition);
    context->data.asciiendposition := asciistartposition + Length(asciidomain);
    context->data.lasturl :=
      [ url := asciidomain
      , display_url := asciidomain
      , indices := [ INTEGER(context->data.startposition + asciistartposition), context->data.startposition + context->data.asciiendposition ]
      ];
    IF (context->data.path != ""
        OR this->regexen.validspecialshortdomain->Test(asciiDomain)
        OR NOT this->regexen.invalidshortdomain->Test(asciiDomain))
    {
      INSERT context->data.lasturl INTO context->data.urls AT END;
    }
  }

  MACRO ExtractHashtagsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING hash := params[1];
    STRING hashtext := params[2];

    STRING after := Substring(chunk, offset_ + Length(match));
    IF (this->regexen.endhashtagmatch->Test(after))
      RETURN;
    INTEGER startposition := offset_ + Length(before);
    INTEGER endposition := startposition + Length(hashtext) + 1;
    INSERT [ hashtag := hashtext
           , indices := [ startposition, endposition ]
           ] INTO context->data.tags AT END;
  }

  MACRO ExtractCashtagsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING dollar := params[1];
    STRING cashtag := params[2];

    INTEGER startposition := offset_ + Length(before);
    INTEGER endposition := startposition + Length(cashtag) + 1;
    INSERT [ cashtag := cashtag
           , indices := [ startposition, endposition ]
           ] INTO context->data.tags AT END;
  }

  BOOLEAN FUNCTION CompareEntities(RECORD a, RECORD b)
  {
    RETURN a.indices[0] < b.indices[0];
  }

  STRING FUNCTION NoEscape(STRING text)
  {
    RETURN text;
  }

  VARIANT FUNCTION GetAttribute(RECORD ARRAY attributes, STRING name)
  {
    RETURN (SELECT value FROM attributes WHERE COLUMN name = VAR name).value;
  }

  RECORD ARRAY FUNCTION SetAttribute(RECORD ARRAY attributes, STRING name, VARIANT value)
  {
    DELETE FROM attributes WHERE COLUMN name = VAR name;
    INSERT [ name := name, value := value ] INTO attributes AT END;
    RETURN attributes;
  }
>;

twttr := NEW TwttrObject;
