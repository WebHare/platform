<?wh
/*
  This is a HareScript port of the twitter-text.js library. For now it
  implements just enough to be able to offer the extraction functions:
    ExtractEntitiesWithIndices
    ExtractMentions
    ExtractMentionsWithIndices
    ExtractMentionsOrListsWithIndices
    ExtractReplies
    ExtractUrls
    ExtractUrlsWithIndices
    ExtractHashtags
    ExtractHashtagsWithIndices
    ExtractCashtags
    ExtractCashtagsWithIndices

  In addition, the following function is added, which shortens a URL for display
  purposes:
    GetDisplayUrl

  Usage (the API is exposed as twttr->txt, just like it's exposed in JavaScript as twttr.txt):
    LOADLIB "mod::socialite/lib/twitter-text.whlib";
    RECORD ARRAY entities := twttr->txt->ExtractEntitiesWithIndices("some text");
*/
/*!
 * twitter-text-js 1.9.4
 *
 * Copyright 2012 Twitter, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this work except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 */
LOADLIB "wh::regex.whlib";
LOADLIB "wh::util/algorithms.whlib";

PUBLIC OBJECT twttr;

// Print and test all regular expressions and terminate
BOOLEAN test_regex;// := TRUE;

// Create a cell if it doesn't exist, update it if it does
RECORD FUNCTION CellCreate(RECORD rec, STRING cellname, VARIANT value)
{
  IF (CellExists(rec, cellname))
    rec := CellDelete(rec, cellname);
  RETURN CellInsert(rec, cellname, value);
}

// Make sure the cell exists and has a value
RECORD FUNCTION CellEnsure(RECORD rec, STRING cellname, VARIANT defaultvalue)
{
  IF (CellExists(rec, cellname))
    RETURN CellUpdate(rec, cellname, GetCell(rec, cellname) ?? defaultvalue);
  RETURN CellInsert(rec, cellname, defaultvalue);
}

// Sort using a comparator function
RECORD ARRAY FUNCTION Sort(RECORD ARRAY input, FUNCTION PTR compare)
{
  IF (compare = DEFAULT FUNCTION PTR)
    RETURN input;
  RECORD ARRAY output;
  FOREVERY (RECORD rec FROM input)
    INSERT rec INTO output AT LowerBound(output, rec, compare).position;
  RETURN output;
}

// Pass context to callback functions by reference, so the data can be updated
OBJECTTYPE CallbackContext
< PUBLIC RECORD data;
  MACRO NEW(RECORD data)
  {
    this->data := data;
  }
>;

OBJECT Supplant_regex;
Supplant_regex := NEW JSRegEx("#\\{(\\w+)\\}", "g");

OBJECTTYPE TwttrObject
<
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT pvt_txt;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  PUBLIC PROPERTY txt(pvt_txt, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    this->pvt_txt := NEW TwttrTxtObject;
  }
>;

OBJECTTYPE TwttrTxtObject
<
  // ---------------------------------------------------------------------------
  //
  // Public variables
  //

  PUBLIC RECORD regexen;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW()
  {
    STRING ARRAY UNICODE_SPACES :=
      [ UCToString(0x0020) // White_Space # Zs       SPACE
      , UCToString(0x0085) // White_Space # Cc       <control-0085>
      , UCToString(0x00A0) // White_Space # Zs       NO-BREAK SPACE
      , UCToString(0x1680) // White_Space # Zs       OGHAM SPACE MARK
      , UCToString(0x180E) // White_Space # Zs       MONGOLIAN VOWEL SEPARATOR
      , UCToString(0x2028) // White_Space # Zl       LINE SEPARATOR
      , UCToString(0x2029) // White_Space # Zp       PARAGRAPH SEPARATOR
      , UCToString(0x202F) // White_Space # Zs       NARROW NO-BREAK SPACE
      , UCToString(0x205F) // White_Space # Zs       MEDIUM MATHEMATICAL SPACE
      , UCToString(0x3000) // White_Space # Zs       IDEOGRAPHIC SPACE
      ];
    UNICODE_SPACES := this->AddCharsToCharClass(UNICODE_SPACES, "\u0009", "\u000D"); // White_Space # Cc   [5] <control-0009>..<control-000D>
    UNICODE_SPACES := this->AddCharsToCharClass(UNICODE_SPACES, "\u2000", "\u200A"); // White_Space # Zs  [11] EN QUAD..HAIR SPACE

    STRING ARRAY INVALID_CHARS :=
      [ UCToString(0xFFFE)
      , UCToString(0xFEFF) // BOM
      // Not allowed by boost::regex, gives "Invalid UTF-8 sequence" error
      // , UCToString(0xFFFF) // Special
      ];
    INVALID_CHARS := this->AddCharsToCharClass(INVALID_CHARS, "\u202A", "\u202E"); // Directional change

    INSERT CELL spaces_group := this->RegexSupplant(Detokenize(UNICODE_SPACES, "")) INTO this->regexen;
    INSERT CELL spaces := this->RegexSupplant("[" || Detokenize(UNICODE_SPACES, "") || "]") INTO this->regexen;
    INSERT CELL invalid_chars_group := this->RegexSupplant(Detokenize(INVALID_CHARS, "")) INTO this->regexen;
    /* B-Lex: Moved - to start of regex, this string is also used in a character class, and
       Harescript uses C++11 regex which doesn't support escaping - within classes
    */
    INSERT CELL punct := NEW JSRegEx("\\-\\!'#%&'\\(\\)\\*\\+,\\\\\\.\\/:;<=>\\?@\\[\\]\\^_\\{\\|\\}~\\$") INTO this->regexen;
    INSERT CELL rtl_chars := NEW JSRegEx("[\u0600-\u06FF]|[\u0750-\u077F]|[\u0590-\u05FF]|[\uFE70-\uFEFF]", "mg") INTO this->regexen;
    INSERT CELL non_bmp_code_pairs := NEW JSRegEx("[\uD800-\uDBFF][\uDC00-\uDFFF]", "mg") INTO this->regexen;

    STRING ARRAY nonlatinhashtagchars;
    // Cyrillic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0400", "\u04FF"); // Cyrillic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0500", "\u0527"); // Cyrillic Supplement
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u2DE0", "\u2DFF"); // Cyrillic Extended A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uA640", "\uA69F"); // Cyrillic Extended B
    // Hebrew
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0591", "\u05BF"); // Hebrew
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C1", "\u05C2");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C4", "\u05C5");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05C7", "\u05C7");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05D0", "\u05EA");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u05F0", "\u05F4");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB12", "\uFB28"); // Hebrew Presentation Forms
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB2A", "\uFB36");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB38", "\uFB3C");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB3E", "\uFB3E");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB40", "\uFB41");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB43", "\uFB44");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB46", "\uFB4F");
    // Arabic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0610", "\u061A"); // Arabic
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0620", "\u065F");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u066E", "\u06D3");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06D5", "\u06DC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06DE", "\u06E8");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06EA", "\u06EF");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06FA", "\u06FC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u06FF", "\u06FF");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0750", "\u077F"); // Arabic Supplement
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08A0", "\u08A0"); // Arabic Extended A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08A2", "\u08AC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u08E4", "\u08FE");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFB50", "\uFBB1"); // Arabic Pres. Forms A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFBD3", "\uFD3D");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFD50", "\uFD8F");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFD92", "\uFDC7");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFDF0", "\uFDFB");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFE70", "\uFE74"); // Arabic Pres. Forms B
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFE76", "\uFEFC");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u200C", "\u200C"); // Zero-Width Non-Joiner
    // Thai
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0E01", "\u0E3A");
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u0E40", "\u0E4E");
    // Hangul (Korean)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u1100", "\u11FF"); // Hangul Jamo
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3130", "\u3185"); // Hangul Compatibility Jamo
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uA960", "\uA97F"); // Hangul Jamo Extended-A
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uAC00", "\uD7AF"); // Hangul Syllables
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD7B0", "\uD7FF"); // Hangul Jamo Extended-B
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFFA1", "\uFFDC"); // half-width Hangul
    // Japanese and Chinese
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u30A1", "\u30FA"); // Katakana (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u30FC", "\u30FE"); // Katakana Chouon and iteration marks (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF66", "\uFF9F"); // Katakana (half-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF70", "\uFF70"); // Katakana Chouon (half-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF10", "\uFF19"); // \
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF21", "\uFF3A"); //  - Latin (full-width)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uFF41", "\uFF5A"); // /
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3041", "\u3096"); // Hiragana
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3099", "\u309E"); // Hiragana voicing and iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3400", "\u4DBF"); // Kanji (CJK Extension A)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u4E00", "\u9FFF"); // Kanji (Unified)
    // Converted to UTF-16 surrogate pairs for HareScript
    // -- Disabled as it breaks the Regex.
    //nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD840\uDC00", "\uD869\uDEDF"); // Kanji (CJK Extension B)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD869\uDF00", "\uD86D\uDF3F"); // Kanji (CJK Extension C)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD86D\uDF40", "\uD86E\uDC1F"); // Kanji (CJK Extension D)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\uD87E\uDC00", "\uD87E\uDE1F"); // Kanji (CJK supplement)
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3003", "\u3003"); // Kanji iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u3005", "\u3005"); // Kanji iteration mark
    nonlatinhashtagchars := this->AddCharsToCharClass(nonlatinhashtagchars, "\u303B", "\u303B"); // Han iteration mark
    INSERT CELL nonlatinhashtagchars := this->RegexSupplant(Detokenize(nonlatinhashtagchars, "")) INTO this->regexen;

    STRING ARRAY latinaccentchars;
    // Latin accented characters (subtracted 0xD7 from the range, it's a confusable multiplication sign. Looks like "x")
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00C0", "\u00D6");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00D8", "\u00DE");
    // Split the range on \u00DF as a continuous range seems to trigger an "Invalid character class name, collating name, or
    // character range" exception from boost regex.
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00DF", "\u00F6");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u00F8", "\u00FF");
    // Latin Extended A and B
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0100", "\u024F");
    // assorted IPA Extensions
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0253", "\u0254");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0256", "\u0257");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0259", "\u0259");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u025B", "\u025B");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0263", "\u0263");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0268", "\u0268");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u026F", "\u026F");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0272", "\u0272");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0289", "\u0289");
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u028B", "\u028B");
    // Okina for Hawaiian (it *is* a letter character)
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u02BB", "\u02BB");
    // Combining diacritics
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u0300", "\u036F");
    // Latin Extended Additional
    latinaccentchars := this->AddCharsToCharClass(latinaccentchars, "\u1E00", "\u1EFF");
    INSERT CELL latinaccentchars := this->RegexSupplant(Detokenize(latinaccentchars, "")) INTO this->regexen;

    // A hashtag must contain characters, numbers and underscores, but not all numbers.
    INSERT CELL hashsigns := NEW JSRegEx("[#＃]") INTO this->regexen;
    INSERT CELL hashtagalpha := this->RegexSupplant(NEW JSRegEx("[a-z_#{latinAccentChars}#{nonLatinHashtagChars}]", "i")) INTO this->regexen;
    INSERT CELL hashtagalphanumeric := this->RegexSupplant(NEW JSRegEx("[a-z0-9_#{latinAccentChars}#{nonLatinHashtagChars}]", "i")) INTO this->regexen;
    INSERT CELL endhashtagmatch := this->RegexSupplant(NEW JSRegEx("^(?:#{hashSigns}|:\\/\\/)")) INTO this->regexen;
    INSERT CELL hashtagboundary := this->RegexSupplant(NEW JSRegEx("(?:^|$|[^&a-z0-9_#{latinAccentChars}#{nonLatinHashtagChars}])")) INTO this->regexen;
    INSERT CELL validhashtag := this->RegexSupplant(NEW JSRegEx("(#{hashtagBoundary})(#{hashSigns})(#{hashtagAlphaNumeric}*#{hashtagAlpha}#{hashtagAlphaNumeric}*)", "gi")) INTO this->regexen;

    // Mention related regex collection
    INSERT CELL validmentionprecedingchars := NEW JSRegEx("(?:^|[^a-zA-Z0-9_!#$%&*@＠]|(?:rt|RT|rT|Rt):?)") INTO this->regexen;
    INSERT CELL atsigns := NEW JSRegEx("[@＠]") INTO this->regexen;
    INSERT CELL validmentionorlist := this->RegexSupplant(
      '(#{validMentionPrecedingChars})' ||  // $1: Preceding character
      '(#{atSigns})' ||                     // $2: At mark
      '([a-zA-Z0-9_]{1,20})' ||             // $3: Screen name
      '(\\/[a-zA-Z][a-zA-Z0-9_\\-]{0,24})?' // $4: List (optional)
    , 'g') INTO this->regexen;
    INSERT CELL validreply := this->RegexSupplant(NEW JSRegEx("^(?:#{spaces})*#{atSigns}([a-zA-Z0-9_]{1,20})")) INTO this->regexen;
    INSERT CELL endmentionmatch := this->RegexSupplant(NEW JSRegEx("^(?:#{atSigns}|[#{latinAccentChars}]|:\\/\\/)")) INTO this->regexen;

    // URL related regex collection
    INSERT CELL validurlprecedingchars := this->RegexSupplant(NEW JSRegEx("(?:[^A-Za-z0-9@＠$#＃#{invalid_chars_group}]|^)")) INTO this->regexen;
    INSERT CELL invalidurlwithoutprotocolprecedingchars := NEW JSRegEx("[-_.\\/]$") INTO this->regexen;
    INSERT CELL invaliddomainchars := this->StringSupplant("#{punct}#{spaces_group}#{invalid_chars_group}", this->regexen) INTO this->regexen;
    INSERT CELL validdomainchars := this->RegexSupplant(NEW JSRegEx("[^#{invalidDomainChars}]")) INTO this->regexen;
    INSERT CELL validsubdomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validDomainChars}(?:[_-]|#{validDomainChars})*)?#{validDomainChars}\\.)")) INTO this->regexen;
    INSERT CELL validdomainname := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validDomainChars}(?:-|#{validDomainChars})*)?#{validDomainChars}\\.)")) INTO this->regexen;
    INSERT CELL validgtld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:' ||
      'academy|accountants|active|actor|aero|agency|airforce|archi|army|arpa|asia|associates|attorney|audio|autos|axa|' ||
      'bar|bargains|bayern|beer|berlin|best|bid|bike|bio|biz|black|blackfriday|blue|bmw|boutique|brussels|build|' ||
      'builders|buzz|bzh|cab|camera|camp|cancerresearch|capetown|capital|cards|care|career|careers|cash|cat|catering|' ||
      'center|ceo|cheap|christmas|church|citic|claims|cleaning|clinic|clothing|club|codes|coffee|college|cologne|com|' ||
      'community|company|computer|condos|construction|consulting|contractors|cooking|cool|coop|country|credit|' ||
      'creditcard|cruises|cuisinella|dance|dating|degree|democrat|dental|dentist|desi|diamonds|digital|direct|' ||
      'directory|discount|dnp|domains|durban|edu|education|email|engineer|engineering|enterprises|equipment|estate|eus|' ||
      'events|exchange|expert|exposed|fail|farm|feedback|finance|financial|fish|fishing|fitness|flights|florist|foo|' ||
      'foundation|frogans|fund|furniture|futbol|gal|gallery|gift|gives|glass|global|globo|gmo|gop|gov|graphics|gratis|' ||
      'green|gripe|guide|guitars|guru|hamburg|haus|hiphop|hiv|holdings|holiday|homes|horse|host|house|immobilien|' ||
      'industries|info|ink|institute|insure|int|international|investments|jetzt|jobs|joburg|juegos|kaufen|kim|kitchen|' ||
      'kiwi|koeln|kred|land|lawyer|lease|lgbt|life|lighting|limited|limo|link|loans|london|lotto|luxe|luxury|maison|' ||
      'management|mango|market|marketing|media|meet|menu|miami|mil|mini|mobi|moda|moe|monash|mortgage|moscow|' ||
      'motorcycles|museum|nagoya|name|navy|net|neustar|nhk|ninja|nyc|okinawa|onl|org|organic|ovh|paris|partners|parts|' ||
      'photo|photography|photos|physio|pics|pictures|pink|place|plumbing|post|press|pro|productions|properties|pub|' ||
      'qpon|quebec|recipes|red|rehab|reise|reisen|ren|rentals|repair|report|republican|rest|reviews|rich|rio|rocks|' ||
      'rodeo|ruhr|ryukyu|saarland|schmidt|schule|scot|services|sexy|shiksha|shoes|singles|social|software|sohu|solar|' ||
      'solutions|soy|space|spiegel|supplies|supply|support|surf|surgery|suzuki|systems|tattoo|tax|technology|tel|' ||
      'tienda|tips|tirol|today|tokyo|tools|town|toys|trade|training|travel|university|uno|vacations|vegas|ventures|' ||
      'versicherung|vet|viajes|villas|vision|vlaanderen|vodka|vote|voting|voto|voyage|wang|watch|webcam|website|wed|' ||
      'wien|wiki|works|wtc|wtf|xxx|xyz|yachts|yokohama|zone|дети|москва|онлайн|орг|сайт|بازار|شبكة|موقع|संगठन|みんな|世界|' ||
      '中信|中文网|公司|公益|商城|商标|在线|我爱你|政务|机构|游戏|移动|组织机构|网址|网络|集团|삼성' ||
      ')(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validcctld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:' ||
      'ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|ax|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bl|bm|bn|bo|bq|br|bs|bt|bv|bw|' ||
      'by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cw|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|eu|fi|fj|' ||
      'fk|fm|fo|fr|ga|gb|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|' ||
      'is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|me|mf|mg|mh|mk|ml|' ||
      'mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|' ||
      'ps|pt|pw|py|qa|re|ro|rs|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|ss|st|su|sv|sx|sy|sz|tc|td|tf|tg|th|' ||
      'tj|tk|tl|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|za|zm|zw|мкд|мон|рф|' ||
      'срб|укр|қаз|الاردن|الجزائر|السعودية|المغرب|امارات|ایران|بھارت|تونس|سودان|سورية|عمان|فلسطين|قطر|مصر|مليسيا|' ||
      'پاکستان|भारत|বাংলা|ভারত|ਭਾਰਤ|ભારત|இந்தியா|இலங்கை|சிங்கப்பூர்|భారత్|ලංකා|ไทย|გე|中国|中國|台湾|台灣|新加坡|香港|한국' ||
      ')(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validpunycode := this->RegexSupplant(NEW JSRegEx("(?:xn--[0-9a-z]+)")) INTO this->regexen;
    INSERT CELL validspecialcctld := this->RegexSupplant(NEW JSRegEx(
      '(?:(?:co|tv)(?=[^0-9a-zA-Z@]|$))')) INTO this->regexen;
    INSERT CELL validdomain := this->RegexSupplant(NEW JSRegEx("(?:#{validSubdomain}*#{validDomainName}(?:#{validGTLD}|#{validCCTLD}|#{validPunycode}))")) INTO this->regexen;
    INSERT CELL validasciidomain := this->RegexSupplant(NEW JSRegEx("(?:(?:[\\-a-z0-9#{latinAccentChars}]+)\\.)+(?:#{validGTLD}|#{validCCTLD}|#{validPunycode})", "gi")) INTO this->regexen;
    INSERT CELL invalidshortdomain := this->RegexSupplant(NEW JSRegEx("^#{validDomainName}#{validCCTLD}$", "i")) INTO this->regexen;
    INSERT CELL validspecialshortdomain := this->RegexSupplant(NEW JSRegEx("^#{validDomainName}#{validSpecialCCTLD}$", "i")) INTO this->regexen;

    INSERT CELL validportnumber := this->RegexSupplant(NEW JSRegEx("[0-9]+")) INTO this->regexen;

    INSERT CELL validgeneralurlpathchars := this->RegexSupplant(NEW JSRegEx("[a-z0-9!\\*';:=\\+,\\.\\$\\/%#\\[\\]\\-_~@|&#{latinAccentChars}]", "i")) INTO this->regexen;
    // Allow URL paths to contain up to two nested levels of balanced parens
    //  1. Used in Wikipedia URLs like /Primer_(film)
    //  2. Used in IIS sessions like /S(dfd346)/
    //  3. Used in Rdio URLs like /track/We_Up_(Album_Version_(Edited))/
    INSERT CELL validurlbalancedparens := this->RegexSupplant(
      '\\('                                   ||
        '(?:'                                 ||
          '#{validGeneralUrlPathChars}+'      ||
          '|'                                 ||
          // allow one nested level of balanced parentheses
          '(?:'                               ||
            '#{validGeneralUrlPathChars}*'    ||
            '\\('                             ||
              '#{validGeneralUrlPathChars}+'  ||
            '\\)'                             ||
            '#{validGeneralUrlPathChars}*'    ||
          ')'                                 ||
        ')'                                   ||
      '\\)'
    , 'i') INTO this->regexen;
    // Valid end-of-path chracters (so /foo. does not gobble the period).
    // 1. Allow =&# for empty URL parameters and other URL-join artifacts
    INSERT CELL validurlpathendingchars := this->RegexSupplant(NEW JSRegEx("[\\+\\-a-z0-9=_#\\/#{latinAccentChars}]|(?:#{validUrlBalancedParens})", "i")) INTO this->regexen;
    // Allow @ in a url, but only in the middle. Catch things like http://example.com/@user/
    INSERT CELL validurlpath := this->RegexSupplant('(?:' ||
      '(?:' ||
        '#{validGeneralUrlPathChars}*' ||
          '(?:#{validUrlBalancedParens}#{validGeneralUrlPathChars}*)*' ||
          '#{validUrlPathEndingChars}'||
        ')|(?:@#{validGeneralUrlPathChars}+\\/)'||
      ')', 'i') INTO this->regexen;

    INSERT CELL validurlquerychars := NEW JSRegEx("[a-z0-9!?\\*'@\\(\\);:&=\\+\\$\\/%#\\[\\]\\-_\\.,~|]", "i") INTO this->regexen;
    INSERT CELL validurlqueryendingchars := NEW JSRegEx("[a-z0-9_&=#\\/]", "i") INTO this->regexen;
    INSERT CELL extracturl := this->RegexSupplant(
      '('                                                            || // $1 total match
        '(#{validUrlPrecedingChars})'                                || // $2 Preceeding chracter
        '('                                                          || // $3 URL
          '(https?:\\/\\/)?'                                         || // $4 Protocol (optional)
          '(#{validDomain})'                                         || // $5 Domain(s)
          '(?::(#{validPortNumber}))?'                               || // $6 Port number (optional)
          '(\\/#{validUrlPath}*)?'                                   || // $7 URL Path
          '(\\?#{validUrlQueryChars}*#{validUrlQueryEndingChars})?'  || // $8 Query String
        ')'                                                          ||
      ')'
    , 'gi') INTO this->regexen;

    INSERT CELL validtcourl := NEW JSRegEx("^https?:\\/\\/t\\.co\\/[a-z0-9]+", "i") INTO this->regexen;
    INSERT CELL urlhasprotocol := NEW JSRegEx("^https?:\\/\\/", "i") INTO this->regexen;
    INSERT CELL urlhashttps := NEW JSRegEx("^https:\\/\\/", "i") INTO this->regexen;

    // cashtag related regex
    INSERT CELL cashtag := NEW JSRegEx("[a-z]{1,6}(?:[._][a-z]{1,2})?", "i") INTO this->regexen;
    INSERT CELL validcashtag := this->RegexSupplant('(^|#{spaces})(\\$)(#{cashtag})(?=$|\\s|[#{punct}])', 'gi') INTO this->regexen;

    // These URL validation pattern strings are based on the ABNF from RFC 3986
    INSERT CELL validateurlunreserved := NEW JSRegEx("[a-z0-9\\-._~]", "i") INTO this->regexen;
    INSERT CELL validateurlpctencoded := NEW JSRegEx("(?:%[0-9a-f]{2})", "i") INTO this->regexen;
    INSERT CELL validateurlsubdelims := NEW JSRegEx("[!$&'()*+,;=]", "i") INTO this->regexen;
    INSERT CELL validateurlpchar := this->RegexSupplant('(?:' ||
      '#{validateUrlUnreserved}|' ||
      '#{validateUrlPctEncoded}|' ||
      '#{validateUrlSubDelims}|' ||
      '[:|@]' ||
    ')', 'i') INTO this->regexen;

    INSERT CELL validateurlscheme := NEW JSRegEx("(?:[a-z][a-z0-9+\\-.]*)", "i") INTO this->regexen;
    INSERT CELL validateurluserinfo := this->RegexSupplant('(?:' ||
      '#{validateUrlUnreserved}|' ||
      '#{validateUrlPctEncoded}|' ||
      '#{validateUrlSubDelims}|' ||
      ':' ||
    ')*', 'i') INTO this->regexen;

    INSERT CELL validateurldecoctet := NEW JSRegEx("(?:[0-9]|(?:[1-9][0-9])|(?:1[0-9]{2})|(?:2[0-4][0-9])|(?:25[0-5]))", "i") INTO this->regexen;
    INSERT CELL validateurlipv4 := this->RegexSupplant(NEW JSRegEx("(?:#{validateUrlDecOctet}(?:\\.#{validateUrlDecOctet}){3})", "i")) INTO this->regexen;

    // Punting on real IPv6 validation for now
    INSERT CELL validateurlipv6 := NEW JSRegEx("(?:\\[[a-f0-9:\\.]+\\])", "i") INTO this->regexen;

    // Also punting on IPvFuture for now
    INSERT CELL validateurlip := this->RegexSupplant('(?:' ||
      '#{validateUrlIpv4}|' ||
      '#{validateUrlIpv6}' ||
    ')', 'i') INTO this->regexen;

    // This is more strict than the rfc specifies
    INSERT CELL validateurlsubdomainsegment := NEW JSRegEx("(?:[a-z0-9](?:[a-z0-9_\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomainsegment := NEW JSRegEx("(?:[a-z0-9](?:[a-z0-9\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomaintld := NEW JSRegEx("(?:[a-z](?:[a-z0-9\\-]*[a-z0-9])?)", "i") INTO this->regexen;
    INSERT CELL validateurldomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validateUrlSubDomainSegment}\\.)*(?:#{validateUrlDomainSegment}\\.)#{validateUrlDomainTld})", "i")) INTO this->regexen;

    INSERT CELL validateurlhost := this->RegexSupplant('(?:' ||
      '#{validateUrlIp}|' ||
      '#{validateUrlDomain}' ||
    ')', 'i') INTO this->regexen;

    // Unencoded internationalized domains - this doesn't check for invalid UTF-8 sequences
    INSERT CELL validateurlunicodesubdomainsegment := NEW JSRegEx("(?:(?:[a-z0-9]|[^\u0000-\u007F])(?:(?:[a-z0-9_\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomainsegment := NEW JSRegEx("(?:(?:[a-z0-9]|[^\u0000-\u007F])(?:(?:[a-z0-9\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomaintld := NEW JSRegEx("(?:(?:[a-z]|[^\u0000-\u007F])(?:(?:[a-z0-9\\-]|[^\u0000-\u007F])*(?:[a-z0-9]|[^\u0000-\u007F]))?)", "i") INTO this->regexen;
    INSERT CELL validateurlunicodedomain := this->RegexSupplant(NEW JSRegEx("(?:(?:#{validateUrlUnicodeSubDomainSegment}\\.)*(?:#{validateUrlUnicodeDomainSegment}\\.)#{validateUrlUnicodeDomainTld})", "i")) INTO this->regexen;

    INSERT CELL validateurlunicodehost := this->RegexSupplant('(?:' ||
      '#{validateUrlIp}|' ||
      '#{validateUrlUnicodeDomain}' ||
    ')', 'i') INTO this->regexen;

    INSERT CELL validateurlport := NEW JSRegEx("[0-9]{1,5}") INTO this->regexen;

    INSERT CELL validateurlunicodeauthority := this->RegexSupplant(
      '(?:(#{validateUrlUserinfo})@)?'  || // $1 userinfo
      '(#{validateUrlUnicodeHost})'     || // $2 host
      '(?::(#{validateUrlPort}))?'         //$3 port
    , "i") INTO this->regexen;

    INSERT CELL validateurlauthority := this->RegexSupplant(
      '(?:(#{validateUrlUserinfo})@)?' || // $1 userinfo
      '(#{validateUrlHost})'           || // $2 host
      '(?::(#{validateUrlPort}))?'        // $3 port
    , "i") INTO this->regexen;

    INSERT CELL validateurlpath := this->RegexSupplant(NEW JSRegEx("(\\/#{validateUrlPchar}*)*", "i")) INTO this->regexen;
    INSERT CELL validateurlquery := this->RegexSupplant(NEW JSRegEx("(#{validateUrlPchar}|\\/|\\?)*", "i")) INTO this->regexen;
    INSERT CELL validateurlfragment := this->RegexSupplant(NEW JSRegEx("(#{validateUrlPchar}|\\/|\\?)*", "i")) INTO this->regexen;

    // Modified version of RFC 3986 Appendix B
    INSERT CELL validateurlunencoded := this->RegexSupplant(
      '^'                               || // Full URL
      '(?:'                             ||
        '([^:/?#]+):\\/\\/'             || // $1 Scheme
      ')?'                              ||
      '([^/?#]*)'                       || // $2 Authority
      '([^?#]*)'                        || // $3 Path
      '(?:'                             ||
        '\\?([^#]*)'                    || // $4 Query
      ')?'                              ||
      '(?:'                             ||
        '#(.*)'                         || // $5 Fragment
      ')?$'
    , "i") INTO this->regexen;

    // Print and test all regular expressions and terminate
    IF (test_regex)
    {
      FOREVERY (RECORD r FROM UnpackRecord(this->regexen))
      {
        Print(r.name || "\n");
        IF (TypeID(r.value) = TypeID(OBJECT))
        {
          Print("RegExp: '" || EncodeJava(r.value->source) || "'");
          r.value->Test("");
        }
        ELSE
        {
          Print("String: '" || EncodeJava(r.value) || "'");
          (NEW JSRegEx(r.value))->Test("");
        }
        Print("\n\n");
      }
      TerminateScript();
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  // Builds a RegExp
  PUBLIC OBJECT FUNCTION RegexSupplant(VARIANT regex, STRING flags DEFAULTSTO "")
  {
    STRING pattern;
    IF (TypeID(regex) = TypeID(OBJECT))
    {
      IF (regex->global AND flags NOT LIKE "*g*")
        flags := flags || "g";
      IF (regex->ignorecase AND flags NOT LIKE "*i*")
        flags := flags || "i";
      IF (regex->multiline AND flags NOT LIKE "*m*")
        flags := flags || "m";

      pattern := regex->source;
    }
    ELSE IF (TypeID(regex) = TypeID(STRING))
      pattern := regex;
    ELSE
      THROW NEW Exception("Expected regular expresseion object or pattern");

    RETURN NEW JSRegEx(Supplant_regex->ReplaceCallback(pattern, PTR this->RegexSupplant_Callback), flags);
  }

  // simple string interpolation
  PUBLIC STRING FUNCTION StringSupplant(STRING str, RECORD values_)
  {
    RETURN Supplant_regex->ReplaceCallback(str, PTR this->StringSupplant_Callback(values_, #1, #2, #3, #4));
  }

  PUBLIC STRING ARRAY FUNCTION AddCharsToCharClass(STRING ARRAY charclass, STRING start, STRING end_)
  {
    STRING s := start;
    IF (end_ != start)
      s := s || "-" || end_;
    INSERT s INTO charclass AT END;
    RETURN charclass;
  }

  PUBLIC RECORD ARRAY FUNCTION RemoveOverlappingEntities(RECORD ARRAY entities)
  {
    entities := Sort(entities, PTR this->CompareEntities);

    RECORD prev;
    RECORD ARRAY result;
    FOREVERY (RECORD entity FROM entities)
    {
      IF (#entity = 0 OR entity.indices[0] >= prev.indices[1])
      {
        prev := entity;
        INSERT entity INTO result AT END;
      }
    }
    RETURN result;
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractEntitiesWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RECORD ARRAY entities := this->ExtractUrlsWithIndices(text, options)
                             CONCAT
                             this->ExtractMentionsOrListsWithIndices(text)
                             CONCAT
                             this->ExtractHashtagsWithIndices(text, [ checkurloverlap := FALSE ])
                             CONCAT
                             this->ExtractCashtagsWithIndices(text);

    IF (Length(entities) = 0)
      RETURN DEFAULT RECORD ARRAY;

    entities := this->RemoveOverlappingEntities(entities);
    RETURN entities;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractMentions(STRING text)
  {
    RETURN SELECT AS STRING ARRAY screenname
             FROM this->ExtractMentionsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractMentionsWithIndices(STRING text)
  {
    RETURN SELECT screenname
                , indices
             FROM this->ExtractMentionsOrListsWithIndices(text) AS mentionsorlists
            WHERE CellExists(mentionsorlists, "listslug") ? listslug = "" : TRUE;
  }

  /**
   * Extract list or user mentions.
   * (Presence of listSlug indicates a list)
   */
  PUBLIC RECORD ARRAY FUNCTION ExtractMentionsOrListsWithIndices(STRING text)
  {
    IF (text = "" OR NOT this->regexen.atsigns->Test(text))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ possiblenames := DEFAULT RECORD ARRAY ]);

    this->regexen.validmentionorlist->ReplaceCallback(text, PTR this->ExtractMentionsOrListsWithIndices_Callback(context, #1, #2, #3, #4));

    RETURN context->data.possiblenames;
  }

  PUBLIC STRING FUNCTION ExtractReplies(STRING text)
  {
    IF (text = "")
      RETURN "";

    OBJECT context := NEW CallbackContext([ possiblescreenname := "" ]);

    this->regexen.validreply->ReplaceCallback(text, PTR this->ExtractReplies_Callback(context, #1, #2, #3, #4));

    RETURN context->data.possiblescreenname;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractUrls(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    RETURN SELECT AS STRING ARRAY url
             FROM this->ExtractUrlsWithIndices(text, options);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractUrlsWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF (NOT RecordExists(options))
      options := [ extracturlswithoutprotocol := TRUE ];
    IF (text = "" OR (options.extracturlswithoutprotocol ? text NOT LIKE "*.*" : text NOT LIKE "*:*"))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ lasturl := DEFAULT RECORD
                                          , startposition := 0
                                          , asciiendposition := 0
                                          , path := ""
                                          , urls := DEFAULT RECORD ARRAY
                                          ]);

    RECORD ARRAY matches := this->regexen.extracturl->Exec(text);
    WHILE (RecordExists(matches))
    {
      STRING before := matches[2].value
           , url := matches[3].value
           , protocol := matches[4].value
           , domain := matches[5].value
           , path := matches[7].value;
      INTEGER endposition := this->regexen.extracturl->lastindex;
      context->data.startposition := endposition - Length(url);

      // if protocol is missing and domain contains non-ASCII characters,
      // extract ASCII-only domains.
      IF (protocol = "")
      {
        IF (NOT options.extracturlswithoutprotocol
            OR this->regexen.invalidurlwithoutprotocolprecedingchars->Test(before))
          CONTINUE;
        context->data.lasturl := DEFAULT RECORD;
        context->data.asciiendposition := 0;
        context->data.path := path;
        this->regexen.validasciidomain->ReplaceCallback(domain, PTR this->ExtractUrlsWithIndices_Callback(context, #1, #2, #3, #4));

        // no ASCII-only domain found. Skip the entire URL.
        IF (NOT RecordExists(context->data.lasturl))
          CONTINUE;

        // lastUrl only contains domain. Need to add path and query if they exist.
        IF (path != "")
        {
          context->data.lasturl.url := Substitute(url, domain, context->data.lasturl.url);
          context->data.lasturl.indices[1] := endposition;
        }
      }
      ELSE
      {
        // In the case of t.co URLs, don't allow additional path characters.
        RECORD lastmatch := this->regexen.validtcourl->Exec(url);
        IF (RecordExists(lastmatch))
        {
          url := lastmatch.value;
          endposition := context->data.startposition + Length(url);
        }
        INSERT [ url := url
               , display_url := this->GetDisplayUrl(url)
               , indices := [ INTEGER(context->data.startposition), endposition ]
               ] INTO context->data.urls AT END;
      }
      matches := this->regexen.extracturl->Exec(text);
    }

    RETURN context->data.urls;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractHashtags(STRING text)
  {
    RETURN SELECT AS STRING ARRAY hashtag
             FROM this->ExtractHashtagsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractHashtagsWithIndices(STRING text, RECORD options DEFAULTSTO DEFAULT RECORD)
  {
    IF (NOT RecordExists(options))
      options := [ checkurloverlap := TRUE ];

    IF (text = "" OR NOT this->regexen.hashsigns->Test(text))
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ tags := DEFAULT RECORD ARRAY ]);

    this->regexen.validhashtag->ReplaceCallback(text, PTR this->ExtractHashtagsWithIndices_Callback(context, #1, #2, #3, #4));

    IF (options.checkurloverlap)
    {
      // also extract URL entities
      RECORD ARRAY urls := this->ExtractUrlsWithIndices(text);
      IF (Length(urls) > 0)
      {
        RECORD ARRAY entities := context->data.tags CONCAT urls;
        // remove overlap
        entities := this->RemoveOverlappingEntities(entities);
        // only push back hashtags
        context->data.tags := SELECT * FROM entities
                               WHERE CellExists(entities, "hashtag") ? hashtag != "" : FALSE; // workaround not optimizable warning
      }
    }

    RETURN context->data.tags;
  }

  PUBLIC STRING ARRAY FUNCTION ExtractCashtags(STRING text)
  {
    RETURN SELECT AS STRING ARRAY cashtag
             FROM this->ExtractCashtagsWithIndices(text);
  }

  PUBLIC RECORD ARRAY FUNCTION ExtractCashtagsWithIndices(STRING text)
  {
    IF (text = "" OR SearchSubstring(text, "$") = -1)
      RETURN DEFAULT RECORD ARRAY;

    OBJECT context := NEW CallbackContext([ tags := DEFAULT RECORD ARRAY ]);

    this->regexen.validcashtag->ReplaceCallback(text, PTR this->ExtractCashtagsWithIndices_Callback(context, #1, #2, #3, #4));

    RETURN context->data.tags;
  }

  // WebHare addition: This function mimics Twitter's display_url generation (which unfortunately isn't provided by twitter-text)
  PUBLIC STRING FUNCTION GetDisplayUrl(STRING url)
  {
    // Strip protocol
    INTEGER hoststart := SearchSubstring(url, "://");
    IF (hoststart >= 0)
      url := Substring(url, hoststart + 3);

    // Strip leading "www."
    IF (url LIKE "www.*")
      url := Substring(url, 4);

    // Limit to 30 characters
    BOOLEAN toolong := UCLength(url) > 30;
    IF (toolong)
      url := UCLeft(url, 30);

    // Strip trailing "/"
    IF (url LIKE "*/")
      url := Left(url, Length(url) - 1);

    // If characters were removed (except trailing slash), add an ellipsis
    IF (toolong)
      url := url || "\u2026";

    RETURN url;
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  STRING FUNCTION RegexSupplant_Callback(STRING match, STRING ARRAY names, INTEGER pos, STRING input)
  {
    STRING newregex;
    IF (CellExists(this->regexen, names[0]))
    {
      VARIANT value := GetCell(this->regexen, names[0]);
      IF (TypeID(value) = TypeID(STRING))
        newregex := value;
      ELSE IF (TypeID(value) = TypeID(OBJECT))
        newregex := value->source;
    }
    ELSE
      THROW NEW Exception("Referenced regex '" || names[0] || "' not found");
    RETURN newregex;
  }

  STRING FUNCTION StringSupplant_Callback(RECORD values_, STRING match, STRING ARRAY names, INTEGER pos, STRING input)
  {
    IF (CellExists(values_, names[0]))
    {
      VARIANT value := GetCell(values_, names[0]);
      IF (TypeID(value) = TypeID(STRING))
        RETURN value;
      ELSE IF (TypeID(value) = TypeID(OBJECT))
        RETURN value->source;
    }
    ELSE
      THROW NEW Exception("Referenced string '" || names[0] || "' not found");
    RETURN "";
  }

  MACRO ExtractMentionsOrListsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING atsign := params[1];
    STRING screenname := params[2];
    STRING slashlistname := params[3];

    STRING after := Substring(chunk, offset_ + Length(match));
    IF (NOT this->regexen.endmentionmatch->Test(after))
    {
      INTEGER startposition := offset_ + Length(before);
      INTEGER endposition := startposition + Length(screenname) + Length(slashlistname) + 1;
      INSERT [ screenname := screenname
             , listslug := slashlistname
             , indices := [ startposition, endposition ]
             ] INTO context->data.possiblenames AT END;
    }
  }

  MACRO ExtractReplies_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER pos, STRING input)
  {
    STRING possiblescreenname := params[0];

    STRING rightcontext := Substring(input, pos + Length(match));
    IF (this->regexen.endmentionmatch->Test(rightcontext))
      possiblescreenname := "";

    context->data.possiblescreenname := possiblescreenname;
  }

  MACRO ExtractUrlsWithIndices_Callback(OBJECT context, STRING asciidomain, STRING ARRAY params, INTEGER pos, STRING input)
  {
    INTEGER asciistartposition := SearchSubstring(input, asciidomain, context->data.asciiendposition);
    context->data.asciiendposition := asciistartposition + Length(asciidomain);
    context->data.lasturl :=
      [ url := asciidomain
      , display_url := asciidomain
      , indices := [ INTEGER(context->data.startposition + asciistartposition), context->data.startposition + context->data.asciiendposition ]
      ];
    IF (context->data.path != ""
        OR this->regexen.validspecialshortdomain->Test(asciiDomain)
        OR NOT this->regexen.invalidshortdomain->Test(asciiDomain))
    {
      INSERT context->data.lasturl INTO context->data.urls AT END;
    }
  }

  MACRO ExtractHashtagsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING hash := params[1];
    STRING hashtext := params[2];

    STRING after := Substring(chunk, offset_ + Length(match));
    IF (this->regexen.endhashtagmatch->Test(after))
      RETURN;
    INTEGER startposition := offset_ + Length(before);
    INTEGER endposition := startposition + Length(hashtext) + 1;
    INSERT [ hashtag := hashtext
           , indices := [ startposition, endposition ]
           ] INTO context->data.tags AT END;
  }

  MACRO ExtractCashtagsWithIndices_Callback(OBJECT context, STRING match, STRING ARRAY params, INTEGER offset_, STRING chunk)
  {
    STRING before := params[0];
    STRING dollar := params[1];
    STRING cashtag := params[2];

    INTEGER startposition := offset_ + Length(before);
    INTEGER endposition := startposition + Length(cashtag) + 1;
    INSERT [ cashtag := cashtag
           , indices := [ startposition, endposition ]
           ] INTO context->data.tags AT END;
  }

  BOOLEAN FUNCTION CompareEntities(RECORD a, RECORD b)
  {
    RETURN a.indices[0] < b.indices[0];
  }

  STRING FUNCTION NoEscape(STRING text)
  {
    RETURN text;
  }

  VARIANT FUNCTION GetAttribute(RECORD ARRAY attributes, STRING name)
  {
    RETURN (SELECT value FROM attributes WHERE COLUMN name = VAR name).value;
  }

  RECORD ARRAY FUNCTION SetAttribute(RECORD ARRAY attributes, STRING name, VARIANT value)
  {
    DELETE FROM attributes WHERE COLUMN name = VAR name;
    INSERT [ name := name, value := value ] INTO attributes AT END;
    RETURN attributes;
  }
>;

twttr := NEW TwttrObject;
