<?wh

LOADLIB "wh::files.whlib";
LOADLIB "wh::regex.whlib";

LOADLIB "mod::system/lib/configure.whlib";
LOADLIB "mod::system/lib/resources.whlib";

LOADLIB "mod::tollium/lib/dialogs.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";

LOADLIB "mod::tollium/lib/internal/langedit/langeditor.whlib";

PUBLIC STATIC OBJECTTYPE Main EXTEND TolliumScreenBase
<
  BOOLEAN hl_untranslated;
  BOOLEAN hl_unreferenced;

  STRING requestedmodule;
  RECORD ARRAY initialcolumns;
  RECORD ARRAY languages;

  PUBLIC MACRO Init(RECORD data)
  {
    this->initialcolumns := ^texts->columns;

    IF (data.calltype = "direct") // by URL or SendApplicationMessage()
    {
      IF (Length(data.params) >= 1)
        this->requestedmodule := data.params[0];
      ELSE IF (RecordExists(data.target))
        this->requestedmodule := data.target.module;
    }

    IF(this->requestedmodule = "")
      THROW NEW Exception("The language editor cannot be directly opened (or: specify a module name as parameter)");

    this->frame->title := this->requestedmodule || " - " || this->frame->title;

    IF(GetDtapStage() != "development" AND GetModuleInstallationRoot(this->requestedmodule) LIKE GetWebHareConfiguration().installationroot || "modules/*")
      THROW NEW Exception("Cannot edit builtin modules on non-development servers"); //TODO probably should check for docker, not for dtapstage?

    IF (NOT this->GetExclusiveAccess([langedit := this->requestedmodule]) OR NOT this->LoadModule())
    {
      this->tolliumresult:="cancel";
      RETURN;
    }

    this->SetContextView(TRUE);
  }

  MACRO OnLangfileChanged(RECORD ARRAY events)
  {
    ^reloadwarning->visible := this->contexts->^langedit->IsOutOfDate();
  }

  MACRO OnMessage(RECORD message)
  {
    IF (CellExists(message, "SEARCH"))
    {
      ^searchfor->value := message.search;
      this->DoSearch();
    }

    IF (CellExists(message, "GOTOTID"))
      this->GotoTid(message.gototid);
  }

  MACRO GotoTid(STRING tid)
  {
    IF (tid LIKE "*:*")
      tid := SubString(tid, SearchSubString(tid, ":") + 1);

    RECORD newsel := SELECT rowkey FROM ^texts->rows AS row WHERE ToUppercase(rowkey) = ToUppercase(tid) LIMIT 1;

    IF (NOT RecordExists(newsel)) //not found, but someone is convinced it should exist...  (ADDME don't reload, just add intermediate groups and final node)
    {
      IF (NOT this->LoadModule())
        RETURN;

      newsel := SELECT rowkey FROM ^texts->rows AS row WHERE ToUppercase(rowkey) = ToUppercase(tid) LIMIT 1;
    }

    IF (RecordExists(newsel))
      ^texts->selection := newsel;
  }

  MACRO SetContextView(BOOLEAN newstate)
  {
    ^contextviewpanel->visible := newstate;
    ^contextview_button->pressed := newstate;
  }

  MACRO OnTextsSelect()
  {
    RECORD selectedtext := ^texts->selection;
    IF (RecordExists(selectedtext))
    {
      ^currenttid->value := selectedtext.rowkey;
      ^references->rows :=
          SELECT *
            FROM this->contexts->^langedit->GetReferences(selectedtext.rowkey)
        ORDER BY resourcename, line;

      IF (IsDefaultValue(^references->value))
        ^references->selection := RECORD(^references->rows);

      ^references->visible := TRUE;
    }
    ELSE
    {
      ^currenttid->value := "";
      ^references->rows := DEFAULT RECORD ARRAY;
      ^references->visible := FALSE;
    }
  }

  MACRO GotReferenceSelect()
  {
    RECORD sel := ^references->selection;
    IF(RecordExists(sel))
    {
      TRY
      {
        BLOB file := GetWebhareResource(sel.resourcename);
        ^code->value := BlobToString(file,-1);
        ^code->GotoLine(sel.line);
      }
      CATCH(OBJECT e)
      {
        ^code->value := e->what;
      }
    }
    ELSE
    {
      ^code->value := "";
    }
  }

  MACRO ToggleContextView()
  {
    this->SetContextView(NOT ^contextviewpanel->visible);
  }

  BOOLEAN FUNCTION PrepareLanguageFiles()
  {
    RECORD ARRAY cols := this->initialcolumns;

    this->languages := this->contexts->^langedit->GetLanguages();
    UPDATE this->languages SET title := GetTid("tollium:common.languages." || langcode)
                           WHERE title = "";

    FOREVERY(RECORD lang FROM this->languages)
      INSERT
        [ name                := "lang_" || lang.langcode
        , type                := "text"
        , short_title         := ""
        , title               := lang.title
        , description         := ""
        , initial_visible     := TRUE
        , initial_sort        := FALSE
        , initial_sort_asc    := FALSE
        , edittype            := "textedit"
        ]
      INTO cols AT END;

    STRING newcolnames := EncodeHSON(SELECT name, title FROM cols);
    STRING oldcolnames := EncodeHSON(SELECT name, title FROM ^texts->columns);

    // Only change columns when something has changed
    IF (newcolnames != oldcolnames)
      ^texts->columns := cols;

    ^langfilelistener->masks := this->contexts->^langedit->GetEventMasks();
    RETURN TRUE;
  }

  RECORD FUNCTION DecorateNode(OBJECT textgroup, RECORD node, STRING tidsofar, BOOLEAN with_subnodes, STRING ARRAY limitlanguages, BOOLEAN keepifempty)
  {
    STRING numocc;
    BOOLEAN highlighted;
    BOOLEAN anyuntranslated;

    IF(tidsofar != "")
      tidsofar := tidsofar || ".";
    tidsofar := tidsofar || node.name;

    IF(ObjectExists(textgroup) AND textgroup->keepifempty)
      keepifempty := TRUE;

    INTEGER numrefs;
    IF(NOT node.isgroup AND keepifempty = FALSE)
    {
      numrefs := this->contexts->^langedit->GetNumReferences(tidsofar);
      numocc := ToString(numrefs);

      FOREVERY(RECORD lang FROM this->languages)
        IF(node.texts[#lang] = "" AND (Length(limitlanguages) = 0 OR lang.langcode IN limitlanguages))
        {
          anyuntranslated := TRUE;
          BREAK;
        }
      highlighted := (this->hl_unreferenced AND numocc="0")
                     OR (this->hl_untranslated AND anyuntranslated);
    }

    RECORD decorated :=
        [ rowkey := tidsofar || (node.isgroup?'.':'')
        , isroot := tidsofar = ""
        , isgroup := node.isgroup
        , name := node.name
        , title := tidsofar = "" ? "module:" || this->requestedmodule : node.name
        , expanded := tidsofar = ""
        , numrefs := numrefs
        , occurrences := numocc
        , issues := INTEGER[]
        , issueshint := ""
        , icon := node.isgroup ? 1 : 2
        , style := highlighted ? "highlight" : ""
        , subnodes := DEFAULT RECORD ARRAY
        , texts := node.texts
        , textgroup := node.textgroup
        , anyuntranslated := anyuntranslated
        , allunreferenced := numrefs = 0 AND NOT keepifempty
        , anyunreferenced := node.isgroup ? FALSE : numrefs = 0 AND NOT keepifempty
        ];

    IF(node.isgroup)
    {
      decorated.subnodes := this->DecorateNodes(node.textgroup, limitlanguages, keepifempty);
      IF(NOT decorated.anyunreferenced AND NOT keepifempty)
        decorated.anyunreferenced := RecordExists(SELECT FROM decorated.subnodes WHERE subnodes.anyunreferenced);
      decorated.allunreferenced := NOT RecordExists(SELECT FROM decorated.subnodes WHERE NOT subnodes.allunreferenced);

      IF(NOT decorated.anyuntranslated)
        decorated.anyuntranslated := RecordExists(SELECT FROM decorated.subnodes WHERE subnodes.anyuntranslated);
    }

    STRING ARRAY hints;
    IF(decorated.allunreferenced AND node.isgroup)
    {
      INSERT 5 INTO decorated.issues AT END;
      INSERT this->GetTid(".allunreferenced") INTO hints AT END;
    }
    ELSE IF(decorated.anyunreferenced)
    {
      INSERT 4 INTO decorated.issues AT END;
      INSERT this->GetTid(".unlinked") INTO hints AT END;
    }
    IF(decorated.anyuntranslated)
    {
      INSERT 3 INTO decorated.issues AT END;
      INSERT this->GetTid(".untranslated") INTO hints AT END;
    }

    decorated.issueshint := Detokenize(hints,'; ');

    FOREVERY(RECORD lang FROM this->languages)
      decorated := CellInsert(decorated, "lang_" || lang.langcode, node.isgroup ? "" : node.texts[#lang]);

    RETURN decorated;
  }

  RECORD ARRAY FUNCTION DecorateNodes(OBJECT textgroup, STRING ARRAY limitlanguages, BOOLEAN keepifempty)
  {
    RECORD ARRAY result;
    STRING basetid := textgroup->GetFullGid();
    FOREVERY (RECORD node FROM textgroup->nodes)
      INSERT this->DecorateNode(textgroup, node, basetid, TRUE, Length(textgroup->limitlanguages) > 0 ? textgroup->limitlanguages : limitlanguages, keepifempty) INTO result AT END;

    RETURN result;
  }

  MACRO RefreshAllNodes()
  {
    ^texts->rows := [ this->DecorateNode( DEFAULT OBJECT
                                             , [ isgroup := TRUE
                                               , name := ""
                                               , textgroup := this->contexts->^langedit->GetBaseGroup()
                                               , texts := DEFAULT STRING ARRAY
                                               ], "", TRUE, DEFAULT STRING ARRAY, FALSE)
                         ];
  }

  BOOLEAN FUNCTION LoadModule()
  {
    RECORD ARRAY llangs, rlangs;
    INTEGER langs;

    OBJECT langedit := NEW LangEditAPI(this->requestedmodule);
    this->contexts->^langedit := langedit;

    IF(NOT this->PrepareLanguageFiles())
      RETURN FALSE;

    this->DoHighlightUntranslated();
    ^reloadwarning->visible := FALSE;
    RETURN TRUE;
  }

  MACRO DoReload()
  {
    IF(NOT this->LoadModule())
      this->tolliumresult:="cancel";
  }

  RECORD ARRAY FUNCTION GetChildRowsRecursive(STRING parentrowkey)
  {
    RECORD ARRAY children := ^texts->GetChildRows(parentrowkey);

    FOREVERY(RECORD recurse FROM children)
      IF(recurse.isgroup)
        children := children CONCAT this->GetChildRowsRecursive(recurse.rowkey);

    RETURN children;
  }

  MACRO DoSelectUnreferenced()
  {
    RECORD ARRAY children := this->GetChildRowsRecursive(^texts->selection[0].rowkey);
    DELETE FROM children WHERE isgroup OR occurrences != "0";
    ^texts->selection := children;
  }

  MACRO SelectPrevious()
  {
    this->SelectInternal(TRUE, FALSE, -1);
  }
  MACRO SelectNext()
  {
    this->SelectInternal(TRUE, FALSE, +1);
  }

  BOOLEAN FUNCTION SelectInternal(BOOLEAN highlighted, BOOLEAN textnodes, INTEGER direction)
  {
    INTEGER pos, startpos;
    RECORD sel := ^texts->selection;
    IF(RecordExists(sel))
      pos := ^texts->GetRowFlatPosition(sel.rowkey);
    IF(pos<0)
      pos := 0;

    startpos := pos;

    RECORD ARRAY rows := ^texts->rows;
    WHILE(TRUE)
    {
      pos := pos + direction;
      IF(pos<0)
        pos := Length(rows)-1;
      IF(pos>=Length(rows))
        pos := 0;

      IF (textnodes AND rows[pos].isgroup)
        CONTINUE;
      IF (NOT highlighted OR rows[pos].style = "highlight")
      {
        ^texts->selection := [ RECORD(rows[pos]) ];
        RETURN TRUE;
      }

      IF(pos=startpos) //looped through all
        RETURN FALSE;
    }
  }

  MACRO DeleteNodes(RECORD ARRAY rows)
  {
    // lookup rows based on their rowkey, kill if found in the langfile, ignore otherwise (eg recursive delete)
    FOREVERY(RECORD row FROM rows)
    {
      TRY
      {
        RECORD parent := ^texts->GetParentRow(row.rowkey);
        IF(RecordExists(parent))
          IF(row.isgroup)
            parent.textgroup->DeleteTextGroup(row.name);
           ELSE
            parent.textgroup->DeleteText(row.name);
      }
      CATCH(OBJECT e) //ignore delete exception
      {

      }
    }
    this->contexts->^langedit->SaveChanges();
    this->RefreshAllNodes();
  }

  INTEGER FUNCTION GetLangIdFromCellName(STRING cellname)
  {
    FOREVERY(RECORD lang FROM this->languages)
      IF(lang.langcode = Substring(cellname,5))
        RETURN #lang;

    THROW NEW Exception("Illegal cell name '" || cellname || "'");
  }

  OBJECT FUNCTION GetTextRowTextgroup(RECORD row)
  {
    IF(row.isgroup)
      THROW NEW Exception("Requesting textgroup for non-text row " || row.rowkey);

    RECORD parent := ^texts->GetParentRow(row.rowkey);
    OBJECT textgroup := RecordExists(parent) ? parent.textgroup : this->contexts->^langedit->GetBaseGroup();
    RETURN textgroup;
  }

  MACRO UpdateText(RECORD row, STRING name, STRING ARRAY newtexts)
  {
    OBJECT textgroup;
    INTEGER finalindex;
    BOOLEAN namechange := FALSE;

    IF(row.isgroup) //adding
    {
      textgroup := row.textgroup;
      finalindex := textgroup->CreateText(name);
      namechange := TRUE;
    }
    ELSE
    {
      textgroup := this->GetTextRowTextgroup(row);
      IF(name != row.name)
      {
        finalindex := textgroup->RenameText(row.name, name);
        namechange := TRUE;
      }
      ELSE
        finalindex := textgroup->GetTextPos(row.name);
    }

    FOREVERY(RECORD lang FROM this->languages)
    {
      //"%" indicates 'not updating'
      IF(newtexts[#lang] != "%" AND (textgroup->GetRawText(row.name, #lang) != newtexts[#lang] OR (namechange AND newtexts[#lang] != "")))
        textgroup->SetRawText(name, #lang, newtexts[#lang]);
    }

    row := this->DecorateNode(textgroup, textgroup->nodes[finalindex], textgroup->GetFullGid(), TRUE, textgroup->GetEffectiveLimitLanguages(), textgroup->IsKeepIfEmpty());
    ^texts->UpdateSingleRow(row);
    ^texts->SetValueIfValid([ STRING(row.rowkey) ]);

    this->contexts->^langedit->SaveChanges();

    IF (namechange) //adding
    {
      this->RefreshAllNodes();
      ^texts->SetValueIfValid([ STRING(row.rowkey) ]);
    }
  }

  BOOLEAN FUNCTION OnCellEdit(RECORD row, STRING cellname, STRING newvalue)
  {
    newvalue := DecodeJava(newvalue);

    IF (NOT IsValidLangfileText(newvalue))
      RETURN FALSE;

    INTEGER cellnum := this->GetLangIdFromCellName(cellname);
    IF(cellnum >= Length(row.texts))
      RETURN FALSE;

    row.texts[cellnum] := newvalue;
    this->UpdateText(row, row.name, row.texts);
    RETURN TRUE;
  }

  PUBLIC MACRO DoAddLanguageFile()
  {
    IF(this->LoadScreen(".languagefile")->RunModal() != "ok")
      RETURN;

    this->LoadModule();
  }

  PUBLIC MACRO DoAddText()
  {
    RECORD selection := ^texts->selection;
    OBJECT textgroup := selection.textgroup;

    this->RunScreen("#langtext", [ textgroup := textgroup, name := "", navigate := FALSE, updatefunc := PTR this->UpdateText(selection,#1,#2) ]);
  }

  PUBLIC MACRO DoEditText()
  {
    WHILE (TRUE)
    {
      RECORD cursel := ^texts->selection;

      STRING currow := ^texts->value[0];
      BOOLEAN enable_navigate := RecordExists(SELECT FROM ^texts->rows WHERE rowkey != currow AND style = "highlight");
      OBJECT subscr := this->LoadScreen(".langtext",
          [ textgroup := this->GetTextRowTextgroup(cursel)
          , name := cursel.name
          , navigate := enable_navigate
          , updatefunc := PTR this->UpdateText(cursel,#1,#2)
          ]);

      STRING result := subscr->RunModal();

      IF (result NOT IN ["next","previous"] OR NOT this->SelectInternal(TRUE, FALSE, result="next"?1:-1))
        BREAK;
    }
  }

  RECORD FUNCTION FindNode(RECORD ARRAY nodes, STRING rowkey)
  {
    FOREVERY (RECORD node FROM nodes)
    {
      IF (node.rowkey = rowkey)
        RETURN node;

      IF (LENGTH(node.subnodes) != 0)
      {
        RECORD rec := this->FindNode(node.subnodes, rowkey);
        IF (RecordExists(rec))
          RETURN rec;
      }
    }
    RETURN DEFAULT RECORD;
  }
  PUBLIC MACRO DoDeleteNodes()
  {
    IF (this->RunMessageBox(".deleteconfirmation") = "yes")
    {
      this->DeleteNodes(SELECT * FROM ^texts->selection);
    }
  }

  PUBLIC MACRO DoAddGroup()
  {
    OBJECT textgroup := ^texts->selection.textgroup;
    OBJECT screen := this->LoadScreen("#textgroup", [ parentgroup := textgroup, textgroup := DEFAULT OBJECT ]);
    IF(screen->RunModal()!="ok")
      RETURN;

    this->RefreshAllNodes();
    ^texts->SetValueIfValid([ screen->textgroupgid||'.' ]);
    this->contexts->^langedit->SaveChanges();

  }

  PUBLIC MACRO DoEditGroup()
  {
    OBJECT textgroup := ^texts->selection.textgroup;
    OBJECT screen := this->LoadScreen("#textgroup", [ parentgroup := textgroup->parent, textgroup := textgroup ]);
    IF(screen->RunModal()!="ok")
      RETURN;

    this->RefreshAllNodes();
    this->contexts->^langedit->SaveChanges();
  }

  MACRO RefreshHighlights()
  {
    ^mi_untranslated->checked := this->hl_untranslated;
    ^untranslated_button->pressed := this->hl_untranslated;

    ^mi_unreferenced->checked := this->hl_unreferenced;
    //this->unreferenced_button->pressed := this->hl_unreferenced;

    this->frame->flags.anyhighlights := this->hl_untranslated OR this->hl_unreferenced;

    this->RefreshAllNodes();

    IF(this->frame->flags.anyhighlights = TRUE AND NOT RecordExists(^texts->selection))
    {
      ^texts->selection := DEFAULT RECORD ARRAY;
      this->SelectNext();
    }
  }

  PUBLIC MACRO DoHighlightUntranslated()
  {
    this->hl_untranslated := TRUE;
    this->RefreshHighlights();
  }

  PUBLIC MACRO DoHighlightUnreferenced()
  {
    this->hl_unreferenced := TRUE;
    this->RefreshHighlights();
  }

  PUBLIC MACRO DoHighlightClear()
  {
    this->hl_untranslated := FALSE;
    this->hl_unreferenced := FALSE;
    this->RefreshHighlights();
  }

  PUBLIC MACRO ToggleUntranslated()
  {
    this->hl_untranslated := NOT this->hl_untranslated;
    this->RefreshHighlights();
  }

  PUBLIC MACRO ToggleUnreferenced()
  {
    this->hl_unreferenced := NOT this->hl_unreferenced;
    this->RefreshHighlights();
  }

  MACRO DoDeleteHighlighted()
  {
    IF (this->RunMessageBox(".removehighlighted") = "yes")
    {
      this->DeleteNodes(SELECT * FROM ^texts->rows WHERE style = "highlight");
    }
  }

  MACRO DoSaveAll()
  {
    this->contexts->^langedit->SaveChanges([ force := TRUE]);
    this->RunMessageBox(".allsaved");
  }

  PUBLIC MACRO DoImport(RECORD ARRAY files)
  {
    this->contexts->^langedit->ImportLanguageFile(files[0].data);
    this->RefreshAllNodes();
  }

  PUBLIC MACRO DoMoveMissingFrom()
  {
    IF(this->RunScreen("#movemissingfrom", [ targetgroup := ^texts->selection.textgroup->GetFullGid() ]) = "ok")
      this->RefreshAllNodes();
  }

  PUBLIC MACRO DoExport()
  {
    STRING base := Left(^texts->value[0], Length(^texts->value[0]) - 1);
    RunColumnFileExportDialog(this, this->contexts->^langedit->GenerateExport(base));
  }

  BOOLEAN FUNCTION TestRowRegex(RECORD row, OBJECT regex)
  {
    FOREVERY(RECORD lang FROM this->languages)
      IF (regex->Test(GetCell(row, "lang_" || lang.langcode)))
        RETURN TRUE;

    RETURN FALSE;
  }

  MACRO DoFind()
  {
    ^searchbar->visible := NOT ^searchbar->visible;
  }

  MACRO DoSearch()
  {
    STRING searchstring := ^searchfor->value;
    BOOLEAN searchintext := ^searchintexts->value;
    IF(NOT ^regex->value)
      searchstring := CreateLikeRegexPattern("*" || TrimWhitespace(searchstring) || "*");

    //ADDME Move search/next/prev functions into langeditor.whlib objects

    OBJECT searchregex := NEW JSRegEx(searchstring,"i");
    TRY
    {
      searchregex->Test(""); //validate..
    }
    CATCH(OBJECT e)
    {
      this->RunSimpleScreen("error", e->what);
      RETURN;
    }


    STRING ARRAY keys := SELECT AS STRING ARRAY rowkey FROM ^texts->selection;

    INTEGER start_at :=
        SELECT AS INTEGER max(#row + 1)
          FROM ^texts->rows AS row
         WHERE rowkey IN keys;

    RECORD ARRAY newsel :=
        SELECT rowkey
          FROM ^texts->rows AS row
         WHERE #row >= start_at
           AND (searchregex->Test(rowkey)
                OR (searchintext AND this->TestRowRegex(row, searchregex)))
         LIMIT 1;

    IF (NOT RecordExists(newsel))
      newsel :=
          SELECT rowkey
            FROM ^texts->rows AS row
           WHERE #row < start_at
             AND (searchregex->Test(rowkey)
                  OR (searchintext AND this->TestRowRegex(row, searchregex)))
           LIMIT 1;

    IF (RecordExists(newsel))
      ^texts->selection := newsel;
    ELSE
      this->RunMessageBox(".notfound", ^searchfor->value);
  }
  MACRO DoExit()
  {
    this->tolliumresult := "cancel";
  }

  MACRO DoCollapseRecursive()
  {
    IF (LENGTH(^texts->value) = 0)
    {
      ^texts->expanded := DEFAULT STRING ARRAY;
      RETURN;
    }
    STRING ARRAY subnodes;
    RECORD ARRAY rows := ^texts->rows;

    FOREVERY (STRING rowkey FROM ^texts->value)
    {
      INTEGER pos := ^texts->GetRowFlatPosition(rowkey);
      INTEGER level := rows[pos].level;
      FOR (INTEGER i := pos; i < LENGTH(rows) AND (i = pos OR rows[i].level > level); i := i + 1)
        INSERT rows[i].rowkey INTO subnodes AT END;
    }

    ^texts->expanded :=
        SELECT AS STRING ARRAY rowkey
          FROM ToRecordArray(^texts->expanded, "ROWKEY")
         WHERE rowkey NOT IN subnodes;
  }

  MACRO DoExpandRecursive()
  {
    RECORD ARRAY rows := ^texts->rows;
    IF (LENGTH(^texts->value) = 0)
    {
      ^texts->expanded := SELECT AS STRING ARRAY rowkey FROM rows;
      RETURN;
    }

    STRING ARRAY subnodes;
    FOREVERY (STRING rowkey FROM ^texts->value)
    {
      INTEGER pos := ^texts->GetRowFlatPosition(rowkey);
      INTEGER level := rows[pos].level;
      FOR (INTEGER i := pos; i < LENGTH(rows) AND (i = pos OR rows[i].level > level); i := i + 1)
        INSERT rows[i].rowkey INTO subnodes AT END;
    }

    ^texts->expanded := ^texts->expanded CONCAT subnodes;
  }

  MACRO DoOpenInEditor()
  {
    RECORD sel := ^references->selection;
    this->contexts->controller->ExecuteClientCall("OpenInEditor", sel.resourcename,
          [ line := sel.line
          , col :=  CellExists(sel, "COL") ? sel.col  : 1
          ]);
  }

>;

PUBLIC OBJECTTYPE LangText EXTEND TolliumScreenBase
<
  OBJECT ARRAY textareas;
  OBJECT textgroup;
  STRING name;
  STRING direction;
  MACRO PTR updatefunc;

  PUBLIC STRING texttid;

  PUBLIC MACRO Init(RECORD data)
  {
    RECORD textnode;
    this->textgroup := data.textgroup;
    this->name := data.name;
    this->updatefunc := data.updatefunc;

    this->gid->value := this->textgroup->GetFullGid() || ".";

    IF(this->name="") //new
    {
    }
    ELSE
    {
      this->tid->value := this->name;
      textnode := this->textgroup->nodes[this->textgroup->GetTextPos(this->name)];
    }

    this->next->enabled := data.navigate;
    this->previous->enabled := data.navigate;

    STRING ARRAY limitlanguages := this->textgroup->GetEffectiveLimitLanguages();
    OBJECT focusable;
    FOREVERY (RECORD lang FROM this->contexts->^langedit->GetLanguages())
    {
      IF(Length(limitlanguages) > 0 AND lang.langcode NOT IN limitlanguages)
      {
        INSERT DEFAULT OBJECT INTO this->textareas AT END;
        CONTINUE;
      }

      OBJECT textarea := this->CreateTolliumComponent("textarea");
      IF(NOT ObjectExists(focusable))
        focusable := textarea;

      INSERT textarea INTO this->textareas AT END;

      textarea->title := lang.title ?? GetTid("tollium:common.languages." || lang.langcode);
      textarea->width := "1pr";
      textarea->height := "1pr";

      IF(this->name != "")
        textarea->value := textnode.texts[#lang];

      this->body->InsertComponentAfter(textarea, DEFAULT OBJECT, TRUE);
    }

    IF(this->name != "" AND ObjectExists(focusable))
      this->frame->focused := focusable; //focus first language text then
  }

  STRING ARRAY FUNCTION GetUpdatedTexts()
  {
    STRING ARRAY retvals;
    FOREVERY(OBJECT area FROM this->textareas)
      INSERT ObjectExists(area) ? area->value : "%" INTO retvals AT END;
    RETURN retvals;
  }

  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();

    IF(this->name != this->tid->value AND this->textgroup->GetTextPos(this->tid->value)!=-1)
      work->AddErrorFor(this->tid, this->GetTid(".duplicatenodename"));

    IF (NOT IsValidTidGid(this->tid->value))
      work->AddErrorFor(this->tid, this->GetTid(".illegaltidname"));

    FOREVERY(OBJECT area FROM this->textareas)
      IF (ObjectExists(area) AND NOT IsValidLangfileText(area->value))
        work->AddErrorFor(area, this->GetTid(".badtext"));

    IF(NOT work->HasFailed())
    {
      this->updatefunc(this->tid->value, this->GetUpdatedTexts());
    }

    this->texttid := this->textgroup->GetFullGid();
    IF(this->texttid != "")
      this->texttid := this->texttid || '.';
    this->texttid := this->texttid || this->tid->value;

    RETURN work->Finish();
  }

  MACRO DoNext()
  {
    IF (this->Submit())
      this->tolliumresult := "next";
  }

  MACRO DoPrevious()
  {
    IF (this->Submit())
      this->tolliumresult := "previous";
  }
>;

PUBLIC STATIC OBJECTTYPE TextGroup EXTEND TolliumScreenBase
<
  OBJECT parentgroup;
  OBJECT textgroup;

  PUBLIC STRING textgroupgid;

  MACRO Init(RECORD data)
  {
    this->parentgroup := data.parentgroup;
    this->textgroup := data.textgroup;
    ^limitlanguages->options := SELECT rowkey := langcode, title := title ?? GetTid("tollium:common.languages." || langcode)
                                  FROM this->contexts->^langedit->GetLanguages();

    IF(ObjectExists(this->textgroup))
    {
      ^elementname->value := this->textgroup->name;
      ^keepifempty->value := this->textgroup->keepifempty;
      ^keepemptyreason->value := this->textgroup->keepemptyreason;
      ^limitlanguages->value := this->textgroup->limitlanguages;
    }
  }

  BOOLEAN FUNCTION Submit()
  {
    //ADDME elementname syntax check, especially dots!
    OBJECT work := this->BeginFeedback();

    OBJECT conflict := this->parentgroup->GetTextgroup(^elementname->value);
    IF(ObjectExists(conflict) AND conflict != this->textgroup)
      work->AddErrorFor(^elementname, this->GetTid(".duplicategroupname"));

    IF(NOT work->HasFailed())
    {
      OBJECT finalgroup := this->textgroup;
      IF(NOT ObjectExists(this->textgroup))
      {
        finalgroup := this->parentgroup->CreateTextGroup(^elementname->value);
      }
      ELSE
      {
        finalgroup->name := ^elementname->value;
      }

      finalgroup->keepemptyreason := ^keepifempty->value ? ^keepemptyreason->value : "";
      finalgroup->limitlanguages := ^limitlanguages->value;
      this->textgroupgid := finalgroup->GetFullGid();
    }
    IF(NOT work->Finish())
      RETURN FALSE;
    this->contexts->^langedit->SaveChanges();
    RETURN TRUE;
  }
>;

PUBLIC STATIC OBJECTTYPE LanguageFile EXTEND TolliumScreenBase
<
  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();
    IF(Length(^Langcode->value) != 2)
      work->AddErrorFor(^langcode, this->GetTid(".error_badlanguagecode"));
    IF(work->HasFailed())
      RETURN work->Finish();

    ^langcode->value := ToLowercase(^Langcode->value);

    //Do we have a default language file?
    STRING ondiskname;
    STRING module := this->contexts->^langedit->openmodule;
    BLOB defaultlangfile := GetWebhareResource(`mod::${module}/language/default.xml`, [ allowmissing := TRUE ]);
    IF(Length(defaultlangfile)=0)
    {
      IF(this->RunMessageBox(".verifyfirstlanguagefile")!="yes")
        RETURN FALSE;

      CreateDiskDirectory(GetModuleInstallationRoot(module) || "language",TRUE);
      ondiskname := "default";
    }
    ELSE
      ondiskname := ^langcode->value;

    //Create a basic language file
    STRING ondiskpath := GetModuleInstallationRoot(module) || "language/" || ondiskname || ".xml";

    StoreDiskFile(ondiskpath, MakeNEwLanguageFile(^langcode->value)->MakeLanguageFile(), [ overwrite := TRUE ]);
    RETURN TRUE;
  }
>;

PUBLIC OBJECTTYPE MoveMissingFrom EXTEND TolliumScreenBase
<
  OBJECT tgroup;

  MACRO Init(RECORD data)
  {
    ^targetgroup->value := data.targetgroup;
    this->tgroup := this->contexts->^langedit->LookupTextGroup(data.targetgroup);
    STRING ARRAY suggestions := this->contexts->^langedit->GetSuggestedMissingFromSources(this->tgroup);
    IF(Length(suggestions)>0)
    {
      ^movefrom->options := ToRecordArray(suggestions, 'title');
      ^movefrom->value := suggestions[0];
    }
  }
  BOOLEAN FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();
    OBJECT sgroup := this->contexts->^langedit->LookupTextGroup(^movefrom->value);
    IF(NOT ObjectExists(sgroup))
      work->AddErrorFor(^movefrom, this->GetTid(".nosuchgroup", ^movefrom->value));
    IF(NOT work->HasFailed())
    {
      this->contexts->^langedit->ImportMissingFrom(this->tgroup, sgroup);
      this->contexts->^langedit->SaveChanges();
    }
    RETURN work->Finish();
  }
>;
