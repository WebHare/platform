<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::os.whlib";
LOADLIB "wh::util/algorithms.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::internal/wasm.whlib";

LOADLIB "mod::system/lib/webserver/management.whlib";
LOADLIB "mod::system/lib/internal/cluster/logwriter.whlib";

LOADLIB "mod::tollium/lib/todd/internal/communication.whlib";


MACRO __HS_ENABLEJOBCACHE(BOOLEAN enable, STRING ARRAY preloadscripts) __ATTRIBUTES__(EXTERNAL);
IF (IsWasm())
{
  __HS_ENABLEJOBCACHE(TRUE, [ "mod::tollium/scripts/internal/applicationhost.whscr" ]);
}

/** This library owns all tollium applications, keeps their crash histories

  To start this in freestanding WASM mode, use
  ```
  wh runwasm mod::tollium/scripts/internal/applicationstarter.whscr
  wh debug enable tollium:usewasm
  ```
*/

INTEGER keephistory := 20; // in seconds
INTEGER checkinterval := 10; // in seconds

// Create BEFORE we create the port
OBJECT commport;

/* Interaction

  Every frontend app has an ID which they speicify when starting a backendapplication. If none
  is specified, the app generates one for them and gives it to the frontend.

  After an application is started, the job is transferred to this script. This script will own
  that job, so it can access crash results.

  The frontend connects to this script and listens on that id. Due to concurrency/restarts, etc.
  a frontent may have multiple ids.

  Crash-info is kept for X minutes.
*/

/** Todd event manager - handles push sessions and messaging
*/
STATIC OBJECTTYPE AppOwnerPortHandler EXTEND IPCPortHandlerBase
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  STRING localid;

  OBJECT linkport;

  OBJECT dispatcher;

  RECORD ARRAY apps;

  RECORD ARRAY frontends;

  INTEGER cleanupcb;

  OBJECT parentlink;
  INTEGER parentlinkcb;

  RECORD debugconfig;

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(OBJECT port)
  : IPCPortHandlerBase(port)
  {
    this->flat_responses := TRUE;

    this->localid := "O:" || GetCurrentGroupId();
    STRING myportname := "tollium:link." || this->localid;
    this->linkport := CreateGlobalIPCPort(myportname);
    this->dispatcher := NEW ToddLinkDispatcher(this->localid || "(as)");

    this->AddListeningPort(this->linkport);
    RegisterTimedCallback(AddTimeToDate(checkinterval*1000, GetCurrentDateTime()), PTR this->CleanupOldApps);

    this->parentlink := GetIPCLinkToParent();
    IF (ObjectExists(this->parentlink))
      this->parentlinkcb := RegisterHandleReadCallback(this->parentlink->handle, PTR this->GotParentMessage);

    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("Started, my port: " || myportname);

    // Wait for queries for existance, and broadcast our own existance
    RegisterEventCallback("tollium:applicationstarter.query", PTR this->GotExistenceQuery);
    this->EmitExistsEvent();
    RegisterEventCallback("system:debugger.*", PTR this->GotDebuggerEvent);

    this->ReloadDebuggerConfig();
    FOREVERY (STRING mask FROM this->debugconfig.eventmasks)
      RegisterEventCallback("system:debugger.configchange", PTR this->GotDebuggerConfigInvalidation);
  }

  MACRO EmitExistsEvent() {
    BroadcastEvent("tollium:applicationstarter.exists", [
      id := this->localid,
      portname := ObjectExists(commport) ? commport->name : "",
      pid := GetProcessId()
    ]);
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO LogDebug(STRING message, VARIANT ARRAY args) __ATTRIBUTES__(VARARG)
  {
    INSERT message INTO args AT 0;
    INSERT "ng-appstart" INTO args AT 0;
    CallMacroPTRVA(PTR LogDebug, args);
  }

  MACRO LogApplicationErrors(STRING appname, STRING appid, STRING externalsessiondata, RECORD ARRAY errors)
  {
    RECORD data :=
        [ message :=    (SELECT AS STRING message FROM errors)
        , warnings :=   DEFAULT RECORD ARRAY
        , errors :=     SELECT filename, line, "column" := col, message FROM errors where code >= 0
        , trace :=      SELECT filename, line, "column" := col, functionname := func FROM errors WHERE code < 0 LIMIT 100
        , groupid :=    appid
        , session :=    externalsessiondata
        ];

    LogNoticeScriptErrorFromRecord(appname, data);
  }

  STRING ARRAY FUNCTION ReloadDebuggerConfig()
  {
    this->debugconfig := CallFunctionFromJob("mod::system/lib/configure.whlib#GetDebuggerConfig");
    RETURN this->debugconfig.eventmasks;
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  MACRO GotExistenceQuery(STRING event, RECORD data)
  {
    this->EmitExistsEvent();
  }

  MACRO GotDebuggerConfigInvalidation(STRING event, RECORD data)
  {
    this->ReloadDebuggerConfig();
  }

  MACRO GotDebuggerEvent(STRING event, RECORD data)
  {
    IF (event LIKE "system:debugger.attach.*"
        OR event LIKE "system:debugger.detach.*"
        OR event LIKE "system:debugger.running.*"
        OR event LIKE "system:debugger.paused.*")
    {
      STRING groupid := Tokenize(event, ".")[2];

      RECORD pos := RecordLowerBound(this->apps, [ appid := groupid ], [ "APPID" ]);
      IF (NOT pos.found)
        RETURN;

      RECORD fpos := RecordLowerBound(this->frontends, [ frontendid := this->apps[pos.position].frontendid ], [ "FRONTENDID" ]);
      IF (NOT fpos.found)
        RETURN;

      this->frontends[fpos.position].msgqueue->QueueMessage(
          [ type :=     "debugstatus"
          , appid :=    "A:" || groupid
          , attached := event NOT LIKE "system:debugger.detach.*"
          , paused :=   event NOT LIKE "system:debugger.running.*"
          ]);
    }
  }

  MACRO GotParentMessage()
  {
    RECORD res := this->parentlink->ReceiveMessage(DEFAULT DATETIME);
    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("Got mgmt message", res);

    IF (res.status = "gone")
    {
      UnregisterCallback(this->parentlinkcb);
      this->parentlink->Close();
      this->parentlink := DEFAULT OBJECT;
      RETURN;
    }
    IF (res.status = "timeout")
      RETURN;

    IF (res.msg.task = "tryrelease")
    {
      IF (IsScriptOutOfDate())
      {
        IF (IsDebugTagEnabled("tollium:logappstarter"))
          this->LogDebug("Out of date, releasing");
        IF (ObjectExists(this->pvt_port))
          this->pvt_port->Close();
        this->pvt_port := DEFAULT OBJECT;

        this->parentlink->SendMessage([ type := "tryrelease-ok" ]);

        UnregisterCallback(this->parentlinkcb);
        this->parentlink->Close();
        this->parentlink := DEFAULT OBJECT;
      }
      ELSE
      {
        IF (IsDebugTagEnabled("tollium:logappstarter"))
          this->LogDebug("Not out of date, staying alive");
        this->parentlink->SendMessage([ type := "tryrelease-cancel" ]);
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // More stuff
  //
  MACRO CleanupOldApps()
  {
    DATETIME cutoff := AddTimeToDate(-keephistory*1000, GetCurrentDateTime());

    FOR (INTEGER i := 0; i < LENGTH(this->apps);)
    {
      IF (this->apps[i].stopped <= cutoff)
      {
        RECORD pos := RecordLowerBound(this->frontends, [ frontendid := this->apps[i].frontendid ], [ "FRONTENDID" ]);
        this->frontends[pos.position].apps := this->frontends[pos.position].apps - 1;
        IF (this->frontends[pos.position].apps = 0)
        {
          IF (IsDebugTagEnabled("tollium:logappstarter"))
            this->LogDebug("No more apps for frontend " || this->apps[i].frontendid || ", destroying");

          this->frontends[pos.position].msgqueue->Close();
          DELETE FROM this->frontends AT pos.position;
        }

        DELETE FROM this->apps AT i;
      }
      ELSE
        i := i + 1;
    }

    // Stop if we have been released has been and we don't have frontends anymore
    IF (NOT ObjectExists(this->pvt_port) AND LENGTH(this->frontends) = 0)
      TerminateScript();

    RegisterTimedCallback(AddTimeToDate(checkinterval*1000, GetCurrentDateTime()), PTR this->CleanupOldApps);
  }

  /** Start an application. Asynchronous, so we can start multiple applications together
  */
  OBJECT ASYNC FUNCTION StartApp(OBJECT link, RECORD message, INTEGER64 replyid)
  {
    // Read parameters
    message := ValidateOptions(CELL[ task := "", invoke := appstartoptions ], message);
    RECORD invoke := message.invoke;
    STRING frontendid := invoke.frontendid;
    STRING app := invoke.app;
    RECORD launchuserinfo := invoke.launchuserinfo;
    INTEGER loggedin_entityid := launchuserinfo.loggedin;
    STRING loggedin_name := launchuserinfo.loggedin_name;
    DATETIME loggedin_expires := launchuserinfo.loggedin_expires;

    // Create an application host
    DATETIME creationdate := GetCurrentDateTime();
    RECORD jobrec := CreateJob("mod::tollium/scripts/internal/applicationhost.whscr");

    // Errors creating the job?
    IF (NOT ObjectExists(jobrec.job))
    {
      IF (IsDebugTagEnabled("tollium:logappstarter"))
        this->LogDebug("Error starting app");

      this->LogApplicationErrors(app, "", "", jobrec.errors);

      // No debugging possible, compile error
      this->SendPorthandlerReply(link,
          [ status := "errors"
          , errors := jobrec.errors
          ], replyid);

      RETURN DEFAULT RECORD;
    }

    RECORD authrec := jobrec.job->GetAuthenticationRecord();
    INSERT CELL tollium :=
        [ app :=
              [ name :=           app
              , title :=          app
              , data :=           DEFAULT RECORD
              ]
        , user :=
              [ realname :=       ""
              , emailaddress :=   ""
              , language :=       ""
              , login :=          loggedin_name ?? "<" || loggedin_entityid || ">"
              , eventidentifier := ""
              , wrdentityid :=    loggedin_entityid
              , authobjectid :=   0
              , expires :=        loggedin_expires
              ]
        ] INTO authrec;
    jobrec.job->SetAuthenticationRecord(authrec);

    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("Created app " || jobrec.job->groupid || ", frontendid " || frontendid);

    // Send configuration to job & start it
    jobrec.job->ipclink->SendMessage(invoke);
    jobrec.job->Start();

    // Wait for startup (or crash). ADDME: timeout?
    RECORD rec := AWAIT jobrec.job->ipclink->AsyncReceiveMessage(MAX_DATETIME);
    IF (rec.status != "ok")
    {
      IF (rec.status != "gone") // ADDME: Should log a timeout here
        jobrec.job->Terminate();

      // Wait for the job to become signalled (the debugger might have taken control of it)
      AWAIT jobrec.job->AsyncWaitRead(MAX_DATETIME);

      RECORD ARRAY errors := jobrec.job->GetErrors();
      STRING groupid := jobrec.job->groupid;
      STRING externalsessiondata := jobrec.job->GetExternalSessionData();
      jobrec.job->Close();

      IF (LENGTH(errors) != 0)
        this->LogApplicationErrors(app, groupid, externalsessiondata, errors);

      this->SendPorthandlerReply(link,
          [ status :=         "errors"
          , errors :=         errors
          , appid :=          groupid
          , debugtimeout :=   this->debugconfig.keep_errorterminated_msecs
          ], replyid);
      RETURN DEFAULT RECORD;
    }

    STRING appid := jobrec.job->groupid;
    OBJECT job := jobrec.job;

    STRING linkid;
    OBJECT msgqueue;
    RECORD pos := RecordLowerBound(this->frontends, [ frontendid := frontendid ], [ "FRONTENDID" ]);
    IF (pos.found)
    {
      IF (IsDebugTagEnabled("tollium:logappstarter"))
        this->LogDebug("Attach to existing message queue for frontendid " || frontendid || " (" || pos.position || ")");
      msgqueue := this->frontends[pos.position].msgqueue;
      linkid := this->frontends[pos.position].linkid;
    }
    ELSE
    {
      IF (IsDebugTagEnabled("tollium:logappstarter"))
        this->LogDebug("Constructing new message queue for frontendid " || frontendid || " (" || pos.position || ")");

      // Create unique link id (otherwise we might recreate a link with the same name)
      linkid := this->localid || "/" || frontendid || "/" || GenerateUFS128BitId();
      msgqueue := NEW ToddMessageLinkEndpoint(this->dispatcher, linkid, frontendid);

      INSERT
          [ frontendid := frontendid
          , linkid :=     linkid
          , msgqueue :=   msgqueue
          , apps :=       0
          , laststop :=   DEFAULT DATETIME
          ] INTO this->frontends AT pos.position;
    }

    this->frontends[pos.position].apps := this->frontends[pos.position].apps + 1;

    job->userdata :=
        [ cbid :=         RegisterHandleReadCallback(job->handle, PTR this->GotJobSignalled(job))
        , lcbid :=        RegisterHandleReadCallback(job->ipclink->handle, PTR this->GetJobLinkSignalled(job))
        , msgqueue :=     msgqueue
        , appid :=        appid
        , frontendid :=   frontendid
        , app :=          app
        , invoke :=       message.invoke
        , expires :=      loggedin_expires
        , expired :=      FALSE
        ];

    INSERT
        [ appid :=        appid
        , job :=          job
        , frontendid :=   frontendid
        , stopped :=      MAX_DATETIME
        , errors :=       DEFAULT RECORD ARRAY
        , lastactivity := GetCurrentDateTime()
        , requestdata :=  message.invoke.requestdata
        , browsertriplet :=   message.invoke.browsertriplet
        , creationdate := creationdate
        , initialauthrec := authrec
        ] INTO this->apps AT RecordUpperBound(this->apps, [ appid := appid ], [ "APPID" ]);

    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("job " || job->groupid || " started");

    this->SendPorthandlerReply(link,
        [ status :=     "ok"
        , linkid :=     linkid
        , frontendid := frontendid
        , appdata :=    rec.msg
        , appid :=      appid
        ], replyid);

    RETURN DEFAULT RECORD;
  }

  // ---------------------------------------------------------------------------
  //
  // Overridden stuff
  //

  /** The link port is multiplexed with the normal port handling, to simplify
      the implementation considerably
  */
  UPDATE RECORD FUNCTION OnMessage(OBJECT link, RECORD message, INTEGER64 replyid)
  {
    IF (CellExists(message, "TYPE") AND TypeID(message.type) = TypeID(STRING) AND message.type = "linkmessages")
    {
      this->dispatcher->RegisterLink(link, message);
      RETURN [ result := "releaselink" ];
    }

    IF (NOT this->IsCellOk(message, "TASK", TypeID(STRING)))
      THROW NEW Exception("Wrong message format, expected 'task' cell");

    SWITCH (message.task)
    {
      CASE "startapp"
        {
          // Async function,
          this->StartApp(link, message, replyid)->OnError(PTR this->SendExceptionReply(link, replyid, #1));
          RETURN
              [ result := "defer"
              ];
        }
      CASE "getapps"
        {
          RECORD ARRAY jobs;
          IF (NOT IsWasm())
          {
            RECORD jobmgr_status := __HS_GETJOBMANAGERSTATUS(TRUE);
            jobs :=
                SELECT *
                  FROM jobmgr_status.jobs CONCAT jobmgr_status.finished
              ORDER BY groupid;
          }

          RETURN
              [ result := "message"
              , msg :=
                    [ apps :=
                        SELECT TEMPORARY pos := RecordLowerBound(jobs, [ groupid := appid ], [ "GROUPID" ])
                             , appid
                             , frontendid
                             , app :=           job->userdata.app
                             , stopped
                             , errors
                             , lastactivity
                             , requestdata
                             , browsertriplet
                             , expires :=       job->userdata.expires
                             , authenticationrecord := pos.found ? jobs[pos.position].authenticationrecord : initialauthrec
                             , creationdate
                             , statistics :=    pos.found ? jobs[pos.position].statistics : DEFAULT RECORD
                          FROM this->apps
                    ]
              ];
        }
      CASE "abortapp"
        {
          RECORD app := SELECT * FROM this->apps WHERE appid = message.appid;
          IF (RecordExists(app)) {
            IF (IsDebugTagEnabled("tollium:logappstarter"))
              this->LogDebug(`Terminating job ${message.appid} by request`);
            __HS_ABORTJOBBYGROUPID(message.appid);
          } ELSE {
            IF (IsDebugTagEnabled("tollium:logappstarter"))
              this->LogDebug(`Could not terminating job ${message.appid} by request, no such app`);
          }

          RETURN
              [ result := "message"
              , msg :=
                    [ type :=     "aborted"
                    , appid :=    message.appid
                    ]
              ];
        }
      DEFAULT
        {
          THROW NEW Exception("Unknown message type '" || message.task || "'");
        }
    }
  }

  MACRO GotJobSignalled(OBJECT job)
  {
    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("job " || job->groupid || " signalled");
    UnregisterCallback(job->userdata.cbid);
    IF (job->userdata.lcbid != 0)
    {
      UnregisterCallback(job->userdata.lcbid);
      job->userdata.lcbid := 0;
    }

    RECORD ARRAY errors := job->GetErrors();

    STRING appname := job->userdata.invoke.app;
    IF (LENGTH(errors) != 0)
    {
      IF (IsDebugTagEnabled("tollium:logappstarter"))
        this->LogDebug("Forwarding errors: " || anytostring(errors,'tree'));

      this->LogApplicationErrors(appname, job->userdata.appid, job->GetExternalSessionData(), errors);
    }
    ELSE IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("Application " || appname || " with id " || job->userdata.appid || " has terminated without errors");

    // Send error/expired message
    job->userdata.msgqueue->QueueMessage(
        [ type :=     job->userdata.expired ? "expired" : "error"
        , appid :=    "A:" || job->userdata.appid
        , errors :=   errors
        , debugtimeout := this->debugconfig.keep_errorterminated_msecs
        ]);

    RECORD pos := RecordLowerBound(this->apps, [ appid := job->userdata.appid ], [ "APPID" ]);
    this->apps[pos.position].stopped := GetCurrentDateTime();
    this->apps[pos.position].errors := errors;

    job->Close();
  }

  MACRO GetJobLinkSignalled(OBJECT job)
  {
    RECORD rec := job->ipclink->ReceiveMessage(DEFAULT DATETIME);
    IF (rec.status = "timeout")
      RETURN;
    IF (rec.status = "gone")
    {
      UnregisterCallback(job->userdata.lcbid);
      job->userdata.lcbid := 0;
      RETURN;
    }

    SWITCH (rec.msg.type)
    {
      CASE "useractivity"
      {
        RECORD pos := RecordLowerBound(this->apps, [ appid := job->userdata.appid ], [ "APPID" ]);
        this->apps[pos.position].lastactivity := GetCurrentDateTime();
      }
      CASE "sessionexpireschange"
      {
        job->userdata.expires := rec.msg.sessionexpires;
      }
      CASE "sessionexpired"
      {
        // Job has expired and will terminate soon
        job->userdata.expired := TRUE;

        job->ipclink->SendReply([ type := "ok" ], rec.msgid);
      }
    }
  }

  UPDATE INTEGER FUNCTION WaitForEvent(INTEGER ARRAY default_handles, DATETIME wait_until)
  {
    RETURN IPCPortHandlerBase::WaitForEvent(default_handles CONCAT this->dispatcher->handles, wait_until);
  }

  UPDATE MACRO OnHandleSignalled(INTEGER handle)
  {
    IF (IsDebugTagEnabled("tollium:logappstarter"))
      this->LogDebug("handlesignalled", handle);
    this->dispatcher->ProcessSignalledHandle(handle);
  }
>;

IF (IsWasm())
  commport := CreateGlobalIPCPort("tollium:wasm-appstarter");
ELSE
  commport := InitManagedScript();

OBJECT handler := NEW AppOwnerPortHandler(commport);
handler->Run();
