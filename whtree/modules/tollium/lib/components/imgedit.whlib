<?wh
LOADLIB "wh::files.whlib";
LOADLIB "wh::graphics/filters.whlib";
LOADLIB "wh::internet/webbrowser.whlib";

LOADLIB "mod::publisher/lib/dialogs.whlib";

LOADLIB "mod::system/lib/database.whlib";
LOADLIB "mod::system/lib/whfs.whlib";
LOADLIB "mod::tollium/lib/componentbase.whlib";
LOADLIB "mod::tollium/lib/screenbase.whlib";
LOADLIB "mod::tollium/lib/internal/support.whlib";

// checkers board background
RECORD imgeditbackground := [ src := checkered_background
                            , position := [ "top", "left" ]
                            ];

RECORD FUNCTION ValidateDimension(STRING newdim, BOOLEAN allowpercentage)
{
  IF(newdim = "")
    RETURN DEFAULT RECORD;

  IF(newdim LIKE "*%")
  {
    IF(NOT allowpercentage)
      THROW NEW Exception(`No percentage value '${newdim}' allowed`);

    INTEGER perc := ToInteger(Left(newdim,Length(newdim)-1),0);
    IF(perc <= 0 OR perc > 1000)
      THROW NEW Exception(`Invalid percentage value '${newdim}'`);

    RETURN CELL[ percentage := perc, x := 0, y := 0 ];
  }
  ELSE IF(newdim LIKE "*x*")
  {
    STRING ARRAY toks := Tokenize(newdim,'x');
    INTEGER x := ToInteger(toks[0],0);
    INTEGER y := Length(toks) >= 2 ? ToInteger(toks[1],0) : 0;

    IF(x <= 0 OR x > 10000 OR y <= 0 OR y > 10000)
      THROW NEW Exception(`Invalid dimension value '${newdim}'`);

    RETURN CELL[ percentage := 0, x, y ];
  }
  ELSE
  {
    THROW NEW Exception(`Invalid image dimension '${newdim}'`);
  }
}

RECORD FUNCTION CalculatePercentage(INTEGER percentage, STRING basedim)
{
  RECORD parsedbasedim := ValidateDimension(basedim, FALSE);
  IF(NOT RecordExists(parsedbasedim))
    THROW NEW Exception(`Cannot take percentage '${percentage}%' from an empty value`);

  RETURN CELL[ x := (parsedbasedim.x * percentage) / 100
             , y := (parsedbasedim.y * percentage) / 100
             ];
}

RECORD FUNCTION CalculateAbsoluteDimension(STRING newdim, STRING parentdim)
{
  RECORD dimension := ValidateDimension(newdim, TRUE);
  IF (dimension.percentage != 0)
    dimension := CalculatePercentage(dimension.percentage, parentdim);

  RETURN dimension;
}

/////////////////////////////////////////////////////////////////////
// The image edit component

PUBLIC OBJECTTYPE TolliumImgEdit EXTEND TolliumFragmentBase <
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  RECORD pvt_value;
  STRING pvt_src;
  BOOLEAN pvt_upload;
  BOOLEAN pvt_publisher;
  STRING pvt_medialibrary;
  RECORD pvt_imgsize;
  INTEGER ARRAY pvt_publisherroots;
  OBJECT ARRAY pvt_custommenuitems;
  STRING __minsize;
  STRING __expectedsize;
  STRING __recommendedsize;


  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  UPDATE PUBLIC PROPERTY value(pvt_value, SetValue);

  // Called when value has changed
  PUBLIC FUNCTION PTR onchange;

  UPDATE PUBLIC PROPERTY title(this->container->title, this->container->title);
  UPDATE PUBLIC PROPERTY width(this->container->width, this->container->width);
  UPDATE PUBLIC PROPERTY height(this->container->height, this->container->height);
  UPDATE PUBLIC PROPERTY hint(this->container->hint, this->container->hint);

  UPDATE PUBLIC PROPERTY required(this->preview->required, this->preview->required);
  UPDATE PUBLIC PROPERTY upload(pvt_upload, SetUpload);
  UPDATE PUBLIC PROPERTY publisher(pvt_publisher, SetPublisher);
  UPDATE PUBLIC PROPERTY medialibrary(pvt_medialibrary, SetMediaLibrary);
  UPDATE PUBLIC PROPERTY publisherroots(pvt_publisherroots, pvt_publisherroots);

  UPDATE PUBLIC PROPERTY minsize(__minsize, SetMinSize);
  UPDATE PUBLIC PROPERTY expectedsize(__expectedsize, SetExpectedSize);
  UPDATE PUBLIC PROPERTY recommendedsize(__recommendedsize, SetRecommendedSize);

  PUBLIC PROPERTY imgsize(pvt_imgsize, SetImgSize);
  PUBLIC PROPERTY customactions(GetCustomActions, SetCustomActions);

  PUBLIC PROPERTY info(^moreinformation->value, ^moreinformation->value);
  PUBLIC PROPERTY htmlinfo(^moreinformation->htmlvalue, ^moreinformation->htmlvalue);


  ///Are we enforcing size checks(requires a user-initiated change)
  PUBLIC BOOLEAN enforcingsizechecks;

  // ---------------------------------------------------------------------------
  //
  // Constructor & tollium admin stuff
  //

  MACRO NEW()
  {
    EXTEND this BY TolliumIsComposable;
    EXTEND this BY TolliumIsDirtyable;
    EXTEND this BY TolliumDownloadKeeper;

    this->pvt_upload := TRUE;
    this->pvt_publisher := TRUE;
    this->pvt_medialibrary := "media";
  }

  UPDATE PUBLIC MACRO StaticInit(RECORD def)
  {
    this->TolliumComponentBase_StaticInit(def);

    this->title := def.title;
    this->required := def.required;
    this->errorlabel := def.errorlabel;
    this->onchange := def.onchange;
    this->upload := def.upload;
    this->publisher := def.publisher;
    this->medialibrary := def.medialibrary;

    this->imgsize := def.imgsize;
    ^imagedimensionsheader->isheading := TRUE; //'secret' property to make a <text> appear as a heading. we can't use <heading> as its a block component

    this->SetExpectedSize(def.expectedsize);
    this->SetMinSize(def.minsize);
    this->SetRecommendedSize(def.recommendedsize);
    ^moreinformation->htmlvalue := def.info;
    ^moreinfo->htmlvalue := `<a href="#">${EncodeHTML(GetTid("tollium:components.imgedit.moreinfo"))}`;

    this->customactions := SELECT AS OBJECT ARRAY component FROM def.actions;
    this->UpdateMoreInfoVisibility();
  }

  UPDATE PUBLIC MACRO SetYamlProps(RECORD props) //Set YAML-based properties. Invoked instead of StaticInit and before setting a value
  {
    IF(CellExists(props,'ref_point')) //refPoint
    {
      this->imgsize := CELL[ method := "none", allowedactions := props.ref_point?['all','refpoint'] : ['all']];
    }

    TolliumFragmentBase::SetYamlProps(props);
  }

  UPDATE PUBLIC MACRO PreInitComponent()
  {
    this->act_upload->mimetypes := [ "image/*" ];
    this->value := this->value; // Initialize preview background images
  }

  UPDATE PUBLIC MACRO PostInitComponent()
  {
    this->UpdateButtonState();

    //this->UpdateSizeInformation(); // FIXME
  }

  UPDATE PUBLIC MACRO ValidateValue(OBJECT work)
  {
    IF(NOT this->enabled) //nothing to check on inactive fields
      RETURN;

    STRING fieldtitle := this->errorlabel!="" ? this->errorlabel : this->title;

    //FIXME: handle when labels are not present!
    IF(this->required AND NOT RecordExists(this->value))
    {
      work->AddErrorFor(this, GetTid("tollium:common.errors.field_required", fieldtitle));
      RETURN;
    }

    IF(RecordExists(this->value) AND this->__minsize != "" AND this->enforcingsizechecks)
    {
      RECORD minsize := ValidateDimension(this->__minsize, TRUE);
      IF(minsize.percentage != 0)
        minsize := CalculatePercentage(minsize.percentage, this->__expectedsize);

      IF(this->value.width < minsize.x OR this->value.height < minsize.y)
        work->AddErrorFor(this, GetTid("tollium:common.errors.image_toosmall", fieldtitle, `${minsize.x}x${minsize.y}`, `${this->value.width}x${this->value.height}`));
    }
  }


  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC MACRO SetValueByUrl(STRING url)
  {
    OBJECT browser := NEW WebBrowser();
    IF (browser->GotoWebPage(url))
    {
      this->value :=
          [ data := browser->content
          , filename := Tokenize(Tokenize(GetNameFromPath(browser->url), "?")[0], "#")[0]
          ];
      IF (this->onchange != DEFAULT FUNCTION PTR)
        this->onchange();
      this->SetDirty();
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO SetExpectedSize(STRING expectedsize)
  {
    IF(expectedsize = this->__expectedsize)
      RETURN;

    ValidateDimension(expectedsize, FALSE);
    this->__expectedsize := expectedsize;

    this->UpdateSizeInformation();
  }

  MACRO SetMinSize(STRING minsize)
  {
    IF(minsize = this->__minsize)
      RETURN;

    ValidateDimension(minsize, TRUE);
    this->__minsize := minsize;

    this->UpdateSizeInformation();
    this->UpdateMoreInfoVisibility();
  }

  MACRO SetRecommendedSize(STRING recommendedsize)
  {
    IF(recommendedsize = this->__recommendedsize)
      RETURN;

    ValidateDimension(recommendedsize, TRUE);
    this->__recommendedsize := recommendedsize;

    this->UpdateSizeInformation();
    this->UpdateMoreInfoVisibility();
  }

  MACRO SetImgSize(RECORD imgsize)
  {
    this->pvt_imgsize := FixImgSize(imgsize);

    this->act_upload->imgsize := this->imgsize;
    this->editaction->imgsize := this->imgsize;
    this->droptarget->acceptdrops.accepttypes :=
        SELECT *, imgsize := this->imgsize
          FROM this->droptarget->acceptdrops.accepttypes;

    this->UpdateSizeInformation();
    this->UpdateMoreInfoVisibility();
  }

  MACRO SetInfo(STRING info)
  {
    ^moreinformation->htmlvalue := info;
    this->UpdateMoreInfoVisibility();
  }

  MACRO UpdateMoreInfoVisibility()
  {
    // NOTE: We don't trigger on only the expected size set, because if it's the only
    //       value which is set it will already be displayed.
    BOOLEAN hasmoreinfo := ^moreinformation->value != "";

    ^moreinfo->visible := hasmoreinfo OR this->__minsize != "" OR this->__recommendedsize != "";
    ^moreinformationheader->visible := hasmoreinfo;
    ^moreinformation->visible := hasmoreinfo;
  }

  MACRO UpdateSizeInformation()
  {
    IF (this->__expectedsize != "")
    {
      RECORD displaysize;
      IF (this->__recommendedsize != "")
      {
        displaysize := ValidateDimension(this->__recommendedsize, TRUE);
        IF(displaysize.percentage != 0)
          displaysize := CalculatePercentage(displaysize.percentage, this->__expectedsize);
      }
      ELSE
        displaysize := ValidateDimension(this->__expectedsize, FALSE);

      ^sizehint->value := GetTid("tollium:components.imgedit.sizehint", ToString(displaysize.x), ToString(displaysize.y));
    }
    ELSE IF (RecordExists(this->imgsize) AND this->imgsize.method != "none")
    {
      STRING ARRAY sizehints;

      IF (this->imgsize.setwidth > 0)
        INSERT "\u2194 " || this->imgsize.setwidth INTO sizehints AT END;
      IF (this->imgsize.setheight > 0)
        INSERT "\u2195 " || this->imgsize.setheight INTO sizehints AT END;

      ^sizehint->value := Detokenize(sizehints, " ");
    }

    STRING ARRAY sizehints;
    RECORD expectedsize := ValidateDimension(this->__expectedsize, FALSE);
    IF (this->__minsize != "")
    {
      RECORD size := CalculateAbsoluteDimension(this->__minsize, this->__expectedsize);
      IF (NOT RecordExists(expectedsize) OR size.x != expectedsize.x OR size.y != expectedsize.y)
        INSERT GetTid("tollium:components.imgedit.imagesizehint-minsize", ToString(size.x), ToString(size.y)) INTO sizehints AT END;
    }
    IF (this->__recommendedsize != "")
    {
      RECORD size := CalculateAbsoluteDimension(this->__recommendedsize, this->__expectedsize);
      IF (NOT RecordExists(expectedsize) OR size.x != expectedsize.x OR size.y != expectedsize.y)
        INSERT GetTid("tollium:components.imgedit.imagesizehint-recommendedsize", ToString(size.x), ToString(size.y)) INTO sizehints AT END;
    }
    IF (RecordExists(expectedsize))
    {
      INSERT GetTid("tollium:components.imgedit.imagesizehint-expectedsize", ToString(expectedsize.x), ToString(expectedsize.y)) INTO sizehints AT END;
    }

    STRING hinttext;
    FOREVERY(STRING hint FROM sizehints)
      hinttext := hinttext || `â€¢ ${hint}<br >`;

    ^imagedimensions->htmlvalue := hinttext;
  }

  UPDATE PUBLIC MACRO CompositionMetadataIsUpdated()
  {
    this->medialibrary := this->medialibrary;
  }

  MACRO OnFileDrop(RECORD dragdata, STRING mode)
  {
    IF (RecordExists(dragdata.items))
    {
      RECORD item := dragdata.items[0];
      RECORD image := WrapBlob(item.data, item.filename);
      IF (CellExists(item, "extradata") AND CellExists(item.extradata, "imageeditor"))
        INSERT CELL extradata := item.extradata INTO image;
      this->OnUploadImage(image);
    }
  }

  // 'upload' button action callback
  MACRO OnUploadImage(RECORD newphoto)
  {
    IF (CellExists(newphoto, "extradata") AND CellExists(newphoto.extradata, "imageeditor"))
    {
      RECORD extradata := newphoto.extradata.imageeditor;
      IF (CellExists(extradata, "SOURCE_FSOBJECT")) //FIXME shouldn't be trusting IDs from the client
      {
        // Check if the supplied object actually/still exists
        INSERT CELL source_fsobject := (SELECT AS INTEGER id
                                          FROM system.fs_objects
                                         WHERE id = extradata.source_fsobject
                                               AND isactive) INTO newphoto;
      }
      IF (CellExists(extradata, "REFPOINT"))
        newphoto := CELL[...newphoto, refpoint := extradata.refpoint ];
      DELETE CELL extradata FROM newphoto;
    }

    this->value := newphoto; //this picks up dominantcolor
    IF (this->onchange != DEFAULT FUNCTION PTR)
      this->onchange();

    this->SetDirty();
    this->enforcingsizechecks := TRUE;
  }

  // 'select from publisher' button action callback
  MACRO PublisherImage()
  {
    this->SelectFromPublisherRoots(this->pvt_publisherroots);
  }

  // 'select from media library' button action callback
  MACRO MediaLibraryImage()
  {
    this->SelectFromPublisherRoots(this->GetMediaLibraryRoots());
  }

  MACRO ResetImage()
  {
    IF (RecordExists(this->value))
    {
      OBJECT imageobj := OpenWHFSObject(this->value.source_fsobject);
      IF (ObjectExists(imageobj))
      {
        RECORD image := WrapBlob(imageobj->data, imageobj->name);
        image.source_fsobject := imageobj->id;
        this->editaction->Execute([ image := image ]);
      }
    }
  }

  // 'edit' button action callback
  MACRO EditImage()
  {
    IF (RecordExists(this->value))
    {
      RECORD image := this->value;
      INSERT CELL src := this->pvt_src INTO image;
      this->editaction->Execute([ image := image ]);
    }
  }

  // 'save' button action callback
  MACRO DownloadImage(OBJECT downloadhandler)
  {
    IF (RecordExists(this->value))
    {
      STRING filename := this->value.filename;
      IF (filename = "" AND this->value.extension != "")
        filename := "image." || this->value.extension;
      downloadhandler->SendFile(this->value.data, this->value.mimetype, filename);
    }
  }

  // 'clear' button action callback
  MACRO ClearImage()
  {
    IF (RecordExists(this->value) AND this->owner->RunSimpleScreen("confirm", GetTid("tollium:commondialogs.messageboxes.remove_image_confirmation")) = "yes")
    {
      this->value := DEFAULT RECORD;
      IF (this->onchange != DEFAULT FUNCTION PTR)
        this->onchange();
      this->SetDirty();
    }
  }

  // Set button titles and enabled states (after value has changed)
  MACRO UpdateButtonState()
  {
    BOOLEAN enabled := this->enabled AND NOT this->readonly;
    BOOLEAN edit_enabled := enabled AND RecordExists(this->value);

    this->act_upload->enabled         := enabled AND this->upload;
    this->act_publisher->enabled      := enabled AND this->publisher;
    this->act_medialibrary->enabled   := enabled AND Length(this->GetMediaLibraryRoots()) > 0;

    this->edit->enabled               := edit_enabled;
    this->clear->enabled              := edit_enabled;
    this->editbutton->visible         := this->edit->enabled;
    this->clearbutton->visible        := this->clear->enabled;

    this->download->enabled           := RecordExists(this->value);
    // The 'other actions' button is visible if there is a value set, or if there are (enabled) custom actions
    this->otherbutton->visible        := RecordExists(this->value) OR RecordExists(SELECT FROM ToRecordArray(this->pvt_custommenuitems, "item") WHERE item->action->IsCurrentlyEnabled());
    // If the 'other actions' button is visible, but there is no value set, hide the default actions (showing only the custom actions)
    IF (this->otherbutton->visible)
    {
      IF (NOT RecordExists(this->value))
      {
        FOREVERY (OBJECT item FROM ^otheractions->GetChildComponents())
          IF (item NOT IN this->pvt_custommenuitems)
            item->visible := FALSE;
      }
      ELSE
      {
        FOREVERY (OBJECT item FROM ^otheractions->GetChildComponents())
          IF (item NOT IN this->pvt_custommenuitems)
            item->visible := TRUE;
      }
    }

    this->uploadbutton->visible       := this->enabled AND this->act_upload->enabled AND NOT RecordExists(this->value);
    this->publisherbutton->visible    := this->enabled AND this->act_publisher->enabled AND NOT RecordExists(this->value);
    this->medialibrarybutton->visible := this->enabled AND this->act_medialibrary->enabled AND NOT RecordExists(this->value);
    ^buttons->visible := ^uploadbutton->visible OR ^publisherbutton->visible OR ^medialibrarybutton->visible OR ^editbutton->visible OR ^clearbutton->visible OR ^otherbutton->visible;
  }

  MACRO SelectFromPublisherRoots(INTEGER ARRAY roots)
  {
    INTEGER imageid := RunBrowseForFSObjectDialog(this->owner,
      [ acceptfiles := TRUE
      , acceptfolders := FALSE
      , acceptunpublished := TRUE
      , accepttypes := [ "http://www.webhare.net/xmlns/publisher/imagefile" ]
      , type := "thumbnails"
      , roots := roots
      , value := RecordExists(this->value) ? this->value.source_fsobject : 0
      ]);
    IF(imageid = 0)
      RETURN;

    OBJECT imageobj := OpenWHFSObject(imageid);
    IF (ObjectExists(imageobj))
    {
      RECORD image := WrapBlob(imageobj->data, imageobj->name);
      IF (image.mimetype NOT IN [ "image/jpeg", "image/png" ])
      {
        // Convert non-jpeg/png images (like bmp, tiff) to jpeg or png, browser must support loading the image in an image element.
        RECORD converted := GfxResizeImageBlobWithMethod(image.data, [ method := "none" ]);
        STRING name := GetBasenameFromPath(imageobj->name);
        IF (converted.mimetype = "image/jpeg")
          name := name || ".jpg";
        ELSE IF (converted.mimetype = "image/png")
          name := name || ".png";
        image := WrapBlob(converted.data, name);
      }

      image.source_fsobject := imageobj->id;
      this->editaction->Execute([ image := image ]);
    }
  }

  MACRO DoProperties()
  {
    RECORD newval := this->owner->RunScreen("mod::tollium/screens/components/imgedit.xml#properties", [ img := this->value, readonly := this->readonly OR NOT this->enabled ]);
    IF(RecordExists(newval))
      this->value := newval;
  }

  MACRO DoShowInfoPanel(STRING url)
  {
    ^mytabs->selectedtab := ^infotab;
  }

  MACRO DoHideInfoPanel()
  {
    ^mytabs->selectedtab := ^imagetab;
  }

  // ---------------------------------------------------------------------------
  //
  // Property getters/setters
  //

  MACRO SetValue(RECORD newval) {
    IF (RecordExists(newval)) {
      //Rewrap only if data appears incomplete:
      RECORD value := CellExists(newval,"filename") AND CellExists(newval, "dominantcolor") ? newval : WrapBlob(newval.data, newval.filename);

      IF (CellExists(newval, "SOURCE_FSOBJECT"))
        value.source_fsobject := newval.source_fsobject;
      IF (CellExists(newval, "REFPOINT"))
        value.refpoint := newval.refpoint;

      IF (RecordExists(this->imgsize))
      {
        RECORD method := this->imgsize; //invokes FixImgSize which will set format to "" if unset.
        IF(method.format IN ["image/webp","image/avif"]) //We can throw, you're explicitly setting an unsupported format (we could support it but would have to involve TS/Sharp)
          THROW NEW Exception(`Unsupported image format '${method.format}' in imageedit property`);
        IF(method.format = "")
          method.format := "keep";

        IF ((method.setwidth > 0 AND value.width > method.setwidth)
            OR (method.setheight > 0 AND value.height > method.setheight)
            OR (method.format != "keep" AND value.mimetype != method.format)
            OR (method.fixorientation AND (value.rotation != 0 OR value.mirrored)))
        {
          DELETE CELL "allowedactions" FROM method;
          DELETE CELL "allowedfilters" FROM method;

          value := MakeUpdatedRecord(value, GfxResizeImageBlobWithMethod(value.data, method));
        }
      }

      this->pvt_value := value;
      this->pvt_src := this->AddInlineDownload(this->pvt_value.data, this->pvt_value.mimetype, this->pvt_value.filename);

      // The fit|width|height value is a special value that is interpreted by the panel/inline component JavaScript code
      this->preview->backgroundimages := [ [ src := this->pvt_src
                                           , repeat := "no-repeat", size := "fit|" || this->pvt_value.width || "|" || this->pvt_value.height
                                           ]
                                         , imgeditbackground
                                         ];
      this->filename->value := newval.filename;
      this->dimensions->value := this->pvt_value.width || "\u00d7" || this->pvt_value.height;
    }
    ELSE
    {
      this->pvt_value := DEFAULT RECORD;
      this->RemoveDownload(this->pvt_src);
      this->pvt_src := "";

      this->preview->backgroundimages := [ imgeditbackground ];
      this->filename->value := GetTid("tollium:components.imgedit.no_image");
      this->dimensions->value := "";
    }

    this->UpdateButtonState();
  }

  UPDATE MACRO SetEnabled(BOOLEAN newstate)
  {
    TolliumFragmentBase::SetEnabled(newstate);
    this->UpdateButtonState();
  }

  MACRO SetUpload(BOOLEAN upload)
  {
    IF (upload != this->pvt_upload)
    {
      this->pvt_upload := upload;
      this->UpdateButtonState();
    }
  }

  MACRO SetPublisher(BOOLEAN publisher)
  {
    IF (publisher != this->pvt_publisher)
    {
      this->pvt_publisher := publisher;
      this->UpdateButtonState();
    }
  }

  MACRO SetMediaLibrary(STRING medialibrary)
  {
    IF (medialibrary != this->pvt_medialibrary)
    {
      this->pvt_medialibrary := medialibrary;
      this->UpdateButtonState();
    }
  }

  INTEGER ARRAY FUNCTION GetMediaLibraryRoots()
  {
    IF(this->medialibrary="")
      RETURN DEFAULT INTEGER ARRAY;

    OBJECT applytester := this->contexts->applytester;
    IF(NOT ObjectExists(applytester))
      RETURN DEFAULT INTEGER ARRAY;

    RETURN applytester->GetLibrary(this->medialibrary);
  }

  OBJECT ARRAY FUNCTION GetCustomActions()
  {
    RETURN SELECT AS OBJECT ARRAY item->action FROM ToRecordArray(this->pvt_custommenuitems, "item");
  }

  MACRO SetCustomActions(OBJECT ARRAY actions)
  {
    OBJECT ARRAY curactions;
    FOREVERY (OBJECT item FROM this->pvt_custommenuitems)
      IF (item->action NOT IN actions)
        item->RemoveFromParent();
      ELSE
        INSERT item->action INTO curactions AT END;

    FOREVERY (OBJECT action FROM actions)
    {
      IF (action NOT IN curactions)
      {
        OBJECT item := this->owner->CreateTolliumComponent("item");
        item->action := action;
        item->disablemode := "hidden";
        this->otheractions->InsertMenuItemAfter(item, DEFAULT OBJECT, FALSE);
        INSERT item INTO this->pvt_custommenuitems AT END;
      }
    }

    this->TolliumHandleAfterInsert(); // also calls this->ExtUpdatedComponent
    this->UpdateButtonState();
  }
>;

PUBLIC STATIC OBJECTTYPE Properties EXTEND TolliumScreenBase
<
  RECORD inputdata;

  MACRO Init(RECORD data)
  {
    this->inputdata := data.img;
    ^filename->value := data.img.filename;
    ^dominantcolor->value := data.img.dominantcolor;

    IF (data.readonly)
    {
      ^filename->enabled := FALSE;
      ^dominantcolor->enabled := FALSE;
      ^buttons->buttons := [ "close" ];
    }
  }
  RECORD FUNCTION Submit()
  {
    OBJECT work := this->BeginFeedback();
    IF(^filename->value NOT LIKE "*" || this->inputdata.extension)
      work->AddErrorFor(^filename, GetTid("tollium:components.imgedit.invalidextension", this->inputdata.extension));

    IF(NOT work->Finish())
      RETURN DEFAULT RECORD;

    RETURN CELL[ ...this->inputdata
               , filename := ^filename->value
               , dominantcolor := ^dominantcolor->value
               ];
  }
>;
