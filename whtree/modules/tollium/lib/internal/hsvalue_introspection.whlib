<?wh
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::devsupport.whlib";
LOADLIB "wh::files.whlib";
LOADLIB "wh::float.whlib";
LOADLIB "wh::money.whlib";
LOADLIB "wh::witty.whlib";
LOADLIB "wh::internal/interface.whlib";
LOADLIB "wh::util/algorithms.whlib";

LOADLIB "mod::system/lib/database.whlib";

PUBLIC STATIC OBJECTTYPE IntrospectionSettings
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  OBJECT pvt_controller;

  INTEGER pvt_maxtreedepth;

  INTEGER pvt_limitbloblength;

  INTEGER pvt_limitstringlength;

  BOOLEAN pvt_hideseenobjects;

  BOOLEAN pvt_onlyuiobjects;

  STRING ARRAY pvt_hideobjecttypes;

  STRING ARRAY pvt_hidemembersforobjecttypes;


  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /// Max depth of shown tree (default: 10 levels)
  PUBLIC PROPERTY maxtreedepth(pvt_maxtreedepth, pvt_maxtreedepth);

  /// Limit the show portion of blobs to this length (default: 2500 characters)
  PUBLIC PROPERTY limitbloblength(pvt_limitbloblength, pvt_limitbloblength);

  /// Limit the show portion of strings to this length (default: 2500 characters)
  PUBLIC PROPERTY limitstringlength(pvt_limitstringlength, pvt_limitstringlength);

  /// Whether to hide already seen objects
  PUBLIC PROPERTY hideseenobjects(pvt_hideseenobjects, pvt_hideseenobjects);

  PUBLIC PROPERTY hidemembersforobjecttypes(pvt_hidemembersforobjecttypes, pvt_hidemembersforobjecttypes);

  PUBLIC PROPERTY onlyuiobjects(pvt_onlyuiobjects, pvt_onlyuiobjects);

  PUBLIC PROPERTY hide_objecttypes(pvt_hideobjecttypes, pvt_hideobjecttypes);




  // ---------------------------------------------------------------------------
  //
  // Constructor & tollium admin stuff
  //

  MACRO NEW()
  {
    //this->pvt_controller := controller;

    // Set the default values
    this->pvt_maxtreedepth := 11;
    this->pvt_limitbloblength := 2500;
    this->pvt_limitstringlength := 2000;
    this->pvt_hideseenobjects := TRUE; // only show each object once

    this->pvt_hideobjecttypes :=
        [ "PVT_OWNER", "PVT_PARENT", "RESOURCEMGR"
        ];

    this->pvt_hidemembersforobjecttypes :=
        [ "WHFSFOLDER" ];
  }
>;



/** @short Helps in serializing data that cannot easily be serialized or can never be fully restored.
           This can be usefull for debugging and sometimes for caching (if you're a lazy basterd who doesn't feel like preventing/deleting ACTIVE FUNCTION PTR's in 'to be cached data')
*/
PUBLIC STATIC OBJECTTYPE HSValueDescriber
<
  // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// References to all seen objects
  OBJECT ARRAY seenobjects;

  /// Descriptions of all seen objects
  RECORD ARRAY seenobjects_recs;

  /** gather extra information on known OBJECTTYPE's such as:
        - WRDSCHEMA
        - WRDTYPE
        - WRDENTITY
        - WHFSOBJECT
        - SITEOBJECT
        - WHFSTYPE
  */
  PUBLIC BOOLEAN gathermetadata;

  PUBLIC OBJECT debug;

  DATETIME hson_max_datetime; // HSON refuses to decode a date above the year 9999


  MACRO NEW()
  {
    this->hson_max_datetime := MakeDate(10000, 1, 1);
    this->debug := NEW IntrospectionSettings();
  }

  /** @short make a RECORD containing a description of the content of the data.
             (WEAK)OBJECT's, ACTIVE FUNCTION PTR's cannot be restored,
             but some information is kept for introspection/debugging purposes.
  */
  PUBLIC RECORD FUNCTION Describe(VARIANT data)
  {
    this->seenobjects := DEFAULT OBJECT ARRAY;
    this->seenobjects_recs := DEFAULT RECORD ARRAY;
    VARIANT content := this->GetVarDescription("", data, 0, FALSE, FALSE);

    RETURN [ type     := "SPC_HSVAR_DESCRIPTION"
           , content  := content
           , objects  := this->seenobjects_recs
           , settings := [ maxtreedepth      := this->debug->maxtreedepth
                         , limitbloblength   := this->debug->limitbloblength
                         , limitstringlength := this->debug->limitstringlength
                         //, hidemembers       := this->debug->hidemembers
                         , hide_objecttypes  := this->debug->hide_objecttypes
                         , hidemembersforobjecttypes := this->debug->hidemembersforobjecttypes
                         , gathermetadata := this->gathermetadata
                         ]
           ];
  }

  // ---------------------------------------------------------------------------
  //
  // Formatter functions
  //

  VARIANT FUNCTION GetVarDescription(STRING name, VARIANT value, INTEGER level, BOOLEAN isprivate, BOOLEAN inobject)
  {
    INTEGER valuetype := TypeId(value);
    BOOLEAN hasChildren  := FALSE;

    INTEGER ARRAY skip_typeids :=
          [ TypeId(BOOLEAN)
          , TypeId(INTEGER)
          , TypeId(INTEGER64)
          , TypeId(STRING)
          , TypeId(MONEY)
          , TypeId(FLOAT)
          , TypeId(DATETIME)
          ];

    /* This didn't seem to actually trigger an issue? Disabling for now, otherwise consider clamping but this otherwise breaks the WRD dataviewer
    IF (valuetype = TypeId(DATETIME) AND value > this->hson_max_datetime AND value != MAX_DATETIME)
    {
      THROW NEW Exception("Dates above the year 9999 cannot be encoded.");
    }*/

    IF (valuetype IN skip_typeids)
      RETURN value;

    SWITCH(valuetype)
    {

      CASE TypeId(VARIANT) // this should never happen?
      {
        THROW NEW Exception("VARIANT's not supported yet.");
      }

      CASE TypeId(BLOB)
      {
        RETURN
            [ hstype := "BLOB"
            , length := Length(value)
            , value  := BlobToString(value, this->debug->limitbloblength)
            ];
      }

      CASE TypeId(FUNCTION PTR)
      {
        RETURN this->GetFunctionPointerDescription(value, inobject);
      }

      CASE TypeId(RECORD)
      {
        IF (NOT RecordExists(value))
          RETURN DEFAULT RECORD;

        // intextlink (from contenttype members of type "intextlink" or value from the Publisher's <intextlink> component)
        IF (this->gathermetadata
            AND CellExists(value, "externallink")
            AND CellExists(value, "internallink")
            AND TypeID(value.externallink) = TypeID(STRING)
            AND TypeID(value.internallink) = TypeID(INTEGER))
          RETURN this->GetIntExtLinkDescription(value);

        RETURN this->GetRecordDescription(value, level + 1);
      }

      CASE TypeId(OBJECT)
      {
        IF(value EXTENDSFROM JsonObject)
          RETURN this->GetJSONObjectDescription(value, level + 1);
        IF(value EXTENDSFROM JsonArray)
          RETURN this->GetJSONArrayDescription(value, level + 1);

        RETURN this->GetObjectDescription(name, value, level + 1, FALSE);
      }

      CASE TypeID(WEAKOBJECT)
      {
        OBJECT normalobject := OBJECT(value);
        RETURN this->GetObjectDescription(name, normalobject, level + 1, TRUE);
      }

      DEFAULT
      {
        IF (IsTypeidArray(valuetype))
        {
          INTEGER arraycontenttype := valuetype - 0x80; // remove ARRAY flag
          RETURN this->GetArrayDescription(value, level + 1).description;
        }
        ELSE
        {
          THROW NEW Exception("Unknown/unsupported type "||GetTypeName(valuetype));
        }

        RETURN value;
      }
    }
  }

  /**   @short Create a description of the function pointer
        @param value The function pointer
  */
  RECORD FUNCTION GetFunctionPointerDescription(FUNCTION PTR value, BOOLEAN inobject)
  {
    IF (value = DEFAULT FUNCTION PTR)
      RETURN [ hstype := "PTR" ];

    RECORD fptrRecord := __INTERNAL_DEBUGFUNCTIONPTRTORECORD(value);
    RECORD ARRAY unpacked := UnpackRecord(fptrRecord);

    // If we are in an object we have to skip the first parameter,
    // because it's bound to the OBJECT in which it resides
   IF(inobject) // FIXME: SliceArray is faster?
      fptrRecord.parameters := SELECT * FROM fptrRecord.parameters AS param WHERE #param > 0; //":TYPE"||varidx

    fptrRecord.parameters :=
        SELECT *
             , DELETE value // FIXME: we might want to describe these too? (probably the bound parameters)
          FROM fptrRecord.parameters;

    DELETE CELL vm FROM fptrRecord;
    INSERT CELL hstype := "PTR" INTO fptrRecord;

    RETURN fptrRecord;
  }

  /**   @short Make a list of all items in an array
        @param data The data to parse
        @param level Current level (depth) of recursion
        @return String with a list of all items in the array
  */
  RECORD FUNCTION GetArrayDescription(VARIANT thearray, INTEGER level)
  {
    IF (Length(thearray) = 0)
      RETURN [ description := thearray ];

    INTEGER array_item_typeid := TypeID(thearray) - 0x80;

    //IF (level > this->debug->maxtreedepth)
    //  RETURN 'max level reached!';

    IF (NOT IsTypeidArray( TypeId(thearray) ))
      THROW NEW Exception ("GetArrayDescription() expects data of any type of array.");

    // Types which we must describe in a RECORD
    // (to support VARIANT we need to store the value as [ value := descr ])
    // FIXME: or make 3 paths (VARIANT, FPTR/OBJ/WEAKOBJ, other simpler types)
    IF (array_item_typeid IN [TypeId(FUNCTION PTR), TypeID(OBJECT), TypeID(WEAKOBJECT), TypeID(VARIANT), TypeID(BLOB)])
    {
      RECORD retval := [ description := DEFAULT RECORD ARRAY ]; // we convert FUNCTION PTR ARRAYs and OBJECT ARRAY's into a RECORD ARRAY with description
      FOREVERY(VARIANT arrayitem FROM thearray)
      {
        VARIANT descr := this->GetVarDescription(""/*parentname but we don't care*/, arrayitem, level, FALSE, FALSE);
        //IF (array_item_typeid = TypeID(VARIANT) AND TypeID(descr) != TypeID(RECORD))
        //  INSERT descr [ hstypeid := TypeID(descr), value := descr ] INTO retval.description AT END;
        //ELSE
          INSERT [ value := descr ] INTO retval.description AT END;
      }

      // since we must represent FUNCTION PTR ARRAY's and OBJECT ARRAY's as RECORD ARRAY,
      // we have to store information on the original type
      RETURN [ description := [ hstypeid := TypeID(thearray) //array_item_typeid
                              , items    := retval.description
                              ]
             ]; // we convert FUNCTION PTR ARRAYs and OBJECT ARRAY's into a RECORD ARRAY with description
    }
    ELSE
    {
      // CAST into the correct type of ARRAY
      RECORD retval := [ description := GetTypeDefaultArray(array_item_typeid) ];
      FOREVERY(VARIANT arrayitem FROM thearray)
      {
        VARIANT descr := this->GetVarDescription(""/*parentname but we don't care*/, arrayitem, level, FALSE, FALSE);
        INSERT descr INTO retval.description AT END;
      }

      RETURN retval;
    }
  }



  /** @short convert an OBJECT into a RECORD describing the OBJECT
      @return
      @cell return.hstype
      @cell return.vars all variables, functions and properties as variables
      @cell return.privatevars the list of names of private variables, functions and properties
      @cell return.typenames all OBJECTTYPES of which this OBJECT is derived
      @cell return.id the ID this OBJECT instance had runtime (used to store references in our data description)
      @cell return.cutoff if this field exists (and is TRUE) the vars and privatevars aren't stored
                          (either because the OBJECT was nested too deep or because the OBJECT's name or one of it's OBJECTTYPES are on the blacklist)
  */
  RECORD FUNCTION GetObjectDescription(STRING name, OBJECT value, INTEGER level, BOOLEAN weak)
  {
    RECORD objectdescription :=
        [ vars        := DEFAULT RECORD
        , privatevars := DEFAULT STRING ARRAY
        , typenames   := GetObjectExtendNames(value)
        , id          := __INTERNAL_GETOBJECTID(value)
        ];

    RECORD reference :=
        [ hstype := "OBJECT"
        , id     := objectdescription.id
        , weak   := weak // if TRUE, this reference is not refcounted for garbage collection
        ];

    RECORD seen := SELECT * FROM this->seenobjects_recs WHERE id = objectdescription.id;
    //IF(value IN this->seenobjects)
    IF (RecordExists(seen)
        AND (NOT CellExists(seen, "cutoff") // maybe this time the OBJECT wasn't too deep, let's retry
             OR level <= this->debug->maxtreedepth
             OR seen.cutoff != "toodeep"
            )
       )
    {
      // return the reference
      RETURN reference;
    }

    // insert the ID in our list of seen objects BEFORE creating the definition,
    // so while recursing through the OBJECT we don't trying to reparse/recurse into the same OBJECT again
    INSERT value INTO this->seenobjects AT END;

    IF (NOT ObjectExists(value))
    {
      INSERT objectdescription INTO this->seenobjects_recs AT END;
      RETURN reference;
    }

    IF (level > this->debug->maxtreedepth)
    {
      // too deep, don't describe
      INSERT CELL cutoff := "toodeep" INTO objectdescription;
      INSERT objectdescription INTO this->seenobjects_recs AT END;
      RETURN reference;
    }



    // Don't store content information if this OBJECT is derived from one of the OBJECTTYPES in our blacklist
    IF (level > 1 AND ArraysIntersect(objectdescription.typenames, this->debug->hide_objecttypes))
    {
      INSERT CELL cutoff := "hiddentype" INTO objectdescription;
      INSERT value INTO this->seenobjects AT END;
      INSERT objectdescription INTO this->seenobjects_recs AT END;
      RETURN reference;
    }

    IF (RecordExists(seen))
    {
      //PRINT("Redoing object description");

      // The object was already described (but incomplete last time)
      // Throw away the object description, because this time whe'll make a complete description
      DELETE FROM this->seenobjects_recs WHERE id = objectdescription.id;
    }

    IF (this->gathermetadata)
    {
      IF ("WRDSCHEMA" in objectdescription.typenames)
      {
        INSERT CELL interpreted :=
            [ type := "WRDSCHEMA"
            , id   := value->id // value->schemarec.id
            , name := value->name // value->schemarec.name
            , usermgmt := value->usermgmt // value->schemarec.usermgmt
            , currentlanguage := value->currentlanguage // value->pvt_currentlanguage
            ] INTO objectdescription;
      }
      IF ("WRDTYPE" in objectdescription.typenames)
      {
        INSERT CELL interpreted :=
            [ type := "WRDTYPE"
            , id   := value->id
            , tag := value->tag
            ] INTO objectdescription;
      }
      IF ("WRDENTITY" in objectdescription.typenames)
      {
        INSERT CELL interpreted :=
            [ type := "WRDENTITY"
            , id   := value->id
            , title := "FIXME:add title" //value->title
            , schemaname := value->wrdschema->name
            , typetag := value->wrdtype->tag
            , guid := value->guid
            ] INTO objectdescription;
      }

      // OBJECT's from module "system"
      IF ("WHFSOBJECT" in objectdescription.typenames)
      {
        INSERT CELL interpreted :=
            [ type := "WHFSOBJECT"
            , id   := value->id // value->schemarec.id
            , name := value->name // value->schemarec.name
            , title := value->title
            , url := value->url
            , whfspath := value->whfspath
            , fullpath := value->fullpath
            ] INTO objectdescription;
      }
      IF ("SITEOBJECT" in objectdescription.typenames)
      {
        INSERT CELL interpreted :=
            [ type := "SITEOBJECT"
            , id   := value->id
            , name := value->name
            , webroot := value->webroot
            ] INTO objectdescription;
      }
      IF ("WHFSTYPE" in objectdescription.typenames) // defined in mod::system/lib/internal/whfs/contenttypes.whlib
      {
        INSERT CELL interpreted :=
            [ type := "WHFSTYPE"
            , id   := value->id // value->typedef.id
            , namespace := value->namespace // value->typedef.name
            //, defaultinstance := value->defaultinstance
            //, title :=  // FIXME: required more work to get...
            ] INTO objectdescription;

      }
    }

    IF (ArraysIntersect(objectdescription.typenames, this->debug->hidemembersforobjecttypes))
    {
      INSERT CELL membershidden := TRUE INTO objectdescription;
      INSERT objectdescription INTO this->seenobjects_recs AT END;
      RETURN reference;
    }



    RECORD ARRAY unpacked := UnpackRecord(__INTERNAL_DebugCopyObjectToRecord(value));
    //ABORT(AnyToString(unpacked,"tree"));
    FOREVERY(RECORD memberrec FROM unpacked)
    {
      BOOLEAN isprivate := GetMemberType(value, memberrec.name) = "PRIVATE";

      VARIANT valuedescription := this->GetVarDescription(memberrec.name, memberrec.value, level, isprivate, TRUE);
      objectdescription.vars := CellInsert(objectdescription.vars, memberrec.name, valuedescription);

      IF (isprivate)
        INSERT memberrec.name INTO objectdescription.privatevars AT END;
    }

    value := __HS_INTERNAL_MakeObjectReferencePrivileged(value); // to allow inspection of private members
    RECORD contents := __INTERNAL_DescribeObjectStructure(value, TRUE);

    FOREVERY(RECORD method FROM contents.methods)
    {
      FUNCTION PTR func := GetObjectMethodPtr(value, method.name);
      VARIANT valuedescription := this->GetVarDescription(method.name, func, level, NOT method.is_public, TRUE);
      objectdescription.vars := CellInsert(objectdescription.vars, method.name, valuedescription);

      IF (NOT method.is_public)
        INSERT method.name INTO objectdescription.privatevars AT END;
    }

    FOREVERY(RECORD objproperty FROM contents.properties)
    {
      // Note that for variable members the getter/setter returns the name of the autocreated function which
      // redirects to the variable.
      objectdescription.vars := CellInsert( objectdescription.vars
                                          , objproperty.name
                                          , [ hstype := "PROPERTY"
                                            , getter := objproperty.getter
                                            , setter := objproperty.setter
                                            ]
                                          );

      IF (NOT objproperty.is_public)
        INSERT objproperty.name INTO objectdescription.privatevars AT END;
    }

    INSERT objectdescription INTO this->seenobjects_recs AT END;

    RETURN reference;
  }

  /** @short fixup all fields within the specified record
  */
  RECORD FUNCTION GetRecordDescription(RECORD value, INTEGER level)
  {
    IF (level > this->debug->maxtreedepth)
      RETURN [ hstype := "CUTOFF" ]; // too deep, delete from here
    IF(NOT RecordExists(value))
      RETURN DEFAULT RECORD;

    RECORD ARRAY unpacked := SELECT * FROM UnpackRecord(value) ORDER BY ToUpperCase(name);

    RECORD fixedrecord := CELL[];

    // unpacked function pointer or record
    FOREVERY(RECORD field FROM unpacked)
      fixedrecord := CellInsert(fixedrecord, field.name, this->GetVarDescription(field.name, field.value, level, FALSE, FALSE));

    RETURN fixedrecord;
  }

  /** @short fixup all fields within the specified record
  */
  RECORD FUNCTION GetJSONObjectDescription(OBJECT value, INTEGER level)
  {
    IF (level > this->debug->maxtreedepth)
      RETURN [ hstype := "CUTOFF" ]; // too deep, delete from here
    IF(NOT ObjectExists(value))
      RETURN DEFAULT RECORD;

    RECORD ARRAY unpacked := SELECT * FROM value->Unpack() ORDER BY ToUpperCase(name);

    RECORD fixedrecord := [ hstype := "OBJECT"
                          , objtype := "JSONObject"
                          , id     := __INTERNAL_GETOBJECTID(value)
                          , elements := RECORD[]
                          ];

    FOREVERY(RECORD field FROM unpacked)
      INSERT CELL[field.name, value := this->GetVarDescription(field.name, field.value, level, FALSE, FALSE) ] INTO fixedrecord.elements AT END;

    RETURN fixedrecord;
  }
  /** @short fixup all fields within the specified record
  */
  RECORD FUNCTION GetJSONArrayDescription(OBJECT value, INTEGER level)
  {
    IF (level > this->debug->maxtreedepth)
      RETURN [ hstype := "CUTOFF" ]; // too deep, delete from here
    IF(NOT ObjectExists(value))
      RETURN DEFAULT RECORD;

    RECORD ARRAY unpacked := SELECT name := ToString(#el), value := val FROM ToRecordArray(value->GetRawElements(),"val") AS el;

    RECORD fixedrecord := [ hstype := "OBJECT"
                          , objtype := "JSONArray"
                          , id     := __INTERNAL_GETOBJECTID(value)
                          , elements := RECORD[]
                          ];

    // unpacked function pointer or record
    FOREVERY(RECORD field FROM unpacked)
      INSERT CELL[field.name, value := this->GetVarDescription(field.name, field.value, level, FALSE, FALSE) ] INTO fixedrecord.elements AT END;

    RETURN fixedrecord;
  }
  /** @short
      @return
      @cell hstype "intextlink"
      @cell value  described RECORD
      @cell interpreted (optional) cell not returned for internallinks which could not be resolved
      @cell interpreted.url
      @cell interpreted.whfspath (optional, used if not an external link)
      @cell interpreted.sitename (optional, if file/folder is in a site)
      @cell interpreted.fullpath (optional)
  */
  RECORD FUNCTION GetIntExtLinkDescription(RECORD value)
  {
    IF (value.externallink != "")
    {
      RETURN [ hstype := "intextlink"
             , value  := this->GetRecordDescription(value, 0/*FIXME*/) // to be safe we handle this as a normal RECORD
             , interpreted := [ url := value.externallink ]
             ];
    }

    IF (value.internallink = 0)
    {
      // the file/folder may have been deleted and the internallink field has been reset to 0
      RETURN [ hstype := "intextlink"
             , value  := this->GetRecordDescription(value, 0/*FIXME*/) // to be safe we handle this as a normal RECORD
             ];
    }

    RECORD fsobj := SELECT fullpath
                         , whfspath
                       //, sitename := //(parentsite = 0 ? "" : OpenSite(parentsite)->name)
                         , sitename := (parentsite = 0 ? "" : (SELECT AS STRING name FROM system.fs_objects WHERE id = parentsite))
                         , url
                      FROM system.fs_objects
                     WHERE id = value.internallink
                           AND isactive; // not trashed

    IF (NOT RecordExists(fsobj)) // empty value (never set yet, non-required field or the object it pointed to was deleted)
    {
      RETURN [ hstype := "intextlink"
             , value  := this->GetRecordDescription(value, 0/*FIXME*/) // to be safe we handle this as a normal RECORD
             ];
    }

    IF (fsobj.sitename = "") // file is not in a site
    {
      RETURN [ hstype := "intextlink"
             , value  := this->GetRecordDescription(value, 0/*FIXME*/) // to be safe we handle this as a normal RECORD
             , interpreted := [ url      := fsobj.url
                              , whfspath := fsobj.whfspath // "/path/to/file.rtd"
                              ]
             ];
    }

      RETURN [ hstype := "intextlink"
             , value  := this->GetRecordDescription(value, 0/*FIXME*/) // to be safe we handle this as a normal RECORD
             , interpreted := [ url      := fsobj.url
                              , whfspath := fsobj.whfspath // "/path/to/file.rtd"
                              , sitename := fsobj.sitename
                              , fullpath := fsobj.fullpath
                              ]
             ];
  }

>;




/** @short tooling objecttype for creating HTML views of data or to walk throught contents of the variable
*/
PUBLIC STATIC OBJECTTYPE HSValueDumper
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// whether the data we got is an "described" value (auto detected)
  BOOLEAN is_description;

  /// List of already seen objects
  OBJECT ARRAY seenobjects;
  INTEGER ARRAY seenobjectids;

  /// Whether only ui objects should be shown
  //BOOLEAN onlyuiobjects;
  PUBLIC BOOLEAN showprivate;

  // Skip type detection (show the RAW value description)
  PUBLIC BOOLEAN forceshowraw;

  // Up to which depth we must auto expand the tree
  PUBLIC INTEGER expandlevel;


  STRING htmlcontent;

  PUBLIC OBJECT debug;

  RECORD currentvalue;


  /** Initialize debug screen
      @param params
      @cell params.data Data to show
      @cell params.tree Whether data must be shown as a tree
      @cell params.onlyuiobjects Whether non ui-stuff should be hidden
  */
  MACRO NEW()
  {
    this->debug := NEW IntrospectionSettings();
    this->forceshowraw := FALSE;
    this->showprivate := TRUE;
    this->expandlevel := 1;
  }


  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  PUBLIC BOOLEAN FUNCTION IsDescribedValue(VARIANT value)
  {
    RETURN TypeId(value) = TypeId(RECORD) AND RecordExists(value) AND CellExists(value, "type") AND TypeID(value.type) = TypeID(STRING) AND value.type = "SPC_HSVAR_DESCRIPTION";
  }

  PUBLIC STRING FUNCTION StyledAnyToHTML(VARIANT data, OBJECT iframe DEFAULTSTO DEFAULT OBJECT)
  {
    OBJECT witty := LoadWittyLibrary(Resolve("hsvalue_debugdump.witty"),"HTML");
    RETURN witty->RunToString([ body := this->AnyToHTML(data)
                              //, supportjs := ObjectExists(iframe) ? iframe->GetToddIframeUrl() : ""
                              ]);
  }

  PUBLIC BLOB FUNCTION StyledAnyToHTMLBlob(VARIANT data, OBJECT iframe DEFAULTSTO DEFAULT OBJECT)
  {
    OBJECT witty := LoadWittyLibrary(Resolve("hsvalue_debugdump.witty"),"HTML");
    RETURN witty->RunToBlob([ body := this->AnyToHTML(data)
                            //, supportjs := ObjectExists(iframe) ? iframe->GetToddIframeUrl() : ""
                            ]);

  }


  // ---------------------------------------------------------------------------
  //
  // Formatter functions
  //

  STRING FUNCTION DumpTypeStart(STRING name, VARIANT value, INTEGER level, BOOLEAN isprivate, INTEGER arrindex)
  {
    this->currentvalue := value;
    this->seenobjects := DEFAULT OBJECT ARRAY;
    this->seenobjectids := DEFAULT INTEGER ARRAY;

    IF (NOT this->forceshowraw AND this->IsDescribedValue(value))
    {
      IF (NOT CellExists(value, "content") OR NOT CellExists(value, "objects") OR NOT CellExists(value, "settings"))
        THROW NEW Exception("incomplete SPC_HSVAR_DESCRIPTION");

      this->is_description := TRUE;
      RETURN this->DumpType(name, value.content, level, isprivate, arrindex);
    }
    ELSE
    {
      this->is_description := FALSE;
      RETURN this->DumpType(name, value, level, isprivate, arrindex);
    }
  }


  STRING FUNCTION DumpType(STRING name, VARIANT value, INTEGER level, BOOLEAN isprivate, INTEGER arrindex, RECORD containerobject DEFAULTSTO DEFAULT RECORD)
  {
    INTEGER valuetype := TypeId(value);
    STRING typename := GetTypeName(valuetype);

    STRING varinfo;
    STRING varcontent;                                    // dump of the contents of the data

    BOOLEAN hasChildren  := FALSE;
    BOOLEAN expanded     := TRUE;                   // tree opened or closed
    BOOLEAN toluielement := FALSE;                  // is it a (visible) Tollium UI element?

    SWITCH(valuetype)
    {
    CASE TypeId(BOOLEAN)   { varcontent := name || " = " || (value ? 'TRUE' : 'FALSE'); }
    CASE TypeId(INTEGER)   { varcontent := name || " = " || value; }
    CASE TypeId(INTEGER64) { varcontent := name || " = " || value; }

    CASE TypeId(STRING)
      {
        IF (UCLength(value) < this->debug->limitstringlength)
        {
          IF (Left(value, 7) = "http://" OR Left(value, 8) = "https://")
            varcontent := name || " = '<a href=\"" || value || "\">" || EncodeHTML(value) || "</a>'";
          ELSE IF (Left(value, 2) = "//")
            varcontent := name || " = '<a href=\"http://" || value || "\">" || EncodeHTML(value) || "</a>'";
          ELSE
            varcontent := name || " = '" || EncodeHTML(value) || "'";
        }
        ELSE
        {
          // NOTE: Length returns the bytes
          INTEGER lenbytes := Length(value);
          INTEGER lenchars := UCLength(value);
          IF (lenbytes = lenchars)
            varcontent := name || "(" || lenbytes || " bytes/chars, partly shown) = '" || EncodeHTML(UCLeft(value, this->debug->limitstringlength)) || "'";
          ELSE
            varcontent := name || "(" || lenbytes || " bytes, " || lenchars || " chars, partly shown) = '" || EncodeHTML(UCLeft(value, this->debug->limitstringlength)) || "'";
        }
      }

    CASE TypeId(MONEY)     { varcontent := name || " = " || FormatMoney(value,2,'.','',false); }
    CASE TypeId(FLOAT)     { varcontent := name || " = " || FormatFloat(value,4); }

    CASE TypeId(DATETIME)
    {
      /*
      ADDME: show milliseconds in a smaller fontsize?
      FIXME: add support for year >9999 ? (not encoded in HSON)
      ADDME: detect low DATETIME's as representation of Tollium Time ?
      */
      STRING dtstring;
      IF (value = DEFAULT DATETIME)
        dtstring := "DEFAULT DATETIME";
      ELSE IF (value = MAX_DATETIME)
        dtstring := "MAX_DATETIME";
      ELSE
      {
        dtstring := FormatDateTime('%a, %#d %B %Y %H:%M:%S.%Q',value);

        // If the time is a round number hide the parts which consist only of zeroes
        IF (Right(dtstring, 13) = " 00:00:00.000") // only the DATE part seems relevant
          dtstring := SubString(dtstring, 0, Length(dtstring) - 13);// || '<span class="dt_irrelevant">' || " 00:00:00.000" || '</span>';
        ELSE IF (Right(dtstring, 7) = ":00.000") // DATETIME, but not specific to the second/millisecond
          dtstring := SubString(dtstring, 0, Length(dtstring) - 7);// || '<span class="dt_irrelevant">' || ":00.000" || '</span>';
      }

      varcontent := name || " = " || dtstring;

      // FIXME: (since 5 jan 2016 a date on day 42 is actually a TIME)
    }

    CASE TypeId(VARIANT)   { varcontent := name || " = <span class='error'>VARIANT</span>"; }

    CASE TypeId(BLOB)      { varcontent := name || " (length = " || Length(value) || ")<br />" || EncodeHTML(BlobToString(value,this->debug->limitbloblength)); }

    CASE TypeId(FUNCTION PTR)
      {
        IF (value = DEFAULT FUNCTION PTR)
        {
          varinfo    := name;
          varcontent := name || ' = DEFAULT ' || typename;
        }
        ELSE
        {
          RECORD fptrRecord     := __INTERNAL_DEBUGFUNCTIONPTRTORECORD(value);
          RECORD ARRAY unpacked := UnpackRecord(fptrRecord);

          hasChildren := TRUE;
          expanded    := FALSE; // we rarely need details about function pointers
          INTEGER returnType   := fptrRecord."RETURNTYPE";
          STRING returnTypeStr := GetTypeName(returnType);

          IF (returnTypeStr = '*NORETURN*')
            returnTypeStr := 'MACRO';

          STRING paramsList;
          FOR(INTEGER varCount := 1; CellExists(fptrRecord, ":TYPE"||varCount); varCount := varCount + 1)
          {
            paramsList := paramsList || ',' || GetTypeName(GetCell(fptrRecord, ":TYPE"||varCount));
          }

          varinfo := name || ' (Function Ptr)';
          varcontent := "definition = " || returnTypeStr || ' (' || paramsList || ")<br />\n"
                     || "library = "    || fptrRecord.library || "<br />\n"
                     || "function = "   || fptrRecord."function" /*getCell(fptrRecord,'function')*/ || "<br />\n"
                     || this->WalkUnpacked(unpacked , level+1) || "\n";
        }
      }

    CASE TypeId(RECORD)
      {
        IF (this->is_description AND (CellExists(value, "hstype") OR CellExists(value, "hstypeid")))
        {
          // Decode descriptions of variable types that cannot be fully serialized/restored
          RECORD description := this->HandleDescribedVar(name, value, level, containerobject);
          varcontent := description.varcontent;
          varinfo := description.varinfo ?? name;

          IF (description.typename != "")
            typename := description.typename;

          haschildren := description.haschildren;
          expanded    := description.expanded;
        }
        ELSE IF (RecordExists(value)) // just a plain RECORD
        {
          RECORD ARRAY unpacked := UnpackRecord(value);
          IF(Length(unpacked)=0)
          {
            varcontent := name || " = EMPTY " || typename;
          }
          ELSE
          {
            hasChildren := TRUE;
            varinfo     := name;
            expanded    := level < this->expandlevel;
            varcontent  := this->WalkUnpacked(unpacked , level+1);
          }
        }
        ELSE
        {
          varcontent := name || " = DEFAULT " || typename;
        }
      }

    CASE TypeId(OBJECT)
      {
      }

    // Reference to another VM
    CASE 0x41
      {
        varcontent := '';
      }

    DEFAULT
      {
        IF (IsTypeidArray(valuetype))
        {
          INTEGER arraycontenttype := valuetype - 0x80; // remove ARRAY flag

          INTEGER arrLen := Length(value);
          IF (arrLen = 0)
          {
            varcontent := name || " = DEFAULT " || typename;
          }
          ELSE
          {
            hasChildren := TRUE;
            varinfo := name || " (length=" || LENGTH(value) || ")";
            varcontent := this->WalkThroughArray(value, level+1, name);
            expanded    := level < this->expandlevel;
          }
        }
        ELSE
        {
          varcontent := name || ' <span class="error">Unknown or unsupported type</span>';
        }
      }
    }


    // Hide all simple data (without children)
    IF (this->debug->onlyuiobjects AND NOT toluielement AND (NOT haschildren OR valuetype = TypeID(FUNCTION PTR)))
      RETURN '';


    STRING infohdr;
    IF (arrindex > -1)
      infohdr := '[' || arrindex || '] ';
    infohdr := infohdr || '<span class="vtype">' || typename || '</span> ' || varinfo;

    IF (hasChildren)
    {
      IF (level = 0)
      {
        // make the first level collapsable makes no sense
        RETURN "<h1>" || infohdr || "</h1>" || varcontent || "\n";
      }
      ELSE
      {
        RETURN `<li class="isarray ${expanded ? 'open' : 'closed'}"">
                  <div class="toggleme header ${isprivate ? ' private' : ''}">${infohdr}</div>
                  <ul ${expanded ? '' : ' hidden="until-found"'}>${varcontent}</ul>
                </li>\n`;
      }
    }
    ELSE
    {
      RETURN '<li ' || (isprivate ? 'class="private"' : '') || '>' || infohdr || varcontent || "</li>\n";
    }
  }


  RECORD FUNCTION HandleDescribedVar(STRING name, RECORD value, INTEGER level, RECORD containerobject)
  {
    STRING varinfo;
    STRING varcontent;                  // dump of the contents of the data
    STRING typename;

    BOOLEAN hasChildren  := FALSE;
    BOOLEAN expanded     := level < 1;  // tree opened or closed
    BOOLEAN toluielement := FALSE;      // is it a (visible) Tollium UI element?

    IF (CellExists(value, "hstypeid"))
    {
      IF (IsTypeidArray(value.hstypeid)) // describing an RECORD or VARIANT ARRAY
      {
        //INTEGER arraycontenttype := value.hstypeid - 0x80; // remove ARRAY flag
        typename := GetTypeName(value.hstypeid);
        haschildren := TRUE;

        IF (Length(value.items) = 0) // empty array?
        {
          varcontent := name || " = DEFAULT " || typename;
        }
        ELSE
        {
          hasChildren := TRUE;
          varinfo := name || " (length=" || Length(value.items) || ")";
          expanded    := level < this->expandlevel;
          varcontent := '<div class="content">' || this->WalkThroughDescribedArray(value.items, level+1, name) || '</div>';
        }
      }
      ELSE
      {
        THROW NEW Exception("description record for unknown vartype #" || value.hstypeid || " (" || GetTypeName(value.hstypeid) || ")" || AnyToString(value, "tree") );
      }
    }
    ELSE
    {
      SWITCH(value.hstype)
      {
        CASE "CUTOFF" // was too deep or object namer or type was on the blacklist
        {
          varcontent := " (too deep, not stored)";
          hasChildren := FALSE;
        }

        CASE "BLOB"
        {
          haschildren := TRUE;
          typename := "BLOB";
          varinfo := name;
          varcontent := '<div class="content">(length = ' || value.length || ')<br />' || EncodeHTML(value.value);
        }

        // FIXME: parameters not correctly shown yet??
        CASE "PTR"
        {
          haschildren := TRUE;

          RECORD fptrRecord := value;

          IF (NOT CellExists(value, "function"))
          {
            typename := "DEFAULT FUNCTION PTR";
            varinfo := name;
            varcontent := "";
          }
          ELSE
          {
            INTEGER returnType   := fptrRecord."RETURNTYPE";
            STRING returnTypeStr := GetTypeName(returnType);

            STRING ARRAY paramslist;
            FOREVERY(RECORD parameter FROM RECORD ARRAY(fptrRecord.parameters)) // Cast to RECORD ARRAY in case we got a VARIANT ARRAY (why do some old datadumps have VARIANT ARRAY's ??)
            {
              IF (NOT CellExists(parameter, "type"))
                INSERT "UNKNOWN" INTO paramslist AT END;
              ELSE
                INSERT GetTypeName(parameter.type) INTO paramslist AT END;
            }

            typename := "FUNCTION PTR"; // NOTE: we don't need to specify it's active :P
            varinfo := name;
            varcontent := '<div class="content">\
                            definition = ' || returnTypeStr || ' (' || DeTokenize(paramslist,", ") || ')<br />\n\
                            library = '    || fptrRecord.library || '<br />\n\
                            function = '   || fptrRecord."function" /*getCell(fptrRecord,'function')*/ || '<br />\n\
                           </div>';
          }
        }

        CASE "PROPERTY"
        {
          typename := "PROPERTY";
          varinfo := name;
          haschildren := TRUE;

          // This should not happen!
          IF (NOT RecordExists(containerobject))
          {
            varcontent := "ERROR!! " || AnyToString([ name := name, value := value ], "htmltree");
            RETURN [ varinfo := varinfo
                   , varcontent := varcontent
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := expanded
                   ];
          }

          // look up the RECORD describing our containerobject, so we can look up the
          // variable or method used as getter or setter by it's name
          RECORD containerobjectrec := SELECT * FROM this->currentvalue.objects WHERE id = containerobject.id;

          // FIXME: how do we handle PROPERTY test(this->testvar, -)?
          //        (at the moment we get wierd getter's like: MYOBJECTTYPENAME#GET#MYPROPERTYNAME)
          IF (value.getter != "")
          {
            // whe'll get a RECORD for FUNCION PTR's (because we translated it) or STRING
            VARIANT getter := GetCell(containerobjectrec.vars, value.getter);
            varcontent := "<b>getter:</b><br />" || this->DumpType(value.getter, getter, level + 1, value.getter IN containerobjectrec.privatevars, -1, containerobjectrec) || "\n";
          }

          IF (value.setter != "")
          {
            // whe'll get a RECORD for FUNCION PTR's (because we translated it) or STRING
            VARIANT setter := GetCell(containerobjectrec.vars, value.setter);
            varcontent := "<b>setter:</b><br />" || this->DumpType(value.setter, setter, level + 1, value.setter IN containerobjectrec.privatevars, -1, containerobjectrec) || "\n";
          }

          varcontent := '<div class="content">' || varcontent || '</div>';
        }

        CASE "OBJECT"
        {
          haschildren := TRUE;
          expanded := level < this->expandlevel;

          IF(CellExists(value, "objtype")) //newly decoded objects eg JSONObject
          {
            typename := value.objtype;

            RECORD ARRAY unpacked := value.elements;
            varcontent := varcontent || '<div class="content">' || Length(unpacked) || ' properties:';
            RECORD ARRAY group1; // misc types
            RECORD ARRAY group2; // ARRAY's and OBJECT's

            FOREVERY(RECORD memberrec FROM unpacked)
            {
              STRING content := this->DumpType(memberrec.name, memberrec.value, level + 1, FALSE, -1) || "\n";

              // we want to place OBJECT's and ARRAY's after simpler types
              IF (TypeID(memberrec.value) = TypeID(OBJECT) OR IsTypeIdArray(TypeID(memberrec.value)))
                INSERT [ name := memberrec.name, content := content ] INTO group2 AT END;
              ELSE
                INSERT [ name := memberrec.name, content := content ] INTO group1 AT END;
            }
            varcontent := varcontent
                          || DeTokenize( (SELECT AS STRING ARRAY content FROM group1 ORDER BY group1.name), "")
                          || DeTokenize( (SELECT AS STRING ARRAY content FROM group2 ORDER BY group2.name), "")
                          || '</div>'
                          ;

            RETURN CELL[ varinfo
                       , varcontent
                       , typename
                       , haschildren
                       , expanded
                       ];
          }
          ELSE
          {
            typename := value.weak ? "WEAKOBJECT" : "OBJECT";
          }


          IF (value.id = -1)
          {
            varinfo := name || " (default object)";
            haschildren := FALSE;

            RETURN [ varinfo := varinfo
                   , varcontent := ""
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := expanded
                   ];
          }

          IF (CellExists(value, "cutoff") AND value.cutoff)
          {
            varinfo := name || " (IGNORED)";
            haschildren := FALSE;

            RETURN [ varinfo := varinfo
                   , varcontent := ""
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := expanded
                   ];
          }

          RECORD objectrec := SELECT * FROM this->currentvalue.objects WHERE id = value.id;
          IF (NOT RecordExists(objectrec)) // this should not happen
          {
            varinfo := name || " (missing OBJECT description)";
            haschildren := FALSE;

            RETURN [ varinfo := varinfo
                   , varcontent := ""
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := expanded
                   ];
          }

          STRING ARRAY typenames := SELECT AS STRING ARRAY COLUMN value
                                     FROM ToRecordArray(objectrec.typenames, "value") AS row
                                    ORDER BY #row DESC;

          varinfo := name || " <span class=\"objtypes\">(" || DeTokenize(typenames, ", ") || ")</span>";//objectrec.typenames[end-1];


          IF (CellExists(objectrec, "interpreted"))
          {
            RECORD meta := objectrec.interpreted;

            // NOTE: An uppercase meta.type is a OBJECTTYPE, lowercase are non-objecttypes

            IF (meta.type = "WRDSCHEMA") //("WRDSCHEMA" in typenames)
            {
              varcontent := '<div class="interpreted">\
                                <div class="humandescription">WRD schema "' || meta.name || '" (#' || meta.id || ')</div>\
                                <a href="webhare://wrd/" || meta.name || ">View in WRD</a>\
                             </div>\
                            ';
            }
            ELSE IF (meta.type = "WRDENTITY")
            {
              varcontent := '<div class="interpreted">\
                                <div class="humandescription">WRD entity ' || meta.title || ' (#' || meta.id || ')</div>\
                                Schema: <a href="webhare://wrd/' || meta.schemaname || '">View schema (by name)<br /></a>\
                                Type: <a href="webhare://wrd/' || meta.schemaname || '/' || meta.typetag || '">View type (by schemanem/typetag)</a>\
                             </div>\
                            ';
            }
            // OBJECT's from module "system"
            ELSE IF (meta.type = "SITEOBJECT")
            {
              // id, name, webroot
              varcontent := "<div class='interpreted'>\
                                <div class='humandescription'>Site \"" || meta.name || "\" (#" || meta.id || ")</div>\
                                <a href=\"" || meta.webroot || "\">" || meta.webroot || "</a><br />\
                                <a href=\"webhare://whfs/" || meta.id || "\">View in Publisher (by ID)</a>\
                             </div>\
                            ";
            }

            ELSE IF (meta.type = "WHFSOBJECT")
            {
              varcontent := "<div class='interpreted'>\
                                <div class='humandescription'>WHFS object " || meta.whfspath || " (#" || meta.id || ")</div>\
                                <a href=\"webhare://whfs/" || meta.id || "\">View in Publisher (by ID)<br /></a>\
                                <a href=\"webhare://whfs/" || meta.whfspath || "\">View in Publisher (by whfspath)</a>\
                             </div>\
                            ";
            }
          }


          IF(objectrec.id IN this->seenobjectids) // prevent recursion and double showing of the same data
          {
            // FIXME: maybe have some logic to do show items again if they would only show a few items
            //        (no deep nesting, circulair references, etc)
            varinfo := varinfo || " (already displayed)";
            varcontent := varcontent || '<div class="content">(members hidden because the object is already displayed)</div>';

            RETURN [ varinfo := varinfo
                   , varcontent := varcontent
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := FALSE
                   ];
          }

          INSERT objectrec.id INTO this->seenobjectids AT END;




          IF (CellExists(objectrec, "membershidden") AND objectrec.membershidden)
          {
            varcontent := varcontent || " (members not stored)";

            RETURN [ varinfo := varinfo
                   , varcontent := varcontent
                   , typename := typename
                   , haschildren := haschildren
                   , expanded := expanded
                   ];
          }



          // empty objects are allready check for earlyer so we can
          // assume the object has 1 or more children
          hasChildren := TRUE;

          RECORD ARRAY unpacked := UnpackRecord(objectrec.vars);
          varcontent := varcontent || '<div class="content">' || Length(unpacked) || ' properties:';
          RECORD ARRAY group1; // misc types
          RECORD ARRAY group2; // ARRAY's and OBJECT's

          FOREVERY(RECORD memberrec FROM unpacked)
          {
            BOOLEAN isprivate := memberrec.name IN objectrec.privatevars;
            IF (isprivate AND NOT this->showprivate) // only add private members if we are interested in PRIVATE members
              CONTINUE;

            STRING content := this->DumpType(memberrec.name, memberrec.value, level + 1, isprivate, -1, objectrec) || "\n";

            // we want to place OBJECT's and ARRAY's after simpler types
            IF (TypeID(memberrec.value) = TypeID(OBJECT) OR IsTypeIdArray(TypeID(memberrec.value)))
              INSERT [ name := memberrec.name, content := content ] INTO group2 AT END;
            ELSE
              INSERT [ name := memberrec.name, content := content ] INTO group1 AT END;
          }
          varcontent := varcontent
                        || DeTokenize( (SELECT AS STRING ARRAY content FROM group1 ORDER BY group1.name), "")
                        || DeTokenize( (SELECT AS STRING ARRAY content FROM group2 ORDER BY group2.name), "")
                        || '</div>'
                        ;
        }

        CASE "intextlink"
        {
          STRING title;
          STRING link;
          IF (NOT CellExists(value, "interpreted"))
          {
            varcontent := '<div class="interpreted">\
                             <div class="humandescription">IntExtLink (no link)</div>\
                             <small>(not set or refenced file/folder was deleted)</small></div>\
                           </div>\
                          ';
          }
          ELSE IF (value.value.externallink != "")
          {
            varcontent := '<div class="interpreted">\
                             <div class="humandescription">IntExtLink (extlink)</div>\
                             URL: <a href="' || value.value.externallink || '">' || value.value.externallink || '</a>\
                           </div>';
          }
          ELSE
          {
            RECORD meta := value.interpreted;

            STRING path;
            IF (CellExists(meta, "sitename"))
              path := "site::" || meta.sitename || meta.fullpath;
            ELSE
              path := meta.whfspath;

            varcontent := '<div class="interpreted">\
                            <div class="humandescription">IntExtLink (intlink)</div>\
                              Publisher:\
                              <a href="webhare://whfs/"' || value.value.internallink || '">#' || value.value.internallink || '</a>\
                              <a href="webhare://whfs/"' || meta.whfspath || '">' || path || '</a><br />';

            if (meta.url != "")
              varcontent := varcontent || 'URL: <a href="' || meta.url || '">' || meta.url || '</a><br />';

            varcontent := varcontent || '\
                            </div>\
                           </div>\
                          ';
          }

          haschildren := TRUE;
          expanded := TRUE;
        }

      } // SWITCH
    }

    RETURN [ varinfo := varinfo
           , varcontent := varcontent
           , typename := typename
           , haschildren := haschildren
           , expanded := expanded
           ];
  }



  /**   @short Make a list of all items in an array
        @param data The data to parse
        @param level Current level (depth) of recursion
        @return String with a list of all items in the array
  */
  STRING FUNCTION WalkThroughArray(VARIANT data , INTEGER level, STRING parentname)
  {
    STRING varcontent;

    IF (level > this->debug->maxtreedepth)
      RETURN 'max level reached! (' || this->debug->maxtreedepth || ")";

    IF (NOT IsTypeidArray( TypeId(data) ))
      RETURN 'Walk() expects data of any type of array.';

    FOREVERY(VARIANT arrayelement FROM data)
      varcontent := varcontent || this->DumpType(parentname, arrayelement , level, FALSE, #arrayelement);

    RETURN varcontent;
  }




  /**   @short Make a list of all items in a described VARIANT ARRAY
        @param data The data to parse
        @param level Current level (depth) of recursion
        @return String with a list of all items in the array
  */
  STRING FUNCTION WalkThroughDescribedArray(RECORD ARRAY data, INTEGER level, STRING parentname)
  {
    STRING varcontent;

    IF (level > this->debug->maxtreedepth)
      RETURN 'max level reached! (' || this->debug->maxtreedepth || ")";

    IF (NOT IsTypeidArray( TypeId(data) ))
      RETURN 'Walk() expects data of any type of array.';

    FOREVERY(RECORD arrayelement FROM data)
      varcontent := varcontent || this->DumpType(parentname, arrayelement.value, level, false, #arrayelement);

    RETURN varcontent;
  }



  /*  @short Walks an RECORD ARRAY which was created from converting an OBJECT, FUNCTION PTR (or it's just a plain unpacked RECORD) */
  STRING FUNCTION WalkUnpacked( RECORD ARRAY unpacked, INTEGER level, OBJECT parentobject DEFAULTSTO DEFAULT OBJECT)
  {
    STRING varcontent;

    IF (level > this->debug->maxtreedepth)
      RETURN 'max level reached!';

    IF (NOT IsTypeidArray( TypeId(unpacked) ))
      RETURN 'WalkUnpacked() expects data of any type of array.';

    STRING ARRAY group1; // misc types
    STRING ARRAY group2; // ARRAY's and OBJECT's

    IF (ObjectExists(parentobject))
    {
      // unpacked object
      // For objects we do a check to see if the member is private
      FOREVERY(RECORD memberrec FROM unpacked)
      {
        BOOLEAN isprivate := GetMemberType(parentobject, memberrec.name) = "PRIVATE";
        STRING content := this->DumpType(memberrec.name, memberrec.value, level, isprivate, -1);
        IF (TypeID(memberrec.value) = TypeID(OBJECT) OR IsTypeIdArray(TypeID(memberrec.value)))
          INSERT content INTO group2 AT END;
        ELSE
          INSERT content INTO group1 AT END;
      }
    }
    ELSE
    {
      // unpacked function pointer or record
      FOREVERY(RECORD recordfield FROM unpacked)
      {
        //varcontent := varcontent || this->DumpType( recordfield.name, recordfield.value, level, false, -1 ) || "\n";
        STRING content := this->DumpType(recordfield.name, recordfield.value, level, FALSE, -1);
        IF (TypeID(recordfield.value) = TypeID(OBJECT) OR TypeID(recordfield.value) = TypeID(RECORD) OR IsTypeIdArray(TypeID(recordfield.value)))
          INSERT content INTO group2 AT END;
        ELSE
          INSERT content INTO group1 AT END;
      }
    }

    varcontent := varcontent || DeTokenize(group1, "") || DeTokenize(group2, "");

    RETURN varcontent;
  }

  PUBLIC STRING FUNCTION AnyToHTML( VARIANT data )
  {
    RETURN '<ul style="overflow: hidden;">' || this->DumpTypeStart('', data, 0, FALSE, -1) || '</ul>';
  }



  /* Allow going through the tree dynamically without unpacking everything
     FIXME: does not work correctly with described values yet
  */
  PUBLIC RECORD FUNCTION WalkThrough(VARIANT test, STRING instruction)
  {
    // FIXME: fix the instructions so you can use stuff like 'myobject->a[1].name'

    STRING ARRAY propertytree := Tokenize(instruction, '.');

    BOOLEAN fail := FALSE;
    STRING failreason;

    /*
    an example of an array:  tolliumcontroller.visiblescreens
    an example of an record: tolliumcontroller.toddweblet.broadcastevent
    */

    IF(LENGTH(propertytree)>1 OR propertytree[0]!='')
    {
      STRING propname;
      STRING prevpropname := 'data';
      INTEGER vtype;

      FOREVERY(propname FROM propertytree)
      {
        vtype := TypeId(test);

        SWITCH(vtype)
        {
        CASE TypeId(OBJECT)
          {
            IF (MemberExists(test, propname))
            {
              test := __HS_GetPrivateMember(test, propname);
            }
            ELSE
            {
              fail := TRUE;
              failreason := 'Property "<b>' || encodeHTML(propname) || '</b>" does not exist.';
              BREAK;
            }
          }

        CASE TypeId(RECORD)
          {
            IF (CellExists(test, propname))
            {
              test := GetCell(test, propname);
            }
            ELSE
            {
              fail := TRUE;
              failreason := 'Cell "<b>' || encodeHTML(propname) || '</b>" does not exist.';
              BREAK;
            }
          }

        DEFAULT
          {
            IF (IsTypeidArray(vtype))
            {
              INTEGER count;
              INTEGER neededindex := ToInteger(propname,-1);
              IF (neededindex = -1)
              {
                fail := TRUE;
                failreason := 'expected an index for array "<b>' || encodeHTML(prevpropname) || '</b>"';
                BREAK;
              }
              ELSE IF (neededindex >= LENGTH(test) OR neededindex < 0)
              {
                fail := TRUE;
                failreason := 'requested index for array "<b>' || encodeHTML(prevpropname) || '</b>" out of bounds';
                BREAK;
              }

              test := test[neededindex];
            }
            ELSE
            {
              // can't view/walk through types: Schema
              fail := TRUE;
              failreason := 'Cant read elements of "<b>' || encodeHTML(prevpropname) || '</b>" because its datatype is unsupported at the moment.';
            }
          }
        }

        prevpropname := propname;
      }

    }

    RETURN [ success := NOT fail
           , failreason := failreason
           , data := test
           ];
  }
>;
