<?wh
LOADLIB "wh::files.whlib";
LOADLIB "mod::system/lib/internal/webhareconstants.whlib";

PUBLIC MACRO PTR onparsedtid;
PUBLIC RECORD modulelangs;

PUBLIC BOOLEAN FUNCTION IsAbsoluteTid(STRING tid)
{
  RETURN tid LIKE "*:*" OR tid LIKE "~*";
}

STRING FUNCTION BuildXPathExpression(STRING tid, BOOLEAN gid)
{
  STRING the_xpath;
  STRING ARRAY toks := Tokenize(tid,'.');
  FOR(INTEGER i:=0; i < Length(toks)-1; i:=i+1)
    the_xpath := the_xpath || "/t:textgroup[@gid='" || EncodeJava(toks[i]) || "']";

  IF (gid)
    the_xpath := the_xpath || "/t:textgroup[@gid='" || EncodeJava(toks[Length(toks)-1]) || "']";
  ELSE
    the_xpath := the_xpath || "/t:text[@tid='" || EncodeJava(toks[Length(toks)-1]) || "']";
  RETURN the_xpath;
}

PUBLIC OBJECTTYPE LanguageFileSystem
<
  STRING ARRAY languagecodes;
  RECORD openfiles;
  STRING name;

  MACRO NEW(STRING name)
  {
    this->name := name;
  }

  /** @short Get the 'best' matching language code for the given language preference
  */
  PUBLIC STRING FUNCTION GetBestLanguageFor(STRING langcode)
  {
    IF(langcode="debug")
      RETURN langcode;

    STRING ARRAY actuallanguagecodes := this->languagecodes;
    FOREVERY(STRING act FROM actuallanguagecodes)
      IF(act="default")
        actuallanguagecodes[#act] := this->OpenLanguageXMLFile(#act)->documentelement->GetAttribute("xml:lang");

    IF(langcode NOT IN actuallanguagecodes AND Length(actuallanguagecodes) > 0 AND actuallanguagecodes[0] IN ["nl","en"])
      RETURN actuallanguagecodes[0];
    RETURN langcode;
  }

  PUBLIC OBJECT FUNCTION OpenLanguageXMLFile(INTEGER langcodeidx)
  {
    THROW NEW Exception("Raw language files not available for '" || this->name || "'");
  }
  PUBLIC MACRO SaveLanguageXMLFile(INTEGER langcodeidx, BLOB filedata)
  {
    THROW NEW Exception("Raw language files not available for '" || this->name || "'");
  }

  OBJECT FUNCTION OpenLanguageTree(INTEGER langcodeidx)
  {
    OBJECT doc := this->OpenLanguageXMLFile(langcodeidx);
    RETURN ObjectExists(doc) ? doc->documentelement : DEFAULT OBJECT;
  }

  RECORD FUNCTION GetLanguageTree(STRING langcode)
  {
    STRING findcode := langcode IN this->languagecodes ? langcode : "default";
    IF(CellExists(this->openfiles, findcode))
      RETURN GetCell(this->openfiles, findcode);

    INTEGER pos := SearchElement(this->languagecodes, findcode);
    IF(pos=-1)
      THROW NEW Exception("No support for language '" || langcode || "' and no fallback available for '" || this->name || "'");

    OBJECT langtree := this->OpenLanguageTree(pos);
    IF(NOT ObjectExists(langtree))
      THROW NEW Exception("The language file/data for language '" || findcode || "' is not valid - invalid XML for '" || this->name || "'");
    IF(langtree->localname != "language" OR langtree->namespaceuri != "http://www.webhare.net/xmlns/tollium/screens")
      THROW NEW Exception("The language file/data for language '" || findcode || "' is not valid - expected a {http://www.webhare.net/xmlns/tollium/screens}language node, got {" || langtree->namespaceuri || "}" || langtree->localname || " for '" || this->name || "'");
    IF(findcode != "default" AND langtree->GetATtribute("xml:lang") != langcode)
      THROW NEW Exception("The language file/data for language '" || findcode || "' is not valid - expected xml:lang '" || langcode || "', got '" || langtree->GetATtribute("xml:lang") || "' for '" || this->name || "'");

    OBJECT pathexpr := langtree->ownerdocument->CreateXPathQuery();
    pathexpr->RegisterNamespace("t", "http://www.webhare.net/xmlns/tollium/screens");

    RECORD langfile := [ tree := langtree
                       , pathexpr := pathexpr
                       , fallback := langtree->GetAttribute("fallbacklanguage")
                       ];
    this->openfiles := CellInsert(this->openfiles, findcode, langfile);
    RETURN langfile;
  }
  PUBLIC OBJECT FUNCTION GetNodePtr(STRING langcode, STRING tid, BOOLEAN gid)
  {
    RETURN this->InternalLookupTID(langcode, tid, gid, DEFAULT STRING ARRAY);
  }
  PUBLIC STRING FUNCTION EvaluateNodePtr(OBJECT nodeptr, STRING p1, STRING p2, STRING p3, STRING p4, BOOLEAN rich)
  {
    RETURN this->RunNodePtr(nodeptr, [p1,p2,p3,p4], rich, FALSE);
  }
  STRING FUNCTION RunNodePtr(OBJECT nodeptr, STRING ARRAY params, BOOLEAN rich, BOOLEAN run_else)
  {
    STRING outtext;

    FOR(OBJECT child := nodeptr->firstchild; ObjectExists(child); child:=child->nextsibling)
    {
      IF(run_else)
      {
        IF (child->localname = "else" AND child->namespaceuri="http://www.webhare.net/xmlns/tollium/screens")
          run_else := FALSE; //we'll output after this node
        CONTINUE; //skipping...
      }

      STRING text;
      IF(child->nodetype = 3)//text
      {
        text := NormalizeWhitespace(child->nodevalue);
      }
      ELSE IF(child->nodetype = 1) //node
      {
        IF (child->namespaceuri="http://www.webhare.net/xmlns/tollium/screens")
        {
          SWITCH (child->localname)
          {
            CASE "else"
            {
              BREAK; //<else/> aborts
            }
            CASE "param"
            {
              INTEGER paramnum := ToInteger(child->GetAttribute("p"),0);
              IF(paramnum>=1 AND paramnum <= Length(params))
                text := params[paramnum-1];
              ELSE
                text := "(no such parameter:" || child->GetAttribute("p") || ")";
            }
            CASE "ifparam"
            {
              INTEGER paramnum := ToInteger(child->GetAttribute("p"),0);
              BOOLEAN result := paramnum>=1 AND paramnum <= Length(params) AND ToUppercase(params[paramnum-1]) = ToUppercase(child->GetAttribute("value"));
              outtext := outtext || this->RunNodePtr(child, params, rich, result = FALSE);
            }
            CASE "br"
            {
              text := "\n";
            }
          }
        }
        ELSE IF (child->namespaceuri="http://www.w3.org/1999/xhtml")
        {
          // FIXME: in the future we want to be able to specify in a language file which tags we want to allow
          IF(rich AND child->localname IN ["b","i","u","ul","ol","li"])
          {
            outtext := outtext || "<" || child->localname || ">" || this->RunNodePtr(child, params, rich, FALSE) || "</" || child->localname || ">";
          }
          ELSE IF(child->localname="a")
          {
            STRING childcontent := this->RunNodePtr(child, params, rich, FALSE);
            STRING href := child->GetAttribute("href");
            IF(href = "")
            {
              INTEGER hrefparam := ToInteger(child->GetAttribute("data-href-param"),0);
              IF(hrefparam >= 1 AND hrefparam <= Length(params))
                href := params[hrefparam - 1];
            }

            outtext := outtext || (rich AND href != "" ? `<a href="${EncodeValue(href)}">${childcontent}</a>`
                                                       : childcontent);
          }
          ELSE IF(child->localname="br")
          {
            outtext := outtext || (rich ? "<br/>" : "\n");
          }
          ELSE
          {
            outtext := outtext || this->RunNodePtr(child, params, rich, FALSE);
          }
          CONTINUE;
        }
        ELSE
        {
          // validation should already have occured in the language editor
          // at this time we don't want to crash on an unknown namespace, since the error would only show up when this tid is used
        }
      }

      IF(text != "")
      {
        IF(rich)
          text := EncodeHTML(text);
        outtext := outtext || text;
      }
    }
    RETURN outtext;
  }

  OBJECT FUNCTION InternalLookupTID(STRING langcode, STRING tid, BOOLEAN gid, STRING ARRAY origlangcodes)
  {
    STRING ARRAY triedlanguages;

    OBJECT result;
    WHILE (TRUE)
    {
      INSERT langcode INTO triedlanguages AT END;
        //Look for the item
      RECORD langfile := this->GetLanguageTree(langcode);

      /* Now build a proper xpath */
      result := langfile.pathexpr->ExecuteQuery("." || BuildXpathExpression(ToLowercase(tid), gid), langfile.tree);
      IF(result->length=0) //If that failed, try the mixed case versions (ADDME make language files and gettid complete case-insensitive)
        result := langfile.pathexpr->ExecuteQuery("." || BuildXpathExpression(tid, gid), langfile.tree);
      IF(result->length!=0)
        BREAK;

      //Is there a fallbakc?
      IF(langfile.fallback = "")
        RETURN DEFAULT OBJECT;
      IF(langfile.fallback IN triedlanguages)
        THROW NEW Exception("Loop in fallback languages found, starting at '" || langcode || "'");
      langcode := langfile.fallback;
    }

    //We have a result, now verify its parent against 'usefromlanguage'
    STRING uselanguage;
    FOR(OBJECT node := gid ? result->item(0) : result->item(0)->parentnode; ObjectExists(node); node := node->parentnode)
    {
      IF(node->nodetype = 1 AND node->HasAttribute("usefromlanguage"))
        uselanguage := node->GetAttribute("usefromlanguage");
    }

    IF(uselanguage!="")
    {
      INSERT langcode INTO origlangcodes AT END;
      IF(uselanguage IN origlangcodes)
        RETURN DEFAULT OBJECT; //a loop was found
      RETURN this->InternalLookupTID(uselanguage, tid, gid, origlangcodes);
    }
    RETURN result->Item(0);
  }

  STRING ARRAY FUNCTION ScanGid(OBJECT node, STRING prefix)
  {
    STRING ARRAY result;
    FOREVERY (OBJECT child FROM node->childnodes->GetCurrentElements())
    {
      IF (child->nodename = "text")
        INSERT prefix || child->GetAttribute("tid") INTO result AT END;
      ELSE IF (child->nodename = "textgroup")
        result := result CONCAT this->ScanGid(child, prefix || child->GetAttribute("gid") || ".");
    }
    RETURN result;
  }

  PUBLIC STRING ARRAY FUNCTION GetAllTidsWithinGID(STRING startlangcode, STRING gid)
  {
    STRING ARRAY triedlanguages;
    STRING ARRAY worklist := [ startlangcode ];

    OBJECT ARRAY gids;
    WHILE (LENGTH(worklist) > 0)
    {
      STRING langcode := worklist[0];
      DELETE FROM worklist AT 0;
      IF (langcode IN triedlanguages)
        CONTINUE;

      INSERT langcode INTO triedlanguages AT END;

        //Look for the item
      RECORD langfile := this->GetLanguageTree(langcode);

      OBJECT ARRAY nodes := langfile.pathexpr->ExecuteQuery("." || BuildXpathExpression(ToLowercase(gid), TRUE), langfile.tree)->GetCurrentElements();
      nodes := nodes CONCAT langfile.pathexpr->ExecuteQuery("." || BuildXpathExpression(gid, TRUE), langfile.tree)->GetCurrentElements();

      IF (langfile.fallback != "")
        INSERT langfile.fallback INTO worklist AT END;

      FOREVERY (OBJECT gidnode FROM nodes)
      {
        FOR(OBJECT node := gidnode; ObjectExists(node); node := node->parentnode)
        {
          IF(node->nodetype = 1 AND node->HasAttribute("usefromlanguage"))
          {
            STRING uselanguage := node->GetAttribute("usefromlanguage");
            IF (uselanguage != "")
              INSERT uselanguage INTO worklist AT END;
          }
        }
      }

      gids := gids CONCAT nodes;
    }

    STRING ARRAY tids;
    FOREVERY (OBJECT node FROM gids)
      tids := tids CONCAT this->ScanGid(node, "");

    RETURN
        SELECT AS STRING ARRAY DISTINCT tid
          FROM ToRecordArray(tids, "TID");
  }

  PUBLIC STRING ARRAY FUNCTION GetLanguageCodes()
  {
    RETURN this->languagecodes;
  }
>;

PUBLIC STRING FUNCTION ParseXMLGid(STRING defaultmodule, STRING currentgid, OBJECT el, STRING ns, STRING cellname)
{
  IF(NOT el->HasAttributeNS(ns, cellname))
    RETURN currentgid;

  STRING gid := el->GetAttributeNS(ns, cellname);
  IF(Left(gid,1)=".")
    RETURN currentgid || gid;
  IF(gid != "" AND gid NOT LIKE "*:*")
    RETURN defaultmodule || ":" || gid;
  RETURN gid;
}

PUBLIC RECORD FUNCTION GetXMLTidFromName(STRING defaultmodule, STRING currentgid, OBJECT el)
{
  FOREVERY(STRING attr FROM ["cellname", "name"])
    IF(el->HasAttribute(attr))
    {
      STRING name := ToLowercase(el->GetAttribute(attr));
      name := Substring(name,  SearchLastSubstring(name,'.')+1);
      IF(currentgid LIKE "*:*")
        RETURN CELL[ attr, tid := currentgid || "." || name ];

      IF(defaultmodule = "")
        THROW NEW Exception(`ParseXMLTidPtr requires a set module for automatic ${attr}-based titles if the gid doesn't specify one`);
      RETURN CELL[ attr, tid := defaultmodule || ":" || currentgid || "." || name ];
    }

  RETURN DEFAULT RECORD;
}

PUBLIC STRING FUNCTION ParseXMLTidDirectly(STRING resourcename, OBJECT el, STRING tid, STRING attrnametid)
{
  IF(resourcename != "" AND resourcename NOT LIKE "*::*") //no exceptions, noone externally should use this
    THROW NEW Exception("ParseXMLTidDirectly call with invalid resource name");
  IF(onparsedtid != DEFAULT MACRO PTR)
    onparsedtid(CELL[ resourcename, tid, line := el->linenum, col := 0, attrname := attrnametid ]);
  RETURN tid;
}

/** @topic localization/gettid
    @public
    @loadlib mod::tollium/lib/gettid.whlib
    @short Parse a title/tid combination, considering any groupid, default module and name/cellname rules. Returns an empty string if unset, ':' prefixed string for untranslated texts, and otherwise a module:tid combination
*/
PUBLIC STRING FUNCTION ParseXMLTidPtr(STRING resourcename, STRING currentgid, OBJECT el, STRING attrname)
{
  RETURN ParseXMLTidPtrNS(resourcename, currentgid, el, "", attrname);
}

PUBLIC STRING FUNCTION ParseXMLTidPtrNS(STRING resourcename, STRING currentgid, OBJECT el, STRING ns, STRING attrname)
{
  /* validate resourcename, as we used to accept modulename for now we'll tolerate it for old code, but only if targetted at
     an external module (eg embedded blexdev_formsapi). this check can probably go away post 4.29 */
  IF(resourcename != "" AND resourcename NOT LIKE "*::*" AND resourcename IN (whconstant_builtinmodules CONCAT ["webhare_testsuite"]))
    THROW NEW Exception("ParseXMLTidPtr call with invalid resource name");

  STRING attrnametid := attrname LIKE "*title" ? Left(attrname, Length(attrname) - 5) || "tid" : attrname || "tid";
  IF(el->HasAttributeNS(ns, attrnametid))
  {
    STRING tid := el->GetAttributeNS(ns, attrnametid);
    IF(Left(tid,1)='.')
      tid := currentgid || tid;
    IF(NOT IsAbsoluteTid(tid))
    {
      IF(resourcename = "")
        THROW NEW Exception("ParseXMLTidPtr requires a set module if the tid/gid doesn't specify one");
      tid := __GetModuleNameFromResourcePath(resourcename) || ":" || tid;
    }

    IF(onparsedtid != DEFAULT MACRO PTR)
      onparsedtid(CELL[ resourcename, tid, line := el->linenum, col := 0, attrname := attrnametid ]);

    RETURN tid;
  }

  IF(el->HasAttributeNS(ns, attrname))
    RETURN ":" || el->GetAttributeNS(ns, attrname);

  IF(currentgid != "" AND attrname LIKE "*title")
  {
    RECORD trygidfromname := GetXMLTidFromName(__GetModuleNameFromResourcePath(resourcename), currentgid, el);
    IF(RecordExists(trygidfromname))
    {
      IF(onparsedtid != DEFAULT MACRO PTR AND trygidfromname.tid!="")
        onparsedtid(CELL[ resourcename, tid := trygidfromname.tid, line := el->linenum, col := 0, attrname := trygidfromname.attr ]);

      RETURN trygidfromname.tid;
    }
  }

  RETURN "";
}

PUBLIC STRING FUNCTION DetermineNodeGid(STRING resourcename, OBJECT node) // FIXME: add tests
{
  WHILE (ObjectExists(node) AND node->nodetype = 1)
  {
    STRING localgid := node->GetAttribute("gid");
    IF (localgid = "")
    {
      node := node->parentnode;
      CONTINUE;
    }

    IF (localgid LIKE "*:*")
      RETURN localgid;

    STRING parentgid := DetermineNodeGid(resourcename, node->parentnode);
    IF (localgid LIKE ".*")
      RETURN parentgid || localgid;

    RETURN __GetModuleNameFromResourcePath(resourcename) || ':' || localgid;
  }
  RETURN "";
}
