<?wh

LOADLIB "wh::crypto.whlib";
LOADLIB "wh::datetime.whlib";
LOADLIB "wh::ipc.whlib";
LOADLIB "wh::promise.whlib";

LOADLIB "mod::system/lib/configure.whlib";


/** Handles exclusive opening of tollium screens (or locking for actions), with support for
    stealing access by other users
*/
PUBLIC STATIC OBJECTTYPE ExclusivityHandler
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Exclusively opened screen
  OBJECT screen;

  /// Identifier (for encoding multiple instances, eg for edited entities)
  STRING identifier;

  /// Port (name dependent on identifier, so 1-port-per-process policy handles exclusivity)
  OBJECT port;

  /// List of connected comm links
  OBJECT ARRAY links;

  /// List of close requests
  RECORD ARRAY pvt_requests;

  /// Counter for close request ids
  INTEGER requestid_counter;

  /// Opened 'can we close?' dialog
  OBJECT askclosedialog;

  /// Takeover dialogs at requester's side
  OBJECT takeoverdialog;

  /** Options
      @cell(function ptr) onbeforesteal Callback called just before the screen is stolen
      @cell(function ptr) onsteal Callback called after the screen has been stolen
      @cell(record) subscreensonly Close only subscreens of the opening screen
  */
  RECORD options;

  /** Steal exitmessage
      @cell(boolean) showmessage
      @cell(record) closedby Identity data for the user that stole the screen (login, realname)
      @cell(string) closedby.login
      @cell(string) closedby.realname
  */
  RECORD exitmessage;

  // ---------------------------------------------------------------------------
  //
  // Public properties
  //

  /** List of current takeover requests
      @cell id Id of request
      @cell login Login name of takeover user
      @cell realname Real name of takeover user
      @cell date Date of takeover request
      @cell deadline Time the requester will take over automatically
  */
  PUBLIC PROPERTY requests(GetRequests, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  /** Constructs a new ExclusivityHandler object
    @param screen Screen opening the exclusive access
    @param identifier Identifies the unique resource to protect
    @param options Options
    @cell(function ptr) options.onbeforesteal Callback called just before the screen is stolen
    @cell(function ptr) options.onsteal Callback called after the screen has been stolen
    @cell(record) options.subscreensonly Close only subscreens of the opening screen
  */
  MACRO NEW(OBJECT screen, STRING identifier, RECORD options)
  {
    this->screen := screen;
    this->identifier := identifier;
    this->options :=  ValidateOptions(
        [ onstolen :=         DEFAULT FUNCTION PTR
        , onbeforesteal :=    DEFAULT FUNCTION PTR
        , subscreensonly :=   FALSE
        ], options);
  }

  // ---------------------------------------------------------------------------
  //
  // Getters & setters
  //

  RECORD ARRAY FUNCTION GetRequests()
  {
    RETURN SELECT *, DELETE link, DELETE msgid FROM this->pvt_requests;
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  /// Got an incoming comm link
  MACRO OnLink()
  {
    OBJECT link := this->port->Accept(DEFAULT DATETIME);
    IF (ObjectExists(link))
    {
      link->userdata :=
          [ cb :=         RegisterHandleReadCallback(link->handle, PTR this->OnLinkMessage(link))
          , requestid :=  0
          ];

      INSERT link INTO this->links AT END;
    }
  }

  /** Incoming comm link is signalled
      Warning: this can be called from WITHIN the signaltakeover dialog!!!
  */
  MACRO OnLinkMessage(OBJECT link)
  {
    RECORD rec := link->ReceiveMessage(DEFAULT DATETIME);
    IF (rec.status = "timeout")
      RETURN; // Spurious wakeup, ignore

    // Other link is gone.
    IF (rec.status = "gone")
    {
      this->CloseLink(link);
      RETURN;
    }

    SWITCH (rec.msg.type)
    {
      CASE "identify"
      {
        // Identification request
        link->SendReply(
            [ login :=    this->screen->tolliumuser->login
            , realname := this->screen->tolliumuser->realname
            , entityid := this->screen->tolliumuser->entityid
            , groupid :=  GetCurrentGroupId()
            ], rec.msgid);
      }
      CASE "close"
      {
        // Already winding down for a forced close? Ignore next close requests
        IF (RecordExists(this->exitmessage))
          RETURN;

        // Set the exit message - this will prevent closes from other sources
        this->exitmessage := [ showmessage := TRUE, closedby := rec.msg ];

        IF (CellExists(this->options, "ONBEFORESTEAL") AND this->options.onbeforesteal != DEFAULT FUNCTION PTR)
          this->options.onbeforesteal();

        // forced close by other side
        link->SendReply([ success := TRUE ], rec.msgid);

        // Give the other side an (little) advantage to the other links
        this->ClosePort();

        // Close the handler, show messages and do callback
        this->Close();
      }
      CASE "requestclose"
      {
        // Only one pending request per link
        IF (link->userdata.requestid != 0)
        {
          link->SendExceptionReply(NEW Exception("Already a close request pending on this link"));
          this->CloseLink(link);
          RETURN;
        }

        // Allocate a request id
        this->requestid_counter := this->requestid_counter + 1;
        link->userdata.requestid := this->requestid_counter;

        // Register the request
        INSERT CELL
            [ id :=       this->requestid_counter
            , date :=     GetCurrentDateTime()
            , rec.msg.login
            , rec.msg.realname
            , rec.msg.deadline
            , rec.msgid
            , link :=     link
            ] INTO this->pvt_requests AT END;

        // Open the ask dialog if not open yet (if already open, we called from within its modal loop!)
        IF (NOT ObjectExists(this->askclosedialog))
        {
          // Run the askclosedialog
          this->askclosedialog := this->screen->tolliumcontroller->LoadScreen("tollium:exclusive.signaltakeover", CELL[ control := this ]);
          STRING dres := this->askclosedialog->RunModal();

          // Erase the reference immediately!
          this->askclosedialog := DEFAULT OBJECT;

          // Did the user consent to the takeover (say ok, or let it timeout)
          BOOLEAN close_screen := dres IN [ "ok", "timeout" ];

          // Yes: give a positive answer to the first request (if present)
          IF (close_screen AND LENGTH(this->pvt_requests) != 0)
          {
            IF (CellExists(this->options, "ONBEFORESTEAL") AND this->options.onbeforesteal != DEFAULT FUNCTION PTR)
              this->options.onbeforesteal();

            this->pvt_requests[0].link->SendReply([ success := TRUE ], this->pvt_requests[0].msgid);
            this->CloseLink(this->pvt_requests[0].link);

            // Give the other side an (little) advantage to the other links
            Sleep(100);
          }

          // Deny all other requests
          FOREVERY (RECORD req FROM this->pvt_requests)
            req.link->SendReply([ success := FALSE ], req.msgid);

          // Close the screen anyway (even if no requests are pending. We want to be predictable, not have users
          // expect that the screen will stay open anyway when they have clicked to close)
          IF (close_screen)
          {
            this->exitmessage := [ showmessage := dres = "timeout", closedby := rec.msg ];

            // Relinquish exclusivity
            this->Close();
          }
        }
        ELSE // Got another request, update the signaltakeover dialog
          this->askclosedialog->GotUpdate();
      }
    }
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  /// Close the exclusivity port
  MACRO ClosePort()
  {
    IF (ObjectExists(this->port))
    {
      UnregisterCallback(this->port->userdata.cb);
      this->port->Close();
      this->port := DEFAULT OBJECT;
    }
  }

  /// Close a comm link
  MACRO CloseLink(OBJECT link)
  {
    // Cancel requests from this link
    DELETE
      FROM this->pvt_requests
     WHERE id = link->userdata.requestid;

    // Remove callback, close link & remove from links list
    UnregisterCallback(link->userdata.cb);
    link->Close();
    INTEGER pos := SearchElement(this->links, link);
    IF (pos != -1)
      DELETE FROM this->links AT pos;

    // If the dialog is open, update its state
    IF (ObjectExists(this->askclosedialog))
      this->askclosedialog->GotUpdate();
  }

  // ---------------------------------------------------------------------------
  //
  // Callbacks
  //

  PUBLIC BOOLEAN FUNCTION Start()
  {
    // Wait loop
    WHILE (TRUE)
    {
      TRY
      {
        // Try to register our port. Only one port with the same name can be active in a process (webserver).
        // Throws upon failure
        this->port := CreateIPCPort("tollium:exclusive_access." || this->identifier);

        // Listen to incoming takeover requests
        this->port->userdata := [ cb := RegisterHandleReadCallback(this->port->handle, PTR this->OnLink) ];
        RETURN TRUE;
      }
      CATCH (OBJECT e)
      {
        // Port already existed. Connect to it.
        OBJECT link := ConnectToIPCPort("tollium:exclusive_access." || this->identifier);
        IF (NOT ObjectExists(link)) // Might have gone already.
          CONTINUE;

        TRY
        {
          // Ask for the identity of the other side (ADDME: timeout for unresponse processes?)
          // Do an async call to make sure an exclusivity handler in the same job doesn't deadlock the system
          RECORD res := WaitForPromise(link->AsyncDoRequest([ type := "identify" ]));

          // If the request failed, the other side is probably gone. Retry getting the port.
          IF (res.status = "ok")
          {
            IF (res.msg.groupid = GetCurrentGroupId())
              THROW NEW Exception("Recursive exclusive access lock detected!");

            // Is this a tab of the current user?
            IF (res.msg.entityid = this->screen->tolliumuser->entityid)
            {
              // Ask what to do
              OBJECT dialog := this->screen->tolliumcontroller->LoadScreen("tollium:exclusive.stealdialog",
                  [ msg := res.msg
                  , link := link
                  , isown := TRUE
                  , title := this->screen->frame->title
                  ]);

              STRING dres := dialog->RunModal();

              // Other side disappeared? Retry loop
              IF (dres = "linkbroken")
                CONTINUE;

              // Got a license to kill from the user?
              IF (dres = "ok")
              {
                link->DoRequest(
                    [ type := "close"
                    , login :=    this->screen->tolliumuser->login
                    , realname := this->screen->tolliumuser->realname
                    ]);
                CONTINUE;
              }
            }
            ELSE
            {
              // Ask if user wants to take over dialog from other user
              OBJECT dialog := this->screen->tolliumcontroller->LoadScreen("tollium:exclusive.stealdialog",
                  [ msg := res.msg
                  , link := link
                  , isown := FALSE
                  , title := this->screen->frame->title
                  ]);

              STRING dres := dialog->RunModal();
              IF (dres = "ok")
              {
                // Yes, user wants to. Run screen waitforreply, it will do the request
                dialog := this->screen->tolliumcontroller->LoadScreen("tollium:exclusive.runtakeoverrequest",
                    [ msg := res.msg
                    , link := link
                    , title := this->screen->frame->title
                    ]);
                dres := dialog->RunModal();

                IF (dres = "ok")
                  CONTINUE;
                ELSE IF (dres = "denied")
                {
                  this->screen->tolliumcontroller->RunMessageBox("tollium:exclusive.takeoverdenied", this->screen->frame->title);
                  RETURN FALSE;
                }
              }
              ELSE IF (dres = "linkbroken")
                CONTINUE;
            }

            // Asked for license to close, but didn't get it
            IF (NOT this->options.subscreensonly)
              this->screen->tolliumcontroller->MarkScreenAsStolen(this->screen);

            // Cleanup resources
            this->Close();
            RETURN FALSE;
          }
        }
        FINALLY
          link->Close();
      }
    }
    RETURN FALSE;
  }

  PUBLIC MACRO Check()
  {
    IF (RecordExists(this->exitmessage))
      THROW NEW OperationCancelledException();
  }

  /// Close the exclusivity handler (release lock)
  PUBLIC MACRO Close()
  {
    this->ClosePort();

    // If forced closing, give our closer a bit of head-start to open its own port
    IF (RecordExists(this->exitmessage))
      Sleep(100);

    WHILE (LENGTH(this->links) != 0)
      this->CloseLink(this->links[0]);

    IF (RecordExists(this->exitmessage))
    {
      IF (this->exitmessage.showmessage)
        this->screen->RunMessageBox("tollium:exclusive.dialogstolen", this->exitmessage.closedby.login, this->exitmessage.closedby.realname);

      // Close the relevant screens
      IF (this->options.subscreensonly)
        this->screen->tolliumcontroller->MarkChildrenScreensAsStolen(this->screen);
      ELSE
        this->screen->tolliumcontroller->MarkScreenAsStolen(this->screen);

      IF (CellExists(this->options, "ONSTOLEN") AND this->options.onstolen != DEFAULT FUNCTION PTR)
        this->options.onstolen();

      this->exitmessage := DEFAULT RECORD;
    }
  }
>;

/** Returns TRUE when a specific tag has a tollium screen exclusive lock. Only
    works within the webserver process!
    @param tag Exclusive lock tag
    @return TRUE if an exclusive lock is present for that tag
    @public
    @loadlib mod::tollium/lib/applications.whlib
    @topic tollium/appdev
*/
PUBLIC BOOLEAN FUNCTION TestExclusiveLocked(RECORD tag)
{
  STRING identifier := EncodeUFS(GetSHA1Hash(EncodeHSON(tag)));
  OBJECT link := ConnectToIPCPort("tollium:exclusive_access." || identifier);
  IF (ObjectExists(link))
  {
    link->Close();
    RETURN TRUE;
  }

  RETURN FALSE;
}


/** Status object returned by [GetBulkExclusiveLock](#GetBulkExclusiveLock)
    @public
    @topic tollium/appdev
*/
STATIC OBJECTTYPE BulkExclusiveKeeper
< // ---------------------------------------------------------------------------
  //
  // Variables
  //

  /// Options
  RECORD _options;

  /// Cancel token source used to stop all async functions
  OBJECT canceltokensource;

  /** status per tag
      @cell tag Tag
      @cell status @includecelldef #pertagstatus.status
      @cell id @includecelldef #pertagstatus.id
  */
  RECORD ARRAY _status;

  /// Time that lock request was started
  DATETIME _requesttime;

  /// Deadline for close requests
  DATETIME _deadline;

  /// Deferred promise for lock waits
  RECORD _defer;

  /// Deferred promise for close waits
  RECORD _closedefer;

  // ---------------------------------------------------------------------------
  //
  // Properties
  //

  /** @type(string) Wait mode:
      - 'try': Try to lock, give back identifications of locksed items
      - 'requestclose': Ask for locks, allow users to deny
      - 'forceclose': Close screen locks (won't close bulk exclusive locks)
  */
  PUBLIC PROPERTY mode(this->_options.mode, -);

  /** @type(string) Status
      - "none": None of the locks succeeded
      - "partial": Not all locks succeeded
      - "ok": all locks are taken
      - "closed": Closed
  */
  PUBLIC PROPERTY status(GetStatus, -);

  /** Status per tag
      @cell(record) tag Lock tag
      @cell(string) status Lock status
          - "acquiring": Acquiring lock
          - "identified": Acquiring lock, got identification about the party holding the lock
          - "denied": Lock acquire denied by current holder
          - "ok": Lock acquired
          - "closed": keeper closed
      @cell(record) id Identification (only when status is "identified" or "denied")
  */
  PUBLIC PROPERTY pertagstatus(GetPerTagStatus, -);

  /** @type(datetime) Deadline for releasing the lock (for mode "requestclose")
  */
  PUBLIC PROPERTY deadline(_deadline, -);

  /** @type(datetime)
  */
  PUBLIC PROPERTY requesttime(_requesttime, -);

  // ---------------------------------------------------------------------------
  //
  // Constructor
  //

  MACRO NEW(RECORD ARRAY tags, RECORD options)
  {
    this->canceltokensource := NEW CancellationTokenSource;
    this->_options := options;
    this->_status :=
        SELECT identifier
             , tag
             , identity :=      DEFAULT RECORD
             , orgdata
             , status := "acquiring" //initial status
          FROM tags;

    INTEGER waitsecs := options.takeovertime ?? ReadRegistryKey("system.backend.exclusiveaccess.takeovertime");
    this->_defer := CreateDeferredPromise();
    this->_closedefer := CreateDeferredPromise();
    this->_requesttime := GetCurrentDateTime();
    this->_deadline := AddTimeToDate(waitsecs * 1000, this->_requesttime);

    FOREVERY (RECORD rec FROM this->_status)
      this->TryGetPort(#rec);
  }

  // ---------------------------------------------------------------------------
  //
  // Getters / setters
  //

  RECORD ARRAY FUNCTION GetPerTagStatus()
  {
    RETURN
        SELECT ...orgdata
             , status
             , identity
          FROM this->_status;
  }

  STRING FUNCTION GetStatus()
  {
    STRING retval := "none";
    FOREVERY (RECORD rec FROM this->_status)
      IF (rec.status != "ok")
        RETURN retval;
      ELSE
        retval := "partial";
    RETURN "locked";
  }

  // ---------------------------------------------------------------------------
  //
  // Helper functions
  //

  MACRO UpdateStatus(INTEGER pos, RECORD updates)
  {
    this->_status[pos] := CELL[ ...this->_status[pos], ...updates ];
    this->ProcessWaits();

  }

  MACRO ProcessWaits()
  {
    BOOLEAN allfinished := TRUE, allidentified := TRUE, alllocked := TRUE, allclosed := TRUE;
    FOREVERY (RECORD rec FROM this->_status)
    {
      IF (rec.status = "acquiring")
      {
        allfinished := FALSE;
        allidentified := FALSE;
      }
      IF (rec.status = "identified")
        allfinished := FALSE;
      IF (rec.status != "ok")
        alllocked := FALSE;
      BOOLEAN closed := rec.status = "closed" OR (this->mode = "try" AND rec.status = "identified");
      IF (NOT closed)
        allclosed := FALSE;
    }

    IF (allfinished OR (this->mode = "try" AND allidentified))
      this->_defer.resolve(alllocked);
    IF (allclosed)
      this->_closedefer.resolve(TRUE);
  }

  ASYNC MACRO HandlePort(INTEGER pos, OBJECT port)
  {
    (AWAIT GetAsyncControl())->autolinkcancel := TRUE;
    OBJECT canceltoken := (AWAIT GetAsyncControl())->canceltoken;
    TRY
    {
      WHILE (TRUE)
      {
        OBJECT link := AWAIT port->AsyncAccept(MAX_DATETIME);
        this->HandlePortLink(link)->LinkToken(canceltoken);
      }
    }
    CATCH (OBJECT< OperationCancelledException > e)
    {
      this->UpdateStatus(pos, [ status := "closed" ]);
    }
    FINALLY
      port->Close();
  }

  ASYNC MACRO HandlePortLink(OBJECT link)
  {
    TRY
    {
      (AWAIT GetAsyncControl())->autolinkcancel := TRUE;

      WHILE (TRUE)
      {
        RECORD rec := AWAIT link->AsyncReceiveMessage(MAX_DATETIME);
        IF (rec.status != "ok")
          RETURN;

        SWITCH (rec.msg.type)
        {
          CASE "identify"
          {
            // Identification request
            link->SendReply(
                [ login :=    this->_options.user->login
                , realname := this->_options.user->realname
                , entityid := this->_options.user->entityid
                , groupid :=  GetCurrentGroupId()
                ], rec.msgid);
          }
          CASE "close", "requestclose"
          {
            // Ignoring, assume that a bulk operation is speedy
          }
        }
      }
    }
    CATCH (OBJECT< OperationCancelledException > e)
    {
    }
    FINALLY
      link->Close();
  }

  ASYNC MACRO HandleExtLink(OBJECT link, INTEGER pos)
  {
    TRY
    {
      (AWAIT GetAsyncControl())->autolinkcancel := TRUE;
      RECORD rec := AWAIT link->AsyncDoRequest([ type := "identify" ]);

      this->UpdateStatus(pos, [ status := "identified", id := rec.msg ]);
      IF (this->mode = "try")
        RETURN;

      rec := AWAIT link->AsyncDoRequest(CELL
          [ type :=     this->mode = "requestclose" ? "requestclose" : "close"
          , login :=    this->_options.user->login
          , realname := this->_options.user->realname
          , this->deadline
          ]);

      // try to open the port before the link is closed
      this->TryGetPort(pos);
      RETURN;
    }
    CATCH (OBJECT< OperationCancelledException > e)
    {
      this->UpdateStatus(pos, [ status := "closed" ]);
    }
    FINALLY
    {
      link->Close();
    }
  }

  MACRO TryGetPort(INTEGER pos)
  {
    OBJECT canceltoken := this->canceltokensource->canceltoken;
    this->UpdateStatus(pos, [ status := "acquiring" ]);

    STRING portname := "tollium:exclusive_access." || this->_status[pos].identifier;
    WHILE (TRUE)
    {
      TRY
      {
        OBJECT port := CreateIPCPort(portname);
        this->UpdateStatus(pos, [ status := "ok", id := DEFAULT RECORD ]);
        this->HandlePort(pos, port)->LinkToken(canceltoken);
        BREAK;
      }
      CATCH
      {
        OBJECT link := ConnectToIPCPort(portname);
        IF (ObjectExists(link))
        {
          this->HandleExtLink(link, pos)->LinkToken(canceltoken);
          BREAK;
        }
      }
    }

    this->ProcessWaits();
  }

  // ---------------------------------------------------------------------------
  //
  // Public API
  //

  /** Returns a promise that will be resolved when the locked status is known. Returns TRUE
      when all locks are taken
  */
  PUBLIC ASYNC FUNCTION AsyncWaitLocked()
  {
    this->ProcessWaits();
    RETURN AWAIT this->_defer.promise;
  }

  /** Close the lock and cancels takeover requests - warning: executes asynchronous code.
  */
  PUBLIC MACRO Close()
  {
    this->canceltokensource->Cancel();
    WaitForPromise(this->_closedefer.promise);
    this->_defer.resolve(FALSE);
  }
>;

/** Get an exclusive lock on multiple objects. Only works within the webserver process!
    @param tags List of tags
    @cell(record) tags.tag The tag as passed to %TolliumScreenBase::GetExclusiveAccess
    @cell(string) options.mode Mode:
        - "try": Try to get the locks, take only the free locks
        - "requestclose": Request the locks from the users
        - "forceclose": Force close screens of users holding the lock
    @cell(integer) options.takeovertime Override default takeover time
    @cell(object %TolliumUser) options.user User object (required)
    @return(object #BulkExclusiveKeeper) Status object
    @public
    @loadlib mod::tollium/lib/applications.whlib
    @topic tollium/appdev
*/
PUBLIC OBJECT FUNCTION GetBulkExclusiveLock(RECORD ARRAY tags, RECORD options DEFAULTSTO DEFAULT RECORD)
{
  IF (IsDefaultValue(tags))
    THROW NEW Exception(`At least one tag expected`);

  FOREVERY (RECORD tag FROM tags)
  {
    tags[#tag] := ValidateOptions(
        [ tag :=        DEFAULT RECORD
        ], tag,
        [ title := `tags[${#tag}]`
        , passthrough := TRUE
        , required := ["tag"]
        ]);
  }

  tags :=
      SELECT identifier :=  EncodeUFS(GetSHA1Hash(EncodeHSON(tag)))
           , tag
           , orgdata :=     tags
        FROM tags;

  options := ValidateOptions(
      [ mode :=           ""
      , takeovertime :=   0
      , user :=           DEFAULT OBJECT
      ], options,
      [ enums := [ mode := [ "try", "requestclose", "forceclose" ] ]
      , required := [ "user" ]
      ]);

  RECORD pos := SELECT pos := Any(#tags) FROM tags GROUP BY identifier HAVING Count(*) > 1;
  IF (RecordExists(SELECT FROM tags GROUP BY identifier HAVING Count(*) > 1))
    THROW NEW Exception(`Tag #${pos.pos} is mentioned more than once`);

  RETURN NEW BulkExclusiveKeeper(tags, options);
}
