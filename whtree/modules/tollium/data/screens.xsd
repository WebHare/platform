<?xml version="1.0" encoding="UTF-8"?>

<!--
To change a <xs:attribute /> for adding descriptions

>
      <xs:annotation>
        <xs:documentation>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
-->
<xs:schema
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:fn="http://www.w3.org/2005/02/xpath-functions"
  xmlns:html="http://www.w3.org/1999/xhtml"
  targetNamespace="http://www.webhare.net/xmlns/tollium/screens"
  xmlns:s="http://www.webhare.net/xmlns/tollium/screens"
  xmlns:sc="http://www.webhare.net/xmlns/system/common"
  xmlns:tc="http://www.webhare.net/xmlns/tollium/common"
  xmlns:tai="http://www.webhare.net/xmlns/tollium/appinfo"
  xmlns="http://www.webhare.net/xmlns/tollium/screens"
  elementFormDefault="qualified"
  xml:lang="en">

  <xs:annotation>
    <xs:documentation>
      Tollium screens XML file schema specification.
      @topic tollium-components/base
    </xs:documentation>
  </xs:annotation>

<!--  <xs:import namespace="http://www.w3.org/1999/xhtml" schemaLocation="http://www.w3.org/2002/08/xhtml/xhtml1-strict.xsd"/> -->
  <xs:import namespace="http://www.webhare.net/xmlns/system/common" schemaLocation="mod::system/data/common.xsd" />
  <xs:import namespace="http://www.webhare.net/xmlns/tollium/common" schemaLocation="mod::tollium/data/common.xsd" />
  <xs:import namespace="http://www.webhare.net/xmlns/tollium/appinfo" schemaLocation="mod::tollium/data/appinfo.xsd" />
  <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="http://www.w3.org/2001/xml.xsd" />

  <!-- The screens file root node -->
  <xs:element name="screens" type="Screens">
    <xs:unique name="screenfragnames">
      <xs:selector xpath="./s:screen|./s:messageboxes/s:messagebox|./s:fragment|./s:imgsizepreset|./s:tabsextension" />
      <xs:field xpath="@name" />
    </xs:unique>
  </xs:element>

  <xs:element name="language" type="Language">
    <xs:unique name="uniquerootgids">
      <xs:selector xpath="./s:textgroup" />
      <xs:field xpath="@gid" />
    </xs:unique>
  </xs:element>

  <!-- Simple types -->
  <xs:simpleType name="NonEmptyString">
    <xs:restriction base="xs:string">
      <xs:pattern value=".+"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="Integers">
    <xs:list itemType="xs:integer" />
  </xs:simpleType>

  <xs:simpleType name="Money">
    <xs:restriction base="xs:string">
      <xs:pattern value="-?\d+(.\d{0,5})?"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="Size">
    <xs:restriction base="tc:Size" />
  </xs:simpleType>

  <xs:simpleType name="SizeList">
    <xs:list itemType="Size" />
  </xs:simpleType>

  <xs:simpleType name="AbsSize">
    <xs:restriction base="tc:AbsSize"/>
  </xs:simpleType>

  <xs:simpleType name="AbsSizeOrSp">
    <xs:annotation>
      <xs:documentation>
        <html:p>An absolute size may not be proportional</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value='(\d+(px|x))|0|sp'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="PixelWidth">
    <xs:restriction base="xs:string">
      <xs:pattern value="[0-9]+px"/> <!-- requiring px to allow future %/em etc support to be added without having to deal with naked '450's -->
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="FixedSize">
    <xs:annotation>
      <xs:documentation>
        <html:p>A fixed size is a font-size independent size (only pixels at the moment)</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:pattern value='(\d+px)|0'/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="VertSize">
    <xs:restriction base="tc:Height"/>
  </xs:simpleType>

  <xs:simpleType name="AbsVertSize">
    <xs:restriction base="tc:AbsHeight"/>
  </xs:simpleType>

  <xs:simpleType name="ComponentRef">
    <xs:restriction base="tc:ComponentRef" />
  </xs:simpleType>

  <!-- A color: #000000-#ffffff, #00000000-#ffffffff (with last two digits specifying alpha) or 'transparent' -->
  <xs:simpleType name="Color">
    <xs:restriction base="tc:Color" />
  </xs:simpleType>

  <!-- An image source link: (modulename ":")? (pathpart "/")* name -->
  <xs:simpleType name="ImageSrc">
    <xs:restriction base="xs:string">
      <xs:pattern value="([_\w]+:)?(\c+/)*\c+(\+([_\w]+:)?(\c+/)*\c+)*"/>
    </xs:restriction>

<!--
    <xs:annotation>
      <xs:documentation>
        <html:p>
          Path to a image. module::path/image.<br />
          <br />
          Images in this tollium:colors/ namespace are automatically generated. Specify the color value
          as the image name. Valid colors are all colors supported by GfxCreateColorFromCSS.<br />
          <br />
          Examples:<br />
          <br />
          tollium:colors/#ffffff        White<br />
          tollium:colors/#ff0           Yellow<br />
          tollium:colors/rgb(0,0,0)     Black<br />
          tollium:colors/rgba(0,0,0,0)  Transparent<br />
          tollium:colors/purple         Purple<br />
        </html:p>
      </xs:documentation>
    </xs:annotation>
-->
  </xs:simpleType>

  <!-- A gid: ( modulename ":" (gid.)* gid | "."? gid ( "." gid )* | <empty> ) -->
  <xs:simpleType name="Gid">
    <xs:restriction base="sc:Gid" />
  </xs:simpleType>

  <!-- A gid that remains 'empty' if not specified (and doesn't default to the 'current' scope) -->
  <xs:simpleType name="OptionalGid">
    <xs:restriction base="xs:string">
      <xs:pattern value="([-\w_]+:([-_\w]+\.)*[-_\w]+|\.?[-_\w]+(\.[-_\w]+)*)?" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="NotimplementedOrHandler">
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="Handler" />
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="@notimplemented"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <xs:simpleType name="Handler">
    <xs:restriction base="tc:Handler" />
  </xs:simpleType>

  <xs:simpleType name="DataFileRefs">
    <xs:list itemType="DataFileRef" />
  </xs:simpleType>

  <xs:simpleType name="DataFileRef">
    <xs:restriction base="xs:string">
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="Name">
    <xs:restriction base="sc:Name" />
  </xs:simpleType>

  <xs:simpleType name="NameList">
    <xs:list itemType="Name" />
 </xs:simpleType>

  <xs:simpleType name="ComponentRefList">
    <xs:list itemType="ComponentRef" />
  </xs:simpleType>

  <xs:simpleType name="StringList">
    <xs:list itemType="xs:string" />
  </xs:simpleType>

  <!-- A tid: ( module ":" (gid ".")+ tid | gid? ("." gid)* ("." tid) ) | ~ (gid ".")? tid -->
  <!-- can't transform (.gid)*(.tid) to (.word)+, libxml treats that as (.word)* ??? -->
  <xs:simpleType name="Tid">
    <xs:restriction base="sc:Tid"/>
  </xs:simpleType>

  <xs:simpleType name="Flags">
    <xs:restriction base="tc:Flags" />
  </xs:simpleType>

  <!-- Either '<flagname>' (flag must be set), '!<flagname>' (flag must not be set)
       Use 'false' as a checkflag to have the condition always fail -->
  <xs:simpleType name="CheckFlags">
    <xs:restriction base="xs:string">
      <xs:pattern value="!?[\w_]+(\s+!?[\w_]+)*"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="SelectMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="none"/>
      <xs:enumeration value="single"/>
      <xs:enumeration value="multiple"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="EventMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="asynchronous"/>
      <xs:enumeration value="synchronous"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="TimePrecision">
    <xs:restriction base="xs:string">
      <xs:enumeration value="minutes"/>
      <xs:enumeration value="seconds"/>
      <xs:enumeration value="milliseconds"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="MaxLengthMeasureMethods">
    <xs:restriction base="xs:string">
      <xs:enumeration value="bytes"/>
      <xs:enumeration value="characters"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="ReserveComponents">
    <xs:list>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="pulldown"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:list>
  </xs:simpleType>

  <xs:simpleType name="Layout">
    <xs:restriction base="xs:string">
      <xs:enumeration value="left"/>
      <xs:enumeration value="form"/>
      <xs:enumeration value="center"/>
      <xs:enumeration value="right"/>
      <xs:enumeration value="tabs-space"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="HorizontalAlignment">
    <xs:restriction base="xs:string">
      <xs:enumeration value="left"/>
      <xs:enumeration value="center"/>
      <xs:enumeration value="right"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="VerticalAlignment">
    <xs:restriction base="xs:string">
      <xs:enumeration value="top"/>
      <xs:enumeration value="middle"/>
      <xs:enumeration value="bottom"/>
      <xs:enumeration value="none"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="StandardButton">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ok"/>
      <xs:enumeration value="cancel"/>
      <xs:enumeration value="yes"/>
      <xs:enumeration value="no"/>
      <xs:enumeration value="yestoall"/>
      <xs:enumeration value="notoall"/>
      <xs:enumeration value="close"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="StandardButtonList">
    <xs:list itemType="StandardButton" />
  </xs:simpleType>

  <xs:simpleType name="TimeType">
    <xs:restriction base="xs:string">
      <xs:pattern value="((1?[0-9])|(2[0-3])):[0-5][0-9]" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="_BorderParts">
    <xs:list>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="top"/>
          <xs:enumeration value="right"/>
          <xs:enumeration value="bottom"/>
          <xs:enumeration value="left"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:list>
  </xs:simpleType>

  <xs:simpleType name="BordersSpacers">
    <xs:union>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="default"/>
          <xs:enumeration value="all"/>
          <xs:enumeration value="none"/>
        </xs:restriction>
      </xs:simpleType>
      <xs:simpleType>
        <xs:restriction base="_BorderParts">
          <xs:minLength value="1" />
        </xs:restriction>
      </xs:simpleType>
    </xs:union>
  </xs:simpleType>

  <!-- Attribute groups -->
  <xs:attributeGroup name="IsComposableListener">
    <xs:attribute name="composition" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          Specify where to store the data in this instance, relative to the base object for this composition.<br />
          This feature is included for backwards compatibility with earlier site profiles, it's use is no longer
          recommended as it is incompatible with the history/versioning system.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="IsComposable">
    <xs:attributeGroup ref="tc:IsComposable" />
  </xs:attributeGroup>

  <xs:attributeGroup name="ComponentBase">
    <xs:attributeGroup ref="tc:ComponentBase" />
  </xs:attributeGroup>

  <xs:attributeGroup name="Composition">
    <xs:attribute name="mergecompositions" type="ComponentRefList" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
  </xs:attributeGroup>

  <xs:attributeGroup name="ComposableComponentBase">
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="IsComposable" />
  </xs:attributeGroup>

  <xs:attributeGroup name="ComposableComponentWithLabelBase">
    <xs:attributeGroup ref="ComposableComponentBase" />
  </xs:attributeGroup>

  <xs:attributeGroup name="AutoSuggestableAttributes">
    <xs:attribute name="minimumsuggestlength" type="xs:integer" default="3"/>
  </xs:attributeGroup>

  <xs:attributeGroup name="Name">
    <xs:attributeGroup ref="tc:NamedComponent" />
  </xs:attributeGroup>

  <xs:attributeGroup name="Styling">
    <xs:attribute name="bold" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>Makes bold</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="italic" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>Makes italic</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="before" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>Before</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="after" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>After</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="left" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>Left</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="right" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>Right</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="backgroundcolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>The backgroundcolor</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="textcolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>The textcolor</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="TidOrTitle">
    <xs:attributeGroup ref="sc:TidOrTitle" />
  </xs:attributeGroup>

  <xs:attributeGroup name="Gid">
    <xs:attributeGroup ref="sc:Gid" />
  </xs:attributeGroup>

  <xs:attributeGroup name="Action">
    <xs:attribute name="action" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the action to use for this component, as defined in the &lt;actions> section.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Icon">
    <xs:attribute name="icon" type="ImageSrc">
      <xs:annotation>
        <xs:documentation>
          <html:p>The icon to use for this component.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Required">
    <xs:attributeGroup ref="tc:Required" />
  </xs:attributeGroup>

  <xs:attributeGroup name="Onchange">
    <xs:attributeGroup ref="tc:OnChange" />
  </xs:attributeGroup>

  <xs:attributeGroup name="OnClick">
    <xs:attribute name="onclick" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function to call when someone has clicked on the component. A record containing the X and Y coordinates (relative to the original imagesize) will be passed as argument to the onclick function.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Errorlabel">
    <xs:attribute name="errorlabel" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The text to use as the name of this component in error messages.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Errorlabeltid">
    <xs:attribute name="errorlabeltid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <html:p>The tid to use as the name of this component in error messages.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Layout">
    <xs:attribute name="layout" type="Layout">
      <xs:annotation>
        <xs:documentation>
          <html:p>The type of layout to use for this component. Possible values are "left", "form" and "right".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="Overlays">
    <xs:attribute name="flags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>
          The overlay flags
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          The name of the function to call when the overlay selection has changed.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onchangeoverlays" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          The name of the function to call when one or more overlays have changed (in size or position).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="oncreateoverlay" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="record" arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          The name of the function to call when the user tries to create an new overlay by click and dragging over the image.
          You can cancel the new overlay by returning DEFAULT RECORD;

          FIXME: Current if not set, the user will not be able to create new overlays using click+drag.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:attributeGroup>

  <xs:attributeGroup name="LibraryLocation">
    <xs:attribute name="lib" type="NonEmptyString">
      <xs:annotation>
        <xs:documentation>
          Deprecated way to set the library containing the implementation of screens and related objects. You should use the library= property
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="library" type="NonEmptyString">
      <xs:annotation>
        <xs:documentation>
          The (default) library implementing the screen, fragment or tabsextension. If not set, the setting from the top level &lt;screens> node is used, if any.
          This path is resolved relative to the location of this XML file
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <!-- Implementations -->
  <xs:complexType name="rowedit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumimplementation objecttype="/lib/screenbase.whlib#TolliumRowEditScreenBase" />
      </xs:appinfo>
    </xs:annotation>
  </xs:complexType>

  <!-- Element types -->
  <!-- The screens element -->
  <xs:complexType name="Screens">
    <xs:annotation>
      <xs:documentation>
        <html:p>This is the root element of a screens XML file. It contains the different screens and global settings.</html:p>
      </xs:documentation>
    </xs:annotation>

    <xs:sequence>
      <xs:element name="messageboxes" type="Messageboxes" minOccurs="0" maxOccurs="1"/>
      <xs:element ref="imgsizepreset" minOccurs="0" maxOccurs="1" />
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="screen" />
        <xs:element ref="fragment" />
        <xs:element ref="tabsextension" />
      </xs:choice>
    </xs:sequence>

    <xs:attributeGroup ref="Gid" />

    <xs:attributeGroup ref="LibraryLocation" />
  </xs:complexType>

  <!-- Tab extensions -->
  <xs:element name="tabsextension" type="TabsExtension" />

  <xs:complexType name="TabsExtension">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="screens"/>
        <tai:childcomponents field="actions" target="./s:actions" />
        <tai:childcomponents field="menus" target="./s:menus" />
        <tai:childcomponents field="compositions" target="./s:compositions" adoptfields="compositions" />
        <tai:childcomponents field="newtabs" target="./s:newtab" />
        <tai:childcomponents field="inserts" target="./s:insert" adoptfields="lines position where" />
      </xs:appinfo>
    <xs:documentation>A TabsExtension organizes one or more extra tabs to load into an existing &lt;tabs> component</xs:documentation>
    </xs:annotation>

    <xs:sequence>
      <xs:element ref="actions" minOccurs="0" maxOccurs="1" />
      <xs:element ref="menus" minOccurs="0" maxOccurs="1"/>
      <xs:element ref="compositions" minOccurs="0" maxOccurs="1" />
      <xs:element ref="insert" minOccurs="0" maxOccurs="unbounded" />
      <!-- ADDME: Would be nice to be able to specify where the tab should be inserted -->
      <xs:element ref="newtab" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="name" type="xs:string" />
    <xs:attributeGroup ref="Gid" />
    <xs:attributeGroup ref="LibraryLocation" />

    <xs:attribute name="implementation" type="xs:QName">
      <xs:annotation>
        <xs:documentation>
          Describes how the tabsextension is implemented
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowresize" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If 'true', suggest to the parent container that allowing this control to resize would make sense</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="insert" type="TabsExtensionInsert" />

  <xs:complexType name="TabsExtensionInsert">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="tabsextension" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="LinesContainer">
        <xs:attribute name="position" type="xs:string" use="required" />
        <xs:attribute name="where" type="InsertWheres" use="required" />
        <xs:attributeGroup ref="Gid" /> <!-- FIXME is this still being picked up? -->
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>


  <xs:simpleType name="InsertWheres">
    <xs:restriction base="xs:string">
      <xs:enumeration value="before" />
      <xs:enumeration value="after" />
      <xs:enumeration value="atend">
        <xs:annotation>
          <xs:documentation>
            Insert inside the specified panel or box, at its end
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>


  <!-- Language (tid) data -->
  <xs:complexType name="Language">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="textgroup" />
      </xs:choice>
    </xs:sequence>
    <xs:attribute ref="xml:lang">
      <xs:annotation>
        <xs:documentation>Language that will be used to specify text Example: "nl", "en"</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fallbacklanguage">
      <xs:annotation>
        <xs:documentation>Language file to use if this language file is missing the text</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="title">
      <xs:annotation>
        <xs:documentation>Title for this language</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="TextGroupAttributes" />
  </xs:complexType>

  <xs:simpleType name="GidTidWord">
    <xs:restriction base="xs:string">
      <xs:pattern value="[^:. ]+" />
    </xs:restriction>
  </xs:simpleType>

  <xs:attributeGroup name="TextGroupAttributes">
    <xs:attribute name="limitlanguages" type="StringList">
      <xs:annotation>
        <xs:documentation>
          To indicate that the texts within this group (and sub groups) only need to be translated to the specified languages.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:element name="textgroup">
    <xs:complexType>
      <xs:sequence>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="textgroup" />
          <xs:element name="text" type="LangText" />
        </xs:choice>
      </xs:sequence>
      <xs:attribute name="gid" type="GidTidWord" use="required">
        <xs:annotation>
          <xs:documentation>The name of the group described by this textgroup</xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attributeGroup ref="TextGroupAttributes" />
      <xs:attribute name="usefromlanguage" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            If set, take language texts from this section, and its children, from the specified language file instead.
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="keepifunreferenced">
        <xs:annotation>
          <xs:documentation>If set, keep this group and their texts even if we can't find any references.</xs:documentation> <!-- added in 4.27, we can start using it as soon as all webhares are 4.27+ -->
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="comments">
        <xs:annotation>
          <xs:documentation>User comments/annotation for this textgroup</xs:documentation> <!-- added in 4.27, we can start using it as soon as all webhares are 4.27+ -->
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="keepemptyreason" type="xs:string" /> <!-- what keepifunreferenced is currently called -->
    </xs:complexType>
    <xs:unique name="uniquegids">
      <xs:selector xpath="./s:textgroup" />
      <xs:field xpath="@gid" />
    </xs:unique>
    <xs:unique name="uniquetids">
      <xs:selector xpath="./s:text" />
      <xs:field xpath="@tid" />
    </xs:unique>
  </xs:element>

  <xs:complexType name="LangText" mixed="true">
    <xs:group ref="LangTextElements" minOccurs="0" maxOccurs="unbounded" />
    <xs:attribute name="tid" type="GidTidWord" use="required">
      <xs:annotation>
        <xs:documentation>The text id</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="LangTextElements">
    <xs:choice>
      <xs:element name="param">
        <xs:complexType>
          <xs:attribute name="p" type="xs:positiveInteger" use="required">
            <xs:annotation>
              <xs:documentation>
                the number of the GetTid() parameter to use in place of this tag, 1-based
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="br">
        <xs:annotation>
          <xs:documentation>
            FIXME: documentation
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ifparam" type="LangTextIf">
        <xs:annotation>
          <xs:documentation>
            Show a specific text only if the specified parameter (p) contains te specified value (value).
            (or when it has another value if [else] is used)
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="http://www.w3.org/1999/xhtml" processContents="skip" /><!-- for HTML content -->
    </xs:choice>
  </xs:group>
  <xs:complexType name="LangTextIf" mixed="true">
    <xs:sequence>
      <xs:group ref="LangTextElements" minOccurs="0" maxOccurs="unbounded" />
      <xs:sequence minOccurs="0" maxOccurs="1">
        <xs:element name="else" />
        <xs:group ref="LangTextElements" minOccurs="0" maxOccurs="unbounded" />
      </xs:sequence>
    </xs:sequence>
    <xs:attribute name="p" type="xs:positiveInteger" use="required">
      <xs:annotation>
        <xs:documentation>
          The number of the GetTid() parameter to check against
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The value to check against
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <!-- ** The message boxes element ** -->
  <xs:complexType name="Messageboxes">
    <xs:sequence>
      <xs:element name="messagebox" type="Messagebox" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attributeGroup ref="Gid" /> <!-- Used as base for messagebox names -->
  </xs:complexType>

  <xs:complexType name="Messagebox">
    <xs:sequence>
      <xs:element name="button" type="MessageBoxButton" minOccurs="0" maxOccurs="unbounded"/> <!-- To insert custom buttons -->
    </xs:sequence>
    <xs:attributeGroup ref="sc:TidOrTitle">
        <xs:annotation>
          <xs:documentation>
            <html:p>Used as message within the messagebox.</html:p>
          </xs:documentation>
        </xs:annotation>
    </xs:attributeGroup>

    <xs:attribute name="name" type="Name" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The name of this messagebox.
            Screens can use messageboxes in the same screens XML file using <i>this->RunMessageBox(".messageboxname");</i>.
            To use a messagebox from another screens file (not recommended) use <i>this->RunMessageBox("myscreen.messageboxname");</i>
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="icon">
      <xs:annotation>
        <xs:documentation>
          <html:p>The icon to use for this messagebox. If no icon specified, the "information" icon will be displayed. If an empty icon is specified, no icon will be displayed.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value=""/>
          <xs:enumeration value="error"/>
          <xs:enumeration value="information"/>
          <xs:enumeration value="question"/>
          <xs:enumeration value="unrecoverable"/>
          <xs:enumeration value="warning"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="dontshowagain"> <!-- Add a "Don't show this dialog again" option -->
      <xs:annotation>
        <xs:documentation>
          <html:p>If not empty, the message box will have a checkbox option "Don't show this dialog again", which when checked will always return the selected result, if one of the dontshowagain values is chosen.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list itemType="xs:string" />
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="buttons" type="StandardButtonList"> <!-- To insert default buttons -->
      <xs:annotation>
        <xs:documentation>
          <html:p>Defines which (default) buttons to use. Examples are "ok" and "yes no".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="default" type="StandardButton">
      <xs:annotation>
        <xs:documentation>
          The name of the button to use as the default selected button. If unspecified but an 'ok' or 'close' button is present, that one will be the default
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Fragment">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="screens"/>
        <tai:childcomponents field="actions" target="./s:actions" />
        <tai:childcomponents field="menus" target="./s:menus" />
        <tai:childcomponents field="compositions" target="./s:compositions" />
        <tai:childcomponents field="contents" target="./s:contents" adoptfields="lines" />
      </xs:appinfo>
      <xs:documentation>
        <html:p>
          Resuable Tollium component excerpts.
          It provides some of the API and elements which screens have. (such as actions, menus, compositions).
          (but not RunMessageBox, tolliumuser, tolliumcontroller).
        </html:p>

        <html:p>
          Compositions can interact with the screen or fragment in which the fragment is used.
          <html:ul>
            <html:li>by giving the composition in a parent a mergecompositions attribute</html:li>
            <html:li>by using composition="parentscope->compositionname" in a field within this fragment</html:li>
          </html:ul>
        </html:p>
      </xs:documentation>
    </xs:annotation>

    <xs:sequence>
      <xs:element ref="actions" minOccurs="0" maxOccurs="1" />
      <xs:element ref="menus" minOccurs="0" maxOccurs="1"/>
      <xs:element ref="compositions" minOccurs="0" maxOccurs="1" />
      <xs:element ref="contents" minOccurs="1" maxOccurs="1" />
    </xs:sequence>

    <xs:attribute name="name" type="Name" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of this fragment. This name must be unique within the screens file.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="LibraryLocation" />

    <xs:attribute name="contentpanel" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            A panel inside this panel, that will receive any content lines passed to this fragment
            (ADDME: describe what it's usefull for)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="Gid" />

    <xs:attribute name="implementation" type="xs:QName">
      <xs:annotation>
        <xs:documentation>
          Describes how the fragment is implemented
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- ** The screen element ** -->
  <xs:complexType name="Screen">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="screens" objecttype="/lib/components/frame.whlib#TolliumFrame" />
        <tai:childcomponents field="actions" target="./s:actions" />
        <tai:childcomponents field="menus" target="./s:menus" />
        <tai:childcomponents field="compositions" target="./s:compositions" />
        <tai:childcomponents field="toolbars" target="./s:toolbar" />
        <tai:childcomponents field="bodynode" target="./s:body" />
        <tai:childcomponents field="footernode" target="./s:footer" />
      </xs:appinfo>
      <xs:documentation>
        <html:p>This is a screen element. Its child elements describe its layout.</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="actions" minOccurs="0" maxOccurs="1"/>
      <xs:element ref="menus" minOccurs="0" maxOccurs="1"/>
      <xs:element ref="compositions" minOccurs="0" maxOccurs="1" />
      <xs:element ref="toolbar" minOccurs="0" maxOccurs="1" />
      <xs:element name="body" type="Panel" minOccurs="1" maxOccurs="1"/>
      <xs:element name="footer" type="Panel" minOccurs="0" maxOccurs="1"/>
    </xs:sequence>

    <xs:attribute name="name" type="Name" use="required">
      <xs:annotation>
        <xs:documentation>The name of the screen. This name must be unique within the screens file.</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="minwidth" type="tc:AbsSize">
      <xs:annotation>
        <xs:documentation>Minimum screen width</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minheight" type="tc:AbsHeight">
      <xs:annotation>
        <xs:documentation>Minimum screen height</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="width" type="tc:Size">
      <xs:annotation>
        <xs:documentation>(Initial) width of the screen</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="height" type="tc:Height">
      <xs:annotation>
        <xs:documentation>(Initial) height of the screen</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="defaultbutton" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>The default button in this screen (may be overridden per foucsable component)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="footerbuttons">
      <xs:simpleType>
        <xs:list itemType="DefaultButtonName" />
      </xs:simpleType>
    </xs:attribute>

    <xs:attributeGroup ref="sc:TidOrTitle" />

    <xs:attributeGroup ref="LibraryLocation" />

    <xs:attributeGroup ref="Gid" />

    <xs:attribute name="flags" type="tc:Flags">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define the screen flags here, used as "enable" filters for your actions. These flags can be set from your library using <i>this->frame->flags.flagname</i>.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="allowresize" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set to 'true', the user can resize the screen. Giving components height="1pr" will allow them to grow to use the extra space when a screen is resized.</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="savestate">
      <xs:annotation>
        <xs:documentation>
          <html:p>Save the selected window properties in the user's registry and restore them upon reopening the window. The value can be any combination of "position" and "size".</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="position"/>
              <xs:enumeration value="size"/>
              <xs:enumeration value="true">
                <xs:annotation>
                  <xs:appinfo>
                    <sc:deprecated>Use the 'position' and/or 'size' values</sc:deprecated> <!-- TODO validate doesn't warn about deprecated enum values yet -->
                  </xs:appinfo>
                </xs:annotation>
              </xs:enumeration>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="allowclose" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to false, a user cannot close the window by using the 'X' icon or the 'Escape' key on the keyboard. Default is 'true'.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="allpublic" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>Makes all components in the screen public.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="menubar" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the menu to use as a menubar. By default, this menu will be shown at the top of the screen.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="oninterval" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Function pointer to the macro to call every specified interval.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="interval" type="xs:nonNegativeInteger">
      <xs:annotation>
        <xs:documentation>
          <html:p>Specifies the time between each call to oninterval in milliseconds</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onshow" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>onshow is fired after initialization of a screen (after the init())</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onunload" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Function that needs to be executed when the screen is unloading. Note that this handler may not be invoked if an application closes unexpectedly (crashed or abandoned by user)</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onmessage" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Function that needs to be executed when a message is send to the application</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="forcemenubar" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Require the menubar to be shown as a separate bar (never integrate into the toolbar)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="Icon" />

    <xs:attribute name="implementation" type="xs:QName">
      <xs:annotation>
        <xs:documentation>
          Describes how the screen is implemented
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>


  <xs:complexType name="MessageBoxButton">
    <xs:attributeGroup ref="sc:TidOrTitle" />

    <xs:attribute name="tolliumresult" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>Value returned by RunMessageBox() when the button was used.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- ** The formbutton element ** -->
  <xs:complexType name="Button">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/button.whlib#TolliumButton" />
      </xs:appinfo>
    </xs:annotation>


    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />

    <!-- FIXME: Wat gebeurt er als je title en icon opgeeft?
                In Webhare V3 werd dit ondersteund, maar support hiervan is deprecated?
    -->

    <xs:attributeGroup ref="Icon" />

    <xs:attribute name="tolliumresult" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Value returned by the screen or messagebox when the button has been used.<br />
            Example of use:<br />
            STRING tolliumresult := this->LoadScreen(".mydialog")->RunModal();<br />
            <br />
            There are a few special values which also adds a specific behaviour:<br />
          </html:p>
          <html:ul>
            <li>"tollium_submit" calls Submit() in the screen (like the defaultformbuttons 'ok' button), 'ok' will be returned as value.</li>
            <li>"tollium_cancel" has the same effect as the defaultformbutton 'cancel', 'cancel' will be returned as value.</li>
          </html:ul>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="action" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the action to use for this component, as defined in the &lt;actions> section.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="isdefault" type="xs:boolean">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Use the 'defaultbutton' attribute on the screen</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="align" type="HorizontalAlignment" default="center">
      <xs:annotation>
        <xs:documentation>
          <html:p>Alignment of the text and icon within the button (only for standard buttons). Right
          alignment places the button on the right side of the button.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="type" type="ButtonType" default="standard">
      <xs:annotation>
        <xs:documentation>
          <html:p>Type of the button (ignored for toolbar buttons). Default is 'standard'.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="Ellipsis" />

    <xs:attribute name="menu" type="ComponentRef"/>
    <xs:attribute name="disablemode" type="DisableModes" />
  </xs:complexType>


  <xs:attributeGroup name="Ellipsis">
    <xs:attribute name="ellipsis" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Show an ellipsis. Use when an action requires more information to execute (often: when a dialog will appear, but
          eg "Properties" doesn't need an ellipsis as the executed action is "Show properties") <!-- see also https://stackoverflow.com/questions/278655/when-should-i-use-a-ellipsis-in-a-menu-item -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:simpleType name="ButtonType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="standard"/>
      <xs:enumeration value="icon"/>
    </xs:restriction>
  </xs:simpleType>

  <!-- Grouped buttons -->
  <xs:complexType name="ButtonGroup">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/buttongroup.whlib#TolliumButtonGroup" />
        <tai:childcomponents field="buttons" target="./s:button" />
      </xs:appinfo>
    </xs:annotation>

    <xs:sequence>
      <xs:element ref="button" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>

    <xs:attributeGroup ref="ComponentBase" />

    <xs:attribute name="layout" />

    <xs:attribute name="borders" type="BordersSpacers">
      <xs:annotation>
        <xs:documentation>A space separated list of borders to enable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- An individual action -->
  <xs:attributeGroup name="ActionBaseAttributes">
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="frameflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define the "enable" flags for this action, as defined in the 'screen' node.
             If these flags flags evaluate to 'true', the action will be enabled.
             To check if a flag evaluates to 'false' prepand it with !.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="Icon" />
    <xs:attributeGroup ref="tc:Shortcut" />
  </xs:attributeGroup>

  <xs:element name="forward">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumForward" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="ComponentBase" />
      <xs:attributeGroup ref="sc:TidOrTitle" />
      <xs:attributeGroup ref="Icon" />
      <xs:attributeGroup ref="tc:Shortcut" />
      <xs:attributeGroup ref="Action" />
    </xs:complexType>
  </xs:element>

  <xs:element name="action">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumAction" />
          <!-- FIXME can we decide to parse the sequeence ourselves?
                     or is it perhaps useful to specify an xpath explaining the nodes to grab? -->
          <tai:extraparser field="enableon" type="enableons" target="./s:enableon" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>An action allows you to execute commands in your application, and to set up client-side checking
             whether the action should be allowed.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="enableon" type="EnableOnWithExecute" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attributeGroup ref="OnExecuteGroup" />
      <xs:attributeGroup ref="Ellipsis" />
    </xs:complexType>
  </xs:element>

  <xs:element name="downloadaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumDownloadAction" />
          <!-- FIXME can we decide to parse the seuqence ourselves?
                     or is it perhaps useful to specify an xpath explaining the nodes to grab? -->
          <tai:extraparser field="enableon" type="enableons" target="./s:enableon" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>An action to start a download. When activated, this action will already start the download before sending the instruction to
            the server, so it should only be offered by handlers that will be able to provide a download in a matter of seconds.
            The 'ondownload' handler will receive an object on which it can invoke '->SendFile(BLOB data, STRING mimetype, STRING name)</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="enableon" type="EnableOnWithOnDownload" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attributeGroup ref="OnDownloadGroup" />
      <xs:attribute name="ondownloadstarted" type="tc:Handler">
        <xs:annotation>
          <xs:appinfo>
            <tai:callbacksignature />
          </xs:appinfo>
          <xs:documentation>This callback is invoked when the user has started the download (when the webbrowser is starting to respond to the actual download request)</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="uploadaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumUploadAction" />
          <!-- FIXME can we decide to parse the seuqence ourselves?
                     or is it perhaps useful to specify an xpath explaining the nodes to grab? -->
          <tai:extraparser field="enableon" type="enableons" target="./s:enableon" />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="enableon" type="EnableOnWithOnUpload" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attributeGroup ref="OnUploadGroup" />
    </xs:complexType>
  </xs:element>

  <xs:attributeGroup name="UploadTypes">
    <xs:attribute name="imageactiontype" default="upload">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The type of image action. One of "upload" (request a new image to upload from the user) or "edit" (edit an
            existing image using the Execute function).
          </html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="upload" />
          <xs:enumeration value="edit" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:element name="imageaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumImageAction" />
          <!-- FIXME can we decide to parse the seuqence ourselves?
                     or is it perhaps useful to specify an xpath explaining the nodes to grab? -->
          <tai:extraparser field="enableon" type="enableons" target="./s:enableon" />
          <tai:extraparser field="imgsize" type="imgsize" target="." />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="enableon" type="EnableOnWithOnUpload" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attribute name="onresend" type="tc:Handler">
        <xs:annotation>
          <xs:appinfo>
            <tai:callbacksignature arguments="" />
          </xs:appinfo>
        </xs:annotation>
      </xs:attribute>

      <xs:attributeGroup ref="OnUploadGroup" />
      <xs:attributeGroup ref="UploadTypes" />
      <xs:attributeGroup ref="sc:ImageEditSettings" />
      <xs:attribute name="useimgsizepreset" type="tc:ScreenFragmentReference" />
    </xs:complexType>
  </xs:element>

  <xs:element name="windowopenaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumWindowOpenAction" />
          <!-- FIXME can we decide to parse the seuqence ourselves?
                     or is it perhaps useful to specify an xpath explaining the nodes to grab? -->
          <tai:extraparser field="enableon" type="enableons" target="./s:enableon" />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="enableon" type="EnableOnWithOnWindowOpen" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attributeGroup ref="OnWindowOpenGroup" />

      <xs:attribute name="target" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            <html:p>The target to use for the window.open call</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="helpaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumHelpAction" />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />

      <xs:attribute name="manual" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            Tag of the manual
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="languages">
        <xs:annotation>
          <xs:documentation>
            Languages in which the manual is available
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:list itemType="xs:string" />
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="accesstoken" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            Access token (shared secret) to access private manuals
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="feedbackaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumFeedbackAction" />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />
      <xs:attribute name="scope">
        <xs:annotation>
          <xs:documentation>Scope to which feedback should be reported.</xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="copyaction">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="action" objecttype="/lib/components/action.whlib#TolliumCopyAction" />
        </xs:appinfo>
      </xs:annotation>
      <xs:sequence>
      </xs:sequence>
      <xs:attributeGroup ref="ActionBaseAttributes" />
      <xs:attribute name="source" type="ComponentRef" use="required">
        <xs:annotation>
          <xs:documentation>
            <html:p>The name of the component to copy from.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>


  <xs:simpleType name="DisableModes">
    <xs:annotation>
      <xs:documentation>Defines what happens to a menuitem or button if its action is disabled</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="grayed">
        <xs:annotation>
          <xs:documentation>Gray out when disabled</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hidden">
        <xs:annotation>
          <xs:documentation>Hide when disabled (context menus always hide disabled items)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- An action enabler -->
  <xs:complexType name="EnableOn">
    <xs:attribute name="source" type="ComponentRef" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the source list to use for the "enabled" check.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="checkflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define the flags of the source list, as defined by the flags="" parameter of the list node.
             If these flags evaluate to 'true', the action will be enabled.
             To check if a flag evaluates to 'false' prepand it with !.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="min" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>The minimum number of selected list entries to enable the action. Defaults to 1.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="max" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>The maximum number of selected list entries to enable the action, or -1 for unlimited. Defaults to -1.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selectionmatch" default="all">
      <xs:annotation>
        <xs:documentation>
          <html:p>Should all (default) or any (at least one) of the selected items match the enableon rule.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="any"/>
          <xs:enumeration value="all"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="requirefocus" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, the action will only be enabled when the item has focus (e.g. is selected).
             This only works with a single enable on. When an action has multiple enableons, requirefocus will be be overriden to be true.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="requirevisible" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, this enableon will only be relevant when the referred source is visible</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="frameflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!-- FIXME: Doc -->
  <xs:attributeGroup name="OnExecuteGroup">
    <xs:attribute name="onexecute" type="NotimplementedOrHandler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function from the accompanying library to run when calling this action.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="customaction" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Invoke a JavaScript registered custom action. Only available in ToddNG.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="OnDownloadGroup">
    <xs:attribute name="ondownload" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="object" />
        </xs:appinfo>
        <xs:documentation>The name of the function from the accompanying library to run to handle downloads.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="OnUploadGroup">
    <xs:attribute name="onupload" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="recordarray" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function from the accompanying library to run to handle uploads. It will receive a record array of (filename, data, mimetype) of the uploaded files. The mimetypes are those as reported by the uploader, not as detected by ScanBlob.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="multiple" type="xs:boolean"> <!--FIXME test-->
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, multiple files can be added at once through this file edit component.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxsize" type="xs:integer" default="-1"> <!--FIXME implement and test-->
      <xs:annotation>
        <xs:documentation>
          <html:p>The maximum size for the uploaded file, in bytes.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="mimetypes" type="StringList"> <!--FIXME implement and test-->
      <xs:annotation>
        <xs:documentation>
          <html:p>A space-separated list of mimetypes to allow for the uploaded file. Examples are "image/*" (all image mimetypes), "application/pdf" and "video/mpeg".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="OnWindowOpenGroup">
    <xs:attribute name="onwindowopen" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="object" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function from the accompanying library to run to handle window opens. This function, of signature MACRO onwindowopen(OBJECT openhandler) should invoke the SendURL function on the openhandler with the URL to open.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="EnableOnWithExecute">
    <xs:complexContent>
      <xs:extension base="EnableOn">
        <xs:attributeGroup ref="OnExecuteGroup" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="EnableOnWithOnDownload">
    <xs:complexContent>
      <xs:extension base="EnableOn">
        <xs:attributeGroup ref="OnDownloadGroup" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="EnableOnWithOnUpload">
    <xs:complexContent>
      <xs:extension base="EnableOn">
        <xs:attributeGroup ref="OnUploadGroup" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="EnableOnWithOnWindowOpen">
    <xs:complexContent>
      <xs:extension base="EnableOn">
        <xs:attributeGroup ref="OnWindowOpenGroup" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- ** Toolbars (menubars, buttonbars or panels) ** -->
  <xs:element name="toolbar">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="toolbar" objecttype="/lib/components/toolbar.whlib#TolliumToolbar" />
        <tai:dividedcomponents field="items" target="./*" divider="s:divider" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:choice>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="button" />
          <xs:element name="divider" type="ButtonBarDivider" />
          <xs:element ref="panel" />
        </xs:choice>
      </xs:choice>
      <xs:attributeGroup ref="ComponentBase" />
      <xs:attributeGroup ref="Gid" />
    </xs:complexType>
  </xs:element>

  <!-- ** The menus group. ** -->
  <xs:element name="menus">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" />
        <tai:childcomponents target="./s:menu" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="menu" minOccurs="0" maxOccurs="unbounded"/>
      </xs:sequence>
      <xs:attributeGroup ref="Gid" />
    </xs:complexType>
  </xs:element>

  <xs:complexType name="Menu">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="menu" objecttype="/lib/components/menuitem.whlib#TolliumMenuItem" />
        <tai:dividedcomponents field="items" target="./*" divider="s:divider" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="divider" type="MenuDivider"/>
      <xs:element ref="item" />
      <xs:any namespace="##other" processContents="strict"/>
    </xs:choice>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="Gid" />
  </xs:complexType>

  <xs:complexType name="MenuItem">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="menu" objecttype="/lib/components/menuitem.whlib#TolliumMenuitem" />
<!--        <tai:dividedcomponents field="items" target="./*" divider="s:divider" /> -->
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Menu">
        <xs:attribute name="indent" type="xs:integer" />
        <xs:attributeGroup ref="sc:TidOrTitle" />
        <xs:attributeGroup ref="Action" />
        <xs:attributeGroup ref="Ellipsis" />
        <xs:attribute name="disablemode" type="DisableModes" default="grayed">
          <xs:annotation>
            <xs:documentation>
              <html:p>The disable mode to use when this action has been disabled. Possible values are "grayed" (default) and "hidden".</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attributeGroup ref="Icon" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="menu" type="Menu" />
  <xs:element name="item" type="MenuItem" />


  <!-- menudivider element (empty element!) -->
  <xs:complexType name="MenuDivider">
    <!-- make this an empty element by defining the content to be complex,
         yet assign neither attributes nor child-elements -->
    <xs:sequence>
    </xs:sequence>
  </xs:complexType>


  <xs:element name="compositions" type="Compositions" />

  <xs:complexType name="Compositions">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" />
        <tai:childcomponents field="compositions" target="./*" />
      </xs:appinfo>
      <xs:documentation>
        Compositions are invisible elements that 'group' related visible components together.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="record"  />
        <xs:element ref="radiogroup" />
        <xs:element ref="eventlistener" />
        <xs:element ref="callbacklistener" />
        <xs:element ref="dirtylistener" />
        <xs:element ref="proxy" />
        <xs:any namespace="##other" processContents="strict" />
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="Gid" />
  </xs:complexType>

  <xs:complexType name="Record">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/record.whlib#TolliumRecord" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="tc:CompositionBase" />
    <xs:attributeGroup ref="tc:IsComposable" />
  </xs:complexType>

  <xs:complexType name="RadioGroup">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/radiogroup.whlib#TolliumRadioGroup" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="Onchange" />

    <xs:attribute name="valuetype">
      <xs:annotation>
        <xs:documentation>
          Type of the value of the radiogroup. The rowkey strings of the connected radiobuttons are converted dynamically.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="string"/>
          <xs:enumeration value="integer"/>
          <xs:enumeration value="boolean"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>


  <!-- buttonbar divider -->
  <xs:complexType name="ButtonBarDivider">
    <xs:attribute name="type">
      <xs:simpleType>
        <xs:restriction base="xs:string"><!-- FIXME: documentation -->
          <xs:enumeration value="single"/>
          <xs:enumeration value="flex"/>
          <xs:enumeration value="line"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>



  <!-- the elements that make up the screen: -->

  <xs:group name="BodyOrRowNode">
    <xs:choice>
      <xs:element name="line" type="Line" />
      <xs:element name="lines" type="Lines" />
      <xs:group ref="BlockNode" />
      <xs:group ref="InlineNode" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
  </xs:group>

  <xs:attributeGroup name="LineLayout">
    <xs:attributeGroup ref="Layout" />

    <!-- obsolete and ignored attributes -->
    <xs:attribute name="margintop">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Margins have been ignored since WH 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="marginbottom">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Margins have been ignored since WH 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="marginleft">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Margins have been ignored since WH 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="marginright">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Margins have been ignored since WH 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reserveheight">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>Reserveheight has been ignored since WH 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="Lines">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="BodyOrRowNode" />
    </xs:choice>
    <xs:attributeGroup ref="LineLayout" />
    <xs:attributeGroup ref="Gid" />
  </xs:complexType>

  <xs:complexType name="Line">
    <xs:choice minOccurs="1" maxOccurs="unbounded">
      <xs:group ref="InlineNode" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>

    <xs:attributeGroup ref="LineLayout" />
  </xs:complexType>

  <xs:group name="BlockNode">
    <xs:choice>
      <xs:element ref="arrayedit" />
      <xs:element name="box" type="Box"/>
      <xs:element name="calendar" type="Calendar" />
      <xs:element ref="codeedit" />
      <xs:element ref="defaultformbuttons" />
      <xs:element ref="emailcontents" />
      <xs:element name="grid" type="Grid" />
      <xs:element name="heading" type="Heading"/>
      <xs:element ref="hr" />
      <xs:element ref="hsvalue" />
      <xs:element name="iframe" type="Iframe"/>
      <xs:element name="imageedit" type="ImageEdit"/>
      <xs:element ref="list" />
      <xs:element ref="listedit" />
      <xs:element ref="panel" />
      <xs:element ref="richarea" />
      <xs:element ref="richdocument" />
      <xs:element name="rte" type="RTE"/>
      <xs:element name="split" type="Split"/>
      <xs:element name="table" type="Table" />
      <xs:element name="tabs" type="Tabs"/>
      <xs:element name="wizard" type="Wizard"/>
    </xs:choice>
  </xs:group>

  <xs:group name="InlineNode">
    <xs:choice>
      <xs:element ref="inlineblock" />
      <xs:element name="browsecustom" type="BrowseCustom" />
      <xs:element name="browseserverpath" type="BrowseServerPath" />
      <xs:element name="button" type="Button" />
      <xs:element name="buttongroup" type="ButtonGroup" />
      <xs:element ref="checkbox" />
      <xs:element name="combobox" type="ComboBox"/>
      <xs:element name="date" type="Date"/>
      <xs:element ref="datetime" />
      <xs:element name="fileedit" type="FileEdit"/>
      <xs:element name="coloredit" type="ColorEdit"/>
      <xs:element name="image" type="Image"/>
      <xs:element name="imgedit" type="ImgEdit"/>
      <xs:element ref="includefragment" />
      <xs:element ref="progress" />
      <xs:element name="radiobutton" type="RadioButton"/>
      <xs:element ref="select" />
      <xs:element name="slider" type="Slider" />
      <xs:element name="tagedit" type="TagEdit" />
      <xs:element name="text" type="Text"/>
      <xs:element name="textarea" type="TextArea"/>
      <xs:element ref="textedit" />
      <xs:element name="passwordfield" type="PasswordField" />
      <xs:element name="time" type="Time"/>
      <xs:element name="url" type="URL"/>
      <xs:element name="spacer" type="Spacer" />
    </xs:choice>
  </xs:group>

  <!--
    ## Input fields ##
  -->
  <xs:attributeGroup name="SaveStateValueOnly">
    <xs:attribute name="savestate">
      <xs:annotation>
        <xs:documentation>
          <html:p>Save the control'ss in the user's registry and restore them upon reopening the window. This component only supports saving its "value".</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="value"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="TextEditBaseAttributes">
    <xs:annotation>
      <xs:documentation tc:component="readonly">
        <html:p>If set to true, the value of this component will be shown as normal text instead of a textedit field.</html:p>
      </xs:documentation>
    </xs:annotation>

    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Onchange" />

    <xs:attribute name="maxlength" type="xs:integer" default="-1">
      <xs:annotation>
        <xs:documentation>The maximum number of characters allowed for this text edit field. If less than 30, the default width of the textedit is reduced to match</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="maxlengthmeasure" type="MaxLengthMeasureMethods" default="characters">
      <xs:annotation>
        <xs:documentation>
          <html:p>The way the number of characters is measured (UTF-8 bytes or Unicode characters).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="showcounter" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, a counter will be shown with the actual number of characters/bytes in the field. This may be useful in conjunction with maxlength.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="trimwhitespace" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, any whitespace surrounding the submitted value will be removed.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="valuetype" type="VariableTypes" default="string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The variable type to use when submitting the value. Possible values are: "string" (default), integer, money and float.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The default value for this field upon opening the screen.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="validationchecks" type="sc:ValidationChecks">
      <xs:annotation>
        <xs:documentation>
          <html:p>A list of checks the entered value must pass.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="decimals" type="xs:nonNegativeInteger" default="0">
      <xs:annotation>
        <xs:documentation>
          <html:p>Number of decimals to show in money and float (also the max. number of accepted decimals for input when the property round is set to true).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="round" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Whether to round precision in excess of the set number of decimals, or just to show it.
            Only valid for valuetype 'money'.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="minvalue" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set, minimum valid value.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="maxvalue" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set, maximum valid value.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="emptyvalue" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The value that will be returned when the field isn't filled in.
            When the value property of this textedit is set to this value, the textvalue will become empty.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Prefix text (shown readonly before the input control)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefixtid" type="Tid">
      <xs:annotation>
        <xs:documentation>Tid for prefix text</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="suffix" type="xs:string">
      <xs:annotation>
        <xs:documentation>Suffix text (shown readonly after the input control)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="suffixtid" type="Tid">
      <xs:annotation>
        <xs:documentation>Tid for suffix text</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="Placeholder" />

    <xs:attributeGroup ref="SaveStateValueOnly" />
  </xs:attributeGroup>

  <xs:complexType name="PasswordField">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/passwordfield.passwordfield" />
      </xs:appinfo>
    </xs:annotation>

    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />

    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The current password
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="ishashed" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          The value field, if not empty, contains a hashed password. Defaults to 'true'
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="entercurrentpassword" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Require entering the current password, if any. Defaults to 'true'
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onpolicycheck" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="boolean" arguments="string"/>
        </xs:appinfo>
        <xs:documentation>
          Verify whether a password complies with a policy
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="policy" type="xs:string">
      <xs:annotation>
        <xs:documentation>A description of the password policy implemented by onpolicycheck</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="policytid" type="Tid">
      <xs:annotation>
        <xs:documentation>A tid for the description of the password policy implemented by onpolicycheck</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="defaulthash" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          If the field is hashed, return this hash when no password has been entered.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="TextEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/textedit.whlib#TolliumTextEdit" />
        <tai:childcomponents field="buttons" target="./s:button" />
        <tai:optionsources field="optionsources" type="optionsources" target="./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens' or (local-name()!='button')]" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="button" minOccurs="0" maxOccurs="unbounded"/>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element ref="autosuggest" />
        <xs:choice minOccurs="1" maxOccurs="unbounded">
          <xs:element name="option" type="TextEditOption" />
          <xs:any namespace="##other" processContents="strict" />
        </xs:choice>
      </xs:choice>
    </xs:sequence>
    <xs:attributeGroup ref="AutoSuggestableAttributes" />
    <xs:attributeGroup ref="TextEditBaseAttributes" />

    <xs:attribute name="password" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, all entered data will be shown as '*' characters.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="autocomplete">
      <xs:annotation>
        <xs:documentation>
          <html:p>The value for the autocomplete attribute on the input DOM node.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list itemType="xs:string"/>
      </xs:simpleType>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="Image">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/image.whlib#TolliumImage" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />

    <xs:attribute name="value" type="ImageSrc">
      <xs:annotation>
        <xs:documentation>
          Specifies an image from a module (format module ':' icon-dir '/' icon-name ).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="filename" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Filename to use when SaveImage() is called on the image.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="action" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="placeholder" type="ImageSrc" default="placeholders/na">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="objectfit" default="none">
      <xs:annotation>
        <xs:documentation>
          How to [object-fit](https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit) an image not matching the
          specified dimensions: fill, contain, cover, none, scale-down. This is often useful when loading external images
          which may not follow your requested aspect ratio. Note that object fitting is not supported on IE11.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="fill"/>
          <xs:enumeration value="contain"/>
          <xs:enumeration value="cover"/>
          <xs:enumeration value="none"/>
          <xs:enumeration value="scale-down"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attributeGroup ref="OnClick" />
    <xs:attributeGroup ref="Overlays" />
  </xs:complexType>

  <xs:complexType name="ImageEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/imageedit.whlib#TolliumImageEdit" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="sc:ImageResizeSettings" />

    <xs:attribute name="value" type="xs:string" />

    <!-- FIXME: Doc -->
    <xs:attribute name="filename" type="xs:string" />

    <xs:attribute name="imagewidth" type="AbsSize">
      <xs:annotation>
        <xs:documentation>
          The width of the element
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="imageheight" type="AbsSize">
      <xs:annotation>
        <xs:documentation>
          The height of the element
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="placeholder" type="ImageSrc" default="placeholders/na">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

<!--    <xs:attributeGroup ref="Required" />  -->

    <xs:attributeGroup ref="Onchange" />

    <!-- Obsoleted by imagesetwidth, imagesetheight and imageresizemethod SINCE v2.38! - use the props below for v2.37 -->
    <xs:attribute name="imagemaxwidth" type="AbsSize">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>imagemaxwidth is deprecated since v2.38, use imagesetwidth, imagesetheight and imageresizemethod instead</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="imagemaxheight" type="AbsSize">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>imagemaxheight is deprecated since v2.38, use imagesetwidth, imagesetheight and imageresizemethod instead</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="imageforcewidth" type="AbsSize">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>imageforcewidth is deprecated since v2.38, use imagesetwidth, imagesetheight and imageresizemethod instead</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="imageforceheight" type="AbsSize">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>imageforceheight is deprecated since v2.38, use imagesetwidth, imagesetheight and imageresizemethod instead</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:attributeGroup name="ImgSizeSpec">
    <xs:attributeGroup ref="sc:ImageEditSettings" /> <!-- TODO only webshop needs this, so this can probably go away 4.22+ ? -->
  </xs:attributeGroup>

  <xs:element name="imgsizepreset">
    <xs:complexType>
      <xs:attribute name="name" type="Name">
        <xs:annotation>
          <xs:documentation>
            <html:p>The (unique) name of this preset.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attributeGroup ref="ImgSizeSpec" />
    </xs:complexType>
  </xs:element>

  <xs:complexType name="ImgEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/imgedit.tolliumimgedit" />
        <tai:extraparser field="imgsize" type="imgsize" target="." />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="ImgSizeSpec" />
    <xs:attribute name="useimgsizepreset" type="tc:ScreenFragmentReference" />
    <xs:attribute name="upload" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the user may upload an image file from disk</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="publisher" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the user may select an image file from the Publisher</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="medialibrary" type="xs:string" default="media">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the user may select an image file from a media library, if defined</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="Onchange" />
  </xs:complexType>

  <xs:complexType name="CheckBox">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/checkbox.whlib#TolliumCheckbox" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Onchange" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Required" />
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The label that follows the checkbox</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labeltid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <html:p>A tid for the label that follows the checkbox</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, the checkbox will be checked upon opening the screen.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="enablecomponents" type="ComponentRefList" />
  </xs:complexType>

  <xs:complexType name="RadioButton">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/radiobutton.whlib#TolliumRadioButton" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="label" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The label that follows the radio button</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labeltid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <html:p>A tid for the label that follows the radio button</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rowkey" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When reading the value of a radiogroup, the rowkey of the selected radiobutton will be returned.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="group" type="ComponentRef" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            All radiobuttons must have a 'group'. Radiobuttons with the same name are 'grouped'.<br />
            Selecting a radiobutton will deselect other radiobuttons in that group.<br />
            When reading the value of a radiogroup, the rowkey of the selected radiobutton element within the group will
            be returned.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="value" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The value of a radiobutton is TRUE if selected and FALSE if not selected.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onset" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            The onset event will be fired when a radiobutton's value changes to TRUE.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="enablecomponents" type="ComponentRefList">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When the radiobutton is selected, the components (separated with a space)
            in enablecomponents will be enabled. When the radiobutton is deselected
            the components will be disabled.
          </html:p>
          <html:p>
             The disabled setting on the components themselves are overriden when they are used in enabledcomponents.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="TextArea">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/textarea.whlib#TolliumTextArea" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="Placeholder" />
    <xs:attribute name="trimwhitespace" type="xs:boolean" default="true" />

    <xs:attribute name="maxlength" type="xs:integer" default="-1">
      <xs:annotation>
        <xs:documentation>
          <html:p>The maximum number of characters allowed for this text area.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="maxlengthmeasure" type="MaxLengthMeasureMethods" default="characters">
      <xs:annotation>
        <xs:documentation>
          <html:p>The way the number of characters is measured (UTF-8 bytes or Unicode characters).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="showcounter" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, a counter will be shown with the actual number of characters/bytes in the field. This may be useful in conjunction with maxlength.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The text which will be shown in this text area upon opening the screen.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="validationchecks" type="sc:ValidationChecks">
      <xs:annotation>
        <xs:documentation>
          <html:p>A list of checks the entered value must pass.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="wordwrap" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>Wrap long lines. Defaults to true</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RTEBase">
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Required" />
    <xs:attribute name="borders" type="BordersSpacers" default="top bottom left right">
      <xs:annotation>
        <xs:documentation>A space separated list of borders to enable. By default, all borders are enabled</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trimwhitespace" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          If set to true, any whitespace surrounding the submitted value will be removed. The following is considered
          whitespace: whitespace characters, &lt;br&gt; tags, empty container tags (e.g. &lt;p&gt; and &lt;div&gt;).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="showcounter" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, a counter will be shown with a count.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="countmethod" default="plaintext:characters">
      <xs:annotation>
        <xs:documentation>
          Method to count length
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="plaintext:characters"/>
          <xs:enumeration value="plaintext:bytes"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="warnlength" type="xs:nonNegativeInteger">
      <xs:annotation>
        <xs:documentation>
          Length to warn on
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="toplaintextmethod" default="converthtmltoplaintext">
      <xs:annotation>
        <xs:documentation>
          Method to use for conversion to plaintext
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="converthtmltoplaintext"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="warnlengthexceededwarningtid" type="sc:TidPtr">
      <xs:annotation>
        <xs:documentation>
          Alternative tid to use for warnlength exceeded warning. Can only be specified as a tid
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="RichDocument">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/rte.whlib#TolliumRichDocument" />
        <tai:extraparser field="allowwidgettypes" type="allowwidgettypes" target="./s:allowwidgettype" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="RTEBase">
        <xs:sequence>
          <xs:element name="allowwidgettype" type="sc:AllowWidgetType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="rtdtype" type="xs:anyURI">
          <xs:annotation>
            <xs:documentation>Namespace of rtdtype which defines allowed styling and widgets</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="contentareawidth" type="PixelWidth">
          <xs:annotation>
            <xs:documentation>Override the width of the content area</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="margins" type="sc:RTDMargins">
          <xs:annotation>
            <xs:documentation>Set the horizontal margins. If the contentareawidth is unknown, the margins will always be considered to be 'none'</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="RichDocumentTypes" default="richdocument">
          <xs:annotation>
            <xs:documentation>The editor to use. Possible types are "richdocument" and "pageeditor".</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RichArea">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/rte.whlib#TolliumRichArea" />
        <tai:extraparser field="linkhandlers" type="bodynode" target="./s:linkhandlers" />
      </xs:appinfo>
    </xs:annotation>

    <xs:complexContent>
      <xs:extension base="RTEBase">
        <xs:sequence>
          <xs:element ref="linkhandlers" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
        <xs:attribute name="type" type="RichAreaTypes" default="html">
          <xs:annotation>
            <xs:documentation>The type of content to edit. Possible types are "html", "html-inline", "html-block" and "email".</xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="tagfilter" default="*">
          <xs:annotation>
            <xs:documentation>
             List of allowed tags. If left empty, defaults to all tags relevant for the RichArea type.
                Supported tags are: "BR", "SUB", "SUP", "SPAN", "A-HREF", "IMG", "B", "I", "U", "STRIKE"
                , "P", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "LI", "DL", "DT", "DD", "BLOCKQUOTE", "PRE"
                , "TABLE", "CAPTION", "TBODY", "TR", "TD", "TH"
                , "HTML", "HEAD", "STYLE", "BODY", "TITLE"
            </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string" />
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="RTE">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/rte.whlib#TolliumRTE" />
        <tai:extraparser field="linkhandlers" type="bodynode" target="./s:linkhandlers" />
      </xs:appinfo>
    </xs:annotation>

    <xs:complexContent>
      <xs:extension base="RTEBase">
        <xs:sequence>
          <xs:element ref="linkhandlers" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
        <xs:attribute name="structuredatafile" type="DataFileRef" />
        <xs:attribute name="cssfile" type="DataFileRef" />
        <xs:attribute name="cssfiles" type="DataFileRefs" />
        <xs:attribute name="css" type="xs:string" />
        <xs:attribute name="onplaceholderopen" type="Name" />
        <xs:attribute name="onbuttonclick" type="tc:Handler">
          <xs:annotation>
            <xs:appinfo>
              <tai:callbacksignature arguments="string" />
            </xs:appinfo>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="interceptbuttons" type="StringList" />
        <xs:attribute name="offercustomhyperlink" type="xs:boolean" /> <!-- FIXME obsolete -->
        <xs:attribute name="htmlclass" type="xs:string" />
        <xs:attribute name="bodyclass" type="xs:string" />

        <xs:attribute name="allowformatting" default="all">
          <xs:annotation>
            <xs:appinfo>
              <sc:deprecated>allowformatting doesn't work anymore. Use the tagfilter attribute instead.</sc:deprecated>
            </xs:appinfo>
          </xs:annotation>
          <xs:simpleType>
            <xs:list>
              <xs:simpleType>
                <xs:restriction base="xs:string">
                  <xs:enumeration value="all"/>
                  <xs:enumeration value="bold"/>
                  <xs:enumeration value="italic"/>
                  <xs:enumeration value="underline"/>
                  <xs:enumeration value="color"/>
                  <xs:enumeration value="justify"/>
                  <xs:enumeration value="indent"/>
                  <xs:enumeration value="anchor"/>
                  <xs:enumeration value="image"/>
                  <xs:enumeration value="list"/>
                </xs:restriction>
              </xs:simpleType>
            </xs:list>
          </xs:simpleType>
        </xs:attribute>

        <xs:attribute name="value" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              <html:p>The contents of the editor.</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="type" type="RTETypes" use="required"> <!-- required: experiment to force people to be explicit about the type they want -->
          <xs:annotation>
            <xs:documentation>
              <html:p>The type of content to edit. Possible types are "html", "html-inline", "html-block", "email", "richdocument" and "pageeditor".</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="tagfilter" default="*">
          <xs:annotation>
            <xs:documentation>
              <html:p>List of allowed tags. If left empty, defaults to all tags relevant for the RTE type.
                Supported tags are: "BR", "SUB", "SUP", "SPAN", "A-HREF", "IMG", "B", "I", "U", "STRIKE"
                , "P", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "UL", "OL", "LI", "DL", "DT", "DD", "BLOCKQUOTE", "PRE"
                , "TABLE", "CAPTION", "TBODY", "TR", "TD", "TH"
                , "HTML", "HEAD", "STYLE", "BODY", "TITLE"</html:p>
            </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
            <xs:list itemType="xs:string" />
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:element name="hsvalue">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="block" fragment="components/hsvalue.hsvalue" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="ComposableComponentBase" />
    </xs:complexType>
  </xs:element>

  <xs:complexType name="Iframe">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/iframe.whlib#TolliumIFrame" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attribute name="onclicklink" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="string" />
        </xs:appinfo>
        <xs:documentation>
          Triggered when a link within the iframe is clicked
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="oncallback" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          Triggered when javascripts calls DoCallback. Deprecated
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ondata" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          Deprecated
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="onmessage" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="variant string" />
        </xs:appinfo>
        <xs:documentation>
          Triggered when iframe sends a postMessage.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enablesandbox" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Set to true to enable the iframe sandbox
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sandbox">
      <xs:annotation>
        <xs:documentation>
          List of sandbox attributes, as defined for HTML5 iframes. You need to set enablesandbox to true to actually activate the sandbox
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list itemType="xs:string" />
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="CodeEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/codeedit.whlib#TolliumCodeEdit" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Required" />

    <xs:attribute name="value" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The contents of the sourcecode editor.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="type" type="EditCodeTypes" default="html">
      <xs:annotation>
        <xs:documentation>
          <html:p>The type of content to edit. Possible types are "text", "c", "cpp", "css", "java", "javascript", "html", "php", "sql" and "xml".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="ongutterclick" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="integer" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called when clicked on the gutter, passes the line number (1-based!).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <!-- ADDME - share/base fileedit on file? -->
  <xs:complexType name="FileEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/fileedit.fileedit" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Onchange" />

    <xs:attribute name="onbeforechange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="boolean" arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name a function to call when the contents are about to change.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="maxsize" type="xs:integer" default="-1">
      <xs:annotation>
        <xs:documentation>
          <html:p>The maximum size for the uploaded file, in bytes.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="mimetypes" type="StringList">
      <xs:annotation>
        <xs:documentation>
          <html:p>A space-separated list of mimetypes to allow for the uploaded file. Examples are "image/*" (all image mimetypes), "application/pdf" and "video/mpeg".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="ColorEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/colorpicker.coloredit" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Onchange" />

    <xs:attribute name="type" default="colors_375">
      <xs:annotation>
        <xs:documentation>
          <html:p>The color picker type. Currently the only supported value is 'colors_375', a palette of 375 colors.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="sliders_rgb"/>
          <xs:enumeration value="colors_16"/>
          <xs:enumeration value="colors_375"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="showedit" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          <html:p>If a textedit with the selected color should be shown in the color picker.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Date">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/datetime.whlib#TolliumDateTime" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called if the the date value is changed using the date picker.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="SaveStateValueOnly" />
    <xs:attribute name="cutoffyear" type="xs:integer" default="70">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the entered year is smaller than the cutoff year, 1900 is added, otherwise 2000 is added (set to 0 to
            always add 1900, to 100 to always add 2000, or to -1 to never add a century). Defaults to 70</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="DateTime">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/datetime.whlib#TolliumDateTime" />
      </xs:appinfo>
      <xs:documentation tc:component="readonly">
        <html:p>If set to true, the value of this component will be shown as normal text instead of a date time field.</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />

    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called if the the date value is changed using the date picker.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>The type to use for this date time field. Possible values are "datetime" (default), "date" and "time".
          To check validity of time, use the ValidateValue() method or the invalidtime property.
          (as type "time" may return DEFAULT DATETIME when 00:00 is given as time)</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="datetime"/>
          <xs:enumeration value="date"/>
          <xs:enumeration value="time"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="precision" type="TimePrecision" default="minutes">
      <xs:annotation>
        <xs:documentation>
          <html:p>The precision of the date time field to use. Possible values are "minutes", "seconds" and milliseconds". The
             shown fields will depend on the precision.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="emptyvalue" default="default datetime">
      <xs:annotation>
        <xs:documentation>
          <html:p>The value this field will have when no data is filled in (if not specified, default datetime)</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="default datetime"/>
          <xs:enumeration value="max_datetime"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="cutoffyear" type="xs:integer" default="70">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the entered year is smaller than the cutoff year, 1900 is added, otherwise 2000 is added (set to 0 to
            always add 1900, to 100 to always add 2000, or to -1 to never add a century). Defaults to 70</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: doc -->
    <xs:attribute name="storeutc" type="xs:boolean" />
    <xs:attributeGroup ref="SaveStateValueOnly" />
  </xs:complexType>

  <xs:complexType name="Time">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/timefield.tolliumtime" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />

    <xs:attribute name="precision" type="TimePrecision" default="minutes">
      <xs:annotation>
        <xs:documentation>
          <html:p>The precision of the date time field to use. Possible values are "minutes", "seconds" and milliseconds". The
             shown fields will depend on the precision.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="BrowseServerPath">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/browseserverpath.whlib#TolliumBrowseServerPath" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="Required" />
    <xs:attributeGroup ref="sc:Errorlabel" />

    <xs:attribute name="acceptfiles" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Whether to accept files (default is TRUE)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acceptfolders" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Whether to accept folders (default is TRUE)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="buttontid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="button" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The title of the browse button, leave empty for default text
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="descriptiontid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <!-- FIXME: Doc -->
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="description" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The description in the browse dialog, leave empty for default text
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowmanualedit" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          If TRUE, manual editing of the path is allowed
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" />
  </xs:complexType>

  <!-- ** combobox ** -->
  <xs:complexType name="ComboBox">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/combobox.whlib#TolliumComboBox" />
        <tai:optionsources field="optionsources" type="optionsources" target="./*" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="option" type="TextEditOption" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
    <xs:attributeGroup ref="TextEditBaseAttributes" />
    <xs:attributeGroup ref="Gid" />

    <xs:attribute name="autocomplete" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Is the element able to autocomplete the lines that are filled in, default is set to FALSE
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <!--
    ## Groupings ##
  -->

  <xs:complexType name="Panel">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="mod::tollium/lib/components/panel.whlib#TolliumPanel" /> <!-- FIXME shouldnt need abspath but it breaks siteprofilecomponents.xsd NewTab -->
        <tai:extraparser field="visibleon" type="enableons" target="./s:visibleon" />
        <tai:extraparser field="backgroundimages" type="backgroundimages" target="./s:backgroundimage" />
        <tai:extraparser field="lines" type="lines"
                      target="./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens'
                               or (local-name()!='visibleon'
                                   and local-name()!='backgroundimage'
                                   and local-name()!='acceptdrops'
                                  )]" />
        <tai:acceptdropsparser field="acceptdrops" ondrop_arguments="record string" target="./s:acceptdrops" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="acceptdrops" type="AcceptDrops" minOccurs="0" maxOccurs="1" />
      <xs:element name="visibleon" type="EnableOn" minOccurs="0" maxOccurs="unbounded"/>
      <xs:element ref="backgroundimage" minOccurs="0" maxOccurs="unbounded" />
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="BodyOrRowNode" />
    </xs:sequence>
    <xs:attributeGroup ref="PanelAttributes" />
  </xs:complexType>

  <!-- The panel attributes that can also be used on <inlineblock> elements -->
  <xs:attributeGroup name="InlineBlockAttributes">
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="Layout" />

    <xs:attribute name="backgroundcolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define the background color for this panel. Use HTML-like color codes for this, like "#33FFCC".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="borders" type="BordersSpacers">
      <xs:annotation>
        <xs:documentation>A space separated list of borders to enable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="PanelAttributes">
    <xs:attributeGroup ref="InlineBlockAttributes" />
    <xs:attributeGroup ref="Gid" />

    <xs:attribute name="border">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>border has been ignored since WH 4.03, we now use borders</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="spacers" type="BordersSpacers" default="default">
      <xs:annotation>
        <xs:documentation>A space separated list of spacers to enable. If not set, a non-leftmost grid cell will enable its left spacer, and tab pages will enable all spacers (unless inside a server tab)</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="vscroll" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, this panel will be rendered with a vertical scroll bar.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="Split">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/split.whlib#TolliumSplit" />
        <tai:childcomponents field="children" target="./s:part" adoptfields="height width minheight minwidth" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="part" minOccurs="0" maxOccurs="unbounded" type="Panel" />
    </xs:sequence>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="Gid" />
    <xs:attribute name="type" use="required" type="sc:HVOrientation">
      <xs:annotation>
        <xs:documentation>The type (orientation) for this split component. Possible values are "horizontal" (a vertical bar between
             its parts) and "vertical" (a horizontal bar between its parts).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="splitter">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="transparent"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Wizard">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/wizard.whlib#TolliumWizard" />
        <tai:childcomponents field="pages" target="./s:page" adoptfields="oninit onnext isfinish" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="page" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>

    <xs:attributeGroup ref="ComponentBase" />

    <xs:attribute name="hidecancel" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            If set to true, the wizard will be rendered without a cancel button.
            The close button and escape key will still continue to work.

            (FIXME: so what's the use of this feature??)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="tab">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="Panel">
          <xs:attributeGroup ref="sc:TidOrTitle" />
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="Tabs">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/tabs.whlib#TolliumTabs" />
        <tai:childcomponents field="line" target="./s:line/*" /><!-- Match all elements within <line> -->
        <tai:childcomponents field="pages" target="./s:tab" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element ref="line" minOccurs="0" maxOccurs="1" /><!-- Only allows inline items -->
      <xs:element ref="tab" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="Gid" />
    <xs:attribute name="selectedtab" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the tab to show as the default tab (upon loading the screen). By default, this is the first tab.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function to use from the accompanying library when the user selects one of the tabs.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="type" default="regular">
      <xs:annotation>
        <xs:documentation>
          <html:p>The type of this tab. Possible values are "regular" (default), "server" (invisible tabs) and "stacked"
             (vertical tabs).</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="regular"/>
          <xs:enumeration value="server"/>
          <xs:enumeration value="stacked"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="savestate">
      <xs:annotation>
        <xs:documentation>
          <html:p>Save the tabs properties in the user's registry and restore them upon reopening the window. At the moment the only possible value is "selectedtab".</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="selectedtab"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>

  </xs:complexType>

  <xs:element name="newtab" type="NewTab" />

  <xs:complexType name="NewTab">
    <xs:complexContent>
      <xs:extension base="Panel">
        <xs:attributeGroup ref="sc:TidOrTitle" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Box">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" fragment="components/boxheading.box" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Panel">
        <xs:attributeGroup ref="IsComposable" />
        <xs:attributeGroup ref="tc:IsDirtyable" />
        <xs:attributeGroup ref="Onchange" />
        <xs:attributeGroup ref="sc:TidOrTitle" />
        <xs:attribute name="checkbox" type="xs:boolean">
          <xs:annotation>
            <xs:documentation>
              <html:p>If set to true, this box will get a checkbox, which can be used to enable and disable components
                 from this box.</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="value" type="xs:boolean">
          <xs:annotation>
            <xs:documentation>
              <html:p>To be used in conjunction with the "checkbox" attribute. If set to true, the checkbox will be checked.</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="enablecomponents" type="ComponentRefList">
          <xs:annotation>
            <xs:documentation>
              <html:p>A space-separated list of component names, which will be enabled/disabled based on the "value" attribute.</html:p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="hr" type="xs:boolean" default="true">
          <xs:annotation>
            <xs:documentation>
              Set to false to suppress the &lt;hr> closing a box
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="Heading">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" fragment="components/boxheading.heading" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="Onchange" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="checkbox" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, this box will get a checkbox, which can be used to enable and disable components
             from this box.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="value" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>To be used in conjunction with the "checkbox" attribute. If set to true, the checkbox will be checked.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="enablecomponents" type="ComponentRefList">
      <xs:annotation>
        <xs:documentation>
          <html:p>A space-separated list of component names, which will be enabled/disabled based on the "value" attribute.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:element name="hr">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="block" objecttype="/lib/components/hr.whlib#TolliumHR" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="ComponentBase" />
    </xs:complexType>
  </xs:element>

  <xs:complexType name="AcceptDropsTypeBase">
    <xs:attribute name="frameflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>>Check these flags on the frame before permitting the drop at all. If these flags flags evaluate to 'true', the action will be enabled. To check if a flag evaluates to 'false' prepand it with !.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="targetflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>Check the flags of the target item in the list. If these flags evaluate to 'true', the action will be enabled. To check if a flag evaluates to 'false' prepend it with !.</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="insertbeforeflags" type="CheckFlags" />
    <xs:attribute name="appendchildflags" type="CheckFlags" />

    <xs:attribute name="locations">
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="ontarget" />
              <xs:enumeration value="position" />
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="requiretarget" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="AcceptDrops">
    <xs:annotation>
      <xs:documentation>
          To make local (within an application) drag &amp; drop working:

          - The type must be activated on a screen using this->RegisterLocalDragType before it will start to work.
          - The row must have a draginfo RECORD
          - The flags being checked in sourceflags must be within the draginfo RECORD

          To make global drag &amp; drop working:
          - Pray that it works
          - Specify in moduledefinition.xml (ADDME: document how)
      </xs:documentation>
      <xs:appinfo>
        <tai:extraparser field="imgsize" type="imgsize" target="." />
      </xs:appinfo>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:element name="accepttype">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AcceptDropsTypeBase">
              <xs:attribute name="type" type="xs:string">
                <xs:annotation>
                  <xs:documentation>
                    Type of item to accept.

                    (FIXME: assumption on have typenames work) The typename should start with an origin (usually the modulename) and semicolon. For example: "mytestmodule:testrow".
                    If dragged rows are only used within the module itself, use local as origin: "local:country".
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>

              <xs:attribute name="sourceflags" type="CheckFlags">
                <xs:annotation>
                  <xs:documentation>
                      Checks the flags (in the draginfo RECORD of the dragged row) of the dragged items of this type.
                      If these flags evaluate to 'true', the action will be enabled.
                      To check if a flag evaluates to 'false' prepend it with !.
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>

              <xs:attribute name="dropeffects">
                <xs:annotation>
                  <xs:documentation>Allowed drop effects (or 'all').</xs:documentation>
                </xs:annotation>
                <xs:simpleType>
                  <xs:list>
                    <xs:simpleType>
                      <xs:restriction base="xs:string">
                        <xs:enumeration value="all" />
                        <xs:enumeration value="move" />
                        <xs:enumeration value="copy" />
                        <xs:enumeration value="link" />
                      </xs:restriction>
                    </xs:simpleType>
                  </xs:list>
                </xs:simpleType>
              </xs:attribute>

              <xs:attribute name="noloops" type="xs:boolean">
                <xs:annotation>
                  <xs:documentation>
                    If enabled, ignore actions that would drop an element on itself, or to a child of itself, by checking whether the dragged element's rowkey is present in the target's element rowkey path
                  </xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
      <xs:element name="acceptfile">
        <xs:complexType>
          <xs:complexContent>
            <xs:extension base="AcceptDropsTypeBase">
              <xs:attributeGroup ref="UploadTypes" />
            </xs:extension>
          </xs:complexContent>
        </xs:complexType>
      </xs:element>
    </xs:choice>
    <xs:attribute name="acceptmultiple" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>Whether multiple items can be dropped at a time.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ondrop" type="Handler">
      <xs:annotation>
        <!-- no callback signature, may vary per location -->
        <xs:documentation>The name of the function from the accompanying library to run to handle drops.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="sc:ImageEditSettings" />
    <xs:attribute name="useimgsizepreset" type="tc:ScreenFragmentReference" />
  </xs:complexType>

  <xs:complexType name="Grid">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/grid.whlib#TolliumGrid" />
        <tai:extraparser field="grid" type="grid" target="./*" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice>
      <xs:element ref="cell" minOccurs="0" maxOccurs="unbounded" />
      <xs:sequence>
        <xs:element name="col" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:attribute name="width" type="Size" />
            <xs:attribute name="minwidth" type="AbsSize" />
          </xs:complexType>
        </xs:element>

        <xs:element name="row" minOccurs="0" maxOccurs="unbounded">
          <xs:complexType>
            <xs:sequence>
              <xs:element ref="cell" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="height" type="VertSize">
              <xs:annotation>
                <xs:documentation>
                  <html:p>Height of the row</html:p>
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
            <xs:attribute name="minheight" type="AbsVertSize">
              <xs:annotation>
                <xs:documentation>
                  The minimum height of the row
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType> <!-- row -->
        </xs:element>

      </xs:sequence>
    </xs:choice>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="Gid" />
  </xs:complexType> <!-- grid -->

  <!--ADDME: I think grid and table can share some code here, but I'm not sure what and how at the moment (Kris) -->
  <xs:complexType name="Table">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/table.whlib#TolliumTable" />
        <tai:acceptdropsparser field="acceptdrops" ondrop_arguments="record record string string" target="./s:acceptdrops" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="acceptdrops" type="AcceptDrops" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
    <xs:attribute name="flags" type="tc:Flags" />

    <xs:attributeGroup ref="ComponentBase" />

    <xs:attribute name="defaultborder" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>Must there be a default border on the table? Options: TRUE, FALSE  (FIXME: this is the border value to apply to each cell?)</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="overlaycontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="cellcontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="onoverlayresize" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="object record string"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            The onoverlayresize event will fire when an editable overlay is resized
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="action" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="openaction" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="contextclickaction" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="selectmode" type="SelectMode" default="none">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="cols" type="Integers">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="colwidth" type="Size">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="colminwidth" type="AbsSize">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="rows" type="Integers">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="rowheight" type="Size">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <!-- FIXME: Doc -->
    <xs:attribute name="rowminheight" type="AbsSize">
      <xs:annotation>
        <xs:documentation>
          <html:p></html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType> <!-- table -->

  <xs:complexType name="Calendar">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/calendar.whlib#TolliumCalendar" />
        <tai:acceptdropsparser field="acceptdrops" ondrop_arguments="record datetime datetime string" target="./s:acceptdrops" />
        <tai:extraparser field="categories" type="array" target="./s:category" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="acceptdrops" type="AcceptDrops" minOccurs="0" maxOccurs="1" />
      <xs:element ref="category" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="flags" type="tc:Flags" />
    <xs:attribute name="startday" type="xs:integer" default="1" />

    <xs:attributeGroup ref="ComponentBase" />

    <xs:attribute name="onloaditems" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="recordarray" arguments="datetime datetime" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function from the accompanying library to use upon loading the calendar.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selectmode" type="SelectMode" default="none">
      <xs:annotation>
        <xs:documentation>
          <html:p>The type of selecting events for this calendar. Possible values are "none" (default), "single"
             and "multiple".</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="storeutc" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to true, the calendar will show datetime's in UTC.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selectcontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the menu to show when right-clicking on events (as defined in a &lt;menu>).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="newcontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the menu to show when right-clicking on an empty cell (as defined in a &lt;menu>).</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="openaction" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>The name of the action from the accompanying library to use when double-clicking on an event.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="weekdayformat" type="xs:string" default="%A">
      <xs:annotation>
        <xs:documentation>
          <html:p>How to render week day names. Defaults to %A.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="monthdayformat" type="xs:string" default="%#d %b">
      <xs:annotation>
        <xs:documentation>
          <html:p>How to render month day names. Defaults to %#d %b.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="type" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>The calendar rendering type. Possible values are "day", "week" and "month". Currently only "week" is supported.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="day"/>
          <xs:enumeration value="week"/>
          <xs:enumeration value="month"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="onchange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function to perform when a change occurs for this component, as defined in the &lt;actions&gt; section.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="showallday" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>Show the all-day events row in the calendar.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="workcolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>Working hours are shown using this color.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="freecolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>Free (non-working) hours are shown using this color.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="weekendcolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>Weekend hours are shown using this color. This color overrides working/free hours on weekend days.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="todaycolor" type="Color">
      <xs:annotation>
        <xs:documentation>
          <html:p>Today's hours are shown using this color. This color overrides all other colors.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workstarttime" type="TimeType">
      <xs:annotation>
        <xs:documentation>
          <html:p>The time at which working hours start, e.g. 9:00. This time is specified in the user's local time, regardless of the storeutc setting.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workendtime" type="TimeType">
      <xs:annotation>
        <xs:documentation>
          <html:p>The time at which working hours end, e.g. 17:00. This time is specified in the user's local time, regardless of the storeutc setting.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="workdays">
      <xs:annotation>
        <xs:documentation>
          <html:p>Days of the week on which working hours are shown. All other days are shown using weekendcolor.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="monday"/>
              <xs:enumeration value="tuesday"/>
              <xs:enumeration value="wednesday"/>
              <xs:enumeration value="thursday"/>
              <xs:enumeration value="friday"/>
              <xs:enumeration value="saturday"/>
              <xs:enumeration value="sunday"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Text">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/text.whlib#TolliumText" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="value" type="xs:string"  />
    <xs:attribute name="valuetid" type="Tid"  />
    <xs:attribute name="action" type="ComponentRef"  />
    <xs:attribute name="onclicklink" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="string" />
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="labelfor" type="ComponentRef"  />
    <xs:attribute name="wordwrap" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to TRUE, the text (value) will be wrapped. (note that this does not wrap the title, but the value!)</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ellipsis" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to TRUE, the text (value) have ellipsis applies. (note that this does apply on the title, but the value!)</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="selectable" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          <html:p>If set to TRUE, the text (value) can be selected. (which is usefull when the user should be able to copy &amp; paste the text)</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attributeGroup ref="Styling" />
  </xs:complexType>

  <xs:complexType name="URL">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="/screens/components/url.xml#tolliumurl" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="value" type="xs:string"  />
  </xs:complexType>

  <xs:complexType name="Slider">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/slider.whlib#TolliumSlider" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />

    <xs:attribute name="orientation" type="sc:HVOrientation">
      <xs:annotation>
        <xs:documentation>
          <html:p>Direction of the slider. Only 'horizontal' is supported at the moment.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onchange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="Money" default="0.0" />
    <xs:attribute name="min" type="Money" default="0.0" />
    <xs:attribute name="max" type="Money" default="100.0" />
    <xs:attribute name="step" type="Money" default="1.0" />
    <xs:attribute name="fill" type="xs:boolean" />
    <xs:attribute name="fillcolor" type="Color" />
    <xs:attribute name="updatecomponent" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>Name of the component in which to show the value of the slider.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TagEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/tagedit.whlib#TolliumTagEdit" />
        <tai:optionsources field="optionsources" type="optionsources" target="./*" />
      </xs:appinfo>
    </xs:annotation>

    <xs:choice minOccurs="0" maxOccurs="1">
      <xs:element ref="autosuggest" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>

    <xs:attributeGroup ref="AutoSuggestableAttributes" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />

    <xs:attribute name="onchange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value" type="xs:string" />
    <xs:attribute name="separator" type="xs:string" default="," />
    <xs:attribute name="allowmultiple" type="xs:boolean" />
    <xs:attribute name="casesensitive" type="xs:boolean" />
    <xs:attributeGroup ref="Placeholder" />

    <xs:attribute name="onvalidatetags" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="stringarray" arguments="stringarray"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called to validate tags before accepting them in the frontend. Return the (filtered) list of allowed tags.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:attributeGroup name="Placeholder">
    <xs:attribute name="placeholder" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>The text to use as placeholder text, which is displayed when nothing is filled in yet, but will not be returned as the textedit's value.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="placeholdertid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <html:p>The tid to use as the placeholder text.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="implicitplaceholder" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Set to false to disable an implicit placeholder generated by the validation checks
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:complexType name="Progress">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/progress.whlib#TolliumProgress" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="value" type="Money" default="0.0" />
    <xs:attribute name="max" type="Money" default="0.0" />
  </xs:complexType>

  <xs:complexType name="Spacer">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/spacer.whlib#TolliumSpacer" />
      </xs:appinfo>
        <xs:documentation>
          <html:p>Creates space between two inline components. Defaults to 1pr width.</html:p>
        </xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="ComponentBase" />
  </xs:complexType>

  <!--
    ## Other ##
  -->

  <xs:simpleType name="DefaultButtonName">
    <xs:restriction base="xs:string">
      <xs:enumeration value="ok" />
      <xs:enumeration value="yes" />
      <xs:enumeration value="yestoall" />
      <xs:enumeration value="no" />
      <xs:enumeration value="cancel" />
      <xs:enumeration value="close" />
    </xs:restriction>
  </xs:simpleType>

  <xs:element name="defaultformbuttons">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="block" objecttype="/lib/components/defaultformbuttons.whlib#TolliumDefaultFormButtons" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="ComponentBase" />
      <xs:attribute name="buttons">
        <xs:simpleType>
          <xs:list itemType="DefaultButtonName" />
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="default" type="DefaultButtonName" />
    </xs:complexType>
  </xs:element>

  <xs:simpleType name="RTETypes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="html">
        <xs:annotation>
          <xs:documentation>
            <html:p>Return the HTML including the HTML tag.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="html-block">
        <xs:annotation>
          <xs:documentation>
            <html:p>Return the HTML content without the surrounding HTML tag</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="html-inline"/>
      <xs:enumeration value="email"/>
      <xs:enumeration value="richdocument"/>
      <xs:enumeration value="pageeditor"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="RichDocumentTypes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="richdocument">
        <xs:annotation>
          <xs:documentation>Edit the full document</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pageeditor">
        <xs:annotation>
          <xs:documentation>Edit specific parts of a page</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="RichAreaTypes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="html">
        <xs:annotation>
          <xs:documentation>
            <html:p>Return the HTML including the HTML tag.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="html-block">
        <xs:annotation>
          <xs:documentation>
            <html:p>Return the HTML content without the surrounding HTML tag</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="html-inline"/>
      <xs:enumeration value="email"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="EditCodeTypes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="text"/><!-- no syntax highlighting -->

      <xs:enumeration value="c"/>
      <xs:enumeration value="cpp"/>
      <xs:enumeration value="css"/>
      <xs:enumeration value="harescript"/>
      <xs:enumeration value="java"/>
      <xs:enumeration value="javascript"/>
      <xs:enumeration value="html"/>
      <xs:enumeration value="php"/>
      <xs:enumeration value="xml"/>
      <xs:enumeration value="sql"/>
    </xs:restriction>
  </xs:simpleType>

  <!--
    ## Select ##
  -->

  <xs:complexType name="Select">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/select.whlib#TolliumSelect" />
        <tai:optionsources field="optionsources" type="optionsources" target="./*" rowkeytypefield="rowkeytype" flagsfield="flags" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded" >
      <xs:element name="option" type="SelectOption" />
      <xs:element ref="diskobjects" />
      <xs:element ref="optionsource" />
      <xs:element name="divider" type="MenuDivider" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
    <xs:attribute name="flags" type="tc:Flags" />
    <xs:attributeGroup ref="Onchange" />
    <xs:attributeGroup ref="RowKeyType" />

    <xs:attribute name="type" use="required">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="checkbox">
            <xs:annotation>
              <xs:documentation>
                <html:p>note: required has no effect on selects with type checkbox</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:enumeration>

          <xs:enumeration value="radio"/>
          <xs:enumeration value="pulldown"/>
          <xs:enumeration value="inlinecheckboxlist" />
          <xs:enumeration value="checkboxlist" />
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="orientation" type="sc:HVOrientation" default="vertical">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Layout direction (only applicable when select type "checkbox" or "radio" is used).
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attributeGroup ref="sc:Errorlabel" />
    <xs:attributeGroup ref="Required" />

    <xs:attributeGroup ref="Gid" />
    <xs:attribute name="optiongid" type="OptionalGid">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When specified, the gid specified in optiongid will be used to translate all options (except if the rowkey is an empty string).<br />
            The optiongid can be relative of absolute like any gid attribute, but is not influenced by the gid on the &lt;select&gt; it's used on.<br />
            <br />
            In contrast to using gid=""/tid="" to translate options, you can use title="" with optiongid="" or use different titles for components while still reusing options.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="emptytid" type="Tid" default="components.select.nooptions" />
    <xs:attribute name="empty" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When there are no options available, this defined text will be shown.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="implicitenablecomponents" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            If set, automatically add components inside an &lt;option&gt; to their enablecomponents. Defaults to true
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="detokenizedvalueseparator" type="xs:string" />
  </xs:complexType>

  <xs:simpleType name="VariableTypes">
    <xs:restriction base="xs:string">
      <xs:enumeration value="string"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="integer64"/>
      <xs:enumeration value="money"/>
      <xs:enumeration value="float"/>
      <xs:enumeration value="datetime"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="SelectOption">
    <xs:choice minOccurs="0" maxOccurs="unbounded">
      <xs:group ref="InlineNode" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
    <xs:attributeGroup ref="sc:TidOrTitle" />
    <xs:attribute name="rowkey" type="xs:string" use="required" />
    <xs:attribute name="selected" type="xs:boolean" />
    <xs:attribute name="flags" type="tc:Flags" />
    <xs:attribute name="enabled" type="xs:boolean" />
    <xs:attributeGroup ref="Icon" />
    <xs:attribute name="indent" type="xs:integer" />
    <xs:attribute name="enablecomponents" type="ComponentRefList" />
    <xs:attribute name="hint" type="xs:string" />
    <xs:attribute name="hinttid" type="Tid" />
    <xs:attribute name="invalidselection" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When the &lt;select&gt; has required="true", any option with invalidselection="true" won't be seen as a valid selection when validating the value.
          </html:p>
        </xs:documentation>
      </xs:annotation>

    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="TextEditOption">
    <xs:attributeGroup ref="sc:TidOrTitle" />
  </xs:complexType>

  <!--
    ## Lists ##
  -->

  <xs:attributeGroup name="GlobalListAttributes">
    <xs:attributeGroup ref="Gid" />

    <xs:attribute name="onfocusin" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>Invoked when this list receives focus</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="columnheaders" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Specifies whether the headers with the column titles must be shown.
            Default is TRUE, the headers will be hidden when set to FALSE.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="flags" type="tc:Flags">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define the list flags here, which will be used by selectableflags and by a droptarget's sourceflags and targetflags.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selectableflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Only rows with these flags set to TRUE will be selectable. Make sure that these flags are specified in the flags property.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="sortable" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>Is the input sortable for the user</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sortascending" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          <html:p>Whether to sort the input ascending</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sortcolumn" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>Column name which the input needs to be sorted</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowselect">
      <xs:annotation>
        <xs:appinfo>
          <sc:deprecated>We always select the whole row since 4.03</sc:deprecated>
        </xs:appinfo>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="icons" type="StringList">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Contains a list of iconnames, separated by a space.
            Each iconname is written in this format: modulename:category/iconname.
            The icon itself must be a PNG picture with the path/filename: modulename/web/img/category/iconname.16x16.png.
            Icons can be used by using the 'iconname'-attribute in a list &lt;column&gt;.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="emptytid" type="Tid">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When the list is empty, the text with the given tid will be shown.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="empty" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When the list is empty, the text defined here will be shown.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowiconname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column containing an index into the icons list for row level icons
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowiconhintname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column containing hint texts for the rowicon
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onselect" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            The onselect event will fire when the selection changes.
            Use selection property to read the selection.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="oncelledit" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="boolean" arguments="record string string"/>
        </xs:appinfo>
        <xs:documentation>The oncelleditevent will fire when a cell with an edittype is modified</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selectevent" type="EventMode" default="asynchronous">
      <xs:annotation>
        <xs:documentation>
          <html:p>
          </html:p>
            The mode in which the select event fires. Asynchronous (the default) will let
            the user continue after a select (smoother interface), but results in
            races when the value of editable components is saved and updated with values
            based off the new selection. Synchronous doesn't have that problem.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="highlightname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column containing the row highlight attribute
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attributeGroup ref="ListBorders" />

  </xs:attributeGroup>

  <xs:attributeGroup name="DynamicListAttributes">
    <xs:attribute name="eventmasks">
      <xs:annotation>
        <xs:documentation>
          Define which events will Invalidate() this list.
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list itemType="xs:string" />
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="ongetpath" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="variant" arguments="variant"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>Defines which function of the screen is used to retrieve list of rowkeys which define the path to the row. The list starts at the row in the root and ends with the rowkey of the node for which the path was requested.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ongetrows" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="recordarray" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Defines which function of the screen is used to get all rows.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ongetchildren" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="recordarray" arguments="record"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>Defines which function of the screen is used to get subnodes of a list row.
             The RECORD with the row for which the subnodes are requested is passed to this function.
             If DEFAULT RECORD is passed, the root level rows are requested.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>


  <xs:attributeGroup name="ArrayListEditButtons">
    <xs:attribute name="showbuttons" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          If set to false, hides the button columns (the actions will still available through the contextmenu)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="buttons" default="add edit delete">
      <xs:annotation>
        <xs:documentation>Space separated list with names of the buttons to show.</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="add"/>
              <xs:enumeration value="edit"/>
              <xs:enumeration value="delete"/>
              <xs:enumeration value="view"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="viewifdisabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>If set, automatically switch to view mode if disabled (without disabling the list)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="ArrayListEditActions">
    <xs:attribute name="addactionoverride" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The action that will be used to add rows.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="editactionoverride" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The action that will be used to edit a row.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deleteactionoverride" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The action that will be used to delete rows.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="ArrayListEditFlags">
    <xs:attribute name="editableflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>Only rows with these flags set to TRUE will be editable</xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="deletableflags" type="CheckFlags">
      <xs:annotation>
        <xs:documentation>Only rows with these flags set to TRUE will be deletable</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="ArrayListEditAttributes">
    <xs:attributeGroup ref="GlobalListAttributes" />
    <xs:attributeGroup ref="tc:IsDirtyable" />
    <xs:attributeGroup ref="ListContextMenus" /><!-- FIXME: experimental for now -->
    <xs:attributeGroup ref="ArrayListEditButtons" />
    <xs:attributeGroup ref="ArrayListEditActions" />
    <xs:attributeGroup ref="ArrayListEditFlags" />

    <xs:attribute name="openaction" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The openaction will be fired when a list item is doubleclicked.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onrowedit" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            Handler used to implement adding/editing rows. By default, the roweditscreen is used
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:attributeGroup>

  <xs:complexType name="ListEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" fragment="components/listedit.listedit" objecttype="/lib/components/listedit.whlib#ListEdit" />
        <tai:extraparser field="columns" type="listcolumns" target="./s:column|./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens']" />
        <tai:extraparser field="styles" type="liststyles" target="./s:style|./s:layout" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded" >
      <xs:element ref="column" />
      <xs:element ref="style" />
      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
    <xs:attributeGroup ref="ArrayListEditAttributes" />
    <xs:attributeGroup ref="DynamicListAttributes" />
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="IsComposableListener" />
    <xs:attributeGroup ref="RowKeyType" />

    <xs:attribute name="onrowdelete" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            (NOTE: preferable use onmultiplerowdelete instead. Using onrowdelete will revert the selectmode of the list to 'single').<br />
            <br />
            Handler used in case of the user trying to delete a row.
            This can be used to implement your own messagebox and perform direct deletion of data.<br />
            <br />
            (NOTE: unlike the onrowdelete attribute for &lt;ArrayEdit&gt; of ListEdit, this handler does not need to return a BOOLEAN)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onrowsdelete" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="recordarray" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            Handler used in case of the user trying to delete one or more rows.
            This can be used to implement your own messagebox and perform direct deletion of data.<br />
            <br />
            (NOTE: unlike the onrowdelete attribute for &lt;ArrayEdit&gt; of ListEdit, this handler does not need to return a BOOLEAN)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onchangeorder" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="variant"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            The onchangeorder handler will fire when the ordering of rows is changed. It will receive the rowkeys in their new ordering.
            Setting this handler shows and enables the moveup/movedown buttons
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="ArrayEdit">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" fragment="components/listedit.listedit" objecttype="/lib/components/listedit.whlib#ArrayEdit" />
        <tai:extraparser field="columns" type="listcolumns" target="./s:column|./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens']" />
        <tai:extraparser field="styles" type="liststyles" target="./s:style|./s:layout" />
        <tai:extraparser field="rowdatatypes" type="rowdatatypes" target="./s:rowdatatype" />
      </xs:appinfo>
    </xs:annotation>
    <xs:choice minOccurs="0" maxOccurs="unbounded" >
      <xs:element ref="column" />
      <xs:element ref="style" />

      <xs:element name="rowdatatype" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>

          <xs:attributeGroup ref="sc:TidOrTitle">
            <xs:annotation>
              <xs:documentation>
                <html:p>The titel/tid to use for this type in the arrayedit's inbuild add (select type) screen.</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attributeGroup>

          <xs:attribute name="type" type="StringList">
            <xs:annotation>
              <xs:documentation>
                <html:p>The value which the type field must have to use this editscreen.</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>

          <xs:attribute name="screen" type="tc:ScreenFragmentReference" default="">
            <xs:annotation>
              <xs:documentation>
                <html:p>The (row)editscreen to edit this type of data. If no screen is specified, adding a row of this type gives a RECORD containing only the type field (with the cell name as specified in rowtypename and the type of this rowdatatype as value)</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>

        </xs:complexType>
      </xs:element>

      <xs:any namespace="##other" processContents="strict" />
    </xs:choice>
    <xs:attributeGroup ref="ArrayListEditAttributes" />
    <xs:attributeGroup ref="ComposableComponentBase" />
    <xs:attributeGroup ref="sc:Errorlabel" />

    <!-- FIXME: this should be called "onchangeorder" -->
    <xs:attribute name="onchange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>The name of the function to perform when the ordering of rows changes</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onrowdelete" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="boolean" arguments="record" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            (NOTE: preferable use onmultiplerowdelete instead. Using onrowdelete will revert the selectmode of the list to 'single').<br />
            <br />
            Handler used in case of the user trying to delete a row.
            This can be used to implement your own messagebox and perform direct deletion of data.<br />
            <br />
            The returnvalue (boolean) of the function specifies whether the row will be deleted.
            If onrowdelete is specified, the default confirmation messagebox will not be used.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onrowsdelete" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="boolean" arguments="recordarray" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            Handler used in case of the user trying to delete one or more rows.
            This can be used to implement your own messagebox and perform direct deletion of data.<br />
            <br />
            The returnvalue (boolean) of the function specifies whether the row will be deleted.
            If onrowsdelete is specified, the default confirmation messagebox will not be used.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowaddscreen" type="tc:ScreenFragmentReference" default="" />

    <xs:attribute name="roweditscreen" type="tc:ScreenFragmentReference" default="">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Reference to the screen to use to edit a row.
            The editscreen should use a implementation="rowedit" (required for siteprofiles and currently the only supported mode).
            If &lt;rowdatatype&gt;'s are used, the editscreen must be specified in these elements and roweditscreen may not be specified.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowtypename" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column which specifies which type of data that is contained in the row.
            This information is used to determine which roweditscreen to use (which is specified through usage of &lt;rowdatatype&gt;'s').
            (NOTE: the valuetype of the specified field must be a STRING)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="orderable" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Allow the rows to be reordered
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="onmaprows" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="recordarray" arguments="recordarray" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            Handler to preprocess the array value before displaying it as list rows. Can be used to convert/add columns to the list.
            It must return the same number of rows, in their original order
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="minrows" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>Minimum required number of rows.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxrows" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>Maximum allowed number of rows.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>


  <xs:complexType name="List">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/list.whlib#TolliumList" />
        <tai:acceptdropsparser field="acceptdrops" ondrop_arguments="record record string string" target="./s:acceptdrops" />
        <!-- columns matches <s:column> and everything outside our namespace -->
        <tai:extraparser field="columns" type="listcolumns" target="./s:column|./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens']" />
        <tai:extraparser field="styles" type="liststyles" target="./s:style|./s:layout" />
        <tai:extraparser field="rowlayouts" type="listrowlayouts" target="./s:rowlayout" />
        <tai:listrows field="rows" target="./s:row" columnsfield="columns" rowkeytypefield="rowkeytype" rowiconnamefield="rowiconname" flagsfield="flags" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="acceptdrops" type="AcceptDrops" minOccurs="0" maxOccurs="1" />
      <xs:choice minOccurs="0" maxOccurs="unbounded" >
        <xs:element name="column" type="ListColumn" />
        <xs:any namespace="##other" processContents="strict" />
      </xs:choice>
      <xs:element name="rowlayout" type="ListRowLayout" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="style" type="ListStyle" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="row" type="ListRow" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attributeGroup ref="GlobalListAttributes" />
    <xs:attributeGroup ref="DynamicListAttributes" />
    <xs:attributeGroup ref="IsComposableListener" />
    <xs:attributeGroup ref="tc:IsDirtyable" /><!-- Used for select type="checkboxlist" -->
    <xs:attributeGroup ref="RowKeyType" />
    <xs:attributeGroup ref="ListContextMenus" />

    <xs:attribute name="selectmode" type="SelectMode" default="none">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            If selectmode is "none" (default), no row can be selected and the list-&gt;selection will return DEFAULT RECORD.<br />
            If selectmode is "single", only one row can be selected and the list-&gt;selection will return a RECORD.<br />
            If selectmode is "multiple", multiple rows can be selected and the list-&gt;selection will return a RECORD ARRAY.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="class">
      <xs:annotation>
        <xs:documentation>Specify the class for this list, eg 'verticaltabs'</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="verticaltabs"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="oncheck" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record string"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            The name of the function to perform when the value of a checkbox in the list is changed.
            The row and columnname in which the checkbox was checked or unchecked is passed to this function.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="oniconclick" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="record string"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            ADDME
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="openaction" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The openaction will be fired when a list item is doubleclicked.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="dragsingleicon" type="ImageSrc" default="actions/dragsingle">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Specifies the source of the icon which is used as icon under the mousepointer to show one row is being dragged.
            Not used anymore.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dragmultipleicon" type="ImageSrc" default="actions/dragmultiple">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Specifies the source of the icon which is used as icon under the mousepointer to show multiple rows are being dragged.
            Not used anymore.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="rowlayout" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The name of the selected row layout. Omit or leave empty for default row layout
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="savestate">
      <xs:annotation>
        <xs:documentation>
          <html:p>Save the selected list properties in the user's registry and restore them upon reopening the window. At the moment the only possible value is "expanded".</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list>
          <xs:simpleType>
            <xs:restriction base="xs:string">
              <xs:enumeration value="expanded"/>
              <xs:enumeration value="selection"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:list>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="onsortorderchange" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            Called when the user changes the sort column, or whether it is sorted in ascending or descenting order.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:attributeGroup name="RowKeyType">
    <xs:attribute name="rowkeytype">
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="string"/>
          <xs:enumeration value="integer"/>
          <xs:enumeration value="boolean"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="ListContextMenus">
    <xs:attribute name="selectcontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The name of the menu which will be used as context menu when activated on a used row.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="newcontextmenu" type="ComponentRef">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The name of the menu which will be used as context menu when activated on a empty row.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:attributeGroup name="ListColumnBase">
    <xs:attributeGroup ref="tc:ListColumnBase" />
  </xs:attributeGroup>

  <xs:complexType name="ListColumn">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="listcolumn" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="mapping" minOccurs="0" maxOccurs="1">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="mapvalue" minOccurs="1" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="value" use="required" />
                <xs:attribute name="result" />
                <xs:attribute name="resulttid" type="Tid" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>

          <xs:attribute name="sourcetype" use="required">
            <xs:annotation>
              <xs:documentation>
                Expected type as source
              </xs:documentation>
            </xs:annotation>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="boolean"/>
                <xs:enumeration value="string"/>
              </xs:restriction>
            </xs:simpleType>
          </xs:attribute>

        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attributeGroup ref="ListColumnBase" />
    <xs:attributeGroup ref="Gid" />
    <xs:attribute name="optiongid" type="OptionalGid">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When specified, the gid specified in optiongid will be used to translate the values in the column by getting the tid based on "optiongid.rowkey" (except when the rowkey is an empty string).<br />
            The optiongid can be relative of absolute like any gid attribute, but is not influenced by the gid on the &lt;column&gt; it's used on.<br />
            <br />
            Unlike titlefromrowkey="true" (which has a similar function to optiongid), the tid and title attribute don't affect the translation, so they can be freely used to specify the column header.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="collapsedname" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the row cell with alternative data to use, if this row is collapsed
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="titlefromrowkey" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            When true, the column won't show the actual value, but a translation of the value.<br />
            <br />
            The tid used to translate the value in the column will be:<br />
            'column's gid + column's name + - + column's value'.<br />
            A tid specified directly on the column doesn't effect the translation,
            so it can be used the have the header show a different title than
            a select using the same title.
            <br />
            There are a few issues with this attribute:<br />
            - the name doesn't reflect what it does. 'titlefromvalue' would be a much better name, rowkey doesn't have anything to do with what the attribute does.<br />
            - since the column's name is used to translate, there's no way to reuse translations in multiple columns<br />
            - be carefull: renaming a column will require you to update the tid's/name in other places where you reuse the same tid's<br />
            - unlike &lt;select&gt; the column's name is used (select uses it's tid if it's set)
            <br />
            Zie ook<br />
            #433 - gid (of optiongid) voor &lt;select&gt;<br />
            #5831 - bij gebruik vertaling van select options en listcolumn weinig controle over titel van het component
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="type" type="ListColumnType" use="required">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The type of data which will be used in this column.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="tree" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            If set to 'true', this column will show its rows in a tree.<br />
            This means that rows with subnodes will get a '+' or '-' sign in front of the column content
            that can be used to open (expand) and close the subnodes.
          </html:p>
          <html:p>
            If you have subnodes and no column with tree set to 'true', then all subnodes will be hidden.
          </html:p>
          <html:p>
            It is possible to have multiple columns in a tree.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="iconname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Specifies the field in the row which gives the number of the icon to use.
            Icons are numbered by the position in the &lt;list&gt;'s 'icons'-attribute starting with 1.
            (note that these icons never fire oniconclick, use an column with type="icon" if you want to use oniconclick)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="selecticonname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the row cell in which the id of the column icon is placed that must be shown when the row is selected (instead of the normal icon specified in iconname)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="iconoverlayname" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the row cell in which the id of the overlay for the column icon is placed (empty if no icon overlay is present)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="edittype">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            If an edittype is specified the contents of the column can be edited inline using the type specified in edittype.
          </html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value=""/>
          <xs:enumeration value="textedit"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="iconlink" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Whether the icon in this column is clickable for oniconclick (only for columns of type 'icon')
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="storeutc" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Whether the data/datetime stored in the row is stored as UTC, and must be converted to the user's timezone (default: FALSE).
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="decimals" type="xs:integer">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            The number of decimals to show, for money columns (default: 0)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="round" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Set to TRUE to round to the specified number of decimals (default: FALSE)
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="precision" type="TimePrecision" default="minutes">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Precision used to show time/datetime. Possible values: 'minutes', 'seconds', 'milliseconds'. (optional, default: 'minutes')
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="checkboxname" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column that contains the value of the column checkbox for a row. If empty, no checkbox is shown.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="checkboxenabled" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column that specifies whether the column checkbox is enabled in that row. If empty, all checkboxes are enabled.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="checkboxvisible" type="Name">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the column that specifies whether the column checkbox is visible in that row. If empty, all checkboxes are shown.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="align" type="HorizontalAlignment" default="left">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Horizontal alignment of the content within the column.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="style" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            Name of the style to use for this row.
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="show">
      <xs:annotation>
        <xs:documentation>
          <html:p>
            For columns of type 'blobrecord', the field to show, defaults to 'filename'.
          </html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:string">
          <xs:enumeration value="info"/>
          <xs:enumeration value="filename"/>
          <xs:enumeration value="mimetype"/>
          <xs:enumeration value="filesize"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>

    <xs:attribute name="onmapvalue" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature returntype="variant" arguments="variant"/>
        </xs:appinfo>
        <xs:documentation>
          <html:p>
            A function to remap input values to the specified column type
          </html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="emptyvalue" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          <html:p>If the a row contains this value for this column, show an empty field.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="ListStyle">
    <xs:attributeGroup ref="tc:NamedComponent" />
    <xs:attributeGroup ref="Styling" />
  </xs:complexType>

  <xs:simpleType name="ListColumnType">
    <xs:restriction base="xs:string">
      <xs:enumeration value="text"/>
      <xs:enumeration value="icon"/>
      <xs:enumeration value="icons"/>
      <!-- page<xs:enumeration value="image"/> even uitgezet, want werkt nog niet mooi met tollium image references -->
      <xs:enumeration value="date"/>
      <xs:enumeration value="time"/>
      <xs:enumeration value="datetime"/>
      <xs:enumeration value="integer"/>
      <xs:enumeration value="integer64"/>
      <xs:enumeration value="money"/>
      <xs:enumeration value="float"/>
      <xs:enumeration value="email"/>
      <xs:enumeration value="url"/>
      <xs:enumeration value="blobrecord"/>
      <xs:enumeration value="richdocument"/>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="ListRowLayout">
    <xs:sequence>
      <xs:element name="col" minOccurs="1" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="coldef" type="xs:string" />
          <xs:attribute name="combinewithnext" type="xs:boolean" />
        </xs:complexType>
      </xs:element>
      <xs:element name="row" minOccurs="1" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="cell" minOccurs="1" maxOccurs="unbounded">
              <xs:complexType>
                <xs:attribute name="coldef" type="xs:string" />
                <xs:attribute name="colspan" type="xs:integer" />
                <xs:attribute name="rowspan" type="xs:integer" />
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>

      <xs:element name="draglayout" minOccurs="0">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="row" minOccurs="1" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="cell" minOccurs="1" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:attribute name="coldef" type="xs:string" />
                      <xs:attribute name="colspan" type="xs:integer" />
                      <xs:attribute name="rowspan" type="xs:integer" />
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="cols" use="required">
            <xs:simpleType>
              <xs:list itemType="Name" />
            </xs:simpleType>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="Name" use="required" />
  </xs:complexType><!-- end of "list" definition -->



  <xs:complexType name="ListRow">
    <xs:sequence>
      <xs:element name="element" type="ListRowElement" minOccurs="0" maxOccurs="unbounded" />
      <xs:element name="row" type="ListRow" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="rowkey" type="xs:string" />
    <xs:attribute name="selected" type="xs:boolean" />
    <xs:attribute name="expanded" type="xs:boolean" />
    <xs:attribute name="style" type="xs:string" />
  </xs:complexType>

  <xs:complexType name="ListRowElement">
    <xs:attribute name="name" type="Name" use="required"/>
    <xs:attribute name="tid" type="Tid" />
    <xs:attribute name="data" type="xs:string" />
  </xs:complexType>


  <!-- element and constraint definitions -->

  <!-- component nodes. all nodes need to be here for XSD includes to work
  -->

  <xs:element name="autosuggest" type="AutoSuggest" />

  <xs:complexType name="AutoSuggest">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="autosuggest" objecttype="/lib/components/autosuggest.whlib#TolliumAutoSuggestComponent" />
      </xs:appinfo>
    </xs:annotation>

    <xs:attributeGroup ref="Name" />
    <xs:attribute name="suggestobjectname" type="DataFileRef">
      <xs:annotation>
        <xs:documentation>
          Reference to a TolliumAutoSuggestBase-devied object which can resolve the autosuggest reports in the background
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>


  <xs:element name="arrayedit" type="ArrayEdit">
    <xs:unique name="uniquecolumnnames_arrayedit">
      <xs:selector xpath="./s:column" />
      <xs:field xpath="@name" />
    </xs:unique>
  </xs:element>
  <xs:element name="listedit" type="ListEdit">
    <xs:unique name="uniquecolumnnames_listedit">
      <xs:selector xpath="./s:column" />
      <xs:field xpath="@name" />
    </xs:unique>
  </xs:element>
  <xs:element name="box" type="Box"/>
  <xs:element name="browsecustom" type="BrowseCustom" />
  <xs:element name="browseserverpath" type="BrowseServerPath" />
  <xs:element name="button" type="Button" />
  <xs:element name="buttongroup" type="ButtonGroup" />
  <xs:element name="calendar" type="Calendar" />
  <xs:element name="checkbox" type="CheckBox"/>
  <xs:element name="coloredit" type="ColorEdit"/>
  <xs:element name="column" type="ListColumn" /> <!-- FIXME keep this? -->
  <xs:element name="style" type="ListStyle" /> <!-- FIXME keep this? -->
  <xs:element name="codeedit" type="CodeEdit"/>
  <xs:element name="combobox" type="ComboBox"/>
  <xs:element name="date" type="Date"/>
  <xs:element name="datetime" type="DateTime"/>
  <xs:element name="fileedit" type="FileEdit"/>
  <xs:element name="grid" type="Grid" />
  <xs:element name="heading" type="Heading"/>
  <xs:element name="iframe" type="Iframe"/>
  <xs:element name="image" type="Image"/>
  <xs:element name="imgedit" type="ImgEdit"/>
  <xs:element name="imageedit" type="ImageEdit"/>
  <xs:element name="includefragment">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/screenbase.whlib#TolliumFragmentBase" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:attributeGroup ref="ComponentBase" />
      <xs:attribute name="fragment" type="tc:ScreenFragmentReference" use="required" />
    </xs:complexType>
  </xs:element>
  <xs:element name="line" type="Line" />
  <xs:element name="list" type="List">
    <xs:unique name="uniquecolumnnames">
      <xs:selector xpath="./s:column" />
      <xs:field xpath="@name" />
    </xs:unique>
  </xs:element>

  <xs:element name="page"> <!-- FIXME keep this? -->
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="Panel">
          <xs:attribute name="iscompletion" type="xs:boolean">
            <xs:annotation>
              <xs:documentation>
                <html:p>If set to true, any next button that will point to this page will become a "finish" button</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>

          <xs:attribute name="isfinish" type="xs:boolean">
            <xs:annotation>
              <xs:documentation>
                <html:p>If set to true, this page will end the wizard (the "next" button will become a "finish" button
                   on this page, it will call Submit() and close the dialog if Submit() returns true).</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>

          <xs:attribute name="oninit" type="tc:Handler">
            <xs:annotation>
              <xs:appinfo>
                <tai:callbacksignature arguments="record" />
              </xs:appinfo>
              <xs:documentation>
                <html:p><!-- FIXME: Doc --></html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>

          <xs:attribute name="onnext" type="tc:Handler">
            <xs:annotation>
              <xs:appinfo>
                <tai:callbacksignature returntype="boolean" />
              </xs:appinfo>
              <xs:documentation>
                <html:p>The name of the function to use from the accompanying library when the user presses the "next"
                   button on this page.</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <xs:element name="eventlistener" type="EventListener" />
  <xs:element name="callbacklistener" type="CallbackListener" />
  <xs:element name="dirtylistener" type="DirtyListener" />
  <xs:element name="panel" type="Panel" />
  <xs:element name="part" type="Panel" /> <!-- FIXME keep this? -->
  <xs:element name="progress" type="Progress" />
  <xs:element name="radiogroup" type="RadioGroup" />
  <xs:element name="radiobutton" type="RadioButton"/>
  <xs:element name="record" type="Record" />
  <xs:element name="richarea" type="RichArea"/>
  <xs:element name="richdocument" type="RichDocument"/>
  <xs:element name="rte" type="RTE"/>
  <xs:element name="select" type="Select"/>
  <xs:element name="slider" type="Slider" />
  <xs:element name="spacer" type="Spacer"/>
  <xs:element name="split" type="Split"/>
  <xs:element name="table" type="Table" />
  <xs:element name="tabs" type="Tabs"/>
  <xs:element name="tagedit" type="TagEdit"/>
  <xs:element name="text" type="Text"/>
  <xs:element name="textarea" type="TextArea"/>
  <xs:element name="passwordfield" type="PasswordField"/>
  <xs:element name="textedit" type="TextEdit"/>
  <xs:element name="time" type="Time"/>
  <xs:element name="url" type="URL"/>
  <xs:element name="wizard" type="Wizard"/>

  <!-- We need acceptdrops as a global element so p:foldertree (and p:filelist) can accept <acceptdrops>  -->
  <xs:element name="acceptdrops" type="AcceptDrops" />

  <xs:element name="pulldown">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/pulldown.whlib#TolliumPulldown" />
      </xs:appinfo>
    </xs:annotation>
  </xs:element>

  <xs:element name="actions">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" />
        <tai:childcomponents field="actions" target="./*" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:annotation>
        <xs:documentation>
          <html:p>This element groups all individual actions.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:sequence>
        <xs:choice minOccurs="0" maxOccurs="unbounded">
          <xs:element ref="action" />
          <xs:element ref="downloadaction" />
          <xs:element ref="uploadaction" />
          <xs:element ref="imageaction" />
          <xs:element ref="windowopenaction" />
          <xs:element ref="helpaction" />
          <xs:element ref="feedbackaction" />
          <xs:element ref="copyaction" />
          <xs:element ref="forward" />
          <xs:any namespace="##other" processContents="strict" />
        </xs:choice>
      </xs:sequence>

      <xs:attributeGroup ref="Gid" />
    </xs:complexType>
  </xs:element>

  <xs:element name="body" type="Panel">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" objecttype="/lib/components/panel.whlib#TolliumPanel" />
      </xs:appinfo>
    </xs:annotation>
  </xs:element>

  <xs:element name="footer" type="Panel">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" objecttype="/lib/components/panel.whlib#TolliumPanel" />
      </xs:appinfo>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="LinesContainer">
    <xs:annotation>
      <xs:appinfo>
        <tai:extraparser field="lines" type="lines" target="./*" />
      </xs:appinfo>
    </xs:annotation>
    <xs:sequence>
      <xs:group minOccurs="0" maxOccurs="unbounded" ref="BodyOrRowNode" />
    </xs:sequence>
  </xs:complexType>

  <xs:element name="contents" type="Contents" />

  <xs:complexType name="Contents">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="fragment" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="LinesContainer">
        <xs:attributeGroup ref="Gid" />
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <!-- FIXME do we really want cell, body etc to live as 'components' at this level ? -->

  <xs:element name="cell">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="row" objecttype="/lib/components/panel.whlib#TolliumPanel" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="Panel">
          <xs:attribute name="colspan" type="xs:integer">
            <xs:annotation>
              <xs:documentation>
                <html:p>Span between columns, so you can add multiple rows and multiple columns and merge them when neccesary</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="rowspan" type="xs:integer">
            <xs:annotation>
              <xs:documentation>
                <html:p>Span between rows, so you can merge rows together</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="valign" type="VerticalAlignment">
            <xs:annotation>
              <xs:documentation>
                <html:p>Vertical alignment, default is set to middle</html:p>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType> <!-- cell -->
  </xs:element>

  <xs:element name="screen" type="Screen">
  </xs:element>

  <xs:element name="fragment" type="Fragment">
  </xs:element>

  <xs:element name="inlineblock">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" objecttype="/lib/components/inlineblock.whlib#TolliumInlineBlock" />
        <tai:extraparser field="backgroundimages" type="backgroundimages" target="./s:backgroundimage" />
        <tai:extraparser field="lines" type="lines"
                      target="./*[namespace-uri()!='http://www.webhare.net/xmlns/tollium/screens'
                               or (local-name()!='backgroundimage')]" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element ref="backgroundimage" minOccurs="0" maxOccurs="unbounded" />
        <xs:group minOccurs="0" maxOccurs="unbounded" ref="BodyOrRowNode" />
      </xs:sequence>
      <xs:attributeGroup ref="InlineBlockAttributes" />
      <xs:attributeGroup ref="sc:TidOrTitle" />
    </xs:complexType>
  </xs:element>

  <xs:element name="countbadge">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" objecttype="/lib/components/countbadge.whlib#TolliumCountBadge" />
      </xs:appinfo>
    </xs:annotation>
  </xs:element>

  <xs:element name="proxy" type="Proxy">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="action" objecttype="/lib/componentbase.whlib#TolliumProxyComponent" />
      </xs:appinfo>
    </xs:annotation>
  </xs:element>

  <xs:element name="category">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:attribute name="name" type="Name" use="required" />
      <xs:attribute name="color" type="Color" />
    </xs:complexType>
  </xs:element>

  <xs:element name="backgroundimage">
    <!--xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent />
      </xs:appinfo>
    </xs:annotation-->
    <xs:complexType>
      <!-- make this an empty element by defining the content to be complex,
           yet assign no child-elements -->
      <xs:sequence>
      </xs:sequence>
      <xs:attribute name="src" type="xs:string" use="required">
        <xs:annotation>
          <xs:documentation>
            <html:p>Define the background image for this element.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="position">
        <xs:annotation>
          <xs:documentation>
            <html:p>
              Define the background image position for this element. The default value is "center", which will center the
              image both horizontally and vertically. If one of "left" or "right" is specified, it will set the horizontal
              alignment.
              If one of "top" or "bottom" is specified, it will set the vertical alignment. Both horizontal and vertical
              alignment can be given.
            </html:p>
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:list>
            <xs:simpleType>
              <xs:restriction base="xs:string">
                <xs:enumeration value="center" />
                <xs:enumeration value="left" />
                <xs:enumeration value="right" />
                <xs:enumeration value="top" />
                <xs:enumeration value="bottom" />
              </xs:restriction>
            </xs:simpleType>
          </xs:list>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="repeat">
        <xs:annotation>
          <xs:documentation>
            <html:p>
              Define if and how the background image should be repeated. If set to "repeat" (the default value), the image is
              repeated both horizontally and vertically. If set to "repeat-x" or "repeat-y", the image is repeated
              horizontally resp. vertically only. If set to "no-repeat", the image is not repeated.
            </html:p>
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="repeat" />
            <xs:enumeration value="repeat-x" />
            <xs:enumeration value="repeat-y" />
            <xs:enumeration value="no-repeat" />
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="size">
        <xs:annotation>
          <xs:documentation>
            <html:p>cover, contain, auto</html:p>
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="auto" />
            <xs:enumeration value="cover" />
            <xs:enumeration value="contain" />
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="EventListener">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/eventlistener.whlib#TolliumEventListener" />
      </xs:appinfo>
    </xs:annotation>

    <xs:attributeGroup ref="tc:EventListenerBase" />

    <xs:attribute name="masks">
      <xs:annotation>
        <xs:documentation>
          <html:p>Define which events this listener reacts on. If the name matches the mask via a LIKE operation, the onevent callback
             is fired, and then the Invalidate() function is called on the components in the invalidatecomponents list.</html:p>
        </xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:list itemType="xs:string" />
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="CallbackListener">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/callbacklistener.whlib#TolliumCallbackListener" />
      </xs:appinfo>
    </xs:annotation>

    <xs:attributeGroup ref="ComponentBase" />
    <xs:attribute name="oncallback" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature arguments="object" />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called if the callback url is opened.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:attributeGroup name="CanMakeDirty">
    <xs:attributeGroup ref="tc:IsDirtyable" />
  </xs:attributeGroup>

  <xs:complexType name="DirtyListener">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/dirtylistener.whlib#TolliumDirtyListener" />
      </xs:appinfo>
    </xs:annotation>

    <xs:attributeGroup ref="ComponentBase" />
    <xs:attribute name="ondirty" type="tc:Handler">
      <xs:annotation>
        <xs:appinfo>
          <tai:callbacksignature />
        </xs:appinfo>
        <xs:documentation>
          <html:p>Called once if one of the registered fields is marked dirty.</html:p>
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="Proxy">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="composition" objecttype="/lib/components/componentbase.whlib#TolliumProxy" />
      </xs:appinfo>
    </xs:annotation>
    <xs:attributeGroup ref="ComponentBase" />
    <xs:attribute name="passthrough" type="ComponentRef"  />
  </xs:complexType>


  <!-- FIXME: why do we need to define this as element if used as component in another module,
       and complexType + two separate definitions when used in Tollium's screens.xsd ? -->
  <xs:complexType name="BrowseCustom">
  <!--xs:element name="browsecustom"-->
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="inline" fragment="components/browsecustom.browsecustom" />
      </xs:appinfo>
    </xs:annotation>
    <!--xs:complexType-->
      <xs:attributeGroup ref="ComposableComponentBase" />
      <xs:attributeGroup ref="sc:TidOrTitle" />
      <xs:attributeGroup ref="sc:Errorlabel" />
      <xs:attributeGroup ref="Required" />
      <xs:attributeGroup ref="Onchange" />

<!--
      <xs:attribute name="emptyvalue" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            <html:p>The value that will be returned when the textedit isn't filled in. Also, when the value property of
            this textedit is set to this value, the textvalue will become empty.</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
-->
      <xs:attribute name="emptytid" type="Tid" default="components.browsecustom.empty" />
      <xs:attribute name="empty" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            <html:p>
              When the value is the default value for the specified valuetype, this text will be shown
            </html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="onbrowse" type="tc:Handler">
        <xs:annotation>
          <xs:appinfo>
            <tai:callbacksignature returntype="variant" arguments="variant"/>
          </xs:appinfo>
          <xs:documentation>
            <html:p>
              The function which will open the dialog to browse.
              The function must return the new value.
            </html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="onmapvalue" type="tc:Handler">
        <xs:annotation>
          <xs:appinfo>
            <tai:callbacksignature returntype="variant" arguments="variant"/>
          </xs:appinfo>
          <xs:documentation>
            <html:p>
              A function to remap the value to a title. If not used, the value (integer or string) will be shown as title.
            </html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="value" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            <html:p>The default value used</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>

      <xs:attribute name="valuetype" type="sc:HareScriptValueTypes" default="string"><!-- type="VariableTypes"  -->

        <xs:annotation>
          <xs:documentation>
            <html:p>The variable type to use when submitting the value. Default is "string". (almost all variable and array types are possible)</html:p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
  <!--
    </xs:complexType>
  </xs:element>
  -->
  </xs:complexType>


  <xs:group name="ScreenParts">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element ref="screen" />
        <xs:element ref="tabsextension" />
        <xs:element ref="fragment" />
      </xs:choice>
    </xs:sequence>
  </xs:group>

  <xs:attributeGroup name="ListBorders">
    <xs:attribute name="borders" type="BordersSpacers" default="top bottom left right">
      <xs:annotation>
        <xs:documentation>Borders to enable on the list. By default, all borders are enabled</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>

  <xs:element name="diskobjects">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="optionsource" objecttype="/lib/components/diskobjects.whlib#DiskObjects" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="tc:ComponentBase" />
      <xs:attributeGroup ref="tc:IsComposableListener" />
      <xs:attribute name="rowkeyprop" default="name">
        <xs:annotation>
          <xs:documentation>
            Defines which file/folder property is used as option rowkey, one of "name", "resourcepath".
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="name" />
            <xs:enumeration value="resourcepath" />
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="titleprop" default="name">
        <xs:annotation>
          <xs:documentation>
            Defines which file/folder property is used as option title, one of "name", "basename".
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="name" />
            <xs:enumeration value="basename" />
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="show" default="all">
        <xs:annotation>
          <xs:documentation>
            To specify whether "files", "folder", or both ("all") must be used as option.
          </xs:documentation>
        </xs:annotation>
        <xs:simpleType>
          <xs:restriction base="xs:string">
            <xs:enumeration value="all" />
            <xs:enumeration value="files" />
            <xs:enumeration value="folders" />
          </xs:restriction>
        </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="basepath" type="xs:string">
        <xs:annotation>
          <xs:documentation>
            WebHare resource path where we should look for objects
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="showhidden" type="xs:boolean">
        <xs:annotation>
          <xs:documentation>
            If true, show hidden files (starting with ".") too
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
      <xs:attribute name="mask" type="xs:string" default="*">
        <xs:annotation>
          <xs:documentation>
            <p>
              When mask is specified only files/folders with names matching the specified mask will be used as options.
              The mask is case insensitive and its syntax is the same as the LIKE instruction in Harescript.
            </p>

            <p>
              Examples:
              <ul>
                <li>*test* will match all files and folders which have test in their name</li>
              </ul>
            </p>
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="optionsource">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="optionsource" objecttype="/lib/components/optionsource.whlib#TolliumOptionSource" />
        </xs:appinfo>
      </xs:annotation>
      <xs:attributeGroup ref="tc:ComponentBase" />
      <xs:attribute name="ongetoptions" type="tc:Handler" use="required">
        <xs:annotation>
          <xs:appinfo>
            <tai:callbacksignature returntype="record" />
          </xs:appinfo>
          <xs:documentation>
            Callback which generates the options. Must return a RECORD with an 'options' cell
          </xs:documentation>
        </xs:annotation>
      </xs:attribute>
    </xs:complexType>
  </xs:element>

  <xs:element name="linkhandlers">
    <xs:complexType>
      <xs:annotation>
        <xs:appinfo>
          <tai:tolliumcomponent placement="rte" objecttype="/lib/components/linkhandlers.whlib#TolliumLinkHandlers" />
          <tai:extraparser field="linkhandlers" type="linkhandlers" target="./*" />
        </xs:appinfo>
      </xs:annotation>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:any namespace="##other" processContents="strict" />
      </xs:choice>
      <xs:attributeGroup ref="tc:ComponentBase" />
    </xs:complexType>
  </xs:element>

  <xs:element name="emailcontents">
    <xs:annotation>
      <xs:appinfo>
        <tai:tolliumcomponent placement="block" fragment="mod::tollium/screens/components/emailcontents.xml#emailcontents" />
      </xs:appinfo>
    </xs:annotation>
    <xs:complexType>
      <xs:attributeGroup ref="tc:ComponentBase" />
    </xs:complexType>
  </xs:element>

  <!-- TC forwards for backwards compatibility -->
  <xs:simpleType name="ScreenFragmentReference">
    <xs:restriction base="tc:ScreenFragmentReference" />
  </xs:simpleType>


  <!-- appinfo forwards for backwards compatibility -->
  <xs:element name="tolliumcomponent">
    <xs:complexType>
      <xs:complexContent>
        <xs:extension base="tai:__AppinfoTolliumComponent">
          <xs:attribute name="lib" /> <!-- legacy nodes can still refer to lib=... -->
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
  </xs:element>

  <!-- appinfo forwards for backwards compatibility -->
  <xs:element name="tolliumimplementation" type="tai:__AppinfoTolliumImplementation"/>
  <xs:element name="extraparser" type="tai:__AppinfoExtraParser"/>
  <xs:element name="callbacksignature" type="tai:__AppinfoCallbackSignature"/>
  <xs:element name="fixedfield" type="tai:__AppinfoFixedField"/>
  <xs:element name="acceptdropsparser" type="tai:__AppinfoAcceptDropsParser"/>

</xs:schema>
