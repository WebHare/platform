// eslint-disable-next-line @typescript-eslint/no-require-imports
const fs = require("node:fs");

class SkipTypeError extends Error {
}

let lines = [];
for (const arg of process.argv.slice(2))
  lines = lines.concat(fs.readFileSync(arg).toString().split("\n"));

const async_exports = fs.readFileSync(`${__dirname}/wasm-suspending-functions.txt`)
  .toString()
  .split("\n")
  .map(l => l.split("#")[0].trim())
  .filter(l => l);

const keepalive = `__attribute__((used))`;

let outfile =
  `import type { VariableType } from "../modules/system/js/internal/whmanager/hsmarshalling";
export type Ptr = number;
export type StringPtr = Ptr;
export type StringPtrPtr = Ptr;
export type HSVM = number & { type: "hsvm" };
export type HSVM_VariableId = number & { type: "variableid" };
export type HSVM_VariableType = VariableType & { type: "variabletype" };
export type HSVM_ColumnId = number & { type: "columnnameid" };

/* This file is generated by harescript/vm/generate-wasm-interface.js.
   The list of suspending (JSPI) functions (that can reach a EM_ASYNC_JS function)
   is kept in harescript/vm/wasm-suspending-functions.txt. These functions all
   return a Promise in the following interface
*/

export interface WASMModuleInterface {
  // Emscripten exports
  HEAP8:Int8Array;
  HEAP16:Int16Array;
  HEAP32:Int32Array;
  HEAPU8:Uint8Array;
  HEAPU16:Uint16Array;
  HEAPU32:Uint32Array;
  HEAPF32:Float32Array;
  HEAPF64:Float64Array;
  HEAP64:BigInt64Array;
  HEAPU64:BigUint64Array;
   _malloc(size: number): Ptr;
  _free(ptr: Ptr): void;
  ENV: Record<string, string>;

  stringToUTF8(str: string, outptr: Ptr, maxBytesToWrite: number): number;
  lengthBytesUTF8(str: string): number;
  stringToNewUTF8(str: string): Ptr;
  UTF8ToString(str: Ptr, maxlength?: number): string;
  getExceptionMessage(ex: unknown): string;
  getValue(ptr: number, type: string): number;
  setValue(ptr: number, value: unknown, type: string): void;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  addFunction(func: (...args: any[]) => any, signature: string): number;
  removeFunction(idx: number): void;
  Emval: { toHandle(value: unknown): number; toValue(handle: number): unknown };

  // Exports from source
`;
let gotfunc = false;

let curcomment = [];
let curfunction = "";
let incomment = false, infunction = false;
for (let i = 0; i < lines.length; ++i) {
  if (incomment || lines[i].trim().startsWith("/*")) {
    if (!incomment)
      curcomment = [];
    incomment = true;
    curcomment.push(lines[i]);
    if (lines[i].indexOf("*/") !== -1) {
      if (curcomment[0].startsWith(`/***`))
        curcomment = [];
      incomment = false;
    }
    continue;
  }
  if (!lines[i].trim() || lines[i].startsWith("//"))
    continue;

  const isUsed = lines[i].indexOf(keepalive) !== -1;

  if (infunction || isUsed) {
    infunction = true;
    curfunction += ` ${lines[i].replace(keepalive, "")}`;
    if (!lines[i].trim().endsWith(";") || lines[i].trim().endsWith("}"))
      continue;
    const normalized_func = curfunction
      .trim()
      .replace(/(\*|\(|\)|,)/g, " $1 ")
      .replace(/(\[)/g, " $1")
      .replace(/\s+/g, " ");

    try {
      const signature = parseSignature(normalized_func);
      if (gotfunc)
        outfile += `\n`;
      gotfunc = true;

      let comment = curcomment.map(l => `  ${l.trimEnd()}\n`).join("");
      comment = comment.replace(/(@param\s+[^\s]+\s)/g, `$1- `);
      comment = comment.replace(/(@return\s)/g, `@returns - `);
      comment = comment.replace(/(@short\s)/g, ``);
      comment = comment.replace(/(@a\s)/g, ``);
      comment = comment.replace(/(@long\s)/g, ``);

      outfile += comment;
      outfile += `  _${signature.name}(${signature.params.map(s => `${s.name}: ${s.type}`).join(", ")}): ${signature.returntype};\n`;

      console.error(`added ${signature.name}`);

    } catch (e) {
      if (e instanceof SkipTypeError) {
        console.error(`skip ${normalized_func}: `, e.message);
      }
      else
        throw e;
    }
  }

  infunction = false;
  curcomment = [];
  curfunction = "";
}

outfile += `}\n`;
{
  // escape debug code detection
  console.log(outfile);
}

/** @param {string[]} parts - parse the part type
*/
function parseType(parts) {
  const partstr = parts.filter(p => !["const", "struct"].includes(p)).join(" ");
  switch (partstr) {
    case "void": return "void";
    case "void *":
    case "uint8_t *":
    case "uint64_t *":
    case "const void *": return "Ptr";
    case "char *":
    case "const char *": return "StringPtr";
    case "bool":
    case "double":
    case "int":
    case "int32_t":
    case "size_t":
    case "time_t":
    case "unsigned int":
    case "unsigned":
      return "number";
    case "long long int":
      return "bigint";
    case "int *":
    case "unsigned *":
      return "Ptr";
    case "char * *":
    case "char * []":
      return "StringPtrPtr";
    case "HSVM_IOReader":
    case "HSVM_IOWriter":
    case "HSVM_IOEndOfStream":
    case "HSVM_IOClose":
    case "EventCallback":
      return "number";
    case "HSVM_VariableType": return "HSVM_VariableType";
    case "HSVM_VariableId": return "HSVM_VariableId";
    case "HSVM_ColumnId": return "HSVM_ColumnId";
    case "HSVM_VariableType *": return "Ptr";
    case "HSVM_VariableId *": return "Ptr";
    case "HSVM *": return "HSVM";
    case "HSVM_DynamicFunction":
    case "HSVM_RegData *":
    case "HSVM_ObjectMarshallerPtr":
    case "tm *":
    case "std::string *":
    case "template < class A > int":
      throw new SkipTypeError(`skipping signature with type ${JSON.stringify(partstr)}`);
    case "emscripten::EM_VAL": return "number";
    default:
      throw new Error(`Unhandled ${JSON.stringify(partstr)}`);
  }

}

/** @param {string} line - line to parse
*/
function parseSignature(line) {
  if (line.indexOf(` ( * `) !== -1) // callback signature
    throw new SkipTypeError(`skipping signature with callback`);

  const startparts = line.split("(")[0].trim().split(" ");

  const params = line.split("(")[1].split(")")[0].trim().split(",").map(p => p.trim()).filter(p => p).map(p => p.split(" ")).map(p => {
    let name = p.pop();
    if (name === "[]") {
      const pushback = name;
      name = p.pop();
      p.push(pushback);
    }
    if (name === "var")
      name = "variable";

    return { name, type: parseType(p) };
  });

  const name = startparts.pop() || "";

  let returntype = parseType(startparts);
  if (async_exports.includes(name))
    returntype = `Promise<${returntype}>`;

  return {
    name,
    startparts,
    returntype,
    params
  };
}
