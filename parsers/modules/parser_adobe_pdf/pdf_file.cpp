//---------------------------------------------------------------------------
#include <ap/libwebhare/allincludes.h>

//---------------------------------------------------------------------------

#include <blex/crypto.h>
#include <harescript/vm/hsvm_dllinterface.h>
#include "pdf_file.h"
#include <cmath>
#include "pdf_encodings.h"
#include "pdf_name2unicode.h"

#include <cstdlib>

namespace Parsers
{

namespace Adobe
{

namespace PDF
{


static const uint8_t pdf_padbytes[32] = {0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a};

void GetPaddedPDFPassword(std::string const &password, uint8_t *buf)
{
        buf = std::copy(password.begin(), std::min(password.begin() + sizeof(pdf_padbytes),password.end()), buf);
        if (password.size()<32)
            std::copy(pdf_padbytes, pdf_padbytes + sizeof(pdf_padbytes) - password.size(), buf);
}

bool PDFfile::GenerateFileKey(DictObject const &trailer, unsigned revision, unsigned keylength,
                              std::string const &ownerkey, std::string const &userkey,
                              std::string const &userpassword)
{
        /* Algorithm 3.2 from the PDF specification */
        std::string fileid = trailer.GetDictionary()["ID"].GetArray()[0].GetString();

        uint8_t permissionbuf[4], passwordbuf[32], digest_so_far[16];

        GetPaddedPDFPassword(userpassword, passwordbuf);
        Blex::putu32lsb(permissionbuf, permissions);

        /* Steps 1-5,7: MD5(PaddedPassword, O, P, fileid) */
        Blex::MD5 digest;
        digest.Process(passwordbuf, sizeof(passwordbuf));
        digest.Process(ownerkey.data(), ownerkey.size());
        digest.Process(permissionbuf, sizeof(permissionbuf));
        digest.Process(fileid.data(), fileid.size());
        /* FIXME: Step 6: If document metadata is not being encrypted, pass 4 bytes with value 0xFFFFFFFF to the MD5 hash function */
        memcpy(digest_so_far, digest.Finalize(), sizeof(digest_so_far));

        if (revision==3) //Step 8: Rehash digest with itself 50 times
        {
                for (unsigned i=0;i<50;++i)
                    Blex::GetMD5Hash(digest_so_far, sizeof(digest_so_far), digest_so_far);
        }

        if (revision==2)
            file_encryption_key.assign(digest_so_far, digest_so_far + 5);
        else
            file_encryption_key.assign(digest_so_far, digest_so_far + std::min<unsigned>(keylength/8,sizeof(digest_so_far)));

        //We now have the file encryption key, or at least we should. Verify user password by regenerating the user key
        std::vector<uint8_t> testbuffer(32);
        if (revision==2)
        {
                Blex::RC4 decryptor(&file_encryption_key[0], file_encryption_key.size());
                std::copy(pdf_padbytes, pdf_padbytes+32, testbuffer.begin());
                decryptor.CryptBuffer(&testbuffer[0], testbuffer.size());
                return memcmp(&userkey[0], &testbuffer[0], 32) == 0;
        }
        else
        {
                //ADDME: Remove this version and use the commented-out algorithm instead. First add Decrypt functions to PDF reader and Owner-password stuf..
                Blex::MD5 verifydigest; ////MD5(padding,id)
                verifydigest.Process(pdf_padbytes, sizeof(pdf_padbytes));
                verifydigest.Process(fileid.data(), fileid.size());
                memcpy(digest_so_far, verifydigest.Finalize(), sizeof(digest_so_far));

                testbuffer.assign(userkey.begin(), userkey.end());
                for (int i=19;i>=0;--i)
                {
                        uint8_t inkey[sizeof(digest_so_far)];
                        for (unsigned j=0;j<file_encryption_key.size();++j)
                            inkey[j] = file_encryption_key[j] ^ uint8_t(i);
                        Blex::RC4 decryptor(inkey, file_encryption_key.size());
                        decryptor.CryptBuffer(&testbuffer[0], testbuffer.size());
                }
                return memcmp(digest_so_far, &testbuffer[0], 16) == 0;

                /*Take the output from the previous invocation of the
                  RC4 function and pass it as input to a new invocation of the function; use an encryption
                  key generated by taking each byte of the original encryption key (obtained
                  in step 1) and performing an XOR (exclusive or) operation between that
                  byte and the single-byte value of the iteration counter (from 1 to 19). * /
                for (unsigned i=0;i<=19;++i) //note, we combined the first decrypt step with this step
                {
                        uint8_t inkey[sizeof(digest_so_far)];
                        for (unsigned j=0;j<file_encryption_key.size();++j)
                            inkey[j] = file_encryption_key[j] ^ i;

                        RC4 decryptor(inkey, file_encryption_key.size());
                        decryptor.DecryptBuffer(digest_so_far, sizeof(digest_so_far));
                }
                memcpy(&testbuffer[0], digest_so_far, sizeof(digest_so_far));*/
        }
}

void CreateLookupTable(std::vector<uint16_t> &lookup_table, const char **encoding)
{
        // Handle all characters
        for (unsigned i = 0; i < 256; i++)
        {
                // Look through all names
                unsigned j;
                for (j=0; nameToUnicodeTab[j].u != 0; ++j)
                        if (encoding[i] != NULL && strcmp(nameToUnicodeTab[j].name, encoding[i])==0)
                                break;

                lookup_table.push_back(nameToUnicodeTab[j].u);
        }
}

PDFfile::PDFfile(Blex::RandomStream &_stream)
        : version(1, 0)
        , permissions(uint32_t(-1))
        , stream(_stream)
{
        lexer.reset(new Lexer(stream));

        // Initialize encodings (lookup tables)
        CreateLookupTable(unicode_encodings["MacRomanEncoding"], macRomanEncoding);
        CreateLookupTable(unicode_encodings["MacExpertEncoding"], macExpertEncoding);
        CreateLookupTable(unicode_encodings["WinAnsiEncoding"], winAnsiEncoding);
        CreateLookupTable(unicode_encodings["StandardEncoding"], standardEncoding);
        CreateLookupTable(unicode_encodings["ExpertEncoding"], expertEncoding);
        CreateLookupTable(unicode_encodings["SymbolEncoding"], symbolEncoding);
        CreateLookupTable(unicode_encodings["ZapfDingbatsEncoding"], zapfDingbatsEncoding);

        // Determine PDF file version
        DEBUGPRINT("Determining version");

        version = lexer->ParseVersion();
        lexer->SetVersion(version);

        // Locate the last crossreference
        DEBUGPRINT("Looking up last crossreference");
        Blex::FileOffset offset = lexer->GetLastCrossRef();

        DEBUGPRINT("Reading last crossreference");
        trailer = lexer->ParseCrossRef(offset);

        // Go on, untill all cross refs are read
        unsigned iterations=0;
        ObjectPtr dictobject = trailer;
        while (dictobject->GetDictionary().KeyExists("Prev"))
        {
                if(++iterations>512)
                    throw std::runtime_error("Too many iterations reading crossref parts, giving up");
                Blex::FileOffset off = dictobject->GetDictionary()["Prev"].GetNumericInt();
                DEBUGPRINT("Reading next crossreference at " << off);
                dictobject = lexer->ParseCrossRef(off);
        }
        //throw std::runtime_error("blaa");

        // Determine PDF file encryption
        if (trailer->GetDictionary().KeyExists("Encrypt"))
        {
                std::string filter; // Need to declare before getdictionary, BCB exception bug

                Object const& encrypt = trailer->GetDictionary()["Encrypt"];
                filter = encrypt.GetDictionary()["Filter"].GetName();
                if (encrypt.GetDictionary().KeyExists("SubFilter"))
                    filter = "/" + encrypt.GetDictionary()["SubFilter"].GetName();

                if (filter != "Standard")
                    throw std::runtime_error("Cannot encrypt PDF files encrypted with filter : " + filter);

                unsigned keylength=40;
                if (encrypt.GetDictionary().KeyExists("Length"))
                    keylength = (unsigned)encrypt.GetDictionary()["Length"].GetNumericInt();

                unsigned revision = (unsigned)encrypt.GetDictionary()["R"].GetNumericInt();
                std::string ownercode = encrypt.GetDictionary()["O"].GetString();
                std::string usercode = encrypt.GetDictionary()["U"].GetString();
                permissions = (unsigned)encrypt.GetDictionary()["P"].GetNumericInt();
                if (ownercode.size() != 32 || usercode.size() != 32 || revision<2 || revision > 4)
                    throw std::runtime_error("PDF document uses unrecognized encryption settings for the Standard filter");

                if (!GenerateFileKey(trailer->GetDictionary(), revision, keylength,
                                     ownercode, usercode, ""))
                    throw std::runtime_error("PDF document is encrypted and the supplied password was incorrect");

                lexer->SetFileKey(file_encryption_key);
        }

        // Now read the Info tag
        if (trailer->GetDictionary().KeyExists("Info"))
        {
                // Here we can get meta data like Title, Author, etc.
                ReadMetaInfo(trailer->GetDictionary()["Info"]);
        }
}

PDFfile::~PDFfile()
{
        DEBUGPRINT("Deleting PDFfile object");
}

void PDFfile::OpenFile()
{
        // And read the required Root object (FIXME: FAIL if it is missing (and move it to the Constructor so our writefile can also rely on it being checked)
        Object const& root = trailer->GetDictionary()["Root"];

        // See if there is updated version information
        if (root.GetDictionary().KeyExists("Version"))
            lexer->SetVersion(Version(root.GetDictionary()["Version"].GetName()));

        // See if there is a (default) language specified for this document
        if (root.GetDictionary().KeyExists("Lang"))
                meta_info["Lang"] = root.GetDictionary()["Lang"].GetString();
        else
                meta_info["Lang"] = "";

        // Read the required Root Pages object
        root_pagetree.reset(new PageTree(this, root.GetDictionary()["Pages"], 0));

/* Disabled reading bookmarks (destinations), not needed right now, just taking up time
        // Read the document's names dictionary
        if(root.GetDictionary().KeyExists("Names"))
        {
                Object const& names = root.GetDictionary()["Names"];

                // See if we got bookmarks (destinations)
                if(names.GetDictionary().KeyExists("Dests"))
                        destinations.reset(new Destinations(names.GetDictionary()["Dests"]));
        }
*/

        if(root.GetDictionary().KeyExists("Outlines"))
                outline.reset(new Outline(root.GetDictionary()["Outlines"]));
}

void PDFfile::WriteFile(Blex::Stream &_outputstream)
{
        PDFOutputStream pdfout(_outputstream);
        pdfout.WriteDocument(trailer->GetDictionary()["Root"].GetDictionary(), NULL, version);

}

void PDFfile::ReadMetaInfo(Object const& info)
{
        DictObject const& info_dict = info.GetDictionary();

        // Read meta information from the info dictionary
        if(info_dict.KeyExists("Title"))
                meta_info["Title"] = info_dict["Title"].GetString();
        else
                meta_info["Title"] = "";

        if(info_dict.KeyExists("Author"))
                meta_info["Author"] = info_dict["Author"].GetString();
        else
                meta_info["Author"] = "";

        if(info_dict.KeyExists("Subject"))
                meta_info["Subject"] = info_dict["Subject"].GetString();
        else
                meta_info["Subject"] = "";

        if(info_dict.KeyExists("Keywords"))
                meta_info["Keywords"] = info_dict["Keywords"].GetString();
        else
                meta_info["Keywords"] = "";

        if(info_dict.KeyExists("Creator"))
                meta_info["Creator"] = info_dict["Creator"].GetString();
        else
                meta_info["Creator"] = "";

        if(info_dict.KeyExists("Producer"))
                meta_info["Producer"] = info_dict["Producer"].GetString();
        else
                meta_info["Producer"] = "";


        if(info_dict.KeyExists("ModDate"))
                meta_info["ModDate"] = info_dict["ModDate"].GetString();
        else
                meta_info["ModDate"] = "";

        if(info_dict.KeyExists("CreationDate"))
                meta_info["CreationDate"] = info_dict["CreationDate"].GetString();
        else
                meta_info["CreationDate"] = "";
}

std::map<std::string, std::string> PDFfile::GetMetaInfo()
{
        return meta_info;
}

void PDFfile::ParseFonts(Object const &font_dictionary, FontRefs *refs)
{
//        DEBUGPRINT(font_dictionary.GetDictionary());
        // Loop through fonts
        DictObject::RawMap const &dict = font_dictionary.GetDictionary().GetRawMap();
        for (DictObject::RawMap ::const_iterator it = dict.begin(); it != dict.end(); ++it)
        {
                //Look up the font object
                FontDescriptors::iterator itr = fontdescriptors.find(it->second.get());

                if(itr == fontdescriptors.end())
                {
                        FontPtr font;
                        font = FontPtr(Font::LoadFont(this, it->second, *lexer, unicode_encodings));
                        itr = fontdescriptors.insert(std::make_pair(it->second.get(), font)).first;
                }
                refs->insert(std::make_pair(it->first,itr));
        }
}

void PDFfile::ParseXObjects(Page const &page, Object const &xobject_dict)
{
         // Loop through xobjects
        DictObject::RawMap const &dict = xobject_dict.GetDictionary().GetRawMap();
        for (DictObject::RawMap::const_iterator it = dict.begin(); it != dict.end(); ++it)
        {
                if (xobjects.find(it->first) == xobjects.end())
                {
                        // XObject not yet cached, let's parse it
                        xobjects[it->first] = XObjectPtr(XObject::LoadXObject(this, page, it->second, *lexer));
                }
        }
}


OutlineItem::OutlineItem(Object const &object)
{
        title = object.GetDictionary()["Title"].GetString();
        if(object.GetDictionary().KeyExists("Dest"))
        {
                switch(object.GetDictionary()["Dest"].GetType())
                {
                        case type_string:
                        {
                                dest = object.GetDictionary()["Dest"].GetString();
                        } break;
                        case type_name:
                        {
                                dest = object.GetDictionary()["Dest"].GetName();
                        } break;
                        case type_array:
                        {
                                DEBUGPRINT("Not supporting Dest arrays in outline yet");
                        } break;
                        default:
                        {
                                throw std::runtime_error("Unknown Dest type in outline");
                        }
                }
        }

        DictObject const &dict = object.GetDictionary();
        if(!dict.KeyExists("First"))
                return;

        DictObject::RawMap const &rawmap = object.GetDictionary().GetRawMap();
        ObjectPtr item_object = rawmap.find("First")->second;

        while(true)
        {
                outline_items.push_back(OutlineItemPtr(new OutlineItem(*item_object)));

                DictObject::RawMap const &item_rawmap = item_object->GetDictionary().GetRawMap();
                if(item_rawmap.find("Next") == item_rawmap.end())
                        break;
                item_object = item_rawmap.find("Next")->second;
        }
}

Outline::Outline(Object const &object)
{
        DictObject const &dict = object.GetDictionary();
        if(!dict.KeyExists("First"))
                return;

        DictObject::RawMap const &rawmap = object.GetDictionary().GetRawMap();
        ObjectPtr item_object = rawmap.find("First")->second;

        while(true)
        {
                outline_items.push_back(OutlineItemPtr (new OutlineItem(*item_object)));

                DictObject::RawMap const &item_rawmap = item_object->GetDictionary().GetRawMap();
                if(item_rawmap.find("Next") == item_rawmap.end())
                        break;
                item_object = item_rawmap.find("Next")->second;
        }
}

Outline::~Outline()
{
        DEBUGPRINT("Deleting Outline object");
}

Page::Page(PDFfile *_file, Object const &object, size_t _pagenr)
        : file(_file)
        , dict(object.GetDictionary())
        , pagenr(_pagenr)
{
        // Read the resources object
        Object const &resources_object = dict["Resources"];
        DictObject const& resource_dict = resources_object.GetDictionary();

         // Read all fonts
        if (resource_dict.KeyExists("Font"))
                file->ParseFonts(resources_object.GetDictionary()["Font"], &fontrefs);
}

FontPtr Page::GetFont(std::string const &name) const
{
        FontRefs::const_iterator itr = fontrefs.find(name);
        if(itr==fontrefs.end())
            return FontPtr();
        else
            return itr->second->second;
}

void Page::Render(Renderer *renderer) const
{
        Object const &resources_object = dict["Resources"];
        DictObject const& resource_dict = resources_object.GetDictionary();

        // Read External Objects
        if (resource_dict.KeyExists("XObject"))
                file->ParseXObjects(*this, resource_dict.GetDictionary()["XObject"]);

        // Now decode the contents on this page
        if (dict.KeyExists("Contents"))
        {
                Contents contents(*this, dict["Contents"]);
                contents.Render(renderer);
        }
}

PageTree::PageTree(PDFfile *file, Object const &object, size_t _first_pagenr)
        : first_pagenr(_first_pagenr)
        , last_pagenr(_first_pagenr)
{
        // Read the Kids array
        Object const &kids_array = object.GetDictionary()["Kids"];

        // Process each of the items in the Kids array
        for (unsigned idx = 0; idx < kids_array.GetArray().GetLength(); ++idx)
        {
                Object const &kid_object = kids_array.GetArray()[idx];

                // Check the type of kid (can be Pages or Page)
                std::string type = kid_object.GetDictionary()["Type"].GetName();
                if (type == "Pages")
                {
                        // Recursively parse a pages tree
                        PageTreePtr subtree(new PageTree(file, kid_object, last_pagenr));
                        subtrees.push_back(subtree);
                        last_pagenr += subtree->GetNumPages();
                } else if (type == "Page")
                {
                        // Add a new page
                        pages.push_back(PagePtr(new Page(file, kid_object, last_pagenr)));
                        ++last_pagenr;
                } else
                        throw std::runtime_error("Corrupt PDF File: Unknown page type");
        }
}

Page const &PageTree::FindPage(size_t find_pagenr) const
{
        // First start looking in recursive page trees
        for(std::vector<PageTreePtr>::const_iterator i = subtrees.begin(); i != subtrees.end(); ++i)
                if((*i)->HasPage(find_pagenr))
                        return (*i)->FindPage(find_pagenr);

        // Then try to look through our pages
        for(std::vector<PagePtr>::const_iterator i = pages.begin(); i != pages.end(); ++i)
                if((*i)->GetPageNr() == find_pagenr)
                        return (**i);

        // Oh dear
        throw std::runtime_error("Page " + Blex::AnyToString(find_pagenr) + " does not exist");
}

Destinations::Destinations(Object const &object)
{
        ReadDestinations(object);
}

void Destinations::ReadDestinations(Object const &object)
{
        // The destinations are stored in a Name Tree
        if(object.GetDictionary().KeyExists("Kids"))
        {
                // Read the Kids array
                Object const &kids_array = object.GetDictionary()["Kids"];

                // Process each of the items in the Kids array
                for (unsigned idx = 0; idx < kids_array.GetArray().GetLength(); ++idx)
                {
                        // Read destinations in this item
                        ReadDestinations(kids_array.GetArray()[idx]);
                }
        }
        else if(object.GetDictionary().KeyExists("Names"))
        {
                // Read the Names array
                Object const &names_array = object.GetDictionary()["Names"];

                // An array of the form
                //   [key_1 value_1 key_2 value_2 ... key_n value_n]
                for (unsigned idx = 0; idx < names_array.GetArray().GetLength(); idx += 2)
                {
//DEBUGPRINT("Found destination: " << names_array.GetArray()[idx].GetString());
                        dests.push_back(names_array.GetArray()[idx].GetString());
                }
        }
}

} //end namespace PDF
} //end namespace Adobe
} //end namespace Parsers




