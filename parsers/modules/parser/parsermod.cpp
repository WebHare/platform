#include <ap/libwebhare/allincludes.h>


#include <blex/utils.h>
#include <parsers/base/parserinterface.h>
#include <parsers/base/filtering.h>
#include <stack>

namespace Parsers
{

///////////////////////////////////////////////////////////////////////////////
//
// Output management
//


void  WHP_GetDocobjectAnchor(HSVM *vm, HSVM_VariableId id_set)
{
        int32_t objid=HSVM_IntegerGet(vm, HSVM_Arg(0));
        OutputObjectInterface *obj = GetOutputObject(vm,objid);

        std::string anchor;
        if (obj)
            anchor = obj->GetAnchor();

        HSVM_StringSetSTD(vm, id_set, anchor);
}

void WHP_PrintDocObj(HSVM *vm)
{
        int32_t formatid=HSVM_IntegerGet(vm, HSVM_Arg(0));
        int32_t objid=HSVM_IntegerGet(vm, HSVM_Arg(1));

        OutputObjectInterface *obj = GetOutputObject(vm,objid);
        FormattedOutputPtr output = GetFormattedOutput(vm, formatid);
        if (!obj || !output)
            return; //error will be generated by GetOutputObject or GetFormattedOutput

        obj->Send(output);
        output->FlushOutput();
}

bool GetBooleanCell(HSVM *vm, HSVM_VariableId varid, const char *cellname)
{
        HSVM_VariableId cellid = HSVM_RecordGetRef(vm, varid, HSVM_GetColumnId(vm,cellname));
        if (!cellid)
        {
                HSVM_ReportCustomError(vm, (std::string("Cell ") + cellname + " missing").c_str());
                return false;
        }
        return HSVM_BooleanGet(vm, cellid);
}

void ReadFilter(HSVM *vm, HSVM_VariableId filter, StyleSettings *dest)
{
        dest->show_bullets_numbering = GetBooleanCell(vm, filter, "BULLETNUMBERING");
        dest->paragraph_formatting = GetBooleanCell(vm, filter, "PARAGRAPHFORMATTING");
        dest->texteffects = GetBooleanCell(vm, filter, "TEXTEFFECTS");
        dest->subsuper = GetBooleanCell(vm, filter, "SUBSUPER");
        dest->hyperlinks = GetBooleanCell(vm, filter, "HYPERLINKS");
        dest->anchors = GetBooleanCell(vm, filter, "ANCHORS");
        dest->images = GetBooleanCell(vm, filter, "IMAGES");
        dest->tables = GetBooleanCell(vm, filter, "TABLES");
        dest->softbreaks = GetBooleanCell(vm, filter, "SOFTBREAKS");
}

void WHP_PrintOutputObjectWithFilter(HSVM *vm)
{
        int32_t formatid=HSVM_IntegerGet(vm, HSVM_Arg(0));
        int32_t objid=HSVM_IntegerGet(vm, HSVM_Arg(1));

        StyleSettings localoverride;
        ReadFilter(vm, HSVM_Arg(2), &localoverride);

        OutputObjectInterface *obj = GetOutputObject(vm,objid);
        FormattedOutputPtr output = GetFormattedOutput(vm, formatid);
        if (!obj || !output)
            return; //error will be generated by GetOutputObject or GetFormattedOutput

        std::shared_ptr<FilteredOutput> filter (new FilteredOutput(output, localoverride));
        obj->Send(filter);
        output->FlushOutput();
}

void WHP_GetRawText(HSVM *vm, HSVM_VariableId id_set)
{
        int32_t objid=HSVM_IntegerGet(vm, HSVM_Arg(0));
        int32_t maxlen=HSVM_IntegerGet(vm, HSVM_Arg(1));
        bool skip_bulnum=HSVM_BooleanGet(vm, HSVM_Arg(2));

        OutputObjectInterface *obj = GetOutputObject(vm,objid);
        if (!obj)
            return; //error will be generated by GetOutputObject

        std::shared_ptr<RawTextFilter> rawtextreceiver(new RawTextFilter(maxlen,skip_bulnum));
        obj->Send(rawtextreceiver);
        HSVM_StringSetSTD(vm, id_set, rawtextreceiver->GetText());
}

extern "C"
{ typedef DrawLib::BitmapInterface* (*GetCanvasBitmapFunc)(HSVM *, int32_t); }

void WHP_PaintCurrentImage(HSVM *vm)
{
        OutputContext &context = *static_cast<OutputContext*>(HSVM_GetContext(vm,OutputContextId,true));
        if (context.paintfunc.empty())
            return;

        int32_t canvasid=HSVM_IntegerGet(vm,HSVM_Arg(0));
        int32_t startx=HSVM_IntegerGet(vm,HSVM_Arg(1));
        int32_t starty=HSVM_IntegerGet(vm,HSVM_Arg(2));
        int32_t lenx=HSVM_IntegerGet(vm,HSVM_Arg(3));
        int32_t leny=HSVM_IntegerGet(vm,HSVM_Arg(4));

        //Get the canvas exporting function
        Blex::DynamicFunction exportfunc = HSVM_GetModuleDynamicFunction(vm, "whmod_graphics", "HSDRAWLIBINTERFACE_GetCanvasBitmap");
        if (!exportfunc)
        {
                HSVM_ReportCustomError(vm, "Unable to find the bitmap hook in the hsm_whmod_graphics module");
                return;
        }

        //We've found the exporting module! Get the canvas
        GetCanvasBitmapFunc bitmapfunc = reinterpret_cast<GetCanvasBitmapFunc>(exportfunc);
        DrawLib::BitmapInterface *bitmap = (*bitmapfunc)(vm,canvasid);
        if (!bitmap)
        {
                HSVM_ReportCustomError(vm, "Unable to find the bitmap hook in the hsm_whmod_graphics module");
                return;
        }

        //Paint the object
        context.paintfunc.top()(canvasid, bitmap,startx,starty,lenx,leny);
}

void WHP_RegisterCustomParserObject(HSVM *vm, HSVM_VariableId id_set)
{
        OutputContext *context = GetOutputContext(vm);
        if (!context)
        {
                HSVM_ReportCustomError(vm, "Could not initialize parser framework");
                return;
        }

        HSVM_VariableId obj = HSVM_Arg(0);

        std::shared_ptr< CustomOutputObject > coo;
        coo.reset(new CustomOutputObject(vm, obj));
        int32_t id = RegisterOutputObject(vm, coo.get());
        context->custom_objs[id] = coo;
        HSVM_IntegerSet(vm, id_set, id);
}

struct InsertImageCBData
{
        HSVM *vm;
        HSVM_VariableId fptr;
};

HSVM_VariableId GetCheckedCell(HSVM *vm, HSVM_VariableId rec, const char *cellname, unsigned type)
{
        HSVM_VariableId cell = HSVM_RecordGetRef(vm, rec, HSVM_GetColumnId(vm, cellname));
        if (!cell)
            HSVM_ReportCustomError(vm, ("Missing cell '"+std::string(cellname)+"'").c_str());
        else if (HSVM_GetType(vm, cell) != type)
            HSVM_ReportCustomError(vm, ("Cell '"+std::string(cellname)+"' is of the wrong type").c_str());
        return cell;
}



void WHF_RenderImageCB(InsertImageCBData *cbdata, int32_t canvasid, DrawLib::BitmapInterface *, int32_t startx, int32_t starty, int32_t lenx, int32_t leny)
{
        HSVM *vm = cbdata->vm;
        if (HSVM_TestMustAbort(vm))
            return;

        if (HSVM_FunctionPtrExists(vm, cbdata->fptr))
        {
                HSVM_OpenFunctionCall(vm, 5);
                HSVM_IntegerSet(vm, HSVM_CallParam(vm, 0), canvasid);
                HSVM_IntegerSet(vm, HSVM_CallParam(vm, 1), startx);
                HSVM_IntegerSet(vm, HSVM_CallParam(vm, 2), starty);
                HSVM_IntegerSet(vm, HSVM_CallParam(vm, 3), lenx);
                HSVM_IntegerSet(vm, HSVM_CallParam(vm, 4), leny);
                HSVM_CallFunctionPtr(vm, cbdata->fptr, true);
                HSVM_CloseFunctionCall(vm);
        }
}

void WHF_InsertImage(HSVM *vm)
{
        int32_t formatterid = HSVM_IntegerGet(vm, HSVM_Arg(0));
        HSVM_VariableId rec = HSVM_Arg(1);
        FormattedOutputPtr destination = GetFormattedOutput(vm, formatterid);
        if (!destination)
        {
                HSVM_ReportCustomError(vm, "No formatter with that id exists");
                return;
        }
        HSVM_VariableId cell, cell2;

        ImageInfo info;

        cell = GetCheckedCell(vm, rec, "IS_KNOWN_PHOTO", HSVM_VAR_Boolean);
        if (!cell) return;
        info.is_known_photo = HSVM_BooleanGet(vm, cell);

        cell = GetCheckedCell(vm, rec, "LENX", HSVM_VAR_Integer);
        if (!cell) return;
        info.lenx = HSVM_IntegerGet(vm, cell);

        cell = GetCheckedCell(vm, rec, "LENY", HSVM_VAR_Integer);
        if (!cell) return;
        info.leny = HSVM_IntegerGet(vm, cell);

        cell = GetCheckedCell(vm, rec, "ALTTAG", HSVM_VAR_String);
        if (!cell) return;
        info.alttag = HSVM_StringGetSTD(vm, cell);

        cell = GetCheckedCell(vm, rec, "TITLE", HSVM_VAR_String);
        if (!cell) return;
        info.title = HSVM_StringGetSTD(vm, cell);

        cell = GetCheckedCell(vm, rec, "ANIMATED_GIF", HSVM_VAR_Blob);
        if (!cell) return;
        int blobhandle = HSVM_BlobOpen (vm, cell);
        if (blobhandle)
        {
                info.animated_gif.resize(HSVM_BlobOpenedLength(vm, blobhandle));
                if (!info.animated_gif.empty())
                    HSVM_BlobRead (vm, blobhandle, info.animated_gif.size(), &info.animated_gif[0]);
                HSVM_BlobClose (vm, blobhandle);
        }

        cell = GetCheckedCell(vm, rec, "ALIGN", HSVM_VAR_Integer);
        if (!cell) return;
        info.align = HSVM_IntegerGet(vm, cell);

        cell = GetCheckedCell(vm, rec, "UNIQUEID", HSVM_VAR_String);
        if (!cell) return;
        info.uniqueid = HSVM_StringGetSTD(vm, cell);

        cell = GetCheckedCell(vm, rec, "WRAPPING", HSVM_VAR_Record);
        if (!cell) return;

        cell2 = GetCheckedCell(vm, cell, "LEFT", HSVM_VAR_Integer);
        if (!cell2) return;
        info.wrapping.left = HSVM_IntegerGet(vm, cell2);

        cell2 = GetCheckedCell(vm, cell, "RIGHT", HSVM_VAR_Integer);
        if (!cell2) return;
        info.wrapping.right = HSVM_IntegerGet(vm, cell2);

        cell2 = GetCheckedCell(vm, cell, "TOP", HSVM_VAR_Integer);
        if (!cell2) return;
        info.wrapping.top = HSVM_IntegerGet(vm, cell2);

        cell2 = GetCheckedCell(vm, cell, "BOTTOM", HSVM_VAR_Integer);
        if (!cell2) return;
        info.wrapping.bottom = HSVM_IntegerGet(vm, cell2);

        InsertImageCBData data;
        data.vm = vm;
        data.fptr =

        cell = GetCheckedCell(vm, rec, "PAINTER", HSVM_VAR_FunctionPtr);
        if (!cell) return;
        data.fptr = cell;

        info.painter = std::bind(&WHF_RenderImageCB, &data, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6);
        destination->InsertImage(info);
}

} //end namespace Parsers

static void* CreateContext(void *)
{
        return new Parsers::OutputContext;
}
static void DestroyContext(void*, void *context_ptr)
{
        delete static_cast<Parsers::OutputContext*>(context_ptr);
}

int HSVM_ModuleEntryPoint(HSVM_RegData *regdata,void*)
{
        HSVM_RegisterContext (regdata, Parsers::OutputContextId, NULL, &CreateContext, &DestroyContext);
        HSVM_RegisterMacro   (regdata, "PRINTPARSEROBJECT:PARSER::II",Parsers::WHP_PrintDocObj);
        HSVM_RegisterMacro   (regdata, "PRINTFILTEREDPARSEROBJECT:PARSER::IIR",Parsers::WHP_PrintOutputObjectWithFilter);
        HSVM_RegisterFunction(regdata, "GETPARSEROBJECTANCHOR:PARSER:S:I",Parsers::WHP_GetDocobjectAnchor);
        HSVM_RegisterFunction(regdata, "__PUBLISHER_GETPARSEROBJECTRAWTEXT:PARSER:S:IIB",Parsers::WHP_GetRawText);
        HSVM_RegisterMacro   (regdata, "__PUBLISHER_PAINTCURRENTIMAGE:PARSER::IIIII",Parsers::WHP_PaintCurrentImage);
        HSVM_RegisterFunction(regdata, "__PUBLISHER_REGISTERCUSTOMPARSEROBJECT:PARSER:I:O",Parsers::WHP_RegisterCustomParserObject);
        HSVM_RegisterMacro   (regdata, "__PUBLISHER_OUTPUT_INSERTIMAGE:PARSER::IR",Parsers::WHF_InsertImage);
        return 1;
}
